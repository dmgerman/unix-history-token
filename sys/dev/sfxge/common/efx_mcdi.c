begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MCDI
end_if

begin_comment
comment|/*  * There are three versions of the MCDI interface:  *  - MCDIv0: Siena BootROM. Transport uses MCDIv1 headers.  *  - MCDIv1: Siena firmware and Huntington BootROM.  *  - MCDIv2: EF10 firmware (Huntington/Medford) and Medford BootROM.  *            Transport uses MCDIv2 headers.  *  * MCDIv2 Header NOT_EPOCH flag  * ----------------------------  * A new epoch begins at initial startup or after an MC reboot, and defines when  * the MC should reject stale MCDI requests.  *  * The first MCDI request sent by the host should contain NOT_EPOCH=0, and all  * subsequent requests (until the next MC reboot) should contain NOT_EPOCH=1.  *  * After rebooting the MC will fail all requests with NOT_EPOCH=1 by writing a  * response with ERROR=1 and DATALEN=0 until a request is seen with NOT_EPOCH=0.  */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_SIENA
end_if

begin_decl_stmt
specifier|static
specifier|const
name|efx_mcdi_ops_t
name|__efx_mcdi_siena_ops
init|=
block|{
name|siena_mcdi_init
block|,
comment|/* emco_init */
name|siena_mcdi_send_request
block|,
comment|/* emco_send_request */
name|siena_mcdi_poll_reboot
block|,
comment|/* emco_poll_reboot */
name|siena_mcdi_poll_response
block|,
comment|/* emco_poll_response */
name|siena_mcdi_read_response
block|,
comment|/* emco_read_response */
name|siena_mcdi_fini
block|,
comment|/* emco_fini */
name|siena_mcdi_feature_supported
block|,
comment|/* emco_feature_supported */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_SIENA */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
operator|||
name|EFSYS_OPT_MEDFORD
end_if

begin_decl_stmt
specifier|static
specifier|const
name|efx_mcdi_ops_t
name|__efx_mcdi_ef10_ops
init|=
block|{
name|ef10_mcdi_init
block|,
comment|/* emco_init */
name|ef10_mcdi_send_request
block|,
comment|/* emco_send_request */
name|ef10_mcdi_poll_reboot
block|,
comment|/* emco_poll_reboot */
name|ef10_mcdi_poll_response
block|,
comment|/* emco_poll_response */
name|ef10_mcdi_read_response
block|,
comment|/* emco_read_response */
name|ef10_mcdi_fini
block|,
comment|/* emco_fini */
name|ef10_mcdi_feature_supported
block|,
comment|/* emco_feature_supported */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON || EFSYS_OPT_MEDFORD */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|enp
operator|->
name|en_family
condition|)
block|{
if|#
directive|if
name|EFSYS_OPT_SIENA
case|case
name|EFX_FAMILY_SIENA
case|:
name|emcop
operator|=
operator|&
name|__efx_mcdi_siena_ops
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* EFSYS_OPT_SIENA */
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
case|case
name|EFX_FAMILY_HUNTINGTON
case|:
name|emcop
operator|=
operator|&
name|__efx_mcdi_ef10_ops
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* EFSYS_OPT_HUNTINGTON */
if|#
directive|if
name|EFSYS_OPT_MEDFORD
case|case
name|EFX_FAMILY_MEDFORD
case|:
name|emcop
operator|=
operator|&
name|__efx_mcdi_ef10_ops
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* EFSYS_OPT_MEDFORD */
default|default:
name|EFSYS_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|enp
operator|->
name|en_features
operator|&
name|EFX_FEATURE_MCDI_DMA
condition|)
block|{
comment|/* MCDI requires a DMA buffer in host memory */
if|if
condition|(
operator|(
name|emtp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|emtp
operator|->
name|emt_dma_mem
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
block|}
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
operator|=
name|emtp
expr_stmt|;
if|if
condition|(
name|emcop
operator|!=
name|NULL
operator|&&
name|emcop
operator|->
name|emco_init
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|emcop
operator|->
name|emco_init
argument_list|(
name|enp
argument_list|,
name|emtp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
block|}
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
operator|=
name|emcop
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator||=
name|EFX_MOD_MCDI
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
operator|=
name|NULL
expr_stmt|;
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
operator|=
name|NULL
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator|&=
operator|~
name|EFX_MOD_MCDI
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|==
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
if|if
condition|(
name|emcop
operator|!=
name|NULL
operator|&&
name|emcop
operator|->
name|emco_fini
operator|!=
name|NULL
condition|)
name|emcop
operator|->
name|emco_fini
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|emip
operator|->
name|emi_port
operator|=
literal|0
expr_stmt|;
name|emip
operator|->
name|emi_aborted
operator|=
literal|0
expr_stmt|;
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
operator|=
name|NULL
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator|&=
operator|~
name|EFX_MOD_MCDI
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_new_epoch
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|int
name|state
decl_stmt|;
comment|/* Start a new epoch (allow fresh MCDI requests to succeed) */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|emip
operator|->
name|emi_new_epoch
operator|=
name|B_TRUE
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|efx_mcdi_send_request
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|void
modifier|*
name|hdrp
parameter_list|,
name|__in
name|size_t
name|hdr_len
parameter_list|,
name|__in
name|void
modifier|*
name|sdup
parameter_list|,
name|__in
name|size_t
name|sdu_len
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|emcop
operator|->
name|emco_send_request
argument_list|(
name|enp
argument_list|,
name|hdrp
argument_list|,
name|hdr_len
argument_list|,
name|sdup
argument_list|,
name|sdu_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|efx_rc_t
name|efx_mcdi_poll_reboot
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|rc
operator|=
name|emcop
operator|->
name|emco_poll_reboot
argument_list|(
name|enp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|efx_mcdi_poll_response
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|boolean_t
name|available
decl_stmt|;
name|available
operator|=
name|emcop
operator|->
name|emco_poll_response
argument_list|(
name|enp
argument_list|)
expr_stmt|;
return|return
operator|(
name|available
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|efx_mcdi_read_response
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|void
modifier|*
name|bufferp
parameter_list|,
name|__in
name|size_t
name|offset
parameter_list|,
name|__in
name|size_t
name|length
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|emcop
operator|->
name|emco_read_response
argument_list|(
name|enp
argument_list|,
name|bufferp
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_request_start
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|,
name|__in
name|boolean_t
name|ev_cpl
parameter_list|)
block|{
if|#
directive|if
name|EFSYS_OPT_MCDI_LOGGING
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
endif|#
directive|endif
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_dword_t
name|hdr
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|hdr_len
decl_stmt|;
name|unsigned
name|int
name|max_version
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
name|unsigned
name|int
name|xflags
decl_stmt|;
name|boolean_t
name|new_epoch
decl_stmt|;
name|int
name|state
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
comment|/* 	 * efx_mcdi_request_start() is naturally serialised against both 	 * efx_mcdi_request_poll() and efx_mcdi_ev_cpl()/efx_mcdi_ev_death(), 	 * by virtue of there only being one outstanding MCDI request. 	 * Unfortunately, upper layers may also call efx_mcdi_request_abort() 	 * at any time, to timeout a pending mcdi request, That request may 	 * then subsequently complete, meaning efx_mcdi_ev_cpl() or 	 * efx_mcdi_ev_death() may end up running in parallel with 	 * efx_mcdi_request_start(). This race is handled by ensuring that 	 * %emi_pending_req, %emi_ev_cpl and %emi_seq are protected by the 	 * en_eslp lock. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_pending_req
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|emip
operator|->
name|emi_pending_req
operator|=
name|emrp
expr_stmt|;
name|emip
operator|->
name|emi_ev_cpl
operator|=
name|ev_cpl
expr_stmt|;
name|emip
operator|->
name|emi_poll_cnt
operator|=
literal|0
expr_stmt|;
name|seq
operator|=
name|emip
operator|->
name|emi_seq
operator|++
operator|&
name|EFX_MASK32
argument_list|(
name|MCDI_HEADER_SEQ
argument_list|)
expr_stmt|;
name|new_epoch
operator|=
name|emip
operator|->
name|emi_new_epoch
expr_stmt|;
name|max_version
operator|=
name|emip
operator|->
name|emi_max_version
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|xflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ev_cpl
condition|)
name|xflags
operator||=
name|MCDI_HEADER_XFLAGS_EVREQ
expr_stmt|;
comment|/* 	 * Huntington firmware supports MCDIv2, but the Huntington BootROM only 	 * supports MCDIv1. Use MCDIv1 headers for MCDIv1 commands where 	 * possible to support this. 	 */
if|if
condition|(
operator|(
name|max_version
operator|>=
literal|2
operator|)
operator|&&
operator|(
operator|(
name|emrp
operator|->
name|emr_cmd
operator|>
name|MC_CMD_CMD_SPACE_ESCAPE_7
operator|)
operator|||
operator|(
name|emrp
operator|->
name|emr_in_length
operator|>
name|MCDI_CTL_SDU_LEN_MAX_V1
operator|)
operator|)
condition|)
block|{
comment|/* Construct MCDI v2 header */
name|hdr_len
operator|=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_8
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|,
name|MCDI_HEADER_CODE
argument_list|,
name|MC_CMD_V2_EXTN
argument_list|,
name|MCDI_HEADER_RESYNC
argument_list|,
literal|1
argument_list|,
name|MCDI_HEADER_DATALEN
argument_list|,
literal|0
argument_list|,
name|MCDI_HEADER_SEQ
argument_list|,
name|seq
argument_list|,
name|MCDI_HEADER_NOT_EPOCH
argument_list|,
name|new_epoch
condition|?
literal|0
else|:
literal|1
argument_list|,
name|MCDI_HEADER_ERROR
argument_list|,
literal|0
argument_list|,
name|MCDI_HEADER_RESPONSE
argument_list|,
literal|0
argument_list|,
name|MCDI_HEADER_XFLAGS
argument_list|,
name|xflags
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_2
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|,
name|MC_CMD_V2_EXTN_IN_EXTENDED_CMD
argument_list|,
name|emrp
operator|->
name|emr_cmd
argument_list|,
name|MC_CMD_V2_EXTN_IN_ACTUAL_LEN
argument_list|,
name|emrp
operator|->
name|emr_in_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Construct MCDI v1 header */
name|hdr_len
operator|=
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_8
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|,
name|MCDI_HEADER_CODE
argument_list|,
name|emrp
operator|->
name|emr_cmd
argument_list|,
name|MCDI_HEADER_RESYNC
argument_list|,
literal|1
argument_list|,
name|MCDI_HEADER_DATALEN
argument_list|,
name|emrp
operator|->
name|emr_in_length
argument_list|,
name|MCDI_HEADER_SEQ
argument_list|,
name|seq
argument_list|,
name|MCDI_HEADER_NOT_EPOCH
argument_list|,
name|new_epoch
condition|?
literal|0
else|:
literal|1
argument_list|,
name|MCDI_HEADER_ERROR
argument_list|,
literal|0
argument_list|,
name|MCDI_HEADER_RESPONSE
argument_list|,
literal|0
argument_list|,
name|MCDI_HEADER_XFLAGS
argument_list|,
name|xflags
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|EFSYS_OPT_MCDI_LOGGING
if|if
condition|(
name|emtp
operator|->
name|emt_logger
operator|!=
name|NULL
condition|)
block|{
name|emtp
operator|->
name|emt_logger
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|EFX_LOG_MCDI_REQUEST
argument_list|,
operator|&
name|hdr
argument_list|,
name|hdr_len
argument_list|,
name|emrp
operator|->
name|emr_in_buf
argument_list|,
name|emrp
operator|->
name|emr_in_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_LOGGING */
name|efx_mcdi_send_request
argument_list|(
name|enp
argument_list|,
operator|&
name|hdr
index|[
literal|0
index|]
argument_list|,
name|hdr_len
argument_list|,
name|emrp
operator|->
name|emr_in_buf
argument_list|,
name|emrp
operator|->
name|emr_in_length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|efx_mcdi_read_response_header
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__inout
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|)
block|{
if|#
directive|if
name|EFSYS_OPT_MCDI_LOGGING
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_LOGGING */
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_dword_t
name|hdr
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|hdr_len
decl_stmt|;
name|unsigned
name|int
name|data_len
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
name|unsigned
name|int
name|cmd
decl_stmt|;
name|unsigned
name|int
name|error
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|emrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|efx_mcdi_read_response
argument_list|(
name|enp
argument_list|,
operator|&
name|hdr
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_len
operator|=
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|,
name|MCDI_HEADER_CODE
argument_list|)
expr_stmt|;
name|seq
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|,
name|MCDI_HEADER_SEQ
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|,
name|MCDI_HEADER_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|MC_CMD_V2_EXTN
condition|)
block|{
name|data_len
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|,
name|MCDI_HEADER_DATALEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|efx_mcdi_read_response
argument_list|(
name|enp
argument_list|,
operator|&
name|hdr
index|[
literal|1
index|]
argument_list|,
name|hdr_len
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_len
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|,
name|MC_CMD_V2_EXTN_IN_EXTENDED_CMD
argument_list|)
expr_stmt|;
name|data_len
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|,
name|MC_CMD_V2_EXTN_IN_ACTUAL_LEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
name|data_len
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* The MC has rebooted since the request was sent. */
name|EFSYS_SPIN
argument_list|(
name|EFX_MCDI_STATUS_SLEEP_US
argument_list|)
expr_stmt|;
name|efx_mcdi_poll_reboot
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|cmd
operator|!=
name|emrp
operator|->
name|emr_cmd
operator|)
operator|||
operator|(
name|seq
operator|!=
operator|(
operator|(
name|emip
operator|->
name|emi_seq
operator|-
literal|1
operator|)
operator|&
name|EFX_MASK32
argument_list|(
name|MCDI_HEADER_SEQ
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Response is for a different request */
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|efx_dword_t
name|err
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|err_len
init|=
name|MIN
argument_list|(
name|data_len
argument_list|,
sizeof|sizeof
argument_list|(
name|err
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|err_code
init|=
name|MC_CMD_ERR_EPROTO
decl_stmt|;
name|int
name|err_arg
init|=
literal|0
decl_stmt|;
comment|/* Read error code (and arg num for MCDI v2 commands) */
name|efx_mcdi_read_response
argument_list|(
name|enp
argument_list|,
operator|&
name|err
argument_list|,
name|hdr_len
argument_list|,
name|err_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_len
operator|>=
operator|(
name|MC_CMD_ERR_CODE_OFST
operator|+
sizeof|sizeof
argument_list|(
name|efx_dword_t
argument_list|)
operator|)
condition|)
name|err_code
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|err
index|[
literal|0
index|]
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_MCDI_V2
if|if
condition|(
name|err_len
operator|>=
operator|(
name|MC_CMD_ERR_ARG_OFST
operator|+
sizeof|sizeof
argument_list|(
name|efx_dword_t
argument_list|)
operator|)
condition|)
name|err_arg
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|err
index|[
literal|1
index|]
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emrp
operator|->
name|emr_err_code
operator|=
name|err_code
expr_stmt|;
name|emrp
operator|->
name|emr_err_arg
operator|=
name|err_arg
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_MCDI_PROXY_AUTH
if|if
condition|(
operator|(
name|err_code
operator|==
name|MC_CMD_ERR_PROXY_PENDING
operator|)
operator|&&
operator|(
name|err_len
operator|==
sizeof|sizeof
argument_list|(
name|err
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * The MCDI request would normally fail with EPERM, but 			 * firmware has forwarded it to an authorization agent 			 * attached to a privileged PF. 			 * 			 * Save the authorization request handle. The client 			 * must wait for a PROXY_RESPONSE event, or timeout. 			 */
name|emrp
operator|->
name|emr_proxy_handle
operator|=
name|err_arg
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_PROXY_AUTH */
if|#
directive|if
name|EFSYS_OPT_MCDI_LOGGING
if|if
condition|(
name|emtp
operator|->
name|emt_logger
operator|!=
name|NULL
condition|)
block|{
name|emtp
operator|->
name|emt_logger
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|EFX_LOG_MCDI_RESPONSE
argument_list|,
operator|&
name|hdr
argument_list|,
name|hdr_len
argument_list|,
operator|&
name|err
argument_list|,
name|err_len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_LOGGING */
if|if
condition|(
operator|!
name|emrp
operator|->
name|emr_quiet
condition|)
block|{
name|EFSYS_PROBE3
argument_list|(
name|mcdi_err_arg
argument_list|,
name|int
argument_list|,
name|emrp
operator|->
name|emr_cmd
argument_list|,
name|int
argument_list|,
name|err_code
argument_list|,
name|int
argument_list|,
name|err_arg
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|efx_mcdi_request_errcode
argument_list|(
name|err_code
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|emrp
operator|->
name|emr_rc
operator|=
literal|0
expr_stmt|;
name|emrp
operator|->
name|emr_out_length_used
operator|=
name|data_len
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_MCDI_PROXY_AUTH
name|emrp
operator|->
name|emr_proxy_handle
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_PROXY_AUTH */
return|return;
name|fail3
label|:
name|fail2
label|:
name|fail1
label|:
name|emrp
operator|->
name|emr_rc
operator|=
name|rc
expr_stmt|;
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|efx_mcdi_finish_response
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|)
block|{
if|#
directive|if
name|EFSYS_OPT_MCDI_LOGGING
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_LOGGING */
name|efx_dword_t
name|hdr
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|hdr_len
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
if|if
condition|(
name|emrp
operator|->
name|emr_out_buf
operator|==
name|NULL
condition|)
return|return;
comment|/* Read the command header to detect MCDI response format */
name|hdr_len
operator|=
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|efx_mcdi_read_response
argument_list|(
name|enp
argument_list|,
operator|&
name|hdr
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|hdr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|0
index|]
argument_list|,
name|MCDI_HEADER_CODE
argument_list|)
operator|==
name|MC_CMD_V2_EXTN
condition|)
block|{
comment|/* 		 * Read the actual payload length. The length given in the event 		 * is only correct for responses with the V1 format. 		 */
name|efx_mcdi_read_response
argument_list|(
name|enp
argument_list|,
operator|&
name|hdr
index|[
literal|1
index|]
argument_list|,
name|hdr_len
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_len
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emrp
operator|->
name|emr_out_length_used
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|,
name|MC_CMD_V2_EXTN_IN_ACTUAL_LEN
argument_list|)
expr_stmt|;
block|}
comment|/* Copy payload out into caller supplied buffer */
name|bytes
operator|=
name|MIN
argument_list|(
name|emrp
operator|->
name|emr_out_length_used
argument_list|,
name|emrp
operator|->
name|emr_out_length
argument_list|)
expr_stmt|;
name|efx_mcdi_read_response
argument_list|(
name|enp
argument_list|,
name|emrp
operator|->
name|emr_out_buf
argument_list|,
name|hdr_len
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_MCDI_LOGGING
if|if
condition|(
name|emtp
operator|->
name|emt_logger
operator|!=
name|NULL
condition|)
block|{
name|emtp
operator|->
name|emt_logger
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|EFX_LOG_MCDI_RESPONSE
argument_list|,
operator|&
name|hdr
argument_list|,
name|hdr_len
argument_list|,
name|emrp
operator|->
name|emr_out_buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_LOGGING */
block|}
end_function

begin_function
name|__checkReturn
name|boolean_t
name|efx_mcdi_request_poll
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
comment|/* Serialise against post-watchdog efx_mcdi_ev* */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_pending_req
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
operator|!
name|emip
operator|->
name|emi_ev_cpl
argument_list|)
expr_stmt|;
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
comment|/* Check for reboot atomically w.r.t efx_mcdi_request_start */
if|if
condition|(
name|emip
operator|->
name|emi_poll_cnt
operator|++
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_poll_reboot
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Reboot/Assertion */
if|if
condition|(
name|rc
operator|==
name|EIO
operator|||
name|rc
operator|==
name|EINTR
condition|)
name|efx_mcdi_raise_exception
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
block|}
comment|/* Check if a response is available */
if|if
condition|(
name|efx_mcdi_poll_response
argument_list|(
name|enp
argument_list|)
operator|==
name|B_FALSE
condition|)
block|{
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
comment|/* Read the response header */
name|efx_mcdi_read_response_header
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
comment|/* Request complete */
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
comment|/* Ensure stale MCDI requests fail after an MC reboot. */
name|emip
operator|->
name|emi_new_epoch
operator|=
name|B_FALSE
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|emrp
operator|->
name|emr_rc
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
name|efx_mcdi_finish_response
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
name|fail2
label|:
if|if
condition|(
operator|!
name|emrp
operator|->
name|emr_quiet
condition|)
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
if|if
condition|(
operator|!
name|emrp
operator|->
name|emr_quiet
condition|)
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|boolean_t
name|efx_mcdi_request_abort
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
decl_stmt|;
name|boolean_t
name|aborted
decl_stmt|;
name|int
name|state
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
comment|/* 	 * efx_mcdi_ev_* may have already completed this event, and be 	 * spinning/blocked on the upper layer lock. So it *is* legitimate 	 * to for emi_pending_req to be NULL. If there is a pending event 	 * completed request, then provide a "credit" to allow 	 * efx_mcdi_ev_cpl() to accept a single spurious completion. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
name|aborted
operator|=
operator|(
name|emrp
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|aborted
condition|)
block|{
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
comment|/* Error the request */
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
name|ETIMEDOUT
expr_stmt|;
comment|/* Provide a credit for seqno/emr_pending_req mismatches */
if|if
condition|(
name|emip
operator|->
name|emi_ev_cpl
condition|)
operator|++
name|emip
operator|->
name|emi_aborted
expr_stmt|;
comment|/* 		 * The upper layer has called us, so we don't 		 * need to complete the request. 		 */
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|aborted
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_request_errcode
parameter_list|(
name|__in
name|unsigned
name|int
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
comment|/* MCDI v1 */
case|case
name|MC_CMD_ERR_EPERM
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
name|MC_CMD_ERR_ENOENT
case|:
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|MC_CMD_ERR_EINTR
case|:
return|return
operator|(
name|EINTR
operator|)
return|;
case|case
name|MC_CMD_ERR_EACCES
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
name|MC_CMD_ERR_EBUSY
case|:
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|MC_CMD_ERR_EINVAL
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MC_CMD_ERR_EDEADLK
case|:
return|return
operator|(
name|EDEADLK
operator|)
return|;
case|case
name|MC_CMD_ERR_ENOSYS
case|:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
case|case
name|MC_CMD_ERR_ETIME
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
case|case
name|MC_CMD_ERR_ENOTSUP
case|:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
case|case
name|MC_CMD_ERR_EALREADY
case|:
return|return
operator|(
name|EALREADY
operator|)
return|;
comment|/* MCDI v2 */
case|case
name|MC_CMD_ERR_EEXIST
case|:
return|return
operator|(
name|EEXIST
operator|)
return|;
ifdef|#
directive|ifdef
name|MC_CMD_ERR_EAGAIN
case|case
name|MC_CMD_ERR_EAGAIN
case|:
return|return
operator|(
name|EAGAIN
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC_CMD_ERR_ENOSPC
case|case
name|MC_CMD_ERR_ENOSPC
case|:
return|return
operator|(
name|ENOSPC
operator|)
return|;
endif|#
directive|endif
case|case
name|MC_CMD_ERR_ALLOC_FAIL
case|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|MC_CMD_ERR_NO_VADAPTOR
case|:
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|MC_CMD_ERR_NO_EVB_PORT
case|:
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|MC_CMD_ERR_NO_VSWITCH
case|:
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
name|MC_CMD_ERR_VLAN_LIMIT
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MC_CMD_ERR_BAD_PCI_FUNC
case|:
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
name|MC_CMD_ERR_BAD_VLAN_MODE
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MC_CMD_ERR_BAD_VSWITCH_TYPE
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MC_CMD_ERR_BAD_VPORT_TYPE
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MC_CMD_ERR_MAC_EXIST
case|:
return|return
operator|(
name|EEXIST
operator|)
return|;
case|case
name|MC_CMD_ERR_PROXY_PENDING
case|:
return|return
operator|(
name|EAGAIN
operator|)
return|;
default|default:
name|EFSYS_PROBE1
argument_list|(
name|mc_pcol_error
argument_list|,
name|int
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|efx_mcdi_raise_exception
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in_opt
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|,
name|__in
name|int
name|rc
parameter_list|)
block|{
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
name|efx_mcdi_exception_t
name|exception
decl_stmt|;
comment|/* Reboot or Assertion failure only */
name|EFSYS_ASSERT
argument_list|(
name|rc
operator|==
name|EIO
operator|||
name|rc
operator|==
name|EINTR
argument_list|)
expr_stmt|;
comment|/* 	 * If MC_CMD_REBOOT causes a reboot (dependent on parameters), 	 * then the EIO is not worthy of an exception. 	 */
if|if
condition|(
name|emrp
operator|!=
name|NULL
operator|&&
name|emrp
operator|->
name|emr_cmd
operator|==
name|MC_CMD_REBOOT
operator|&&
name|rc
operator|==
name|EIO
condition|)
return|return;
name|exception
operator|=
operator|(
name|rc
operator|==
name|EIO
operator|)
condition|?
name|EFX_MCDI_EXCEPTION_MC_REBOOT
else|:
name|EFX_MCDI_EXCEPTION_MC_BADASSERT
expr_stmt|;
name|emtp
operator|->
name|emt_exception
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_execute
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__inout
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
name|emrp
operator|->
name|emr_quiet
operator|=
name|B_FALSE
expr_stmt|;
name|emtp
operator|->
name|emt_execute
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_execute_quiet
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__inout
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
name|emrp
operator|->
name|emr_quiet
operator|=
name|B_TRUE
expr_stmt|;
name|emtp
operator|->
name|emt_execute
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_ev_cpl
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|seq
parameter_list|,
name|__in
name|unsigned
name|int
name|outlen
parameter_list|,
name|__in
name|int
name|errcode
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
comment|/* 	 * Serialise against efx_mcdi_request_poll()/efx_mcdi_request_start() 	 * when we're completing an aborted request. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|emip
operator|->
name|emi_pending_req
operator|==
name|NULL
operator|||
operator|!
name|emip
operator|->
name|emi_ev_cpl
operator|||
operator|(
name|seq
operator|!=
operator|(
operator|(
name|emip
operator|->
name|emi_seq
operator|-
literal|1
operator|)
operator|&
name|EFX_MASK32
argument_list|(
name|MCDI_HEADER_SEQ
argument_list|)
operator|)
operator|)
condition|)
block|{
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_aborted
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|emip
operator|->
name|emi_aborted
operator|>
literal|0
condition|)
operator|--
name|emip
operator|->
name|emi_aborted
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|emip
operator|->
name|emi_max_version
operator|>=
literal|2
condition|)
block|{
comment|/* MCDIv2 response details do not fit into an event. */
name|efx_mcdi_read_response_header
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|emrp
operator|->
name|emr_quiet
condition|)
block|{
name|EFSYS_PROBE2
argument_list|(
name|mcdi_err
argument_list|,
name|int
argument_list|,
name|emrp
operator|->
name|emr_cmd
argument_list|,
name|int
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
block|}
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
name|efx_mcdi_request_errcode
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emrp
operator|->
name|emr_out_length_used
operator|=
name|outlen
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
name|efx_mcdi_finish_response
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
block|}
name|emtp
operator|->
name|emt_ev_cpl
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_MCDI_PROXY_AUTH
end_if

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_proxy_handle
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|handlep
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * Return proxy handle from MCDI request that returned with error 	 * MC_MCD_ERR_PROXY_PENDING. This handle is used to wait for a matching 	 * PROXY_RESPONSE event. 	 */
if|if
condition|(
operator|(
name|emrp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|handlep
operator|==
name|NULL
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|emrp
operator|->
name|emr_rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|emrp
operator|->
name|emr_err_code
operator|==
name|MC_CMD_ERR_PROXY_PENDING
operator|)
condition|)
block|{
operator|*
name|handlep
operator|=
name|emrp
operator|->
name|emr_proxy_handle
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|handlep
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ENOENT
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_ev_proxy_response
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|handle
parameter_list|,
name|__in
name|unsigned
name|int
name|status
parameter_list|)
block|{
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * Handle results of an authorization request for a privileged MCDI 	 * command. If authorization was granted then we must re-issue the 	 * original MCDI request. If authorization failed or timed out, 	 * then the original MCDI request should be completed with the 	 * result code from this event. 	 */
name|rc
operator|=
operator|(
name|status
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|efx_mcdi_request_errcode
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|emtp
operator|->
name|emt_ev_proxy_response
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|handle
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MCDI_PROXY_AUTH */
end_comment

begin_function
name|void
name|efx_mcdi_ev_death
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|int
name|rc
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emtp
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|ev_cpl
decl_stmt|;
name|int
name|state
decl_stmt|;
comment|/* 	 * The MCDI request (if there is one) has been terminated, either 	 * by a BADASSERT or REBOOT event. 	 * 	 * If there is an outstanding event-completed MCDI operation, then we 	 * will never receive the completion event (because both MCDI 	 * completions and BADASSERT events are sent to the same evq). So 	 * complete this MCDI op. 	 * 	 * This function might run in parallel with efx_mcdi_request_poll() 	 * for poll completed mcdi requests, and also with 	 * efx_mcdi_request_start() for post-watchdog completions. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
name|ev_cpl
operator|=
name|emip
operator|->
name|emi_ev_cpl
expr_stmt|;
if|if
condition|(
name|emrp
operator|!=
name|NULL
operator|&&
name|emip
operator|->
name|emi_ev_cpl
condition|)
block|{
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
name|rc
expr_stmt|;
operator|++
name|emip
operator|->
name|emi_aborted
expr_stmt|;
block|}
comment|/* 	 * Since we're running in parallel with a request, consume the 	 * status word before dropping the lock. 	 */
if|if
condition|(
name|rc
operator|==
name|EIO
operator|||
name|rc
operator|==
name|EINTR
condition|)
block|{
name|EFSYS_SPIN
argument_list|(
name|EFX_MCDI_STATUS_SLEEP_US
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_poll_reboot
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|emip
operator|->
name|emi_new_epoch
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|efx_mcdi_raise_exception
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|emrp
operator|!=
name|NULL
operator|&&
name|ev_cpl
condition|)
name|emtp
operator|->
name|emt_ev_cpl
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_version
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount_opt
argument_list|(
literal|4
argument_list|)
name|uint16_t
name|versionp
index|[
literal|4
index|]
argument_list|,
name|__out_opt
name|uint32_t
operator|*
name|buildp
argument_list|,
name|__out_opt
name|efx_mcdi_boot_t
operator|*
name|statusp
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MAX
argument_list|(
name|MC_CMD_GET_VERSION_IN_LEN
argument_list|,
name|MC_CMD_GET_VERSION_OUT_LEN
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|MC_CMD_GET_BOOT_STATUS_IN_LEN
argument_list|,
name|MC_CMD_GET_BOOT_STATUS_OUT_LEN
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|efx_word_t
modifier|*
name|ver_words
decl_stmt|;
name|uint16_t
name|version
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|build
decl_stmt|;
name|efx_mcdi_boot_t
name|status
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_VERSION
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_VERSION_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_VERSION_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* bootrom support */
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|==
name|MC_CMD_GET_VERSION_V0_OUT_LEN
condition|)
block|{
name|version
index|[
literal|0
index|]
operator|=
name|version
index|[
literal|1
index|]
operator|=
name|version
index|[
literal|2
index|]
operator|=
name|version
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|build
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VERSION_OUT_FIRMWARE
argument_list|)
expr_stmt|;
goto|goto
name|version
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_VERSION_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ver_words
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|efx_word_t
argument_list|,
name|GET_VERSION_OUT_VERSION
argument_list|)
expr_stmt|;
name|version
index|[
literal|0
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|0
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|version
index|[
literal|1
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|1
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|version
index|[
literal|2
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|2
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|version
index|[
literal|3
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|3
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|build
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VERSION_OUT_FIRMWARE
argument_list|)
expr_stmt|;
name|version
label|:
comment|/* The bootrom doesn't understand BOOT_STATUS */
if|if
condition|(
name|MC_FW_VERSION_IS_BOOTLOADER
argument_list|(
name|build
argument_list|)
condition|)
block|{
name|status
operator|=
name|EFX_MCDI_BOOT_ROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_BOOT_STATUS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_BOOT_STATUS_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_BOOT_STATUS_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|==
name|EACCES
condition|)
block|{
comment|/* Unprivileged functions cannot access BOOT_STATUS */
name|status
operator|=
name|EFX_MCDI_BOOT_PRIMARY
expr_stmt|;
name|version
index|[
literal|0
index|]
operator|=
name|version
index|[
literal|1
index|]
operator|=
name|version
index|[
literal|2
index|]
operator|=
name|version
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|build
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_BOOT_STATUS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_BOOT_STATUS_OUT_FLAGS
argument_list|,
name|GET_BOOT_STATUS_OUT_FLAGS_PRIMARY
argument_list|)
condition|)
name|status
operator|=
name|EFX_MCDI_BOOT_PRIMARY
expr_stmt|;
else|else
name|status
operator|=
name|EFX_MCDI_BOOT_SECONDARY
expr_stmt|;
name|out
label|:
if|if
condition|(
name|versionp
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|versionp
argument_list|,
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buildp
operator|!=
name|NULL
condition|)
operator|*
name|buildp
operator|=
name|build
expr_stmt|;
if|if
condition|(
name|statusp
operator|!=
name|NULL
condition|)
operator|*
name|statusp
operator|=
name|status
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_do_reboot
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|boolean_t
name|after_assertion
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_REBOOT_IN_LEN
argument_list|,
name|MC_CMD_REBOOT_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * We could require the caller to have caused en_mod_flags=0 to 	 * call this function. This doesn't help the other port though, 	 * who's about to get the MC ripped out from underneath them. 	 * Since they have to cope with the subsequent fallout of MCDI 	 * failures, we should as well. 	 */
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_REBOOT
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_REBOOT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_REBOOT_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|REBOOT_IN_FLAGS
argument_list|,
operator|(
name|after_assertion
condition|?
name|MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|==
name|EACCES
condition|)
block|{
comment|/* Unprivileged functions cannot reboot the MC. */
goto|goto
name|out
goto|;
block|}
comment|/* A successful reboot request returns EIO. */
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
operator|&&
name|req
operator|.
name|emr_rc
operator|!=
name|EIO
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|out
label|:
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_reboot
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
return|return
operator|(
name|efx_mcdi_do_reboot
argument_list|(
name|enp
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_exit_assertion_handler
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
return|return
operator|(
name|efx_mcdi_do_reboot
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_read_assertion
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_ASSERTS_IN_LEN
argument_list|,
name|MC_CMD_GET_ASSERTS_OUT_LEN
argument_list|)
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|unsigned
name|int
name|ofst
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * Before we attempt to chat to the MC, we should verify that the MC 	 * isn't in it's assertion handler, either due to a previous reboot, 	 * or because we're reinitializing due to an eec_exception(). 	 * 	 * Use GET_ASSERTS to read any assertion state that may be present. 	 * Retry this command twice. Once because a boot-time assertion failure 	 * might cause the 1st MCDI request to fail. And once again because 	 * we might race with efx_mcdi_exit_assertion_handler() running on 	 * partner port(s) on the same NIC. 	 */
name|retry
operator|=
literal|2
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_ASSERTS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_ASSERTS_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_ASSERTS_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|GET_ASSERTS_IN_CLEAR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|req
operator|.
name|emr_rc
operator|==
name|EINTR
operator|||
name|req
operator|.
name|emr_rc
operator|==
name|EIO
operator|)
operator|&&
name|retry
operator|--
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|==
name|EACCES
condition|)
block|{
comment|/* Unprivileged functions cannot clear assertions. */
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_ASSERTS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
comment|/* Print out any assertion state recorded */
name|flags
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_ASSERTS_OUT_GLOBAL_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reason
operator|=
operator|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL
operator|)
condition|?
literal|"system-level assertion"
else|:
operator|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL
operator|)
condition|?
literal|"thread-level assertion"
else|:
operator|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED
operator|)
condition|?
literal|"watchdog reset"
else|:
operator|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_ADDR_TRAP
operator|)
condition|?
literal|"illegal address trap"
else|:
literal|"unknown assertion"
expr_stmt|;
name|EFSYS_PROBE3
argument_list|(
argument|mcpu_assertion
argument_list|,
argument|const char *
argument_list|,
argument|reason
argument_list|,
argument|unsigned int
argument_list|,
argument|MCDI_OUT_DWORD(req, GET_ASSERTS_OUT_SAVED_PC_OFFS)
argument_list|,
argument|unsigned int
argument_list|,
argument|MCDI_OUT_DWORD(req, GET_ASSERTS_OUT_THREAD_OFFS)
argument_list|)
empty_stmt|;
comment|/* Print out the registers (r1 ... r31) */
name|ofst
operator|=
name|MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|1
init|;
name|index
operator|<
literal|1
operator|+
name|MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_NUM
condition|;
name|index
operator|++
control|)
block|{
name|EFSYS_PROBE2
argument_list|(
argument|mcpu_register
argument_list|,
argument|unsigned int
argument_list|,
argument|index
argument_list|,
argument|unsigned int
argument_list|,
argument|EFX_DWORD_FIELD(*MCDI_OUT(req, efx_dword_t, ofst), 					    EFX_DWORD_0)
argument_list|)
empty_stmt|;
name|ofst
operator|+=
sizeof|sizeof
argument_list|(
name|efx_dword_t
argument_list|)
expr_stmt|;
block|}
name|EFSYS_ASSERT
argument_list|(
name|ofst
operator|<=
name|MC_CMD_GET_ASSERTS_OUT_LEN
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal routines for for specific MCDI requests.  */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_drv_attach
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|boolean_t
name|attach
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_DRV_ATTACH_IN_LEN
argument_list|,
name|MC_CMD_DRV_ATTACH_EXT_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_DRV_ATTACH
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_DRV_ATTACH_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_DRV_ATTACH_EXT_OUT_LEN
expr_stmt|;
comment|/* 	 * Use DONT_CARE for the datapath firmware type to ensure that the 	 * driver can attach to an unprivileged function. The datapath firmware 	 * type to use is controlled by the 'sfboot' utility. 	 */
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRV_ATTACH_IN_NEW_STATE
argument_list|,
name|attach
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRV_ATTACH_IN_UPDATE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRV_ATTACH_IN_FIRMWARE_ID
argument_list|,
name|MC_CMD_FW_DONT_CARE
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_DRV_ATTACH_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|attach
operator|==
name|B_FALSE
condition|)
block|{
name|flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_SIENA
condition|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
comment|/* Create synthetic privileges for Siena functions */
name|flags
operator|=
name|EFX_NIC_FUNC_LINKCTRL
operator||
name|EFX_NIC_FUNC_TRUSTED
expr_stmt|;
if|if
condition|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
condition|)
name|flags
operator||=
name|EFX_NIC_FUNC_PRIMARY
expr_stmt|;
block|}
else|else
block|{
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_NIC_FUNC_PRIMARY
operator|==
operator|(
literal|1u
operator|<<
name|MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY
operator|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_NIC_FUNC_LINKCTRL
operator|==
operator|(
literal|1u
operator|<<
name|MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL
operator|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_NIC_FUNC_TRUSTED
operator|==
operator|(
literal|1u
operator|<<
name|MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_TRUSTED
operator|)
argument_list|)
expr_stmt|;
comment|/* Save function privilege flags (EF10 and later) */
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_DRV_ATTACH_EXT_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|flags
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|DRV_ATTACH_EXT_OUT_FUNC_FLAGS
argument_list|)
expr_stmt|;
block|}
name|encp
operator|->
name|enc_func_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_board_cfg
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_opt
name|uint32_t
operator|*
name|board_typep
argument_list|,
name|__out_opt
name|efx_dword_t
operator|*
name|capabilitiesp
argument_list|,
name|__out_ecount_opt
argument_list|(
literal|6
argument_list|)
name|uint8_t
name|mac_addrp
index|[
literal|6
index|]
argument_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_BOARD_CFG_IN_LEN
argument_list|,
name|MC_CMD_GET_BOARD_CFG_OUT_LENMIN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_BOARD_CFG
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_BOARD_CFG_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_BOARD_CFG_OUT_LENMIN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_BOARD_CFG_OUT_LENMIN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|mac_addrp
operator|!=
name|NULL
condition|)
block|{
name|uint8_t
modifier|*
name|addrp
decl_stmt|;
if|if
condition|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
condition|)
block|{
name|addrp
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|emip
operator|->
name|emi_port
operator|==
literal|2
condition|)
block|{
name|addrp
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|EFX_MAC_ADDR_COPY
argument_list|(
name|mac_addrp
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|capabilitiesp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
condition|)
block|{
operator|*
name|capabilitiesp
operator|=
operator|*
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|efx_dword_t
argument_list|,
name|GET_BOARD_CFG_OUT_CAPABILITIES_PORT0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|emip
operator|->
name|emi_port
operator|==
literal|2
condition|)
block|{
operator|*
name|capabilitiesp
operator|=
operator|*
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|efx_dword_t
argument_list|,
name|GET_BOARD_CFG_OUT_CAPABILITIES_PORT1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
block|}
if|if
condition|(
name|board_typep
operator|!=
name|NULL
condition|)
block|{
operator|*
name|board_typep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_BOARD_CFG_OUT_BOARD_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_resource_limits
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|nevqp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|nrxqp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|ntxqp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_RESOURCE_LIMITS_IN_LEN
argument_list|,
name|MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_RESOURCE_LIMITS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_RESOURCE_LIMITS_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|nevqp
operator|!=
name|NULL
condition|)
operator|*
name|nevqp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_RESOURCE_LIMITS_OUT_EVQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrxqp
operator|!=
name|NULL
condition|)
operator|*
name|nrxqp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_RESOURCE_LIMITS_OUT_RXQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntxqp
operator|!=
name|NULL
condition|)
operator|*
name|ntxqp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_RESOURCE_LIMITS_OUT_TXQ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_phy_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PHY_CFG_IN_LEN
argument_list|,
name|MC_CMD_GET_PHY_CFG_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PHY_CFG
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PHY_CFG_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PHY_CFG_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PHY_CFG_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|encp
operator|->
name|enc_phy_type
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_TYPE
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_NAMES
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|encp
operator|->
name|enc_phy_name
argument_list|,
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|char
argument_list|,
name|GET_PHY_CFG_OUT_NAME
argument_list|)
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|encp
operator|->
name|enc_phy_name
argument_list|)
operator|-
literal|1
argument_list|,
name|MC_CMD_GET_PHY_CFG_OUT_NAME_LEN
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_NAMES */
operator|(
name|void
operator|)
name|memset
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|,
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|char
argument_list|,
name|GET_PHY_CFG_OUT_REVISION
argument_list|)
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|)
operator|-
literal|1
argument_list|,
name|MC_CMD_GET_PHY_CFG_OUT_REVISION_LEN
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_LED_CONTROL
name|encp
operator|->
name|enc_led_mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|EFX_PHY_LED_DEFAULT
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_PHY_LED_OFF
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_PHY_LED_ON
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_LED_CONTROL */
comment|/* Get the media type of the fixed port, if recognised. */
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_XAUI
operator|==
name|EFX_PHY_MEDIA_XAUI
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_CX4
operator|==
name|EFX_PHY_MEDIA_CX4
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_KX4
operator|==
name|EFX_PHY_MEDIA_KX4
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_XFP
operator|==
name|EFX_PHY_MEDIA_XFP
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_SFP_PLUS
operator|==
name|EFX_PHY_MEDIA_SFP_PLUS
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_BASE_T
operator|==
name|EFX_PHY_MEDIA_BASE_T
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_QSFP_PLUS
operator|==
name|EFX_PHY_MEDIA_QSFP_PLUS
argument_list|)
expr_stmt|;
name|epp
operator|->
name|ep_fixed_port_type
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_MEDIA_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|epp
operator|->
name|ep_fixed_port_type
operator|>=
name|EFX_PHY_MEDIA_NTYPES
condition|)
name|epp
operator|->
name|ep_fixed_port_type
operator|=
name|EFX_PHY_MEDIA_INVALID
expr_stmt|;
name|epp
operator|->
name|ep_phy_cap_mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_SUPPORTED_CAP
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_FLAGS
name|encp
operator|->
name|enc_phy_flags_mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_FLAGS */
name|encp
operator|->
name|enc_port
operator|=
operator|(
name|uint8_t
operator|)
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_PRT
argument_list|)
expr_stmt|;
comment|/* Populate internal state */
name|encp
operator|->
name|enc_mcdi_mdio_channel
operator|=
operator|(
name|uint8_t
operator|)
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_CHANNEL
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_STATS
name|encp
operator|->
name|enc_mcdi_phy_stat_mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_STATS_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_STATS */
if|#
directive|if
name|EFSYS_OPT_BIST
name|encp
operator|->
name|enc_bist_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|,
name|GET_PHY_CFG_OUT_BIST_CABLE_SHORT
argument_list|)
condition|)
name|encp
operator|->
name|enc_bist_mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_BIST_TYPE_PHY_CABLE_SHORT
operator|)
expr_stmt|;
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|,
name|GET_PHY_CFG_OUT_BIST_CABLE_LONG
argument_list|)
condition|)
name|encp
operator|->
name|enc_bist_mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_BIST_TYPE_PHY_CABLE_LONG
operator|)
expr_stmt|;
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|,
name|GET_PHY_CFG_OUT_BIST
argument_list|)
condition|)
name|encp
operator|->
name|enc_bist_mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_BIST_TYPE_PHY_NORMAL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_BIST */
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_firmware_update_supported
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|boolean_t
modifier|*
name|supportedp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|emcop
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|emcop
operator|->
name|emco_feature_supported
argument_list|(
name|enp
argument_list|,
name|EFX_MCDI_FEATURE_FW_UPDATE
argument_list|,
name|supportedp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
comment|/* Earlier devices always supported updates */
operator|*
name|supportedp
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_macaddr_change_supported
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|boolean_t
modifier|*
name|supportedp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|emcop
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|emcop
operator|->
name|emco_feature_supported
argument_list|(
name|enp
argument_list|,
name|EFX_MCDI_FEATURE_MACADDR_CHANGE
argument_list|,
name|supportedp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
comment|/* Earlier devices always supported MAC changes */
operator|*
name|supportedp
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_link_control_supported
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|boolean_t
modifier|*
name|supportedp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|emcop
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|emcop
operator|->
name|emco_feature_supported
argument_list|(
name|enp
argument_list|,
name|EFX_MCDI_FEATURE_LINK_CONTROL
argument_list|,
name|supportedp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
comment|/* Earlier devices always supported link control */
operator|*
name|supportedp
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_mac_spoofing_supported
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|boolean_t
modifier|*
name|supportedp
parameter_list|)
block|{
specifier|const
name|efx_mcdi_ops_t
modifier|*
name|emcop
init|=
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emcop
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|emcop
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|emcop
operator|->
name|emco_feature_supported
argument_list|(
name|enp
argument_list|,
name|EFX_MCDI_FEATURE_MAC_SPOOFING
argument_list|,
name|supportedp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
comment|/* Earlier devices always supported MAC spoofing */
operator|*
name|supportedp
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_BIST
end_if

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
operator|||
name|EFSYS_OPT_MEDFORD
end_if

begin_comment
comment|/*  * Enter bist offline mode. This is a fw mode which puts the NIC into a state  * where memory BIST tests can be run and not much else can interfere or happen.  * A reboot is required to exit this mode.  */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_bist_enable_offline
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_ENABLE_OFFLINE_BIST_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_ENABLE_OFFLINE_BIST_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ENABLE_OFFLINE_BIST
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON || EFSYS_OPT_MEDFORD */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_bist_start
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_bist_type_t
name|type
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_START_BIST_IN_LEN
argument_list|,
name|MC_CMD_START_BIST_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_START_BIST
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_START_BIST_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_START_BIST_OUT_LEN
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EFX_BIST_TYPE_PHY_NORMAL
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|START_BIST_IN_TYPE
argument_list|,
name|MC_CMD_PHY_BIST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFX_BIST_TYPE_PHY_CABLE_SHORT
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|START_BIST_IN_TYPE
argument_list|,
name|MC_CMD_PHY_BIST_CABLE_SHORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFX_BIST_TYPE_PHY_CABLE_LONG
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|START_BIST_IN_TYPE
argument_list|,
name|MC_CMD_PHY_BIST_CABLE_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFX_BIST_TYPE_MC_MEM
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|START_BIST_IN_TYPE
argument_list|,
name|MC_CMD_MC_MEM_BIST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFX_BIST_TYPE_SAT_MEM
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|START_BIST_IN_TYPE
argument_list|,
name|MC_CMD_PORT_MEM_BIST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFX_BIST_TYPE_REG
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|START_BIST_IN_TYPE
argument_list|,
name|MC_CMD_REG_BIST
argument_list|)
expr_stmt|;
break|break;
default|default:
name|EFSYS_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_BIST */
end_comment

begin_comment
comment|/* Enable logging of some events (e.g. link state changes) */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_log_ctrl
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_LOG_CTRL_IN_LEN
argument_list|,
name|MC_CMD_LOG_CTRL_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_LOG_CTRL
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_LOG_CTRL_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_LOG_CTRL_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LOG_CTRL_IN_LOG_DEST
argument_list|,
name|MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LOG_CTRL_IN_LOG_DEST_EVQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
end_if

begin_typedef
typedef|typedef
enum|enum
name|efx_stats_action_e
block|{
name|EFX_STATS_CLEAR
block|,
name|EFX_STATS_UPLOAD
block|,
name|EFX_STATS_ENABLE_NOEVENTS
block|,
name|EFX_STATS_ENABLE_EVENTS
block|,
name|EFX_STATS_DISABLE
block|, }
name|efx_stats_action_t
typedef|;
end_typedef

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_mac_stats
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in_opt
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|,
name|__in
name|efx_stats_action_t
name|action
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_MAC_STATS_IN_LEN
argument_list|,
name|MC_CMD_MAC_STATS_OUT_DMA_LEN
argument_list|)
index|]
decl_stmt|;
name|int
name|clear
init|=
operator|(
name|action
operator|==
name|EFX_STATS_CLEAR
operator|)
decl_stmt|;
name|int
name|upload
init|=
operator|(
name|action
operator|==
name|EFX_STATS_UPLOAD
operator|)
decl_stmt|;
name|int
name|enable
init|=
operator|(
name|action
operator|==
name|EFX_STATS_ENABLE_NOEVENTS
operator|)
decl_stmt|;
name|int
name|events
init|=
operator|(
name|action
operator|==
name|EFX_STATS_ENABLE_EVENTS
operator|)
decl_stmt|;
name|int
name|disable
init|=
operator|(
name|action
operator|==
name|EFX_STATS_DISABLE
operator|)
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_MAC_STATS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_MAC_STATS_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_MAC_STATS_OUT_DMA_LEN
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_6
argument_list|(
name|req
argument_list|,
name|MAC_STATS_IN_CMD
argument_list|,
name|MAC_STATS_IN_DMA
argument_list|,
name|upload
argument_list|,
name|MAC_STATS_IN_CLEAR
argument_list|,
name|clear
argument_list|,
name|MAC_STATS_IN_PERIODIC_CHANGE
argument_list|,
name|enable
operator||
name|events
operator||
name|disable
argument_list|,
name|MAC_STATS_IN_PERIODIC_ENABLE
argument_list|,
name|enable
operator||
name|events
argument_list|,
name|MAC_STATS_IN_PERIODIC_NOEVENT
argument_list|,
operator|!
name|events
argument_list|,
name|MAC_STATS_IN_PERIOD_MS
argument_list|,
operator|(
name|enable
operator||
name|events
operator|)
condition|?
literal|1000
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|esmp
operator|!=
name|NULL
condition|)
block|{
name|int
name|bytes
init|=
name|MC_CMD_MAC_NSTATS
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MAC_NSTATS
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|<=
name|EFX_MAC_STATS_SIZE
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|MAC_STATS_IN_DMA_ADDR_LO
argument_list|,
name|EFSYS_MEM_ADDR
argument_list|(
name|esmp
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|MAC_STATS_IN_DMA_ADDR_HI
argument_list|,
name|EFSYS_MEM_ADDR
argument_list|(
name|esmp
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|MAC_STATS_IN_DMA_LEN
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EFSYS_ASSERT
argument_list|(
operator|!
name|upload
operator|&&
operator|!
name|enable
operator|&&
operator|!
name|events
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * NOTE: Do not use EVB_PORT_ID_ASSIGNED when disabling periodic stats, 	 *	 as this may fail (and leave periodic DMA enabled) if the 	 *	 vadapter has already been deleted. 	 */
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|MAC_STATS_IN_PORT_ID
argument_list|,
operator|(
name|disable
condition|?
name|EVB_PORT_ID_NULL
else|:
name|enp
operator|->
name|en_vport_id
operator|)
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
comment|/* EF10: Expect ENOENT if no DMA queues are initialised */
if|if
condition|(
operator|(
name|req
operator|.
name|emr_rc
operator|!=
name|ENOENT
operator|)
operator|||
operator|(
name|enp
operator|->
name|en_rx_qcount
operator|+
name|enp
operator|->
name|en_tx_qcount
operator|!=
literal|0
operator|)
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_mac_stats_clear
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_mac_stats
argument_list|(
name|enp
argument_list|,
name|NULL
argument_list|,
name|EFX_STATS_CLEAR
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_mac_stats_upload
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * The MC DMAs aggregate statistics for our convenience, so we can 	 * avoid having to pull the statistics buffer into the cache to 	 * maintain cumulative statistics. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_mac_stats
argument_list|(
name|enp
argument_list|,
name|esmp
argument_list|,
name|EFX_STATS_UPLOAD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_mac_stats_periodic
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|,
name|__in
name|uint16_t
name|period
parameter_list|,
name|__in
name|boolean_t
name|events
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * The MC DMAs aggregate statistics for our convenience, so we can 	 * avoid having to pull the statistics buffer into the cache to 	 * maintain cumulative statistics. 	 * Huntington uses a fixed 1sec period, so use that on Siena too. 	 */
if|if
condition|(
name|period
operator|==
literal|0
condition|)
name|rc
operator|=
name|efx_mcdi_mac_stats
argument_list|(
name|enp
argument_list|,
name|NULL
argument_list|,
name|EFX_STATS_DISABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|events
condition|)
name|rc
operator|=
name|efx_mcdi_mac_stats
argument_list|(
name|enp
argument_list|,
name|esmp
argument_list|,
name|EFX_STATS_ENABLE_EVENTS
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|efx_mcdi_mac_stats
argument_list|(
name|enp
argument_list|,
name|esmp
argument_list|,
name|EFX_STATS_ENABLE_NOEVENTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MAC_STATS */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
operator|||
name|EFSYS_OPT_MEDFORD
end_if

begin_comment
comment|/*  * This function returns the pf and vf number of a function.  If it is a pf the  * vf number is 0xffff.  The vf number is the index of the vf on that  * function. So if you have 3 vfs on pf 0 the 3 vfs will return (pf=0,vf=0),  * (pf=0,vf=1), (pf=0,vf=2) aand the pf will return (pf=0, vf=0xffff).  */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_function_info
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|pfp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|vfp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_FUNCTION_INFO_IN_LEN
argument_list|,
name|MC_CMD_GET_FUNCTION_INFO_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_FUNCTION_INFO
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_FUNCTION_INFO_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_FUNCTION_INFO_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_FUNCTION_INFO_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|pfp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_FUNCTION_INFO_OUT_PF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp
operator|!=
name|NULL
condition|)
operator|*
name|vfp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_FUNCTION_INFO_OUT_VF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_privilege_mask
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|pf
parameter_list|,
name|__in
name|uint32_t
name|vf
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|maskp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_PRIVILEGE_MASK_IN_LEN
argument_list|,
name|MC_CMD_PRIVILEGE_MASK_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_PRIVILEGE_MASK
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_PRIVILEGE_MASK_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_PRIVILEGE_MASK_OUT_LEN
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_2
argument_list|(
name|req
argument_list|,
name|PRIVILEGE_MASK_IN_FUNCTION
argument_list|,
name|PRIVILEGE_MASK_IN_FUNCTION_PF
argument_list|,
name|pf
argument_list|,
name|PRIVILEGE_MASK_IN_FUNCTION_VF
argument_list|,
name|vf
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_PRIVILEGE_MASK_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|maskp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|PRIVILEGE_MASK_OUT_OLD_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON || EFSYS_OPT_MEDFORD */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_set_workaround
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|type
parameter_list|,
name|__in
name|boolean_t
name|enabled
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|flagsp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_WORKAROUND_IN_LEN
argument_list|,
name|MC_CMD_WORKAROUND_EXT_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_WORKAROUND
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_WORKAROUND_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_WORKAROUND_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|WORKAROUND_IN_TYPE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|WORKAROUND_IN_ENABLED
argument_list|,
name|enabled
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|>=
name|MC_CMD_WORKAROUND_EXT_OUT_LEN
condition|)
operator|*
name|flagsp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|WORKAROUND_EXT_OUT_FLAGS
argument_list|)
expr_stmt|;
else|else
operator|*
name|flagsp
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_workarounds
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|implementedp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|enabledp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MC_CMD_GET_WORKAROUNDS_OUT_LEN
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_WORKAROUNDS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_WORKAROUNDS_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|implementedp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|implementedp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_WORKAROUNDS_OUT_IMPLEMENTED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enabledp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|enabledp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_WORKAROUNDS_OUT_ENABLED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Size of media information page in accordance with SFF-8472 and SFF-8436.  * It is used in MCDI interface as well.  */
end_comment

begin_define
define|#
directive|define
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
value|0x80
end_define

begin_decl_stmt
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_phy_media_info
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|uint32_t
name|mcdi_page
argument_list|,
name|__in
name|uint8_t
name|offset
argument_list|,
name|__in
name|uint8_t
name|len
argument_list|,
name|__out_bcount
argument_list|(
argument|len
argument_list|)
name|uint8_t
operator|*
name|data
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PHY_MEDIA_INFO_IN_LEN
argument_list|,
name|MC_CMD_GET_PHY_MEDIA_INFO_OUT_LEN
argument_list|(
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
operator|(
name|uint32_t
operator|)
name|offset
operator|+
name|len
operator|<=
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PHY_MEDIA_INFO
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PHY_MEDIA_INFO_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PHY_MEDIA_INFO_OUT_LEN
argument_list|(
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_MEDIA_INFO_IN_PAGE
argument_list|,
name|mcdi_page
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|!=
name|MC_CMD_GET_PHY_MEDIA_INFO_OUT_LEN
argument_list|(
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_MEDIA_INFO_OUT_DATALEN
argument_list|)
operator|!=
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|memcpy
argument_list|(
name|data
argument_list|,
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|GET_PHY_MEDIA_INFO_OUT_DATA
argument_list|)
operator|+
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * 2-wire device address of the base information in accordance with SFF-8472  * Diagnostic Monitoring Interface for Optical Transceivers section  * 4 Memory Organization.  */
end_comment

begin_define
define|#
directive|define
name|EFX_PHY_MEDIA_INFO_DEV_ADDR_SFP_BASE
value|0xA0
end_define

begin_comment
comment|/*  * 2-wire device address of the digital diagnostics monitoring interface  * in accordance with SFF-8472 Diagnostic Monitoring Interface for Optical  * Transceivers section 4 Memory Organization.  */
end_comment

begin_define
define|#
directive|define
name|EFX_PHY_MEDIA_INFO_DEV_ADDR_SFP_DDM
value|0xA2
end_define

begin_comment
comment|/*  * Hard wired 2-wire device address for QSFP+ in accordance with SFF-8436  * QSFP+ 10 Gbs 4X PLUGGABLE TRANSCEIVER section 7.4 Device Addressing and  * Operation.  */
end_comment

begin_define
define|#
directive|define
name|EFX_PHY_MEDIA_INFO_DEV_ADDR_QSFP
value|0xA0
end_define

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_phy_module_get_info
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|uint8_t
name|dev_addr
argument_list|,
name|__in
name|uint8_t
name|offset
argument_list|,
name|__in
name|uint8_t
name|len
argument_list|,
name|__out_bcount
argument_list|(
argument|len
argument_list|)
name|uint8_t
operator|*
name|data
argument_list|)
block|{
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|uint32_t
name|mcdi_lower_page
decl_stmt|;
name|uint32_t
name|mcdi_upper_page
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_PROBE
argument_list|)
expr_stmt|;
comment|/* 	 * Map device address to MC_CMD_GET_PHY_MEDIA_INFO pages. 	 * Offset plus length interface allows to access page 0 only. 	 * I.e. non-zero upper pages are not accessible. 	 * See SFF-8472 section 4 Memory Organization and SFF-8436 section 7.6 	 * QSFP+ Memory Map for details on how information is structured 	 * and accessible. 	 */
switch|switch
condition|(
name|epp
operator|->
name|ep_fixed_port_type
condition|)
block|{
case|case
name|EFX_PHY_MEDIA_SFP_PLUS
case|:
comment|/* 		 * In accordance with SFF-8472 Diagnostic Monitoring 		 * Interface for Optical Transceivers section 4 Memory 		 * Organization two 2-wire addresses are defined. 		 */
switch|switch
condition|(
name|dev_addr
condition|)
block|{
comment|/* Base information */
case|case
name|EFX_PHY_MEDIA_INFO_DEV_ADDR_SFP_BASE
case|:
comment|/* 			 * MCDI page 0 should be used to access lower 			 * page 0 (0x00 - 0x7f) at the device address 0xA0. 			 */
name|mcdi_lower_page
operator|=
literal|0
expr_stmt|;
comment|/* 			 * MCDI page 1 should be used to access  upper 			 * page 0 (0x80 - 0xff) at the device address 0xA0. 			 */
name|mcdi_upper_page
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Diagnostics */
case|case
name|EFX_PHY_MEDIA_INFO_DEV_ADDR_SFP_DDM
case|:
comment|/* 			 * MCDI page 2 should be used to access lower 			 * page 0 (0x00 - 0x7f) at the device address 0xA2. 			 */
name|mcdi_lower_page
operator|=
literal|2
expr_stmt|;
comment|/* 			 * MCDI page 3 should be used to access upper 			 * page 0 (0x80 - 0xff) at the device address 0xA2. 			 */
name|mcdi_upper_page
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
break|break;
case|case
name|EFX_PHY_MEDIA_QSFP_PLUS
case|:
switch|switch
condition|(
name|dev_addr
condition|)
block|{
case|case
name|EFX_PHY_MEDIA_INFO_DEV_ADDR_QSFP
case|:
comment|/* 			 * MCDI page -1 should be used to access lower page 0 			 * (0x00 - 0x7f). 			 */
name|mcdi_lower_page
operator|=
operator|(
name|uint32_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * MCDI page 0 should be used to access upper page 0 			 * (0x80h - 0xff). 			 */
name|mcdi_upper_page
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
break|break;
default|default:
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|offset
operator|<
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
condition|)
block|{
name|uint8_t
name|read_len
init|=
name|MIN
argument_list|(
name|len
argument_list|,
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
operator|-
name|offset
argument_list|)
decl_stmt|;
name|rc
operator|=
name|efx_mcdi_get_phy_media_info
argument_list|(
name|enp
argument_list|,
name|mcdi_lower_page
argument_list|,
name|offset
argument_list|,
name|read_len
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
name|data
operator|+=
name|read_len
expr_stmt|;
name|len
operator|-=
name|read_len
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|-=
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|EFSYS_ASSERT3U
argument_list|(
name|len
argument_list|,
operator|<=
argument_list|,
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|<
argument_list|,
name|EFX_PHY_MEDIA_INFO_PAGE_SIZE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|efx_mcdi_get_phy_media_info
argument_list|(
name|enp
argument_list|,
name|mcdi_upper_page
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MCDI */
end_comment

end_unit

