begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
end_if

begin_if
if|#
directive|if
name|EFSYS_OPT_QSTATS
end_if

begin_define
define|#
directive|define
name|EFX_TX_QSTAT_INCR
parameter_list|(
name|_etp
parameter_list|,
name|_stat
parameter_list|)
define|\
value|do {								\ 		(_etp)->et_stat[_stat]++;				\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EFX_TX_QSTAT_INCR
parameter_list|(
name|_etp
parameter_list|,
name|_stat
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_init_txq
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|size
parameter_list|,
name|__in
name|uint32_t
name|target_evq
parameter_list|,
name|__in
name|uint32_t
name|label
parameter_list|,
name|__in
name|uint32_t
name|instance
parameter_list|,
name|__in
name|uint16_t
name|flags
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_INIT_TXQ_IN_LEN
argument_list|(
name|EFX_TXQ_MAX_BUFS
argument_list|)
argument_list|,
name|MC_CMD_INIT_TXQ_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_qword_t
modifier|*
name|dma_addr
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|EFX_TXQ_MAX_BUFS
operator|>=
name|EFX_TXQ_NBUFS
argument_list|(
name|EFX_TXQ_MAXNDESCS
argument_list|(
operator|&
name|enp
operator|->
name|en_nic_cfg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|npages
operator|=
name|EFX_TXQ_NBUFS
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|npages
operator|>
name|MC_CMD_INIT_TXQ_IN_DMA_ADDR_MAXNUM
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_INIT_TXQ
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_INIT_TXQ_IN_LEN
argument_list|(
name|npages
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_INIT_TXQ_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_TXQ_IN_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_TXQ_IN_TARGET_EVQ
argument_list|,
name|target_evq
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_TXQ_IN_LABEL
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_TXQ_IN_INSTANCE
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_6
argument_list|(
name|req
argument_list|,
name|INIT_TXQ_IN_FLAGS
argument_list|,
name|INIT_TXQ_IN_FLAG_BUFF_MODE
argument_list|,
literal|0
argument_list|,
name|INIT_TXQ_IN_FLAG_IP_CSUM_DIS
argument_list|,
operator|(
name|flags
operator|&
name|EFX_CKSUM_IPV4
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|INIT_TXQ_IN_FLAG_TCP_CSUM_DIS
argument_list|,
operator|(
name|flags
operator|&
name|EFX_CKSUM_TCPUDP
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|INIT_TXQ_IN_FLAG_TCP_UDP_ONLY
argument_list|,
literal|0
argument_list|,
name|INIT_TXQ_IN_CRC_MODE
argument_list|,
literal|0
argument_list|,
name|INIT_TXQ_IN_FLAG_TIMESTAMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_TXQ_IN_OWNER_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_TXQ_IN_PORT_ID
argument_list|,
name|EVB_PORT_ID_ASSIGNED
argument_list|)
expr_stmt|;
name|dma_addr
operator|=
name|MCDI_IN2
argument_list|(
name|req
argument_list|,
name|efx_qword_t
argument_list|,
name|INIT_TXQ_IN_DMA_ADDR
argument_list|)
expr_stmt|;
name|addr
operator|=
name|EFSYS_MEM_ADDR
argument_list|(
name|esmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|EFX_POPULATE_QWORD_2
argument_list|(
operator|*
name|dma_addr
argument_list|,
name|EFX_DWORD_1
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|,
name|EFX_DWORD_0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
name|dma_addr
operator|++
expr_stmt|;
name|addr
operator|+=
name|EFX_BUF_SIZE
expr_stmt|;
block|}
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_fini_txq
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|instance
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_FINI_TXQ_IN_LEN
argument_list|,
name|MC_CMD_FINI_TXQ_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FINI_TXQ
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_FINI_TXQ_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_FINI_TXQ_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FINI_TXQ_IN_INSTANCE
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|req
operator|.
name|emr_rc
operator|!=
name|MC_CMD_ERR_EALREADY
operator|)
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_tx_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hunt_tx_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qcreate
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|,
name|__in
name|unsigned
name|int
name|label
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|,
name|__in
name|size_t
name|n
parameter_list|,
name|__in
name|uint32_t
name|id
parameter_list|,
name|__in
name|uint16_t
name|flags
parameter_list|,
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|,
name|__out
name|unsigned
name|int
modifier|*
name|addedp
parameter_list|)
block|{
name|efx_qword_t
name|desc
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_init_txq
argument_list|(
name|enp
argument_list|,
name|n
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
name|label
argument_list|,
name|index
argument_list|,
name|flags
argument_list|,
name|esmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* 	 * A previous user of this TX queue may have written a descriptor to the 	 * TX push collector, but not pushed the doorbell (e.g. after a crash). 	 * The next doorbell write would then push the stale descriptor. 	 * 	 * Ensure the (per network port) TX push collector is cleared by writing 	 * a no-op TX option descriptor. See bug29981 for details. 	 */
operator|*
name|addedp
operator|=
literal|1
expr_stmt|;
name|EFX_POPULATE_QWORD_4
argument_list|(
name|desc
argument_list|,
name|ESF_DZ_TX_DESC_IS_OPT
argument_list|,
literal|1
argument_list|,
name|ESF_DZ_TX_OPTION_TYPE
argument_list|,
name|ESE_DZ_TX_OPTION_DESC_CRC_CSUM
argument_list|,
name|ESF_DZ_TX_OPTION_UDP_TCP_CSUM
argument_list|,
operator|(
name|flags
operator|&
name|EFX_CKSUM_TCPUDP
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ESF_DZ_TX_OPTION_IP_CSUM
argument_list|,
operator|(
name|flags
operator|&
name|EFX_CKSUM_IPV4
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|EFSYS_MEM_WRITEQ
argument_list|(
name|etp
operator|->
name|et_esmp
argument_list|,
literal|0
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|hunt_tx_qpush
argument_list|(
name|etp
argument_list|,
operator|*
name|addedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hunt_tx_qdestroy
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|)
block|{
comment|/* FIXME */
name|_NOTE
argument_list|(
argument|ARGUNUSED(etp)
argument_list|)
comment|/* FIXME */
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qpio_enable
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|etp
operator|->
name|et_enp
decl_stmt|;
name|efx_piobuf_handle_t
name|handle
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|etp
operator|->
name|et_pio_size
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|EALREADY
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* Sub-allocate a PIO block from a piobuf */
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_nic_pio_alloc
argument_list|(
name|enp
argument_list|,
operator|&
name|etp
operator|->
name|et_pio_bufnum
argument_list|,
operator|&
name|handle
argument_list|,
operator|&
name|etp
operator|->
name|et_pio_blknum
argument_list|,
operator|&
name|etp
operator|->
name|et_pio_offset
argument_list|,
operator|&
name|etp
operator|->
name|et_pio_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail2
goto|;
block|}
name|EFSYS_ASSERT3U
argument_list|(
name|etp
operator|->
name|et_pio_size
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Link the piobuf to this TXQ */
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_nic_pio_link
argument_list|(
name|enp
argument_list|,
name|etp
operator|->
name|et_index
argument_list|,
name|handle
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail3
goto|;
block|}
comment|/* 	 * et_pio_offset is the offset of the sub-allocated block within the 	 * hardware PIO buffer. It is used as the buffer address in the PIO 	 * option descriptor. 	 * 	 * et_pio_write_offset is the offset of the sub-allocated block from the 	 * start of the write-combined memory mapping, and is used for writing 	 * data into the PIO buffer. 	 */
name|etp
operator|->
name|et_pio_write_offset
operator|=
operator|(
name|etp
operator|->
name|et_pio_bufnum
operator|*
name|ER_DZ_TX_PIOBUF_STEP
operator|)
operator|+
name|ER_DZ_TX_PIOBUF_OFST
operator|+
name|etp
operator|->
name|et_pio_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|hunt_nic_pio_free
argument_list|(
name|enp
argument_list|,
name|etp
operator|->
name|et_pio_bufnum
argument_list|,
name|etp
operator|->
name|et_pio_blknum
argument_list|)
expr_stmt|;
name|etp
operator|->
name|et_pio_size
operator|=
literal|0
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hunt_tx_qpio_disable
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|etp
operator|->
name|et_enp
decl_stmt|;
if|if
condition|(
name|etp
operator|->
name|et_pio_size
operator|!=
literal|0
condition|)
block|{
comment|/* Unlink the piobuf from this TXQ */
name|hunt_nic_pio_unlink
argument_list|(
name|enp
argument_list|,
name|etp
operator|->
name|et_index
argument_list|)
expr_stmt|;
comment|/* Free the sub-allocated PIO block */
name|hunt_nic_pio_free
argument_list|(
name|enp
argument_list|,
name|etp
operator|->
name|et_pio_bufnum
argument_list|,
name|etp
operator|->
name|et_pio_blknum
argument_list|)
expr_stmt|;
name|etp
operator|->
name|et_pio_size
operator|=
literal|0
expr_stmt|;
name|etp
operator|->
name|et_pio_write_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qpio_write
argument_list|(
name|__in
name|efx_txq_t
operator|*
name|etp
argument_list|,
name|__in_ecount
argument_list|(
argument|length
argument_list|)
name|uint8_t
operator|*
name|buffer
argument_list|,
name|__in
name|size_t
name|length
argument_list|,
name|__in
name|size_t
name|offset
argument_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|etp
operator|->
name|et_enp
decl_stmt|;
name|efsys_bar_t
modifier|*
name|esbp
init|=
name|enp
operator|->
name|en_esbp
decl_stmt|;
name|uint32_t
name|write_offset
decl_stmt|;
name|uint32_t
name|write_offset_limit
decl_stmt|;
name|efx_qword_t
modifier|*
name|eqp
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|length
operator|%
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|etp
operator|->
name|et_pio_size
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|offset
operator|+
name|length
operator|>
name|etp
operator|->
name|et_pio_size
condition|)
block|{
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
comment|/* 	 * Writes to PIO buffers must be 64 bit aligned, and multiples of 	 * 64 bits. 	 */
name|write_offset
operator|=
name|etp
operator|->
name|et_pio_write_offset
operator|+
name|offset
expr_stmt|;
name|write_offset_limit
operator|=
name|write_offset
operator|+
name|length
expr_stmt|;
name|eqp
operator|=
operator|(
name|efx_qword_t
operator|*
operator|)
name|buffer
expr_stmt|;
while|while
condition|(
name|write_offset
operator|<
name|write_offset_limit
condition|)
block|{
name|EFSYS_BAR_WC_WRITEQ
argument_list|(
name|esbp
argument_list|,
name|write_offset
argument_list|,
name|eqp
argument_list|)
expr_stmt|;
name|eqp
operator|++
expr_stmt|;
name|write_offset
operator|+=
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qpio_post
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|,
name|__in
name|size_t
name|pkt_length
parameter_list|,
name|__in
name|unsigned
name|int
name|completed
parameter_list|,
name|__inout
name|unsigned
name|int
modifier|*
name|addedp
parameter_list|)
block|{
name|efx_qword_t
name|pio_desc
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|unsigned
name|int
name|added
init|=
operator|*
name|addedp
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|added
operator|-
name|completed
operator|+
literal|1
operator|>
name|EFX_TXQ_LIMIT
argument_list|(
name|etp
operator|->
name|et_mask
operator|+
literal|1
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|etp
operator|->
name|et_pio_size
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|id
operator|=
name|added
operator|++
operator|&
name|etp
operator|->
name|et_mask
expr_stmt|;
name|offset
operator|=
name|id
operator|*
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
name|EFSYS_PROBE4
argument_list|(
argument|tx_pio_post
argument_list|,
argument|unsigned int
argument_list|,
argument|etp->et_index
argument_list|,
argument|unsigned int
argument_list|,
argument|id
argument_list|,
argument|uint32_t
argument_list|,
argument|etp->et_pio_offset
argument_list|,
argument|size_t
argument_list|,
argument|pkt_length
argument_list|)
empty_stmt|;
name|EFX_POPULATE_QWORD_5
argument_list|(
name|pio_desc
argument_list|,
name|ESF_DZ_TX_DESC_IS_OPT
argument_list|,
literal|1
argument_list|,
name|ESF_DZ_TX_OPTION_TYPE
argument_list|,
literal|1
argument_list|,
name|ESF_DZ_TX_PIO_CONT
argument_list|,
literal|0
argument_list|,
name|ESF_DZ_TX_PIO_BYTE_CNT
argument_list|,
name|pkt_length
argument_list|,
name|ESF_DZ_TX_PIO_BUF_ADDR
argument_list|,
name|etp
operator|->
name|et_pio_offset
argument_list|)
expr_stmt|;
name|EFSYS_MEM_WRITEQ
argument_list|(
name|etp
operator|->
name|et_esmp
argument_list|,
name|offset
argument_list|,
operator|&
name|pio_desc
argument_list|)
expr_stmt|;
name|EFX_TX_QSTAT_INCR
argument_list|(
name|etp
argument_list|,
name|TX_POST_PIO
argument_list|)
expr_stmt|;
operator|*
name|addedp
operator|=
name|added
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qpost
argument_list|(
name|__in
name|efx_txq_t
operator|*
name|etp
argument_list|,
name|__in_ecount
argument_list|(
argument|n
argument_list|)
name|efx_buffer_t
operator|*
name|eb
argument_list|,
name|__in
name|unsigned
name|int
name|n
argument_list|,
name|__in
name|unsigned
name|int
name|completed
argument_list|,
name|__inout
name|unsigned
name|int
operator|*
name|addedp
argument_list|)
block|{
name|unsigned
name|int
name|added
init|=
operator|*
name|addedp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|added
operator|-
name|completed
operator|+
name|n
operator|>
name|EFX_TXQ_LIMIT
argument_list|(
name|etp
operator|->
name|et_mask
operator|+
literal|1
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|efx_buffer_t
modifier|*
name|ebp
init|=
operator|&
name|eb
index|[
name|i
index|]
decl_stmt|;
name|efsys_dma_addr_t
name|addr
init|=
name|ebp
operator|->
name|eb_addr
decl_stmt|;
name|size_t
name|size
init|=
name|ebp
operator|->
name|eb_size
decl_stmt|;
name|boolean_t
name|eop
init|=
name|ebp
operator|->
name|eb_eop
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|efx_qword_t
name|qword
decl_stmt|;
comment|/* Fragments must not span 4k boundaries. */
name|EFSYS_ASSERT
argument_list|(
name|P2ROUNDUP
argument_list|(
name|addr
operator|+
literal|1
argument_list|,
literal|4096
argument_list|)
operator|>=
operator|(
name|addr
operator|+
name|size
operator|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|added
operator|++
operator|&
name|etp
operator|->
name|et_mask
expr_stmt|;
name|offset
operator|=
name|id
operator|*
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
name|EFSYS_PROBE5
argument_list|(
argument|tx_post
argument_list|,
argument|unsigned int
argument_list|,
argument|etp->et_index
argument_list|,
argument|unsigned int
argument_list|,
argument|id
argument_list|,
argument|efsys_dma_addr_t
argument_list|,
argument|addr
argument_list|,
argument|size_t
argument_list|,
argument|size
argument_list|,
argument|boolean_t
argument_list|,
argument|eop
argument_list|)
empty_stmt|;
name|EFX_POPULATE_QWORD_5
argument_list|(
name|qword
argument_list|,
name|ESF_DZ_TX_KER_TYPE
argument_list|,
literal|0
argument_list|,
name|ESF_DZ_TX_KER_CONT
argument_list|,
operator|(
name|eop
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|ESF_DZ_TX_KER_BYTE_CNT
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
argument_list|)
argument_list|,
name|ESF_DZ_TX_KER_BUF_ADDR_DW0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
name|ESF_DZ_TX_KER_BUF_ADDR_DW1
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|EFSYS_MEM_WRITEQ
argument_list|(
name|etp
operator|->
name|et_esmp
argument_list|,
name|offset
argument_list|,
operator|&
name|qword
argument_list|)
expr_stmt|;
block|}
name|EFX_TX_QSTAT_INCR
argument_list|(
name|etp
argument_list|,
name|TX_POST
argument_list|)
expr_stmt|;
operator|*
name|addedp
operator|=
name|added
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * This improves performance by pushing a TX descriptor at the same time as the  * doorbell. The descriptor must be added to the TXQ, so that can be used if the  * hardware decides not to use the pushed descriptor.  */
end_comment

begin_function
name|void
name|hunt_tx_qpush
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|,
name|__in
name|unsigned
name|int
name|added
parameter_list|,
name|__in
name|unsigned
name|int
name|pushed
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|etp
operator|->
name|et_enp
decl_stmt|;
name|unsigned
name|int
name|wptr
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|efx_qword_t
name|desc
decl_stmt|;
name|efx_oword_t
name|oword
decl_stmt|;
name|wptr
operator|=
name|added
operator|&
name|etp
operator|->
name|et_mask
expr_stmt|;
name|id
operator|=
name|pushed
operator|&
name|etp
operator|->
name|et_mask
expr_stmt|;
name|offset
operator|=
name|id
operator|*
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
name|EFSYS_MEM_READQ
argument_list|(
name|etp
operator|->
name|et_esmp
argument_list|,
name|offset
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|EFX_POPULATE_OWORD_3
argument_list|(
name|oword
argument_list|,
name|ERF_DZ_TX_DESC_WPTR
argument_list|,
name|wptr
argument_list|,
name|ERF_DZ_TX_DESC_HWORD
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
name|desc
argument_list|,
name|EFX_DWORD_1
argument_list|)
argument_list|,
name|ERF_DZ_TX_DESC_LWORD
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
name|desc
argument_list|,
name|EFX_DWORD_0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Guarantee ordering of memory (descriptors) and PIO (doorbell) */
name|EFX_DMA_SYNC_QUEUE_FOR_DEVICE
argument_list|(
name|etp
operator|->
name|et_esmp
argument_list|,
name|etp
operator|->
name|et_mask
operator|+
literal|1
argument_list|,
name|wptr
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|EFSYS_PIO_WRITE_BARRIER
argument_list|()
expr_stmt|;
name|EFX_BAR_TBL_DOORBELL_WRITEO
argument_list|(
name|enp
argument_list|,
name|ER_DZ_TX_DESC_UPD_REG
argument_list|,
name|etp
operator|->
name|et_index
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qdesc_post
argument_list|(
name|__in
name|efx_txq_t
operator|*
name|etp
argument_list|,
name|__in_ecount
argument_list|(
argument|n
argument_list|)
name|efx_desc_t
operator|*
name|ed
argument_list|,
name|__in
name|unsigned
name|int
name|n
argument_list|,
name|__in
name|unsigned
name|int
name|completed
argument_list|,
name|__inout
name|unsigned
name|int
operator|*
name|addedp
argument_list|)
block|{
name|unsigned
name|int
name|added
init|=
operator|*
name|addedp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|added
operator|-
name|completed
operator|+
name|n
operator|>
name|EFX_TXQ_LIMIT
argument_list|(
name|etp
operator|->
name|et_mask
operator|+
literal|1
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|efx_desc_t
modifier|*
name|edp
init|=
operator|&
name|ed
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|id
operator|=
name|added
operator|++
operator|&
name|etp
operator|->
name|et_mask
expr_stmt|;
name|offset
operator|=
name|id
operator|*
sizeof|sizeof
argument_list|(
name|efx_desc_t
argument_list|)
expr_stmt|;
name|EFSYS_MEM_WRITEQ
argument_list|(
name|etp
operator|->
name|et_esmp
argument_list|,
name|offset
argument_list|,
operator|&
name|edp
operator|->
name|ed_eq
argument_list|)
expr_stmt|;
block|}
name|EFSYS_PROBE3
argument_list|(
argument|tx_desc_post
argument_list|,
argument|unsigned int
argument_list|,
argument|etp->et_index
argument_list|,
argument|unsigned int
argument_list|,
argument|added
argument_list|,
argument|unsigned int
argument_list|,
argument|n
argument_list|)
empty_stmt|;
name|EFX_TX_QSTAT_INCR
argument_list|(
name|etp
argument_list|,
name|TX_POST
argument_list|)
expr_stmt|;
operator|*
name|addedp
operator|=
name|added
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|hunt_tx_qdesc_dma_create
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|,
name|__in
name|efsys_dma_addr_t
name|addr
parameter_list|,
name|__in
name|size_t
name|size
parameter_list|,
name|__in
name|boolean_t
name|eop
parameter_list|,
name|__out
name|efx_desc_t
modifier|*
name|edp
parameter_list|)
block|{
comment|/* Fragments must not span 4k boundaries. */
name|EFSYS_ASSERT
argument_list|(
name|P2ROUNDUP
argument_list|(
name|addr
operator|+
literal|1
argument_list|,
literal|4096
argument_list|)
operator|>=
name|addr
operator|+
name|size
argument_list|)
expr_stmt|;
name|EFSYS_PROBE4
argument_list|(
argument|tx_desc_dma_create
argument_list|,
argument|unsigned int
argument_list|,
argument|etp->et_index
argument_list|,
argument|efsys_dma_addr_t
argument_list|,
argument|addr
argument_list|,
argument|size_t
argument_list|,
argument|size
argument_list|,
argument|boolean_t
argument_list|,
argument|eop
argument_list|)
empty_stmt|;
name|EFX_POPULATE_QWORD_5
argument_list|(
name|edp
operator|->
name|ed_eq
argument_list|,
name|ESF_DZ_TX_KER_TYPE
argument_list|,
literal|0
argument_list|,
name|ESF_DZ_TX_KER_CONT
argument_list|,
operator|(
name|eop
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|ESF_DZ_TX_KER_BYTE_CNT
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
argument_list|)
argument_list|,
name|ESF_DZ_TX_KER_BUF_ADDR_DW0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
name|ESF_DZ_TX_KER_BUF_ADDR_DW1
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hunt_tx_qdesc_tso_create
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|,
name|__in
name|uint16_t
name|ipv4_id
parameter_list|,
name|__in
name|uint32_t
name|tcp_seq
parameter_list|,
name|__in
name|uint8_t
name|tcp_flags
parameter_list|,
name|__out
name|efx_desc_t
modifier|*
name|edp
parameter_list|)
block|{
name|EFSYS_PROBE4
argument_list|(
argument|tx_desc_tso_create
argument_list|,
argument|unsigned int
argument_list|,
argument|etp->et_index
argument_list|,
argument|uint16_t
argument_list|,
argument|ipv4_id
argument_list|,
argument|uint32_t
argument_list|,
argument|tcp_seq
argument_list|,
argument|uint8_t
argument_list|,
argument|tcp_flags
argument_list|)
empty_stmt|;
name|EFX_POPULATE_QWORD_5
argument_list|(
name|edp
operator|->
name|ed_eq
argument_list|,
name|ESF_DZ_TX_DESC_IS_OPT
argument_list|,
literal|1
argument_list|,
name|ESF_DZ_TX_OPTION_TYPE
argument_list|,
name|ESE_DZ_TX_OPTION_DESC_TSO
argument_list|,
name|ESF_DZ_TX_TSO_TCP_FLAGS
argument_list|,
name|tcp_flags
argument_list|,
name|ESF_DZ_TX_TSO_IP_ID
argument_list|,
name|ipv4_id
argument_list|,
name|ESF_DZ_TX_TSO_TCP_SEQNO
argument_list|,
name|tcp_seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hunt_tx_qdesc_vlantci_create
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|,
name|__in
name|uint16_t
name|tci
parameter_list|,
name|__out
name|efx_desc_t
modifier|*
name|edp
parameter_list|)
block|{
name|EFSYS_PROBE2
argument_list|(
argument|tx_desc_vlantci_create
argument_list|,
argument|unsigned int
argument_list|,
argument|etp->et_index
argument_list|,
argument|uint16_t
argument_list|,
argument|tci
argument_list|)
empty_stmt|;
name|EFX_POPULATE_QWORD_4
argument_list|(
name|edp
operator|->
name|ed_eq
argument_list|,
name|ESF_DZ_TX_DESC_IS_OPT
argument_list|,
literal|1
argument_list|,
name|ESF_DZ_TX_OPTION_TYPE
argument_list|,
name|ESE_DZ_TX_OPTION_DESC_VLAN
argument_list|,
name|ESF_DZ_TX_VLAN_OP
argument_list|,
name|tci
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ESF_DZ_TX_VLAN_TAG1
argument_list|,
name|tci
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qpace
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|,
name|__in
name|unsigned
name|int
name|ns
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* FIXME */
name|_NOTE
argument_list|(
argument|ARGUNUSED(etp, ns)
argument_list|)
if|if
condition|(
name|B_FALSE
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* FIXME */
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_tx_qflush
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|etp
operator|->
name|et_enp
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_fini_txq
argument_list|(
name|enp
argument_list|,
name|etp
operator|->
name|et_index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hunt_tx_qenable
parameter_list|(
name|__in
name|efx_txq_t
modifier|*
name|etp
parameter_list|)
block|{
comment|/* FIXME */
name|_NOTE
argument_list|(
argument|ARGUNUSED(etp)
argument_list|)
comment|/* FIXME */
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_QSTATS
end_if

begin_decl_stmt
name|void
name|hunt_tx_qstats_update
argument_list|(
name|__in
name|efx_txq_t
operator|*
name|etp
argument_list|,
name|__inout_ecount
argument_list|(
argument|TX_NQSTATS
argument_list|)
name|efsys_stat_t
operator|*
name|stat
argument_list|)
block|{
comment|/* 	 * TBD: Consider a common Siena/Huntington function.  The code is 	 * essentially identical. 	 */
name|unsigned
name|int
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|TX_NQSTATS
condition|;
name|id
operator|++
control|)
block|{
name|efsys_stat_t
modifier|*
name|essp
init|=
operator|&
name|stat
index|[
name|id
index|]
decl_stmt|;
name|EFSYS_STAT_INCR
argument_list|(
name|essp
argument_list|,
name|etp
operator|->
name|et_stat
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|etp
operator|->
name|et_stat
index|[
name|id
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_QSTATS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON */
end_comment

end_unit

