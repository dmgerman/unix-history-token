begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2007-2009 Solarflare Communications Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_types.h"
end_include

begin_include
include|#
directive|include
file|"efx_regs.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_QSTATS
end_if

begin_define
define|#
directive|define
name|EFX_EV_QSTAT_INCR
parameter_list|(
name|_eep
parameter_list|,
name|_stat
parameter_list|)
define|\
value|do {								\ 		(_eep)->ee_stat[_stat]++;				\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EFX_EV_QSTAT_INCR
parameter_list|(
name|_eep
parameter_list|,
name|_stat
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|__checkReturn
name|int
name|efx_ev_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_oword_t
name|oword
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_mod_flags
operator|&
name|EFX_MOD_EV
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_ev_qcount
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Program the event queue for receive and transmit queue 	 * flush events. 	 */
name|EFX_BAR_READO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_DP_CTRL_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|EFX_SET_OWORD_FIELD
argument_list|(
name|oword
argument_list|,
name|FRF_AZ_FLS_EVQ_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_DP_CTRL_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator||=
name|EFX_MOD_EV
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|efx_ev_rx_not_ok
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
name|uint32_t
name|label
parameter_list|,
name|__in
name|uint32_t
name|id
parameter_list|,
name|__inout
name|uint16_t
modifier|*
name|flagsp
parameter_list|)
block|{
name|boolean_t
name|ignore
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_TOBE_DISC
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_TOBE_DISC
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|tobe_disc
argument_list|)
expr_stmt|;
comment|/* Assume this is a unicast address mismatch, unless below 		 * we find either FSF_AZ_RX_EV_ETH_CRC_ERR or 		 * EV_RX_PAUSE_FRM_ERR is set. 		 */
operator|(
operator|*
name|flagsp
operator|)
operator||=
name|EFX_ADDR_MISMATCH
expr_stmt|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_FRM_TRUNC
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFSYS_PROBE2
argument_list|(
name|frm_trunc
argument_list|,
name|uint32_t
argument_list|,
name|label
argument_list|,
name|uint32_t
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_FRM_TRUNC
argument_list|)
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator||=
name|EFX_DISCARD
expr_stmt|;
if|#
directive|if
operator|(
name|EFSYS_OPT_RX_HDR_SPLIT
operator|||
name|EFSYS_OPT_RX_SCATTER
operator|)
comment|/* Lookout for payload queue ran dry errors and ignore them. 		 * 		 * Sadly for the header/data split cases, the descriptor 		 * pointer in this event refers to the header queue and 		 * therefore cannot be easily detected as duplicate. 		 * So we drop these and rely on the receive processing seeing 		 * a subsequent packet with FSF_AZ_RX_EV_SOP set to discard 		 * the partially received packet. 		 */
if|if
condition|(
operator|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_SOP
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_JUMBO_CONT
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_BYTE_CNT
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|ignore
operator|=
name|B_TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_RX_HDR_SPLIT || EFSYS_OPT_RX_SCATTER */
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_ETH_CRC_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_ETH_CRC_ERR
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|crc_err
argument_list|)
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator|&=
operator|~
name|EFX_ADDR_MISMATCH
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator||=
name|EFX_DISCARD
expr_stmt|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_PAUSE_FRM_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_PAUSE_FRM_ERR
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|pause_frm_err
argument_list|)
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator|&=
operator|~
name|EFX_ADDR_MISMATCH
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator||=
name|EFX_DISCARD
expr_stmt|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_BUF_OWNER_ID_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_BUF_OWNER_ID_ERR
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|owner_id_err
argument_list|)
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator||=
name|EFX_DISCARD
expr_stmt|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_IPV4_HDR_CHKSUM_ERR
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|ipv4_err
argument_list|)
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator|&=
operator|~
name|EFX_CKSUM_IPV4
expr_stmt|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_TCP_UDP_CHKSUM_ERR
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|udp_chk_err
argument_list|)
expr_stmt|;
operator|(
operator|*
name|flagsp
operator|)
operator|&=
operator|~
name|EFX_CKSUM_TCPUDP
expr_stmt|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_IP_FRAG_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_IP_FRAG_ERR
argument_list|)
expr_stmt|;
comment|/* 		 * If IP is fragmented FSF_AZ_RX_EV_IP_FRAG_ERR is set. This 		 * causes FSF_AZ_RX_EV_PKT_OK to be clear. This is not an error 		 * condition. 		 */
operator|(
operator|*
name|flagsp
operator|)
operator|&=
operator|~
operator|(
name|EFX_PKT_TCP
operator||
name|EFX_PKT_UDP
operator||
name|EFX_CKSUM_TCPUDP
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|ignore
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|efx_ev_rx
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|label
decl_stmt|;
name|boolean_t
name|ok
decl_stmt|;
if|#
directive|if
operator|(
name|EFSYS_OPT_RX_HDR_SPLIT
operator|||
name|EFSYS_OPT_RX_SCATTER
operator|)
name|boolean_t
name|sop
decl_stmt|;
name|boolean_t
name|jumbo_cont
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_RX_HDR_SPLIT || EFSYS_OPT_RX_SCATTER */
name|uint32_t
name|hdr_type
decl_stmt|;
name|boolean_t
name|is_v6
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|boolean_t
name|ignore
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX
argument_list|)
expr_stmt|;
comment|/* Basic packet information */
name|id
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_DESC_PTR
argument_list|)
expr_stmt|;
name|size
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_BYTE_CNT
argument_list|)
expr_stmt|;
name|label
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_Q_LABEL
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_PKT_OK
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|EFSYS_OPT_RX_HDR_SPLIT
operator|||
name|EFSYS_OPT_RX_SCATTER
operator|)
name|sop
operator|=
operator|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_SOP
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|jumbo_cont
operator|=
operator|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_JUMBO_CONT
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_RX_HDR_SPLIT || EFSYS_OPT_RX_SCATTER */
name|hdr_type
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_HDR_TYPE
argument_list|)
expr_stmt|;
name|is_v6
operator|=
operator|(
name|enp
operator|->
name|en_family
operator|!=
name|EFX_FAMILY_FALCON
operator|&&
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_CZ_RX_EV_IPV6_PKT
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * If packet is marked as OK and packet type is TCP/IP or 	 * UDP/IP or other IP, then we can rely on the hardware checksums. 	 */
switch|switch
condition|(
name|hdr_type
condition|)
block|{
case|case
name|FSE_AZ_RX_EV_HDR_TYPE_IPV4V6_TCP
case|:
name|flags
operator|=
name|EFX_PKT_TCP
operator||
name|EFX_CKSUM_TCPUDP
expr_stmt|;
if|if
condition|(
name|is_v6
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_TCP_IPV6
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_IPV6
expr_stmt|;
block|}
else|else
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_TCP_IPV4
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_IPV4
operator||
name|EFX_CKSUM_IPV4
expr_stmt|;
block|}
break|break;
case|case
name|FSE_AZ_RX_EV_HDR_TYPE_IPV4V6_UDP
case|:
name|flags
operator|=
name|EFX_PKT_UDP
operator||
name|EFX_CKSUM_TCPUDP
expr_stmt|;
if|if
condition|(
name|is_v6
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_UDP_IPV6
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_IPV6
expr_stmt|;
block|}
else|else
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_UDP_IPV4
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_IPV4
operator||
name|EFX_CKSUM_IPV4
expr_stmt|;
block|}
break|break;
case|case
name|FSE_AZ_RX_EV_HDR_TYPE_IPV4V6_OTHER
case|:
if|if
condition|(
name|is_v6
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_OTHER_IPV6
argument_list|)
expr_stmt|;
name|flags
operator|=
name|EFX_PKT_IPV6
expr_stmt|;
block|}
else|else
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_OTHER_IPV4
argument_list|)
expr_stmt|;
name|flags
operator|=
name|EFX_PKT_IPV4
operator||
name|EFX_CKSUM_IPV4
expr_stmt|;
block|}
break|break;
case|case
name|FSE_AZ_RX_EV_HDR_TYPE_OTHER
case|:
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_NON_IP
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|EFSYS_ASSERT
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|EFSYS_OPT_RX_SCATTER
operator|||
name|EFSYS_OPT_RX_HDR_SPLIT
comment|/* Report scatter and header/lookahead split buffer flags */
if|if
condition|(
name|sop
condition|)
name|flags
operator||=
name|EFX_PKT_START
expr_stmt|;
if|if
condition|(
name|jumbo_cont
condition|)
name|flags
operator||=
name|EFX_PKT_CONT
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_RX_SCATTER || EFSYS_OPT_RX_HDR_SPLIT */
comment|/* Detect errors included in the FSF_AZ_RX_EV_PKT_OK indication */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|ignore
operator|=
name|efx_ev_rx_not_ok
argument_list|(
name|eep
argument_list|,
name|eqp
argument_list|,
name|label
argument_list|,
name|id
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
block|{
name|EFSYS_PROBE4
argument_list|(
name|rx_complete
argument_list|,
name|uint32_t
argument_list|,
name|label
argument_list|,
name|uint32_t
argument_list|,
name|id
argument_list|,
name|uint32_t
argument_list|,
name|size
argument_list|,
name|uint16_t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
comment|/* If we're not discarding the packet then it is ok */
if|if
condition|(
operator|~
name|flags
operator|&
name|EFX_DISCARD
condition|)
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_OK
argument_list|)
expr_stmt|;
comment|/* Detect multicast packets that didn't match the filter */
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_MCAST_PKT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_MCAST_PKT
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_MCAST_HASH_MATCH
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_MCAST_HASH_MATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EFSYS_PROBE
argument_list|(
name|mcast_mismatch
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_ADDR_MISMATCH
expr_stmt|;
block|}
block|}
else|else
block|{
name|flags
operator||=
name|EFX_PKT_UNICAST
expr_stmt|;
block|}
comment|/* 	 * The packet parser in Siena can abort parsing packets under 	 * certain error conditions, setting the PKT_NOT_PARSED bit 	 * (which clears PKT_OK). If this is set, then don't trust 	 * the PKT_TYPE field. 	 */
if|if
condition|(
name|enp
operator|->
name|en_family
operator|!=
name|EFX_FAMILY_FALCON
operator|&&
operator|!
name|ok
condition|)
block|{
name|uint32_t
name|parse_err
decl_stmt|;
name|parse_err
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_CZ_RX_EV_PKT_NOT_PARSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_err
operator|!=
literal|0
condition|)
name|flags
operator||=
name|EFX_CHECK_VLAN
expr_stmt|;
block|}
if|if
condition|(
operator|~
name|flags
operator|&
name|EFX_CHECK_VLAN
condition|)
block|{
name|uint32_t
name|pkt_type
decl_stmt|;
name|pkt_type
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_RX_EV_PKT_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_type
operator|>=
name|FSE_AZ_RX_EV_PKT_TYPE_VLAN
condition|)
name|flags
operator||=
name|EFX_PKT_VLAN_TAGGED
expr_stmt|;
block|}
name|EFSYS_PROBE4
argument_list|(
name|rx_complete
argument_list|,
name|uint32_t
argument_list|,
name|label
argument_list|,
name|uint32_t
argument_list|,
name|id
argument_list|,
name|uint32_t
argument_list|,
name|size
argument_list|,
name|uint16_t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_rx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_rx
argument_list|(
name|arg
argument_list|,
name|label
argument_list|,
name|id
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|efx_ev_tx
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|label
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_COMP
argument_list|)
operator|!=
literal|0
operator|&&
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_PKT_ERR
argument_list|)
operator|==
literal|0
operator|&&
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_PKT_TOO_BIG
argument_list|)
operator|==
literal|0
operator|&&
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_WQ_FF_FULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|id
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_DESC_PTR
argument_list|)
expr_stmt|;
name|label
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_Q_LABEL
argument_list|)
expr_stmt|;
name|EFSYS_PROBE2
argument_list|(
name|tx_complete
argument_list|,
name|uint32_t
argument_list|,
name|label
argument_list|,
name|uint32_t
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_tx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_tx
argument_list|(
name|arg
argument_list|,
name|label
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_COMP
argument_list|)
operator|!=
literal|0
condition|)
name|EFSYS_PROBE3
argument_list|(
argument|bad_event
argument_list|,
argument|unsigned int
argument_list|,
argument|eep->ee_index
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_1)
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_0)
argument_list|)
empty_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_PKT_ERR
argument_list|)
operator|!=
literal|0
condition|)
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_TX_PKT_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_PKT_TOO_BIG
argument_list|)
operator|!=
literal|0
condition|)
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_TX_PKT_TOO_BIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_TX_EV_WQ_FF_FULL
argument_list|)
operator|!=
literal|0
condition|)
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_TX_WQ_FF_FULL
argument_list|)
expr_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_TX_UNEXPECTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|efx_ev_global
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_GLOBAL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|B_FALSE
expr_stmt|;
comment|/* Check for a link management event */
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_BZ_GLB_EV_XG_MNT_INTR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_GLOBAL_MNT
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|xg_mgt
argument_list|)
expr_stmt|;
name|epp
operator|->
name|ep_mac_poll_needed
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|efx_ev_driver
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|B_FALSE
expr_stmt|;
switch|switch
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_DRIVER_EV_SUBCODE
argument_list|)
condition|)
block|{
case|case
name|FSE_AZ_TX_DESCQ_FLS_DONE_EV
case|:
block|{
name|uint32_t
name|txq_index
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_TX_DESCQ_FLS_DONE
argument_list|)
expr_stmt|;
name|txq_index
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_DRIVER_EV_SUBDATA
argument_list|)
expr_stmt|;
name|EFSYS_PROBE1
argument_list|(
name|tx_descq_fls_done
argument_list|,
name|uint32_t
argument_list|,
name|txq_index
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_txq_flush_done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_txq_flush_done
argument_list|(
name|arg
argument_list|,
name|txq_index
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FSE_AZ_RX_DESCQ_FLS_DONE_EV
case|:
block|{
name|uint32_t
name|rxq_index
decl_stmt|;
name|uint32_t
name|failed
decl_stmt|;
name|rxq_index
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_DRIVER_EV_RX_DESCQ_ID
argument_list|)
expr_stmt|;
name|failed
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_rxq_flush_done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_rxq_flush_failed
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_RX_DESCQ_FLS_FAILED
argument_list|)
expr_stmt|;
name|EFSYS_PROBE1
argument_list|(
name|rx_descq_fls_failed
argument_list|,
name|uint32_t
argument_list|,
name|rxq_index
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_rxq_flush_failed
argument_list|(
name|arg
argument_list|,
name|rxq_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_RX_DESCQ_FLS_DONE
argument_list|)
expr_stmt|;
name|EFSYS_PROBE1
argument_list|(
name|rx_descq_fls_done
argument_list|,
name|uint32_t
argument_list|,
name|rxq_index
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_rxq_flush_done
argument_list|(
name|arg
argument_list|,
name|rxq_index
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|FSE_AZ_EVQ_INIT_DONE_EV
case|:
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_initialized
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_initialized
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSE_AZ_EVQ_NOT_EN_EV
case|:
name|EFSYS_PROBE
argument_list|(
name|evq_not_en
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSE_AZ_SRM_UPD_DONE_EV
case|:
block|{
name|uint32_t
name|code
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_SRM_UPD_DONE
argument_list|)
expr_stmt|;
name|code
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_DRIVER_EV_SUBDATA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_sram
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_sram
argument_list|(
name|arg
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FSE_AZ_WAKE_UP_EV
case|:
block|{
name|uint32_t
name|id
decl_stmt|;
name|id
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_DRIVER_EV_SUBDATA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_wake_up
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_wake_up
argument_list|(
name|arg
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FSE_AZ_TX_PKT_NON_TCP_UDP
case|:
name|EFSYS_PROBE
argument_list|(
name|tx_pkt_non_tcp_udp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSE_AZ_TIMER_EV
case|:
block|{
name|uint32_t
name|id
decl_stmt|;
name|id
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_DRIVER_EV_SUBDATA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_timer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_timer
argument_list|(
name|arg
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FSE_AZ_RX_DSC_ERROR_EV
case|:
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_RX_DSC_ERROR
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|rx_dsc_error
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_exception
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_RX_DSC_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSE_AZ_TX_DSC_ERROR_EV
case|:
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_TX_DSC_ERROR
argument_list|)
expr_stmt|;
name|EFSYS_PROBE
argument_list|(
name|tx_dsc_error
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_exception
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_TX_DSC_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|efx_ev_drv_gen
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRV_GEN
argument_list|)
expr_stmt|;
name|data
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|FSF_AZ_EV_DATA_DW0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|>=
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
name|EFSYS_PROBE3
argument_list|(
argument|bad_event
argument_list|,
argument|unsigned int
argument_list|,
argument|eep->ee_index
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_1)
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_0)
argument_list|)
empty_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_software
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_software
argument_list|(
name|arg
argument_list|,
operator|(
name|uint16_t
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_MCDI
end_if

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|efx_ev_mcdi
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
name|boolean_t
name|should_abort
init|=
name|B_FALSE
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_family
operator|!=
name|EFX_FAMILY_SIENA
condition|)
goto|goto
name|out
goto|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_MCDI_RESPONSE
argument_list|)
expr_stmt|;
name|code
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|MCDI_EVENT_CODE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MCDI_EVENT_CODE_BADSSERT
case|:
name|efx_mcdi_ev_death
argument_list|(
name|enp
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_CODE_CMDDONE
case|:
name|efx_mcdi_ev_cpl
argument_list|(
name|enp
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|CMDDONE_SEQ
argument_list|)
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|CMDDONE_DATALEN
argument_list|)
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|CMDDONE_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_CODE_LINKCHANGE
case|:
block|{
name|efx_link_mode_t
name|link_mode
decl_stmt|;
name|siena_phy_link_ev
argument_list|(
name|enp
argument_list|,
name|eqp
argument_list|,
operator|&
name|link_mode
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_link_change
argument_list|(
name|arg
argument_list|,
name|link_mode
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_SENSOREVT
case|:
block|{
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|efx_mon_stat_t
name|id
decl_stmt|;
name|efx_mon_stat_value_t
name|value
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_mon_ev
argument_list|(
name|enp
argument_list|,
name|eqp
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|should_abort
operator|=
name|eecp
operator|->
name|eec_monitor
argument_list|(
name|arg
argument_list|,
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|==
name|ENOTSUP
condition|)
block|{
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_UNKNOWN_SENSOREVT
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|DATA
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|EFSYS_ASSERT
argument_list|(
name|rc
operator|==
name|ENODEV
argument_list|)
expr_stmt|;
comment|/* Wrong port */
else|#
directive|else
name|should_abort
operator|=
name|B_FALSE
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_SCHEDERR
case|:
comment|/* Informational only */
break|break;
case|case
name|MCDI_EVENT_CODE_REBOOT
case|:
name|efx_mcdi_ev_death
argument_list|(
name|enp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_CODE_MAC_STATS_DMA
case|:
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
if|if
condition|(
name|eecp
operator|->
name|eec_mac_stats
operator|!=
name|NULL
condition|)
block|{
name|eecp
operator|->
name|eec_mac_stats
argument_list|(
name|arg
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|MAC_STATS_DMA_GENERATION
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|MCDI_EVENT_CODE_FWALERT
case|:
block|{
name|uint32_t
name|reason
init|=
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|FWALERT_REASON
argument_list|)
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|MCDI_EVENT_FWALERT_REASON_SRAM_ACCESS
condition|)
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_FWALERT_SRAM
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|FWALERT_DATA
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_UNKNOWN_FWALERT
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|DATA
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|EFSYS_PROBE1
argument_list|(
name|mc_pcol_error
argument_list|,
name|int
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_SIENA */
end_comment

begin_function
name|__checkReturn
name|int
name|efx_ev_qprime
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|uint32_t
name|rptr
decl_stmt|;
name|efx_dword_t
name|dword
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|enp
operator|->
name|en_mod_flags
operator|&
name|EFX_MOD_INTR
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|rptr
operator|=
name|count
operator|&
name|eep
operator|->
name|ee_mask
expr_stmt|;
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dword
argument_list|,
name|FRF_AZ_EVQ_RPTR
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|FR_AZ_EVQ_RPTR_REG
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|boolean_t
name|efx_ev_qpending
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|size_t
name|offset
decl_stmt|;
name|efx_qword_t
name|qword
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|count
operator|&
name|eep
operator|->
name|ee_mask
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
name|EFSYS_MEM_READQ
argument_list|(
name|eep
operator|->
name|ee_esmp
argument_list|,
name|offset
argument_list|,
operator|&
name|qword
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFX_QWORD_FIELD
argument_list|(
name|qword
argument_list|,
name|EFX_DWORD_0
argument_list|)
operator|!=
literal|0xffffffff
operator|&&
name|EFX_QWORD_FIELD
argument_list|(
name|qword
argument_list|,
name|EFX_DWORD_1
argument_list|)
operator|!=
literal|0xffffffff
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_EV_PREFETCH
end_if

begin_function
name|void
name|efx_ev_qprefetch
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|unsigned
name|int
name|offset
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|count
operator|&
name|eep
operator|->
name|ee_mask
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
name|EFSYS_MEM_PREFETCH
argument_list|(
name|eep
operator|->
name|ee_esmp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_EV_PREFETCH */
end_comment

begin_define
define|#
directive|define
name|EFX_EV_BATCH
value|8
end_define

begin_define
define|#
directive|define
name|EFX_EV_PRESENT
parameter_list|(
name|_qword
parameter_list|)
define|\
value|(EFX_QWORD_FIELD((_qword), EFX_DWORD_0) != 0xffffffff&&	\ 	EFX_QWORD_FIELD((_qword), EFX_DWORD_1) != 0xffffffff)
end_define

begin_function
name|void
name|efx_ev_qpoll
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__inout
name|unsigned
name|int
modifier|*
name|countp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|efx_qword_t
name|ev
index|[
name|EFX_EV_BATCH
index|]
decl_stmt|;
name|unsigned
name|int
name|batch
decl_stmt|;
name|unsigned
name|int
name|total
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|countp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|count
operator|=
operator|*
name|countp
expr_stmt|;
do|do
block|{
comment|/* Read up until the end of the batch period */
name|batch
operator|=
name|EFX_EV_BATCH
operator|-
operator|(
name|count
operator|&
operator|(
name|EFX_EV_BATCH
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
name|count
operator|&
name|eep
operator|->
name|ee_mask
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
for|for
control|(
name|total
operator|=
literal|0
init|;
name|total
operator|<
name|batch
condition|;
operator|++
name|total
control|)
block|{
name|EFSYS_MEM_READQ
argument_list|(
name|eep
operator|->
name|ee_esmp
argument_list|,
name|offset
argument_list|,
operator|&
operator|(
name|ev
index|[
name|total
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFX_EV_PRESENT
argument_list|(
name|ev
index|[
name|total
index|]
argument_list|)
condition|)
break|break;
name|EFSYS_PROBE3
argument_list|(
argument|event
argument_list|,
argument|unsigned int
argument_list|,
argument|eep->ee_index
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(ev[total], EFX_DWORD_1)
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(ev[total], EFX_DWORD_0)
argument_list|)
empty_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|EFSYS_OPT_EV_PREFETCH
operator|&&
operator|(
name|EFSYS_OPT_EV_PREFETCH_PERIOD
operator|>
literal|1
operator|)
comment|/* 		 * Prefetch the next batch when we get within PREFETCH_PERIOD 		 * of a completed batch. If the batch is smaller, then prefetch 		 * immediately. 		 */
if|if
condition|(
name|total
operator|==
name|batch
operator|&&
name|total
operator|<
name|EFSYS_OPT_EV_PREFETCH_PERIOD
condition|)
name|EFSYS_MEM_PREFETCH
argument_list|(
name|eep
operator|->
name|ee_esmp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_EV_PREFETCH */
comment|/* Process the batch of events */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|total
condition|;
operator|++
name|index
control|)
block|{
name|boolean_t
name|should_abort
decl_stmt|;
name|uint32_t
name|code
decl_stmt|;
name|efx_ev_handler_t
name|handler
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_EV_PREFETCH
comment|/* Prefetch if we've now reached the batch period */
if|if
condition|(
name|total
operator|==
name|batch
operator|&&
name|index
operator|+
name|EFSYS_OPT_EV_PREFETCH_PERIOD
operator|==
name|total
condition|)
block|{
name|offset
operator|=
operator|(
name|count
operator|+
name|batch
operator|)
operator|&
name|eep
operator|->
name|ee_mask
expr_stmt|;
name|offset
operator|*=
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
name|EFSYS_MEM_PREFETCH
argument_list|(
name|eep
operator|->
name|ee_esmp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EFSYS_OPT_EV_PREFETCH */
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_ALL
argument_list|)
expr_stmt|;
name|code
operator|=
name|EFX_QWORD_FIELD
argument_list|(
name|ev
index|[
name|index
index|]
argument_list|,
name|FSF_AZ_EV_CODE
argument_list|)
expr_stmt|;
name|handler
operator|=
name|eep
operator|->
name|ee_handler
index|[
name|code
index|]
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|handler
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|handler
argument_list|(
name|eep
argument_list|,
operator|&
operator|(
name|ev
index|[
name|index
index|]
operator|)
argument_list|,
name|eecp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_abort
condition|)
block|{
comment|/* Ignore subsequent events */
name|total
operator|=
name|index
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Now that the hardware has most likely moved onto dma'ing 		 * into the next cache line, clear the processed events. Take 		 * care to only clear out events that we've processed 		 */
name|EFX_SET_QWORD
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|count
operator|&
name|eep
operator|->
name|ee_mask
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|total
condition|;
operator|++
name|index
control|)
block|{
name|EFSYS_MEM_WRITEQ
argument_list|(
name|eep
operator|->
name|ee_esmp
argument_list|,
name|offset
argument_list|,
operator|&
operator|(
name|ev
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|efx_qword_t
argument_list|)
expr_stmt|;
block|}
name|count
operator|+=
name|total
expr_stmt|;
block|}
do|while
condition|(
name|total
operator|==
name|batch
condition|)
do|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_ev_qpost
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|uint16_t
name|data
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|efx_qword_t
name|ev
decl_stmt|;
name|efx_oword_t
name|oword
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
name|EFX_POPULATE_QWORD_2
argument_list|(
name|ev
argument_list|,
name|FSF_AZ_EV_CODE
argument_list|,
name|FSE_AZ_EV_CODE_DRV_GEN_EV
argument_list|,
name|FSF_AZ_EV_DATA_DW0
argument_list|,
operator|(
name|uint32_t
operator|)
name|data
argument_list|)
expr_stmt|;
name|EFX_POPULATE_OWORD_3
argument_list|(
name|oword
argument_list|,
name|FRF_AZ_DRV_EV_QID
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
name|EFX_DWORD_0
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
name|ev
argument_list|,
name|EFX_DWORD_0
argument_list|)
argument_list|,
name|EFX_DWORD_1
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
name|ev
argument_list|,
name|EFX_DWORD_1
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_DRV_EV_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|int
name|efx_ev_qmoderate
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|unsigned
name|int
name|us
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|unsigned
name|int
name|locked
decl_stmt|;
name|efx_dword_t
name|dword
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|us
operator|>
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_evq_moderation_max
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* If the value is zero then disable the timer */
if|if
condition|(
name|us
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_FALCON
condition|)
name|EFX_POPULATE_DWORD_2
argument_list|(
name|dword
argument_list|,
name|FRF_AB_TC_TIMER_MODE
argument_list|,
name|FFE_AB_TIMER_MODE_DIS
argument_list|,
name|FRF_AB_TC_TIMER_VAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|EFX_POPULATE_DWORD_2
argument_list|(
name|dword
argument_list|,
name|FRF_CZ_TC_TIMER_MODE
argument_list|,
name|FFE_CZ_TIMER_MODE_DIS
argument_list|,
name|FRF_CZ_TC_TIMER_VAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|timer_val
decl_stmt|;
comment|/* Calculate the timer value in quanta */
name|us
operator|-=
operator|(
name|us
operator|%
name|EFX_EV_TIMER_QUANTUM
operator|)
expr_stmt|;
if|if
condition|(
name|us
operator|<
name|EFX_EV_TIMER_QUANTUM
condition|)
name|us
operator|=
name|EFX_EV_TIMER_QUANTUM
expr_stmt|;
name|timer_val
operator|=
name|us
operator|/
name|EFX_EV_TIMER_QUANTUM
expr_stmt|;
comment|/* Moderation value is base 0 so we need to deduct 1 */
if|if
condition|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_FALCON
condition|)
name|EFX_POPULATE_DWORD_2
argument_list|(
name|dword
argument_list|,
name|FRF_AB_TC_TIMER_MODE
argument_list|,
name|FFE_AB_TIMER_MODE_INT_HLDOFF
argument_list|,
name|FRF_AB_TIMER_VAL
argument_list|,
name|timer_val
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|EFX_POPULATE_DWORD_2
argument_list|(
name|dword
argument_list|,
name|FRF_CZ_TC_TIMER_MODE
argument_list|,
name|FFE_CZ_TIMER_MODE_INT_HLDOFF
argument_list|,
name|FRF_CZ_TC_TIMER_VAL
argument_list|,
name|timer_val
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|locked
operator|=
operator|(
name|eep
operator|->
name|ee_index
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|FR_BZ_TIMER_COMMAND_REGP0
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|dword
argument_list|,
name|locked
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|int
name|efx_ev_qcreate
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|,
name|__in
name|size_t
name|n
parameter_list|,
name|__in
name|uint32_t
name|id
parameter_list|,
name|__deref_out
name|efx_evq_t
modifier|*
modifier|*
name|eepp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|efx_evq_t
modifier|*
name|eep
decl_stmt|;
name|efx_oword_t
name|oword
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_EV
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_ev_qcount
operator|+
literal|1
argument_list|,
operator|<
argument_list|,
name|encp
operator|->
name|enc_evq_limit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISP2
argument_list|(
name|n
argument_list|)
operator|||
operator|!
operator|(
name|n
operator|&
name|EFX_EVQ_NEVS_MASK
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|index
operator|>=
name|encp
operator|->
name|enc_evq_limit
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|#
directive|if
name|EFSYS_OPT_RX_SCALE
if|if
condition|(
name|enp
operator|->
name|en_intr
operator|.
name|ei_type
operator|==
name|EFX_INTR_LINE
operator|&&
name|index
operator|>=
name|EFX_MAXRSS_LEGACY
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
endif|#
directive|endif
for|for
control|(
name|size
operator|=
literal|0
init|;
operator|(
literal|1
operator|<<
name|size
operator|)
operator|<=
operator|(
name|EFX_EVQ_MAXNEVS
operator|/
name|EFX_EVQ_MINNEVS
operator|)
condition|;
name|size
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|==
call|(
name|int
call|)
argument_list|(
name|n
operator|/
name|EFX_EVQ_MINNEVS
argument_list|)
condition|)
break|break;
if|if
condition|(
name|id
operator|+
operator|(
literal|1
operator|<<
name|size
operator|)
operator|>=
name|encp
operator|->
name|enc_buftbl_limit
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
comment|/* Allocate an EVQ object */
name|EFSYS_KMEM_ALLOC
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
sizeof|sizeof
argument_list|(
name|efx_evq_t
argument_list|)
argument_list|,
name|eep
argument_list|)
expr_stmt|;
if|if
condition|(
name|eep
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail5
goto|;
block|}
name|eep
operator|->
name|ee_magic
operator|=
name|EFX_EVQ_MAGIC
expr_stmt|;
name|eep
operator|->
name|ee_enp
operator|=
name|enp
expr_stmt|;
name|eep
operator|->
name|ee_index
operator|=
name|index
expr_stmt|;
name|eep
operator|->
name|ee_mask
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|eep
operator|->
name|ee_esmp
operator|=
name|esmp
expr_stmt|;
comment|/* Set up the handler table */
name|eep
operator|->
name|ee_handler
index|[
name|FSE_AZ_EV_CODE_RX_EV
index|]
operator|=
name|efx_ev_rx
expr_stmt|;
name|eep
operator|->
name|ee_handler
index|[
name|FSE_AZ_EV_CODE_TX_EV
index|]
operator|=
name|efx_ev_tx
expr_stmt|;
name|eep
operator|->
name|ee_handler
index|[
name|FSE_AZ_EV_CODE_DRIVER_EV
index|]
operator|=
name|efx_ev_driver
expr_stmt|;
name|eep
operator|->
name|ee_handler
index|[
name|FSE_AZ_EV_CODE_GLOBAL_EV
index|]
operator|=
name|efx_ev_global
expr_stmt|;
name|eep
operator|->
name|ee_handler
index|[
name|FSE_AZ_EV_CODE_DRV_GEN_EV
index|]
operator|=
name|efx_ev_drv_gen
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_MCDI
name|eep
operator|->
name|ee_handler
index|[
name|FSE_AZ_EV_CODE_MCDI_EVRESPONSE
index|]
operator|=
name|efx_ev_mcdi
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_SIENA */
comment|/* Set up the new event queue */
if|if
condition|(
name|enp
operator|->
name|en_family
operator|!=
name|EFX_FAMILY_FALCON
condition|)
block|{
name|EFX_POPULATE_OWORD_1
argument_list|(
name|oword
argument_list|,
name|FRF_CZ_TIMER_Q_EN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_TIMER_TBL
argument_list|,
name|index
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
name|EFX_POPULATE_OWORD_3
argument_list|(
name|oword
argument_list|,
name|FRF_AZ_EVQ_EN
argument_list|,
literal|1
argument_list|,
name|FRF_AZ_EVQ_SIZE
argument_list|,
name|size
argument_list|,
name|FRF_AZ_EVQ_BUF_BASE_ID
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_EVQ_PTR_TBL
argument_list|,
name|index
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_ev_qcount
operator|++
expr_stmt|;
operator|*
name|eepp
operator|=
name|eep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_RX_SCALE
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_NAMES
end_if

begin_comment
comment|/* START MKCONFIG GENERATED EfxEventQueueStatNamesBlock 67e9bdcd920059bd */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|__cs
modifier|*
name|__cs
name|__efx_ev_qstat_name
index|[]
init|=
block|{
literal|"all"
block|,
literal|"rx"
block|,
literal|"rx_ok"
block|,
literal|"rx_recovery"
block|,
literal|"rx_frm_trunc"
block|,
literal|"rx_tobe_disc"
block|,
literal|"rx_pause_frm_err"
block|,
literal|"rx_buf_owner_id_err"
block|,
literal|"rx_ipv4_hdr_chksum_err"
block|,
literal|"rx_tcp_udp_chksum_err"
block|,
literal|"rx_eth_crc_err"
block|,
literal|"rx_ip_frag_err"
block|,
literal|"rx_mcast_pkt"
block|,
literal|"rx_mcast_hash_match"
block|,
literal|"rx_tcp_ipv4"
block|,
literal|"rx_tcp_ipv6"
block|,
literal|"rx_udp_ipv4"
block|,
literal|"rx_udp_ipv6"
block|,
literal|"rx_other_ipv4"
block|,
literal|"rx_other_ipv6"
block|,
literal|"rx_non_ip"
block|,
literal|"rx_overrun"
block|,
literal|"tx"
block|,
literal|"tx_wq_ff_full"
block|,
literal|"tx_pkt_err"
block|,
literal|"tx_pkt_too_big"
block|,
literal|"tx_unexpected"
block|,
literal|"global"
block|,
literal|"global_phy"
block|,
literal|"global_mnt"
block|,
literal|"global_rx_recovery"
block|,
literal|"driver"
block|,
literal|"driver_srm_upd_done"
block|,
literal|"driver_tx_descq_fls_done"
block|,
literal|"driver_rx_descq_fls_done"
block|,
literal|"driver_rx_descq_fls_failed"
block|,
literal|"driver_rx_dsc_error"
block|,
literal|"driver_tx_dsc_error"
block|,
literal|"drv_gen"
block|,
literal|"mcdi_response"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* END MKCONFIG GENERATED EfxEventQueueStatNamesBlock */
end_comment

begin_function
specifier|const
name|char
name|__cs
modifier|*
name|efx_ev_qstat_name
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|id
parameter_list|)
block|{
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|id
argument_list|,
operator|<
argument_list|,
name|EV_NQSTATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|__efx_ev_qstat_name
index|[
name|id
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_NAMES */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_QSTATS
end_if

begin_decl_stmt
name|void
name|efx_ev_qstats_update
argument_list|(
name|__in
name|efx_evq_t
operator|*
name|eep
argument_list|,
name|__inout_ecount
argument_list|(
argument|EV_NQSTATS
argument_list|)
name|efsys_stat_t
operator|*
name|stat
argument_list|)
block|{
name|unsigned
name|int
name|id
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|EV_NQSTATS
condition|;
name|id
operator|++
control|)
block|{
name|efsys_stat_t
modifier|*
name|essp
init|=
operator|&
name|stat
index|[
name|id
index|]
decl_stmt|;
name|EFSYS_STAT_INCR
argument_list|(
name|essp
argument_list|,
name|eep
operator|->
name|ee_stat
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|eep
operator|->
name|ee_stat
index|[
name|id
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_QSTATS */
end_comment

begin_function
name|void
name|efx_ev_qdestroy
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|efx_oword_t
name|oword
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eep
operator|->
name|ee_magic
argument_list|,
operator|==
argument_list|,
name|EFX_EVQ_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_ev_qcount
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|--
name|enp
operator|->
name|en_ev_qcount
expr_stmt|;
comment|/* Purge event queue */
name|EFX_ZERO_OWORD
argument_list|(
name|oword
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_EVQ_PTR_TBL
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_family
operator|!=
name|EFX_FAMILY_FALCON
condition|)
block|{
name|EFX_ZERO_OWORD
argument_list|(
name|oword
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_TIMER_TBL
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
comment|/* Free the EVQ object */
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
sizeof|sizeof
argument_list|(
name|efx_evq_t
argument_list|)
argument_list|,
name|eep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_ev_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_INTR
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_EV
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
operator|!
operator|(
name|enp
operator|->
name|en_mod_flags
operator|&
name|EFX_MOD_RX
operator|)
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
operator|!
operator|(
name|enp
operator|->
name|en_mod_flags
operator|&
name|EFX_MOD_TX
operator|)
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_ev_qcount
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator|&=
operator|~
name|EFX_MOD_EV
expr_stmt|;
block|}
end_function

end_unit

