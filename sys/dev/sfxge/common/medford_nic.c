begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MEDFORD
end_if

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_rxdp_config
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|end_paddingp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_RXDP_CONFIG_IN_LEN
argument_list|,
name|MC_CMD_GET_RXDP_CONFIG_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|end_padding
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_RXDP_CONFIG
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_RXDP_CONFIG_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_RXDP_CONFIG_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_RXDP_CONFIG_OUT_DATA
argument_list|,
name|GET_RXDP_CONFIG_OUT_PAD_HOST_DMA
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* RX DMA end padding is disabled */
name|end_padding
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_RXDP_CONFIG_OUT_DATA
argument_list|,
name|GET_RXDP_CONFIG_OUT_PAD_HOST_LEN
argument_list|)
condition|)
block|{
case|case
name|MC_CMD_SET_RXDP_CONFIG_IN_PAD_HOST_64
case|:
name|end_padding
operator|=
literal|64
expr_stmt|;
break|break;
case|case
name|MC_CMD_SET_RXDP_CONFIG_IN_PAD_HOST_128
case|:
name|end_padding
operator|=
literal|128
expr_stmt|;
break|break;
case|case
name|MC_CMD_SET_RXDP_CONFIG_IN_PAD_HOST_256
case|:
name|end_padding
operator|=
literal|256
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
block|}
operator|*
name|end_paddingp
operator|=
name|end_padding
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|medford_nic_get_required_pcie_bandwidth
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|bandwidth_mbpsp
parameter_list|)
block|{
name|uint32_t
name|port_modes
decl_stmt|;
name|uint32_t
name|current_mode
decl_stmt|;
name|uint32_t
name|bandwidth
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_modes
argument_list|(
name|enp
argument_list|,
operator|&
name|port_modes
argument_list|,
operator|&
name|current_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* No port mode info available. */
name|bandwidth
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_nic_get_port_mode_bandwidth
argument_list|(
name|current_mode
argument_list|,
operator|&
name|bandwidth
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|out
label|:
operator|*
name|bandwidth_mbpsp
operator|=
name|bandwidth
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|medford_board_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint8_t
name|mac_addr
index|[
literal|6
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint32_t
name|board_type
init|=
literal|0
decl_stmt|;
name|ef10_link_state_t
name|els
decl_stmt|;
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|;
name|uint32_t
name|vf
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|sysclk
decl_stmt|,
name|dpcpu_clk
decl_stmt|;
name|uint32_t
name|base
decl_stmt|,
name|nvec
decl_stmt|;
name|uint32_t
name|end_padding
decl_stmt|;
name|uint32_t
name|bandwidth
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * FIXME: Likely to be incomplete and incorrect. 	 * Parts of this should be shared with Huntington. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_assignment
argument_list|(
name|enp
argument_list|,
operator|&
name|port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* 	 * NOTE: The MCDI protocol numbers ports from zero. 	 * The common code MCDI interface numbers ports from one. 	 */
name|emip
operator|->
name|emi_port
operator|=
name|port
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_external_port_mapping
argument_list|(
name|enp
argument_list|,
name|port
argument_list|,
operator|&
name|encp
operator|->
name|enc_external_port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* 	 * Get PCIe function number from firmware (used for 	 * per-function privilege and dynamic config info). 	 *  - PCIe PF: pf = PF number, vf = 0xffff. 	 *  - PCIe VF: pf = parent PF, vf = VF number. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_function_info
argument_list|(
name|enp
argument_list|,
operator|&
name|pf
argument_list|,
operator|&
name|vf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
name|encp
operator|->
name|enc_pf
operator|=
name|pf
expr_stmt|;
name|encp
operator|->
name|enc_vf
operator|=
name|vf
expr_stmt|;
comment|/* MAC address for this function */
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_pf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_ALLOW_UNCONFIGURED_NIC
comment|/* Disable static config checking for Medford NICs, ONLY 		 * for manufacturing test and setup at the factory, to 		 * allow the static config to be installed. 		 */
else|#
directive|else
comment|/* EFSYS_OPT_ALLOW_UNCONFIGURED_NIC */
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
condition|)
block|{
comment|/* 			 * If the static config does not include a global MAC 			 * address pool then the board may return a locally 			 * administered MAC address (this should only happen on 			 * incorrectly programmed boards). 			 */
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EFSYS_OPT_ALLOW_UNCONFIGURED_NIC */
block|}
else|else
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_vf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|encp
operator|->
name|enc_mac_addr
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
comment|/* Board configuration */
name|rc
operator|=
name|efx_mcdi_get_board_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|board_type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* Unprivileged functions may not be able to read board cfg */
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
name|board_type
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|fail5
goto|;
block|}
name|encp
operator|->
name|enc_board_type
operator|=
name|board_type
expr_stmt|;
name|encp
operator|->
name|enc_clk_mult
operator|=
literal|1
expr_stmt|;
comment|/* not used for Medford */
comment|/* Fill out fields in enp->en_port and enp->en_nic_cfg from MCDI */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_phy_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
comment|/* Obtain the default PHY advertised capabilities */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_phy_get_link
argument_list|(
name|enp
argument_list|,
operator|&
name|els
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail7
goto|;
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|=
name|els
operator|.
name|els_adv_cap_mask
expr_stmt|;
name|epp
operator|->
name|ep_adv_cap_mask
operator|=
name|els
operator|.
name|els_adv_cap_mask
expr_stmt|;
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_VF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
comment|/* 		 * Interrupt testing does not work for VFs. See bug50084. 		 * FIXME: Does this still  apply to Medford? 		 */
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* Chained multicast is always enabled on Medford */
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_TRUE
expr_stmt|;
comment|/* Get clock frequencies (in MHz). */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_clock
argument_list|(
name|enp
argument_list|,
operator|&
name|sysclk
argument_list|,
operator|&
name|dpcpu_clk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail8
goto|;
comment|/* 	 * The Medford timer quantum is 1536 dpcpu_clk cycles, documented for 	 * the EV_TMR_VAL field of EV_TIMER_TBL. Scale for MHz and ns units. 	 */
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|=
literal|1536000UL
operator|/
name|dpcpu_clk
expr_stmt|;
comment|/* 1536 cycles */
name|encp
operator|->
name|enc_evq_timer_max_us
operator|=
operator|(
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|<<
name|FRF_CZ_TC_TIMER_VAL_WIDTH
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* Check capabilities of running datapath firmware */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_get_datapath_caps
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail9
goto|;
comment|/* Alignment for receive packet DMA buffers */
name|encp
operator|->
name|enc_rx_buf_align_start
operator|=
literal|1
expr_stmt|;
comment|/* Get the RX DMA end padding alignment configuration */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_rxdp_config
argument_list|(
name|enp
argument_list|,
operator|&
name|end_padding
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail10
goto|;
name|encp
operator|->
name|enc_rx_buf_align_end
operator|=
name|end_padding
expr_stmt|;
comment|/* Alignment for WPTR updates */
name|encp
operator|->
name|enc_rx_push_align
operator|=
name|EF10_RX_WPTR_ALIGN
expr_stmt|;
comment|/* 	 * Set resource limits for MC_CMD_ALLOC_VIS. Note that we cannot use 	 * MC_CMD_GET_RESOURCE_LIMITS here as that reports the available 	 * resources (allocated to this PCIe function), which is zero until 	 * after we have allocated VIs. 	 */
name|encp
operator|->
name|enc_evq_limit
operator|=
literal|1024
expr_stmt|;
name|encp
operator|->
name|enc_rxq_limit
operator|=
name|EFX_RXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_txq_limit
operator|=
name|EFX_TXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_buftbl_limit
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_limit
operator|=
name|MEDFORD_PIOBUF_NBUFS
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_size
operator|=
name|MEDFORD_PIOBUF_SIZE
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_min_alloc_size
operator|=
name|MEDFORD_MIN_PIO_ALLOC_SIZE
expr_stmt|;
comment|/* 	 * Get the current privilege mask. Note that this may be modified 	 * dynamically, so this value is informational only. DO NOT use 	 * the privilege mask to check for sufficient privileges, as that 	 * can result in time-of-check/time-of-use bugs. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_get_privilege_mask
argument_list|(
name|enp
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail11
goto|;
name|encp
operator|->
name|enc_privilege_mask
operator|=
name|mask
expr_stmt|;
comment|/* Get interrupt vector limits */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_vector_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|nvec
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
goto|goto
name|fail12
goto|;
comment|/* Ignore error (cannot query vector limits from a VF). */
name|base
operator|=
literal|0
expr_stmt|;
name|nvec
operator|=
literal|1024
expr_stmt|;
block|}
name|encp
operator|->
name|enc_intr_vec_base
operator|=
name|base
expr_stmt|;
name|encp
operator|->
name|enc_intr_limit
operator|=
name|nvec
expr_stmt|;
comment|/* 	 * Maximum number of bytes into the frame the TCP header can start for 	 * firmware assisted TSO to work. 	 */
name|encp
operator|->
name|enc_tx_tso_tcp_header_offset_limit
operator|=
name|EF10_TCP_HEADER_OFFSET_LIMIT
expr_stmt|;
comment|/* 	 * Medford stores a single global copy of VPD, not per-PF as on 	 * Huntington. 	 */
name|encp
operator|->
name|enc_vpd_is_global
operator|=
name|B_TRUE
expr_stmt|;
name|rc
operator|=
name|medford_nic_get_required_pcie_bandwidth
argument_list|(
name|enp
argument_list|,
operator|&
name|bandwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail13
goto|;
name|encp
operator|->
name|enc_required_pcie_bandwidth_mbps
operator|=
name|bandwidth
expr_stmt|;
name|encp
operator|->
name|enc_max_pcie_link_gen
operator|=
name|EFX_PCIE_LINK_SPEED_GEN3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail13
label|:
name|EFSYS_PROBE
argument_list|(
name|fail13
argument_list|)
expr_stmt|;
name|fail12
label|:
name|EFSYS_PROBE
argument_list|(
name|fail12
argument_list|)
expr_stmt|;
name|fail11
label|:
name|EFSYS_PROBE
argument_list|(
name|fail11
argument_list|)
expr_stmt|;
name|fail10
label|:
name|EFSYS_PROBE
argument_list|(
name|fail10
argument_list|)
expr_stmt|;
name|fail9
label|:
name|EFSYS_PROBE
argument_list|(
name|fail9
argument_list|)
expr_stmt|;
name|fail8
label|:
name|EFSYS_PROBE
argument_list|(
name|fail8
argument_list|)
expr_stmt|;
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MEDFORD */
end_comment

end_unit

