begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_include
include|#
directive|include
file|"mcdi_mon.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MEDFORD
end_if

begin_include
include|#
directive|include
file|"ef10_tlv_layout.h"
end_include

begin_function
name|__checkReturn
name|efx_rc_t
name|medford_board_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint8_t
name|mac_addr
index|[
literal|6
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint32_t
name|board_type
init|=
literal|0
decl_stmt|;
name|hunt_link_state_t
name|hls
decl_stmt|;
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|;
name|uint32_t
name|vf
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|sysclk
decl_stmt|;
name|uint32_t
name|base
decl_stmt|,
name|nvec
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * FIXME: Likely to be incomplete and incorrect. 	 * Parts of this should be shared with Huntington. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_assignment
argument_list|(
name|enp
argument_list|,
operator|&
name|port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* 	 * NOTE: The MCDI protocol numbers ports from zero. 	 * The common code MCDI interface numbers ports from one. 	 */
name|emip
operator|->
name|emi_port
operator|=
name|port
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_external_port_mapping
argument_list|(
name|enp
argument_list|,
name|port
argument_list|,
operator|&
name|encp
operator|->
name|enc_external_port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* 	 * Get PCIe function number from firmware (used for 	 * per-function privilege and dynamic config info). 	 *  - PCIe PF: pf = PF number, vf = 0xffff. 	 *  - PCIe VF: pf = parent PF, vf = VF number. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_function_info
argument_list|(
name|enp
argument_list|,
operator|&
name|pf
argument_list|,
operator|&
name|vf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
name|encp
operator|->
name|enc_pf
operator|=
name|pf
expr_stmt|;
name|encp
operator|->
name|enc_vf
operator|=
name|vf
expr_stmt|;
comment|/* MAC address for this function */
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_pf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
condition|)
block|{
comment|/* 			 * If the static config does not include a global MAC 			 * address pool then the board may return a locally 			 * administered MAC address (this should only happen on 			 * incorrectly programmed boards). 			 */
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_vf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|encp
operator|->
name|enc_mac_addr
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
comment|/* Board configuration */
name|rc
operator|=
name|efx_mcdi_get_board_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|board_type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* Unprivileged functions may not be able to read board cfg */
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
name|board_type
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|fail5
goto|;
block|}
name|encp
operator|->
name|enc_board_type
operator|=
name|board_type
expr_stmt|;
name|encp
operator|->
name|enc_clk_mult
operator|=
literal|1
expr_stmt|;
comment|/* not used for Medford */
comment|/* Fill out fields in enp->en_port and enp->en_nic_cfg from MCDI */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_phy_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
comment|/* Obtain the default PHY advertised capabilities */
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_phy_get_link
argument_list|(
name|enp
argument_list|,
operator|&
name|hls
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail7
goto|;
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|=
name|hls
operator|.
name|hls_adv_cap_mask
expr_stmt|;
name|epp
operator|->
name|ep_adv_cap_mask
operator|=
name|hls
operator|.
name|hls_adv_cap_mask
expr_stmt|;
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_VF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
comment|/* 		 * Interrupt testing does not work for VFs. See bug50084. 		 * FIXME: Does this still  apply to Medford? 		 */
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* Chained multicast is always enabled on Medford */
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_TRUE
expr_stmt|;
comment|/* Get sysclk frequency (in MHz). */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_clock
argument_list|(
name|enp
argument_list|,
operator|&
name|sysclk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail8
goto|;
comment|/* 	 * The timer quantum is 1536 sysclk cycles, documented for the 	 * EV_TMR_VAL field of EV_TIMER_TBL. Scale for MHz and ns units. 	 */
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|=
literal|1536000UL
operator|/
name|sysclk
expr_stmt|;
comment|/* 1536 cycles */
name|encp
operator|->
name|enc_evq_timer_max_us
operator|=
operator|(
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|<<
name|FRF_CZ_TC_TIMER_VAL_WIDTH
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* Check capabilities of running datapath firmware */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_get_datapath_caps
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail9
goto|;
comment|/* Alignment for receive packet DMA buffers */
name|encp
operator|->
name|enc_rx_buf_align_start
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: RX DMA end padding is configurable on Medford */
name|encp
operator|->
name|enc_rx_buf_align_end
operator|=
literal|64
expr_stmt|;
comment|/* Alignment for WPTR updates */
name|encp
operator|->
name|enc_rx_push_align
operator|=
name|EF10_RX_WPTR_ALIGN
expr_stmt|;
comment|/* 	 * Set resource limits for MC_CMD_ALLOC_VIS. Note that we cannot use 	 * MC_CMD_GET_RESOURCE_LIMITS here as that reports the available 	 * resources (allocated to this PCIe function), which is zero until 	 * after we have allocated VIs. 	 */
name|encp
operator|->
name|enc_evq_limit
operator|=
literal|1024
expr_stmt|;
name|encp
operator|->
name|enc_rxq_limit
operator|=
name|EFX_RXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_txq_limit
operator|=
name|EFX_TXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_buftbl_limit
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_limit
operator|=
name|MEDFORD_PIOBUF_NBUFS
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_size
operator|=
name|MEDFORD_PIOBUF_SIZE
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_min_alloc_size
operator|=
name|MEDFORD_MIN_PIO_ALLOC_SIZE
expr_stmt|;
comment|/* 	 * Get the current privilege mask. Note that this may be modified 	 * dynamically, so this value is informational only. DO NOT use 	 * the privilege mask to check for sufficient privileges, as that 	 * can result in time-of-check/time-of-use bugs. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_privilege_mask
argument_list|(
name|enp
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail10
goto|;
name|encp
operator|->
name|enc_privilege_mask
operator|=
name|mask
expr_stmt|;
comment|/* Get interrupt vector limits */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_vector_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|nvec
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
goto|goto
name|fail11
goto|;
comment|/* Ignore error (cannot query vector limits from a VF). */
name|base
operator|=
literal|0
expr_stmt|;
name|nvec
operator|=
literal|1024
expr_stmt|;
block|}
name|encp
operator|->
name|enc_intr_vec_base
operator|=
name|base
expr_stmt|;
name|encp
operator|->
name|enc_intr_limit
operator|=
name|nvec
expr_stmt|;
comment|/* 	 * Maximum number of bytes into the frame the TCP header can start for 	 * firmware assisted TSO to work. 	 */
name|encp
operator|->
name|enc_tx_tso_tcp_header_offset_limit
operator|=
name|EF10_TCP_HEADER_OFFSET_LIMIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail11
label|:
name|EFSYS_PROBE
argument_list|(
name|fail11
argument_list|)
expr_stmt|;
name|fail10
label|:
name|EFSYS_PROBE
argument_list|(
name|fail10
argument_list|)
expr_stmt|;
name|fail9
label|:
name|EFSYS_PROBE
argument_list|(
name|fail9
argument_list|)
expr_stmt|;
name|fail8
label|:
name|EFSYS_PROBE
argument_list|(
name|fail8
argument_list|)
expr_stmt|;
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MEDFORD */
end_comment

end_unit

