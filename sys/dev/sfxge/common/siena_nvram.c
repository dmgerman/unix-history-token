begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_types.h"
end_include

begin_include
include|#
directive|include
file|"efx_regs.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_SIENA
end_if

begin_if
if|#
directive|if
name|EFSYS_OPT_VPD
operator|||
name|EFSYS_OPT_NVRAM
end_if

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_partn_size
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|partn
parameter_list|,
name|__out
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
literal|1
operator|<<
name|partn
operator|)
operator|&
operator|~
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_partn_mask
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_nvram_info
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
name|sizep
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail2
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_partn_lock
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|partn
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_nvram_update_start
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|siena_nvram_partn_read
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|unsigned
name|int
name|partn
argument_list|,
name|__in
name|unsigned
name|int
name|offset
argument_list|,
name|__out_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|)
block|{
name|size_t
name|chunk
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|chunk
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|SIENA_NVRAM_CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_nvram_read
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|chunk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail1
goto|;
block|}
name|size
operator|-=
name|chunk
expr_stmt|;
name|data
operator|+=
name|chunk
expr_stmt|;
name|offset
operator|+=
name|chunk
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_partn_erase
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|partn
parameter_list|,
name|__in
name|unsigned
name|int
name|offset
parameter_list|,
name|__in
name|size_t
name|size
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_nvram_erase
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|siena_nvram_partn_write
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|unsigned
name|int
name|partn
argument_list|,
name|__in
name|unsigned
name|int
name|offset
argument_list|,
name|__out_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|)
block|{
name|size_t
name|chunk
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|chunk
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|SIENA_NVRAM_CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_nvram_write
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|chunk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail1
goto|;
block|}
name|size
operator|-=
name|chunk
expr_stmt|;
name|data
operator|+=
name|chunk
expr_stmt|;
name|offset
operator|+=
name|chunk
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|siena_nvram_partn_unlock
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|partn
parameter_list|)
block|{
name|boolean_t
name|reboot
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * Reboot into the new image only for PHYs. The driver has to 	 * explicitly cope with an MC reboot after a firmware update. 	 */
name|reboot
operator|=
operator|(
name|partn
operator|==
name|MC_CMD_NVRAM_TYPE_PHY_PORT0
operator|||
name|partn
operator|==
name|MC_CMD_NVRAM_TYPE_PHY_PORT1
operator|||
name|partn
operator|==
name|MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_nvram_update_finish
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
name|reboot
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail1
goto|;
block|}
return|return;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_VPD || EFSYS_OPT_NVRAM */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_NVRAM
end_if

begin_typedef
typedef|typedef
struct|struct
name|siena_parttbl_entry_s
block|{
name|unsigned
name|int
name|partn
decl_stmt|;
name|unsigned
name|int
name|port
decl_stmt|;
name|efx_nvram_type_t
name|nvtype
decl_stmt|;
block|}
name|siena_parttbl_entry_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|siena_parttbl_entry_t
name|siena_parttbl
index|[]
init|=
block|{
block|{
name|MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO
block|,
literal|1
block|,
name|EFX_NVRAM_NULLPHY
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO
block|,
literal|2
block|,
name|EFX_NVRAM_NULLPHY
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_MC_FW
block|,
literal|1
block|,
name|EFX_NVRAM_MC_FIRMWARE
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_MC_FW
block|,
literal|2
block|,
name|EFX_NVRAM_MC_FIRMWARE
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_MC_FW_BACKUP
block|,
literal|1
block|,
name|EFX_NVRAM_MC_GOLDEN
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_MC_FW_BACKUP
block|,
literal|2
block|,
name|EFX_NVRAM_MC_GOLDEN
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_EXP_ROM
block|,
literal|1
block|,
name|EFX_NVRAM_BOOTROM
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_EXP_ROM
block|,
literal|2
block|,
name|EFX_NVRAM_BOOTROM
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT0
block|,
literal|1
block|,
name|EFX_NVRAM_BOOTROM_CFG
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT1
block|,
literal|2
block|,
name|EFX_NVRAM_BOOTROM_CFG
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_PHY_PORT0
block|,
literal|1
block|,
name|EFX_NVRAM_PHY
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_PHY_PORT1
block|,
literal|2
block|,
name|EFX_NVRAM_PHY
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_FPGA
block|,
literal|1
block|,
name|EFX_NVRAM_FPGA
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_FPGA
block|,
literal|2
block|,
name|EFX_NVRAM_FPGA
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_FPGA_BACKUP
block|,
literal|1
block|,
name|EFX_NVRAM_FPGA_BACKUP
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_FPGA_BACKUP
block|,
literal|2
block|,
name|EFX_NVRAM_FPGA_BACKUP
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_FC_FW
block|,
literal|1
block|,
name|EFX_NVRAM_FCFW
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_FC_FW
block|,
literal|2
block|,
name|EFX_NVRAM_FCFW
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_CPLD
block|,
literal|1
block|,
name|EFX_NVRAM_CPLD
block|}
block|,
block|{
name|MC_CMD_NVRAM_TYPE_CPLD
block|,
literal|2
block|,
name|EFX_NVRAM_CPLD
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__checkReturn
name|siena_parttbl_entry_t
modifier|*
name|siena_parttbl_entry
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_nvram_type_t
name|type
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|type
argument_list|,
operator|<
argument_list|,
name|EFX_NVRAM_NTYPES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EFX_ARRAY_SIZE
argument_list|(
name|siena_parttbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|siena_parttbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|port
operator|==
name|emip
operator|->
name|emi_port
operator|&&
name|entry
operator|->
name|nvtype
operator|==
name|type
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_DIAG
end_if

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_test
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * Iterate over the list of supported partition types 	 * applicable to *this* port 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EFX_ARRAY_SIZE
argument_list|(
name|siena_parttbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|siena_parttbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|port
operator|!=
name|emip
operator|->
name|emi_port
operator|||
operator|!
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_partn_mask
operator|&
operator|(
literal|1
operator|<<
name|entry
operator|->
name|partn
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_nvram_test
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail1
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_DIAG */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_size
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_nvram_type_t
name|type
parameter_list|,
name|__out
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_size
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|,
name|sizep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SIENA_DYNAMIC_CFG_SIZE
parameter_list|(
name|_nitems
parameter_list|)
define|\
value|(sizeof (siena_mc_dynamic_config_hdr_t) + ((_nitems) *		\ 	sizeof (((siena_mc_dynamic_config_hdr_t *)NULL)->fw_version[0])))
end_define

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_get_dynamic_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|partn
parameter_list|,
name|__in
name|boolean_t
name|vpd
parameter_list|,
name|__out
name|siena_mc_dynamic_config_hdr_t
modifier|*
modifier|*
name|dcfgp
parameter_list|,
name|__out
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|siena_mc_dynamic_config_hdr_t
modifier|*
name|dcfg
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint8_t
name|cksum
decl_stmt|;
name|unsigned
name|int
name|vpd_offset
decl_stmt|;
name|unsigned
name|int
name|vpd_length
decl_stmt|;
name|unsigned
name|int
name|hdr_length
decl_stmt|;
name|unsigned
name|int
name|nversions
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
name|unsigned
name|int
name|region
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|partn
operator|==
name|MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0
operator|||
name|partn
operator|==
name|MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate sufficient memory for the entire dynamiccfg area, even 	 * if we're not actually going to read in the VPD. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_size
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|EFSYS_KMEM_ALLOC
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|size
argument_list|,
name|dcfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcfg
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_read
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|dcfg
argument_list|,
name|SIENA_NVRAM_CHUNK
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
comment|/* Verify the magic */
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|magic
argument_list|,
name|EFX_DWORD_0
argument_list|)
operator|!=
name|SIENA_MC_DYNAMIC_CONFIG_MAGIC
condition|)
goto|goto
name|invalid1
goto|;
comment|/* All future versions of the structure must be backwards compatable */
name|EFX_STATIC_ASSERT
argument_list|(
name|SIENA_MC_DYNAMIC_CONFIG_VERSION
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hdr_length
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|dcfg
operator|->
name|length
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|nversions
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|num_fw_version_items
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
name|vpd_offset
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|dynamic_vpd_offset
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
name|vpd_length
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|dynamic_vpd_length
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
comment|/* Verify the hdr doesn't overflow the partn size */
if|if
condition|(
name|hdr_length
operator|>
name|size
operator|||
name|vpd_offset
operator|>
name|size
operator|||
name|vpd_length
operator|>
name|size
operator|||
name|vpd_length
operator|+
name|vpd_offset
operator|>
name|size
condition|)
goto|goto
name|invalid2
goto|;
comment|/* Verify the header has room for all it's versions */
if|if
condition|(
name|hdr_length
operator|<
name|SIENA_DYNAMIC_CFG_SIZE
argument_list|(
literal|0
argument_list|)
operator|||
name|hdr_length
operator|<
name|SIENA_DYNAMIC_CFG_SIZE
argument_list|(
name|nversions
argument_list|)
condition|)
goto|goto
name|invalid3
goto|;
comment|/* 	 * Read the remaining portion of the dcfg, either including 	 * the whole of VPD (there is no vpd length in this structure, 	 * so we have to parse each tag), or just the dcfg header itself 	 */
name|region
operator|=
name|vpd
condition|?
name|vpd_offset
operator|+
name|vpd_length
else|:
name|hdr_length
expr_stmt|;
if|if
condition|(
name|region
operator|>
name|SIENA_NVRAM_CHUNK
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_read
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
name|SIENA_NVRAM_CHUNK
argument_list|,
operator|(
name|caddr_t
operator|)
name|dcfg
operator|+
name|SIENA_NVRAM_CHUNK
argument_list|,
name|region
operator|-
name|SIENA_NVRAM_CHUNK
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
block|}
comment|/* Verify checksum */
name|cksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|hdr_length
condition|;
name|pos
operator|++
control|)
name|cksum
operator|+=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|dcfg
operator|)
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|!=
literal|0
condition|)
goto|goto
name|invalid4
goto|;
goto|goto
name|done
goto|;
name|invalid4
label|:
name|EFSYS_PROBE
argument_list|(
name|invalid4
argument_list|)
expr_stmt|;
name|invalid3
label|:
name|EFSYS_PROBE
argument_list|(
name|invalid3
argument_list|)
expr_stmt|;
name|invalid2
label|:
name|EFSYS_PROBE
argument_list|(
name|invalid2
argument_list|)
expr_stmt|;
name|invalid1
label|:
name|EFSYS_PROBE
argument_list|(
name|invalid1
argument_list|)
expr_stmt|;
comment|/* 	 * Construct a new "null" dcfg, with an empty version vector, 	 * and an empty VPD chunk trailing. This has the neat side effect 	 * of testing the exception paths in the write path. 	 */
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dcfg
operator|->
name|magic
argument_list|,
name|EFX_DWORD_0
argument_list|,
name|SIENA_MC_DYNAMIC_CONFIG_MAGIC
argument_list|)
expr_stmt|;
name|EFX_POPULATE_WORD_1
argument_list|(
name|dcfg
operator|->
name|length
argument_list|,
name|EFX_WORD_0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dcfg
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_POPULATE_BYTE_1
argument_list|(
name|dcfg
operator|->
name|version
argument_list|,
name|EFX_BYTE_0
argument_list|,
name|SIENA_MC_DYNAMIC_CONFIG_VERSION
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dcfg
operator|->
name|dynamic_vpd_offset
argument_list|,
name|EFX_DWORD_0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dcfg
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dcfg
operator|->
name|dynamic_vpd_length
argument_list|,
name|EFX_DWORD_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dcfg
operator|->
name|num_fw_version_items
argument_list|,
name|EFX_DWORD_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|dcfgp
operator|=
name|dcfg
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|size
argument_list|,
name|dcfg
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_get_subtype
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|partn
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|subtypep
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_BOARD_CFG_IN_LEN
argument_list|,
name|MC_CMD_GET_BOARD_CFG_OUT_LENMAX
argument_list|)
index|]
decl_stmt|;
name|efx_word_t
modifier|*
name|fw_list
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_BOARD_CFG
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_BOARD_CFG_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_BOARD_CFG_OUT_LENMAX
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_BOARD_CFG_OUT_LENMIN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST
operator|+
operator|(
name|partn
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|efx_word_t
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|fw_list
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|efx_word_t
argument_list|,
name|GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST
argument_list|)
expr_stmt|;
operator|*
name|subtypep
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|fw_list
index|[
name|partn
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|siena_nvram_get_version
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|efx_nvram_type_t
name|type
argument_list|,
name|__out
name|uint32_t
operator|*
name|subtypep
argument_list|,
name|__out_ecount
argument_list|(
literal|4
argument_list|)
name|uint16_t
name|version
index|[
literal|4
index|]
argument_list|)
block|{
name|siena_mc_dynamic_config_hdr_t
modifier|*
name|dcfg
decl_stmt|;
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|int
name|dcfg_partn
decl_stmt|;
name|unsigned
name|int
name|partn
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|partn
operator|=
name|entry
operator|->
name|partn
expr_stmt|;
if|if
condition|(
operator|(
literal|1
operator|<<
name|partn
operator|)
operator|&
operator|~
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_partn_mask
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_get_subtype
argument_list|(
name|enp
argument_list|,
name|partn
argument_list|,
name|subtypep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
comment|/* 	 * Some partitions are accessible from both ports (for instance BOOTROM) 	 * Find the highest version reported by all dcfg structures on ports 	 * that have access to this partition. 	 */
name|version
index|[
literal|0
index|]
operator|=
name|version
index|[
literal|1
index|]
operator|=
name|version
index|[
literal|2
index|]
operator|=
name|version
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EFX_ARRAY_SIZE
argument_list|(
name|siena_parttbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|nitems
decl_stmt|;
name|uint16_t
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|entry
operator|=
operator|&
name|siena_parttbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|partn
operator|!=
name|partn
condition|)
continue|continue;
name|dcfg_partn
operator|=
operator|(
name|entry
operator|->
name|port
operator|==
literal|1
operator|)
condition|?
name|MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0
else|:
name|MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1
expr_stmt|;
comment|/* 		 * Ingore missing partitions on port 2, assuming they're due 		 * to to running on a single port part. 		 */
if|if
condition|(
operator|(
literal|1
operator|<<
name|dcfg_partn
operator|)
operator|&
operator|~
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_partn_mask
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|port
operator|==
literal|2
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_get_dynamic_cfg
argument_list|(
name|enp
argument_list|,
name|dcfg_partn
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|dcfg
argument_list|,
operator|&
name|length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|nitems
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|num_fw_version_items
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nitems
operator|<
name|entry
operator|->
name|partn
condition|)
goto|goto
name|done
goto|;
name|temp
index|[
literal|0
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|partn
index|]
operator|.
name|version_w
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|partn
index|]
operator|.
name|version_x
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|temp
index|[
literal|2
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|partn
index|]
operator|.
name|version_y
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|temp
index|[
literal|3
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|partn
index|]
operator|.
name|version_z
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|version
argument_list|,
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|memcpy
argument_list|(
name|version
argument_list|,
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|length
argument_list|,
name|dcfg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_rw_start
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_nvram_type_t
name|type
parameter_list|,
name|__out
name|size_t
modifier|*
name|chunk_sizep
parameter_list|)
block|{
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_lock
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
name|chunk_sizep
operator|!=
name|NULL
condition|)
operator|*
name|chunk_sizep
operator|=
name|SIENA_NVRAM_CHUNK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|siena_nvram_read_chunk
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|efx_nvram_type_t
name|type
argument_list|,
name|__in
name|unsigned
name|int
name|offset
argument_list|,
name|__out_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|)
block|{
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_read
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nvram_erase
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_nvram_type_t
name|type
parameter_list|)
block|{
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_size
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_erase
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|siena_nvram_write_chunk
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|efx_nvram_type_t
name|type
argument_list|,
name|__in
name|unsigned
name|int
name|offset
argument_list|,
name|__in_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|)
block|{
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_write
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|siena_nvram_rw_finish
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_nvram_type_t
name|type
parameter_list|)
block|{
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|siena_nvram_partn_unlock
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|siena_nvram_set_version
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|efx_nvram_type_t
name|type
argument_list|,
name|__in_ecount
argument_list|(
literal|4
argument_list|)
name|uint16_t
name|version
index|[
literal|4
index|]
argument_list|)
block|{
name|siena_mc_dynamic_config_hdr_t
modifier|*
name|dcfg
init|=
name|NULL
decl_stmt|;
name|siena_parttbl_entry_t
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|int
name|dcfg_partn
decl_stmt|;
name|size_t
name|partn_size
decl_stmt|;
name|unsigned
name|int
name|hdr_length
decl_stmt|;
name|unsigned
name|int
name|vpd_length
decl_stmt|;
name|unsigned
name|int
name|vpd_offset
decl_stmt|;
name|unsigned
name|int
name|nitems
decl_stmt|;
name|unsigned
name|int
name|required_hdr_length
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
name|uint8_t
name|cksum
decl_stmt|;
name|uint32_t
name|subtype
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|siena_parttbl_entry
argument_list|(
name|enp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|dcfg_partn
operator|=
operator|(
name|entry
operator|->
name|port
operator|==
literal|1
operator|)
condition|?
name|MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0
else|:
name|MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_size
argument_list|(
name|enp
argument_list|,
name|dcfg_partn
argument_list|,
operator|&
name|partn_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_lock
argument_list|(
name|enp
argument_list|,
name|dcfg_partn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_get_dynamic_cfg
argument_list|(
name|enp
argument_list|,
name|dcfg_partn
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|dcfg
argument_list|,
operator|&
name|length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
name|hdr_length
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|dcfg
operator|->
name|length
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|num_fw_version_items
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
name|vpd_length
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|dynamic_vpd_length
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
name|vpd_offset
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dcfg
operator|->
name|dynamic_vpd_offset
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: This function will blatt any fields trailing the version 	 * vector, or the VPD chunk. 	 */
name|required_hdr_length
operator|=
name|SIENA_DYNAMIC_CFG_SIZE
argument_list|(
name|entry
operator|->
name|partn
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|required_hdr_length
operator|+
name|vpd_length
operator|>
name|length
condition|)
block|{
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
if|if
condition|(
name|vpd_offset
operator|<
name|required_hdr_length
condition|)
block|{
operator|(
name|void
operator|)
name|memmove
argument_list|(
operator|(
name|caddr_t
operator|)
name|dcfg
operator|+
name|required_hdr_length
argument_list|,
operator|(
name|caddr_t
operator|)
name|dcfg
operator|+
name|vpd_offset
argument_list|,
name|vpd_length
argument_list|)
expr_stmt|;
name|vpd_offset
operator|=
name|required_hdr_length
expr_stmt|;
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dcfg
operator|->
name|dynamic_vpd_offset
argument_list|,
name|EFX_DWORD_0
argument_list|,
name|vpd_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr_length
operator|<
name|required_hdr_length
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|caddr_t
operator|)
name|dcfg
operator|+
name|hdr_length
argument_list|,
literal|0
argument_list|,
name|required_hdr_length
operator|-
name|hdr_length
argument_list|)
expr_stmt|;
name|hdr_length
operator|=
name|required_hdr_length
expr_stmt|;
name|EFX_POPULATE_WORD_1
argument_list|(
name|dcfg
operator|->
name|length
argument_list|,
name|EFX_WORD_0
argument_list|,
name|hdr_length
argument_list|)
expr_stmt|;
block|}
comment|/* Get the subtype to insert into the fw_subtype array */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_get_subtype
argument_list|(
name|enp
argument_list|,
name|entry
operator|->
name|partn
argument_list|,
operator|&
name|subtype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail5
goto|;
comment|/* Fill out the new version */
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|entry
operator|->
name|partn
index|]
operator|.
name|fw_subtype
argument_list|,
name|EFX_DWORD_0
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|EFX_POPULATE_WORD_1
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|entry
operator|->
name|partn
index|]
operator|.
name|version_w
argument_list|,
name|EFX_WORD_0
argument_list|,
name|version
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|EFX_POPULATE_WORD_1
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|entry
operator|->
name|partn
index|]
operator|.
name|version_x
argument_list|,
name|EFX_WORD_0
argument_list|,
name|version
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|EFX_POPULATE_WORD_1
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|entry
operator|->
name|partn
index|]
operator|.
name|version_y
argument_list|,
name|EFX_WORD_0
argument_list|,
name|version
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|EFX_POPULATE_WORD_1
argument_list|(
name|dcfg
operator|->
name|fw_version
index|[
name|entry
operator|->
name|partn
index|]
operator|.
name|version_z
argument_list|,
name|EFX_WORD_0
argument_list|,
name|version
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Update the version count */
if|if
condition|(
name|nitems
operator|<
name|entry
operator|->
name|partn
operator|+
literal|1
condition|)
block|{
name|nitems
operator|=
name|entry
operator|->
name|partn
operator|+
literal|1
expr_stmt|;
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dcfg
operator|->
name|num_fw_version_items
argument_list|,
name|EFX_DWORD_0
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
block|}
comment|/* Update the checksum */
name|cksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|hdr_length
condition|;
name|pos
operator|++
control|)
name|cksum
operator|+=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|dcfg
operator|)
index|[
name|pos
index|]
expr_stmt|;
name|dcfg
operator|->
name|csum
operator|.
name|eb_u8
index|[
literal|0
index|]
operator|-=
name|cksum
expr_stmt|;
comment|/* Erase and write the new partition */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_erase
argument_list|(
name|enp
argument_list|,
name|dcfg_partn
argument_list|,
literal|0
argument_list|,
name|partn_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
comment|/* Write out the new structure to nvram */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nvram_partn_write
argument_list|(
name|enp
argument_list|,
name|dcfg_partn
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|dcfg
argument_list|,
name|vpd_offset
operator|+
name|vpd_length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail7
goto|;
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|length
argument_list|,
name|dcfg
argument_list|)
expr_stmt|;
name|siena_nvram_partn_unlock
argument_list|(
name|enp
argument_list|,
name|dcfg_partn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|length
argument_list|,
name|dcfg
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_NVRAM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_SIENA */
end_comment

end_unit

