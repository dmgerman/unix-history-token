begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2015 Solarflare Communications Inc.  * All rights reserved.  *  * This software was developed in part by Philip Paeps under contract for  * Solarflare Communications, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_comment
comment|/* Theory of operation:  *  * Tx queues allocation and mapping  *  * One Tx queue with enabled checksum offload is allocated per Rx channel  * (event queue).  Also 2 Tx queues (one without checksum offload and one  * with IP checksum offload only) are allocated and bound to event queue 0.  * sfxge_txq_type is used as Tx queue label.  *  * So, event queue plus label mapping to Tx queue index is:  *	if event queue index is 0, TxQ-index = TxQ-label * [0..SFXGE_TXQ_NTYPES)  *	else TxQ-index = SFXGE_TXQ_NTYPES + EvQ-index - 1  * See sfxge_get_txq_by_label() sfxge_ev.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|"common/efx.h"
end_include

begin_include
include|#
directive|include
file|"sfxge.h"
end_include

begin_include
include|#
directive|include
file|"sfxge_tx.h"
end_include

begin_define
define|#
directive|define
name|SFXGE_PARAM_TX_DPL_GET_MAX
value|SFXGE_PARAM(tx_dpl_get_max)
end_define

begin_decl_stmt
specifier|static
name|int
name|sfxge_tx_dpl_get_max
init|=
name|SFXGE_TX_DPL_GET_PKT_LIMIT_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|SFXGE_PARAM_TX_DPL_GET_MAX
argument_list|,
operator|&
name|sfxge_tx_dpl_get_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sfxge
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_dpl_get_max
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sfxge_tx_dpl_get_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of any packets in deferred packet get-list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SFXGE_PARAM_TX_DPL_GET_NON_TCP_MAX
define|\
value|SFXGE_PARAM(tx_dpl_get_non_tcp_max)
end_define

begin_decl_stmt
specifier|static
name|int
name|sfxge_tx_dpl_get_non_tcp_max
init|=
name|SFXGE_TX_DPL_GET_NON_TCP_PKT_LIMIT_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|SFXGE_PARAM_TX_DPL_GET_NON_TCP_MAX
argument_list|,
operator|&
name|sfxge_tx_dpl_get_non_tcp_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sfxge
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_dpl_get_non_tcp_max
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sfxge_tx_dpl_get_non_tcp_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of non-TCP packets in deferred packet get-list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SFXGE_PARAM_TX_DPL_PUT_MAX
value|SFXGE_PARAM(tx_dpl_put_max)
end_define

begin_decl_stmt
specifier|static
name|int
name|sfxge_tx_dpl_put_max
init|=
name|SFXGE_TX_DPL_PUT_PKT_LIMIT_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|SFXGE_PARAM_TX_DPL_PUT_MAX
argument_list|,
operator|&
name|sfxge_tx_dpl_put_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sfxge
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_dpl_put_max
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sfxge_tx_dpl_put_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of any packets in deferred packet put-list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SFXGE_PARAM_TSO_FW_ASSISTED
value|SFXGE_PARAM(tso_fw_assisted)
end_define

begin_decl_stmt
specifier|static
name|int
name|sfxge_tso_fw_assisted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|SFXGE_PARAM_TSO_FW_ASSISTED
argument_list|,
operator|&
name|sfxge_tso_fw_assisted
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sfxge
argument_list|,
name|OID_AUTO
argument_list|,
name|tso_fw_assisted
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sfxge_tso_fw_assisted
argument_list|,
literal|0
argument_list|,
literal|"Use FW-assisted TSO if supported by NIC firmware"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
block|}
name|sfxge_tx_stats
index|[]
init|=
block|{
define|#
directive|define
name|SFXGE_TX_STAT
parameter_list|(
name|name
parameter_list|,
name|member
parameter_list|)
define|\
value|{ #name, offsetof(struct sfxge_txq, member) }
name|SFXGE_TX_STAT
argument_list|(
name|tso_bursts
argument_list|,
name|tso_bursts
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tso_packets
argument_list|,
name|tso_packets
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tso_long_headers
argument_list|,
name|tso_long_headers
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tso_pdrop_too_many
argument_list|,
name|tso_pdrop_too_many
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tso_pdrop_no_rsrc
argument_list|,
name|tso_pdrop_no_rsrc
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_collapses
argument_list|,
name|collapses
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_drops
argument_list|,
name|drops
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_get_overflow
argument_list|,
name|get_overflow
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_get_non_tcp_overflow
argument_list|,
name|get_non_tcp_overflow
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_put_overflow
argument_list|,
name|put_overflow
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_netdown_drops
argument_list|,
name|netdown_drops
argument_list|)
block|, }
struct|;
end_struct

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|void
name|sfxge_tx_qdpl_service
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sfxge_tx_qlist_post
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sfxge_tx_qunblock
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sfxge_tx_queue_tso
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
specifier|const
name|bus_dma_segment_t
modifier|*
name|dma_seg
parameter_list|,
name|int
name|n_dma_seg
parameter_list|,
name|int
name|vlan_tagged
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sfxge_tx_maybe_insert_tag
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|uint16_t
name|this_tag
init|=
operator|(
operator|(
name|mbuf
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
condition|?
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|this_tag
operator|==
name|txq
operator|->
name|hw_vlan_tci
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|efx_tx_qdesc_vlantci_create
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|bswap16
argument_list|(
name|this_tag
argument_list|)
argument_list|,
operator|&
name|txq
operator|->
name|pend_desc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|txq
operator|->
name|n_pend_desc
operator|=
literal|1
expr_stmt|;
name|txq
operator|->
name|hw_vlan_tci
operator|=
name|this_tag
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|sfxge_next_stmp
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sfxge_tx_mapping
modifier|*
modifier|*
name|pstmp
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|*
name|pstmp
operator|)
operator|->
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"stmp flags are not 0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|*
name|pstmp
operator|==
operator|&
name|txq
operator|->
name|stmp
index|[
name|txq
operator|->
name|ptr_mask
index|]
argument_list|)
condition|)
operator|*
name|pstmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|(
operator|*
name|pstmp
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sfxge_tx_qcomplete
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sfxge_evq
modifier|*
name|evq
parameter_list|)
block|{
name|unsigned
name|int
name|completed
decl_stmt|;
name|SFXGE_EVQ_LOCK_ASSERT_OWNED
argument_list|(
name|evq
argument_list|)
expr_stmt|;
name|completed
operator|=
name|txq
operator|->
name|completed
expr_stmt|;
while|while
condition|(
name|completed
operator|!=
name|txq
operator|->
name|pending
condition|)
block|{
name|struct
name|sfxge_tx_mapping
modifier|*
name|stmp
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|id
operator|=
name|completed
operator|++
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
name|stmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|stmp
operator|->
name|flags
operator|&
name|TX_BUF_UNMAP
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmp
operator|->
name|flags
operator|&
name|TX_BUF_MBUF
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|stmp
operator|->
name|u
operator|.
name|mbuf
decl_stmt|;
do|do
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
block|}
else|else
block|{
name|free
argument_list|(
name|stmp
operator|->
name|u
operator|.
name|heap_buf
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
name|stmp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|txq
operator|->
name|completed
operator|=
name|completed
expr_stmt|;
comment|/* Check whether we need to unblock the queue. */
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|blocked
condition|)
block|{
name|unsigned
name|int
name|level
decl_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|completed
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|SFXGE_TXQ_UNBLOCK_LEVEL
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
condition|)
name|sfxge_tx_qunblock
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|sfxge_is_mbuf_non_tcp
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
comment|/* Absense of TCP checksum flags does not mean that it is non-TCP 	 * but it should be true if user wants to achieve high throughput. 	 */
return|return
operator|(
operator|!
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_TCP
operator||
name|CSUM_IP6_TCP
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reorder the put list and append it to the get list.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qdpl_swizzle
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|get_next
decl_stmt|,
modifier|*
modifier|*
name|get_tailp
decl_stmt|;
specifier|volatile
name|uintptr_t
modifier|*
name|putp
decl_stmt|;
name|uintptr_t
name|put
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|non_tcp_count
decl_stmt|;
name|SFXGE_TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
comment|/* Acquire the put list. */
name|putp
operator|=
operator|&
name|stdp
operator|->
name|std_put
expr_stmt|;
name|put
operator|=
name|atomic_readandclear_ptr
argument_list|(
name|putp
argument_list|)
expr_stmt|;
name|mbuf
operator|=
operator|(
name|void
operator|*
operator|)
name|put
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return;
comment|/* Reverse the put list. */
name|get_tailp
operator|=
operator|&
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|get_next
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|non_tcp_count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|struct
name|mbuf
modifier|*
name|put_next
decl_stmt|;
name|non_tcp_count
operator|+=
name|sfxge_is_mbuf_non_tcp
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|put_next
operator|=
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|mbuf
operator|->
name|m_nextpkt
operator|=
name|get_next
expr_stmt|;
name|get_next
operator|=
name|mbuf
expr_stmt|;
name|mbuf
operator|=
name|put_next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|count
operator|>
name|stdp
operator|->
name|std_put_hiwat
condition|)
name|stdp
operator|->
name|std_put_hiwat
operator|=
name|count
expr_stmt|;
comment|/* Append the reversed put list to the get list. */
name|KASSERT
argument_list|(
operator|*
name|get_tailp
operator|==
name|NULL
argument_list|,
operator|(
literal|"*get_tailp != NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|stdp
operator|->
name|std_getp
operator|=
name|get_next
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
name|get_tailp
expr_stmt|;
name|stdp
operator|->
name|std_get_count
operator|+=
name|count
expr_stmt|;
name|stdp
operator|->
name|std_get_non_tcp_count
operator|+=
name|non_tcp_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qreap
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|SFXGE_TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|reaped
operator|=
name|txq
operator|->
name|completed
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qlist_post
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|unsigned
name|int
name|old_added
decl_stmt|;
name|unsigned
name|int
name|block_level
decl_stmt|;
name|unsigned
name|int
name|level
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|SFXGE_TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|n_pend_desc
operator|!=
literal|0
argument_list|,
operator|(
literal|"txq->n_pend_desc == 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|n_pend_desc
operator|<=
name|txq
operator|->
name|max_pkt_desc
argument_list|,
operator|(
literal|"txq->n_pend_desc too large"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|txq
operator|->
name|blocked
argument_list|,
operator|(
literal|"txq->blocked"
operator|)
argument_list|)
expr_stmt|;
name|old_added
operator|=
name|txq
operator|->
name|added
expr_stmt|;
comment|/* Post the fragment list. */
name|rc
operator|=
name|efx_tx_qdesc_post
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|pend_desc
argument_list|,
name|txq
operator|->
name|n_pend_desc
argument_list|,
name|txq
operator|->
name|reaped
argument_list|,
operator|&
name|txq
operator|->
name|added
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|0
argument_list|,
operator|(
literal|"efx_tx_qdesc_post() failed"
operator|)
argument_list|)
expr_stmt|;
comment|/* If efx_tx_qdesc_post() had to refragment, our information about 	 * buffers to free may be associated with the wrong 	 * descriptors. 	 */
name|KASSERT
argument_list|(
name|txq
operator|->
name|added
operator|-
name|old_added
operator|==
name|txq
operator|->
name|n_pend_desc
argument_list|,
operator|(
literal|"efx_tx_qdesc_post() refragmented descriptors"
operator|)
argument_list|)
expr_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|reaped
expr_stmt|;
name|KASSERT
argument_list|(
name|level
operator|<=
name|txq
operator|->
name|entries
argument_list|,
operator|(
literal|"overfilled TX queue"
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear the fragment list. */
name|txq
operator|->
name|n_pend_desc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set the block level to ensure there is space to generate a 	 * large number of descriptors for TSO. 	 */
name|block_level
operator|=
name|EFX_TXQ_LIMIT
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
operator|-
name|txq
operator|->
name|max_pkt_desc
expr_stmt|;
comment|/* Have we reached the block level? */
if|if
condition|(
name|level
operator|<
name|block_level
condition|)
return|return;
comment|/* Reap, and check again */
name|sfxge_tx_qreap
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|reaped
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|block_level
condition|)
return|return;
name|txq
operator|->
name|blocked
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Avoid a race with completion interrupt handling that could leave 	 * the queue blocked. 	 */
name|mb
argument_list|()
expr_stmt|;
name|sfxge_tx_qreap
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|reaped
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|block_level
condition|)
block|{
name|mb
argument_list|()
expr_stmt|;
name|txq
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_queue_mbuf
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|bus_dmamap_t
modifier|*
name|used_map
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_segment_t
name|dma_seg
index|[
name|SFXGE_TX_MAPPING_MAX_SEG
index|]
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|struct
name|sfxge_tx_mapping
modifier|*
name|stmp
decl_stmt|;
name|efx_desc_t
modifier|*
name|desc
decl_stmt|;
name|int
name|n_dma_seg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|eop
decl_stmt|;
name|int
name|vlan_tagged
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|txq
operator|->
name|blocked
argument_list|,
operator|(
literal|"txq->blocked"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
name|prefetch_read_many
argument_list|(
name|mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|txq
operator|->
name|init_state
operator|!=
name|SFXGE_TXQ_STARTED
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
comment|/* Load the packet for DMA. */
name|id
operator|=
name|txq
operator|->
name|added
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
name|stmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
name|id
index|]
expr_stmt|;
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|mbuf
argument_list|,
name|dma_seg
argument_list|,
operator|&
name|n_dma_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EFBIG
condition|)
block|{
comment|/* Try again. */
name|struct
name|mbuf
modifier|*
name|new_mbuf
init|=
name|m_collapse
argument_list|(
name|mbuf
argument_list|,
name|M_NOWAIT
argument_list|,
name|SFXGE_TX_MAPPING_MAX_SEG
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mbuf
operator|==
name|NULL
condition|)
goto|goto
name|reject
goto|;
operator|++
name|txq
operator|->
name|collapses
expr_stmt|;
name|mbuf
operator|=
name|new_mbuf
expr_stmt|;
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|mbuf
argument_list|,
name|dma_seg
argument_list|,
operator|&
name|n_dma_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|reject
goto|;
comment|/* Make the packet visible to the hardware. */
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|used_map
operator|=
operator|&
name|stmp
operator|->
name|map
expr_stmt|;
name|vlan_tagged
operator|=
name|sfxge_tx_maybe_insert_tag
argument_list|(
name|txq
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan_tagged
condition|)
block|{
name|sfxge_next_stmp
argument_list|(
name|txq
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|rc
operator|=
name|sfxge_tx_queue_tso
argument_list|(
name|txq
argument_list|,
name|mbuf
argument_list|,
name|dma_seg
argument_list|,
name|n_dma_seg
argument_list|,
name|vlan_tagged
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|reject_mapped
goto|;
name|stmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
operator|(
name|rc
operator|-
literal|1
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the mapping to the fragment list, and set flags 		 * for the buffer. 		 */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|desc
operator|=
operator|&
name|txq
operator|->
name|pend_desc
index|[
name|i
operator|+
name|vlan_tagged
index|]
expr_stmt|;
name|eop
operator|=
operator|(
name|i
operator|==
name|n_dma_seg
operator|-
literal|1
operator|)
expr_stmt|;
name|efx_tx_qdesc_dma_create
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|dma_seg
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|dma_seg
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
name|eop
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|eop
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|sfxge_next_stmp
argument_list|(
name|txq
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
block|}
name|txq
operator|->
name|n_pend_desc
operator|=
name|n_dma_seg
operator|+
name|vlan_tagged
expr_stmt|;
block|}
comment|/* 	 * If the mapping required more than one descriptor 	 * then we need to associate the DMA map with the last 	 * descriptor, not the first. 	 */
if|if
condition|(
name|used_map
operator|!=
operator|&
name|stmp
operator|->
name|map
condition|)
block|{
name|map
operator|=
name|stmp
operator|->
name|map
expr_stmt|;
name|stmp
operator|->
name|map
operator|=
operator|*
name|used_map
expr_stmt|;
operator|*
name|used_map
operator|=
name|map
expr_stmt|;
block|}
name|stmp
operator|->
name|u
operator|.
name|mbuf
operator|=
name|mbuf
expr_stmt|;
name|stmp
operator|->
name|flags
operator|=
name|TX_BUF_UNMAP
operator||
name|TX_BUF_MBUF
expr_stmt|;
comment|/* Post the fragment list. */
name|sfxge_tx_qlist_post
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|reject_mapped
label|:
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
operator|*
name|used_map
argument_list|)
expr_stmt|;
name|reject
label|:
comment|/* Drop the packet on the floor. */
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
operator|++
name|txq
operator|->
name|drops
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drain the deferred packet list into the transmit queue.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qdpl_drain
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|non_tcp_count
decl_stmt|;
name|unsigned
name|int
name|pushed
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|SFXGE_TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|sc
operator|=
name|txq
operator|->
name|sc
expr_stmt|;
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
name|pushed
operator|=
name|txq
operator|->
name|added
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|txq
operator|->
name|init_state
operator|==
name|SFXGE_TXQ_STARTED
argument_list|)
condition|)
block|{
name|prefetch_read_many
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|prefetch_read_many
argument_list|(
name|txq
operator|->
name|common
argument_list|)
expr_stmt|;
block|}
name|mbuf
operator|=
name|stdp
operator|->
name|std_get
expr_stmt|;
name|count
operator|=
name|stdp
operator|->
name|std_get_count
expr_stmt|;
name|non_tcp_count
operator|=
name|stdp
operator|->
name|std_get_non_tcp_count
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|stdp
operator|->
name|std_get_hiwat
condition|)
name|stdp
operator|->
name|std_get_hiwat
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|mbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mbuf == NULL"
operator|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|mbuf
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|sc
operator|->
name|ifnet
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
comment|/* packet capture */
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|prefetch_read_many
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sfxge_tx_queue_mbuf
argument_list|(
name|txq
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
operator|--
name|count
expr_stmt|;
name|non_tcp_count
operator|-=
name|sfxge_is_mbuf_non_tcp
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|txq
operator|->
name|blocked
condition|)
break|break;
comment|/* Push the fragments to the hardware in batches. */
if|if
condition|(
name|txq
operator|->
name|added
operator|-
name|pushed
operator|>=
name|SFXGE_TX_BATCH
condition|)
block|{
name|efx_tx_qpush
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|added
argument_list|,
name|pushed
argument_list|)
expr_stmt|;
name|pushed
operator|=
name|txq
operator|->
name|added
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|mbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|non_tcp_count
operator|==
literal|0
argument_list|,
operator|(
literal|"inconsistent TCP/non-TCP detection"
operator|)
argument_list|)
expr_stmt|;
name|stdp
operator|->
name|std_get
operator|=
name|NULL
expr_stmt|;
name|stdp
operator|->
name|std_get_count
operator|=
literal|0
expr_stmt|;
name|stdp
operator|->
name|std_get_non_tcp_count
operator|=
literal|0
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|stdp
operator|->
name|std_get
expr_stmt|;
block|}
else|else
block|{
name|stdp
operator|->
name|std_get
operator|=
name|mbuf
expr_stmt|;
name|stdp
operator|->
name|std_get_count
operator|=
name|count
expr_stmt|;
name|stdp
operator|->
name|std_get_non_tcp_count
operator|=
name|non_tcp_count
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|added
operator|!=
name|pushed
condition|)
name|efx_tx_qpush
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|added
argument_list|,
name|pushed
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|blocked
operator|||
name|stdp
operator|->
name|std_get_count
operator|==
literal|0
argument_list|,
operator|(
literal|"queue unblocked but count is non-zero"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SFXGE_TX_QDPL_PENDING
parameter_list|(
name|_txq
parameter_list|)
value|((_txq)->dpl.std_put != 0)
end_define

begin_comment
comment|/*  * Service the deferred packet list.  *  * NOTE: drops the txq mutex!  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qdpl_service
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|SFXGE_TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|SFXGE_TX_QDPL_PENDING
argument_list|(
name|txq
argument_list|)
condition|)
name|sfxge_tx_qdpl_swizzle
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|txq
operator|->
name|blocked
condition|)
name|sfxge_tx_qdpl_drain
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|SFXGE_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|SFXGE_TX_QDPL_PENDING
argument_list|(
name|txq
argument_list|)
operator|&&
name|SFXGE_TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Put a packet on the deferred packet get-list.  */
end_comment

begin_function
specifier|static
name|int
name|sfxge_tx_qdpl_put_locked
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
name|KASSERT
argument_list|(
name|mbuf
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf->m_nextpkt != NULL"
operator|)
argument_list|)
expr_stmt|;
name|SFXGE_TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdp
operator|->
name|std_get_count
operator|>=
name|stdp
operator|->
name|std_get_max
condition|)
block|{
name|txq
operator|->
name|get_overflow
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|sfxge_is_mbuf_non_tcp
argument_list|(
name|mbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|stdp
operator|->
name|std_get_non_tcp_count
operator|>=
name|stdp
operator|->
name|std_get_non_tcp_max
condition|)
block|{
name|txq
operator|->
name|get_non_tcp_overflow
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|stdp
operator|->
name|std_get_non_tcp_count
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|stdp
operator|->
name|std_getp
operator|)
operator|=
name|mbuf
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|stdp
operator|->
name|std_get_count
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a packet on the deferred packet put-list.  *  * We overload the csum_data field in the mbuf to keep track of this length  * because there is no cheap alternative to avoid races.  */
end_comment

begin_function
specifier|static
name|int
name|sfxge_tx_qdpl_put_unlocked
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
specifier|volatile
name|uintptr_t
modifier|*
name|putp
decl_stmt|;
name|uintptr_t
name|old
decl_stmt|;
name|uintptr_t
name|new
decl_stmt|;
name|unsigned
name|old_len
decl_stmt|;
name|KASSERT
argument_list|(
name|mbuf
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf->m_nextpkt != NULL"
operator|)
argument_list|)
expr_stmt|;
name|SFXGE_TXQ_LOCK_ASSERT_NOTOWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
name|putp
operator|=
operator|&
name|stdp
operator|->
name|std_put
expr_stmt|;
name|new
operator|=
operator|(
name|uintptr_t
operator|)
name|mbuf
expr_stmt|;
do|do
block|{
name|old
operator|=
operator|*
name|putp
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
init|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|old
decl_stmt|;
name|old_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
block|}
else|else
name|old_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old_len
operator|>=
name|stdp
operator|->
name|std_put_max
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|txq
operator|->
name|put_overflow
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|old_len
operator|+
literal|1
expr_stmt|;
name|mbuf
operator|->
name|m_nextpkt
operator|=
operator|(
name|void
operator|*
operator|)
name|old
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cmpset_ptr
argument_list|(
name|putp
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
operator|==
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from if_transmit - will try to grab the txq lock and enqueue to the  * put list if it succeeds, otherwise try to push onto the defer list if space.  */
end_comment

begin_function
specifier|static
name|int
name|sfxge_tx_packet_add
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|SFXGE_LINK_UP
argument_list|(
name|txq
operator|->
name|sc
argument_list|)
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|txq
operator|->
name|netdown_drops
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* 	 * Try to grab the txq lock.  If we are able to get the lock, 	 * the packet will be appended to the "get list" of the deferred 	 * packet list.  Otherwise, it will be pushed on the "put list". 	 */
if|if
condition|(
name|SFXGE_TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
condition|)
block|{
comment|/* First swizzle put-list to get-list to keep order */
name|sfxge_tx_qdpl_swizzle
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sfxge_tx_qdpl_put_locked
argument_list|(
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Try to service the list. */
name|sfxge_tx_qdpl_service
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Lock has been dropped. */
block|}
else|else
block|{
name|rc
operator|=
name|sfxge_tx_qdpl_put_unlocked
argument_list|(
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Try to grab the lock again. 		 * 		 * If we are able to get the lock, we need to process 		 * the deferred packet list.  If we are not able to get 		 * the lock, another thread is processing the list. 		 */
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
name|SFXGE_TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
condition|)
block|{
name|sfxge_tx_qdpl_service
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Lock has been dropped. */
block|}
block|}
name|SFXGE_TXQ_LOCK_ASSERT_NOTOWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qdpl_flush
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
init|=
operator|&
name|txq
operator|->
name|dpl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|sfxge_tx_qdpl_swizzle
argument_list|(
name|txq
argument_list|)
expr_stmt|;
for|for
control|(
name|mbuf
operator|=
name|stdp
operator|->
name|std_get
init|;
name|mbuf
operator|!=
name|NULL
condition|;
name|mbuf
operator|=
name|next
control|)
block|{
name|next
operator|=
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
block|}
name|stdp
operator|->
name|std_get
operator|=
name|NULL
expr_stmt|;
name|stdp
operator|->
name|std_get_count
operator|=
literal|0
expr_stmt|;
name|stdp
operator|->
name|std_get_non_tcp_count
operator|=
literal|0
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|stdp
operator|->
name|std_get
expr_stmt|;
name|SFXGE_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sfxge_if_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|txq_count
condition|;
name|i
operator|++
control|)
name|sfxge_tx_qdpl_flush
argument_list|(
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TX start -- called by the stack.  */
end_comment

begin_function
name|int
name|sfxge_if_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sfxge_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
expr_stmt|;
comment|/* 	 * Transmit may be called when interface is up from the kernel 	 * point of view, but not yet up (in progress) from the driver 	 * point of view. I.e. link aggregation bring up. 	 * Transmit may be called when interface is up from the driver 	 * point of view, but already down from the kernel point of 	 * view. I.e. Rx when interface shutdown is in progress. 	 */
name|KASSERT
argument_list|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|||
operator|(
name|sc
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
argument_list|,
operator|(
literal|"interface not up"
operator|)
argument_list|)
expr_stmt|;
comment|/* Pick the desired transmit queue. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TSO
operator|)
condition|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
comment|/* check if flowid is set */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
name|uint32_t
name|hash
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
decl_stmt|;
name|index
operator|=
name|sc
operator|->
name|rx_indir_table
index|[
name|hash
operator|%
name|SFXGE_RX_SCALE_MAX
index|]
expr_stmt|;
block|}
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_IP
condition|)
block|{
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|SFXGE_TXQ_IP_CKSUM
index|]
expr_stmt|;
block|}
else|else
block|{
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|SFXGE_TXQ_NON_CKSUM
index|]
expr_stmt|;
block|}
name|rc
operator|=
name|sfxge_tx_packet_add
argument_list|(
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Software "TSO".  Not quite as good as doing it in hardware, but  * still faster than segmenting in the stack.  */
end_comment

begin_struct
struct|struct
name|sfxge_tso_state
block|{
comment|/* Output position */
name|unsigned
name|out_len
decl_stmt|;
comment|/* Remaining length in current segment */
name|unsigned
name|seqnum
decl_stmt|;
comment|/* Current sequence number */
name|unsigned
name|packet_space
decl_stmt|;
comment|/* Remaining space in current packet */
comment|/* Input position */
name|uint64_t
name|dma_addr
decl_stmt|;
comment|/* DMA address of current position */
name|unsigned
name|in_len
decl_stmt|;
comment|/* Remaining length in current mbuf */
specifier|const
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
comment|/* Input mbuf (head of chain) */
name|u_short
name|protocol
decl_stmt|;
comment|/* Network protocol (after VLAN decap) */
name|ssize_t
name|nh_off
decl_stmt|;
comment|/* Offset of network header */
name|ssize_t
name|tcph_off
decl_stmt|;
comment|/* Offset of TCP header */
name|unsigned
name|header_len
decl_stmt|;
comment|/* Number of bytes of header */
name|unsigned
name|seg_size
decl_stmt|;
comment|/* TCP segment size */
name|int
name|fw_assisted
decl_stmt|;
comment|/* Use FW-assisted TSO */
name|u_short
name|packet_id
decl_stmt|;
comment|/* IPv4 packet ID from the original packet */
name|efx_desc_t
name|header_desc
decl_stmt|;
comment|/* Precomputed header descriptor for 				 * FW-assisted TSO */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|struct
name|ip
modifier|*
name|tso_iph
parameter_list|(
specifier|const
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
argument_list|,
operator|(
literal|"tso_iph() in non-IPv4 state"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
expr|struct
name|ip
operator|*
operator|)
operator|(
name|tso
operator|->
name|mbuf
operator|->
name|m_data
operator|+
name|tso
operator|->
name|nh_off
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__unused
specifier|const
expr|struct
name|ip6_hdr
operator|*
name|tso_ip6h
argument_list|(
argument|const struct sfxge_tso_state *tso
argument_list|)
block|{
name|KASSERT
argument_list|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
argument_list|,
operator|(
literal|"tso_ip6h() in non-IPv6 state"
operator|)
argument_list|)
block|;
return|return
operator|(
specifier|const
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|tso
operator|->
name|mbuf
operator|->
name|m_data
operator|+
name|tso
operator|->
name|nh_off
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|const
name|struct
name|tcphdr
modifier|*
name|tso_tcph
parameter_list|(
specifier|const
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|)
block|{
return|return
operator|(
specifier|const
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|tso
operator|->
name|mbuf
operator|->
name|m_data
operator|+
name|tso
operator|->
name|tcph_off
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Size of preallocated TSO header buffers.  Larger blocks must be  * allocated from the heap.  */
end_comment

begin_define
define|#
directive|define
name|TSOH_STD_SIZE
value|128
end_define

begin_comment
comment|/* At most half the descriptors in the queue at any time will refer to  * a TSO header buffer, since they must always be followed by a  * payload descriptor referring to an mbuf.  */
end_comment

begin_define
define|#
directive|define
name|TSOH_COUNT
parameter_list|(
name|_txq_entries
parameter_list|)
value|((_txq_entries) / 2u)
end_define

begin_define
define|#
directive|define
name|TSOH_PER_PAGE
value|(PAGE_SIZE / TSOH_STD_SIZE)
end_define

begin_define
define|#
directive|define
name|TSOH_PAGE_COUNT
parameter_list|(
name|_txq_entries
parameter_list|)
define|\
value|((TSOH_COUNT(_txq_entries) + TSOH_PER_PAGE - 1) / TSOH_PER_PAGE)
end_define

begin_function
specifier|static
name|int
name|tso_init
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|txq
operator|->
name|sc
decl_stmt|;
name|unsigned
name|int
name|tsoh_page_count
init|=
name|TSOH_PAGE_COUNT
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
comment|/* Allocate TSO header buffers */
name|txq
operator|->
name|tsoh_buffer
operator|=
name|malloc
argument_list|(
name|tsoh_page_count
operator|*
sizeof|sizeof
argument_list|(
name|txq
operator|->
name|tsoh_buffer
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tsoh_page_count
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|sfxge_dma_alloc
argument_list|(
name|sc
argument_list|,
name|PAGE_SIZE
argument_list|,
operator|&
name|txq
operator|->
name|tsoh_buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|sfxge_dma_free
argument_list|(
operator|&
name|txq
operator|->
name|tsoh_buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|tsoh_buffer
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|txq
operator|->
name|tsoh_buffer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tso_fini
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|txq
operator|->
name|tsoh_buffer
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSOH_PAGE_COUNT
argument_list|(
name|txq
operator|->
name|sc
operator|->
name|txq_entries
argument_list|)
condition|;
name|i
operator|++
control|)
name|sfxge_dma_free
argument_list|(
operator|&
name|txq
operator|->
name|tsoh_buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|tsoh_buffer
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tso_start
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|,
specifier|const
name|bus_dma_segment_t
modifier|*
name|hdr_dma_seg
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
init|=
name|mtod
argument_list|(
name|mbuf
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
name|efx_nic_cfg_get
argument_list|(
name|txq
operator|->
name|sc
operator|->
name|enp
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|tcphdr
name|th_copy
decl_stmt|;
name|tso
operator|->
name|fw_assisted
operator|=
name|txq
operator|->
name|sc
operator|->
name|tso_fw_assisted
expr_stmt|;
name|tso
operator|->
name|mbuf
operator|=
name|mbuf
expr_stmt|;
comment|/* Find network protocol and header */
name|tso
operator|->
name|protocol
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
if|if
condition|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|veh
init|=
name|mtod
argument_list|(
name|mbuf
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
decl_stmt|;
name|tso
operator|->
name|protocol
operator|=
name|veh
operator|->
name|evl_proto
expr_stmt|;
name|tso
operator|->
name|nh_off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|veh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tso
operator|->
name|nh_off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
block|}
comment|/* Find TCP header */
if|if
condition|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|tso_iph
argument_list|(
name|tso
argument_list|)
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
argument_list|,
operator|(
literal|"TSO required on non-TCP packet"
operator|)
argument_list|)
expr_stmt|;
name|tso
operator|->
name|tcph_off
operator|=
name|tso
operator|->
name|nh_off
operator|+
literal|4
operator|*
name|tso_iph
argument_list|(
name|tso
argument_list|)
operator|->
name|ip_hl
expr_stmt|;
name|tso
operator|->
name|packet_id
operator|=
name|tso_iph
argument_list|(
name|tso
argument_list|)
operator|->
name|ip_id
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
argument_list|,
operator|(
literal|"TSO required on non-IP packet"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tso_ip6h
argument_list|(
name|tso
argument_list|)
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_TCP
argument_list|,
operator|(
literal|"TSO required on non-TCP packet"
operator|)
argument_list|)
expr_stmt|;
name|tso
operator|->
name|tcph_off
operator|=
name|tso
operator|->
name|nh_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|tso
operator|->
name|packet_id
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tso
operator|->
name|fw_assisted
operator|&&
name|__predict_false
argument_list|(
name|tso
operator|->
name|tcph_off
operator|>
name|encp
operator|->
name|enc_tx_tso_tcp_header_offset_limit
argument_list|)
condition|)
block|{
name|tso
operator|->
name|fw_assisted
operator|=
literal|0
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|mbuf
operator|->
name|m_len
operator|>=
name|tso
operator|->
name|tcph_off
argument_list|,
operator|(
literal|"network header is fragmented in mbuf"
operator|)
argument_list|)
expr_stmt|;
comment|/* We need TCP header including flags (window is the next) */
if|if
condition|(
name|mbuf
operator|->
name|m_len
operator|<
name|tso
operator|->
name|tcph_off
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_win
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|tso
operator|->
name|mbuf
argument_list|,
name|tso
operator|->
name|tcph_off
argument_list|,
sizeof|sizeof
argument_list|(
name|th_copy
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|th_copy
argument_list|)
expr_stmt|;
name|th
operator|=
operator|&
name|th_copy
expr_stmt|;
block|}
else|else
block|{
name|th
operator|=
name|tso_tcph
argument_list|(
name|tso
argument_list|)
expr_stmt|;
block|}
name|tso
operator|->
name|header_len
operator|=
name|tso
operator|->
name|tcph_off
operator|+
literal|4
operator|*
name|th
operator|->
name|th_off
expr_stmt|;
name|tso
operator|->
name|seg_size
operator|=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|tso
operator|->
name|seqnum
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
comment|/* These flags must not be duplicated */
comment|/* 	 * RST should not be duplicated as well, but FreeBSD kernel 	 * generates TSO packets with RST flag. So, do not assert 	 * its absence. 	 */
name|KASSERT
argument_list|(
operator|!
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_URG
operator||
name|TH_SYN
operator|)
operator|)
argument_list|,
operator|(
literal|"incompatible TCP flag 0x%x on TSO packet"
operator|,
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_URG
operator||
name|TH_SYN
operator|)
operator|)
argument_list|)
expr_stmt|;
name|tso
operator|->
name|out_len
operator|=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|tso
operator|->
name|header_len
expr_stmt|;
if|if
condition|(
name|tso
operator|->
name|fw_assisted
condition|)
block|{
if|if
condition|(
name|hdr_dma_seg
operator|->
name|ds_len
operator|>=
name|tso
operator|->
name|header_len
condition|)
name|efx_tx_qdesc_dma_create
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|hdr_dma_seg
operator|->
name|ds_addr
argument_list|,
name|tso
operator|->
name|header_len
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|tso
operator|->
name|header_desc
argument_list|)
expr_stmt|;
else|else
name|tso
operator|->
name|fw_assisted
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * tso_fill_packet_with_fragment - form descriptors for the current fragment  *  * Form descriptors for the current fragment, until we reach the end  * of fragment or end-of-packet.  Return 0 on success, 1 if not enough  * space.  */
end_comment

begin_function
specifier|static
name|void
name|tso_fill_packet_with_fragment
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|)
block|{
name|efx_desc_t
modifier|*
name|desc
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tso
operator|->
name|in_len
operator|==
literal|0
operator|||
name|tso
operator|->
name|packet_space
operator|==
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|tso
operator|->
name|in_len
operator|>
literal|0
argument_list|,
operator|(
literal|"TSO input length went negative"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tso
operator|->
name|packet_space
operator|>
literal|0
argument_list|,
operator|(
literal|"TSO packet space went negative"
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|tso
operator|->
name|in_len
argument_list|,
name|tso
operator|->
name|packet_space
argument_list|)
expr_stmt|;
name|tso
operator|->
name|packet_space
operator|-=
name|n
expr_stmt|;
name|tso
operator|->
name|out_len
operator|-=
name|n
expr_stmt|;
name|tso
operator|->
name|in_len
operator|-=
name|n
expr_stmt|;
name|desc
operator|=
operator|&
name|txq
operator|->
name|pend_desc
index|[
name|txq
operator|->
name|n_pend_desc
operator|++
index|]
expr_stmt|;
name|efx_tx_qdesc_dma_create
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|tso
operator|->
name|dma_addr
argument_list|,
name|n
argument_list|,
name|tso
operator|->
name|out_len
operator|==
literal|0
operator|||
name|tso
operator|->
name|packet_space
operator|==
literal|0
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|tso
operator|->
name|dma_addr
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback from bus_dmamap_load() for long TSO headers. */
end_comment

begin_function
specifier|static
name|void
name|tso_map_long_header
parameter_list|(
name|void
modifier|*
name|dma_addr_ret
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|dma_addr_ret
operator|=
operator|(
operator|(
name|__predict_true
argument_list|(
name|error
operator|==
literal|0
argument_list|)
operator|&&
name|__predict_true
argument_list|(
name|nseg
operator|==
literal|1
argument_list|)
operator|)
condition|?
name|segs
operator|->
name|ds_addr
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * tso_start_new_packet - generate a new header and prepare for the new packet  *  * Generate a new header and prepare for the new packet.  Return 0 on  * success, or an error code if failed to alloc header.  */
end_comment

begin_function
specifier|static
name|int
name|tso_start_new_packet
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|,
name|unsigned
name|int
modifier|*
name|idp
parameter_list|)
block|{
name|unsigned
name|int
name|id
init|=
operator|*
name|idp
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tsoh_th
decl_stmt|;
name|unsigned
name|ip_length
decl_stmt|;
name|caddr_t
name|header
decl_stmt|;
name|uint64_t
name|dma_addr
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|efx_desc_t
modifier|*
name|desc
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|tso
operator|->
name|fw_assisted
condition|)
block|{
name|uint8_t
name|tcp_flags
init|=
name|tso_tcph
argument_list|(
name|tso
argument_list|)
operator|->
name|th_flags
decl_stmt|;
if|if
condition|(
name|tso
operator|->
name|out_len
operator|>
name|tso
operator|->
name|seg_size
condition|)
name|tcp_flags
operator|&=
operator|~
operator|(
name|TH_FIN
operator||
name|TH_PUSH
operator|)
expr_stmt|;
comment|/* TSO option descriptor */
name|desc
operator|=
operator|&
name|txq
operator|->
name|pend_desc
index|[
name|txq
operator|->
name|n_pend_desc
operator|++
index|]
expr_stmt|;
name|efx_tx_qdesc_tso_create
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|tso
operator|->
name|packet_id
argument_list|,
name|tso
operator|->
name|seqnum
argument_list|,
name|tcp_flags
argument_list|,
name|desc
operator|++
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|stmp
index|[
name|id
index|]
operator|.
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"stmp flags are not 0"
operator|)
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
comment|/* Header DMA descriptor */
operator|*
name|desc
operator|=
name|tso
operator|->
name|header_desc
expr_stmt|;
name|txq
operator|->
name|n_pend_desc
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|stmp
index|[
name|id
index|]
operator|.
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"stmp flags are not 0"
operator|)
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
name|tso
operator|->
name|seqnum
operator|+=
name|tso
operator|->
name|seg_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocate a DMA-mapped header buffer. */
if|if
condition|(
name|__predict_true
argument_list|(
name|tso
operator|->
name|header_len
operator|<=
name|TSOH_STD_SIZE
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|page_index
init|=
operator|(
name|id
operator|/
literal|2
operator|)
operator|/
name|TSOH_PER_PAGE
decl_stmt|;
name|unsigned
name|int
name|buf_index
init|=
operator|(
name|id
operator|/
literal|2
operator|)
operator|%
name|TSOH_PER_PAGE
decl_stmt|;
name|header
operator|=
operator|(
name|txq
operator|->
name|tsoh_buffer
index|[
name|page_index
index|]
operator|.
name|esm_base
operator|+
name|buf_index
operator|*
name|TSOH_STD_SIZE
operator|)
expr_stmt|;
name|dma_addr
operator|=
operator|(
name|txq
operator|->
name|tsoh_buffer
index|[
name|page_index
index|]
operator|.
name|esm_addr
operator|+
name|buf_index
operator|*
name|TSOH_STD_SIZE
operator|)
expr_stmt|;
name|map
operator|=
name|txq
operator|->
name|tsoh_buffer
index|[
name|page_index
index|]
operator|.
name|esm_map
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|stmp
index|[
name|id
index|]
operator|.
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"stmp flags are not 0"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sfxge_tx_mapping
modifier|*
name|stmp
init|=
operator|&
name|txq
operator|->
name|stmp
index|[
name|id
index|]
decl_stmt|;
comment|/* We cannot use bus_dmamem_alloc() as that may sleep */
name|header
operator|=
name|malloc
argument_list|(
name|tso
operator|->
name|header_len
argument_list|,
name|M_SFXGE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|header
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|header
argument_list|,
name|tso
operator|->
name|header_len
argument_list|,
name|tso_map_long_header
argument_list|,
operator|&
name|dma_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|dma_addr
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* Succeeded but got>1 segment */
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|free
argument_list|(
name|header
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|map
operator|=
name|stmp
operator|->
name|map
expr_stmt|;
name|txq
operator|->
name|tso_long_headers
operator|++
expr_stmt|;
name|stmp
operator|->
name|u
operator|.
name|heap_buf
operator|=
name|header
expr_stmt|;
name|stmp
operator|->
name|flags
operator|=
name|TX_BUF_UNMAP
expr_stmt|;
block|}
name|tsoh_th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|header
operator|+
name|tso
operator|->
name|tcph_off
operator|)
expr_stmt|;
comment|/* Copy and update the headers. */
name|m_copydata
argument_list|(
name|tso
operator|->
name|mbuf
argument_list|,
literal|0
argument_list|,
name|tso
operator|->
name|header_len
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|tsoh_th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|tso
operator|->
name|seqnum
argument_list|)
expr_stmt|;
name|tso
operator|->
name|seqnum
operator|+=
name|tso
operator|->
name|seg_size
expr_stmt|;
if|if
condition|(
name|tso
operator|->
name|out_len
operator|>
name|tso
operator|->
name|seg_size
condition|)
block|{
comment|/* This packet will not finish the TSO burst. */
name|ip_length
operator|=
name|tso
operator|->
name|header_len
operator|-
name|tso
operator|->
name|nh_off
operator|+
name|tso
operator|->
name|seg_size
expr_stmt|;
name|tsoh_th
operator|->
name|th_flags
operator|&=
operator|~
operator|(
name|TH_FIN
operator||
name|TH_PUSH
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This packet will be the last in the TSO burst. */
name|ip_length
operator|=
name|tso
operator|->
name|header_len
operator|-
name|tso
operator|->
name|nh_off
operator|+
name|tso
operator|->
name|out_len
expr_stmt|;
block|}
if|if
condition|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|tsoh_iph
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|header
operator|+
name|tso
operator|->
name|nh_off
operator|)
decl_stmt|;
name|tsoh_iph
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip_length
argument_list|)
expr_stmt|;
comment|/* XXX We should increment ip_id, but FreeBSD doesn't 			 * currently allocate extra IDs for multiple segments. 			 */
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|tsoh_iph
init|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|header
operator|+
name|tso
operator|->
name|nh_off
operator|)
decl_stmt|;
name|tsoh_iph
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|ip_length
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|tsoh_iph
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make the header visible to the hardware. */
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Form a descriptor for this header. */
name|desc
operator|=
operator|&
name|txq
operator|->
name|pend_desc
index|[
name|txq
operator|->
name|n_pend_desc
operator|++
index|]
expr_stmt|;
name|efx_tx_qdesc_dma_create
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|dma_addr
argument_list|,
name|tso
operator|->
name|header_len
argument_list|,
literal|0
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
block|}
name|tso
operator|->
name|packet_space
operator|=
name|tso
operator|->
name|seg_size
expr_stmt|;
name|txq
operator|->
name|tso_packets
operator|++
expr_stmt|;
operator|*
name|idp
operator|=
name|id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_queue_tso
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
specifier|const
name|bus_dma_segment_t
modifier|*
name|dma_seg
parameter_list|,
name|int
name|n_dma_seg
parameter_list|,
name|int
name|vlan_tagged
parameter_list|)
block|{
name|struct
name|sfxge_tso_state
name|tso
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|unsigned
name|skipped
init|=
literal|0
decl_stmt|;
name|tso_start
argument_list|(
name|txq
argument_list|,
operator|&
name|tso
argument_list|,
name|dma_seg
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
while|while
condition|(
name|dma_seg
operator|->
name|ds_len
operator|+
name|skipped
operator|<=
name|tso
operator|.
name|header_len
condition|)
block|{
name|skipped
operator|+=
name|dma_seg
operator|->
name|ds_len
expr_stmt|;
operator|--
name|n_dma_seg
expr_stmt|;
name|KASSERT
argument_list|(
name|n_dma_seg
argument_list|,
operator|(
literal|"no payload found in TSO packet"
operator|)
argument_list|)
expr_stmt|;
operator|++
name|dma_seg
expr_stmt|;
block|}
name|tso
operator|.
name|in_len
operator|=
name|dma_seg
operator|->
name|ds_len
operator|-
operator|(
name|tso
operator|.
name|header_len
operator|-
name|skipped
operator|)
expr_stmt|;
name|tso
operator|.
name|dma_addr
operator|=
name|dma_seg
operator|->
name|ds_addr
operator|+
operator|(
name|tso
operator|.
name|header_len
operator|-
name|skipped
operator|)
expr_stmt|;
name|id
operator|=
operator|(
name|txq
operator|->
name|added
operator|+
name|vlan_tagged
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tso_start_new_packet
argument_list|(
name|txq
argument_list|,
operator|&
name|tso
argument_list|,
operator|&
name|id
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|tso_fill_packet_with_fragment
argument_list|(
name|txq
argument_list|,
operator|&
name|tso
argument_list|)
expr_stmt|;
comment|/* Exactly one DMA descriptor is added */
name|KASSERT
argument_list|(
name|txq
operator|->
name|stmp
index|[
name|id
index|]
operator|.
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"stmp flags are not 0"
operator|)
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
comment|/* Move onto the next fragment? */
if|if
condition|(
name|tso
operator|.
name|in_len
operator|==
literal|0
condition|)
block|{
operator|--
name|n_dma_seg
expr_stmt|;
if|if
condition|(
name|n_dma_seg
operator|==
literal|0
condition|)
break|break;
operator|++
name|dma_seg
expr_stmt|;
name|tso
operator|.
name|in_len
operator|=
name|dma_seg
operator|->
name|ds_len
expr_stmt|;
name|tso
operator|.
name|dma_addr
operator|=
name|dma_seg
operator|->
name|ds_addr
expr_stmt|;
block|}
comment|/* End of packet? */
if|if
condition|(
name|tso
operator|.
name|packet_space
operator|==
literal|0
condition|)
block|{
comment|/* If the queue is now full due to tiny MSS, 			 * or we can't create another header, discard 			 * the remainder of the input mbuf but do not 			 * roll back the work we have done. 			 */
if|if
condition|(
name|txq
operator|->
name|n_pend_desc
operator|+
name|tso
operator|.
name|fw_assisted
operator|+
literal|1
comment|/* header */
operator|+
name|n_dma_seg
operator|>
name|txq
operator|->
name|max_pkt_desc
condition|)
block|{
name|txq
operator|->
name|tso_pdrop_too_many
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|tso_start_new_packet
argument_list|(
name|txq
argument_list|,
operator|&
name|tso
argument_list|,
operator|&
name|id
argument_list|)
argument_list|)
condition|)
block|{
name|txq
operator|->
name|tso_pdrop_no_rsrc
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|txq
operator|->
name|tso_bursts
operator|++
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qunblock
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|sc
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|txq
operator|->
name|evq_index
index|]
expr_stmt|;
name|SFXGE_EVQ_LOCK_ASSERT_OWNED
argument_list|(
name|evq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|txq
operator|->
name|init_state
operator|!=
name|SFXGE_TXQ_STARTED
argument_list|)
condition|)
return|return;
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|blocked
condition|)
block|{
name|unsigned
name|int
name|level
decl_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|completed
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|SFXGE_TXQ_UNBLOCK_LEVEL
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
condition|)
block|{
comment|/* reaped must be in sync with blocked */
name|sfxge_tx_qreap
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sfxge_tx_qdpl_service
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* note: lock has been dropped */
block|}
end_function

begin_function
name|void
name|sfxge_tx_qflush_done
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_DONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qstop
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|SFXGE_ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|index
index|]
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|txq
operator|->
name|evq_index
index|]
expr_stmt|;
name|SFXGE_EVQ_LOCK
argument_list|(
name|evq
argument_list|)
expr_stmt|;
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|init_state
operator|==
name|SFXGE_TXQ_STARTED
argument_list|,
operator|(
literal|"txq->init_state != SFXGE_TXQ_STARTED"
operator|)
argument_list|)
expr_stmt|;
name|txq
operator|->
name|init_state
operator|=
name|SFXGE_TXQ_INITIALIZED
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|flush_state
operator|!=
name|SFXGE_FLUSH_DONE
condition|)
block|{
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_PENDING
expr_stmt|;
name|SFXGE_EVQ_UNLOCK
argument_list|(
name|evq
argument_list|)
expr_stmt|;
name|SFXGE_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Flush the transmit queue. */
if|if
condition|(
name|efx_tx_qflush
argument_list|(
name|txq
operator|->
name|common
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Flushing Tx queue %u failed\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_DONE
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Spin for 100ms. */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|flush_state
operator|!=
name|SFXGE_FLUSH_PENDING
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|count
operator|<
literal|20
condition|)
do|;
block|}
name|SFXGE_EVQ_LOCK
argument_list|(
name|evq
argument_list|)
expr_stmt|;
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|flush_state
operator|!=
name|SFXGE_FLUSH_FAILED
argument_list|,
operator|(
literal|"txq->flush_state == SFXGE_FLUSH_FAILED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|flush_state
operator|!=
name|SFXGE_FLUSH_DONE
condition|)
block|{
comment|/* Flush timeout */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Cannot flush Tx queue %u\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_DONE
expr_stmt|;
block|}
block|}
name|txq
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|pending
operator|=
name|txq
operator|->
name|added
expr_stmt|;
name|sfxge_tx_qcomplete
argument_list|(
name|txq
argument_list|,
name|evq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|completed
operator|==
name|txq
operator|->
name|added
argument_list|,
operator|(
literal|"txq->completed != txq->added"
operator|)
argument_list|)
expr_stmt|;
name|sfxge_tx_qreap
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|reaped
operator|==
name|txq
operator|->
name|completed
argument_list|,
operator|(
literal|"txq->reaped != txq->completed"
operator|)
argument_list|)
expr_stmt|;
name|txq
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|completed
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|reaped
operator|=
literal|0
expr_stmt|;
comment|/* Destroy the common code transmit queue. */
name|efx_tx_qdestroy
argument_list|(
name|txq
operator|->
name|common
argument_list|)
expr_stmt|;
name|txq
operator|->
name|common
operator|=
name|NULL
expr_stmt|;
name|efx_sram_buf_tbl_clear
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|)
expr_stmt|;
name|SFXGE_EVQ_UNLOCK
argument_list|(
name|evq
argument_list|)
expr_stmt|;
name|SFXGE_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_qstart
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|unsigned
name|int
name|desc_index
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|SFXGE_ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|index
index|]
expr_stmt|;
name|esmp
operator|=
operator|&
name|txq
operator|->
name|mem
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|txq
operator|->
name|evq_index
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|init_state
operator|==
name|SFXGE_TXQ_INITIALIZED
argument_list|,
operator|(
literal|"txq->init_state != SFXGE_TXQ_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|evq
operator|->
name|init_state
operator|==
name|SFXGE_EVQ_STARTED
argument_list|,
operator|(
literal|"evq->init_state != SFXGE_EVQ_STARTED"
operator|)
argument_list|)
expr_stmt|;
comment|/* Program the buffer table. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_sram_buf_tbl_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|esmp
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Determine the kind of queue we are creating. */
switch|switch
condition|(
name|txq
operator|->
name|type
condition|)
block|{
case|case
name|SFXGE_TXQ_NON_CKSUM
case|:
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SFXGE_TXQ_IP_CKSUM
case|:
name|flags
operator|=
name|EFX_CKSUM_IPV4
expr_stmt|;
break|break;
case|case
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
case|:
name|flags
operator|=
name|EFX_CKSUM_IPV4
operator||
name|EFX_CKSUM_TCPUDP
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"Impossible TX queue"
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Create the common code transmit queue. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_tx_qcreate
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|index
argument_list|,
name|txq
operator|->
name|type
argument_list|,
name|esmp
argument_list|,
name|sc
operator|->
name|txq_entries
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|flags
argument_list|,
name|evq
operator|->
name|common
argument_list|,
operator|&
name|txq
operator|->
name|common
argument_list|,
operator|&
name|desc_index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Initialise queue descriptor indexes */
name|txq
operator|->
name|added
operator|=
name|txq
operator|->
name|pending
operator|=
name|txq
operator|->
name|completed
operator|=
name|txq
operator|->
name|reaped
operator|=
name|desc_index
expr_stmt|;
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Enable the transmit queue. */
name|efx_tx_qenable
argument_list|(
name|txq
operator|->
name|common
argument_list|)
expr_stmt|;
name|txq
operator|->
name|init_state
operator|=
name|SFXGE_TXQ_STARTED
expr_stmt|;
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_REQUIRED
expr_stmt|;
name|SFXGE_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|efx_sram_buf_tbl_clear
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sfxge_tx_stop
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|index
operator|=
name|sc
operator|->
name|txq_count
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Tear down the transmit module */
name|efx_tx_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_tx_start
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Initialize the common code transmit module. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_tx_init
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|sc
operator|->
name|txq_count
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qstart
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|efx_tx_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_txq_stat_init
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|txq_node
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|txq
operator|->
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|stat_node
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|stat_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|txq_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Tx queue statistics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_node
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|nitems
argument_list|(
name|sfxge_tx_stats
argument_list|)
condition|;
name|id
operator|++
control|)
block|{
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|sfxge_tx_stats
index|[
name|id
index|]
operator|.
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_STATS
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|txq
operator|+
name|sfxge_tx_stats
index|[
name|id
index|]
operator|.
name|offset
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Destroy a transmit queue.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qfini
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|unsigned
name|int
name|nmaps
decl_stmt|;
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|index
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|init_state
operator|==
name|SFXGE_TXQ_INITIALIZED
argument_list|,
operator|(
literal|"txq->init_state != SFXGE_TXQ_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|type
operator|==
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
condition|)
name|tso_fini
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Free the context arrays. */
name|free
argument_list|(
name|txq
operator|->
name|pend_desc
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|nmaps
operator|=
name|sc
operator|->
name|txq_entries
expr_stmt|;
while|while
condition|(
name|nmaps
operator|--
operator|!=
literal|0
condition|)
name|bus_dmamap_destroy
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|txq
operator|->
name|stmp
index|[
name|nmaps
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|stmp
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
comment|/* Release DMA memory mapping. */
name|sfxge_dma_free
argument_list|(
operator|&
name|txq
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txq
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
name|SFXGE_TXQ_LOCK_DESTROY
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Estimate maximum number of Tx descriptors required for TSO packet.  * With minimum MSS and maximum mbuf length we might need more (even  * than a ring-ful of descriptors), but this should not happen in  * practice except due to deliberate attack.  In that case we will  * truncate the output at a packet boundary.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|sfxge_tx_max_pkt_desc
parameter_list|(
specifier|const
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|sfxge_txq_type
name|type
parameter_list|)
block|{
comment|/* One descriptor for every input fragment */
name|unsigned
name|int
name|max_descs
init|=
name|SFXGE_TX_MAPPING_MAX_SEG
decl_stmt|;
comment|/* VLAN tagging Tx option descriptor may be required */
if|if
condition|(
name|efx_nic_cfg_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|->
name|enc_hw_tx_insert_vlan_enabled
condition|)
name|max_descs
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
condition|)
block|{
comment|/* 		 * Plus header and payload descriptor for each output segment. 		 * Minus one since header fragment is already counted. 		 */
name|max_descs
operator|+=
name|SFXGE_TSO_MAX_SEGS
operator|*
literal|2
operator|-
literal|1
expr_stmt|;
comment|/* FW assisted TSO requires one more descriptor per segment */
if|if
condition|(
name|sc
operator|->
name|tso_fw_assisted
condition|)
name|max_descs
operator|+=
name|SFXGE_TSO_MAX_SEGS
expr_stmt|;
block|}
return|return
operator|(
name|max_descs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_qinit
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|txq_index
parameter_list|,
name|enum
name|sfxge_txq_type
name|type
parameter_list|,
name|unsigned
name|int
name|evq_index
parameter_list|)
block|{
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|txq_node
decl_stmt|;
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|dpl_node
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
decl_stmt|;
name|unsigned
name|int
name|nmaps
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|txq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfxge_txq
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|txq
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|txq
operator|->
name|entries
operator|=
name|sc
operator|->
name|txq_entries
expr_stmt|;
name|txq
operator|->
name|ptr_mask
operator|=
name|txq
operator|->
name|entries
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|txq
index|[
name|txq_index
index|]
operator|=
name|txq
expr_stmt|;
name|esmp
operator|=
operator|&
name|txq
operator|->
name|mem
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|evq_index
index|]
expr_stmt|;
comment|/* Allocate and zero DMA space for the descriptor ring. */
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_dma_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_TXQ_SIZE
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|,
name|esmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Allocate buffer table entries. */
name|sfxge_sram_buf_tbl_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|,
operator|&
name|txq
operator|->
name|buf_base_id
argument_list|)
expr_stmt|;
comment|/* Create a DMA tag for packet mappings. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|,
literal|1
argument_list|,
literal|0x1000
argument_list|,
name|MIN
argument_list|(
literal|0x3FFFFFFFFFFFUL
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0x11000
argument_list|,
name|SFXGE_TX_MAPPING_MAX_SEG
argument_list|,
literal|0x1000
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|txq
operator|->
name|packet_dma_tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Couldn't allocate txq DMA tag\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate pending descriptor array for batching writes. */
name|txq
operator|->
name|pend_desc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|efx_desc_t
argument_list|)
operator|*
name|sc
operator|->
name|txq_entries
argument_list|,
name|M_SFXGE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Allocate and initialise mbuf DMA mapping array. */
name|txq
operator|->
name|stmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfxge_tx_mapping
argument_list|)
operator|*
name|sc
operator|->
name|txq_entries
argument_list|,
name|M_SFXGE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|nmaps
operator|=
literal|0
init|;
name|nmaps
operator|<
name|sc
operator|->
name|txq_entries
condition|;
name|nmaps
operator|++
control|)
block|{
name|rc
operator|=
name|bus_dmamap_create
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txq
operator|->
name|stmp
index|[
name|nmaps
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
block|}
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|txq_index
argument_list|)
expr_stmt|;
name|txq_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|txqs_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq_node
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_txq_node
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|&&
operator|(
name|rc
operator|=
name|tso_init
argument_list|(
name|txq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
if|if
condition|(
name|sfxge_tx_dpl_get_max
operator|<=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s=%d must be greater than 0"
argument_list|,
name|SFXGE_PARAM_TX_DPL_GET_MAX
argument_list|,
name|sfxge_tx_dpl_get_max
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail_tx_dpl_get_max
goto|;
block|}
if|if
condition|(
name|sfxge_tx_dpl_get_non_tcp_max
operator|<=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s=%d must be greater than 0"
argument_list|,
name|SFXGE_PARAM_TX_DPL_GET_NON_TCP_MAX
argument_list|,
name|sfxge_tx_dpl_get_non_tcp_max
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail_tx_dpl_get_max
goto|;
block|}
if|if
condition|(
name|sfxge_tx_dpl_put_max
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s=%d must be greater or equal to 0"
argument_list|,
name|SFXGE_PARAM_TX_DPL_PUT_MAX
argument_list|,
name|sfxge_tx_dpl_put_max
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail_tx_dpl_put_max
goto|;
block|}
comment|/* Initialize the deferred packet list. */
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
name|stdp
operator|->
name|std_put_max
operator|=
name|sfxge_tx_dpl_put_max
expr_stmt|;
name|stdp
operator|->
name|std_get_max
operator|=
name|sfxge_tx_dpl_get_max
expr_stmt|;
name|stdp
operator|->
name|std_get_non_tcp_max
operator|=
name|sfxge_tx_dpl_get_non_tcp_max
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|stdp
operator|->
name|std_get
expr_stmt|;
name|SFXGE_TXQ_LOCK_INIT
argument_list|(
name|txq
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|txq_index
argument_list|)
expr_stmt|;
name|dpl_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|txq_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dpl"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Deferred packet list statistics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpl_node
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_dpl_node
goto|;
block|}
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|dpl_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"get_count"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_STATS
argument_list|,
operator|&
name|stdp
operator|->
name|std_get_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|dpl_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"get_non_tcp_count"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_STATS
argument_list|,
operator|&
name|stdp
operator|->
name|std_get_non_tcp_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|dpl_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"get_hiwat"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_STATS
argument_list|,
operator|&
name|stdp
operator|->
name|std_get_hiwat
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|dpl_node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"put_hiwat"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_STATS
argument_list|,
operator|&
name|stdp
operator|->
name|std_put_hiwat
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sfxge_txq_stat_init
argument_list|(
name|txq
argument_list|,
name|txq_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail_txq_stat_init
goto|;
name|txq
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|txq
operator|->
name|evq_index
operator|=
name|evq_index
expr_stmt|;
name|txq
operator|->
name|txq_index
operator|=
name|txq_index
expr_stmt|;
name|txq
operator|->
name|init_state
operator|=
name|SFXGE_TXQ_INITIALIZED
expr_stmt|;
name|txq
operator|->
name|hw_vlan_tci
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|max_pkt_desc
operator|=
name|sfxge_tx_max_pkt_desc
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_txq_stat_init
label|:
name|fail_dpl_node
label|:
name|fail_tx_dpl_put_max
label|:
name|fail_tx_dpl_get_max
label|:
name|fail3
label|:
name|fail_txq_node
label|:
name|free
argument_list|(
name|txq
operator|->
name|pend_desc
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|fail2
label|:
while|while
condition|(
name|nmaps
operator|--
operator|!=
literal|0
condition|)
name|bus_dmamap_destroy
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|txq
operator|->
name|stmp
index|[
name|nmaps
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|stmp
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|)
expr_stmt|;
name|fail
label|:
name|sfxge_dma_free
argument_list|(
name|esmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_stat_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|unsigned
name|int
name|id
init|=
name|arg2
decl_stmt|;
name|unsigned
name|long
name|sum
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
comment|/* Sum across all TX queues */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|sc
operator|->
name|txq_count
condition|;
name|index
operator|++
control|)
name|sum
operator|+=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|txq
index|[
name|index
index|]
operator|+
name|sfxge_tx_stats
index|[
name|id
index|]
operator|.
name|offset
operator|)
expr_stmt|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|sum
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_stat_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|stats_node
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|nitems
argument_list|(
name|sfxge_tx_stats
argument_list|)
condition|;
name|id
operator|++
control|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|sfxge_tx_stats
index|[
name|id
index|]
operator|.
name|name
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|id
argument_list|,
name|sfxge_tx_stat_handler
argument_list|,
literal|"LU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|sfxge_tx_get_drops
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|uint64_t
name|drops
init|=
literal|0
decl_stmt|;
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
comment|/* Sum across all TX queues */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|sc
operator|->
name|txq_count
condition|;
name|index
operator|++
control|)
block|{
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|index
index|]
expr_stmt|;
comment|/* 		 * In theory, txq->put_overflow and txq->netdown_drops 		 * should use atomic operation and other should be 		 * obtained under txq lock, but it is just statistics. 		 */
name|drops
operator|+=
name|txq
operator|->
name|drops
operator|+
name|txq
operator|->
name|get_overflow
operator|+
name|txq
operator|->
name|get_non_tcp_overflow
operator|+
name|txq
operator|->
name|put_overflow
operator|+
name|txq
operator|->
name|netdown_drops
operator|+
name|txq
operator|->
name|tso_pdrop_too_many
operator|+
name|txq
operator|->
name|tso_pdrop_no_rsrc
expr_stmt|;
block|}
return|return
operator|(
name|drops
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sfxge_tx_update_stats
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|ifnet
operator|->
name|if_oerrors
operator|+=
name|sfxge_tx_get_drops
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sfxge_tx_fini
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|index
operator|=
name|sc
operator|->
name|txq_count
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txq_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_tx_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
name|efx_nic_cfg_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
decl_stmt|;
name|struct
name|sfxge_intr
modifier|*
name|intr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|intr
operator|=
operator|&
name|sc
operator|->
name|intr
expr_stmt|;
name|KASSERT
argument_list|(
name|intr
operator|->
name|state
operator|==
name|SFXGE_INTR_INITIALIZED
argument_list|,
operator|(
literal|"intr->state != SFXGE_INTR_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txq_count
operator|=
name|SFXGE_TXQ_NTYPES
operator|-
literal|1
operator|+
name|sc
operator|->
name|intr
operator|.
name|n_alloc
expr_stmt|;
name|sc
operator|->
name|tso_fw_assisted
operator|=
name|sfxge_tso_fw_assisted
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tso_fw_assisted
condition|)
name|sc
operator|->
name|tso_fw_assisted
operator|=
operator|(
name|encp
operator|->
name|enc_features
operator|&
name|EFX_FEATURE_FW_ASSISTED_TSO
operator|)
operator|&&
operator|(
name|encp
operator|->
name|enc_fw_assisted_tso_enabled
operator|)
expr_stmt|;
name|sc
operator|->
name|txqs_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Tx queues"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txqs_node
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_txq_node
goto|;
block|}
comment|/* Initialize the transmit queues */
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qinit
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qinit
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|sc
operator|->
name|txq_count
operator|-
name|SFXGE_TXQ_NTYPES
operator|+
literal|1
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qinit
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NTYPES
operator|-
literal|1
operator|+
name|index
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
block|}
name|sfxge_tx_stat_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
argument_list|)
expr_stmt|;
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|)
expr_stmt|;
name|fail2
label|:
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|)
expr_stmt|;
name|fail
label|:
name|fail_txq_node
label|:
name|sc
operator|->
name|txq_count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

