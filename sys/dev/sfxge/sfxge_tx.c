begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Solarflare Communications, Inc.  * All rights reserved.  *  * This software was developed in part by Philip Paeps under contract for  * Solarflare Communications, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Theory of operation:  *  * Tx queues allocation and mapping  *  * One Tx queue with enabled checksum offload is allocated per Rx channel  * (event queue).  Also 2 Tx queues (one without checksum offload and one  * with IP checksum offload only) are allocated and bound to event queue 0.  * sfxge_txq_type is used as Tx queue label.  *  * So, event queue plus label mapping to Tx queue index is:  *	if event queue index is 0, TxQ-index = TxQ-label * [0..SFXGE_TXQ_NTYPES)  *	else TxQ-index = SFXGE_TXQ_NTYPES + EvQ-index - 1  * See sfxge_get_txq_by_label() sfxge_ev.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|"common/efx.h"
end_include

begin_include
include|#
directive|include
file|"sfxge.h"
end_include

begin_include
include|#
directive|include
file|"sfxge_tx.h"
end_include

begin_comment
comment|/* Set the block level to ensure there is space to generate a  * large number of descriptors for TSO.  With minimum MSS and  * maximum mbuf length we might need more than a ring-ful of  * descriptors, but this should not happen in practice except  * due to deliberate attack.  In that case we will truncate  * the output at a packet boundary.  Allow for a reasonable  * minimum MSS of 512.  */
end_comment

begin_define
define|#
directive|define
name|SFXGE_TSO_MAX_DESC
value|((65535 / 512) * 2 + SFXGE_TX_MAPPING_MAX_SEG - 1)
end_define

begin_define
define|#
directive|define
name|SFXGE_TXQ_BLOCK_LEVEL
parameter_list|(
name|_entries
parameter_list|)
value|((_entries) - SFXGE_TSO_MAX_DESC)
end_define

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|sfxge_tx_qdpl_service
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sfxge_tx_qlist_post
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sfxge_tx_qunblock
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sfxge_tx_queue_tso
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
specifier|const
name|bus_dma_segment_t
modifier|*
name|dma_seg
parameter_list|,
name|int
name|n_dma_seg
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|sfxge_tx_qcomplete
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|unsigned
name|int
name|completed
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|sc
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|txq
operator|->
name|evq_index
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|completed
operator|=
name|txq
operator|->
name|completed
expr_stmt|;
while|while
condition|(
name|completed
operator|!=
name|txq
operator|->
name|pending
condition|)
block|{
name|struct
name|sfxge_tx_mapping
modifier|*
name|stmp
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|id
operator|=
name|completed
operator|++
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
name|stmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|stmp
operator|->
name|flags
operator|&
name|TX_BUF_UNMAP
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmp
operator|->
name|flags
operator|&
name|TX_BUF_MBUF
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|stmp
operator|->
name|u
operator|.
name|mbuf
decl_stmt|;
do|do
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
block|}
else|else
block|{
name|free
argument_list|(
name|stmp
operator|->
name|u
operator|.
name|heap_buf
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
name|stmp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|txq
operator|->
name|completed
operator|=
name|completed
expr_stmt|;
comment|/* Check whether we need to unblock the queue. */
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|blocked
condition|)
block|{
name|unsigned
name|int
name|level
decl_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|completed
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|SFXGE_TXQ_UNBLOCK_LEVEL
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
condition|)
name|sfxge_tx_qunblock
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SFXGE_HAVE_MQ
end_ifdef

begin_comment
comment|/*  * Reorder the put list and append it to the get list.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qdpl_swizzle
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|get_next
decl_stmt|,
modifier|*
modifier|*
name|get_tailp
decl_stmt|;
specifier|volatile
name|uintptr_t
modifier|*
name|putp
decl_stmt|;
name|uintptr_t
name|put
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
comment|/* Acquire the put list. */
name|putp
operator|=
operator|&
name|stdp
operator|->
name|std_put
expr_stmt|;
name|put
operator|=
name|atomic_readandclear_ptr
argument_list|(
name|putp
argument_list|)
expr_stmt|;
name|mbuf
operator|=
operator|(
name|void
operator|*
operator|)
name|put
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return;
comment|/* Reverse the put list. */
name|get_tailp
operator|=
operator|&
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|get_next
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|struct
name|mbuf
modifier|*
name|put_next
decl_stmt|;
name|put_next
operator|=
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|mbuf
operator|->
name|m_nextpkt
operator|=
name|get_next
expr_stmt|;
name|get_next
operator|=
name|mbuf
expr_stmt|;
name|mbuf
operator|=
name|put_next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
do|;
comment|/* Append the reversed put list to the get list. */
name|KASSERT
argument_list|(
operator|*
name|get_tailp
operator|==
name|NULL
argument_list|,
operator|(
literal|"*get_tailp != NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|stdp
operator|->
name|std_getp
operator|=
name|get_next
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
name|get_tailp
expr_stmt|;
name|stdp
operator|->
name|std_count
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SFXGE_HAVE_MQ */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qreap
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|txq
operator|->
name|reaped
operator|=
name|txq
operator|->
name|completed
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qlist_post
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|unsigned
name|int
name|old_added
decl_stmt|;
name|unsigned
name|int
name|level
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mtx_assert
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|n_pend_desc
operator|!=
literal|0
argument_list|,
operator|(
literal|"txq->n_pend_desc == 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|n_pend_desc
operator|<=
name|SFXGE_TSO_MAX_DESC
argument_list|,
operator|(
literal|"txq->n_pend_desc too large"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|txq
operator|->
name|blocked
argument_list|,
operator|(
literal|"txq->blocked"
operator|)
argument_list|)
expr_stmt|;
name|old_added
operator|=
name|txq
operator|->
name|added
expr_stmt|;
comment|/* Post the fragment list. */
name|rc
operator|=
name|efx_tx_qpost
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|pend_desc
argument_list|,
name|txq
operator|->
name|n_pend_desc
argument_list|,
name|txq
operator|->
name|reaped
argument_list|,
operator|&
name|txq
operator|->
name|added
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|0
argument_list|,
operator|(
literal|"efx_tx_qpost() failed"
operator|)
argument_list|)
expr_stmt|;
comment|/* If efx_tx_qpost() had to refragment, our information about 	 * buffers to free may be associated with the wrong 	 * descriptors. 	 */
name|KASSERT
argument_list|(
name|txq
operator|->
name|added
operator|-
name|old_added
operator|==
name|txq
operator|->
name|n_pend_desc
argument_list|,
operator|(
literal|"efx_tx_qpost() refragmented descriptors"
operator|)
argument_list|)
expr_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|reaped
expr_stmt|;
name|KASSERT
argument_list|(
name|level
operator|<=
name|txq
operator|->
name|entries
argument_list|,
operator|(
literal|"overfilled TX queue"
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear the fragment list. */
name|txq
operator|->
name|n_pend_desc
operator|=
literal|0
expr_stmt|;
comment|/* Have we reached the block level? */
if|if
condition|(
name|level
operator|<
name|SFXGE_TXQ_BLOCK_LEVEL
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
condition|)
return|return;
comment|/* Reap, and check again */
name|sfxge_tx_qreap
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|reaped
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|SFXGE_TXQ_BLOCK_LEVEL
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
condition|)
return|return;
name|txq
operator|->
name|blocked
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Avoid a race with completion interrupt handling that could leave 	 * the queue blocked. 	 */
name|mb
argument_list|()
expr_stmt|;
name|sfxge_tx_qreap
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|reaped
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|SFXGE_TXQ_BLOCK_LEVEL
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
condition|)
block|{
name|mb
argument_list|()
expr_stmt|;
name|txq
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_queue_mbuf
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|bus_dmamap_t
modifier|*
name|used_map
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_segment_t
name|dma_seg
index|[
name|SFXGE_TX_MAPPING_MAX_SEG
index|]
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|struct
name|sfxge_tx_mapping
modifier|*
name|stmp
decl_stmt|;
name|efx_buffer_t
modifier|*
name|desc
decl_stmt|;
name|int
name|n_dma_seg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|txq
operator|->
name|blocked
argument_list|,
operator|(
literal|"txq->blocked"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
name|prefetch_read_many
argument_list|(
name|mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|init_state
operator|!=
name|SFXGE_TXQ_STARTED
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
comment|/* Load the packet for DMA. */
name|id
operator|=
name|txq
operator|->
name|added
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
name|stmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
name|id
index|]
expr_stmt|;
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|mbuf
argument_list|,
name|dma_seg
argument_list|,
operator|&
name|n_dma_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EFBIG
condition|)
block|{
comment|/* Try again. */
name|struct
name|mbuf
modifier|*
name|new_mbuf
init|=
name|m_collapse
argument_list|(
name|mbuf
argument_list|,
name|M_NOWAIT
argument_list|,
name|SFXGE_TX_MAPPING_MAX_SEG
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mbuf
operator|==
name|NULL
condition|)
goto|goto
name|reject
goto|;
operator|++
name|txq
operator|->
name|collapses
expr_stmt|;
name|mbuf
operator|=
name|new_mbuf
expr_stmt|;
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|mbuf
argument_list|,
name|dma_seg
argument_list|,
operator|&
name|n_dma_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|reject
goto|;
comment|/* Make the packet visible to the hardware. */
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|used_map
operator|=
operator|&
name|stmp
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|rc
operator|=
name|sfxge_tx_queue_tso
argument_list|(
name|txq
argument_list|,
name|mbuf
argument_list|,
name|dma_seg
argument_list|,
name|n_dma_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|reject_mapped
goto|;
name|stmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
name|rc
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the mapping to the fragment list, and set flags 		 * for the buffer. 		 */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|desc
operator|=
operator|&
name|txq
operator|->
name|pend_desc
index|[
name|i
index|]
expr_stmt|;
name|desc
operator|->
name|eb_addr
operator|=
name|dma_seg
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|desc
operator|->
name|eb_size
operator|=
name|dma_seg
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n_dma_seg
operator|-
literal|1
condition|)
block|{
name|desc
operator|->
name|eb_eop
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|desc
operator|->
name|eb_eop
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|stmp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|stmp
operator|==
operator|&
name|txq
operator|->
name|stmp
index|[
name|txq
operator|->
name|ptr_mask
index|]
argument_list|)
condition|)
name|stmp
operator|=
operator|&
name|txq
operator|->
name|stmp
index|[
literal|0
index|]
expr_stmt|;
else|else
name|stmp
operator|++
expr_stmt|;
block|}
name|txq
operator|->
name|n_pend_desc
operator|=
name|n_dma_seg
expr_stmt|;
block|}
comment|/* 	 * If the mapping required more than one descriptor 	 * then we need to associate the DMA map with the last 	 * descriptor, not the first. 	 */
if|if
condition|(
name|used_map
operator|!=
operator|&
name|stmp
operator|->
name|map
condition|)
block|{
name|map
operator|=
name|stmp
operator|->
name|map
expr_stmt|;
name|stmp
operator|->
name|map
operator|=
operator|*
name|used_map
expr_stmt|;
operator|*
name|used_map
operator|=
name|map
expr_stmt|;
block|}
name|stmp
operator|->
name|u
operator|.
name|mbuf
operator|=
name|mbuf
expr_stmt|;
name|stmp
operator|->
name|flags
operator|=
name|TX_BUF_UNMAP
operator||
name|TX_BUF_MBUF
expr_stmt|;
comment|/* Post the fragment list. */
name|sfxge_tx_qlist_post
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|reject_mapped
label|:
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
operator|*
name|used_map
argument_list|)
expr_stmt|;
name|reject
label|:
comment|/* Drop the packet on the floor. */
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
operator|++
name|txq
operator|->
name|drops
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SFXGE_HAVE_MQ
end_ifdef

begin_comment
comment|/*  * Drain the deferred packet list into the transmit queue.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qdpl_drain
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|pushed
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sc
operator|=
name|txq
operator|->
name|sc
expr_stmt|;
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
name|pushed
operator|=
name|txq
operator|->
name|added
expr_stmt|;
name|prefetch_read_many
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|prefetch_read_many
argument_list|(
name|txq
operator|->
name|common
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|stdp
operator|->
name|std_get
expr_stmt|;
name|count
operator|=
name|stdp
operator|->
name|std_count
expr_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|mbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mbuf == NULL"
operator|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|mbuf
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|sc
operator|->
name|ifnet
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
comment|/* packet capture */
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|prefetch_read_many
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sfxge_tx_queue_mbuf
argument_list|(
name|txq
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
operator|--
name|count
expr_stmt|;
name|mbuf
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|txq
operator|->
name|blocked
condition|)
break|break;
comment|/* Push the fragments to the hardware in batches. */
if|if
condition|(
name|txq
operator|->
name|added
operator|-
name|pushed
operator|>=
name|SFXGE_TX_BATCH
condition|)
block|{
name|efx_tx_qpush
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|added
argument_list|)
expr_stmt|;
name|pushed
operator|=
name|txq
operator|->
name|added
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|mbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf != NULL"
operator|)
argument_list|)
expr_stmt|;
name|stdp
operator|->
name|std_get
operator|=
name|NULL
expr_stmt|;
name|stdp
operator|->
name|std_count
operator|=
literal|0
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|stdp
operator|->
name|std_get
expr_stmt|;
block|}
else|else
block|{
name|stdp
operator|->
name|std_get
operator|=
name|mbuf
expr_stmt|;
name|stdp
operator|->
name|std_count
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|added
operator|!=
name|pushed
condition|)
name|efx_tx_qpush
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|added
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|blocked
operator|||
name|stdp
operator|->
name|std_count
operator|==
literal|0
argument_list|,
operator|(
literal|"queue unblocked but count is non-zero"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SFXGE_TX_QDPL_PENDING
parameter_list|(
name|_txq
parameter_list|)
define|\
value|((_txq)->dpl.std_put != 0)
end_define

begin_comment
comment|/*  * Service the deferred packet list.  *  * NOTE: drops the txq mutex!  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|sfxge_tx_qdpl_service
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|SFXGE_TX_QDPL_PENDING
argument_list|(
name|txq
argument_list|)
condition|)
name|sfxge_tx_qdpl_swizzle
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|txq
operator|->
name|blocked
condition|)
name|sfxge_tx_qdpl_drain
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|SFXGE_TX_QDPL_PENDING
argument_list|(
name|txq
argument_list|)
operator|&&
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Put a packet on the deferred packet list.  *  * If we are called with the txq lock held, we put the packet on the "get  * list", otherwise we atomically push it on the "put list".  The swizzle  * function takes care of ordering.  *  * The length of the put list is bounded by SFXGE_TX_MAX_DEFFERED.  We  * overload the csum_data field in the mbuf to keep track of this length  * because there is no cheap alternative to avoid races.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sfxge_tx_qdpl_put
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
name|KASSERT
argument_list|(
name|mbuf
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf->m_nextpkt != NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sfxge_tx_qdpl_swizzle
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdp
operator|->
name|std_count
operator|>=
name|SFXGE_TX_DPL_GET_PKT_LIMIT_DEFAULT
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
operator|*
operator|(
name|stdp
operator|->
name|std_getp
operator|)
operator|=
name|mbuf
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|stdp
operator|->
name|std_count
operator|++
expr_stmt|;
block|}
else|else
block|{
specifier|volatile
name|uintptr_t
modifier|*
name|putp
decl_stmt|;
name|uintptr_t
name|old
decl_stmt|;
name|uintptr_t
name|new
decl_stmt|;
name|unsigned
name|old_len
decl_stmt|;
name|putp
operator|=
operator|&
name|stdp
operator|->
name|std_put
expr_stmt|;
name|new
operator|=
operator|(
name|uintptr_t
operator|)
name|mbuf
expr_stmt|;
do|do
block|{
name|old
operator|=
operator|*
name|putp
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
init|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|old
decl_stmt|;
name|old_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
block|}
else|else
name|old_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old_len
operator|>=
name|SFXGE_TX_DPL_PUT_PKT_LIMIT_DEFAULT
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|old_len
operator|+
literal|1
expr_stmt|;
name|mbuf
operator|->
name|m_nextpkt
operator|=
operator|(
name|void
operator|*
operator|)
name|old
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cmpset_ptr
argument_list|(
name|putp
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from if_transmit - will try to grab the txq lock and enqueue to the  * put list if it succeeds, otherwise will push onto the defer list.  */
end_comment

begin_function
name|int
name|sfxge_tx_packet_add
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|locked
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|SFXGE_LINK_UP
argument_list|(
name|txq
operator|->
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Try to grab the txq lock.  If we are able to get the lock, 	 * the packet will be appended to the "get list" of the deferred 	 * packet list.  Otherwise, it will be pushed on the "put list". 	 */
name|locked
operator|=
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfxge_tx_qdpl_put
argument_list|(
name|txq
argument_list|,
name|m
argument_list|,
name|locked
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|locked
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Try to grab the lock again. 	 * 	 * If we are able to get the lock, we need to process the deferred 	 * packet list.  If we are not able to get the lock, another thread 	 * is processing the list. 	 */
if|if
condition|(
operator|!
name|locked
condition|)
name|locked
operator|=
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
comment|/* Try to service the list. */
name|sfxge_tx_qdpl_service
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Lock has been dropped. */
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|txq
operator|->
name|early_drops
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qdpl_flush
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
init|=
operator|&
name|txq
operator|->
name|dpl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sfxge_tx_qdpl_swizzle
argument_list|(
name|txq
argument_list|)
expr_stmt|;
for|for
control|(
name|mbuf
operator|=
name|stdp
operator|->
name|std_get
init|;
name|mbuf
operator|!=
name|NULL
condition|;
name|mbuf
operator|=
name|next
control|)
block|{
name|next
operator|=
name|mbuf
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
block|}
name|stdp
operator|->
name|std_get
operator|=
name|NULL
expr_stmt|;
name|stdp
operator|->
name|std_count
operator|=
literal|0
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|stdp
operator|->
name|std_get
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sfxge_if_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SFXGE_TX_SCALE
argument_list|(
name|sc
argument_list|)
condition|;
name|i
operator|++
control|)
name|sfxge_tx_qdpl_flush
argument_list|(
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TX start -- called by the stack.  */
end_comment

begin_function
name|int
name|sfxge_if_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sfxge_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
argument_list|,
operator|(
literal|"interface not up"
operator|)
argument_list|)
expr_stmt|;
comment|/* Pick the desired transmit queue. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_TSO
operator|)
condition|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
block|{
name|uint32_t
name|hash
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
decl_stmt|;
name|index
operator|=
name|sc
operator|->
name|rx_indir_table
index|[
name|hash
operator|%
name|SFXGE_RX_SCALE_MAX
index|]
expr_stmt|;
block|}
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_IP
condition|)
block|{
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|SFXGE_TXQ_IP_CKSUM
index|]
expr_stmt|;
block|}
else|else
block|{
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|SFXGE_TXQ_NON_CKSUM
index|]
expr_stmt|;
block|}
name|rc
operator|=
name|sfxge_tx_packet_add
argument_list|(
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SFXGE_HAVE_MQ */
end_comment

begin_function
specifier|static
name|void
name|sfxge_if_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|unsigned
name|int
name|pushed
index|[
name|SFXGE_TXQ_NTYPES
index|]
decl_stmt|;
name|unsigned
name|int
name|q_index
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
if|if
condition|(
operator|!
name|sc
operator|->
name|port
operator|.
name|link_up
condition|)
return|return;
for|for
control|(
name|q_index
operator|=
literal|0
init|;
name|q_index
operator|<
name|SFXGE_TXQ_NTYPES
condition|;
name|q_index
operator|++
control|)
block|{
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|q_index
index|]
expr_stmt|;
name|pushed
index|[
name|q_index
index|]
operator|=
name|txq
operator|->
name|added
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
break|break;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
comment|/* packet capture */
comment|/* Pick the desired transmit queue. */
if|if
condition|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_TSO
operator|)
condition|)
name|q_index
operator|=
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_IP
condition|)
name|q_index
operator|=
name|SFXGE_TXQ_IP_CKSUM
expr_stmt|;
else|else
name|q_index
operator|=
name|SFXGE_TXQ_NON_CKSUM
expr_stmt|;
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|q_index
index|]
expr_stmt|;
if|if
condition|(
name|sfxge_tx_queue_mbuf
argument_list|(
name|txq
argument_list|,
name|mbuf
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|txq
operator|->
name|blocked
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
comment|/* Push the fragments to the hardware in batches. */
if|if
condition|(
name|txq
operator|->
name|added
operator|-
name|pushed
index|[
name|q_index
index|]
operator|>=
name|SFXGE_TX_BATCH
condition|)
block|{
name|efx_tx_qpush
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|added
argument_list|)
expr_stmt|;
name|pushed
index|[
name|q_index
index|]
operator|=
name|txq
operator|->
name|added
expr_stmt|;
block|}
block|}
for|for
control|(
name|q_index
operator|=
literal|0
init|;
name|q_index
operator|<
name|SFXGE_TXQ_NTYPES
condition|;
name|q_index
operator|++
control|)
block|{
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|q_index
index|]
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|added
operator|!=
name|pushed
index|[
name|q_index
index|]
condition|)
name|efx_tx_qpush
argument_list|(
name|txq
operator|->
name|common
argument_list|,
name|txq
operator|->
name|added
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sfxge_if_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|sfxge_if_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|sfxge_tx_qdpl_service
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|txq
operator|->
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifnet
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sfxge_if_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SFXGE_HAVE_MQ */
end_comment

begin_comment
comment|/*  * Software "TSO".  Not quite as good as doing it in hardware, but  * still faster than segmenting in the stack.  */
end_comment

begin_struct
struct|struct
name|sfxge_tso_state
block|{
comment|/* Output position */
name|unsigned
name|out_len
decl_stmt|;
comment|/* Remaining length in current segment */
name|unsigned
name|seqnum
decl_stmt|;
comment|/* Current sequence number */
name|unsigned
name|packet_space
decl_stmt|;
comment|/* Remaining space in current packet */
comment|/* Input position */
name|unsigned
name|dma_seg_i
decl_stmt|;
comment|/* Current DMA segment number */
name|uint64_t
name|dma_addr
decl_stmt|;
comment|/* DMA address of current position */
name|unsigned
name|in_len
decl_stmt|;
comment|/* Remaining length in current mbuf */
specifier|const
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
comment|/* Input mbuf (head of chain) */
name|u_short
name|protocol
decl_stmt|;
comment|/* Network protocol (after VLAN decap) */
name|ssize_t
name|nh_off
decl_stmt|;
comment|/* Offset of network header */
name|ssize_t
name|tcph_off
decl_stmt|;
comment|/* Offset of TCP header */
name|unsigned
name|header_len
decl_stmt|;
comment|/* Number of bytes of header */
name|int
name|full_packet_size
decl_stmt|;
comment|/* Number of bytes to put in each outgoing 				 * segment */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|ip
modifier|*
name|tso_iph
parameter_list|(
specifier|const
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
argument_list|,
operator|(
literal|"tso_iph() in non-IPv4 state"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
expr|struct
name|ip
operator|*
operator|)
operator|(
name|tso
operator|->
name|mbuf
operator|->
name|m_data
operator|+
name|tso
operator|->
name|nh_off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|tso_ip6h
parameter_list|(
specifier|const
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
argument_list|,
operator|(
literal|"tso_ip6h() in non-IPv6 state"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|tso
operator|->
name|mbuf
operator|->
name|m_data
operator|+
name|tso
operator|->
name|nh_off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|tcphdr
modifier|*
name|tso_tcph
parameter_list|(
specifier|const
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|)
block|{
return|return
operator|(
specifier|const
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|tso
operator|->
name|mbuf
operator|->
name|m_data
operator|+
name|tso
operator|->
name|tcph_off
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Size of preallocated TSO header buffers.  Larger blocks must be  * allocated from the heap.  */
end_comment

begin_define
define|#
directive|define
name|TSOH_STD_SIZE
value|128
end_define

begin_comment
comment|/* At most half the descriptors in the queue at any time will refer to  * a TSO header buffer, since they must always be followed by a  * payload descriptor referring to an mbuf.  */
end_comment

begin_define
define|#
directive|define
name|TSOH_COUNT
parameter_list|(
name|_txq_entries
parameter_list|)
value|((_txq_entries) / 2u)
end_define

begin_define
define|#
directive|define
name|TSOH_PER_PAGE
value|(PAGE_SIZE / TSOH_STD_SIZE)
end_define

begin_define
define|#
directive|define
name|TSOH_PAGE_COUNT
parameter_list|(
name|_txq_entries
parameter_list|)
define|\
value|((TSOH_COUNT(_txq_entries) + TSOH_PER_PAGE - 1) / TSOH_PER_PAGE)
end_define

begin_function
specifier|static
name|int
name|tso_init
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|txq
operator|->
name|sc
decl_stmt|;
name|unsigned
name|int
name|tsoh_page_count
init|=
name|TSOH_PAGE_COUNT
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
comment|/* Allocate TSO header buffers */
name|txq
operator|->
name|tsoh_buffer
operator|=
name|malloc
argument_list|(
name|tsoh_page_count
operator|*
sizeof|sizeof
argument_list|(
name|txq
operator|->
name|tsoh_buffer
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tsoh_page_count
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|sfxge_dma_alloc
argument_list|(
name|sc
argument_list|,
name|PAGE_SIZE
argument_list|,
operator|&
name|txq
operator|->
name|tsoh_buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|sfxge_dma_free
argument_list|(
operator|&
name|txq
operator|->
name|tsoh_buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|tsoh_buffer
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|txq
operator|->
name|tsoh_buffer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tso_fini
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|txq
operator|->
name|tsoh_buffer
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSOH_PAGE_COUNT
argument_list|(
name|txq
operator|->
name|sc
operator|->
name|txq_entries
argument_list|)
condition|;
name|i
operator|++
control|)
name|sfxge_dma_free
argument_list|(
operator|&
name|txq
operator|->
name|tsoh_buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|tsoh_buffer
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tso_start
parameter_list|(
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
init|=
name|mtod
argument_list|(
name|mbuf
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
decl_stmt|;
name|tso
operator|->
name|mbuf
operator|=
name|mbuf
expr_stmt|;
comment|/* Find network protocol and header */
name|tso
operator|->
name|protocol
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
if|if
condition|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|veh
init|=
name|mtod
argument_list|(
name|mbuf
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
decl_stmt|;
name|tso
operator|->
name|protocol
operator|=
name|veh
operator|->
name|evl_proto
expr_stmt|;
name|tso
operator|->
name|nh_off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|veh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tso
operator|->
name|nh_off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
block|}
comment|/* Find TCP header */
if|if
condition|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|tso_iph
argument_list|(
name|tso
argument_list|)
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
argument_list|,
operator|(
literal|"TSO required on non-TCP packet"
operator|)
argument_list|)
expr_stmt|;
name|tso
operator|->
name|tcph_off
operator|=
name|tso
operator|->
name|nh_off
operator|+
literal|4
operator|*
name|tso_iph
argument_list|(
name|tso
argument_list|)
operator|->
name|ip_hl
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
argument_list|,
operator|(
literal|"TSO required on non-IP packet"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tso_ip6h
argument_list|(
name|tso
argument_list|)
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_TCP
argument_list|,
operator|(
literal|"TSO required on non-TCP packet"
operator|)
argument_list|)
expr_stmt|;
name|tso
operator|->
name|tcph_off
operator|=
name|tso
operator|->
name|nh_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
block|}
comment|/* We assume all headers are linear in the head mbuf */
name|tso
operator|->
name|header_len
operator|=
name|tso
operator|->
name|tcph_off
operator|+
literal|4
operator|*
name|tso_tcph
argument_list|(
name|tso
argument_list|)
operator|->
name|th_off
expr_stmt|;
name|KASSERT
argument_list|(
name|tso
operator|->
name|header_len
operator|<=
name|mbuf
operator|->
name|m_len
argument_list|,
operator|(
literal|"packet headers fragmented"
operator|)
argument_list|)
expr_stmt|;
name|tso
operator|->
name|full_packet_size
operator|=
name|tso
operator|->
name|header_len
operator|+
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|tso
operator|->
name|seqnum
operator|=
name|ntohl
argument_list|(
name|tso_tcph
argument_list|(
name|tso
argument_list|)
operator|->
name|th_seq
argument_list|)
expr_stmt|;
comment|/* These flags must not be duplicated */
name|KASSERT
argument_list|(
operator|!
operator|(
name|tso_tcph
argument_list|(
name|tso
argument_list|)
operator|->
name|th_flags
operator|&
operator|(
name|TH_URG
operator||
name|TH_SYN
operator||
name|TH_RST
operator|)
operator|)
argument_list|,
operator|(
literal|"incompatible TCP flag on TSO packet"
operator|)
argument_list|)
expr_stmt|;
name|tso
operator|->
name|out_len
operator|=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|tso
operator|->
name|header_len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * tso_fill_packet_with_fragment - form descriptors for the current fragment  *  * Form descriptors for the current fragment, until we reach the end  * of fragment or end-of-packet.  Return 0 on success, 1 if not enough  * space.  */
end_comment

begin_function
specifier|static
name|void
name|tso_fill_packet_with_fragment
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|)
block|{
name|efx_buffer_t
modifier|*
name|desc
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tso
operator|->
name|in_len
operator|==
literal|0
operator|||
name|tso
operator|->
name|packet_space
operator|==
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|tso
operator|->
name|in_len
operator|>
literal|0
argument_list|,
operator|(
literal|"TSO input length went negative"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tso
operator|->
name|packet_space
operator|>
literal|0
argument_list|,
operator|(
literal|"TSO packet space went negative"
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|tso
operator|->
name|in_len
argument_list|,
name|tso
operator|->
name|packet_space
argument_list|)
expr_stmt|;
name|tso
operator|->
name|packet_space
operator|-=
name|n
expr_stmt|;
name|tso
operator|->
name|out_len
operator|-=
name|n
expr_stmt|;
name|tso
operator|->
name|in_len
operator|-=
name|n
expr_stmt|;
name|desc
operator|=
operator|&
name|txq
operator|->
name|pend_desc
index|[
name|txq
operator|->
name|n_pend_desc
operator|++
index|]
expr_stmt|;
name|desc
operator|->
name|eb_addr
operator|=
name|tso
operator|->
name|dma_addr
expr_stmt|;
name|desc
operator|->
name|eb_size
operator|=
name|n
expr_stmt|;
name|desc
operator|->
name|eb_eop
operator|=
name|tso
operator|->
name|out_len
operator|==
literal|0
operator|||
name|tso
operator|->
name|packet_space
operator|==
literal|0
expr_stmt|;
name|tso
operator|->
name|dma_addr
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback from bus_dmamap_load() for long TSO headers. */
end_comment

begin_function
specifier|static
name|void
name|tso_map_long_header
parameter_list|(
name|void
modifier|*
name|dma_addr_ret
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|dma_addr_ret
operator|=
operator|(
operator|(
name|__predict_true
argument_list|(
name|error
operator|==
literal|0
argument_list|)
operator|&&
name|__predict_true
argument_list|(
name|nseg
operator|==
literal|1
argument_list|)
operator|)
condition|?
name|segs
operator|->
name|ds_addr
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * tso_start_new_packet - generate a new header and prepare for the new packet  *  * Generate a new header and prepare for the new packet.  Return 0 on  * success, or an error code if failed to alloc header.  */
end_comment

begin_function
specifier|static
name|int
name|tso_start_new_packet
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sfxge_tso_state
modifier|*
name|tso
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|)
block|{
name|struct
name|sfxge_tx_mapping
modifier|*
name|stmp
init|=
operator|&
name|txq
operator|->
name|stmp
index|[
name|id
index|]
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tsoh_th
decl_stmt|;
name|unsigned
name|ip_length
decl_stmt|;
name|caddr_t
name|header
decl_stmt|;
name|uint64_t
name|dma_addr
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|efx_buffer_t
modifier|*
name|desc
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Allocate a DMA-mapped header buffer. */
if|if
condition|(
name|__predict_true
argument_list|(
name|tso
operator|->
name|header_len
operator|<=
name|TSOH_STD_SIZE
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|page_index
init|=
operator|(
name|id
operator|/
literal|2
operator|)
operator|/
name|TSOH_PER_PAGE
decl_stmt|;
name|unsigned
name|int
name|buf_index
init|=
operator|(
name|id
operator|/
literal|2
operator|)
operator|%
name|TSOH_PER_PAGE
decl_stmt|;
name|header
operator|=
operator|(
name|txq
operator|->
name|tsoh_buffer
index|[
name|page_index
index|]
operator|.
name|esm_base
operator|+
name|buf_index
operator|*
name|TSOH_STD_SIZE
operator|)
expr_stmt|;
name|dma_addr
operator|=
operator|(
name|txq
operator|->
name|tsoh_buffer
index|[
name|page_index
index|]
operator|.
name|esm_addr
operator|+
name|buf_index
operator|*
name|TSOH_STD_SIZE
operator|)
expr_stmt|;
name|map
operator|=
name|txq
operator|->
name|tsoh_buffer
index|[
name|page_index
index|]
operator|.
name|esm_map
expr_stmt|;
name|stmp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We cannot use bus_dmamem_alloc() as that may sleep */
name|header
operator|=
name|malloc
argument_list|(
name|tso
operator|->
name|header_len
argument_list|,
name|M_SFXGE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|header
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|,
name|header
argument_list|,
name|tso
operator|->
name|header_len
argument_list|,
name|tso_map_long_header
argument_list|,
operator|&
name|dma_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|dma_addr
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* Succeeded but got>1 segment */
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|stmp
operator|->
name|map
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|free
argument_list|(
name|header
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|map
operator|=
name|stmp
operator|->
name|map
expr_stmt|;
name|txq
operator|->
name|tso_long_headers
operator|++
expr_stmt|;
name|stmp
operator|->
name|u
operator|.
name|heap_buf
operator|=
name|header
expr_stmt|;
name|stmp
operator|->
name|flags
operator|=
name|TX_BUF_UNMAP
expr_stmt|;
block|}
name|tsoh_th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|header
operator|+
name|tso
operator|->
name|tcph_off
operator|)
expr_stmt|;
comment|/* Copy and update the headers. */
name|memcpy
argument_list|(
name|header
argument_list|,
name|tso
operator|->
name|mbuf
operator|->
name|m_data
argument_list|,
name|tso
operator|->
name|header_len
argument_list|)
expr_stmt|;
name|tsoh_th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|tso
operator|->
name|seqnum
argument_list|)
expr_stmt|;
name|tso
operator|->
name|seqnum
operator|+=
name|tso
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
if|if
condition|(
name|tso
operator|->
name|out_len
operator|>
name|tso
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
condition|)
block|{
comment|/* This packet will not finish the TSO burst. */
name|ip_length
operator|=
name|tso
operator|->
name|full_packet_size
operator|-
name|tso
operator|->
name|nh_off
expr_stmt|;
name|tsoh_th
operator|->
name|th_flags
operator|&=
operator|~
operator|(
name|TH_FIN
operator||
name|TH_PUSH
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This packet will be the last in the TSO burst. */
name|ip_length
operator|=
name|tso
operator|->
name|header_len
operator|-
name|tso
operator|->
name|nh_off
operator|+
name|tso
operator|->
name|out_len
expr_stmt|;
block|}
if|if
condition|(
name|tso
operator|->
name|protocol
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|tsoh_iph
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|header
operator|+
name|tso
operator|->
name|nh_off
operator|)
decl_stmt|;
name|tsoh_iph
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip_length
argument_list|)
expr_stmt|;
comment|/* XXX We should increment ip_id, but FreeBSD doesn't 		 * currently allocate extra IDs for multiple segments. 		 */
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|tsoh_iph
init|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|header
operator|+
name|tso
operator|->
name|nh_off
operator|)
decl_stmt|;
name|tsoh_iph
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|ip_length
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|tsoh_iph
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make the header visible to the hardware. */
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|tso
operator|->
name|packet_space
operator|=
name|tso
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|txq
operator|->
name|tso_packets
operator|++
expr_stmt|;
comment|/* Form a descriptor for this header. */
name|desc
operator|=
operator|&
name|txq
operator|->
name|pend_desc
index|[
name|txq
operator|->
name|n_pend_desc
operator|++
index|]
expr_stmt|;
name|desc
operator|->
name|eb_addr
operator|=
name|dma_addr
expr_stmt|;
name|desc
operator|->
name|eb_size
operator|=
name|tso
operator|->
name|header_len
expr_stmt|;
name|desc
operator|->
name|eb_eop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_queue_tso
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
specifier|const
name|bus_dma_segment_t
modifier|*
name|dma_seg
parameter_list|,
name|int
name|n_dma_seg
parameter_list|)
block|{
name|struct
name|sfxge_tso_state
name|tso
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|,
name|next_id
decl_stmt|;
name|tso_start
argument_list|(
operator|&
name|tso
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
comment|/* Grab the first payload fragment. */
if|if
condition|(
name|dma_seg
operator|->
name|ds_len
operator|==
name|tso
operator|.
name|header_len
condition|)
block|{
operator|--
name|n_dma_seg
expr_stmt|;
name|KASSERT
argument_list|(
name|n_dma_seg
argument_list|,
operator|(
literal|"no payload found in TSO packet"
operator|)
argument_list|)
expr_stmt|;
operator|++
name|dma_seg
expr_stmt|;
name|tso
operator|.
name|in_len
operator|=
name|dma_seg
operator|->
name|ds_len
expr_stmt|;
name|tso
operator|.
name|dma_addr
operator|=
name|dma_seg
operator|->
name|ds_addr
expr_stmt|;
block|}
else|else
block|{
name|tso
operator|.
name|in_len
operator|=
name|dma_seg
operator|->
name|ds_len
operator|-
name|tso
operator|.
name|header_len
expr_stmt|;
name|tso
operator|.
name|dma_addr
operator|=
name|dma_seg
operator|->
name|ds_addr
operator|+
name|tso
operator|.
name|header_len
expr_stmt|;
block|}
name|id
operator|=
name|txq
operator|->
name|added
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tso_start_new_packet
argument_list|(
name|txq
argument_list|,
operator|&
name|tso
argument_list|,
name|id
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|id
operator|=
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
name|tso_fill_packet_with_fragment
argument_list|(
name|txq
argument_list|,
operator|&
name|tso
argument_list|)
expr_stmt|;
comment|/* Move onto the next fragment? */
if|if
condition|(
name|tso
operator|.
name|in_len
operator|==
literal|0
condition|)
block|{
operator|--
name|n_dma_seg
expr_stmt|;
if|if
condition|(
name|n_dma_seg
operator|==
literal|0
condition|)
break|break;
operator|++
name|dma_seg
expr_stmt|;
name|tso
operator|.
name|in_len
operator|=
name|dma_seg
operator|->
name|ds_len
expr_stmt|;
name|tso
operator|.
name|dma_addr
operator|=
name|dma_seg
operator|->
name|ds_addr
expr_stmt|;
block|}
comment|/* End of packet? */
if|if
condition|(
name|tso
operator|.
name|packet_space
operator|==
literal|0
condition|)
block|{
comment|/* If the queue is now full due to tiny MSS, 			 * or we can't create another header, discard 			 * the remainder of the input mbuf but do not 			 * roll back the work we have done. 			 */
if|if
condition|(
name|txq
operator|->
name|n_pend_desc
operator|>
name|SFXGE_TSO_MAX_DESC
operator|-
operator|(
literal|1
operator|+
name|SFXGE_TX_MAPPING_MAX_SEG
operator|)
condition|)
break|break;
name|next_id
operator|=
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
name|txq
operator|->
name|ptr_mask
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tso_start_new_packet
argument_list|(
name|txq
argument_list|,
operator|&
name|tso
argument_list|,
name|next_id
argument_list|)
argument_list|)
condition|)
break|break;
name|id
operator|=
name|next_id
expr_stmt|;
block|}
block|}
name|txq
operator|->
name|tso_bursts
operator|++
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qunblock
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|sc
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|txq
operator|->
name|evq_index
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|init_state
operator|!=
name|SFXGE_TXQ_STARTED
condition|)
return|return;
name|mtx_lock
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|blocked
condition|)
block|{
name|unsigned
name|int
name|level
decl_stmt|;
name|level
operator|=
name|txq
operator|->
name|added
operator|-
name|txq
operator|->
name|completed
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|SFXGE_TXQ_UNBLOCK_LEVEL
argument_list|(
name|txq
operator|->
name|entries
argument_list|)
condition|)
name|txq
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
block|}
name|sfxge_tx_qdpl_service
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* note: lock has been dropped */
block|}
end_function

begin_function
name|void
name|sfxge_tx_qflush_done
parameter_list|(
name|struct
name|sfxge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_DONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_qstop
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|index
index|]
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|txq
operator|->
name|evq_index
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|init_state
operator|==
name|SFXGE_TXQ_STARTED
argument_list|,
operator|(
literal|"txq->init_state != SFXGE_TXQ_STARTED"
operator|)
argument_list|)
expr_stmt|;
name|txq
operator|->
name|init_state
operator|=
name|SFXGE_TXQ_INITIALIZED
expr_stmt|;
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_PENDING
expr_stmt|;
comment|/* Flush the transmit queue. */
name|efx_tx_qflush
argument_list|(
name|txq
operator|->
name|common
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Spin for 100ms. */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|flush_state
operator|!=
name|SFXGE_FLUSH_PENDING
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|count
operator|<
literal|20
condition|)
do|;
name|mtx_lock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|flush_state
operator|!=
name|SFXGE_FLUSH_FAILED
argument_list|,
operator|(
literal|"txq->flush_state == SFXGE_FLUSH_FAILED"
operator|)
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_DONE
expr_stmt|;
name|txq
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|pending
operator|=
name|txq
operator|->
name|added
expr_stmt|;
name|sfxge_tx_qcomplete
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|completed
operator|==
name|txq
operator|->
name|added
argument_list|,
operator|(
literal|"txq->completed != txq->added"
operator|)
argument_list|)
expr_stmt|;
name|sfxge_tx_qreap
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|reaped
operator|==
name|txq
operator|->
name|completed
argument_list|,
operator|(
literal|"txq->reaped != txq->completed"
operator|)
argument_list|)
expr_stmt|;
name|txq
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|completed
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|reaped
operator|=
literal|0
expr_stmt|;
comment|/* Destroy the common code transmit queue. */
name|efx_tx_qdestroy
argument_list|(
name|txq
operator|->
name|common
argument_list|)
expr_stmt|;
name|txq
operator|->
name|common
operator|=
name|NULL
expr_stmt|;
name|efx_sram_buf_tbl_clear
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_qstart
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|index
index|]
expr_stmt|;
name|esmp
operator|=
operator|&
name|txq
operator|->
name|mem
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|txq
operator|->
name|evq_index
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|init_state
operator|==
name|SFXGE_TXQ_INITIALIZED
argument_list|,
operator|(
literal|"txq->init_state != SFXGE_TXQ_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|evq
operator|->
name|init_state
operator|==
name|SFXGE_EVQ_STARTED
argument_list|,
operator|(
literal|"evq->init_state != SFXGE_EVQ_STARTED"
operator|)
argument_list|)
expr_stmt|;
comment|/* Program the buffer table. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_sram_buf_tbl_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|esmp
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Determine the kind of queue we are creating. */
switch|switch
condition|(
name|txq
operator|->
name|type
condition|)
block|{
case|case
name|SFXGE_TXQ_NON_CKSUM
case|:
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SFXGE_TXQ_IP_CKSUM
case|:
name|flags
operator|=
name|EFX_CKSUM_IPV4
expr_stmt|;
break|break;
case|case
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
case|:
name|flags
operator|=
name|EFX_CKSUM_IPV4
operator||
name|EFX_CKSUM_TCPUDP
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"Impossible TX queue"
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Create the common code transmit queue. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_tx_qcreate
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|index
argument_list|,
name|txq
operator|->
name|type
argument_list|,
name|esmp
argument_list|,
name|sc
operator|->
name|txq_entries
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|flags
argument_list|,
name|evq
operator|->
name|common
argument_list|,
operator|&
name|txq
operator|->
name|common
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|mtx_lock
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable the transmit queue. */
name|efx_tx_qenable
argument_list|(
name|txq
operator|->
name|common
argument_list|)
expr_stmt|;
name|txq
operator|->
name|init_state
operator|=
name|SFXGE_TXQ_STARTED
expr_stmt|;
name|mtx_unlock
argument_list|(
name|SFXGE_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|efx_sram_buf_tbl_clear
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|txq
operator|->
name|buf_base_id
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sfxge_tx_stop
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|efx_nic_cfg_t
modifier|*
name|encp
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|SFXGE_TX_SCALE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
argument_list|)
expr_stmt|;
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|)
expr_stmt|;
name|encp
operator|=
name|efx_nic_cfg_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|)
expr_stmt|;
comment|/* Tear down the transmit module */
name|efx_tx_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_tx_start
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Initialize the common code transmit module. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_tx_init
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qstart
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qstart
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SFXGE_TX_SCALE
argument_list|(
name|sc
argument_list|)
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qstart
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
argument_list|)
expr_stmt|;
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|)
expr_stmt|;
name|fail2
label|:
name|sfxge_tx_qstop
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|)
expr_stmt|;
name|fail
label|:
name|efx_tx_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Destroy a transmit queue.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_tx_qfini
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|unsigned
name|int
name|nmaps
decl_stmt|;
name|txq
operator|=
name|sc
operator|->
name|txq
index|[
name|index
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|init_state
operator|==
name|SFXGE_TXQ_INITIALIZED
argument_list|,
operator|(
literal|"txq->init_state != SFXGE_TXQ_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|type
operator|==
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
condition|)
name|tso_fini
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Free the context arrays. */
name|free
argument_list|(
name|txq
operator|->
name|pend_desc
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|nmaps
operator|=
name|sc
operator|->
name|txq_entries
expr_stmt|;
while|while
condition|(
name|nmaps
operator|--
operator|!=
literal|0
condition|)
name|bus_dmamap_destroy
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|txq
operator|->
name|stmp
index|[
name|nmaps
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|stmp
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
comment|/* Release DMA memory mapping. */
name|sfxge_dma_free
argument_list|(
operator|&
name|txq
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txq
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SFXGE_HAVE_MQ
name|mtx_destroy
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|txq
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_tx_qinit
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|txq_index
parameter_list|,
name|enum
name|sfxge_txq_type
name|type
parameter_list|,
name|unsigned
name|int
name|evq_index
parameter_list|)
block|{
name|struct
name|sfxge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
ifdef|#
directive|ifdef
name|SFXGE_HAVE_MQ
name|struct
name|sfxge_tx_dpl
modifier|*
name|stdp
decl_stmt|;
endif|#
directive|endif
name|efsys_mem_t
modifier|*
name|esmp
decl_stmt|;
name|unsigned
name|int
name|nmaps
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|txq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfxge_txq
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|txq
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|txq
operator|->
name|entries
operator|=
name|sc
operator|->
name|txq_entries
expr_stmt|;
name|txq
operator|->
name|ptr_mask
operator|=
name|txq
operator|->
name|entries
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|txq
index|[
name|txq_index
index|]
operator|=
name|txq
expr_stmt|;
name|esmp
operator|=
operator|&
name|txq
operator|->
name|mem
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|evq_index
index|]
expr_stmt|;
comment|/* Allocate and zero DMA space for the descriptor ring. */
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_dma_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_TXQ_SIZE
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|,
name|esmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|esmp
operator|->
name|esm_base
argument_list|,
literal|0
argument_list|,
name|EFX_TXQ_SIZE
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate buffer table entries. */
name|sfxge_sram_buf_tbl_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_TXQ_NBUFS
argument_list|(
name|sc
operator|->
name|txq_entries
argument_list|)
argument_list|,
operator|&
name|txq
operator|->
name|buf_base_id
argument_list|)
expr_stmt|;
comment|/* Create a DMA tag for packet mappings. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|,
literal|1
argument_list|,
literal|0x1000
argument_list|,
name|MIN
argument_list|(
literal|0x3FFFFFFFFFFFUL
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0x11000
argument_list|,
name|SFXGE_TX_MAPPING_MAX_SEG
argument_list|,
literal|0x1000
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|txq
operator|->
name|packet_dma_tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Couldn't allocate txq DMA tag\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate pending descriptor array for batching writes. */
name|txq
operator|->
name|pend_desc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|efx_buffer_t
argument_list|)
operator|*
name|sc
operator|->
name|txq_entries
argument_list|,
name|M_SFXGE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Allocate and initialise mbuf DMA mapping array. */
name|txq
operator|->
name|stmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfxge_tx_mapping
argument_list|)
operator|*
name|sc
operator|->
name|txq_entries
argument_list|,
name|M_SFXGE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|nmaps
operator|=
literal|0
init|;
name|nmaps
operator|<
name|sc
operator|->
name|txq_entries
condition|;
name|nmaps
operator|++
control|)
block|{
name|rc
operator|=
name|bus_dmamap_create
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txq
operator|->
name|stmp
index|[
name|nmaps
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|&&
operator|(
name|rc
operator|=
name|tso_init
argument_list|(
name|txq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
ifdef|#
directive|ifdef
name|SFXGE_HAVE_MQ
comment|/* Initialize the deferred packet list. */
name|stdp
operator|=
operator|&
name|txq
operator|->
name|dpl
expr_stmt|;
name|stdp
operator|->
name|std_getp
operator|=
operator|&
name|stdp
operator|->
name|std_get
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
literal|"txq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|txq
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|txq
operator|->
name|evq_index
operator|=
name|evq_index
expr_stmt|;
name|txq
operator|->
name|txq_index
operator|=
name|txq_index
expr_stmt|;
name|txq
operator|->
name|init_state
operator|=
name|SFXGE_TXQ_INITIALIZED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|free
argument_list|(
name|txq
operator|->
name|pend_desc
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|fail2
label|:
while|while
condition|(
name|nmaps
operator|--
operator|!=
literal|0
condition|)
name|bus_dmamap_destroy
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|,
name|txq
operator|->
name|stmp
index|[
name|nmaps
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|stmp
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|txq
operator|->
name|packet_dma_tag
argument_list|)
expr_stmt|;
name|fail
label|:
name|sfxge_dma_free
argument_list|(
name|esmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
block|}
name|sfxge_tx_stats
index|[]
init|=
block|{
define|#
directive|define
name|SFXGE_TX_STAT
parameter_list|(
name|name
parameter_list|,
name|member
parameter_list|)
define|\
value|{ #name, offsetof(struct sfxge_txq, member) }
name|SFXGE_TX_STAT
argument_list|(
name|tso_bursts
argument_list|,
name|tso_bursts
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tso_packets
argument_list|,
name|tso_packets
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tso_long_headers
argument_list|,
name|tso_long_headers
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_collapses
argument_list|,
name|collapses
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_drops
argument_list|,
name|drops
argument_list|)
block|,
name|SFXGE_TX_STAT
argument_list|(
name|tx_early_drops
argument_list|,
name|early_drops
argument_list|)
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|sfxge_tx_stat_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|unsigned
name|int
name|id
init|=
name|arg2
decl_stmt|;
name|unsigned
name|long
name|sum
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
comment|/* Sum across all TX queues */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|SFXGE_TX_SCALE
argument_list|(
name|sc
argument_list|)
condition|;
name|index
operator|++
control|)
name|sum
operator|+=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|txq
index|[
name|index
index|]
operator|+
name|sfxge_tx_stats
index|[
name|id
index|]
operator|.
name|offset
operator|)
expr_stmt|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|sum
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_tx_stat_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|stats_node
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
sizeof|sizeof
argument_list|(
name|sfxge_tx_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sfxge_tx_stats
index|[
literal|0
index|]
argument_list|)
condition|;
name|id
operator|++
control|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|sfxge_tx_stats
index|[
name|id
index|]
operator|.
name|name
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|id
argument_list|,
name|sfxge_tx_stat_handler
argument_list|,
literal|"LU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sfxge_tx_fini
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|index
operator|=
name|SFXGE_TX_SCALE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
argument_list|)
expr_stmt|;
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|)
expr_stmt|;
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_tx_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_intr
modifier|*
name|intr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|intr
operator|=
operator|&
name|sc
operator|->
name|intr
expr_stmt|;
name|KASSERT
argument_list|(
name|intr
operator|->
name|state
operator|==
name|SFXGE_INTR_INITIALIZED
argument_list|,
operator|(
literal|"intr->state != SFXGE_INTR_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize the transmit queues */
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qinit
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qinit
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SFXGE_TX_SCALE
argument_list|(
name|sc
argument_list|)
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_tx_qinit
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
block|}
name|sfxge_tx_stat_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_CKSUM
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_IP_TCP_UDP_CKSUM
operator|+
name|index
argument_list|)
expr_stmt|;
name|fail2
label|:
name|sfxge_tx_qfini
argument_list|(
name|sc
argument_list|,
name|SFXGE_TXQ_NON_CKSUM
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

