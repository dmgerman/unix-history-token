begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2001 Scott Long  * Copyright (c) 2000 BSDi  * Copyright (c) 2001-2010 Adaptec, Inc.  * Copyright (c) 2010-2012 PMC-Sierra, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Adaptec by PMC Series 6,7,8,... families of RAID controllers  */
end_comment

begin_define
define|#
directive|define
name|AAC_DRIVERNAME
value|"aacraid"
end_define

begin_include
include|#
directive|include
file|"opt_aacraid.h"
end_include

begin_comment
comment|/* #include<stddef.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/aacraid/aacraid_reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/aac_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/aacraid/aacraid_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/aacraid/aacraid_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FILTER_HANDLED
end_ifndef

begin_define
define|#
directive|define
name|FILTER_HANDLED
value|0x02
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|aac_add_container
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|int
name|f
parameter_list|,
name|u_int32_t
name|uid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_get_bus_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_container_bus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_daemon
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_convert_sgraw2
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_raw_io2
modifier|*
name|raw
parameter_list|,
name|int
name|pages
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|nseg_new
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Processing */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_command_thread
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|xferstate
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|,
name|u_int16_t
name|datasize
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Buffer Management */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hardware Interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_alloc
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_check_firmware
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_define_int_mode
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_find_pci_capability
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_setup_intr
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_check_config
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* PMC SRC interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_src_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_src_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_src_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_src_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_src_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_src_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_src_access_devreg
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_src_send_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_src_get_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_src_set_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aacraid_src_interface
init|=
block|{
name|aac_src_get_fwstatus
block|,
name|aac_src_qnotify
block|,
name|aac_src_get_istatus
block|,
name|aac_src_clear_istatus
block|,
name|aac_src_set_mailbox
block|,
name|aac_src_get_mailbox
block|,
name|aac_src_access_devreg
block|,
name|aac_src_send_command
block|,
name|aac_src_get_outb_queue
block|,
name|aac_src_set_outb_queue
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PMC SRCv interface */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_srcv_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_srcv_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aacraid_srcv_interface
init|=
block|{
name|aac_src_get_fwstatus
block|,
name|aac_src_qnotify
block|,
name|aac_src_get_istatus
block|,
name|aac_src_clear_istatus
block|,
name|aac_srcv_set_mailbox
block|,
name|aac_srcv_get_mailbox
block|,
name|aac_src_access_devreg
block|,
name|aac_src_send_command
block|,
name|aac_src_get_outb_queue
block|,
name|aac_src_set_outb_queue
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging and Diagnostics */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|aac_code_lookup
name|aac_cpu_variant
index|[]
init|=
block|{
block|{
literal|"i960JX"
block|,
name|CPUI960_JX
block|}
block|,
block|{
literal|"i960CX"
block|,
name|CPUI960_CX
block|}
block|,
block|{
literal|"i960HX"
block|,
name|CPUI960_HX
block|}
block|,
block|{
literal|"i960RX"
block|,
name|CPUI960_RX
block|}
block|,
block|{
literal|"i960 80303"
block|,
name|CPUI960_80303
block|}
block|,
block|{
literal|"StrongARM SA110"
block|,
name|CPUARM_SA110
block|}
block|,
block|{
literal|"PPC603e"
block|,
name|CPUPPC_603e
block|}
block|,
block|{
literal|"XScale 80321"
block|,
name|CPU_XSCALE_80321
block|}
block|,
block|{
literal|"MIPS 4KC"
block|,
name|CPU_MIPS_4KC
block|}
block|,
block|{
literal|"MIPS 5KC"
block|,
name|CPU_MIPS_5KC
block|}
block|,
block|{
literal|"Unknown StrongARM"
block|,
name|CPUARM_xxx
block|}
block|,
block|{
literal|"Unknown PowerPC"
block|,
name|CPUPPC_xxx
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"Unknown processor"
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|aac_code_lookup
name|aac_battery_platform
index|[]
init|=
block|{
block|{
literal|"required battery present"
block|,
name|PLATFORM_BAT_REQ_PRESENT
block|}
block|,
block|{
literal|"REQUIRED BATTERY NOT PRESENT"
block|,
name|PLATFORM_BAT_REQ_NOTPRESENT
block|}
block|,
block|{
literal|"optional battery present"
block|,
name|PLATFORM_BAT_OPT_PRESENT
block|}
block|,
block|{
literal|"optional battery not installed"
block|,
name|PLATFORM_BAT_OPT_NOTPRESENT
block|}
block|,
block|{
literal|"no battery support"
block|,
name|PLATFORM_BAT_NOT_SUPPORTED
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"unknown battery platform"
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management Interface */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|aac_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|aac_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|aac_poll
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|702000
end_if

begin_function_decl
specifier|static
name|void
name|aac_cdevpriv_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|d_close_t
name|aac_close
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_ioctl_send_raw_srb
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_request_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_open_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_close_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib_context
modifier|*
name|ctx
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_query_disk
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_get_pci_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_supported_features
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_ioctl_event
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_reset_adapter
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_get_container_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|,
name|int
name|cid
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|u_int32_t
modifier|*
name|uid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|aac_check_adapter_health
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|bled
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|aacraid_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|aac_open
block|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|702000
operator|.
name|d_close
operator|=
name|aac_close
block|,
endif|#
directive|endif
operator|.
name|d_ioctl
operator|=
name|aac_ioctl
block|,
operator|.
name|d_poll
operator|=
name|aac_poll
block|,
operator|.
name|d_name
operator|=
literal|"aacraid"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AACRAIDBUF
argument_list|,
literal|"aacraid_buf"
argument_list|,
literal|"Buffers for the AACRAID driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* sysctl node */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|aacraid
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"AACRAID driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Device Interface  */
end_comment

begin_comment
comment|/*  * Initialize the controller and softc  */
end_comment

begin_function
name|int
name|aacraid_attach
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_mntinforesp
name|mir
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|uid
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hint_flags
operator|=
name|device_get_flags
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize per-controller queues. 	 */
name|aac_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* mark controller as suspended until we get ourselves organised */
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* 	 * Check that the firmware on the card is supported. 	 */
name|sc
operator|->
name|msi_enabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|aac_check_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Initialize locks 	 */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
literal|"AACRAID I/O lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* Initialize the clock daemon callout. */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|aac_daemontime
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize the adapter. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SYNC_MODE
operator|)
condition|)
block|{
name|aac_define_int_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|aac_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Allocate and connect our interrupt. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_setup_intr
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Print a little information about the controller. 	 */
name|aac_describe_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Make the control device. 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|aacraid_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"aacraid%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Create the AIF thread */
if|if
condition|(
name|aac_kthread_create
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|aac_command_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|aifthread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"aacraid%daif"
argument_list|,
name|unit
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Could not create AIF thread"
argument_list|)
expr_stmt|;
comment|/* Register the shutdown method to only be called post-dump */
if|if
condition|(
operator|(
name|sc
operator|->
name|eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|aacraid_shutdown
argument_list|,
name|sc
operator|->
name|aac_dev
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"shutdown event registration failed\n"
argument_list|)
expr_stmt|;
comment|/* Find containers */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
comment|/* loop over possible containers */
do|do
block|{
if|if
condition|(
operator|(
name|aac_get_container_info
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|,
name|i
argument_list|,
operator|&
name|mir
argument_list|,
operator|&
name|uid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|count
operator|=
name|mir
operator|.
name|MntRespCount
expr_stmt|;
name|aac_add_container
argument_list|(
name|sc
argument_list|,
operator|&
name|mir
argument_list|,
literal|0
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|count
operator|)
operator|&&
operator|(
name|i
operator|<
name|AAC_MAX_CONTAINERS
operator|)
condition|)
do|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* Register with CAM for the containers */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|)
expr_stmt|;
name|aac_container_bus
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Register with CAM for the non-DASD devices */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_ENABLE_CAM
operator|)
operator|!=
literal|0
condition|)
name|aac_get_bus_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* poke the bus to actually attach the child devices */
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
comment|/* mark the controller up */
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* enable interrupts now */
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_ENABLE_INTERRUPT
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aac_daemontime
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|aac_daemon
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|timeout_id
operator|=
name|timeout
argument_list|(
name|aac_daemon
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_daemon
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|sc
operator|->
name|aac_daemontime
argument_list|)
operator|||
name|callout_active
argument_list|(
operator|&
name|sc
operator|->
name|aac_daemontime
argument_list|)
operator|==
literal|0
condition|)
return|return;
else|#
directive|else
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aacraid_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
name|cm
operator|->
name|cm_datalen
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_WAIT
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
operator||
name|AAC_FIBSTATE_ASYNC
operator||
name|AAC_FIBSTATE_FAST_RESPONSE
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|SendHostTime
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|fib
operator|->
name|data
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|aacraid_map_command_sg
argument_list|(
name|cm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aacraid_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|aac_daemontime
argument_list|,
literal|30
operator|*
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
else|#
directive|else
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|30
operator|*
literal|60
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|timeout_id
operator|=
name|timeout
argument_list|(
name|aac_daemon
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|aacraid_add_event
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_event
modifier|*
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|->
name|ev_type
operator|&
name|AAC_EVENT_MASK
condition|)
block|{
case|case
name|AAC_EVENT_CMFREE
case|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|,
name|event
argument_list|,
name|ev_links
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_add event: unknown event %d\n"
argument_list|,
name|event
operator|->
name|ev_type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Request information of container #cid  */
end_comment

begin_function
specifier|static
name|int
name|aac_get_container_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|sync_fib
parameter_list|,
name|int
name|cid
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|u_int32_t
modifier|*
name|uid
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_mntinfo
modifier|*
name|mi
decl_stmt|;
name|struct
name|aac_cnt_config
modifier|*
name|ccfg
decl_stmt|;
name|int
name|rval
decl_stmt|;
if|if
condition|(
name|sync_fib
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|aacraid_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Warning, no free command available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
block|}
else|else
block|{
name|fib
operator|=
name|sync_fib
expr_stmt|;
block|}
name|mi
operator|=
operator|(
expr|struct
name|aac_mntinfo
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* 4KB support?, 64-bit LBA? */
if|if
condition|(
name|sc
operator|->
name|aac_support_opt2
operator|&
name|AAC_SUPPORTED_VARIABLE_BLOCK_SIZE
condition|)
name|mi
operator|->
name|Command
operator|=
name|VM_NameServeAllBlk
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_LBA_64BIT
condition|)
name|mi
operator|->
name|Command
operator|=
name|VM_NameServe64
expr_stmt|;
else|else
name|mi
operator|->
name|Command
operator|=
name|VM_NameServe
expr_stmt|;
name|mi
operator|->
name|MntType
operator|=
name|FT_FILESYS
expr_stmt|;
name|mi
operator|->
name|MntCount
operator|=
name|cid
expr_stmt|;
if|if
condition|(
name|sync_fib
condition|)
block|{
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error probing container %d\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
name|cm
operator|->
name|cm_datalen
operator|=
literal|0
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
operator||
name|AAC_FIBSTATE_ASYNC
operator||
name|AAC_FIBSTATE_FAST_RESPONSE
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|ContainerCommand
expr_stmt|;
if|if
condition|(
name|aacraid_wait_command
argument_list|(
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error probing container %d\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|aacraid_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|bcopy
argument_list|(
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|mir
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinforesp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UID */
operator|*
name|uid
operator|=
name|cid
expr_stmt|;
if|if
condition|(
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|&&
operator|!
operator|(
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|ContentState
operator|&
name|AAC_FSCS_HIDDEN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|aac_support_opt2
operator|&
name|AAC_SUPPORTED_VARIABLE_BLOCK_SIZE
operator|)
condition|)
block|{
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjExtension
operator|.
name|BlockDevice
operator|.
name|BlockSize
operator|=
literal|0x200
expr_stmt|;
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjExtension
operator|.
name|BlockDevice
operator|.
name|bdLgclPhysMap
operator|=
literal|0
expr_stmt|;
block|}
name|ccfg
operator|=
operator|(
expr|struct
name|aac_cnt_config
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|ccfg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ccfg
argument_list|)
operator|-
name|CT_PACKET_SIZE
argument_list|)
expr_stmt|;
name|ccfg
operator|->
name|Command
operator|=
name|VM_ContainerConfig
expr_stmt|;
name|ccfg
operator|->
name|CTCommand
operator|.
name|command
operator|=
name|CT_CID_TO_32BITS_UID
expr_stmt|;
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|cid
expr_stmt|;
if|if
condition|(
name|sync_fib
condition|)
block|{
name|rval
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_cnt_config
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
operator|&&
name|ccfg
operator|->
name|Command
operator|==
name|ST_OK
operator|&&
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|CT_OK
operator|&&
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_PASSTHRU
condition|)
operator|*
name|uid
operator|=
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_cnt_config
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
operator||
name|AAC_FIBSTATE_ASYNC
operator||
name|AAC_FIBSTATE_FAST_RESPONSE
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|ContainerCommand
expr_stmt|;
name|rval
operator|=
name|aacraid_wait_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
operator|&&
name|ccfg
operator|->
name|Command
operator|==
name|ST_OK
operator|&&
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|CT_OK
operator|&&
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_PASSTHRU
condition|)
operator|*
name|uid
operator|=
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|aacraid_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a device to represent a new container  */
end_comment

begin_function
specifier|static
name|void
name|aac_add_container
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|int
name|f
parameter_list|,
name|u_int32_t
name|uid
parameter_list|)
block|{
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Check container volume type for validity.  Note that many of 	 * the possible types may never show up. 	 */
if|if
condition|(
operator|(
name|mir
operator|->
name|Status
operator|==
name|ST_OK
operator|)
operator|&&
operator|(
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|)
condition|)
block|{
name|co
operator|=
operator|(
expr|struct
name|aac_container
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|co
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
block|}
name|co
operator|->
name|co_found
operator|=
name|f
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
argument_list|,
operator|&
name|co
operator|->
name|co_mntobj
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntobj
argument_list|)
argument_list|)
expr_stmt|;
name|co
operator|->
name|co_uid
operator|=
name|uid
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate resources associated with (sc)  */
end_comment

begin_function
specifier|static
name|int
name|aac_alloc
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_size_t
name|maxsize
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Create DMA tag for mapping buffers into controller-addressable space. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sc
operator|->
name|aac_max_sectors
operator|<<
literal|9
argument_list|,
comment|/* maxsize */
name|sc
operator|->
name|aac_sg_tablesize
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|aac_buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Create DMA tag for mapping FIBs into controller-addressable space.. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE1
condition|)
name|maxsize
operator|=
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
operator|(
name|sc
operator|->
name|aac_max_fib_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_xporthdr
argument_list|)
operator|+
literal|31
operator|)
expr_stmt|;
else|else
name|maxsize
operator|=
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
operator|(
name|sc
operator|->
name|aac_max_fib_size
operator|+
literal|31
operator|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_4GB_WINDOW
operator|)
condition|?
name|BUS_SPACE_MAXADDR_32BIT
else|:
literal|0x7fffffff
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|maxsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|maxsize
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* No locking needed */
operator|&
name|sc
operator|->
name|aac_fib_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate FIB DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Create DMA tag for the common structure and allocate it. 	 */
name|maxsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_common
argument_list|)
expr_stmt|;
name|maxsize
operator|+=
name|sc
operator|->
name|aac_max_fibs
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_4GB_WINDOW
operator|)
condition|?
name|BUS_SPACE_MAXADDR_32BIT
else|:
literal|0x7fffffff
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|maxsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|maxsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* No locking needed */
operator|&
name|sc
operator|->
name|aac_common_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|aac_common
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
name|maxsize
argument_list|,
name|aac_common_map
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|aac_common
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
comment|/* Allocate some FIBs and associated command structs */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_commands
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|aac_max_fibs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_command
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|total_fibs
operator|<
name|sc
operator|->
name|aac_max_fibs
condition|)
block|{
if|if
condition|(
name|aac_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all of the resources associated with (sc)  *  * Should not be called if the controller is active.  */
end_comment

begin_function
name|void
name|aacraid_free
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* remove the control device */
if|if
condition|(
name|sc
operator|->
name|aac_dev_t
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|)
expr_stmt|;
comment|/* throw away any FIB buffers, discard the FIB DMA tag */
name|aac_free_commands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_fib_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|aac_commands
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
comment|/* destroy the common area */
if|if
condition|(
name|sc
operator|->
name|aac_common
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aac_common_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|)
expr_stmt|;
comment|/* disconnect the interrupt handler */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AAC_MAX_MSIX
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|aac_intr
index|[
name|i
index|]
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|sc
operator|->
name|aac_irq
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|aac_intr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_irq
index|[
name|i
index|]
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|aac_irq_rid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|aac_irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|msi_enabled
condition|)
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
comment|/* destroy data-transfer DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_buffer_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|)
expr_stmt|;
comment|/* destroy the parent DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|)
expr_stmt|;
comment|/* release the register window mapping */
if|if
condition|(
name|sc
operator|->
name|aac_regs_res0
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|aac_regs_rid0
argument_list|,
name|sc
operator|->
name|aac_regs_res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_regs_res1
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|aac_regs_rid1
argument_list|,
name|sc
operator|->
name|aac_regs_res1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disconnect from the controller completely, in preparation for unload.  */
end_comment

begin_function
name|int
name|aacraid_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|struct
name|aac_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|aac_daemontime
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|aac_daemon
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|timeout_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove the child containers */
while|while
condition|(
operator|(
name|co
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|co
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the CAM SIMs */
while|while
condition|(
operator|(
name|sim
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|,
name|sim
argument_list|,
name|sim_link
argument_list|)
expr_stmt|;
name|error
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sim
operator|->
name|sim_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|free
argument_list|(
name|sim
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
block|{
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_EXIT
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|PUSER
operator||
name|PCATCH
argument_list|,
literal|"aac_dch"
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
name|panic
argument_list|(
literal|"Cannot shutdown AIF thread"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|aacraid_shutdown
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|sc
operator|->
name|eh
argument_list|)
expr_stmt|;
name|aacraid_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller down to a dormant state and detach all child devices.  *  * This function is called before detach or system shutdown.  *  * Note that we can assume that the bioq on the controller is empty, as we won't  * allow shutdown if any device is open.  */
end_comment

begin_function
name|int
name|aacraid_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_close_command
modifier|*
name|cc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* 	 * Send a Container shutdown followed by a HostShutdown FIB to the 	 * controller to convince it that we don't want to talk to it anymore. 	 * We've been closed and all I/O completed already 	 */
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"shutting down controller..."
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|cc
operator|=
operator|(
expr|struct
name|aac_close_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_close_command
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|Command
operator|=
name|VM_CloseAll
expr_stmt|;
name|cc
operator|->
name|ContainerId
operator|=
literal|0xfffffffe
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_close_command
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"FAILED.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_DISABLE_INTERRUPT
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller to a quiescent state, ready for system suspend.  */
end_comment

begin_function
name|int
name|aacraid_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_DISABLE_INTERRUPT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller back to a state ready for operation.  */
end_comment

begin_function
name|int
name|aacraid_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_ENABLE_INTERRUPT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for NEW_COMM_TYPE1, NEW_COMM_TYPE2, NEW_COMM_TYPE34 interface.  */
end_comment

begin_function
name|void
name|aacraid_new_intr_type1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_msix_ctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|vector_no
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|u_int32_t
name|bellbits
decl_stmt|,
name|bellbits_shifted
decl_stmt|,
name|index
decl_stmt|,
name|handle
decl_stmt|;
name|int
name|isFastResponse
decl_stmt|,
name|isAif
decl_stmt|,
name|noMoreAif
decl_stmt|,
name|mode
decl_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|aac_msix_ctx
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|ctx
operator|->
name|sc
expr_stmt|;
name|vector_no
operator|=
name|ctx
operator|->
name|vector_no
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msi_enabled
condition|)
block|{
name|mode
operator|=
name|AAC_INT_MODE_MSI
expr_stmt|;
if|if
condition|(
name|vector_no
operator|==
literal|0
condition|)
block|{
name|bellbits
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_MSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|bellbits
operator|&
literal|0x40000
condition|)
name|mode
operator||=
name|AAC_INT_MODE_AIF
expr_stmt|;
elseif|else
if|if
condition|(
name|bellbits
operator|&
literal|0x1000
condition|)
name|mode
operator||=
name|AAC_INT_MODE_SYNC
expr_stmt|;
block|}
block|}
else|else
block|{
name|mode
operator|=
name|AAC_INT_MODE_INTX
expr_stmt|;
name|bellbits
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|bellbits
operator|&
name|AAC_DB_RESPONSE_SENT_NS
condition|)
block|{
name|bellbits
operator|=
name|AAC_DB_RESPONSE_SENT_NS
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_C
argument_list|,
name|bellbits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bellbits_shifted
operator|=
operator|(
name|bellbits
operator|>>
name|AAC_SRC_ODR_SHIFT
operator|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_C
argument_list|,
name|bellbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|bellbits_shifted
operator|&
name|AAC_DB_AIF_PENDING
condition|)
name|mode
operator||=
name|AAC_INT_MODE_AIF
expr_stmt|;
elseif|else
if|if
condition|(
name|bellbits_shifted
operator|&
name|AAC_DB_SYNC_COMMAND
condition|)
name|mode
operator||=
name|AAC_INT_MODE_SYNC
expr_stmt|;
block|}
comment|/* ODR readback, Prep #238630 */
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_R
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|AAC_INT_MODE_SYNC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|aac_sync_cm
condition|)
block|{
name|cm
operator|=
name|sc
operator|->
name|aac_sync_cm
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_COMPLETED
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this command */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|AAC_QUEUE_FRZN
expr_stmt|;
name|sc
operator|->
name|aac_sync_cm
operator|=
name|NULL
expr_stmt|;
block|}
name|mode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|AAC_INT_MODE_AIF
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|AAC_INT_MODE_INTX
condition|)
block|{
name|aac_request_aif
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
condition|)
block|{
comment|/* handle async. status */
name|index
operator|=
name|sc
operator|->
name|aac_host_rrq_idx
index|[
name|vector_no
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|isFastResponse
operator|=
name|isAif
operator|=
name|noMoreAif
operator|=
literal|0
expr_stmt|;
comment|/* remove toggle bit (31) */
name|handle
operator|=
operator|(
name|sc
operator|->
name|aac_common
operator|->
name|ac_host_rrq
index|[
name|index
index|]
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
comment|/* check fast response bit (30) */
if|if
condition|(
name|handle
operator|&
literal|0x40000000
condition|)
name|isFastResponse
operator|=
literal|1
expr_stmt|;
comment|/* check AIF bit (23) */
elseif|else
if|if
condition|(
name|handle
operator|&
literal|0x00800000
condition|)
name|isAif
operator|=
name|TRUE
expr_stmt|;
name|handle
operator|&=
literal|0x0000ffff
expr_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
break|break;
name|cm
operator|=
name|sc
operator|->
name|aac_commands
operator|+
operator|(
name|handle
operator|-
literal|1
operator|)
expr_stmt|;
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|sc
operator|->
name|aac_rrq_outstanding
index|[
name|vector_no
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|isAif
condition|)
block|{
name|noMoreAif
operator|=
operator|(
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|&
name|AAC_FIBSTATE_NOMOREAIF
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|noMoreAif
condition|)
name|aac_handle_aif
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
name|aac_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aacraid_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isFastResponse
condition|)
block|{
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|AAC_FIBSTATE_DONEADAP
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|fib
operator|->
name|data
operator|)
operator|)
operator|=
name|ST_OK
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_FASTRESP
expr_stmt|;
block|}
name|aac_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_COMPLETED
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this command */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|AAC_QUEUE_FRZN
expr_stmt|;
block|}
name|sc
operator|->
name|aac_common
operator|->
name|ac_host_rrq
index|[
name|index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|(
name|vector_no
operator|+
literal|1
operator|)
operator|*
name|sc
operator|->
name|aac_vector_cap
condition|)
name|index
operator|=
name|vector_no
operator|*
name|sc
operator|->
name|aac_vector_cap
expr_stmt|;
name|sc
operator|->
name|aac_host_rrq_idx
index|[
name|vector_no
index|]
operator|=
name|index
expr_stmt|;
if|if
condition|(
operator|(
name|isAif
operator|&&
operator|!
name|noMoreAif
operator|)
operator|||
name|sc
operator|->
name|aif_pending
condition|)
name|aac_request_aif
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|&
name|AAC_INT_MODE_AIF
condition|)
block|{
name|aac_request_aif
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_CLEAR_AIF_BIT
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* see if we can start some more I/O */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_QUEUE_FRZN
operator|)
operator|==
literal|0
condition|)
name|aacraid_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle notification of one or more FIBs coming from the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_command_thread
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aifflags
operator|=
name|AAC_AIFFLAGS_RUNNING
expr_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_EXIT
operator|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_PENDING
operator|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|msleep
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"aacraid_aifthd"
argument_list|,
name|AAC_PERIODIC_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* 		 * First see if any FIBs need to be allocated.  This needs 		 * to be called without the driver lock because contigmalloc 		 * will grab Giant, and would result in an LOR. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_ALLOCFIBS
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_commands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aifflags
operator|&=
operator|~
name|AAC_AIFFLAGS_ALLOCFIBS
expr_stmt|;
name|aacraid_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * While we're here, check to see if any commands are stuck. 		 * This is pretty low-priority, so it's ok if it doesn't 		 * always fire. 		 */
if|if
condition|(
name|retval
operator|==
name|EWOULDBLOCK
condition|)
name|aac_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check the hardware printf message buffer */
if|if
condition|(
name|sc
operator|->
name|aac_common
operator|->
name|ac_printf
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|aac_print_printf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|aifflags
operator|&=
operator|~
name|AAC_AIFFLAGS_RUNNING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|aac_kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Submit a command to the controller, return when it completes.  * XXX This is very dangerous!  If the card has gone out to lunch, we could  *     be stuck here forever.  At the same time, signals are not caught  *     because there is a risk that a signal could wakeup the sleep before  *     the card has a chance to complete the command.  Since there is no way  *     to cancel a command that is in progress, we can't protect against the  *     card completing a command late and spamming the command and data  *     memory.  So, we are held hostage until the command completes.  */
end_comment

begin_function
name|int
name|aacraid_wait_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Put the command on the ready queue and get things going */
name|aac_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aacraid_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"aacraid_wait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *Command Buffer Management  */
end_comment

begin_comment
comment|/*  * Allocate a command.  */
end_comment

begin_function
name|int
name|aacraid_alloc_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|aac_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|<
name|sc
operator|->
name|aac_max_fibs
condition|)
block|{
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_ALLOCFIBS
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a command back to the freelist.  */
end_comment

begin_function
name|void
name|aacraid_release_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_event
modifier|*
name|event
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* (re)initialize the command/FIB */
name|cm
operator|->
name|cm_sgtable
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_ccb
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_passthr_dmat
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Unused
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
name|cm
operator|->
name|cm_sc
operator|->
name|aac_max_fib_size
expr_stmt|;
comment|/* 	 * These are duplicated in aac_start to cover the case where an 	 * intermediate stage may have destroyed them.  They're left 	 * initialized here for debugging purposes only. 	 */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|u
operator|.
name|ReceiverFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Handle
operator|=
literal|0
expr_stmt|;
name|aac_enqueue_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* 	 * Dequeue all events so that there's no risk of events getting 	 * stranded. 	 */
while|while
condition|(
operator|(
name|event
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|,
name|event
argument_list|,
name|ev_links
argument_list|)
expr_stmt|;
name|event
operator|->
name|ev_callback
argument_list|(
name|sc
argument_list|,
name|event
argument_list|,
name|event
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map helper for command/FIB allocation.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint64_t
modifier|*
name|fibphys
decl_stmt|;
name|fibphys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|fibphys
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialize commands/FIBs for this adapter.  */
end_comment

begin_function
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fibmap
modifier|*
name|fm
decl_stmt|;
name|uint64_t
name|fibphys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|u_int32_t
name|maxsize
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|+
name|sc
operator|->
name|aac_max_fibs_alloc
operator|>
name|sc
operator|->
name|aac_max_fibs
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fibmap
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* allocate the FIBs in DMAable memory and load them */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fm
operator|->
name|aac_fibs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fm
operator|->
name|aac_fibmap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Not enough contiguous memory available.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|maxsize
operator|=
name|sc
operator|->
name|aac_max_fib_size
operator|+
literal|31
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE1
condition|)
name|maxsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_xporthdr
argument_list|)
expr_stmt|;
comment|/* Ignore errors since this doesn't bounce */
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
name|maxsize
argument_list|,
name|aac_map_command_helper
argument_list|,
operator|&
name|fibphys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize constant fields in the command structure */
name|bzero
argument_list|(
name|fm
operator|->
name|aac_fibs
argument_list|,
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
name|maxsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|aac_max_fibs_alloc
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
name|sc
operator|->
name|aac_commands
operator|+
name|sc
operator|->
name|total_fibs
expr_stmt|;
name|fm
operator|->
name|aac_commands
operator|=
name|cm
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|=
operator|(
expr|struct
name|aac_fib
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|fm
operator|->
name|aac_fibs
operator|+
name|i
operator|*
name|maxsize
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_fibphys
operator|=
name|fibphys
operator|+
name|i
operator|*
name|maxsize
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE1
condition|)
block|{
name|u_int64_t
name|fibphys_aligned
decl_stmt|;
name|fibphys_aligned
operator|=
operator|(
name|cm
operator|->
name|cm_fibphys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_xporthdr
argument_list|)
operator|+
literal|31
operator|)
operator|&
operator|~
literal|31
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|=
operator|(
expr|struct
name|aac_fib
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|cm
operator|->
name|cm_fib
operator|+
operator|(
name|fibphys_aligned
operator|-
name|cm
operator|->
name|cm_fibphys
operator|)
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_fibphys
operator|=
name|fibphys_aligned
expr_stmt|;
block|}
else|else
block|{
name|u_int64_t
name|fibphys_aligned
decl_stmt|;
name|fibphys_aligned
operator|=
operator|(
name|cm
operator|->
name|cm_fibphys
operator|+
literal|31
operator|)
operator|&
operator|~
literal|31
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|=
operator|(
expr|struct
name|aac_fib
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|cm
operator|->
name|cm_fib
operator|+
operator|(
name|fibphys_aligned
operator|-
name|cm
operator|->
name|cm_fibphys
operator|)
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_fibphys
operator|=
name|fibphys_aligned
expr_stmt|;
block|}
name|cm
operator|->
name|cm_index
operator|=
name|sc
operator|->
name|total_fibs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_datamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|sc
operator|->
name|aac_max_fibs
operator|<=
literal|1
operator|||
name|sc
operator|->
name|aac_max_fibs
operator|-
name|sc
operator|->
name|total_fibs
operator|>
literal|1
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aacraid_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|total_fibs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|,
name|fm
argument_list|,
name|fm_link
argument_list|)
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_COMM_B
argument_list|,
literal|"total_fibs= %d\n"
argument_list|,
name|sc
operator|->
name|total_fibs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free FIBs owned by this adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fibmap
modifier|*
name|fm
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|,
name|fm
argument_list|,
name|fm_link
argument_list|)
expr_stmt|;
comment|/* 		 * We check against total_fibs to handle partially 		 * allocated blocks. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|aac_max_fibs_alloc
operator|&&
name|sc
operator|->
name|total_fibs
operator|--
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
name|fm
operator|->
name|aac_commands
operator|+
name|i
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Command-mapping helper function - populate this command's s/g table.  */
end_comment

begin_function
name|void
name|aacraid_map_command_sg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|aac_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|"nseg %d"
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* copy into the FIB */
if|if
condition|(
name|cm
operator|->
name|cm_sgtable
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fib
operator|->
name|Header
operator|.
name|Command
operator|==
name|RawIo2
condition|)
block|{
name|struct
name|aac_raw_io2
modifier|*
name|raw
decl_stmt|;
name|struct
name|aac_sge_ieee1212
modifier|*
name|sg
decl_stmt|;
name|u_int32_t
name|min_size
init|=
name|PAGE_SIZE
decl_stmt|,
name|cur_size
decl_stmt|;
name|int
name|conformable
init|=
name|TRUE
decl_stmt|;
name|raw
operator|=
operator|(
expr|struct
name|aac_raw_io2
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|aac_sge_ieee1212
operator|*
operator|)
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
name|raw
operator|->
name|sgeCnt
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|cur_size
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|sg
index|[
name|i
index|]
operator|.
name|addrHigh
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
operator|&
name|sg
index|[
name|i
index|]
operator|.
name|addrLow
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
index|[
name|i
index|]
operator|.
name|length
operator|=
name|cur_size
expr_stmt|;
name|sg
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|raw
operator|->
name|sgeFirstSize
operator|=
name|cur_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|raw
operator|->
name|sgeNominalSize
operator|=
name|cur_size
expr_stmt|;
name|min_size
operator|=
name|cur_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|nseg
operator|&&
name|cur_size
operator|!=
name|raw
operator|->
name|sgeNominalSize
condition|)
block|{
name|conformable
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cur_size
operator|<
name|min_size
condition|)
name|min_size
operator|=
name|cur_size
expr_stmt|;
block|}
block|}
comment|/* not conformable: evaluate required sg elements */
if|if
condition|(
operator|!
name|conformable
condition|)
block|{
name|int
name|j
decl_stmt|,
name|err_found
decl_stmt|,
name|nseg_new
init|=
name|nseg
decl_stmt|;
for|for
control|(
name|i
operator|=
name|min_size
operator|/
name|PAGE_SIZE
init|;
name|i
operator|>=
literal|1
condition|;
operator|--
name|i
control|)
block|{
name|err_found
operator|=
name|FALSE
expr_stmt|;
name|nseg_new
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nseg
operator|-
literal|1
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|sg
index|[
name|j
index|]
operator|.
name|length
operator|%
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
name|err_found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|nseg_new
operator|+=
operator|(
name|sg
index|[
name|j
index|]
operator|.
name|length
operator|/
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err_found
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|nseg_new
operator|<=
name|sc
operator|->
name|aac_sg_tablesize
operator|&&
operator|!
operator|(
name|sc
operator|->
name|hint_flags
operator|&
literal|4
operator|)
condition|)
name|nseg
operator|=
name|aac_convert_sgraw2
argument_list|(
name|sc
argument_list|,
name|raw
argument_list|,
name|i
argument_list|,
name|nseg
argument_list|,
name|nseg_new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw
operator|->
name|flags
operator||=
name|RIO2_SGL_CONFORMANT
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sge_ieee1212
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fib
operator|->
name|Header
operator|.
name|Command
operator|==
name|RawIo
condition|)
block|{
name|struct
name|aac_sg_tableraw
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|aac_sg_tableraw
operator|*
operator|)
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|Next
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|Prev
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entryraw
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|aac_sg_table
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|aac_sg_table64
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|aac_sg_table64
operator|*
operator|)
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntry64
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntry64
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fix up the address values in the FIB.  Use the command array index 	 * instead of a pointer since these fields are only 32 bits.  Shift 	 * the SenderFibAddress over to make room for the fast response bit 	 * and for the AIF bit 	 */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|cm
operator|->
name|cm_index
operator|<<
literal|2
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|u
operator|.
name|ReceiverFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
comment|/* save a pointer to the command for speedy reverse-lookup */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Handle
operator|+=
name|cm
operator|->
name|cm_index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_passthr_dmat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_MAPPED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SYNC_MODE
condition|)
block|{
name|u_int32_t
name|wait
init|=
literal|0
decl_stmt|;
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_SYNCFIB
argument_list|,
name|cm
operator|->
name|cm_fibphys
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_WAIT
condition|)
block|{
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_SYNCFIB
argument_list|,
name|cm
operator|->
name|cm_fibphys
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|count
init|=
literal|10000000L
decl_stmt|;
while|while
condition|(
name|AAC_SEND_COMMAND
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_QUEUE_FRZN
expr_stmt|;
name|aac_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* wait 5 usec. */
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|aac_convert_sgraw2
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_raw_io2
modifier|*
name|raw
parameter_list|,
name|int
name|pages
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|nseg_new
parameter_list|)
block|{
name|struct
name|aac_sge_ieee1212
modifier|*
name|sge
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pos
decl_stmt|;
name|u_int32_t
name|addr_low
decl_stmt|;
name|sge
operator|=
name|malloc
argument_list|(
name|nseg_new
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sge_ieee1212
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sge
operator|==
name|NULL
condition|)
return|return
name|nseg
return|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|pos
operator|=
literal|1
init|;
name|i
operator|<
name|nseg
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|raw
operator|->
name|sge
index|[
name|i
index|]
operator|.
name|length
operator|/
operator|(
name|pages
operator|*
name|PAGE_SIZE
operator|)
condition|;
operator|++
name|j
control|)
block|{
name|addr_low
operator|=
name|raw
operator|->
name|sge
index|[
name|i
index|]
operator|.
name|addrLow
operator|+
name|j
operator|*
name|pages
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sge
index|[
name|pos
index|]
operator|.
name|addrLow
operator|=
name|addr_low
expr_stmt|;
name|sge
index|[
name|pos
index|]
operator|.
name|addrHigh
operator|=
name|raw
operator|->
name|sge
index|[
name|i
index|]
operator|.
name|addrHigh
expr_stmt|;
if|if
condition|(
name|addr_low
operator|<
name|raw
operator|->
name|sge
index|[
name|i
index|]
operator|.
name|addrLow
condition|)
name|sge
index|[
name|pos
index|]
operator|.
name|addrHigh
operator|++
expr_stmt|;
name|sge
index|[
name|pos
index|]
operator|.
name|length
operator|=
name|pages
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sge
index|[
name|pos
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
block|}
name|sge
index|[
name|pos
index|]
operator|=
name|raw
operator|->
name|sge
index|[
name|nseg
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nseg_new
condition|;
operator|++
name|i
control|)
name|raw
operator|->
name|sge
index|[
name|i
index|]
operator|=
name|sge
index|[
name|i
index|]
expr_stmt|;
name|free
argument_list|(
name|sge
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
name|raw
operator|->
name|sgeCnt
operator|=
name|nseg_new
expr_stmt|;
name|raw
operator|->
name|flags
operator||=
name|RIO2_SGL_CONFORMANT
expr_stmt|;
name|raw
operator|->
name|sgeNominalSize
operator|=
name|pages
operator|*
name|PAGE_SIZE
expr_stmt|;
return|return
name|nseg_new
return|;
block|}
end_function

begin_comment
comment|/*  * Unmap a command from controller-visible space.  */
end_comment

begin_function
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_MAPPED
operator|)
condition|)
return|return;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_datalen
operator|!=
literal|0
operator|&&
name|cm
operator|->
name|cm_passthr_dmat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|AAC_CMD_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hardware Interface  */
end_comment

begin_comment
comment|/*  * Initialize the adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_common_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_check_firmware
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|code
decl_stmt|,
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|maxsize
decl_stmt|;
name|u_int32_t
name|options
init|=
literal|0
decl_stmt|,
name|atu_size
init|=
literal|0
decl_stmt|,
name|status
decl_stmt|,
name|waitCount
decl_stmt|;
name|time_t
name|then
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* check if flash update is running */
if|if
condition|(
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
operator|&
name|AAC_FLASH_UPD_PENDING
condition|)
block|{
name|then
operator|=
name|time_uptime
expr_stmt|;
do|do
block|{
name|code
operator|=
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|>
operator|(
name|then
operator|+
name|AAC_FWUPD_TIMEOUT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller not coming ready, "
literal|"status %x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|code
operator|&
name|AAC_FLASH_UPD_SUCCESS
operator|)
operator|&&
operator|!
operator|(
name|code
operator|&
name|AAC_FLASH_UPD_FAILED
operator|)
condition|)
do|;
comment|/*  		 * Delay 10 seconds. Because right now FW is doing a soft reset, 		 * do not read scratch pad register at this time 		 */
name|waitCount
operator|=
literal|10
operator|*
literal|10000
expr_stmt|;
while|while
condition|(
name|waitCount
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* delay 100 microseconds */
name|waitCount
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Wait for the adapter to come ready. 	 */
name|then
operator|=
name|time_uptime
expr_stmt|;
do|do
block|{
name|code
operator|=
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|>
operator|(
name|then
operator|+
name|AAC_BOOT_TIMEOUT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller not coming ready, "
literal|"status %x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|code
operator|&
name|AAC_UP_AND_RUNNING
operator|)
operator|||
name|code
operator|==
literal|0xffffffff
condition|)
do|;
comment|/* 	 * Retrieve the firmware version numbers.  Dell PERC2/QC cards with 	 * firmware version 1.x are not compatible with this driver. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_PERC2QC
condition|)
block|{
if|if
condition|(
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_GETKERNVER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error reading firmware version\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* These numbers are stored as ASCII! */
name|major
operator|=
operator|(
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
name|minor
operator|=
operator|(
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
if|if
condition|(
name|major
operator|==
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Firmware version %d.%d is not supported.\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* 	 * Retrieve the capabilities/supported options word so we know what 	 * work-arounds to enable.  Some firmware revs don't support this 	 * command. 	 */
if|if
condition|(
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_GETINFO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|AAC_SRB_STS_INVALID_REQUEST
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestAdapterInfo failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|atu_size
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|supported_options
operator|=
name|options
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|AAC_SUPPORTED_4GB_WINDOW
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NO4GB
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_4GB_WINDOW
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|AAC_SUPPORTED_NONDASD
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_ENABLE_CAM
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|AAC_SUPPORTED_SGMAP_HOST64
operator|)
operator|!=
literal|0
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
operator|)
operator|&&
operator|(
name|sc
operator|->
name|hint_flags
operator|&
literal|0x1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Enabling 64-bit address support\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_SG_64BIT
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aac_if
operator|.
name|aif_send_command
condition|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|AAC_SUPPORTED_NEW_COMM_TYPE3
operator|)
operator|||
operator|(
name|options
operator|&
name|AAC_SUPPORTED_NEW_COMM_TYPE4
operator|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_NEW_COMM
operator||
name|AAC_FLAGS_NEW_COMM_TYPE34
expr_stmt|;
elseif|else
if|if
condition|(
name|options
operator|&
name|AAC_SUPPORTED_NEW_COMM_TYPE1
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_NEW_COMM
operator||
name|AAC_FLAGS_NEW_COMM_TYPE1
expr_stmt|;
elseif|else
if|if
condition|(
name|options
operator|&
name|AAC_SUPPORTED_NEW_COMM_TYPE2
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_NEW_COMM
operator||
name|AAC_FLAGS_NEW_COMM_TYPE2
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|AAC_SUPPORTED_64BIT_ARRAYSIZE
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_ARRAY_64BIT
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Communication interface not supported!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|hint_flags
operator|&
literal|2
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Sync. mode enforced by driver parameter. This will cause a significant performance decrease!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_SYNC_MODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE34
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Async. mode not supported by current driver, sync. mode enforced.\nPlease update driver to get full performance.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_SYNC_MODE
expr_stmt|;
block|}
comment|/* Check for broken hardware that does a lower number of commands */
name|sc
operator|->
name|aac_max_fibs
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_256FIBS
condition|?
literal|256
else|:
literal|512
operator|)
expr_stmt|;
comment|/* Remap mem. resource, if required */
if|if
condition|(
name|atu_size
operator|>
name|rman_get_size
argument_list|(
name|sc
operator|->
name|aac_regs_res0
argument_list|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|aac_regs_rid0
argument_list|,
name|sc
operator|->
name|aac_regs_res0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_regs_res0
operator|=
name|bus_alloc_resource_anywhere
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|aac_regs_rid0
argument_list|,
name|atu_size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_regs_res0
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|aac_regs_res0
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|aac_regs_rid0
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_regs_res0
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"couldn't allocate register window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|aac_btag0
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|aac_regs_res0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_bhandle0
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|aac_regs_res0
argument_list|)
expr_stmt|;
block|}
comment|/* Read preferred settings */
name|sc
operator|->
name|aac_max_fib_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_sectors
operator|=
literal|128
expr_stmt|;
comment|/* 64KB */
name|sc
operator|->
name|aac_max_aif
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
condition|)
name|sc
operator|->
name|aac_sg_tablesize
operator|=
operator|(
name|AAC_FIB_DATASIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite64
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry64
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|aac_sg_tablesize
operator|=
operator|(
name|AAC_FIB_DATASIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_GETCOMMPREF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_fib_size
operator|=
operator|(
name|options
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
name|sc
operator|->
name|aac_max_sectors
operator|=
operator|(
name|options
operator|>>
literal|16
operator|)
operator|<<
literal|1
expr_stmt|;
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_sg_tablesize
operator|=
operator|(
name|options
operator|>>
literal|16
operator|)
expr_stmt|;
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_fibs
operator|=
operator|(
operator|(
name|options
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_max_fibs
operator|==
literal|0
operator|||
name|sc
operator|->
name|aac_hwif
operator|!=
name|AAC_HWIF_SRCV
condition|)
name|sc
operator|->
name|aac_max_fibs
operator|=
operator|(
name|options
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_aif
operator|=
operator|(
name|options
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_msix
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE2
operator|)
condition|?
name|options
else|:
literal|0
expr_stmt|;
block|}
name|maxsize
operator|=
name|sc
operator|->
name|aac_max_fib_size
operator|+
literal|31
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE1
condition|)
name|maxsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_xporthdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxsize
operator|>
name|PAGE_SIZE
condition|)
block|{
name|sc
operator|->
name|aac_max_fib_size
operator|-=
operator|(
name|maxsize
operator|-
name|PAGE_SIZE
operator|)
expr_stmt|;
name|maxsize
operator|=
name|PAGE_SIZE
expr_stmt|;
block|}
name|sc
operator|->
name|aac_max_fibs_alloc
operator|=
name|PAGE_SIZE
operator|/
name|maxsize
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_max_fib_size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_RAW_IO
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Enable Raw I/O\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_RAW_IO
operator|)
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_ARRAY_64BIT
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_LBA_64BIT
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Enable 64-bit array\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AACRAID_DEBUG
name|aacraid_get_fw_debug_buffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_adapter_init
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* reset rrq index */
name|sc
operator|->
name|aac_fibs_pushed_no
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|aac_max_msix
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|aac_host_rrq_idx
index|[
name|i
index|]
operator|=
name|i
operator|*
name|sc
operator|->
name|aac_vector_cap
expr_stmt|;
comment|/* 	 * Fill in the init structure.  This tells the adapter about the 	 * physical location of various important shared data structures. 	 */
name|ip
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_init
expr_stmt|;
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_max_fib_size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION_4
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_RAW_IO
expr_stmt|;
block|}
name|ip
operator|->
name|NoOfMSIXVectors
operator|=
name|sc
operator|->
name|aac_max_msix
expr_stmt|;
name|ip
operator|->
name|AdapterFibsPhysicalAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_fibs
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibsVirtualAddress
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|AdapterFibsSize
operator|=
name|AAC_ADAPTER_FIBS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibAlign
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_printf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferSize
operator|=
name|AAC_PRINTF_BUFSIZE
expr_stmt|;
comment|/* 	 * The adapter assumes that pages are 4K in size, except on some  	 * broken firmware versions that do the page->byte conversion twice, 	 * therefore 'assuming' that this value is in 16MB units (2^24). 	 * Round up since the granularity is so high. 	 */
name|ip
operator|->
name|HostPhysMemPages
operator|=
name|ctob
argument_list|(
name|physmem
argument_list|)
operator|/
name|AAC_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_BROKEN_MEMMAP
condition|)
block|{
name|ip
operator|->
name|HostPhysMemPages
operator|=
operator|(
name|ip
operator|->
name|HostPhysMemPages
operator|+
name|AAC_PAGE_SIZE
operator|)
operator|/
name|AAC_PAGE_SIZE
expr_stmt|;
block|}
name|ip
operator|->
name|HostElapsedSeconds
operator|=
name|time_uptime
expr_stmt|;
comment|/* reset later if invalid */
name|ip
operator|->
name|InitFlags
operator|=
name|AAC_INITFLAGS_NEW_COMM_SUPPORTED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE1
condition|)
block|{
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION_6
expr_stmt|;
name|ip
operator|->
name|InitFlags
operator||=
operator|(
name|AAC_INITFLAGS_NEW_COMM_TYPE1_SUPPORTED
operator||
name|AAC_INITFLAGS_FAST_JBOD_SUPPORTED
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"New comm. interface type1 enabled\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE2
condition|)
block|{
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION_7
expr_stmt|;
name|ip
operator|->
name|InitFlags
operator||=
operator|(
name|AAC_INITFLAGS_NEW_COMM_TYPE2_SUPPORTED
operator||
name|AAC_INITFLAGS_FAST_JBOD_SUPPORTED
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"New comm. interface type2 enabled\n"
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|MaxNumAif
operator|=
name|sc
operator|->
name|aac_max_aif
expr_stmt|;
name|ip
operator|->
name|HostRRQ_AddrLow
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_host_rrq
argument_list|)
expr_stmt|;
comment|/* always 32-bit address */
name|ip
operator|->
name|HostRRQ_AddrHigh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_support_opt2
operator|&
name|AAC_SUPPORTED_POWER_MANAGEMENT
condition|)
block|{
name|ip
operator|->
name|InitFlags
operator||=
name|AAC_INITFLAGS_DRIVER_SUPPORTS_PM
expr_stmt|;
name|ip
operator|->
name|InitFlags
operator||=
name|AAC_INITFLAGS_DRIVER_USES_UTC_TIME
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Power Management enabled\n"
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|MaxIoCommands
operator|=
name|sc
operator|->
name|aac_max_fibs
expr_stmt|;
name|ip
operator|->
name|MaxIoSize
operator|=
name|sc
operator|->
name|aac_max_sectors
operator|<<
literal|9
expr_stmt|;
name|ip
operator|->
name|MaxFibSize
operator|=
name|sc
operator|->
name|aac_max_fib_size
expr_stmt|;
comment|/* 	 * Do controller-type-specific initialisation 	 */
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_C
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Give the init structure to the controller. 	 */
if|if
condition|(
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_INITSTRUCT
argument_list|,
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_init
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"error establishing init structure\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Check configuration issues  	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_check_config
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_define_int_mode
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|cap
decl_stmt|,
name|msi_count
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|aac_dev
expr_stmt|;
comment|/* max. vectors from AAC_MONKER_GETCOMMPREF */
if|if
condition|(
name|sc
operator|->
name|aac_max_msix
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|aac_max_msix
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|aac_vector_cap
operator|=
name|sc
operator|->
name|aac_max_fibs
expr_stmt|;
return|return;
block|}
comment|/* OS capability */
name|msi_count
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi_count
operator|>
name|AAC_MAX_MSIX
condition|)
name|msi_count
operator|=
name|AAC_MAX_MSIX
expr_stmt|;
if|if
condition|(
name|msi_count
operator|>
name|sc
operator|->
name|aac_max_msix
condition|)
name|msi_count
operator|=
name|sc
operator|->
name|aac_max_msix
expr_stmt|;
if|if
condition|(
name|msi_count
operator|==
literal|0
operator|||
operator|(
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msi_count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc msix failed - msi_count=%d, err=%d; "
literal|"will try MSI\n"
argument_list|,
name|msi_count
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|msi_enabled
operator|=
name|TRUE
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using MSI-X interrupts (%u vectors)\n"
argument_list|,
name|msi_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|msi_enabled
condition|)
block|{
name|msi_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msi_count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc msi failed - err=%d; "
literal|"will use INTx\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|msi_enabled
operator|=
name|TRUE
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using MSI interrupts\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|msi_enabled
condition|)
block|{
comment|/* now read controller capability from PCI config. space */
name|cap
operator|=
name|aac_find_pci_capability
argument_list|(
name|sc
argument_list|,
name|PCIY_MSIX
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|cap
operator|!=
literal|0
condition|?
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|AAC_PCI_MSI_ENABLE
operator|)
condition|)
block|{
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msi_enabled
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|msi_enabled
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using legacy interrupts\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_msix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_ENABLE_MSIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_max_msix
operator|>
name|msi_count
condition|)
name|sc
operator|->
name|aac_max_msix
operator|=
name|msi_count
expr_stmt|;
block|}
name|sc
operator|->
name|aac_vector_cap
operator|=
name|sc
operator|->
name|aac_max_fibs
operator|/
name|sc
operator|->
name|aac_max_msix
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_DEBUG_B
argument_list|,
literal|"msi_enabled %d vector_cap %d max_fibs %d max_msix %d"
argument_list|,
name|sc
operator|->
name|msi_enabled
argument_list|,
name|sc
operator|->
name|aac_vector_cap
argument_list|,
name|sc
operator|->
name|aac_max_fibs
argument_list|,
name|sc
operator|->
name|aac_max_msix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_find_pci_capability
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint8_t
name|ptr
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|aac_dev
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
name|int
name|next
decl_stmt|,
name|val
decl_stmt|;
name|next
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|cap
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|ptr
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_setup_intr
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|msi_count
decl_stmt|,
name|rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
name|msi_count
operator|=
name|sc
operator|->
name|aac_max_msix
expr_stmt|;
name|rid
operator|=
operator|(
name|sc
operator|->
name|msi_enabled
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msi_count
condition|;
name|i
operator|++
operator|,
name|rid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|aac_irq_rid
index|[
name|i
index|]
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|aac_irq
index|[
name|i
index|]
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|aac_bus_setup_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_BIO
argument_list|,
name|NULL
argument_list|,
name|aacraid_new_intr_type1
argument_list|,
operator|&
name|sc
operator|->
name|aac_msix
index|[
name|i
index|]
argument_list|,
operator|&
name|tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|aac_msix
index|[
name|i
index|]
operator|.
name|vector_no
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|aac_msix
index|[
name|i
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|aac_intr
index|[
name|i
index|]
operator|=
name|tag
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_check_config
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_cnt_config
modifier|*
name|ccfg
decl_stmt|;
name|struct
name|aac_cf_status_hdr
modifier|*
name|cf_shdr
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|ccfg
operator|=
operator|(
expr|struct
name|aac_cnt_config
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|ccfg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ccfg
argument_list|)
operator|-
name|CT_PACKET_SIZE
argument_list|)
expr_stmt|;
name|ccfg
operator|->
name|Command
operator|=
name|VM_ContainerConfig
expr_stmt|;
name|ccfg
operator|->
name|CTCommand
operator|.
name|command
operator|=
name|CT_GET_CONFIG_STATUS
expr_stmt|;
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
name|CNT_SIZE
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_cf_status_hdr
argument_list|)
expr_stmt|;
name|rval
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_cnt_config
argument_list|)
argument_list|)
expr_stmt|;
name|cf_shdr
operator|=
operator|(
expr|struct
name|aac_cf_status_hdr
operator|*
operator|)
name|ccfg
operator|->
name|CTCommand
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
operator|&&
name|ccfg
operator|->
name|Command
operator|==
name|ST_OK
operator|&&
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|CT_OK
condition|)
block|{
if|if
condition|(
name|cf_shdr
operator|->
name|action
operator|<=
name|CFACT_PAUSE
condition|)
block|{
name|bzero
argument_list|(
name|ccfg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ccfg
argument_list|)
operator|-
name|CT_PACKET_SIZE
argument_list|)
expr_stmt|;
name|ccfg
operator|->
name|Command
operator|=
name|VM_ContainerConfig
expr_stmt|;
name|ccfg
operator|->
name|CTCommand
operator|.
name|command
operator|=
name|CT_COMMIT_CONFIG
expr_stmt|;
name|rval
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_cnt_config
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
operator|&&
name|ccfg
operator|->
name|Command
operator|==
name|ST_OK
operator|&&
name|ccfg
operator|->
name|CTCommand
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|CT_OK
condition|)
block|{
comment|/* successful completion */
name|rval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* auto commit aborted due to error(s) */
name|rval
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* auto commit aborted due to adapter indicating 			   config. issues too dangerous to auto commit  */
name|rval
operator|=
operator|-
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* error */
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a synchronous command to the controller and wait for a result.  * Indicate if the controller completed the command with an error status.  */
end_comment

begin_function
name|int
name|aacraid_sync_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|,
name|u_int32_t
modifier|*
name|sp
parameter_list|,
name|u_int32_t
modifier|*
name|r1
parameter_list|)
block|{
name|time_t
name|then
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* populate the mailbox */
name|AAC_SET_MAILBOX
argument_list|(
name|sc
argument_list|,
name|command
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
comment|/* ensure the sync command doorbell flag is cleared */
if|if
condition|(
operator|!
name|sc
operator|->
name|msi_enabled
condition|)
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* then set it to signal the adapter */
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|!=
name|AAC_MONKER_SYNCFIB
operator|)
operator|||
operator|(
name|sp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|sp
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* spin waiting for the command to complete */
name|then
operator|=
name|time_uptime
expr_stmt|;
do|do
block|{
if|if
condition|(
name|time_uptime
operator|>
operator|(
name|then
operator|+
name|AAC_SYNC_TIMEOUT
operator|)
condition|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_ERROR_B
argument_list|,
literal|"timed out"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
operator|&
name|AAC_DB_SYNC_COMMAND
operator|)
condition|)
do|;
comment|/* clear the completion flag */
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* get the command status */
name|status
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
operator|*
name|sp
operator|=
name|status
expr_stmt|;
comment|/* return parameter */
if|if
condition|(
name|r1
operator|!=
name|NULL
condition|)
operator|*
name|r1
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AAC_SRB_STS_SUCCESS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|xferstate
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|,
name|u_int16_t
name|datasize
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
name|AAC_FIB_DATASIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Set up the sync FIB 	 */
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|xferstate
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|command
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
operator|+
name|datasize
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
literal|0
expr_stmt|;
comment|/* Not needed */
name|fib
operator|->
name|Header
operator|.
name|u
operator|.
name|ReceiverFibAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_sync_fib
argument_list|)
expr_stmt|;
comment|/* 	 * Give the FIB to the controller, wait for a response. 	 */
if|if
condition|(
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_SYNCFIB
argument_list|,
name|fib
operator|->
name|Header
operator|.
name|u
operator|.
name|ReceiverFibAddress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_ERROR_B
argument_list|,
literal|"IO error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for commands that have been outstanding for a suspiciously long time,  * and complain about them.  */
end_comment

begin_function
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
name|int
name|timedout
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Traverse the busy command list, bitch about late commands once 	 * only. 	 */
name|timedout
operator|=
literal|0
expr_stmt|;
name|deadline
operator|=
name|time_uptime
operator|-
name|AAC_CMD_TIMEOUT
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&sc->aac_busy
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_timestamp
operator|<
name|deadline
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"COMMAND %p TIMEOUT AFTER %d SECONDS\n"
argument_list|,
name|cm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_uptime
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|)
expr_stmt|;
name|timedout
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timedout
condition|)
name|aac_reset_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aacraid_print_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interface Function Vectors  */
end_comment

begin_comment
comment|/*  * Read the current firmware status word.  */
end_comment

begin_function
specifier|static
name|int
name|aac_src_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_OMR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify the controller of a change in a given queue  */
end_comment

begin_function
specifier|static
name|void
name|aac_src_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|,
name|qbit
operator|<<
name|AAC_SRC_IDR_SHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the interrupt reason bits  */
end_comment

begin_function
specifier|static
name|int
name|aac_src_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msi_enabled
condition|)
block|{
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_MSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|AAC_MSI_SYNC_STATUS
condition|)
name|val
operator|=
name|AAC_DB_SYNC_COMMAND
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_R
argument_list|)
operator|>>
name|AAC_SRC_ODR_SHIFT
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear some interrupt reason bits  */
end_comment

begin_function
specifier|static
name|void
name|aac_src_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msi_enabled
condition|)
block|{
if|if
condition|(
name|mask
operator|==
name|AAC_DB_SYNC_COMMAND
condition|)
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_CLEAR_SYNC_BIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_ODBR_C
argument_list|,
name|mask
operator|<<
name|AAC_SRC_ODR_SHIFT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Populate the mailbox and set the command word  */
end_comment

begin_function
specifier|static
name|void
name|aac_src_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_srcv_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRCV_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRCV_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRCV_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRCV_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRCV_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch the immediate command status word  */
end_comment

begin_function
specifier|static
name|int
name|aac_src_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_MAILBOX
operator|+
operator|(
name|mb
operator|*
literal|4
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_srcv_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRCV_MAILBOX
operator|+
operator|(
name|mb
operator|*
literal|4
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set/clear interrupt masks  */
end_comment

begin_function
specifier|static
name|void
name|aac_src_access_devreg
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|AAC_ENABLE_INTERRUPT
case|:
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_OIMR
argument_list|,
operator|(
name|sc
operator|->
name|msi_enabled
condition|?
name|AAC_INT_ENABLE_TYPE1_MSIX
else|:
name|AAC_INT_ENABLE_TYPE1_INTX
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AAC_DISABLE_INTERRUPT
case|:
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_OIMR
argument_list|,
name|AAC_INT_DISABLE_ALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|AAC_ENABLE_MSIX
case|:
comment|/* set bit 6 */
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x40
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
comment|/* unmask int. */
name|val
operator|=
name|PMC_ALL_INTERRUPT_BITS
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IOAR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_OIMR
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_OIMR
argument_list|,
name|val
operator|&
operator|(
operator|~
operator|(
name|PMC_GLOBAL_INT_BIT2
operator||
name|PMC_GLOBAL_INT_BIT0
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AAC_DISABLE_MSIX
case|:
comment|/* reset bit 6 */
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
break|break;
case|case
name|AAC_CLEAR_AIF_BIT
case|:
comment|/* set bit 5 */
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x20
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
break|break;
case|case
name|AAC_CLEAR_SYNC_BIT
case|:
comment|/* set bit 4 */
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x10
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
break|break;
case|case
name|AAC_ENABLE_INTX
case|:
comment|/* set bit 7 */
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x80
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|)
expr_stmt|;
comment|/* unmask int. */
name|val
operator|=
name|PMC_ALL_INTERRUPT_BITS
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IOAR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_MEM0_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_OIMR
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_OIMR
argument_list|,
name|val
operator|&
operator|(
operator|~
operator|(
name|PMC_GLOBAL_INT_BIT2
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * New comm. interface: Send command functions  */
end_comment

begin_function
specifier|static
name|int
name|aac_src_send_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_fib_xporthdr
modifier|*
name|pFibX
decl_stmt|;
name|u_int32_t
name|fibsize
decl_stmt|,
name|high_addr
decl_stmt|;
name|u_int64_t
name|address
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|"send command (new comm. type1)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msi_enabled
operator|&&
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Command
operator|!=
name|AifRequest
operator|&&
name|sc
operator|->
name|aac_max_msix
operator|>
literal|1
condition|)
block|{
name|u_int16_t
name|vector_no
decl_stmt|,
name|first_choice
init|=
literal|0xffff
decl_stmt|;
name|vector_no
operator|=
name|sc
operator|->
name|aac_fibs_pushed_no
operator|%
name|sc
operator|->
name|aac_max_msix
expr_stmt|;
do|do
block|{
name|vector_no
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|vector_no
operator|==
name|sc
operator|->
name|aac_max_msix
condition|)
name|vector_no
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_rrq_outstanding
index|[
name|vector_no
index|]
operator|<
name|sc
operator|->
name|aac_vector_cap
condition|)
break|break;
if|if
condition|(
literal|0xffff
operator|==
name|first_choice
condition|)
name|first_choice
operator|=
name|vector_no
expr_stmt|;
elseif|else
if|if
condition|(
name|vector_no
operator|==
name|first_choice
condition|)
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|vector_no
operator|==
name|first_choice
condition|)
name|vector_no
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|aac_rrq_outstanding
index|[
name|vector_no
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_fibs_pushed_no
operator|==
literal|0xffffffff
condition|)
name|sc
operator|->
name|aac_fibs_pushed_no
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|aac_fibs_pushed_no
operator|++
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Handle
operator|+=
operator|(
name|vector_no
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM_TYPE2
condition|)
block|{
comment|/* Calculate the amount to the fibsize bits */
name|fibsize
operator|=
operator|(
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|+
literal|127
operator|)
operator|/
literal|128
operator|-
literal|1
expr_stmt|;
comment|/* Fill new FIB header */
name|address
operator|=
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
name|high_addr
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|address
operator|>>
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_addr
operator|==
literal|0L
condition|)
block|{
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB2
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|u
operator|.
name|TimeStamp
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB2_64
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|u
operator|.
name|SenderFibAddressHigh
operator|=
name|high_addr
expr_stmt|;
block|}
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|address
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculate the amount to the fibsize bits */
name|fibsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_xporthdr
argument_list|)
operator|+
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|+
literal|127
operator|)
operator|/
literal|128
operator|-
literal|1
expr_stmt|;
comment|/* Fill XPORT header */
name|pFibX
operator|=
operator|(
expr|struct
name|aac_fib_xporthdr
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cm
operator|->
name|cm_fib
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_xporthdr
argument_list|)
operator|)
expr_stmt|;
name|pFibX
operator|->
name|Handle
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Handle
expr_stmt|;
name|pFibX
operator|->
name|HostAddress
operator|=
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
name|pFibX
operator|->
name|Size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
name|address
operator|=
name|cm
operator|->
name|cm_fibphys
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_xporthdr
argument_list|)
expr_stmt|;
name|high_addr
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|address
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fibsize
operator|>
literal|31
condition|)
name|fibsize
operator|=
literal|31
expr_stmt|;
name|aac_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_addr
condition|)
block|{
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IQUE64_H
argument_list|,
name|high_addr
argument_list|)
expr_stmt|;
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IQUE64_L
argument_list|,
operator|(
name|u_int32_t
operator|)
name|address
operator|+
name|fibsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IQUE32
argument_list|,
operator|(
name|u_int32_t
operator|)
name|address
operator|+
name|fibsize
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * New comm. interface: get, set outbound queue index  */
end_comment

begin_function
specifier|static
name|int
name|aac_src_get_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_src_set_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debugging and Diagnostics  */
end_comment

begin_comment
comment|/*  * Print some information about the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_adapter_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|adapter_type
init|=
literal|"Adaptec RAID controller"
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|supported_options
operator|&
name|AAC_SUPPORTED_SUPPLEMENT_ADAPTER_INFO
condition|)
block|{
name|fib
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|RequestSupplementAdapterInfo
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
literal|1
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestSupplementAdapterInfo failed\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|aac_supplement_adapter_info
modifier|*
name|supp_info
decl_stmt|;
name|supp_info
operator|=
operator|(
operator|(
expr|struct
name|aac_supplement_adapter_info
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|adapter_type
operator|=
operator|(
name|char
operator|*
operator|)
name|supp_info
operator|->
name|AdapterTypeText
expr_stmt|;
name|sc
operator|->
name|aac_feature_bits
operator|=
name|supp_info
operator|->
name|FeatureBits
expr_stmt|;
name|sc
operator|->
name|aac_support_opt2
operator|=
name|supp_info
operator|->
name|SupportedOptions2
expr_stmt|;
block|}
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"%s, aacraid driver %d.%d.%d-%d\n"
argument_list|,
name|adapter_type
argument_list|,
name|AAC_DRIVER_MAJOR_VERSION
argument_list|,
name|AAC_DRIVER_MINOR_VERSION
argument_list|,
name|AAC_DRIVER_BUGFIX_LEVEL
argument_list|,
name|AAC_DRIVER_BUILD
argument_list|)
expr_stmt|;
name|fib
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|RequestAdapterInfo
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestAdapterInfo failed\n"
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save the kernel revision structure for later use */
name|info
operator|=
operator|(
expr|struct
name|aac_adapter_info
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_revision
operator|=
name|info
operator|->
name|KernelRevision
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"%s %dMHz, %dMB memory "
literal|"(%dMB cache, %dMB execution), %s\n"
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_cpu_variant
argument_list|,
name|info
operator|->
name|CpuVariant
argument_list|)
argument_list|,
name|info
operator|->
name|ClockSpeed
argument_list|,
name|info
operator|->
name|TotalMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|info
operator|->
name|BufferMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|info
operator|->
name|ExecutionMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_battery_platform
argument_list|,
name|info
operator|->
name|batteryPlatform
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Kernel %d.%d-%d, Build %d, S/N %6X\n"
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|major
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|minor
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|dash
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|buildNumber
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|info
operator|->
name|SerialNumber
operator|&
literal|0xffffff
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Supported Options=%b\n"
argument_list|,
name|sc
operator|->
name|supported_options
argument_list|,
literal|"\20"
literal|"\1SNAPSHOT"
literal|"\2CLUSTERS"
literal|"\3WCACHE"
literal|"\4DATA64"
literal|"\5HOSTTIME"
literal|"\6RAID50"
literal|"\7WINDOW4GB"
literal|"\10SCSIUPGD"
literal|"\11SOFTERR"
literal|"\12NORECOND"
literal|"\13SGMAP64"
literal|"\14ALARM"
literal|"\15NONDASD"
literal|"\16SCSIMGT"
literal|"\17RAIDSCSI"
literal|"\21ADPTINFO"
literal|"\22NEWCOMM"
literal|"\23ARRAY64BIT"
literal|"\24HEATSENSOR"
argument_list|)
expr_stmt|;
block|}
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up a text description of a numeric error code and return a pointer to  * same.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|string
operator|)
return|;
return|return
operator|(
name|table
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Management Interface  */
end_comment

begin_function
specifier|static
name|int
name|aac_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|702000
name|device_busy
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|devfs_set_cdevpriv
argument_list|(
name|sc
argument_list|,
name|aac_cdevpriv_dtor
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|union
name|aac_statrequest
modifier|*
name|as
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|as
operator|=
operator|(
expr|union
name|aac_statrequest
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AACIO_STATS
case|:
switch|switch
condition|(
name|as
operator|->
name|as_item
condition|)
block|{
case|case
name|AACQ_FREE
case|:
case|case
name|AACQ_READY
case|:
case|case
name|AACQ_BUSY
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|aac_qstat
index|[
name|as
operator|->
name|as_item
index|]
argument_list|,
operator|&
name|as
operator|->
name|as_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FSACTL_SENDFIB
case|:
case|case
name|FSACTL_SEND_LARGE_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_SENDFIB
case|:
case|case
name|FSACTL_LNX_SEND_LARGE_FIB
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_SENDFIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_ioctl_sendfib
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_SEND_RAW_SRB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_SEND_RAW_SRB
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_SEND_RAW_SRB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_ioctl_send_raw_srb
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_AIF_THREAD
case|:
case|case
name|FSACTL_LNX_AIF_THREAD
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_AIF_THREAD"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|FSACTL_OPEN_GET_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_OPEN_GET_ADAPTER_FIB
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_OPEN_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_open_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_GET_NEXT_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_GET_NEXT_ADAPTER_FIB
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_GET_NEXT_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_getnext_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_CLOSE_GET_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_CLOSE_GET_ADAPTER_FIB
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_CLOSE_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_close_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_MINIPORT_REV_CHECK
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_MINIPORT_REV_CHECK
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_MINIPORT_REV_CHECK"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_rev_check
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_QUERY_DISK
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_QUERY_DISK
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_QUERY_DISK"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_query_disk
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_DELETE_DISK
case|:
case|case
name|FSACTL_LNX_DELETE_DISK
case|:
comment|/* 		 * We don't trust the underland to tell us when to delete a 		 * container, rather we rely on an AIF coming from the 		 * controller 		 */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FSACTL_GET_PCI_INFO
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_GET_PCI_INFO
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_GET_PCI_INFO"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_get_pci_info
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_GET_FEATURES
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_GET_FEATURES
case|:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"FSACTL_GET_FEATURES"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_supported_features
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"unsupported cmd 0x%lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_fib_context
modifier|*
name|ctx
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLRDNORM
operator||
name|POLLIN
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_idx
operator|!=
name|sc
operator|->
name|aifq_idx
operator|||
name|ctx
operator|->
name|ctx_wrap
condition|)
block|{
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_ioctl_event
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|->
name|ev_type
condition|)
block|{
case|case
name|AAC_EVENT_CMFREE
case|:
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|aacraid_alloc_command
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|aac_command
operator|*
operator|*
operator|)
name|arg
argument_list|)
condition|)
block|{
name|aacraid_add_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|event
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a FIB supplied from userspace  */
end_comment

begin_function
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|size
decl_stmt|,
name|error
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Get a command 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|aacraid_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|struct
name|aac_event
modifier|*
name|event
decl_stmt|;
name|event
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_event
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|event
operator|->
name|ev_type
operator|=
name|AAC_EVENT_CMFREE
expr_stmt|;
name|event
operator|->
name|ev_callback
operator|=
name|aac_ioctl_event
expr_stmt|;
name|event
operator|->
name|ev_arg
operator|=
operator|&
name|cm
expr_stmt|;
name|aacraid_add_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
literal|0
argument_list|,
literal|"aacraid_ctlsfib"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Fetch the FIB header, then re-copy to get data as well. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|sc
operator|->
name|aac_max_fib_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"incoming FIB oversized (%d> %d)\n"
argument_list|,
name|size
argument_list|,
name|sc
operator|->
name|aac_max_fib_size
argument_list|)
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|aac_max_fib_size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|=
name|size
expr_stmt|;
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
name|cm
operator|->
name|cm_datalen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Pass the FIB to the controller, wait for it to complete. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|aacraid_wait_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aacraid_wait_command return %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Copy the FIB and data back out to the caller. 	 */
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|sc
operator|->
name|aac_max_fib_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"outbound FIB oversized (%d> %d)\n"
argument_list|,
name|size
argument_list|,
name|sc
operator|->
name|aac_max_fib_size
argument_list|)
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|aac_max_fib_size
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_fib
argument_list|,
name|ufib
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aacraid_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a passthrough FIB supplied from userspace  */
end_comment

begin_function
specifier|static
name|int
name|aac_ioctl_send_raw_srb
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_srb
modifier|*
name|srbcmd
decl_stmt|;
name|struct
name|aac_srb
modifier|*
name|user_srb
init|=
operator|(
expr|struct
name|aac_srb
operator|*
operator|)
name|arg
decl_stmt|;
name|void
modifier|*
name|user_reply
decl_stmt|;
name|int
name|error
decl_stmt|,
name|transfer_data
init|=
literal|0
decl_stmt|;
name|bus_dmamap_t
name|orig_map
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|fibsize
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|srb_sg_address
decl_stmt|;
name|u_int32_t
name|srb_sg_bytecount
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|aacraid_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|struct
name|aac_event
modifier|*
name|event
decl_stmt|;
name|event
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_event
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|event
operator|->
name|ev_type
operator|=
name|AAC_EVENT_CMFREE
expr_stmt|;
name|event
operator|->
name|ev_callback
operator|=
name|aac_ioctl_event
expr_stmt|;
name|event
operator|->
name|ev_arg
operator|=
operator|&
name|cm
expr_stmt|;
name|aacraid_add_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
literal|0
argument_list|,
literal|"aacraid_ctlsraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
comment|/* save original dma map */
name|orig_map
operator|=
name|cm
operator|->
name|cm_datamap
expr_stmt|;
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|srbcmd
operator|=
operator|(
expr|struct
name|aac_srb
operator|*
operator|)
name|fib
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|user_srb
operator|->
name|data_len
argument_list|,
operator|&
name|fibsize
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|fibsize
operator|>
operator|(
name|sc
operator|->
name|aac_max_fib_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|user_srb
argument_list|,
name|srbcmd
argument_list|,
name|fibsize
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
name|srbcmd
operator|->
name|function
operator|=
literal|0
expr_stmt|;
comment|/* SRBF_ExecuteScsi */
name|srbcmd
operator|->
name|retry_limit
operator|=
literal|0
expr_stmt|;
comment|/* obsolete */
comment|/* only one sg element from userspace supported */
if|if
condition|(
name|srbcmd
operator|->
name|sg_map
operator|.
name|SgCount
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check fibsize */
if|if
condition|(
name|fibsize
operator|==
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_srb
argument_list|)
operator|+
name|srbcmd
operator|->
name|sg_map
operator|.
name|SgCount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry
argument_list|)
operator|)
condition|)
block|{
name|struct
name|aac_sg_entry
modifier|*
name|sgp
init|=
name|srbcmd
operator|->
name|sg_map
operator|.
name|SgEntry
decl_stmt|;
name|struct
name|aac_sg_entry
name|sg
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|sgp
argument_list|,
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|srb_sg_bytecount
operator|=
name|sg
operator|.
name|SgByteCount
expr_stmt|;
name|srb_sg_address
operator|=
operator|(
name|u_int64_t
operator|)
name|sg
operator|.
name|SgAddress
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fibsize
operator|==
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_srb
argument_list|)
operator|+
name|srbcmd
operator|->
name|sg_map
operator|.
name|SgCount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry64
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__LP64__
name|struct
name|aac_sg_entry64
modifier|*
name|sgp
init|=
operator|(
expr|struct
name|aac_sg_entry64
operator|*
operator|)
name|srbcmd
operator|->
name|sg_map
operator|.
name|SgEntry
decl_stmt|;
name|struct
name|aac_sg_entry64
name|sg
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|sgp
argument_list|,
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|srb_sg_bytecount
operator|=
name|sg
operator|.
name|SgByteCount
expr_stmt|;
name|srb_sg_address
operator|=
name|sg
operator|.
name|SgAddress
expr_stmt|;
if|if
condition|(
name|srb_sg_address
operator|>
literal|0xffffffffull
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
condition|)
endif|#
directive|endif
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|user_reply
operator|=
operator|(
name|char
operator|*
operator|)
name|arg
operator|+
name|fibsize
expr_stmt|;
name|srbcmd
operator|->
name|data_len
operator|=
name|srb_sg_bytecount
expr_stmt|;
if|if
condition|(
name|srbcmd
operator|->
name|sg_map
operator|.
name|SgCount
operator|==
literal|1
condition|)
name|transfer_data
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|transfer_data
condition|)
block|{
comment|/* 		 * Create DMA tag for the passthr. data buffer and allocate it. 		 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
condition|?
name|BUS_SPACE_MAXADDR_32BIT
else|:
literal|0x7fffffff
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|srb_sg_bytecount
argument_list|,
comment|/* size */
name|sc
operator|->
name|aac_sg_tablesize
argument_list|,
comment|/* nsegments */
name|srb_sg_bytecount
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* No locking needed */
operator|&
name|cm
operator|->
name|cm_passthr_dmat
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|cm
operator|->
name|cm_passthr_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_data
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|cm
operator|->
name|cm_datamap
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* fill some cm variables */
name|cm
operator|->
name|cm_datalen
operator|=
name|srb_sg_bytecount
expr_stmt|;
if|if
condition|(
name|srbcmd
operator|->
name|flags
operator|&
name|AAC_SRB_FLAGS_DATA_IN
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAIN
expr_stmt|;
if|if
condition|(
name|srbcmd
operator|->
name|flags
operator|&
name|AAC_SRB_FLAGS_DATA_OUT
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAOUT
expr_stmt|;
if|if
condition|(
name|srbcmd
operator|->
name|flags
operator|&
name|AAC_SRB_FLAGS_DATA_OUT
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|srb_sg_address
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_datalen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* sync required for bus_dmamem_alloc() alloc. mem.? */
name|bus_dmamap_sync
argument_list|(
name|cm
operator|->
name|cm_passthr_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* build the FIB */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_srb
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
operator||
name|AAC_FIBSTATE_ASYNC
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
condition|?
name|ScsiPortCommandU64
else|:
name|ScsiPortCommand
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|(
expr|struct
name|aac_sg_table
operator|*
operator|)
operator|&
name|srbcmd
operator|->
name|sg_map
expr_stmt|;
comment|/* send command */
if|if
condition|(
name|transfer_data
condition|)
block|{
name|bus_dmamap_load
argument_list|(
name|cm
operator|->
name|cm_passthr_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_datalen
argument_list|,
name|aacraid_map_command_sg
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aacraid_map_command_sg
argument_list|(
name|cm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* wait for completion */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_COMPLETED
operator|)
condition|)
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
literal|0
argument_list|,
literal|"aacraid_ctlsrw2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* copy data */
if|if
condition|(
name|transfer_data
operator|&&
operator|(
name|srbcmd
operator|->
name|flags
operator|&
name|AAC_SRB_FLAGS_DATA_IN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|srb_sg_address
argument_list|,
name|cm
operator|->
name|cm_datalen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* sync required for bus_dmamem_alloc() allocated mem.? */
name|bus_dmamap_sync
argument_list|(
name|cm
operator|->
name|cm_passthr_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
comment|/* status */
name|error
operator|=
name|copyout
argument_list|(
name|fib
operator|->
name|data
argument_list|,
name|user_reply
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_srb_response
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cm
operator|&&
name|cm
operator|->
name|cm_data
condition|)
block|{
if|if
condition|(
name|transfer_data
condition|)
name|bus_dmamap_unload
argument_list|(
name|cm
operator|->
name|cm_passthr_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|cm
operator|->
name|cm_passthr_dmat
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_datamap
operator|=
name|orig_map
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|&&
name|cm
operator|->
name|cm_passthr_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|cm
operator|->
name|cm_passthr_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aacraid_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Request an AIF from the controller (new comm. type1)  */
end_comment

begin_function
specifier|static
name|void
name|aac_request_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|aacraid_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|sc
operator|->
name|aif_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|aif_pending
operator|=
literal|0
expr_stmt|;
comment|/* build the FIB */
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
operator||
name|AAC_FIBSTATE_ASYNC
expr_stmt|;
comment|/* set AIF marker */
name|fib
operator|->
name|Header
operator|.
name|Handle
operator|=
literal|0x00800000
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|AifRequest
expr_stmt|;
operator|(
operator|(
expr|struct
name|aac_aif_command
operator|*
operator|)
name|fib
operator|->
name|data
operator|)
operator|->
name|command
operator|=
name|AifReqEvent
expr_stmt|;
name|aacraid_map_command_sg
argument_list|(
name|cm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|702000
end_if

begin_comment
comment|/*  * cdevpriv interface private destructor.  */
end_comment

begin_function
specifier|static
name|void
name|aac_cdevpriv_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_unbusy
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|aac_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle an AIF sent to us by the controller; queue it for later reference.  * If the queue fills up, then drop the older entries.  */
end_comment

begin_function
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
block|{
name|struct
name|aac_aif_command
modifier|*
name|aif
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|,
modifier|*
name|co_next
decl_stmt|;
name|struct
name|aac_fib_context
modifier|*
name|ctx
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|sync_fib
decl_stmt|;
name|struct
name|aac_mntinforesp
name|mir
decl_stmt|;
name|int
name|next
decl_stmt|,
name|current
decl_stmt|,
name|found
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|changed
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|channel
decl_stmt|,
name|uid
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|aif
operator|=
operator|(
expr|struct
name|aac_aif_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|aacraid_print_aif
argument_list|(
name|sc
argument_list|,
name|aif
argument_list|)
expr_stmt|;
comment|/* Is it an event that we should care about? */
switch|switch
condition|(
name|aif
operator|->
name|command
condition|)
block|{
case|case
name|AifCmdEventNotify
case|:
switch|switch
condition|(
name|aif
operator|->
name|data
operator|.
name|EN
operator|.
name|type
condition|)
block|{
case|case
name|AifEnAddContainer
case|:
case|case
name|AifEnDeleteContainer
case|:
comment|/* 			 * A container was added or deleted, but the message 			 * doesn't tell us anything else!  Re-enumerate the 			 * containers and sort things out. 			 */
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|sync_fib
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 				 * Ask the controller for its containers one at 				 * a time. 				 * XXX What if the controller's list changes 				 * midway through this enumaration? 				 * XXX This should be done async. 				 */
if|if
condition|(
name|aac_get_container_info
argument_list|(
name|sc
argument_list|,
name|sync_fib
argument_list|,
name|i
argument_list|,
operator|&
name|mir
argument_list|,
operator|&
name|uid
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|count
operator|=
name|mir
operator|.
name|MntRespCount
expr_stmt|;
comment|/* 				 * Check the container against our list. 				 * co->co_found was already set to 0 in a 				 * previous run. 				 */
if|if
condition|(
operator|(
name|mir
operator|.
name|Status
operator|==
name|ST_OK
operator|)
operator|&&
operator|(
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|)
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|co
argument_list|,
argument|&sc->aac_container_tqh
argument_list|,
argument|co_link
argument_list|)
block|{
if|if
condition|(
name|co
operator|->
name|co_mntobj
operator|.
name|ObjectId
operator|==
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjectId
condition|)
block|{
name|co
operator|->
name|co_found
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 					 * If the container matched, continue 					 * in the list. 					 */
if|if
condition|(
name|found
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 					 * This is a new container.  Do all the 					 * appropriate things to set it up. 					 */
name|aac_add_container
argument_list|(
name|sc
argument_list|,
operator|&
name|mir
argument_list|,
literal|1
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|count
operator|)
operator|&&
operator|(
name|i
operator|<
name|AAC_MAX_CONTAINERS
operator|)
condition|)
do|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Go through our list of containers and see which ones 			 * were not marked 'found'.  Since the controller didn't 			 * list them they must have been deleted.  Do the 			 * appropriate steps to destroy the device.  Also reset 			 * the co->co_found field. 			 */
name|co
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
expr_stmt|;
while|while
condition|(
name|co
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|co
operator|->
name|co_found
operator|==
literal|0
condition|)
block|{
name|co_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|co
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|co
operator|=
name|co_next
expr_stmt|;
block|}
else|else
block|{
name|co
operator|->
name|co_found
operator|=
literal|0
expr_stmt|;
name|co
operator|=
name|TAILQ_NEXT
argument_list|(
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Attach the newly created containers */
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|cam_rescan_cb
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|cam_rescan_cb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|AAC_CAM_TARGET_WILDCARD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AifEnEnclosureManagement
case|:
switch|switch
condition|(
name|aif
operator|->
name|data
operator|.
name|EN
operator|.
name|data
operator|.
name|EEE
operator|.
name|eventType
condition|)
block|{
case|case
name|AIF_EM_DRIVE_INSERTION
case|:
case|case
name|AIF_EM_DRIVE_REMOVAL
case|:
name|channel
operator|=
name|aif
operator|->
name|data
operator|.
name|EN
operator|.
name|data
operator|.
name|EEE
operator|.
name|unitID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cam_rescan_cb
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|cam_rescan_cb
argument_list|(
name|sc
argument_list|,
operator|(
operator|(
name|channel
operator|>>
literal|24
operator|)
operator|&
literal|0xF
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|channel
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|AifEnAddJBOD
case|:
case|case
name|AifEnDeleteJBOD
case|:
case|case
name|AifRawDeviceRemove
case|:
name|channel
operator|=
name|aif
operator|->
name|data
operator|.
name|EN
operator|.
name|data
operator|.
name|ECE
operator|.
name|container
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cam_rescan_cb
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|cam_rescan_cb
argument_list|(
name|sc
argument_list|,
operator|(
operator|(
name|channel
operator|>>
literal|24
operator|)
operator|&
literal|0xF
operator|)
operator|+
literal|1
argument_list|,
name|AAC_CAM_TARGET_WILDCARD
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Copy the AIF data to the AIF queue for ioctl retrieval */
name|current
operator|=
name|sc
operator|->
name|aifq_idx
expr_stmt|;
name|next
operator|=
operator|(
name|current
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
name|sc
operator|->
name|aifq_filled
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|fib
argument_list|,
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|current
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
comment|/* modify AIF contexts */
if|if
condition|(
name|sc
operator|->
name|aifq_filled
condition|)
block|{
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|next
operator|==
name|ctx
operator|->
name|ctx_idx
condition|)
name|ctx
operator|->
name|ctx_wrap
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|current
operator|==
name|ctx
operator|->
name|ctx_idx
operator|&&
name|ctx
operator|->
name|ctx_wrap
condition|)
name|ctx
operator|->
name|ctx_idx
operator|=
name|next
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|aifq_idx
operator|=
name|next
expr_stmt|;
comment|/* On the off chance that someone is sleeping for an aif... */
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_AIF_SLEEPER
condition|)
name|wakeup
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|)
expr_stmt|;
comment|/* Wakeup any poll()ers */
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|rcv_select
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Return the Revision of the driver to userspace and check to see if the  * userspace app is possibly compatible.  This is extremely bogus since  * our driver doesn't follow Adaptec's versioning system.  Cheat by just  * returning what the card reported.  */
end_comment

begin_function
specifier|static
name|int
name|aac_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
block|{
name|struct
name|aac_rev_check
name|rev_check
decl_stmt|;
name|struct
name|aac_rev_check_resp
name|rev_check_resp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Copyin the revision struct from userspace 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|udata
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_IOCTL_COMMANDS_B
argument_list|,
literal|"Userland revision= %d\n"
argument_list|,
name|rev_check
operator|.
name|callingRevision
operator|.
name|buildNumber
argument_list|)
expr_stmt|;
comment|/* 	 * Doctor up the response struct. 	 */
name|rev_check_resp
operator|.
name|possiblyCompatible
operator|=
literal|1
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|major
operator|=
name|AAC_DRIVER_MAJOR_VERSION
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|minor
operator|=
name|AAC_DRIVER_MINOR_VERSION
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|type
operator|=
name|AAC_DRIVER_TYPE
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|dash
operator|=
name|AAC_DRIVER_BUGFIX_LEVEL
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|buildNumber
operator|=
name|AAC_DRIVER_BUILD
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check_resp
argument_list|,
name|udata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check_resp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass the fib context to the caller  */
end_comment

begin_function
specifier|static
name|int
name|aac_open_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|aac_fib_context
modifier|*
name|fibctx
decl_stmt|,
modifier|*
name|ctx
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fibctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_context
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fibctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* all elements are already 0, add to queue */
if|if
condition|(
name|sc
operator|->
name|fibctx
operator|==
name|NULL
condition|)
name|sc
operator|->
name|fibctx
operator|=
name|fibctx
expr_stmt|;
else|else
block|{
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
operator|->
name|next
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
empty_stmt|;
name|ctx
operator|->
name|next
operator|=
name|fibctx
expr_stmt|;
name|fibctx
operator|->
name|prev
operator|=
name|ctx
expr_stmt|;
block|}
comment|/* evaluate unique value */
name|fibctx
operator|->
name|unique
operator|=
operator|(
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|fibctx
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|ctx
operator|=
name|sc
operator|->
name|fibctx
expr_stmt|;
while|while
condition|(
name|ctx
operator|!=
name|fibctx
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|unique
operator|==
name|fibctx
operator|->
name|unique
condition|)
block|{
name|fibctx
operator|->
name|unique
operator|++
expr_stmt|;
name|ctx
operator|=
name|sc
operator|->
name|fibctx
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|=
name|ctx
operator|->
name|next
expr_stmt|;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|fibctx
operator|->
name|unique
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|aac_close_aif
argument_list|(
name|sc
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Close the caller's fib context  */
end_comment

begin_function
specifier|static
name|int
name|aac_close_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|aac_fib_context
modifier|*
name|ctx
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|unique
operator|==
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|arg
condition|)
block|{
if|if
condition|(
name|ctx
operator|==
name|sc
operator|->
name|fibctx
condition|)
name|sc
operator|->
name|fibctx
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|ctx
operator|->
name|prev
operator|->
name|next
operator|=
name|ctx
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|next
condition|)
name|ctx
operator|->
name|next
operator|->
name|prev
operator|=
name|ctx
operator|->
name|prev
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|ctx
condition|)
name|free
argument_list|(
name|ctx
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Pass the caller the next AIF in their queue  */
end_comment

begin_function
specifier|static
name|int
name|aac_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|get_adapter_fib_ioctl
name|agf
decl_stmt|;
name|struct
name|aac_fib_context
modifier|*
name|ctx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|agf
argument_list|,
sizeof|sizeof
argument_list|(
name|agf
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|agf
operator|.
name|AdapterFibContext
operator|==
name|ctx
operator|->
name|unique
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|error
operator|=
name|aac_return_aif
argument_list|(
name|sc
argument_list|,
name|ctx
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
operator|&&
name|agf
operator|.
name|Wait
condition|)
block|{
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_AIF_B
argument_list|,
literal|"aac_getnext_aif(): waiting for AIF"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
while|while
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aacaif"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|aac_return_aif
argument_list|(
name|sc
argument_list|,
name|ctx
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hand the next AIF off the top of the queue out to userspace.  */
end_comment

begin_function
specifier|static
name|int
name|aac_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib_context
modifier|*
name|ctx
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|int
name|current
decl_stmt|,
name|error
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|current
operator|=
name|ctx
operator|->
name|ctx_idx
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|sc
operator|->
name|aifq_idx
operator|&&
operator|!
name|ctx
operator|->
name|ctx_wrap
condition|)
block|{
comment|/* empty */
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|current
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_return_aif: copyout returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
block|{
name|ctx
operator|->
name|ctx_wrap
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|ctx_idx
operator|=
operator|(
name|current
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_get_pci_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
struct|struct
name|aac_pci_info
block|{
name|u_int32_t
name|bus
decl_stmt|;
name|u_int32_t
name|slot
decl_stmt|;
block|}
name|pciinf
struct|;
name|int
name|error
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pciinf
operator|.
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|pciinf
operator|.
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pciinf
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_pci_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_supported_features
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|struct
name|aac_features
name|f
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uptr
argument_list|,
operator|&
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|f
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * When the management driver receives FSACTL_GET_FEATURES ioctl with 	 * ALL zero in the featuresState, the driver will return the current 	 * state of all the supported features, the data field will not be 	 * valid. 	 * When the management driver receives FSACTL_GET_FEATURES ioctl with 	 * a specific bit set in the featuresState, the driver will return the 	 * current state of this specific feature and whatever data that are 	 * associated with the feature in the data field or perform whatever 	 * action needed indicates in the data field. 	 */
if|if
condition|(
name|f
operator|.
name|feat
operator|.
name|fValue
operator|==
literal|0
condition|)
block|{
name|f
operator|.
name|feat
operator|.
name|fBits
operator|.
name|largeLBA
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_LBA_64BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|f
operator|.
name|feat
operator|.
name|fBits
operator|.
name|JBODSupport
operator|=
literal|1
expr_stmt|;
comment|/* TODO: In the future, add other features state here as well */
block|}
else|else
block|{
if|if
condition|(
name|f
operator|.
name|feat
operator|.
name|fBits
operator|.
name|largeLBA
condition|)
name|f
operator|.
name|feat
operator|.
name|fBits
operator|.
name|largeLBA
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_LBA_64BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* TODO: Add other features state and data in the future */
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|f
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give the userland some information about the container.  The AAC arch  * expects the driver to be a SCSI passthrough type driver, so it expects  * the containers to have b:t:l numbers.  Fake it.  */
end_comment

begin_function
specifier|static
name|int
name|aac_query_disk
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|struct
name|aac_query_disk
name|query_disk
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|int
name|error
decl_stmt|,
name|id
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uptr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|query_disk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_query_disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|id
operator|=
name|query_disk
operator|.
name|ContainerNumber
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|co
argument_list|,
argument|&sc->aac_container_tqh
argument_list|,
argument|co_link
argument_list|)
block|{
if|if
condition|(
name|co
operator|->
name|co_mntobj
operator|.
name|ObjectId
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|co
operator|==
name|NULL
condition|)
block|{
name|query_disk
operator|.
name|Valid
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Locked
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Deleted
operator|=
literal|1
expr_stmt|;
comment|/* XXX is this right? */
block|}
else|else
block|{
name|query_disk
operator|.
name|Valid
operator|=
literal|1
expr_stmt|;
name|query_disk
operator|.
name|Locked
operator|=
literal|1
expr_stmt|;
name|query_disk
operator|.
name|Deleted
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Bus
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|query_disk
operator|.
name|Target
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Lun
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|UnMapped
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|query_disk
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_query_disk
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_container_bus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_sim
modifier|*
name|sim
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|aac_sim
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sim
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"No memory to add container bus\n"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
block|}
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aacraidp"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"device_add_child failed for container bus\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sim
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
block|}
name|sim
operator|->
name|TargetsPerBus
operator|=
name|AAC_MAX_CONTAINERS
expr_stmt|;
name|sim
operator|->
name|BusNumber
operator|=
literal|0
expr_stmt|;
name|sim
operator|->
name|BusType
operator|=
name|CONTAINER_BUS
expr_stmt|;
name|sim
operator|->
name|InitiatorBusId
operator|=
operator|-
literal|1
expr_stmt|;
name|sim
operator|->
name|aac_sc
operator|=
name|sc
expr_stmt|;
name|sim
operator|->
name|sim_dev
operator|=
name|child
expr_stmt|;
name|sim
operator|->
name|aac_cam
operator|=
name|NULL
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|sim
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"Container Bus"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|,
name|sim
argument_list|,
name|sim_link
argument_list|)
expr_stmt|;
comment|/* 	device_set_desc(child, aac_describe_code(aac_container_types, 			mir->MntTable[0].VolType)); 	*/
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_get_bus_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_ctcfg
modifier|*
name|c_cmd
decl_stmt|;
name|struct
name|aac_ctcfg_resp
modifier|*
name|c_resp
decl_stmt|;
name|struct
name|aac_vmioctl
modifier|*
name|vmi
decl_stmt|;
name|struct
name|aac_vmi_businf_resp
modifier|*
name|vmi_resp
decl_stmt|;
name|struct
name|aac_getbusinf
name|businfo
decl_stmt|;
name|struct
name|aac_sim
modifier|*
name|caminf
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|c_cmd
operator|=
operator|(
expr|struct
name|aac_ctcfg
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|c_cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_ctcfg
argument_list|)
argument_list|)
expr_stmt|;
name|c_cmd
operator|->
name|Command
operator|=
name|VM_ContainerConfig
expr_stmt|;
name|c_cmd
operator|->
name|cmd
operator|=
name|CT_GET_SCSI_METHOD
expr_stmt|;
name|c_cmd
operator|->
name|param
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_ctcfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error %d sending "
literal|"VM_ContainerConfig command\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|c_resp
operator|=
operator|(
expr|struct
name|aac_ctcfg_resp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c_resp
operator|->
name|Status
operator|!=
name|ST_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"VM_ContainerConfig returned 0x%x\n"
argument_list|,
name|c_resp
operator|->
name|Status
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|scsi_method_id
operator|=
name|c_resp
operator|->
name|param
expr_stmt|;
name|vmi
operator|=
operator|(
expr|struct
name|aac_vmioctl
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|vmi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_vmioctl
argument_list|)
argument_list|)
expr_stmt|;
name|vmi
operator|->
name|Command
operator|=
name|VM_Ioctl
expr_stmt|;
name|vmi
operator|->
name|ObjType
operator|=
name|FT_DRIVE
expr_stmt|;
name|vmi
operator|->
name|MethId
operator|=
name|sc
operator|->
name|scsi_method_id
expr_stmt|;
name|vmi
operator|->
name|ObjId
operator|=
literal|0
expr_stmt|;
name|vmi
operator|->
name|IoctlCmd
operator|=
name|GetBusInfo
expr_stmt|;
name|error
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_vmi_businf_resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error %d sending VMIoctl command\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|vmi_resp
operator|=
operator|(
expr|struct
name|aac_vmi_businf_resp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vmi_resp
operator|->
name|Status
operator|!=
name|ST_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"VM_Ioctl returned %d\n"
argument_list|,
name|vmi_resp
operator|->
name|Status
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
operator|&
name|vmi_resp
operator|->
name|BusInf
argument_list|,
operator|&
name|businfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_getbusinf
argument_list|)
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|businfo
operator|.
name|BusCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|businfo
operator|.
name|BusValid
index|[
name|i
index|]
operator|!=
name|AAC_BUS_VALID
condition|)
continue|continue;
name|caminf
operator|=
operator|(
expr|struct
name|aac_sim
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sim
argument_list|)
argument_list|,
name|M_AACRAIDBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|caminf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"No memory to add passthrough bus %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aacraidp"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"device_add_child failed for passthrough bus %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|caminf
argument_list|,
name|M_AACRAIDBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|caminf
operator|->
name|TargetsPerBus
operator|=
name|businfo
operator|.
name|TargetsPerBus
expr_stmt|;
name|caminf
operator|->
name|BusNumber
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|caminf
operator|->
name|BusType
operator|=
name|PASSTHROUGH_BUS
expr_stmt|;
name|caminf
operator|->
name|InitiatorBusId
operator|=
name|businfo
operator|.
name|InitiatorBusId
index|[
name|i
index|]
expr_stmt|;
name|caminf
operator|->
name|aac_sc
operator|=
name|sc
expr_stmt|;
name|caminf
operator|->
name|sim_dev
operator|=
name|child
expr_stmt|;
name|caminf
operator|->
name|aac_cam
operator|=
name|NULL
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|caminf
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"SCSI Passthrough Bus"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|,
name|caminf
argument_list|,
name|sim_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if the kernel is up and running. If we are in a  * BlinkLED state, return the BlinkLED code.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|aac_check_adapter_health
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|bled
parameter_list|)
block|{
name|u_int32_t
name|ret
decl_stmt|;
name|ret
operator|=
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|AAC_UP_AND_RUNNING
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|&
name|AAC_KERNEL_PANIC
operator|&&
name|bled
condition|)
operator|*
name|bled
operator|=
operator|(
name|ret
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Once do an IOP reset, basically have to re-initialize the card as  * if coming up from a cold boot, and the driver is responsible for  * any IO that was outstanding to the adapter at the time of the IOP  * RESET. And prepare the driver for IOP RESET by making the init code  * modular with the ability to call it from multiple places.  */
end_comment

begin_function
specifier|static
name|int
name|aac_reset_adapter
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_pause_command
modifier|*
name|pc
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|,
name|reset_mask
decl_stmt|,
name|waitCount
decl_stmt|,
name|max_msix_orig
decl_stmt|;
name|int
name|msi_enabled_orig
decl_stmt|;
name|fwprintf
argument_list|(
name|sc
argument_list|,
name|HBA_FLAGS_DBG_FUNCTION_ENTRY_B
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_RESET
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_reset_adapter() already in progress\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_RESET
expr_stmt|;
comment|/* disable interrupt */
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_DISABLE_INTERRUPT
argument_list|)
expr_stmt|;
comment|/* 	 * Abort all pending commands: 	 * a) on the controller 	 */
while|while
condition|(
operator|(
name|cm
operator|=
name|aac_dequeue_busy
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_RESET
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this 			 * command 			 */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* b) in the waiting queues */
while|while
condition|(
operator|(
name|cm
operator|=
name|aac_dequeue_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_RESET
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this 			 * command 			 */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* flush drives */
if|if
condition|(
name|aac_check_adapter_health
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|aacraid_shutdown
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
comment|/* execute IOP reset */
if|if
condition|(
name|sc
operator|->
name|aac_support_opt2
operator|&
name|AAC_SUPPORTED_MU_RESET
condition|)
block|{
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_IRCSR
argument_list|,
name|AAC_IRCSR_CORES_RST
argument_list|)
expr_stmt|;
comment|/* We need to wait for 5 seconds before accessing the MU again 		 * 10000 * 100us = 1000,000us = 1000ms = 1s   		 */
name|waitCount
operator|=
literal|5
operator|*
literal|10000
expr_stmt|;
while|while
condition|(
name|waitCount
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* delay 100 microseconds */
name|waitCount
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_IOP_RESET_ALWAYS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|reset_mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* call IOP_RESET for older firmware */
if|if
condition|(
operator|(
name|aacraid_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_IOP_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|AAC_SRB_STS_INVALID_REQUEST
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"IOP_RESET not supported\n"
argument_list|)
expr_stmt|;
else|else
comment|/* probably timeout */
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"IOP_RESET failed\n"
argument_list|)
expr_stmt|;
comment|/* unwind aac_shutdown() */
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|aac_pause_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|pc
operator|->
name|Command
operator|=
name|VM_ContainerConfig
expr_stmt|;
name|pc
operator|->
name|Type
operator|=
name|CT_PAUSE_IO
expr_stmt|;
name|pc
operator|->
name|Timeout
operator|=
literal|1
expr_stmt|;
name|pc
operator|->
name|Min
operator|=
literal|1
expr_stmt|;
name|pc
operator|->
name|NoRescan
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_pause_command
argument_list|)
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|aac_support_opt2
operator|&
name|AAC_SUPPORTED_DOORBELL_RESET
condition|)
block|{
name|AAC_MEM0_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SRC_IDBR
argument_list|,
name|reset_mask
argument_list|)
expr_stmt|;
comment|/*  		 * We need to wait for 5 seconds before accessing the doorbell 		 * again, 10000 * 100us = 1000,000us = 1000ms = 1s   		 */
name|waitCount
operator|=
literal|5
operator|*
literal|10000
expr_stmt|;
while|while
condition|(
name|waitCount
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* delay 100 microseconds */
name|waitCount
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Initialize the adapter. 	 */
name|max_msix_orig
operator|=
name|sc
operator|->
name|aac_max_msix
expr_stmt|;
name|msi_enabled_orig
operator|=
name|sc
operator|->
name|msi_enabled
expr_stmt|;
name|sc
operator|->
name|msi_enabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|aac_check_firmware
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|finish
goto|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SYNC_MODE
operator|)
condition|)
block|{
name|sc
operator|->
name|aac_max_msix
operator|=
name|max_msix_orig
expr_stmt|;
if|if
condition|(
name|msi_enabled_orig
condition|)
block|{
name|sc
operator|->
name|msi_enabled
operator|=
name|msi_enabled_orig
expr_stmt|;
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_ENABLE_MSIX
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_RESET
expr_stmt|;
name|AAC_ACCESS_DEVREG
argument_list|(
name|sc
argument_list|,
name|AAC_ENABLE_INTERRUPT
argument_list|)
expr_stmt|;
name|aacraid_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

