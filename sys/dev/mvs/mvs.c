begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"mvs.h"
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_comment
comment|/* local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|mvs_ch_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mvs_ch_deinit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mvs_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mvs_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_setup_edma_queues
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_set_edma_mode
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|enum
name|mvs_edma_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_ch_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_ch_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_softreset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mvs_sata_connect
parameter_list|(
name|struct
name|mvs_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mvs_sata_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mvs_wait
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|c
parameter_list|,
name|int
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_tfd_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_tfd_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_legacy_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|poll
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_crbq_intr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_begin_transaction
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_legacy_execute_transaction
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_timeout
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_requeue_frozen
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_execute_transaction
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_end_transaction
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|mvs_err_type
name|et
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_issue_recovery
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_process_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvs_process_request_sense
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvsaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mvspoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MVS
argument_list|,
literal|"MVS driver"
argument_list|,
literal|"MVS driver data buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|recovery_type
value|spriv_field0
end_define

begin_define
define|#
directive|define
name|RECOVERY_NONE
value|0
end_define

begin_define
define|#
directive|define
name|RECOVERY_READ_LOG
value|1
end_define

begin_define
define|#
directive|define
name|RECOVERY_REQUEST_SENSE
value|2
end_define

begin_define
define|#
directive|define
name|recovery_slot
value|spriv_field1
end_define

begin_function
specifier|static
name|int
name|mvs_ch_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"Marvell SATA channel"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_ch_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|sata_rev
init|=
literal|0
decl_stmt|;
name|ch
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ch
operator|->
name|unit
operator|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|->
name|quirks
operator|=
name|ctlr
operator|->
name|quirks
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|"MVS channel lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"pm_level"
argument_list|,
operator|&
name|ch
operator|->
name|pm_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_init_mtx
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"sata_rev"
argument_list|,
operator|&
name|sata_rev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|revision
operator|=
name|sata_rev
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|bytecount
operator|=
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
operator|)
condition|?
literal|8192
else|:
literal|2048
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|tags
operator|=
name|MVS_MAX_SLOTS
expr_stmt|;
name|ch
operator|->
name|curr
index|[
name|i
index|]
operator|=
name|ch
operator|->
name|user
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
condition|)
block|{
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|caps
operator|=
name|CTS_SATA_CAPS_H_PMREQ
operator||
name|CTS_SATA_CAPS_H_APST
operator||
name|CTS_SATA_CAPS_D_PMREQ
operator||
name|CTS_SATA_CAPS_D_APST
expr_stmt|;
block|}
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|caps
operator||=
name|CTS_SATA_CAPS_H_AN
expr_stmt|;
block|}
name|rid
operator|=
name|ch
operator|->
name|unit
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mvs_dmainit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mvs_slotsalloc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mvs_ch_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|rid
operator|=
name|ATA_IRQ_RID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ATA_INTR_FLAGS
argument_list|,
name|NULL
argument_list|,
name|mvs_ch_intr_locked
argument_list|,
name|dev
argument_list|,
operator|&
name|ch
operator|->
name|ih
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to setup interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Create the device queue for our SIM. */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|MVS_MAX_SLOTS
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate simq\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Construct SIM entry */
name|ch
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|mvsaction
argument_list|,
name|mvspoll
argument_list|,
literal|"mvsch"
argument_list|,
name|ch
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|2
argument_list|,
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENI
operator|)
condition|?
literal|0
else|:
name|MVS_MAX_SLOTS
operator|-
literal|1
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate sim\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to register xpt bus\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ch
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create path\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err3
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|,
name|mvs_ch_pm
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err3
label|:
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|err2
label|:
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|err1
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|err0
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_ch_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Forget about reset. */
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
block|{
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|ch
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_drain
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ch
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|mvs_ch_deinit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mvs_slotsfree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mvs_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_ch_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop EDMA */
name|ch
operator|->
name|curr_mode
operator|=
name|MVS_EDMA_UNKNOWN
expr_stmt|;
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_OFF
argument_list|)
expr_stmt|;
comment|/* Clear and configure FIS interrupts. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISC
argument_list|)
expr_stmt|;
name|reg
operator||=
name|SATA_FISC_FISWAIT4HOSTRDYEN_B1
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISIM
argument_list|)
expr_stmt|;
name|reg
operator||=
name|SATA_FISC_FISWAIT4HOSTRDYEN_B1
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Clear SATA error register. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Clear any outstanding error interrupts. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unmask all error interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEM
argument_list|,
operator|~
name|EDMA_IE_TRANSIENT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_ch_deinit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Stop EDMA */
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_OFF
argument_list|)
expr_stmt|;
comment|/* Disable port interrupts. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|->
name|oslots
condition|)
name|msleep
argument_list|(
name|ch
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"mvssusp"
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* Forget about reset. */
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
block|{
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|mvs_ch_deinit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mvs_ch_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mvs_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|mvs_dc_cb_args
block|{
name|bus_addr_t
name|maddr
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|mvs_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mvs_dc_cb_args
name|dcba
decl_stmt|;
comment|/* EDMA command request area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1024
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MVS_WORKRQ_SIZE
argument_list|,
literal|1
argument_list|,
name|MVS_WORKRQ_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|workrq
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq
argument_list|,
name|MVS_WORKRQ_SIZE
argument_list|,
name|mvs_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|workrq_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* EDMA command response area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|256
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MVS_WORKRP_SIZE
argument_list|,
literal|1
argument_list|,
name|MVS_WORKRP_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|workrp
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp
argument_list|,
name|MVS_WORKRP_SIZE
argument_list|,
name|mvs_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|workrp_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* Data area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|2
argument_list|,
name|MVS_EPRD_MAX
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MVS_SG_ENTRIES
operator|*
name|PAGE_SIZE
operator|*
name|MVS_MAX_SLOTS
argument_list|,
name|MVS_SG_ENTRIES
argument_list|,
name|MVS_EPRD_MAX
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return;
name|error
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING - DMA initialization failed\n"
argument_list|)
expr_stmt|;
name|mvs_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mvs_dc_cb_args
modifier|*
name|dcba
init|=
operator|(
expr|struct
name|mvs_dc_cb_args
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dcba
operator|->
name|error
operator|=
name|error
operator|)
condition|)
name|dcba
operator|->
name|maddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|data_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|workrp_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrp_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrp_map
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|workrq_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrq_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrq_map
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Alloc and setup command/dma slots */
name|bzero
argument_list|(
name|ch
operator|->
name|slot
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|slot
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mvs_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|slot
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|slot
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|MVS_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"FAILURE - create data_map\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Free all dma slots */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mvs_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|dma
operator|.
name|data_map
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
name|slot
operator|->
name|dma
operator|.
name|data_map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_setup_edma_queues
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint64_t
name|work
decl_stmt|;
comment|/* Requests queue. */
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|workrq_bus
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_REQQBAH
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_REQQIP
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_REQQOP
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Reponses queue. */
name|memset
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp
argument_list|,
literal|0xff
argument_list|,
name|MVS_WORKRP_SIZE
argument_list|)
expr_stmt|;
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|workrp_bus
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_RESQBAH
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_RESQIP
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_RESQOP
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ch
operator|->
name|out_idx
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|in_idx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_set_edma_mode
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|enum
name|mvs_edma_mode
name|mode
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|uint32_t
name|ecfg
decl_stmt|,
name|fcfg
decl_stmt|,
name|hc
decl_stmt|,
name|ltm
decl_stmt|,
name|unkn
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|ch
operator|->
name|curr_mode
condition|)
return|return;
comment|/* If we are running, we should stop first. */
if|if
condition|(
name|ch
operator|->
name|curr_mode
operator|!=
name|MVS_EDMA_OFF
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_CMD
argument_list|,
name|EDMA_CMD_EDSEDMA
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_CMD
argument_list|)
operator|&
name|EDMA_CMD_EENEDMA
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping EDMA engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
empty_stmt|;
block|}
name|ch
operator|->
name|curr_mode
operator|=
name|mode
expr_stmt|;
name|ch
operator|->
name|fbs_enabled
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|fake_busy
operator|=
literal|0
expr_stmt|;
comment|/* Report mode to controller. Needed for correct CCC operation. */
name|MVS_EDMA
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Configure new mode. */
name|ecfg
operator|=
name|EDMA_CFG_RESERVED
operator||
name|EDMA_CFG_RESERVED2
operator||
name|EDMA_CFG_EHOSTQUEUECACHEEN
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_present
condition|)
block|{
name|ecfg
operator||=
name|EDMA_CFG_EMASKRXPM
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
condition|)
block|{
name|ecfg
operator||=
name|EDMA_CFG_EEDMAFBS
expr_stmt|;
name|ch
operator|->
name|fbs_enabled
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENI
condition|)
name|ecfg
operator||=
name|EDMA_CFG_ERDBSZ
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENII
condition|)
name|ecfg
operator||=
name|EDMA_CFG_ERDBSZEXT
operator||
name|EDMA_CFG_EWRBUFFERLEN
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_CT
condition|)
name|ecfg
operator||=
name|EDMA_CFG_ECUTTHROUGHEN
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|MVS_EDMA_OFF
condition|)
name|ecfg
operator||=
name|EDMA_CFG_EEARLYCOMPLETIONEN
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MVS_EDMA_QUEUED
condition|)
name|ecfg
operator||=
name|EDMA_CFG_EQUE
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|MVS_EDMA_NCQ
condition|)
name|ecfg
operator||=
name|EDMA_CFG_ESATANATVCMDQUE
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_CFG
argument_list|,
name|ecfg
argument_list|)
expr_stmt|;
name|mvs_setup_edma_queues
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
condition|)
block|{
comment|/* Configure FBS-related registers */
name|fcfg
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISC
argument_list|)
expr_stmt|;
name|ltm
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_LTM
argument_list|)
expr_stmt|;
name|hc
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_HC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
name|fcfg
operator||=
name|SATA_FISC_FISDMAACTIVATESYNCRESP
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MVS_EDMA_NCQ
condition|)
block|{
name|fcfg
operator|&=
operator|~
name|SATA_FISC_FISWAIT4HOSTRDYEN_B0
expr_stmt|;
name|hc
operator|&=
operator|~
name|EDMA_IE_EDEVERR
expr_stmt|;
block|}
else|else
block|{
name|fcfg
operator||=
name|SATA_FISC_FISWAIT4HOSTRDYEN_B0
expr_stmt|;
name|hc
operator||=
name|EDMA_IE_EDEVERR
expr_stmt|;
block|}
name|ltm
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fcfg
operator|&=
operator|~
name|SATA_FISC_FISDMAACTIVATESYNCRESP
expr_stmt|;
name|fcfg
operator|&=
operator|~
name|SATA_FISC_FISWAIT4HOSTRDYEN_B0
expr_stmt|;
name|hc
operator||=
name|EDMA_IE_EDEVERR
expr_stmt|;
name|ltm
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISC
argument_list|,
name|fcfg
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_LTM
argument_list|,
name|ltm
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_HC
argument_list|,
name|hc
argument_list|)
expr_stmt|;
comment|/* This is some magic, required to handle several DRQs 		 * with basic DMA. */
name|unkn
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_UNKN_RESD
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MVS_EDMA_OFF
condition|)
name|unkn
operator||=
literal|1
expr_stmt|;
else|else
name|unkn
operator|&=
operator|~
literal|1
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_UNKN_RESD
argument_list|,
name|unkn
argument_list|)
expr_stmt|;
block|}
comment|/* Run EDMA. */
if|if
condition|(
name|mode
operator|!=
name|MVS_EDMA_OFF
condition|)
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_CMD
argument_list|,
name|EDMA_CMD_EENEDMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|devclass_t
name|mvs_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|mvsch_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|mvsch_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mvs_ch_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mvs_ch_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mvs_ch_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|mvs_ch_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|mvs_ch_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mvsch_driver
init|=
block|{
literal|"mvsch"
block|,
name|mvsch_methods
block|,
expr|sizeof
operator|(
expr|struct
name|mvs_channel
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mvsch
argument_list|,
name|mvs
argument_list|,
name|mvsch_driver
argument_list|,
name|mvsch_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mvsch
argument_list|,
name|sata
argument_list|,
name|mvsch_driver
argument_list|,
name|mvsch_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|mvs_phy_check_events
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|serr
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|status
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SS
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|SATA_SS_DET_MASK
operator|)
operator|==
name|SATA_SS_DET_PHY_ONLINE
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|SATA_SS_SPD_MASK
operator|)
operator|!=
name|SATA_SS_SPD_NO_SPEED
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|SATA_SS_IPM_MASK
operator|)
operator|==
name|SATA_SS_IPM_ACTIVE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CONNECT requested\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DISCONNECT requested\n"
argument_list|)
expr_stmt|;
block|}
name|mvs_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_notify_events
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|dpath
decl_stmt|;
name|uint32_t
name|fis
decl_stmt|;
name|int
name|d
decl_stmt|;
comment|/* Try to read PMP field from SDB FIS. Present only for Gen-IIe. */
name|fis
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISDW0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fis
operator|&
literal|0x80ff
operator|)
operator|==
literal|0x80a1
condition|)
name|d
operator|=
operator|(
name|fis
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
else|else
name|d
operator|=
name|ch
operator|->
name|pm_present
condition|?
literal|15
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SNTF %d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|dpath
argument_list|,
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ch
operator|->
name|path
argument_list|)
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_SCSI_AEN
argument_list|,
name|dpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|dpath
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_ch_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mvs_intr_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mvs_intr_arg
operator|*
operator|)
name|data
decl_stmt|;
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
operator|->
name|arg
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|xpt_batch_start
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
expr_stmt|;
name|mvs_ch_intr
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|xpt_batch_done
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|work
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return;
comment|/* If we are idle - request power state transition. */
name|work
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SC
argument_list|)
expr_stmt|;
name|work
operator|&=
operator|~
name|SATA_SC_SPM_MASK
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
condition|)
name|work
operator||=
name|SATA_SC_SPM_PARTIAL
expr_stmt|;
else|else
name|work
operator||=
name|SATA_SC_SPM_SLUMBER
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SC
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_ch_pm_wake
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|work
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|work
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SS
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|&
name|SATA_SS_IPM_ACTIVE
condition|)
return|return;
comment|/* If we are not in active state - request power state transition. */
name|work
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SC
argument_list|)
expr_stmt|;
name|work
operator|&=
operator|~
name|SATA_SC_SPM_MASK
expr_stmt|;
name|work
operator||=
name|SATA_SC_SPM_ACTIVE
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SC
argument_list|,
name|work
argument_list|)
expr_stmt|;
comment|/* Wait for transition to happen. */
while|while
condition|(
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SS
argument_list|)
operator|&
name|SATA_SS_IPM_ACTIVE
operator|)
operator|==
literal|0
operator|&&
name|timeout
operator|++
operator|<
literal|100
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_ch_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mvs_intr_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mvs_intr_arg
operator|*
operator|)
name|data
decl_stmt|;
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
operator|->
name|arg
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|iec
decl_stmt|,
name|serr
init|=
literal|0
decl_stmt|,
name|fisic
init|=
literal|0
decl_stmt|;
name|enum
name|mvs_err_type
name|et
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ccs
decl_stmt|,
name|port
init|=
operator|-
literal|1
decl_stmt|,
name|selfdis
init|=
literal|0
decl_stmt|;
name|int
name|edma
init|=
operator|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
operator|||
name|ch
operator|->
name|numdslots
operator|!=
literal|0
operator|)
decl_stmt|;
comment|/* New item in response queue. */
if|if
condition|(
operator|(
name|arg
operator|->
name|cause
operator|&
literal|2
operator|)
operator|&&
name|edma
condition|)
name|mvs_crbq_intr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Some error or special event. */
if|if
condition|(
name|arg
operator|->
name|cause
operator|&
literal|1
condition|)
block|{
name|iec
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|iec
operator|&
name|EDMA_IE_SERRINT
condition|)
block|{
name|serr
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SE
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SE
argument_list|,
name|serr
argument_list|)
expr_stmt|;
block|}
comment|/* EDMA self-disabled due to error. */
if|if
condition|(
name|iec
operator|&
name|EDMA_IE_ESELFDIS
condition|)
name|selfdis
operator|=
literal|1
expr_stmt|;
comment|/* Transport interrupt. */
if|if
condition|(
name|iec
operator|&
name|EDMA_IE_ETRANSINT
condition|)
block|{
comment|/* For Gen-I this bit means self-disable. */
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENI
condition|)
name|selfdis
operator|=
literal|1
expr_stmt|;
comment|/* For Gen-II this bit means SDB-N. */
elseif|else
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENII
condition|)
name|fisic
operator|=
name|SATA_FISC_FISWAIT4HOSTRDYEN_B1
expr_stmt|;
else|else
comment|/* For Gen-IIe - read FIS interrupt cause. */
name|fisic
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISIC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selfdis
condition|)
name|ch
operator|->
name|curr_mode
operator|=
name|MVS_EDMA_UNKNOWN
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEC
argument_list|,
operator|~
name|iec
argument_list|)
expr_stmt|;
comment|/* Interface errors or Device error. */
if|if
condition|(
name|iec
operator|&
operator|(
literal|0xfc1e9000
operator||
name|EDMA_IE_EDEVERR
operator|)
condition|)
block|{
name|port
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|numpslots
operator|!=
literal|0
condition|)
block|{
name|ccs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
condition|)
name|ccs
operator|=
name|EDMA_S_EIOID
argument_list|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_S
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ccs
operator|=
name|EDMA_S_EDEVQUETAG
argument_list|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_S
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if error is one-PMP-port-specific, */
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
comment|/* Which ports were active. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|numrslotspd
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
name|port
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|!=
name|i
condition|)
block|{
name|port
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
block|}
comment|/* If several ports were active and EDMA still enabled -  					 * other ports are probably unaffected and may continue. 					 */
if|if
condition|(
name|port
operator|==
operator|-
literal|2
operator|&&
operator|!
name|selfdis
condition|)
block|{
name|uint16_t
name|p
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SATAITC
argument_list|)
operator|>>
literal|16
decl_stmt|;
name|port
operator|=
name|ffs
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|port
operator|!=
operator|(
name|fls
argument_list|(
name|p
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|port
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
block|}
name|mvs_requeue_frozen
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX: reqests in loading state. */
if|if
condition|(
operator|(
operator|(
name|ch
operator|->
name|rslots
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|port
operator|>=
literal|0
operator|&&
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|port
condition|)
continue|continue;
if|if
condition|(
name|iec
operator|&
name|EDMA_IE_EDEVERR
condition|)
block|{
comment|/* Device error. */
if|if
condition|(
name|port
operator|!=
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|==
literal|0
condition|)
block|{
comment|/* Untagged operation. */
if|if
condition|(
name|i
operator|==
name|ccs
condition|)
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
else|else
name|et
operator|=
name|MVS_ERR_INNOCENT
expr_stmt|;
block|}
else|else
block|{
comment|/* Tagged operation. */
name|et
operator|=
name|MVS_ERR_NCQ
expr_stmt|;
block|}
block|}
else|else
block|{
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|iec
operator|&
literal|0xfc1e9000
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|==
literal|0
operator|&&
name|i
operator|!=
name|ccs
operator|&&
name|port
operator|!=
operator|-
literal|2
condition|)
name|et
operator|=
name|MVS_ERR_INNOCENT
expr_stmt|;
else|else
name|et
operator|=
name|MVS_ERR_SATA
expr_stmt|;
block|}
else|else
name|et
operator|=
name|MVS_ERR_INVALID
expr_stmt|;
name|mvs_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process SDB-N. */
if|if
condition|(
name|fisic
operator|&
name|SATA_FISC_FISWAIT4HOSTRDYEN_B1
condition|)
name|mvs_notify_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fisic
condition|)
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_FISIC
argument_list|,
operator|~
name|fisic
argument_list|)
expr_stmt|;
comment|/* Process hot-plug. */
if|if
condition|(
operator|(
name|iec
operator|&
operator|(
name|EDMA_IE_EDEVDIS
operator||
name|EDMA_IE_EDEVCON
operator|)
operator|)
operator|||
operator|(
name|serr
operator|&
name|SATA_SE_PHY_CHANGED
operator|)
condition|)
name|mvs_phy_check_events
argument_list|(
name|dev
argument_list|,
name|serr
argument_list|)
expr_stmt|;
block|}
comment|/* Legacy mode device interrupt. */
if|if
condition|(
operator|(
name|arg
operator|->
name|cause
operator|&
literal|2
operator|)
operator|&&
operator|!
name|edma
condition|)
name|mvs_legacy_intr
argument_list|(
name|dev
argument_list|,
name|arg
operator|->
name|cause
operator|&
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|mvs_getstatus
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|status
init|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|clear
condition|?
name|ATA_STATUS
else|:
name|ATA_ALTSTAT
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|fake_busy
condition|)
block|{
if|if
condition|(
name|status
operator|&
operator|(
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
operator||
name|ATA_S_ERROR
operator|)
condition|)
name|ch
operator|->
name|fake_busy
operator|=
literal|0
expr_stmt|;
else|else
name|status
operator||=
name|ATA_S_BUSY
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_legacy_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|poll
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mvs_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
literal|0
index|]
decl_stmt|;
comment|/* PIO is always in slot 0. */
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|enum
name|mvs_err_type
name|et
init|=
name|MVS_ERR_NONE
decl_stmt|;
name|int
name|port
decl_stmt|;
name|u_int
name|length
decl_stmt|,
name|resid
decl_stmt|,
name|size
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|status
decl_stmt|,
name|ireason
decl_stmt|;
comment|/* Clear interrupt and get status. */
name|status
operator|=
name|mvs_getstatus
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|MVS_SLOT_RUNNING
condition|)
return|return;
name|port
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
expr_stmt|;
comment|/* Wait a bit for late !BUSY status update. */
if|if
condition|(
name|status
operator|&
name|ATA_S_BUSY
condition|)
block|{
if|if
condition|(
name|poll
condition|)
return|return;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|mvs_getstatus
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
operator|&
name|ATA_S_BUSY
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|mvs_getstatus
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
operator|&
name|ATA_S_BUSY
condition|)
return|return;
block|}
block|}
comment|/* If we got an error, we are done. */
if|if
condition|(
name|status
operator|&
name|ATA_S_ERROR
condition|)
block|{
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
goto|goto
name|end_finished
goto|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
comment|/* ATA PIO */
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|status
operator|=
name|status
expr_stmt|;
comment|/* Are we moving data? */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
comment|/* If data read command - get them. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
if|if
condition|(
name|mvs_wait
argument_list|(
name|dev
argument_list|,
name|ATA_S_DRQ
argument_list|,
name|ATA_S_BUSY
argument_list|,
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"timeout waiting for read DRQ\n"
argument_list|)
expr_stmt|;
name|et
operator|=
name|MVS_ERR_TIMEOUT
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
goto|goto
name|end_finished
goto|;
block|}
name|ATA_INSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|)
argument_list|,
name|ch
operator|->
name|transfersize
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Update how far we've gotten. */
name|ch
operator|->
name|donecount
operator|+=
name|ch
operator|->
name|transfersize
expr_stmt|;
comment|/* Do we need more? */
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
operator|>
name|ch
operator|->
name|donecount
condition|)
block|{
comment|/* Set this transfer size according to HW capabilities */
name|ch
operator|->
name|transfersize
operator|=
name|min
argument_list|(
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
operator|-
name|ch
operator|->
name|donecount
argument_list|,
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|bytecount
argument_list|)
expr_stmt|;
comment|/* If data write command - put them */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
if|if
condition|(
name|mvs_wait
argument_list|(
name|dev
argument_list|,
name|ATA_S_DRQ
argument_list|,
name|ATA_S_BUSY
argument_list|,
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"timeout waiting for write DRQ\n"
argument_list|)
expr_stmt|;
name|et
operator|=
name|MVS_ERR_TIMEOUT
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
goto|goto
name|end_finished
goto|;
block|}
name|ATA_OUTSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|)
argument_list|,
name|ch
operator|->
name|transfersize
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If data read command, return& wait for interrupt */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|basic_dma
condition|)
block|{
comment|/* ATAPI DMA */
if|if
condition|(
name|status
operator|&
name|ATA_S_DWF
condition|)
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
elseif|else
if|if
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_S
argument_list|)
operator|&
name|DMA_S_ERR
condition|)
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
comment|/* Stop basic DMA. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_C
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|end_finished
goto|;
block|}
else|else
block|{
comment|/* ATAPI PIO */
name|length
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_LSB
argument_list|)
operator||
operator|(
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_MSB
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|ch
operator|->
name|transfersize
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ireason
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_IREASON
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ireason
operator|&
operator|(
name|ATA_I_CMD
operator||
name|ATA_I_IN
operator|)
operator|)
operator||
operator|(
name|status
operator|&
name|ATA_S_DRQ
operator|)
condition|)
block|{
case|case
name|ATAPI_P_CMDOUT
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ATAPI CMDOUT\n"
argument_list|)
expr_stmt|;
comment|/* Return wait for interrupt */
return|return;
case|case
name|ATAPI_P_WRITE
case|:
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"trying to write on read buffer\n"
argument_list|)
expr_stmt|;
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
goto|goto
name|end_finished
goto|;
break|break;
block|}
name|ATA_OUTSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|)
argument_list|,
operator|(
name|size
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|resid
operator|=
name|ch
operator|->
name|transfersize
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
init|;
name|resid
operator|<
name|length
condition|;
name|resid
operator|+=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
control|)
name|ATA_OUTW
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|->
name|donecount
operator|+=
name|length
expr_stmt|;
comment|/* Set next transfer size according to HW capabilities */
name|ch
operator|->
name|transfersize
operator|=
name|min
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ch
operator|->
name|donecount
argument_list|,
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|bytecount
argument_list|)
expr_stmt|;
comment|/* Return wait for interrupt */
return|return;
case|case
name|ATAPI_P_READ
case|:
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"trying to read on write buffer\n"
argument_list|)
expr_stmt|;
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
goto|goto
name|end_finished
goto|;
block|}
if|if
condition|(
name|size
operator|>=
literal|2
condition|)
block|{
name|ATA_INSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|)
argument_list|,
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|&
literal|1
condition|)
block|{
name|ATA_INSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|+
operator|(
name|size
operator|&
operator|~
literal|1
operator|)
operator|)
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|resid
operator|=
name|ch
operator|->
name|transfersize
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
init|;
name|resid
operator|<
name|length
condition|;
name|resid
operator|+=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
control|)
name|ATA_INW
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|)
expr_stmt|;
name|ch
operator|->
name|donecount
operator|+=
name|length
expr_stmt|;
comment|/* Set next transfer size according to HW capabilities */
name|ch
operator|->
name|transfersize
operator|=
name|min
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ch
operator|->
name|donecount
argument_list|,
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|bytecount
argument_list|)
expr_stmt|;
comment|/* Return wait for interrupt */
return|return;
case|case
name|ATAPI_P_DONEDRQ
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING - DONEDRQ non conformant device\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|ATA_INSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|)
argument_list|,
name|length
operator|/
literal|2
argument_list|)
expr_stmt|;
name|ch
operator|->
name|donecount
operator|+=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|ATA_OUTSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|)
argument_list|,
name|length
operator|/
literal|2
argument_list|)
expr_stmt|;
name|ch
operator|->
name|donecount
operator|+=
name|length
expr_stmt|;
block|}
else|else
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ATAPI_P_ABORT
case|:
case|case
name|ATAPI_P_DONE
case|:
if|if
condition|(
name|status
operator|&
operator|(
name|ATA_S_ERROR
operator||
name|ATA_S_DWF
operator|)
condition|)
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
goto|goto
name|end_finished
goto|;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown transfer phase"
literal|" (status %02x, ireason %02x)\n"
argument_list|,
name|status
argument_list|,
name|ireason
argument_list|)
expr_stmt|;
name|et
operator|=
name|MVS_ERR_TFE
expr_stmt|;
block|}
block|}
name|end_finished
label|:
name|mvs_end_transaction
argument_list|(
name|slot
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_crbq_intr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mvs_crpb
modifier|*
name|crpb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|in_idx
decl_stmt|,
name|fin_idx
decl_stmt|,
name|cin_idx
decl_stmt|,
name|slot
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_RESQIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_RESQIP
argument_list|)
expr_stmt|;
name|in_idx
operator|=
operator|(
name|val
operator|&
name|EDMA_RESQP_ERPQP_MASK
operator|)
operator|>>
name|EDMA_RESQP_ERPQP_SHIFT
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|fin_idx
operator|=
name|cin_idx
operator|=
name|ch
operator|->
name|in_idx
expr_stmt|;
name|ch
operator|->
name|in_idx
operator|=
name|in_idx
expr_stmt|;
while|while
condition|(
name|in_idx
operator|!=
name|cin_idx
condition|)
block|{
name|crpb
operator|=
operator|(
expr|struct
name|mvs_crpb
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|workrp
operator|+
name|MVS_CRPB_OFFSET
operator|+
operator|(
name|MVS_CRPB_SIZE
operator|*
name|cin_idx
operator|)
operator|)
expr_stmt|;
name|slot
operator|=
name|le16toh
argument_list|(
name|crpb
operator|->
name|id
argument_list|)
operator|&
name|MVS_CRPB_TAG_MASK
expr_stmt|;
name|flags
operator|=
name|le16toh
argument_list|(
name|crpb
operator|->
name|rspflg
argument_list|)
expr_stmt|;
comment|/* 		 * Handle only successfull completions here. 		 * Errors will be handled by main intr handler. 		 */
if|if
condition|(
name|crpb
operator|->
name|id
operator|==
literal|0xffff
operator|&&
name|crpb
operator|->
name|rspflg
operator|==
literal|0xffff
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unfilled CRPB "
literal|"%d (%d->%d) tag %d flags %04x rs %08x\n"
argument_list|,
name|cin_idx
argument_list|,
name|fin_idx
argument_list|,
name|in_idx
argument_list|,
name|slot
argument_list|,
name|flags
argument_list|,
name|ch
operator|->
name|rslots
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|EDMA_IE_EDEVERR
operator|)
operator|==
literal|0
condition|)
block|{
name|crpb
operator|->
name|id
operator|=
literal|0xffff
expr_stmt|;
name|crpb
operator|->
name|rspflg
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|slot
index|]
operator|.
name|state
operator|>=
name|MVS_SLOT_RUNNING
condition|)
block|{
name|ccb
operator|=
name|ch
operator|->
name|slot
index|[
name|slot
index|]
operator|.
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|status
operator|=
operator|(
name|flags
operator|&
name|MVS_CRPB_ATASTS_MASK
operator|)
operator|>>
name|MVS_CRPB_ATASTS_SHIFT
expr_stmt|;
name|mvs_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|slot
index|]
argument_list|,
name|MVS_ERR_NONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unused tag in CRPB "
literal|"%d (%d->%d) tag %d flags %04x rs %08x\n"
argument_list|,
name|cin_idx
argument_list|,
name|fin_idx
argument_list|,
name|in_idx
argument_list|,
name|slot
argument_list|,
name|flags
argument_list|,
name|ch
operator|->
name|rslots
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CRPB with error %d tag %d flags %04x\n"
argument_list|,
name|cin_idx
argument_list|,
name|slot
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|cin_idx
operator|=
operator|(
name|cin_idx
operator|+
literal|1
operator|)
operator|&
operator|(
name|MVS_MAX_SLOTS
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cin_idx
operator|==
name|ch
operator|->
name|in_idx
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_RESQOP
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_bus
operator||
operator|(
name|cin_idx
operator|<<
name|EDMA_RESQP_ERPQP_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|int
name|mvs_check_collision
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
comment|/* NCQ DMA */
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
comment|/* Can't mix NCQ and non-NCQ DMA commands. */
if|if
condition|(
name|ch
operator|->
name|numdslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Can't mix NCQ and PIO commands. */
if|if
condition|(
name|ch
operator|->
name|numpslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If we have no FBS */
if|if
condition|(
operator|!
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
comment|/* Tagged command while tagged to other target is active. */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|taggedtarget
operator|!=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Non-NCQ DMA */
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_DMA
condition|)
block|{
comment|/* Can't mix non-NCQ DMA and NCQ commands. */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Can't mix non-NCQ DMA and PIO commands. */
if|if
condition|(
name|ch
operator|->
name|numpslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* PIO */
block|}
else|else
block|{
comment|/* Can't mix PIO with anything. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
condition|)
block|{
comment|/* Atomic command while anything active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* ATAPI */
comment|/* ATAPI goes without EDMA, so can't mix it with anything. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We have some atomic command running. */
if|if
condition|(
name|ch
operator|->
name|aslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_tfd_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ata_res
modifier|*
name|res
init|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
decl_stmt|;
name|res
operator|->
name|status
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_ALTSTAT
argument_list|)
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DRIVE
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CONTROL
argument_list|,
name|ATA_A_HOB
argument_list|)
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_COUNT
argument_list|)
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_SECTOR
argument_list|)
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_LSB
argument_list|)
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_MSB
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_COUNT
argument_list|)
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_SECTOR
argument_list|)
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_LSB
argument_list|)
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_MSB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_tfd_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ata_cmd
modifier|*
name|cmd
init|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|cmd
decl_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DRIVE
argument_list|,
name|cmd
operator|->
name|device
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CONTROL
argument_list|,
name|cmd
operator|->
name|control
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_FEATURE
argument_list|,
name|cmd
operator|->
name|features_exp
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_FEATURE
argument_list|,
name|cmd
operator|->
name|features
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_COUNT
argument_list|,
name|cmd
operator|->
name|sector_count_exp
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_COUNT
argument_list|,
name|cmd
operator|->
name|sector_count
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_SECTOR
argument_list|,
name|cmd
operator|->
name|lba_low_exp
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_SECTOR
argument_list|,
name|cmd
operator|->
name|lba_low
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_LSB
argument_list|,
name|cmd
operator|->
name|lba_mid_exp
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_LSB
argument_list|,
name|cmd
operator|->
name|lba_mid
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_MSB
argument_list|,
name|cmd
operator|->
name|lba_high_exp
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_MSB
argument_list|,
name|cmd
operator|->
name|lba_high
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_COMMAND
argument_list|,
name|cmd
operator|->
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|mvs_begin_transaction
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mvs_slot
modifier|*
name|slot
decl_stmt|;
name|int
name|slotn
decl_stmt|,
name|tag
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
condition|)
name|mvs_ch_pm_wake
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Softreset is a special case. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
condition|)
block|{
name|mvs_softreset
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Choose empty slot. */
name|slotn
operator|=
name|ffs
argument_list|(
operator|~
name|ch
operator|->
name|oslots
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
condition|)
name|tag
operator|=
name|ffs
argument_list|(
operator|~
name|ch
operator|->
name|otagspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|tag
operator|=
name|slotn
expr_stmt|;
block|}
else|else
name|tag
operator|=
literal|0
expr_stmt|;
comment|/* Occupy chosen slot. */
name|slot
operator|=
operator|&
name|ch
operator|->
name|slot
index|[
name|slotn
index|]
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|slot
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
comment|/* Stop PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|oslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|numrslots
operator|++
expr_stmt|;
name|ch
operator|->
name|numrslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|ch
operator|->
name|otagspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|tag
operator|)
expr_stmt|;
name|ch
operator|->
name|numtslots
operator|++
expr_stmt|;
name|ch
operator|->
name|numtslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|++
expr_stmt|;
name|ch
operator|->
name|taggedtarget
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_NCQ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_DMA
condition|)
block|{
name|ch
operator|->
name|numdslots
operator|++
expr_stmt|;
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_ON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|numpslots
operator|++
expr_stmt|;
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_OFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
condition|)
block|{
name|ch
operator|->
name|aslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint8_t
modifier|*
name|cdb
init|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
decl_stmt|;
name|ch
operator|->
name|numpslots
operator|++
expr_stmt|;
comment|/* Use ATAPI DMA only for commands without under-/overruns. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|&&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|mode
operator|>=
name|ATA_DMA
operator|&&
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_SOC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x08
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x0a
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x28
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x2a
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x88
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x8a
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0xa8
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0xaa
operator|||
name|cdb
index|[
literal|0
index|]
operator|==
literal|0xbe
operator|)
condition|)
block|{
name|ch
operator|->
name|basic_dma
operator|=
literal|1
expr_stmt|;
block|}
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_OFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|numpslots
operator|==
literal|0
operator|||
name|ch
operator|->
name|basic_dma
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|slot
operator|->
name|state
operator|=
name|MVS_SLOT_LOADING
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|buf
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
name|size
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|size
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
block|}
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|mvs_dmasetprd
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mvs_legacy_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locked by busdma engine. */
end_comment

begin_function
specifier|static
name|void
name|mvs_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mvs_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|slot
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mvs_eprd
modifier|*
name|eprd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|slot
operator|->
name|dev
argument_list|,
literal|"DMA load error\n"
argument_list|)
expr_stmt|;
name|mvs_end_transaction
argument_list|(
name|slot
argument_list|,
name|MVS_ERR_INVALID
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|MVS_SG_ENTRIES
argument_list|,
operator|(
literal|"too many DMA segment entries\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* If there is only one segment - no need to use S/G table on Gen-IIe. */
if|if
condition|(
name|nsegs
operator|==
literal|1
operator|&&
name|ch
operator|->
name|basic_dma
operator|==
literal|0
operator|&&
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
operator|)
condition|)
block|{
name|slot
operator|->
name|dma
operator|.
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|slot
operator|->
name|dma
operator|.
name|len
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|->
name|dma
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* Get a piece of the workspace for this EPRD */
name|eprd
operator|=
operator|(
expr|struct
name|mvs_eprd
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|workrq
operator|+
name|MVS_EPRD_OFFSET
operator|+
operator|(
name|MVS_EPRD_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Fill S/G table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|eprd
index|[
name|i
index|]
operator|.
name|prdbal
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|eprd
index|[
name|i
index|]
operator|.
name|bytecount
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|&
name|MVS_EPRD_MASK
argument_list|)
expr_stmt|;
name|eprd
index|[
name|i
index|]
operator|.
name|prdbah
operator|=
name|htole32
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
name|eprd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bytecount
operator||=
name|htole32
argument_list|(
name|MVS_EPRD_EOF
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
operator|(
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|basic_dma
condition|)
name|mvs_legacy_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
else|else
name|mvs_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_legacy_execute_transaction
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_addr_t
name|eprd
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|int
name|port
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|slot
operator|->
name|state
operator|=
name|MVS_SLOT_RUNNING
expr_stmt|;
name|ch
operator|->
name|rslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SATAICTL
argument_list|,
name|port
operator|<<
name|SATA_SATAICTL_PMPTX_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|mvs_tfd_write
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* Device reset doesn't interrupt. */
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
operator|==
name|ATA_DEVICE_RESET
condition|)
block|{
name|int
name|timeout
init|=
literal|1000000
decl_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|status
operator|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|status
operator|&
name|ATA_S_BUSY
operator|&&
name|timeout
operator|--
condition|)
do|;
name|mvs_legacy_intr
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ch
operator|->
name|donecount
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|transfersize
operator|=
name|min
argument_list|(
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
argument_list|,
name|ch
operator|->
name|curr
index|[
name|port
index|]
operator|.
name|bytecount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
name|ch
operator|->
name|fake_busy
operator|=
literal|1
expr_stmt|;
comment|/* If data write command - output the data */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
if|if
condition|(
name|mvs_wait
argument_list|(
name|dev
argument_list|,
name|ATA_S_DRQ
argument_list|,
name|ATA_S_BUSY
argument_list|,
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"timeout waiting for write DRQ\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|mvs_end_transaction
argument_list|(
name|slot
argument_list|,
name|MVS_ERR_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|ATA_OUTSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
operator|+
name|ch
operator|->
name|donecount
operator|)
argument_list|,
name|ch
operator|->
name|transfersize
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ch
operator|->
name|donecount
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|transfersize
operator|=
name|min
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|ch
operator|->
name|curr
index|[
name|port
index|]
operator|.
name|bytecount
argument_list|)
expr_stmt|;
comment|/* Write ATA PACKET command. */
if|if
condition|(
name|ch
operator|->
name|basic_dma
condition|)
block|{
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_FEATURE
argument_list|,
name|ATA_F_DMA
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_LSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_MSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_FEATURE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_LSB
argument_list|,
name|ch
operator|->
name|transfersize
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CYL_MSB
argument_list|,
name|ch
operator|->
name|transfersize
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_COMMAND
argument_list|,
name|ATA_PACKET_CMD
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fake_busy
operator|=
literal|1
expr_stmt|;
comment|/* Wait for ready to write ATAPI command block */
if|if
condition|(
name|mvs_wait
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ATA_S_BUSY
argument_list|,
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"timeout waiting for ATAPI !BUSY\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|mvs_end_transaction
argument_list|(
name|slot
argument_list|,
name|MVS_ERR_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|=
literal|5000
expr_stmt|;
while|while
condition|(
name|timeout
operator|--
condition|)
block|{
name|int
name|reason
init|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_IREASON
argument_list|)
decl_stmt|;
name|int
name|status
init|=
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|reason
operator|&
operator|(
name|ATA_I_CMD
operator||
name|ATA_I_IN
operator|)
operator|)
operator||
operator|(
name|status
operator|&
operator|(
name|ATA_S_DRQ
operator||
name|ATA_S_BUSY
operator|)
operator|)
operator|)
operator|==
name|ATAPI_P_CMDOUT
condition|)
break|break;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"timeout waiting for ATAPI command ready\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|mvs_end_transaction
argument_list|(
name|slot
argument_list|,
name|MVS_ERR_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write ATAPI command. */
name|ATA_OUTSW_STRM
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
operator|)
argument_list|,
name|ch
operator|->
name|curr
index|[
name|port
index|]
operator|.
name|atapi
operator|/
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|basic_dma
condition|)
block|{
comment|/* Start basic DMA. */
name|eprd
operator|=
name|ch
operator|->
name|dma
operator|.
name|workrq_bus
operator|+
name|MVS_EPRD_OFFSET
operator|+
operator|(
name|MVS_EPRD_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_DTLBA
argument_list|,
name|eprd
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_DTHBA
argument_list|,
operator|(
name|eprd
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_C
argument_list|,
name|DMA_C_START
operator||
operator|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
operator|)
condition|?
name|DMA_C_READ
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Start command execution timeout */
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|(
name|int
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|1000
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|mvs_timeout
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|mvs_execute_transaction
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_addr_t
name|eprd
decl_stmt|;
name|struct
name|mvs_crqb
modifier|*
name|crqb
decl_stmt|;
name|struct
name|mvs_crqb_gen2e
modifier|*
name|crqb2e
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|int
name|port
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get address of the prepared EPRD */
name|eprd
operator|=
name|ch
operator|->
name|dma
operator|.
name|workrq_bus
operator|+
name|MVS_EPRD_OFFSET
operator|+
operator|(
name|MVS_EPRD_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
comment|/* Prepare CRQB. Gen IIe uses different CRQB format. */
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
condition|)
block|{
name|crqb2e
operator|=
operator|(
expr|struct
name|mvs_crqb_gen2e
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|workrq
operator|+
name|MVS_CRQB_OFFSET
operator|+
operator|(
name|MVS_CRQB_SIZE
operator|*
name|ch
operator|->
name|out_idx
operator|)
operator|)
expr_stmt|;
name|crqb2e
operator|->
name|ctrlflg
operator|=
name|htole32
argument_list|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|MVS_CRQB2E_READ
else|:
literal|0
operator|)
operator||
operator|(
name|slot
operator|->
name|tag
operator|<<
name|MVS_CRQB2E_DTAG_SHIFT
operator|)
operator||
operator|(
name|port
operator|<<
name|MVS_CRQB2E_PMP_SHIFT
operator|)
operator||
operator|(
name|slot
operator|->
name|slot
operator|<<
name|MVS_CRQB2E_HTAG_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* If there is only one segment - no need to use S/G table. */
if|if
condition|(
name|slot
operator|->
name|dma
operator|.
name|addr
operator|!=
literal|0
condition|)
block|{
name|eprd
operator|=
name|slot
operator|->
name|dma
operator|.
name|addr
expr_stmt|;
name|crqb2e
operator|->
name|ctrlflg
operator||=
name|htole32
argument_list|(
name|MVS_CRQB2E_CPRD
argument_list|)
expr_stmt|;
name|crqb2e
operator|->
name|drbc
operator|=
name|slot
operator|->
name|dma
operator|.
name|len
expr_stmt|;
block|}
name|crqb2e
operator|->
name|cprdbl
operator|=
name|htole32
argument_list|(
name|eprd
argument_list|)
expr_stmt|;
name|crqb2e
operator|->
name|cprdbh
operator|=
name|htole32
argument_list|(
operator|(
name|eprd
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|2
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|3
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|4
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|5
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|6
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|7
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|device
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|8
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low_exp
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|9
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid_exp
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|10
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high_exp
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|11
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features_exp
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|crqb2e
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|slot
operator|->
name|tag
operator|<<
literal|3
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|crqb2e
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count_exp
expr_stmt|;
block|}
name|crqb2e
operator|->
name|cmd
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|crqb2e
operator|->
name|cmd
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|crqb
operator|=
operator|(
expr|struct
name|mvs_crqb
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|workrq
operator|+
name|MVS_CRQB_OFFSET
operator|+
operator|(
name|MVS_CRQB_SIZE
operator|*
name|ch
operator|->
name|out_idx
operator|)
operator|)
expr_stmt|;
name|crqb
operator|->
name|cprdbl
operator|=
name|htole32
argument_list|(
name|eprd
argument_list|)
expr_stmt|;
name|crqb
operator|->
name|cprdbh
operator|=
name|htole32
argument_list|(
operator|(
name|eprd
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|crqb
operator|->
name|ctrlflg
operator|=
name|htole16
argument_list|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|MVS_CRQB_READ
else|:
literal|0
operator|)
operator||
operator|(
name|slot
operator|->
name|slot
operator|<<
name|MVS_CRQB_TAG_SHIFT
operator|)
operator||
operator|(
name|port
operator|<<
name|MVS_CRQB_PMP_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Controller can handle only 11 of 12 ATA registers, 		 * so we have to choose which one to skip. 		 */
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features_exp
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x11
expr_stmt|;
block|}
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x11
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|slot
operator|->
name|tag
operator|<<
literal|3
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x12
expr_stmt|;
block|}
else|else
block|{
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count_exp
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x12
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x12
expr_stmt|;
block|}
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low_exp
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x13
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x13
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid_exp
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x14
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x14
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high_exp
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x15
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x15
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|device
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x16
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
expr_stmt|;
name|crqb
operator|->
name|cmd
index|[
name|i
operator|++
index|]
operator|=
literal|0x97
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrp_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrp_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|MVS_SLOT_RUNNING
expr_stmt|;
name|ch
operator|->
name|rslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
comment|/* Issue command to the controller. */
name|ch
operator|->
name|out_idx
operator|=
operator|(
name|ch
operator|->
name|out_idx
operator|+
literal|1
operator|)
operator|&
operator|(
name|MVS_MAX_SLOTS
operator|-
literal|1
operator|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_REQQIP
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_bus
operator|+
name|MVS_CRQB_OFFSET
operator|+
operator|(
name|MVS_CRQB_SIZE
operator|*
name|ch
operator|->
name|out_idx
operator|)
argument_list|)
expr_stmt|;
comment|/* Start command execution timeout */
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|(
name|int
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|1000
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|mvs_timeout
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|mvs_process_timeout
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Handle the rest of commands. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|MVS_SLOT_RUNNING
condition|)
continue|continue;
name|mvs_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|MVS_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|mvs_rearm_timeout
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mvs_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|MVS_SLOT_RUNNING
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ch
operator|->
name|toslots
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|(
name|int
operator|)
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|2000
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|mvs_timeout
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Locked by callout mechanism. */
end_comment

begin_function
specifier|static
name|void
name|mvs_timeout
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Check for stale timeout. */
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|MVS_SLOT_RUNNING
condition|)
return|return;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Timeout on slot %d\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"iec %08x sstat %08x serr %08x edma_s %08x "
literal|"dma_c %08x dma_s %08x rs %08x status %02x\n"
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEC
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SS
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SE
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_S
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_C
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_S
argument_list|)
argument_list|,
name|ch
operator|->
name|rslots
argument_list|,
name|ATA_INB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_ALTSTAT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle frozen command. */
name|mvs_requeue_frozen
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* We wait for other commands timeout and pray. */
if|if
condition|(
name|ch
operator|->
name|toslots
operator|==
literal|0
condition|)
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|rslots
operator|&
operator|~
name|ch
operator|->
name|toslots
operator|)
operator|==
literal|0
condition|)
name|mvs_process_timeout
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" ... waiting for slots %08x\n"
argument_list|,
name|ch
operator|->
name|rslots
operator|&
operator|~
name|ch
operator|->
name|toslots
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|mvs_end_transaction
parameter_list|(
name|struct
name|mvs_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|mvs_err_type
name|et
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|int
name|lastto
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|workrq_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|workrq_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Read result registers to the result struct 	 * May be incorrect if several commands finished same time, 	 * so read only when sure or have to. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|struct
name|ata_res
modifier|*
name|res
init|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|et
operator|==
name|MVS_ERR_TFE
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_NEEDRESULT
operator|)
condition|)
block|{
name|mvs_tfd_read
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|&&
name|ch
operator|->
name|basic_dma
operator|==
literal|0
condition|)
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ch
operator|->
name|donecount
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|numpslots
operator|==
literal|0
operator|||
name|ch
operator|->
name|basic_dma
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|et
operator|!=
name|MVS_ERR_NONE
condition|)
name|ch
operator|->
name|eslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
comment|/* In case of error, freeze device for proper recovery. */
if|if
condition|(
operator|(
name|et
operator|!=
name|MVS_ERR_NONE
operator|)
operator|&&
operator|(
operator|!
name|ch
operator|->
name|recoverycmd
operator|)
operator|&&
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
comment|/* Set proper result status. */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|MVS_ERR_NONE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
case|case
name|MVS_ERR_INVALID
case|:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|MVS_ERR_INNOCENT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
case|case
name|MVS_ERR_TFE
case|:
case|case
name|MVS_ERR_NCQ
case|:
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_ATA_STATUS_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|MVS_ERR_SATA
case|:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|recoverycmd
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
break|break;
case|case
name|MVS_ERR_TIMEOUT
case|:
if|if
condition|(
operator|!
name|ch
operator|->
name|recoverycmd
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
default|default:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
comment|/* Free slot. */
name|ch
operator|->
name|oslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|rslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|aslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|MVS_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|numrslots
operator|--
expr_stmt|;
name|ch
operator|->
name|numrslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|ch
operator|->
name|otagspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|tag
operator|)
expr_stmt|;
name|ch
operator|->
name|numtslots
operator|--
expr_stmt|;
name|ch
operator|->
name|numtslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_DMA
condition|)
block|{
name|ch
operator|->
name|numdslots
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|numpslots
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|ch
operator|->
name|numpslots
operator|--
expr_stmt|;
name|ch
operator|->
name|basic_dma
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Cancel timeout state if request completed normally. */
if|if
condition|(
name|et
operator|!=
name|MVS_ERR_TIMEOUT
condition|)
block|{
name|lastto
operator|=
operator|(
name|ch
operator|->
name|toslots
operator|==
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
if|if
condition|(
name|lastto
condition|)
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* If it was our READ LOG command - process it. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|==
name|RECOVERY_READ_LOG
condition|)
block|{
name|mvs_process_read_log
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* If it was our REQUEST SENSE command - process it. */
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|==
name|RECOVERY_REQUEST_SENSE
condition|)
block|{
name|mvs_process_request_sense
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* If it was NCQ or ATAPI command error, put result on hold. */
block|}
elseif|else
if|if
condition|(
name|et
operator|==
name|MVS_ERR_NCQ
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ch
operator|->
name|hold
index|[
name|slot
operator|->
name|slot
index|]
operator|=
name|ccb
expr_stmt|;
name|ch
operator|->
name|holdtag
index|[
name|slot
operator|->
name|slot
index|]
operator|=
name|slot
operator|->
name|tag
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|++
expr_stmt|;
block|}
else|else
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* If we have no other active commands, ... */
if|if
condition|(
name|ch
operator|->
name|rslots
operator|==
literal|0
condition|)
block|{
comment|/* if there was fatal error - reset port. */
if|if
condition|(
name|ch
operator|->
name|toslots
operator|!=
literal|0
operator|||
name|ch
operator|->
name|fatalerr
condition|)
block|{
name|mvs_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if we have slots in error, we can reinit port. */
if|if
condition|(
name|ch
operator|->
name|eslots
operator|!=
literal|0
condition|)
block|{
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_OFF
argument_list|)
expr_stmt|;
name|ch
operator|->
name|eslots
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if there commands on hold, we can do READ LOG. */
if|if
condition|(
operator|!
name|ch
operator|->
name|recoverycmd
operator|&&
name|ch
operator|->
name|numhslots
condition|)
name|mvs_issue_recovery
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* If all the rest of commands are in timeout - give them chance. */
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|->
name|rslots
operator|&
operator|~
name|ch
operator|->
name|toslots
operator|)
operator|==
literal|0
operator|&&
name|et
operator|!=
name|MVS_ERR_TIMEOUT
condition|)
name|mvs_rearm_timeout
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Unfreeze frozen command. */
if|if
condition|(
name|ch
operator|->
name|frozen
operator|&&
operator|!
name|mvs_check_collision
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|frozen
argument_list|)
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|mvs_begin_transaction
argument_list|(
name|dev
argument_list|,
name|fccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Start PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
operator|&&
operator|(
name|ch
operator|->
name|curr
index|[
name|ch
operator|->
name|pm_present
condition|?
literal|15
else|:
literal|0
index|]
operator|.
name|caps
operator|&
name|CTS_SATA_CAPS_D_PMREQ
operator|)
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_issue_recovery
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_ataio
modifier|*
name|ataio
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find some held command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
break|break;
block|}
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate recovery command\n"
argument_list|)
expr_stmt|;
name|completeall
label|:
comment|/* We can't do anything -- complete held commands. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
name|mvs_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|=
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
expr_stmt|;
comment|/* Reuse old header. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
comment|/* READ LOG */
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|=
name|RECOVERY_READ_LOG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ATA_IO
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|1000
expr_stmt|;
comment|/* 1s should be enough. */
name|ataio
operator|=
operator|&
name|ccb
operator|->
name|ataio
expr_stmt|;
name|ataio
operator|->
name|data_ptr
operator|=
name|malloc
argument_list|(
literal|512
argument_list|,
name|M_MVS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ataio
operator|->
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate memory for READ LOG command\n"
argument_list|)
expr_stmt|;
goto|goto
name|completeall
goto|;
block|}
name|ataio
operator|->
name|dxfer_len
operator|=
literal|512
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ataio
operator|->
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ataio
operator|->
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|flags
operator|=
name|CAM_ATAIO_48BIT
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|command
operator|=
literal|0x2F
expr_stmt|;
comment|/* READ LOG EXT */
name|ataio
operator|->
name|cmd
operator|.
name|sector_count
operator|=
literal|1
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|sector_count_exp
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_low
operator|=
literal|0x10
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid_exp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* REQUEST SENSE */
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|=
name|RECOVERY_REQUEST_SENSE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_slot
operator|=
name|i
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCSI_IO
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|1000
expr_stmt|;
comment|/* 1s should be enough. */
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|csio
operator|->
name|data_ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|csio
operator|->
name|dxfer_len
operator|=
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
name|csio
operator|->
name|cdb_len
operator|=
literal|6
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|csio
operator|->
name|cdb_io
argument_list|,
sizeof|sizeof
argument_list|(
name|csio
operator|->
name|cdb_io
argument_list|)
argument_list|)
expr_stmt|;
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|=
literal|0x03
expr_stmt|;
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
block|}
comment|/* Freeze SIM while doing recovery. */
name|ch
operator|->
name|recoverycmd
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mvs_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_process_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|struct
name|ata_res
modifier|*
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|recoverycmd
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
condition|)
continue|continue;
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x1F
operator|)
operator|==
name|ch
operator|->
name|holdtag
index|[
name|i
index|]
condition|)
block|{
name|res
operator|=
operator|&
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ataio
operator|.
name|res
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|data
index|[
literal|7
index|]
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|data
index|[
literal|8
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|data
index|[
literal|9
index|]
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|data
index|[
literal|10
index|]
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|data
index|[
literal|12
index|]
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|data
index|[
literal|13
index|]
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error while READ LOG EXT\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Non-queued command error in READ LOG EXT\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
condition|)
continue|continue;
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
argument_list|,
name|M_MVS
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_process_request_sense
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|recoverycmd
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_slot
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_wait
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|c
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|uint8_t
name|st
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|st
operator|=
name|mvs_getstatus
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
operator|&
operator|(
name|s
operator||
name|c
operator|)
operator|)
operator|!=
name|s
condition|)
block|{
if|if
condition|(
name|timeout
operator|>=
name|t
condition|)
block|{
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Wait status %02x\n"
argument_list|,
name|st
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|timeout
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|timeout
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_requeue_frozen
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
if|if
condition|(
name|fccb
condition|)
block|{
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|fccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|fccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_reset_to
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|arg
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|t
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|resetting
operator|==
literal|0
condition|)
return|return;
name|ch
operator|->
name|resetting
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|mvs_wait
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MVS reset: device ready after %dms\n"
argument_list|,
operator|(
literal|310
operator|-
name|ch
operator|->
name|resetting
operator|)
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ch
operator|->
name|resetting
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MVS reset: device not ready after 31000ms\n"
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|callout_schedule
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MVS reset...\n"
argument_list|)
expr_stmt|;
comment|/* Forget about previous reset. */
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
block|{
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Requeue freezed command. */
name|mvs_requeue_frozen
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Kill the engine and requeue all running commands. */
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_OFF
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|DMA_C
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|MVS_SLOT_RUNNING
condition|)
continue|continue;
comment|/* XXX; Commands in loading state. */
name|mvs_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|MVS_ERR_INNOCENT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVS_MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|toslots
operator|!=
literal|0
condition|)
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ch
operator|->
name|eslots
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|toslots
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|fatalerr
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|fake_busy
operator|=
literal|0
expr_stmt|;
comment|/* Tell the XPT about the event */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_CMD
argument_list|,
name|EDMA_CMD_EATARST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset and reconnect PHY, */
if|if
condition|(
operator|!
name|mvs_sata_phy_reset
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MVS reset: device not found\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEM
argument_list|,
operator|~
name|EDMA_IE_TRANSIENT
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MVS reset: device found\n"
argument_list|)
expr_stmt|;
comment|/* Wait for clearing busy status. */
if|if
condition|(
operator|(
name|i
operator|=
name|mvs_wait
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
argument_list|,
name|dumping
condition|?
literal|31000
else|:
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dumping
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MVS reset: device not ready after 31000ms\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|ch
operator|->
name|resetting
operator|=
literal|310
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MVS reset: device ready after %dms\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|1
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|EDMA_IEM
argument_list|,
operator|~
name|EDMA_IE_TRANSIENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
name|callout_reset
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|,
name|hz
operator|/
literal|10
argument_list|,
name|mvs_reset_to
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvs_softreset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stuck
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|mvs_set_edma_mode
argument_list|(
name|dev
argument_list|,
name|MVS_EDMA_OFF
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SATAICTL
argument_list|,
name|port
operator|<<
name|SATA_SATAICTL_PMPTX_SHIFT
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CONTROL
argument_list|,
name|ATA_A_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
comment|/* Wait for clearing busy status. */
if|if
condition|(
operator|(
name|i
operator|=
name|mvs_wait
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ATA_S_BUSY
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|stuck
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|mvs_getstatus
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_ATA_STATUS_ERROR
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ATA_S_DRQ
condition|)
name|stuck
operator|=
literal|1
expr_stmt|;
else|else
name|stuck
operator|=
literal|0
expr_stmt|;
block|}
name|mvs_tfd_read
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: If some device on PMP failed to soft-reset, 	 * try to recover by sending dummy soft-reset to PMP. 	 */
if|if
condition|(
name|stuck
operator|&&
name|ch
operator|->
name|pm_present
operator|&&
name|port
operator|!=
literal|15
condition|)
block|{
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SATAICTL
argument_list|,
literal|15
operator|<<
name|SATA_SATAICTL_PMPTX_SHIFT
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CONTROL
argument_list|,
name|ATA_A_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|ATA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mvs_wait
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_sata_connect
parameter_list|(
name|struct
name|mvs_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
comment|/* Wait up to 100ms for "connect well" */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|1000
condition|;
name|timeout
operator|++
control|)
block|{
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SATA_SS_DET_MASK
operator|)
operator|!=
name|SATA_SS_DET_NO_DEVICE
condition|)
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|SATA_SS_DET_MASK
operator|)
operator|==
name|SATA_SS_DET_PHY_ONLINE
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|SATA_SS_SPD_MASK
operator|)
operator|!=
name|SATA_SS_SPD_NO_SPEED
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|SATA_SS_IPM_MASK
operator|)
operator|==
name|SATA_SS_IPM_ACTIVE
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
name|SATA_SS_DET_MASK
operator|)
operator|==
name|SATA_SS_DET_PHY_OFFLINE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA offline status=%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
operator|&&
name|timeout
operator|>=
literal|100
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>=
literal|1000
operator|||
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect timeout time=%dus status=%08x\n"
argument_list|,
name|timeout
operator|*
literal|100
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect time=%dus status=%08x\n"
argument_list|,
name|timeout
operator|*
literal|100
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Clear SATA error register */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_sata_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|sata_rev
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|sata_rev
operator|=
name|ch
operator|->
name|user
index|[
name|ch
operator|->
name|pm_present
condition|?
literal|15
else|:
literal|0
index|]
operator|.
name|revision
expr_stmt|;
if|if
condition|(
name|sata_rev
operator|==
literal|1
condition|)
name|val
operator|=
name|SATA_SC_SPD_SPEED_GEN1
expr_stmt|;
elseif|else
if|if
condition|(
name|sata_rev
operator|==
literal|2
condition|)
name|val
operator|=
name|SATA_SC_SPD_SPEED_GEN2
expr_stmt|;
elseif|else
if|if
condition|(
name|sata_rev
operator|==
literal|3
condition|)
name|val
operator|=
name|SATA_SC_SPD_SPEED_GEN3
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SC
argument_list|,
name|SATA_SC_DET_RESET
operator||
name|val
operator||
name|SATA_SC_IPM_DIS_PARTIAL
operator||
name|SATA_SC_IPM_DIS_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SC
argument_list|,
name|SATA_SC_DET_IDLE
operator||
name|val
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|SATA_SC_IPM_DIS_PARTIAL
operator||
name|SATA_SC_IPM_DIS_SLUMBER
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mvs_sata_connect
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
condition|)
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SC
argument_list|,
name|SATA_SC_DET_DISABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvs_check_ids
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
operator|(
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENI
operator|)
condition|?
literal|0
else|:
literal|15
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvsaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|,
name|parent
decl_stmt|;
name|struct
name|mvs_channel
modifier|*
name|ch
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"mvsaction func_code=%x\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|mvs_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|dev
operator|=
name|ch
operator|->
name|dev
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ATA_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_SCSI_IO
case|:
if|if
condition|(
name|mvs_check_ids
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ch
operator|->
name|devices
operator|==
literal|0
operator|||
operator|(
name|ch
operator|->
name|pm_present
operator|==
literal|0
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
literal|0
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|<
literal|15
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|=
name|RECOVERY_NONE
expr_stmt|;
comment|/* Check for command collision. */
if|if
condition|(
name|mvs_check_collision
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
comment|/* Freeze command. */
name|ch
operator|->
name|frozen
operator|=
name|ccb
expr_stmt|;
comment|/* We have only one frozen slot, so freeze simq also. */
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|mvs_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|mvs_device
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|mvs_check_ids
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|d
operator|=
operator|&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_REVISION
condition|)
name|d
operator|->
name|revision
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_MODE
condition|)
name|d
operator|->
name|mode
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_BYTECOUNT
condition|)
block|{
name|d
operator|->
name|bytecount
operator|=
name|min
argument_list|(
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
operator|)
condition|?
literal|8192
else|:
literal|2048
argument_list|,
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bytecount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_TAGS
condition|)
name|d
operator|->
name|tags
operator|=
name|min
argument_list|(
name|MVS_MAX_SLOTS
argument_list|,
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_PM
condition|)
name|ch
operator|->
name|pm_present
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_ATAPI
condition|)
name|d
operator|->
name|atapi
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|atapi
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_CAPS
condition|)
name|d
operator|->
name|caps
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|mvs_device
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|mvs_check_ids
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|d
operator|=
operator|&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_ATA
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|15
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|0
operator|&&
operator|!
name|ch
operator|->
name|pm_present
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|SATA_SS
argument_list|)
operator|&
name|SATA_SS_SPD_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0f0
condition|)
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
operator|=
operator|(
name|status
operator|&
literal|0x0f0
operator|)
operator|>>
literal|4
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_REVISION
expr_stmt|;
block|}
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator|=
name|d
operator|->
name|caps
operator|&
name|CTS_SATA_CAPS_D
expr_stmt|;
comment|//			if (ch->pm_level)
comment|//				cts->xport_specific.sata.caps |= CTS_SATA_CAPS_H_PMREQ;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator||=
name|CTS_SATA_CAPS_H_AN
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator|&=
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|caps
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_CAPS
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
operator|=
name|d
operator|->
name|revision
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_REVISION
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator|=
name|d
operator|->
name|caps
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
comment|/*&& 			    (ch->quirks& MVS_Q_GENIIE) == 0*/
condition|)
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator|&=
operator|~
name|CTS_SATA_CAPS_H_AN
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_CAPS
expr_stmt|;
block|}
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|mode
operator|=
name|d
operator|->
name|mode
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_MODE
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bytecount
operator|=
name|d
operator|->
name|bytecount
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_BYTECOUNT
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
operator|=
name|ch
operator|->
name|pm_present
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_PM
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|tags
operator|=
name|d
operator|->
name|tags
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_TAGS
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|atapi
operator|=
name|d
operator|->
name|atapi
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_ATAPI
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
name|mvs_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENI
operator|)
condition|)
block|{
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_SATAPM
expr_stmt|;
comment|/* Gen-II is extremely slow with NCQ on PMP. */
if|if
condition|(
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENIIE
operator|)
operator|||
name|ch
operator|->
name|pm_present
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_TAG_ABLE
expr_stmt|;
block|}
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_SEQSCAN
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_GENI
operator|)
condition|)
name|cpi
operator|->
name|max_target
operator|=
literal|15
expr_stmt|;
else|else
name|cpi
operator|->
name|max_target
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Marvell"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_ATA
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|maxio
operator|=
name|MAXPHYS
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|quirks
operator|&
name|MVS_Q_SOC
operator|)
operator|==
literal|0
condition|)
block|{
name|cpi
operator|->
name|hba_vendor
operator|=
name|pci_get_vendor
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|hba_device
operator|=
name|pci_get_device
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|hba_subvendor
operator|=
name|pci_get_subvendor
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|hba_subdevice
operator|=
name|pci_get_subdevice
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mvspoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|mvs_channel
modifier|*
name|ch
init|=
operator|(
expr|struct
name|mvs_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|struct
name|mvs_intr_arg
name|arg
decl_stmt|;
name|arg
operator|.
name|arg
operator|=
name|ch
operator|->
name|dev
expr_stmt|;
name|arg
operator|.
name|cause
operator|=
literal|2
operator||
literal|4
expr_stmt|;
comment|/* XXX */
name|mvs_ch_intr
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|resetting
operator|!=
literal|0
operator|&&
operator|(
operator|--
name|ch
operator|->
name|resetpolldiv
operator|<=
literal|0
operator|||
operator|!
name|callout_pending
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
operator|)
condition|)
block|{
name|ch
operator|->
name|resetpolldiv
operator|=
literal|1000
expr_stmt|;
name|mvs_reset_to
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

