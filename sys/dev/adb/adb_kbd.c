begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2008 Nathan Whitehorn  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kbio.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|"opt_kbd.h"
end_include

begin_include
include|#
directive|include
file|<dev/kbd/kbdreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/kbdtables.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|"adb.h"
end_include

begin_define
define|#
directive|define
name|KBD_DRIVER_NAME
value|"akbd"
end_define

begin_define
define|#
directive|define
name|AKBD_EMULATE_ATKBD
value|1
end_define

begin_function_decl
specifier|static
name|int
name|adb_kbd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adb_kbd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adb_kbd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|akbd_repeat
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adb_fn_keys
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|adb_kbd_receive_packet
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|status
parameter_list|,
name|u_char
name|command
parameter_list|,
name|u_char
name|reg
parameter_list|,
name|int
name|len
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|adb_kbd_softc
block|{
name|keyboard_t
name|sc_kbd
decl_stmt|;
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|mtx
name|sc_mutex
decl_stmt|;
name|struct
name|cv
name|sc_cv
decl_stmt|;
name|int
name|sc_mode
decl_stmt|;
name|int
name|sc_state
decl_stmt|;
name|int
name|have_led_control
decl_stmt|;
name|uint8_t
name|buffer
index|[
literal|8
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|AKBD_EMULATE_ATKBD
name|uint8_t
name|at_buffered_char
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
specifier|volatile
name|int
name|buffers
decl_stmt|;
name|struct
name|callout
name|sc_repeater
decl_stmt|;
name|int
name|sc_repeatstart
decl_stmt|;
name|int
name|sc_repeatcontinue
decl_stmt|;
name|uint8_t
name|last_press
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|device_method_t
name|adb_kbd_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|adb_kbd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|adb_kbd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|adb_kbd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* ADB interface */
name|DEVMETHOD
argument_list|(
name|adb_receive_packet
argument_list|,
name|adb_kbd_receive_packet
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|adb_kbd_driver
init|=
block|{
literal|"akbd"
block|,
name|adb_kbd_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adb_kbd_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|adb_kbd_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|akbd
argument_list|,
name|adb
argument_list|,
name|adb_kbd_driver
argument_list|,
name|adb_kbd_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AKBD_EMULATE_ATKBD
end_ifdef

begin_define
define|#
directive|define
name|SCAN_PRESS
value|0x000
end_define

begin_define
define|#
directive|define
name|SCAN_RELEASE
value|0x080
end_define

begin_define
define|#
directive|define
name|SCAN_PREFIX_E0
value|0x100
end_define

begin_define
define|#
directive|define
name|SCAN_PREFIX_E1
value|0x200
end_define

begin_define
define|#
directive|define
name|SCAN_PREFIX_CTL
value|0x400
end_define

begin_define
define|#
directive|define
name|SCAN_PREFIX_SHIFT
value|0x800
end_define

begin_define
define|#
directive|define
name|SCAN_PREFIX
value|(SCAN_PREFIX_E0 | SCAN_PREFIX_E1 |	\ 				SCAN_PREFIX_CTL | SCAN_PREFIX_SHIFT)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|adb_to_at_scancode_map
index|[
literal|128
index|]
init|=
block|{
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|35
block|,
literal|34
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|0
block|,
literal|48
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|21
block|,
literal|20
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|6
block|,
literal|13
block|,
literal|10
block|,
literal|8
block|,
literal|12
block|,
literal|9
block|,
literal|11
block|,
literal|27
block|,
literal|24
block|,
literal|22
block|,
literal|26
block|,
literal|23
block|,
literal|25
block|,
literal|28
block|,
literal|38
block|,
literal|36
block|,
literal|40
block|,
literal|37
block|,
literal|39
block|,
literal|43
block|,
literal|51
block|,
literal|53
block|,
literal|49
block|,
literal|50
block|,
literal|52
block|,
literal|15
block|,
literal|57
block|,
literal|41
block|,
literal|14
block|,
literal|0
block|,
literal|1
block|,
literal|29
block|,
literal|0
block|,
literal|42
block|,
literal|58
block|,
literal|56
block|,
literal|97
block|,
literal|98
block|,
literal|100
block|,
literal|95
block|,
literal|0
block|,
literal|0
block|,
literal|83
block|,
literal|0
block|,
literal|55
block|,
literal|0
block|,
literal|78
block|,
literal|0
block|,
literal|69
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|91
block|,
literal|89
block|,
literal|0
block|,
literal|74
block|,
literal|13
block|,
literal|0
block|,
literal|0
block|,
literal|82
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|71
block|,
literal|0
block|,
literal|72
block|,
literal|73
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|61
block|,
literal|66
block|,
literal|67
block|,
literal|0
block|,
literal|87
block|,
literal|0
block|,
literal|105
block|,
literal|0
block|,
literal|70
block|,
literal|0
block|,
literal|68
block|,
literal|0
block|,
literal|88
block|,
literal|0
block|,
literal|107
block|,
literal|102
block|,
literal|94
block|,
literal|96
block|,
literal|103
block|,
literal|62
block|,
literal|99
block|,
literal|60
block|,
literal|101
block|,
literal|59
block|,
literal|54
block|,
literal|93
block|,
literal|90
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|keycode2scancode
parameter_list|(
name|int
name|keycode
parameter_list|,
name|int
name|shift
parameter_list|,
name|int
name|up
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|scan
index|[]
init|=
block|{
comment|/* KP enter, right ctrl, KP divide */
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x35
block|,
comment|/* print screen */
literal|0x37
operator||
name|SCAN_PREFIX_SHIFT
block|,
comment|/* right alt, home, up, page up, left, right, end */
literal|0x38
block|,
literal|0x47
block|,
literal|0x48
block|,
literal|0x49
block|,
literal|0x4b
block|,
literal|0x4d
block|,
literal|0x4f
block|,
comment|/* down, page down, insert, delete */
literal|0x50
block|,
literal|0x51
block|,
literal|0x52
block|,
literal|0x53
block|,
comment|/* pause/break (see also below) */
literal|0x46
block|,
comment|/* 		 * MS: left window, right window, menu 		 * also Sun: left meta, right meta, compose 		 */
literal|0x5b
block|,
literal|0x5c
block|,
literal|0x5d
block|,
comment|/* Sun type 6 USB */
comment|/* help, stop, again, props, undo, front, copy */
literal|0x68
block|,
literal|0x5e
block|,
literal|0x5f
block|,
literal|0x60
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
comment|/* open, paste, find, cut, audiomute, audiolower, audioraise */
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x25
block|,
literal|0x1f
block|,
literal|0x1e
block|,
comment|/* power */
literal|0x20
block|}
decl_stmt|;
name|int
name|scancode
decl_stmt|;
name|scancode
operator|=
name|keycode
expr_stmt|;
if|if
condition|(
operator|(
name|keycode
operator|>=
literal|89
operator|)
operator|&&
operator|(
name|keycode
operator|<
literal|89
operator|+
sizeof|sizeof
argument_list|(
name|scan
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scan
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|scancode
operator|=
name|scan
index|[
name|keycode
operator|-
literal|89
index|]
operator||
name|SCAN_PREFIX_E0
expr_stmt|;
comment|/* pause/break */
if|if
condition|(
operator|(
name|keycode
operator|==
literal|104
operator|)
operator|&&
operator|!
operator|(
name|shift
operator|&
name|CTLS
operator|)
condition|)
name|scancode
operator|=
literal|0x45
operator||
name|SCAN_PREFIX_E1
operator||
name|SCAN_PREFIX_CTL
expr_stmt|;
if|if
condition|(
name|shift
operator|&
name|SHIFTS
condition|)
name|scancode
operator|&=
operator|~
name|SCAN_PREFIX_SHIFT
expr_stmt|;
return|return
operator|(
name|scancode
operator||
operator|(
name|up
condition|?
name|SCAN_RELEASE
else|:
name|SCAN_PRESS
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* keyboard driver declaration */
end_comment

begin_function_decl
specifier|static
name|int
name|akbd_configure
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kbd_probe_t
name|akbd_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_init_t
name|akbd_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_term_t
name|akbd_term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_intr_t
name|akbd_interrupt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_test_if_t
name|akbd_test_if
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_enable_t
name|akbd_enable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_disable_t
name|akbd_disable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_read_t
name|akbd_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_check_t
name|akbd_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_read_char_t
name|akbd_read_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_check_char_t
name|akbd_check_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_ioctl_t
name|akbd_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_lock_t
name|akbd_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_clear_state_t
name|akbd_clear_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_get_state_t
name|akbd_get_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_set_state_t
name|akbd_set_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_poll_mode_t
name|akbd_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|keyboard_switch_t
name|akbdsw
init|=
block|{
name|akbd_probe
block|,
name|akbd_init
block|,
name|akbd_term
block|,
name|akbd_interrupt
block|,
name|akbd_test_if
block|,
name|akbd_enable
block|,
name|akbd_disable
block|,
name|akbd_read
block|,
name|akbd_check
block|,
name|akbd_read_char
block|,
name|akbd_check_char
block|,
name|akbd_ioctl
block|,
name|akbd_lock
block|,
name|akbd_clear_state
block|,
name|akbd_get_state
block|,
name|akbd_set_state
block|,
name|genkbd_get_fkeystr
block|,
name|akbd_poll
block|,
name|genkbd_diag
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|KEYBOARD_DRIVER
argument_list|(
name|akbd
argument_list|,
name|akbdsw
argument_list|,
name|akbd_configure
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|adb_kbd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint8_t
name|type
decl_stmt|;
name|type
operator|=
name|adb_get_device_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ADB_DEVICE_KEYBOARD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|adb_get_device_handler
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple Standard Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple Extended Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple ISO Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple Extended ISO Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple Keyboard II"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple ISO Keyboard II"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PowerBook Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PowerBook ISO Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PowerBook Extended Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple Design Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|195
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PowerBook G3 Keyboard"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|196
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"iBook Keyboard"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ADB Keyboard"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ms_to_ticks
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
if|if
condition|(
name|hz
operator|>
literal|1000
condition|)
return|return
name|ms
operator|*
operator|(
name|hz
operator|/
literal|1000
operator|)
return|;
return|return
name|ms
operator|/
operator|(
literal|1000
operator|/
name|hz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adb_kbd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
name|keyboard_switch_t
modifier|*
name|sw
decl_stmt|;
name|uint32_t
name|fkeys
decl_stmt|;
name|phandle_t
name|handle
decl_stmt|;
name|sw
operator|=
name|kbd_get_switch
argument_list|(
name|KBD_DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|=
name|K_RAW
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|have_led_control
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|buffers
operator|=
literal|0
expr_stmt|;
comment|/* Try stepping forward to the extended keyboard protocol */
name|adb_set_device_handler
argument_list|(
name|dev
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|,
name|KBD_DRIVER_NAME
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|,
name|KBD_DRIVER_NAME
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_repeater
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AKBD_EMULATE_ATKBD
name|kbd_init_struct
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|,
name|KBD_DRIVER_NAME
argument_list|,
name|KB_101
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kbd_set_maps
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|,
operator|&
name|key_map
argument_list|,
operator|&
name|accent_map
argument_list|,
name|fkey_tab
argument_list|,
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fkey_tab
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|ADB raw mode not implemented
endif|#
directive|endif
name|KBD_FOUND_DEVICE
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
expr_stmt|;
name|KBD_PROBE_DONE
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
expr_stmt|;
name|KBD_INIT_DONE
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
expr_stmt|;
name|KBD_CONFIG_DONE
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sw
operator|->
name|enable
call|)
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
expr_stmt|;
name|kbd_register
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
if|if
condition|(
name|kbd_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
condition|)
block|{
name|adb_kbd_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
endif|#
directive|endif
comment|/* Check if we can read out the LED state from  	   this keyboard by reading the key state register */
if|if
condition|(
name|adb_read_register
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
operator|==
literal|2
condition|)
name|sc
operator|->
name|have_led_control
operator|=
literal|1
expr_stmt|;
name|adb_set_autopoll
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handle
operator|=
name|OF_finddevice
argument_list|(
literal|"mac-io/via-pmu/adb/keyboard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
operator|-
literal|1
operator|&&
name|OF_getprop
argument_list|(
name|handle
argument_list|,
literal|"AAPL,has-embedded-fn-keys"
argument_list|,
operator|&
name|fkeys
argument_list|,
sizeof|sizeof
argument_list|(
name|fkeys
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|key_names
index|[]
init|=
block|{
literal|"F1"
block|,
literal|"F2"
block|,
literal|"F3"
block|,
literal|"F4"
block|,
literal|"F5"
block|,
literal|"F6"
block|,
literal|"F7"
block|,
literal|"F8"
block|,
literal|"F9"
block|,
literal|"F10"
block|,
literal|"F11"
block|,
literal|"F12"
block|}
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Keyboard has embedded Fn keys\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|keyval
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|handle
argument_list|,
name|key_names
index|[
name|i
index|]
argument_list|,
operator|&
name|keyval
argument_list|,
sizeof|sizeof
argument_list|(
name|keyval
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|buf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|keyval
expr_stmt|;
name|adb_write_register
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|adb_write_register
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|uint16_t
operator|)
block|{
literal|0
block|}
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fn_keys_function_as_primary"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|adb_fn_keys
argument_list|,
literal|"I"
argument_list|,
literal|"Set the Fn keys to be their F-key type as default"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adb_kbd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adb_set_autopoll
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_repeater
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|kbd_find_keyboard
argument_list|(
name|KBD_DRIVER_NAME
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|kbdd_disable
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
name|kbd_detach
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kbdd_term
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|adb_kbd_receive_packet
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|status
parameter_list|,
name|u_char
name|command
parameter_list|,
name|u_char
name|reg
parameter_list|,
name|int
name|len
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|!=
name|ADB_COMMAND_TALK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg
operator|!=
literal|0
operator|||
name|len
operator|!=
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
comment|/* 0x7f is always the power button */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
literal|0x7f
condition|)
block|{
name|devctl_notify
argument_list|(
literal|"PMU"
argument_list|,
literal|"Button"
argument_list|,
literal|"pressed"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
literal|0xff
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore power button release. */
block|}
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator|==
literal|57
operator|&&
name|sc
operator|->
name|buffers
operator|<
literal|7
condition|)
block|{
comment|/* Fake the down/up cycle for caps lock */
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
name|data
index|[
literal|0
index|]
operator|&
literal|0x7f
expr_stmt|;
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator||
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|-
literal|1
index|]
operator|<
literal|0xff
condition|)
name|sc
operator|->
name|last_press
operator|=
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0x7f
operator|)
operator|==
literal|57
operator|&&
name|sc
operator|->
name|buffers
operator|<
literal|7
condition|)
block|{
comment|/* Fake the down/up cycle for caps lock */
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
name|data
index|[
literal|1
index|]
operator|&
literal|0x7f
expr_stmt|;
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0x7f
operator|)
operator||
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|-
literal|1
index|]
operator|<
literal|0xff
condition|)
name|sc
operator|->
name|last_press
operator|=
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Stop any existing key repeating */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_repeater
argument_list|)
expr_stmt|;
comment|/* Schedule a repeat callback on keydown */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|last_press
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_repeater
argument_list|,
name|ms_to_ticks
argument_list|(
name|sc
operator|->
name|sc_kbd
operator|.
name|kb_delay1
argument_list|)
argument_list|,
name|akbd_repeat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|KBD_IS_ACTIVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
operator|&&
name|KBD_IS_BUSY
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_kbd
operator|.
name|kb_callback
operator|.
name|kc_func
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|,
name|KBDIO_KEYINPUT
argument_list|,
name|sc
operator|->
name|sc_kbd
operator|.
name|kb_callback
operator|.
name|kc_arg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|akbd_repeat
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|int
name|notify_kbd
init|=
literal|0
decl_stmt|;
comment|/* Fake an up/down key repeat so long as we have the 	   free buffers */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|buffers
operator|<
literal|7
condition|)
block|{
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
name|sc
operator|->
name|last_press
operator||
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
name|sc
operator|->
name|buffer
index|[
name|sc
operator|->
name|buffers
operator|++
index|]
operator|=
name|sc
operator|->
name|last_press
expr_stmt|;
name|notify_kbd
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_kbd
operator|&&
name|KBD_IS_ACTIVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
operator|&&
name|KBD_IS_BUSY
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_kbd
operator|.
name|kb_callback
operator|.
name|kc_func
argument_list|(
operator|&
name|sc
operator|->
name|sc_kbd
argument_list|,
name|KBDIO_KEYINPUT
argument_list|,
name|sc
operator|->
name|sc_kbd
operator|.
name|kb_callback
operator|.
name|kc_arg
argument_list|)
expr_stmt|;
block|}
comment|/* Reschedule the callout */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_repeater
argument_list|,
name|ms_to_ticks
argument_list|(
name|sc
operator|->
name|sc_kbd
operator|.
name|kb_delay2
argument_list|)
argument_list|,
name|akbd_repeat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_configure
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_probe
parameter_list|(
name|int
name|unit
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_init
parameter_list|(
name|int
name|unit
parameter_list|,
name|keyboard_t
modifier|*
modifier|*
name|kbdp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_term
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_interrupt
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_test_if
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_enable
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|KBD_ACTIVATE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_disable
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|adb_kbd_softc
operator|*
operator|)
operator|(
name|kbd
operator|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_repeater
argument_list|)
expr_stmt|;
name|KBD_DEACTIVATE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_read
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_check
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
operator|!
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|sc
operator|=
operator|(
expr|struct
name|adb_kbd_softc
operator|*
operator|)
operator|(
name|kbd
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AKBD_EMULATE_ATKBD
if|if
condition|(
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|buffers
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|akbd_read_char
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|key
decl_stmt|;
name|uint8_t
name|adb_code
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|adb_kbd_softc
operator|*
operator|)
operator|(
name|kbd
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AKBD_EMULATE_ATKBD
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|K_RAW
operator|&&
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
condition|)
block|{
name|key
operator|=
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|key
operator|&
name|SCAN_PREFIX
condition|)
block|{
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
operator|=
name|key
operator|&
operator|~
name|SCAN_PREFIX
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|&
name|SCAN_PREFIX_E0
operator|)
condition|?
literal|0xe0
else|:
literal|0xe1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|at_buffered_char
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|at_buffered_char
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|key
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|sc
operator|->
name|buffers
operator|&&
name|wait
condition|)
name|cv_wait
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|,
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|buffers
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOKEY
operator|)
return|;
block|}
name|adb_code
operator|=
name|sc
operator|->
name|buffer
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|buffers
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|buffer
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|sc
operator|->
name|buffer
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|buffers
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|AKBD_EMULATE_ATKBD
name|key
operator|=
name|adb_to_at_scancode_map
index|[
name|adb_code
operator|&
literal|0x7f
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|K_CODE
condition|)
block|{
comment|/* Add the key-release bit */
name|key
operator||=
name|adb_code
operator|&
literal|0x80
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|K_RAW
condition|)
block|{
comment|/* 			 * In the raw case, we have to emulate the gross 			 * variable-length AT keyboard thing. Since this code 			 * is copied from sunkbd, which is the same code 			 * as ukbd, it might be nice to have this centralized. 			 */
name|key
operator|=
name|keycode2scancode
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|adb_code
operator|&
literal|0x80
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|&
name|SCAN_PREFIX
condition|)
block|{
if|if
condition|(
name|key
operator|&
name|SCAN_PREFIX_CTL
condition|)
block|{
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
operator|=
literal|0x1d
operator||
operator|(
name|key
operator|&
name|SCAN_RELEASE
operator|)
expr_stmt|;
name|sc
operator|->
name|at_buffered_char
index|[
literal|1
index|]
operator|=
name|key
operator|&
operator|~
name|SCAN_PREFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|&
name|SCAN_PREFIX_SHIFT
condition|)
block|{
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
operator|=
literal|0x2a
operator||
operator|(
name|key
operator|&
name|SCAN_RELEASE
operator|)
expr_stmt|;
name|sc
operator|->
name|at_buffered_char
index|[
literal|1
index|]
operator|=
name|key
operator|&
operator|~
name|SCAN_PREFIX_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
operator|=
name|key
operator|&
operator|~
name|SCAN_PREFIX
expr_stmt|;
name|sc
operator|->
name|at_buffered_char
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|key
operator|=
operator|(
name|key
operator|&
name|SCAN_PREFIX_E0
operator|)
condition|?
literal|0xe0
else|:
literal|0xe1
expr_stmt|;
block|}
block|}
else|#
directive|else
name|key
operator|=
name|adb_code
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|key
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_check_char
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|akbd_check
argument_list|(
name|kbd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_typematic
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|code
parameter_list|)
block|{
comment|/* These numbers are in microseconds, so convert to ticks */
specifier|static
name|int
name|delays
index|[]
init|=
block|{
literal|250
block|,
literal|500
block|,
literal|750
block|,
literal|1000
block|}
decl_stmt|;
specifier|static
name|int
name|rates
index|[]
init|=
block|{
literal|34
block|,
literal|38
block|,
literal|42
block|,
literal|46
block|,
literal|50
block|,
literal|55
block|,
literal|59
block|,
literal|63
block|,
literal|68
block|,
literal|76
block|,
literal|84
block|,
literal|92
block|,
literal|100
block|,
literal|110
block|,
literal|118
block|,
literal|126
block|,
literal|136
block|,
literal|152
block|,
literal|168
block|,
literal|184
block|,
literal|200
block|,
literal|220
block|,
literal|236
block|,
literal|252
block|,
literal|272
block|,
literal|304
block|,
literal|336
block|,
literal|368
block|,
literal|400
block|,
literal|440
block|,
literal|472
block|,
literal|504
block|}
decl_stmt|;
if|if
condition|(
name|code
operator|&
operator|~
literal|0x7f
condition|)
return|return
name|EINVAL
return|;
name|kbd
operator|->
name|kb_delay1
operator|=
name|delays
index|[
operator|(
name|code
operator|>>
literal|5
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|kbd
operator|->
name|kb_delay2
operator|=
name|rates
index|[
name|code
operator|&
literal|0x1f
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_ioctl
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|r2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|adb_kbd_softc
operator|*
operator|)
operator|(
name|kbd
operator|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KDGKBMODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_mode
expr_stmt|;
break|break;
case|case
name|KDSKBMODE
case|:
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|K_XLATE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|!=
name|K_XLATE
condition|)
block|{
comment|/* make lock key state and LED state match */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|sc
operator|->
name|sc_state
operator||=
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|K_RAW
case|:
case|case
name|K_CODE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|!=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|sc
operator|->
name|sc_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|KDGETLED
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
break|break;
case|case
name|KDSKBSTATE
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
name|LOCK_MASK
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|sc
operator|->
name|sc_state
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|KDSETLED
case|:
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|have_led_control
condition|)
break|break;
name|r2
operator|=
operator|(
operator|~
literal|0
operator|&
literal|0x04
operator|)
operator||
literal|3
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|NLKED
condition|)
name|r2
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|CLKED
condition|)
name|r2
operator|&=
operator|~
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|SLKED
condition|)
name|r2
operator|&=
operator|~
literal|4
expr_stmt|;
name|adb_send_packet
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|ADB_COMMAND_LISTEN
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|r2
argument_list|)
expr_stmt|;
break|break;
case|case
name|KDGKBSTATE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_state
operator|&
name|LOCK_MASK
expr_stmt|;
break|break;
case|case
name|KDSETREPEAT
case|:
if|if
condition|(
operator|!
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* fastest possible value */
name|kbd
operator|->
name|kb_delay1
operator|=
literal|200
expr_stmt|;
else|else
name|kbd
operator|->
name|kb_delay1
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|kbd
operator|->
name|kb_delay2
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|KDSETRAD
case|:
name|error
operator|=
name|set_typematic
argument_list|(
name|kbd
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIO_KEYMAP
case|:
case|case
name|OPIO_KEYMAP
case|:
case|case
name|PIO_KEYMAPENT
case|:
case|case
name|PIO_DEADKEYMAP
case|:
default|default:
return|return
operator|(
name|genkbd_commonioctl
argument_list|(
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_lock
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|lock
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|akbd_clear_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|adb_kbd_softc
operator|*
operator|)
operator|(
name|kbd
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|sc
operator|->
name|buffers
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_repeater
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AKBD_EMULATE_ATKBD
argument_list|)
name|sc
operator|->
name|at_buffered_char
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|at_buffered_char
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_get_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_set_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_poll
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|on
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|akbd_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|kbd_add_driver
argument_list|(
operator|&
name|akbd_kbd_driver
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|kbd_delete_driver
argument_list|(
operator|&
name|akbd_kbd_driver
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adb_fn_keys
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adb_kbd_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|is_fn_enabled
decl_stmt|;
name|unsigned
name|int
name|is_fn_enabled_sysctl
decl_stmt|;
name|adb_read_register
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|1
argument_list|,
operator|&
name|is_fn_enabled
argument_list|)
expr_stmt|;
name|is_fn_enabled
operator|&=
literal|1
expr_stmt|;
name|is_fn_enabled_sysctl
operator|=
name|is_fn_enabled
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|is_fn_enabled_sysctl
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|is_fn_enabled
operator|=
name|is_fn_enabled_sysctl
expr_stmt|;
if|if
condition|(
name|is_fn_enabled
operator|!=
literal|1
operator|&&
name|is_fn_enabled
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|adb_write_register
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|is_fn_enabled
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|akbd
argument_list|,
name|akbd_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

