begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_tcb.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_do_autorcvbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_autorcvbuf
value|VNET(tcp_do_autorcvbuf)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_inc
value|VNET(tcp_autorcvbuf_inc)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_max
value|VNET(tcp_autorcvbuf_max)
end_define

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|get_ddp_mbuf
parameter_list|(
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PPOD_SZ
parameter_list|(
name|n
parameter_list|)
value|((n) * sizeof(struct pagepod))
end_define

begin_define
define|#
directive|define
name|PPOD_SIZE
value|(PPOD_SZ(1))
end_define

begin_comment
comment|/* XXX: must match A_ULP_RX_TDDP_PSZ */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_ddp_pgsz
index|[]
init|=
block|{
literal|4096
block|,
literal|4096
operator|<<
literal|2
block|,
literal|4096
operator|<<
literal|4
block|,
literal|4096
operator|<<
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void t4_dump_tcb(struct adapter *sc, int tid) { 	uint32_t tcb_base, off, i, j;
comment|/* Dump TCB for the tid */
end_comment

begin_endif
unit|tcb_base = t4_read_reg(sc, A_TP_CMM_TCB_BASE); 	t4_write_reg(sc, PCIE_MEM_ACCESS_REG(A_PCIE_MEM_ACCESS_OFFSET, 2), 	    tcb_base + tid * TCB_SIZE); 	t4_read_reg(sc, PCIE_MEM_ACCESS_REG(A_PCIE_MEM_ACCESS_OFFSET, 2)); 	off = 0; 	printf("\n"); 	for (i = 0; i< 4; i++) { 		uint32_t buf[8]; 		for (j = 0; j< 8; j++, off += 4) 			buf[j] = htonl(t4_read_reg(sc, MEMWIN2_BASE + off));  		printf("%08x %08x %08x %08x %08x %08x %08x %08x\n", 		    buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], 		    buf[7]); 	} }
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_DDP_BUFFER_SIZE
value|(M_TCB_RX_DDP_BUF0_LEN)
end_define

begin_function
specifier|static
name|int
name|alloc_ppods
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|int
name|n
parameter_list|,
name|u_int
modifier|*
name|ppod_addr
parameter_list|)
block|{
name|vmem_addr_t
name|v
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vmem_alloc
argument_list|(
name|td
operator|->
name|ppod_arena
argument_list|,
name|PPOD_SZ
argument_list|(
name|n
argument_list|)
argument_list|,
name|M_NOWAIT
operator||
name|M_FIRSTFIT
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
operator|*
name|ppod_addr
operator|=
operator|(
name|u_int
operator|)
name|v
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_ppods
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|u_int
name|ppod_addr
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|vmem_free
argument_list|(
name|td
operator|->
name|ppod_arena
argument_list|,
operator|(
name|vmem_addr_t
operator|)
name|ppod_addr
argument_list|,
name|PPOD_SZ
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pages_to_nppods
parameter_list|(
name|int
name|npages
parameter_list|,
name|int
name|ddp_pgsz
parameter_list|)
block|{
name|int
name|nsegs
init|=
name|npages
operator|*
name|PAGE_SIZE
operator|/
name|ddp_pgsz
decl_stmt|;
return|return
operator|(
name|howmany
argument_list|(
name|nsegs
argument_list|,
name|PPOD_PAGES
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_ddp_buffer
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|ddp_buffer
modifier|*
name|db
parameter_list|)
block|{
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|db
operator|->
name|pages
condition|)
name|free
argument_list|(
name|db
operator|->
name|pages
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|nppods
operator|>
literal|0
condition|)
name|free_ppods
argument_list|(
name|td
argument_list|,
name|db
operator|->
name|ppod_addr
argument_list|,
name|db
operator|->
name|nppods
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|release_ddp_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free_ddp_buffer
argument_list|(
name|toep
operator|->
name|td
argument_list|,
name|toep
operator|->
name|db
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* XXX: handle_ddp_data code duplication */
end_comment

begin_function
name|void
name|insert_ddp_data
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|inp
operator|->
name|inp_socket
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|m
operator|=
name|get_ddp_mbuf
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|n
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_DDP_RX_FLOW_CONTROL
name|KASSERT
argument_list|(
name|tp
operator|->
name|rcv_wnd
operator|>=
name|n
argument_list|,
operator|(
literal|"%s: negative window size"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|-=
name|n
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|toep
operator|->
name|sb_cc
operator|>=
name|sbused
argument_list|(
name|sb
argument_list|)
argument_list|,
operator|(
literal|"%s: sb %p has more data (%d) than last time (%d)."
operator|,
name|__func__
operator|,
name|sb
operator|,
name|sbused
argument_list|(
name|sb
argument_list|)
operator|,
name|toep
operator|->
name|sb_cc
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|+=
name|toep
operator|->
name|sb_cc
operator|-
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DDP_RX_FLOW_CONTROL
name|toep
operator|->
name|rx_credits
operator|-=
name|n
expr_stmt|;
comment|/* adjust for F_RX_FC_DDP */
endif|#
directive|endif
name|sbappendstream_locked
argument_list|(
name|sb
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|sb_cc
operator|=
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SET_TCB_FIELD sent as a ULP command looks like this */
end_comment

begin_define
define|#
directive|define
name|LEN__SET_TCB_FIELD_ULP
value|(sizeof(struct ulp_txpkt) + \     sizeof(struct ulptx_idata) + sizeof(struct cpl_set_tcb_field_core))
end_define

begin_comment
comment|/* RX_DATA_ACK sent as a ULP command looks like this */
end_comment

begin_define
define|#
directive|define
name|LEN__RX_DATA_ACK_ULP
value|(sizeof(struct ulp_txpkt) + \     sizeof(struct ulptx_idata) + sizeof(struct cpl_rx_data_ack_core))
end_define

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mk_set_tcb_field_ulp
parameter_list|(
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|uint64_t
name|word
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|cpl_set_tcb_field_core
modifier|*
name|req
decl_stmt|;
name|ulpmc
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_PKT
argument_list|)
operator||
name|V_ULP_TXPKT_DEST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|howmany
argument_list|(
name|LEN__SET_TCB_FIELD_ULP
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|cpl_set_tcb_field_core
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
name|toep
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply_ctrl
operator|=
name|htobe16
argument_list|(
name|V_NO_REPLY
argument_list|(
literal|1
argument_list|)
operator||
name|V_QUEUENO
argument_list|(
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|word_cookie
operator|=
name|htobe16
argument_list|(
name|V_WORD
argument_list|(
name|word
argument_list|)
operator||
name|V_COOKIE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|LEN__SET_TCB_FIELD_ULP
operator|%
literal|16
condition|)
block|{
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_NOOP
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ulpsc
operator|+
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ulpsc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mk_rx_data_ack_ulp
parameter_list|(
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|cpl_rx_data_ack_core
modifier|*
name|req
decl_stmt|;
name|ulpmc
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_PKT
argument_list|)
operator||
name|V_ULP_TXPKT_DEST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|howmany
argument_list|(
name|LEN__RX_DATA_ACK_ULP
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|cpl_rx_data_ack_core
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RX_DATA_ACK
argument_list|,
name|toep
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|credit_dack
operator|=
name|htobe32
argument_list|(
name|F_RX_MODULATE_RX
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|LEN__RX_DATA_ACK_ULP
operator|%
literal|16
condition|)
block|{
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_NOOP
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ulpsc
operator|+
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ulpsc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|select_ddp_flags
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|db_idx
parameter_list|)
block|{
name|uint64_t
name|ddp_flags
init|=
name|V_TF_DDP_INDICATE_OUT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|waitall
init|=
name|flags
operator|&
name|MSG_WAITALL
decl_stmt|;
name|int
name|nb
init|=
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|||
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
decl_stmt|;
name|KASSERT
argument_list|(
name|db_idx
operator|==
literal|0
operator|||
name|db_idx
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: bad DDP buffer index %d"
operator|,
name|__func__
operator|,
name|db_idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_idx
operator|==
literal|0
condition|)
block|{
name|ddp_flags
operator||=
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitall
condition|)
name|ddp_flags
operator||=
name|V_TF_DDP_PUSH_DISABLE_0
argument_list|(
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nb
condition|)
name|ddp_flags
operator||=
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|ddp_flags
operator||=
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ddp_flags
operator||=
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitall
condition|)
name|ddp_flags
operator||=
name|V_TF_DDP_PUSH_DISABLE_1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nb
condition|)
name|ddp_flags
operator||=
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|ddp_flags
operator||=
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ddp_flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wrqe
modifier|*
name|mk_update_tcb_for_ddp
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|db_idx
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint64_t
name|ddp_flags
parameter_list|)
block|{
name|struct
name|ddp_buffer
modifier|*
name|db
init|=
name|toep
operator|->
name|db
index|[
name|db_idx
index|]
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrh
decl_stmt|;
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|KASSERT
argument_list|(
name|db_idx
operator|==
literal|0
operator|||
name|db_idx
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: bad DDP buffer index %d"
operator|,
name|__func__
operator|,
name|db_idx
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We'll send a compound work request that has 3 SET_TCB_FIELDs and an 	 * RX_DATA_ACK (with RX_MODULATE to speed up delivery). 	 * 	 * The work request header is 16B and always ends at a 16B boundary. 	 * The ULPTX master commands that follow must all end at 16B boundaries 	 * too so we round up the size to 16. 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wrh
argument_list|)
operator|+
literal|3
operator|*
name|roundup2
argument_list|(
name|LEN__SET_TCB_FIELD_ULP
argument_list|,
literal|16
argument_list|)
operator|+
name|roundup2
argument_list|(
name|LEN__RX_DATA_ACK_ULP
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|len
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|wrh
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_ULPTX_WRH
argument_list|(
name|wrh
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* atomic */
name|ulpmc
operator|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
operator|(
name|wrh
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Write the buffer's tag */
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF0_TAG
operator|+
name|db_idx
argument_list|,
name|V_TCB_RX_DDP_BUF0_TAG
argument_list|(
name|M_TCB_RX_DDP_BUF0_TAG
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF0_TAG
argument_list|(
name|db
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the current offset in the DDP buffer and its total length */
if|if
condition|(
name|db_idx
operator|==
literal|0
condition|)
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF0_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF0_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF0_LEN
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
name|offset
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
name|db
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF1_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF1_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
operator|(
name|u64
operator|)
name|M_TCB_RX_DDP_BUF1_LEN
operator|<<
literal|32
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
name|offset
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
operator|(
name|u64
operator|)
name|db
operator|->
name|len
operator|<<
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update DDP flags */
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_INDICATE_OUT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ddp_flags
argument_list|)
expr_stmt|;
comment|/* Gratuitous RX_DATA_ACK with RX_MODULATE set to speed up delivery. */
name|ulpmc
operator|=
name|mk_rx_data_ack_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|wr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|discourage_ddp
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
if|if
condition|(
name|toep
operator|->
name|ddp_score
operator|&&
operator|--
name|toep
operator|->
name|ddp_score
operator|==
literal|0
condition|)
block|{
name|toep
operator|->
name|ddp_flags
operator|&=
operator|~
name|DDP_OK
expr_stmt|;
name|toep
operator|->
name|ddp_disabled
operator|=
name|time_uptime
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u !DDP_OK @ %u"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|time_uptime
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|handle_ddp_data
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|__be32
name|ddp_report
parameter_list|,
name|__be32
name|rcv_nxt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|uint32_t
name|report
init|=
name|be32toh
argument_list|(
name|ddp_report
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|db_flag
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|db_flag
operator|=
name|report
operator|&
name|F_DDP_BUF_IDX
condition|?
name|DDP_BUF1_ACTIVE
else|:
name|DDP_BUF0_ACTIVE
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|report
operator|&
name|F_DDP_INV
operator|)
argument_list|)
condition|)
name|CXGBE_UNIMPLEMENTED
argument_list|(
literal|"DDP buffer still valid"
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_DROPPED
operator||
name|INP_TIMEWAIT
operator|)
argument_list|)
condition|)
block|{
comment|/* 		 * XXX: think a bit more. 		 * tcpcb probably gone, but socket should still be around 		 * because we always wait for DDP completion in soreceive no 		 * matter what.  Just wake it up and let it clean up. 		 */
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, seq 0x%x, len %d, inp_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|be32toh
argument_list|(
name|rcv_nxt
argument_list|)
argument_list|,
name|len
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|wakeup
goto|;
block|}
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * For RX_DDP_COMPLETE, len will be zero and rcv_nxt is the 	 * sequence number of the next byte to receive.  The length of 	 * the data received for this message must be computed by 	 * comparing the new and old values of rcv_nxt. 	 *  	 * For RX_DATA_DDP, len might be non-zero, but it is only the 	 * length of the most recent DMA.  It does not include the 	 * total length of the data received since the previous update 	 * for this DDP buffer.  rcv_nxt is the sequence number of the 	 * first received byte from the most recent DMA. 	 */
name|len
operator|+=
name|be32toh
argument_list|(
name|rcv_nxt
argument_list|)
operator|-
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|len
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_DDP_RX_FLOW_CONTROL
name|KASSERT
argument_list|(
name|tp
operator|->
name|rcv_wnd
operator|>=
name|len
argument_list|,
operator|(
literal|"%s: negative window size"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|-=
name|len
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|get_ddp_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|report
operator|&
name|F_DDP_BUF_COMPLETE
condition|)
name|toep
operator|->
name|ddp_score
operator|=
name|DDP_HIGH_SCORE
expr_stmt|;
else|else
name|discourage_ddp
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* receive buffer autosize */
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|&&
name|V_tcp_do_autorcvbuf
operator|&&
name|sb
operator|->
name|sb_hiwat
operator|<
name|V_tcp_autorcvbuf_max
operator|&&
name|len
operator|>
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|/
literal|8
operator|*
literal|7
operator|)
condition|)
block|{
name|unsigned
name|int
name|hiwat
init|=
name|sb
operator|->
name|sb_hiwat
decl_stmt|;
name|unsigned
name|int
name|newsize
init|=
name|min
argument_list|(
name|hiwat
operator|+
name|V_tcp_autorcvbuf_inc
argument_list|,
name|V_tcp_autorcvbuf_max
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sbreserve_locked
argument_list|(
name|sb
argument_list|,
name|newsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
condition|)
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
else|else
name|toep
operator|->
name|rx_credits
operator|+=
name|newsize
operator|-
name|hiwat
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|toep
operator|->
name|sb_cc
operator|>=
name|sbused
argument_list|(
name|sb
argument_list|)
argument_list|,
operator|(
literal|"%s: sb %p has more data (%d) than last time (%d)."
operator|,
name|__func__
operator|,
name|sb
operator|,
name|sbused
argument_list|(
name|sb
argument_list|)
operator|,
name|toep
operator|->
name|sb_cc
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|+=
name|toep
operator|->
name|sb_cc
operator|-
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DDP_RX_FLOW_CONTROL
name|toep
operator|->
name|rx_credits
operator|-=
name|len
expr_stmt|;
comment|/* adjust for F_RX_FC_DDP */
endif|#
directive|endif
name|sbappendstream_locked
argument_list|(
name|sb
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|sb_cc
operator|=
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|wakeup
label|:
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_flags
operator|&
name|db_flag
argument_list|,
operator|(
literal|"%s: DDP buffer not active. toep %p, ddp_flags 0x%x, report 0x%x"
operator|,
name|__func__
operator|,
name|toep
operator|,
name|toep
operator|->
name|ddp_flags
operator|,
name|report
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator|&=
operator|~
name|db_flag
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|handle_ddp_close
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|__be32
name|rcv_nxt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|toep
operator|->
name|inp
argument_list|)
expr_stmt|;
name|len
operator|=
name|be32toh
argument_list|(
name|rcv_nxt
argument_list|)
operator|-
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
comment|/* Signal handle_ddp() to break out of its sleep loop. */
name|toep
operator|->
name|ddp_flags
operator|&=
operator|~
operator|(
name|DDP_BUF0_ACTIVE
operator||
name|DDP_BUF1_ACTIVE
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|len
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|sb_cc
operator|>=
name|sbused
argument_list|(
name|sb
argument_list|)
argument_list|,
operator|(
literal|"%s: sb %p has more data (%d) than last time (%d)."
operator|,
name|__func__
operator|,
name|sb
operator|,
name|sbused
argument_list|(
name|sb
argument_list|)
operator|,
name|toep
operator|->
name|sb_cc
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|+=
name|toep
operator|->
name|sb_cc
operator|-
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DDP_RX_FLOW_CONTROL
name|toep
operator|->
name|rx_credits
operator|-=
name|len
expr_stmt|;
comment|/* adjust for F_RX_FC_DDP */
endif|#
directive|endif
name|m
operator|=
name|get_ddp_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sbappendstream_locked
argument_list|(
name|sb
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|sb_cc
operator|=
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DDP_ERR
value|(F_DDP_PPOD_MISMATCH | F_DDP_LLIMIT_ERR | F_DDP_ULIMIT_ERR |\ 	 F_DDP_PPOD_PARITY_ERR | F_DDP_PADDING_ERR | F_DDP_OFFSET_ERR |\ 	 F_DDP_INVALID_TAG | F_DDP_COLOR_ERR | F_DDP_TID_MISMATCH |\ 	 F_DDP_INVALID_PPOD | F_DDP_HDRCRC_ERR | F_DDP_DATACRC_ERR)
end_define

begin_function
specifier|static
name|int
name|do_rx_data_ddp
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_data_ddp
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|uint32_t
name|vld
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
operator|)
argument_list|,
operator|(
literal|"%s: toep %p claims to be a synq entry"
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|vld
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|ddpvld
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|vld
operator|&
name|DDP_ERR
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: DDP error 0x%x (tid %d, toep %p)"
argument_list|,
name|__func__
argument_list|,
name|vld
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_ISCSI
condition|)
block|{
name|sc
operator|->
name|cpl_handler
index|[
name|CPL_RX_ISCSI_DDP
index|]
operator|(
name|iq
operator|,
name|rss
operator|,
name|m
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|handle_ddp_data
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|u
operator|.
name|ddp_report
argument_list|,
name|cpl
operator|->
name|seq
argument_list|,
name|be16toh
argument_list|(
name|cpl
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_rx_ddp_complete
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_ddp_complete
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
operator|)
argument_list|,
operator|(
literal|"%s: toep %p claims to be a synq entry"
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|handle_ddp_data
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|ddp_report
argument_list|,
name|cpl
operator|->
name|rcv_nxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|enable_ddp
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
operator|(
name|DDP_ON
operator||
name|DDP_OK
operator||
name|DDP_SC_REQ
operator|)
operator|)
operator|==
name|DDP_OK
argument_list|,
operator|(
literal|"%s: toep %p has bad ddp_flags 0x%x"
operator|,
name|__func__
operator|,
name|toep
operator|,
name|toep
operator|->
name|ddp_flags
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u (time %u)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|time_uptime
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator||=
name|DDP_SC_REQ
expr_stmt|;
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|1
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_INDICATE_OUT
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_INDICATE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_INDICATE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_BUF0_INDICATE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_INDICATE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|1
argument_list|,
name|W_TCB_T_FLAGS
argument_list|,
name|V_TF_RCV_COALESCE_ENABLE
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|disable_ddp
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
operator|(
name|DDP_ON
operator||
name|DDP_SC_REQ
operator|)
operator|)
operator|==
name|DDP_ON
argument_list|,
operator|(
literal|"%s: toep %p has bad ddp_flags 0x%x"
operator|,
name|__func__
operator|,
name|toep
operator|,
name|toep
operator|->
name|ddp_flags
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u (time %u)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|time_uptime
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator||=
name|DDP_SC_REQ
expr_stmt|;
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|1
argument_list|,
name|W_TCB_T_FLAGS
argument_list|,
name|V_TF_RCV_COALESCE_ENABLE
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_RCV_COALESCE_ENABLE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|1
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hold_uio
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|vm_page_t
modifier|*
modifier|*
name|ppages
parameter_list|,
name|int
modifier|*
name|pnpages
parameter_list|)
block|{
name|struct
name|vm_map
modifier|*
name|map
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|vm_page_t
modifier|*
name|pp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|KASSERT
argument_list|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: uio_iovcnt %d"
operator|,
name|__func__
operator|,
name|uio
operator|->
name|uio_iovcnt
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
operator|==
name|curproc
argument_list|,
operator|(
literal|"%s: uio proc (%p) is not curproc (%p)"
operator|,
name|__func__
operator|,
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
operator|,
name|curproc
operator|)
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|iov
operator|=
operator|&
name|uio
operator|->
name|uio_iov
index|[
literal|0
index|]
expr_stmt|;
name|start
operator|=
name|trunc_page
argument_list|(
operator|(
name|uintptr_t
operator|)
name|iov
operator|->
name|iov_base
argument_list|)
expr_stmt|;
name|end
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|iov
operator|->
name|iov_base
operator|+
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
name|n
operator|=
name|howmany
argument_list|(
name|end
operator|-
name|start
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|start
operator|>
name|MAX_DDP_BUFFER_SIZE
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
name|pp
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|vm_fault_quick_hold_pages
argument_list|(
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|iov
operator|->
name|iov_base
argument_list|,
name|iov
operator|->
name|iov_len
argument_list|,
name|VM_PROT_WRITE
argument_list|,
name|pp
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|pp
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
operator|*
name|ppages
operator|=
name|pp
expr_stmt|;
operator|*
name|pnpages
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bufcmp
parameter_list|(
name|struct
name|ddp_buffer
modifier|*
name|db
parameter_list|,
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|db
operator|->
name|npages
operator|!=
name|npages
operator|||
name|db
operator|->
name|offset
operator|!=
name|offset
operator|||
name|db
operator|->
name|len
operator|!=
name|len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pages
index|[
name|i
index|]
operator|->
name|phys_addr
operator|!=
name|db
operator|->
name|pages
index|[
name|i
index|]
operator|->
name|phys_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|calculate_hcf
parameter_list|(
name|int
name|n1
parameter_list|,
name|int
name|n2
parameter_list|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|n1
operator|<=
name|n2
condition|)
block|{
name|a
operator|=
name|n1
expr_stmt|;
name|b
operator|=
name|n2
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|n2
expr_stmt|;
name|b
operator|=
name|n1
expr_stmt|;
block|}
while|while
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|t
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
operator|%
name|a
expr_stmt|;
name|b
operator|=
name|t
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ddp_buffer
modifier|*
name|alloc_ddp_buffer
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|hcf
decl_stmt|,
name|seglen
decl_stmt|,
name|idx
decl_stmt|,
name|ppod
decl_stmt|,
name|nppods
decl_stmt|;
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
comment|/* 	 * The DDP page size is unrelated to the VM page size.  We combine 	 * contiguous physical pages into larger segments to get the best DDP 	 * page size possible.  This is the largest of the four sizes in 	 * A_ULP_RX_TDDP_PSZ that evenly divides the HCF of the segment sizes in 	 * the page list. 	 */
name|hcf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|seglen
operator|=
name|PAGE_SIZE
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|npages
operator|-
literal|1
operator|&&
name|pages
index|[
name|i
index|]
operator|->
name|phys_addr
operator|+
name|PAGE_SIZE
operator|==
name|pages
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|phys_addr
condition|)
block|{
name|seglen
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|hcf
operator|=
name|calculate_hcf
argument_list|(
name|hcf
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hcf
operator|<
name|t4_ddp_pgsz
index|[
literal|1
index|]
condition|)
block|{
name|idx
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_pgsz
goto|;
comment|/* give up, short circuit */
block|}
block|}
if|if
condition|(
name|hcf
operator|%
name|t4_ddp_pgsz
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* hmmm.  This could only happen when PAGE_SIZE< 4K */
name|KASSERT
argument_list|(
name|PAGE_SIZE
operator|<
literal|4096
argument_list|,
operator|(
literal|"%s: PAGE_SIZE %d, hcf %d"
operator|,
name|__func__
operator|,
name|PAGE_SIZE
operator|,
name|hcf
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: PAGE_SIZE %d, hcf %d"
argument_list|,
name|__func__
argument_list|,
name|PAGE_SIZE
argument_list|,
name|hcf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|idx
operator|=
name|nitems
argument_list|(
name|t4_ddp_pgsz
argument_list|)
operator|-
literal|1
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
block|{
if|if
condition|(
name|hcf
operator|%
name|t4_ddp_pgsz
index|[
name|idx
index|]
operator|==
literal|0
condition|)
break|break;
block|}
name|have_pgsz
label|:
name|MPASS
argument_list|(
name|idx
operator|<=
name|M_PPOD_PGSZ
argument_list|)
expr_stmt|;
name|db
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: malloc failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nppods
operator|=
name|pages_to_nppods
argument_list|(
name|npages
argument_list|,
name|t4_ddp_pgsz
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_ppods
argument_list|(
name|td
argument_list|,
name|nppods
argument_list|,
operator|&
name|db
operator|->
name|ppod_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|db
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: no pods, nppods %d, resid %d, pgsz %d"
argument_list|,
name|__func__
argument_list|,
name|nppods
argument_list|,
name|len
argument_list|,
name|t4_ddp_pgsz
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ppod
operator|=
operator|(
name|db
operator|->
name|ppod_addr
operator|-
name|td
operator|->
name|ppod_start
operator|)
operator|/
name|PPOD_SIZE
expr_stmt|;
name|db
operator|->
name|tag
operator|=
name|V_PPOD_PGSZ
argument_list|(
name|idx
argument_list|)
operator||
name|V_PPOD_TAG
argument_list|(
name|ppod
argument_list|)
expr_stmt|;
name|db
operator|->
name|nppods
operator|=
name|nppods
expr_stmt|;
name|db
operator|->
name|npages
operator|=
name|npages
expr_stmt|;
name|db
operator|->
name|pages
operator|=
name|pages
expr_stmt|;
name|db
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|db
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"New DDP buffer.  "
literal|"ddp_pgsz %d, ppod 0x%x, npages %d, nppods %d, offset %d, len %d"
argument_list|,
name|t4_ddp_pgsz
index|[
name|idx
index|]
argument_list|,
name|ppod
argument_list|,
name|db
operator|->
name|npages
argument_list|,
name|db
operator|->
name|nppods
argument_list|,
name|db
operator|->
name|offset
argument_list|,
name|db
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|db
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NUM_ULP_TX_SC_IMM_PPODS
value|(256 / PPOD_SIZE)
end_define

begin_function
specifier|static
name|int
name|write_page_pods
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|ddp_buffer
modifier|*
name|db
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|ulp_mem_io
modifier|*
name|ulpmc
decl_stmt|;
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|pagepod
modifier|*
name|ppod
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|chunk
decl_stmt|,
name|len
decl_stmt|,
name|ddp_pgsz
decl_stmt|,
name|idx
decl_stmt|;
name|u_int
name|ppod_addr
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_MEM_WRITE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
name|cmd
operator||=
name|htobe32
argument_list|(
name|F_ULP_MEMIO_ORDER
argument_list|)
expr_stmt|;
else|else
name|cmd
operator||=
name|htobe32
argument_list|(
name|F_T5_ULP_MEMIO_IMM
argument_list|)
expr_stmt|;
name|ddp_pgsz
operator|=
name|t4_ddp_pgsz
index|[
name|G_PPOD_PGSZ
argument_list|(
name|db
operator|->
name|tag
argument_list|)
index|]
expr_stmt|;
name|ppod_addr
operator|=
name|db
operator|->
name|ppod_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|db
operator|->
name|nppods
condition|;
name|ppod_addr
operator|+=
name|chunk
control|)
block|{
comment|/* How many page pods are we writing in this cycle */
name|n
operator|=
name|min
argument_list|(
name|db
operator|->
name|nppods
operator|-
name|i
argument_list|,
name|NUM_ULP_TX_SC_IMM_PPODS
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|PPOD_SZ
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|len
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ulpmc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ulpsc
argument_list|)
operator|+
name|chunk
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|len
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* ok to just bail out */
name|ulpmc
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_ULPTX_WR
argument_list|(
name|ulpmc
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|ulpmc
operator|->
name|dlen
operator|=
name|htobe32
argument_list|(
name|V_ULP_MEMIO_DATA_LEN
argument_list|(
name|chunk
operator|/
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len16
operator|=
name|htobe32
argument_list|(
name|howmany
argument_list|(
name|len
operator|-
sizeof|sizeof
argument_list|(
name|ulpmc
operator|->
name|wr
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|lock_addr
operator|=
name|htobe32
argument_list|(
name|V_ULP_MEMIO_ADDR
argument_list|(
name|ppod_addr
operator|>>
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|ppod
operator|=
operator|(
expr|struct
name|pagepod
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|j
operator|++
operator|,
name|ppod
operator|++
control|)
block|{
name|ppod
operator|->
name|vld_tid_pgsz_tag_color
operator|=
name|htobe64
argument_list|(
name|F_PPOD_VALID
operator||
name|V_PPOD_TID
argument_list|(
name|toep
operator|->
name|tid
argument_list|)
operator||
name|db
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ppod
operator|->
name|len_offset
operator|=
name|htobe64
argument_list|(
name|V_PPOD_LEN
argument_list|(
name|db
operator|->
name|len
argument_list|)
operator||
name|V_PPOD_OFST
argument_list|(
name|db
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|ppod
operator|->
name|rsvd
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|i
operator|*
name|PPOD_PAGES
operator|*
operator|(
name|ddp_pgsz
operator|/
name|PAGE_SIZE
operator|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nitems
argument_list|(
name|ppod
operator|->
name|addr
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|<
name|db
operator|->
name|npages
condition|)
block|{
name|ppod
operator|->
name|addr
index|[
name|k
index|]
operator|=
name|htobe64
argument_list|(
name|db
operator|->
name|pages
index|[
name|idx
index|]
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|ddp_pgsz
operator|/
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
name|ppod
operator|->
name|addr
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|CTR5(KTR_CXGBE, 				    "%s: tid %d ppod[%d]->addr[%d] = %p", 				    __func__, toep->tid, i, k, 				    htobe64(ppod->addr[k]));
endif|#
directive|endif
block|}
block|}
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reuse, or allocate (and program the page pods for) a new DDP buffer.  The  * "pages" array is handed over to this function and should not be used in any  * way by the caller after that.  */
end_comment

begin_function
specifier|static
name|int
name|select_ddp_buffer
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|db_off
parameter_list|,
name|int
name|db_len
parameter_list|)
block|{
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|empty_slot
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Try to reuse */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bufcmp
argument_list|(
name|toep
operator|->
name|db
index|[
name|i
index|]
argument_list|,
name|pages
argument_list|,
name|npages
argument_list|,
name|db_off
argument_list|,
name|db_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|pages
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
comment|/* pages still held */
block|}
elseif|else
if|if
condition|(
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|empty_slot
operator|<
literal|0
condition|)
name|empty_slot
operator|=
name|i
expr_stmt|;
block|}
comment|/* Allocate new buffer, write its page pods. */
name|db
operator|=
name|alloc_ddp_buffer
argument_list|(
name|td
argument_list|,
name|pages
argument_list|,
name|npages
argument_list|,
name|db_off
argument_list|,
name|db_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|vm_page_unhold_pages
argument_list|(
name|pages
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pages
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|write_page_pods
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|db
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vm_page_unhold_pages
argument_list|(
name|pages
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|free_ddp_buffer
argument_list|(
name|td
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|=
name|empty_slot
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|arc4random
argument_list|()
operator|%
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
expr_stmt|;
name|free_ddp_buffer
argument_list|(
name|td
argument_list|,
name|toep
operator|->
name|db
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|=
name|db
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d, DDP buffer[%d] = %p (tag 0x%x)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|i
argument_list|,
name|db
argument_list|,
name|db
operator|->
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wire_ddp_buffer
parameter_list|(
name|struct
name|ddp_buffer
modifier|*
name|db
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|db
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|db
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unhold
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unwire_ddp_buffer
parameter_list|(
name|struct
name|ddp_buffer
modifier|*
name|db
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|db
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|db
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|p
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|handle_ddp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|td_adapter
argument_list|(
name|toep
operator|->
name|td
argument_list|)
decl_stmt|;
name|vm_page_t
modifier|*
name|pages
decl_stmt|;
name|int
name|npages
decl_stmt|,
name|db_idx
decl_stmt|,
name|rc
decl_stmt|,
name|buf_flag
decl_stmt|;
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|uint64_t
name|ddp_flags
decl_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (sbused(sb) + sc->tt.ddp_thres> uio->uio_resid) { 		CTR4(KTR_CXGBE, "%s: sb_cc %d, threshold %d, resid %d", 		    __func__, sbused(sb), sc->tt.ddp_thres, uio->uio_resid); 	}
endif|#
directive|endif
comment|/* XXX: too eager to disable DDP, could handle NBIO better than this. */
if|if
condition|(
name|sbused
argument_list|(
name|sb
argument_list|)
operator|>=
name|uio
operator|->
name|uio_resid
operator|||
name|uio
operator|->
name|uio_resid
operator|<
name|sc
operator|->
name|tt
operator|.
name|ddp_thres
operator|||
name|uio
operator|->
name|uio_resid
operator|>
name|MAX_DDP_BUFFER_SIZE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|>
literal|1
operator|||
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|||
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|||
name|error
operator|||
name|so
operator|->
name|so_error
operator|||
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
goto|goto
name|no_ddp
goto|;
comment|/* 	 * Fault in and then hold the pages of the uio buffers.  We'll wire them 	 * a bit later if everything else works out. 	 */
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|hold_uio
argument_list|(
name|uio
argument_list|,
operator|&
name|pages
argument_list|,
operator|&
name|npages
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|no_ddp
goto|;
block|}
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|so
operator|->
name|so_error
operator|||
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
argument_list|)
condition|)
block|{
name|vm_page_unhold_pages
argument_list|(
name|pages
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pages
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
goto|goto
name|no_ddp
goto|;
block|}
comment|/* 	 * Figure out which one of the two DDP buffers to use this time. 	 */
name|db_idx
operator|=
name|select_ddp_buffer
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|pages
argument_list|,
name|npages
argument_list|,
operator|(
name|uintptr_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|&
name|PAGE_MASK
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|pages
operator|=
name|NULL
expr_stmt|;
comment|/* handed off to select_ddp_buffer */
if|if
condition|(
name|db_idx
operator|<
literal|0
condition|)
goto|goto
name|no_ddp
goto|;
name|db
operator|=
name|toep
operator|->
name|db
index|[
name|db_idx
index|]
expr_stmt|;
name|buf_flag
operator|=
name|db_idx
operator|==
literal|0
condition|?
name|DDP_BUF0_ACTIVE
else|:
name|DDP_BUF1_ACTIVE
expr_stmt|;
comment|/* 	 * Build the compound work request that tells the chip where to DMA the 	 * payload. 	 */
name|ddp_flags
operator|=
name|select_ddp_flags
argument_list|(
name|so
argument_list|,
name|flags
argument_list|,
name|db_idx
argument_list|)
expr_stmt|;
name|wr
operator|=
name|mk_update_tcb_for_ddp
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|db_idx
argument_list|,
name|sbused
argument_list|(
name|sb
argument_list|)
argument_list|,
name|ddp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Just unhold the pages.  The DDP buffer's software state is 		 * left as-is in the toep.  The page pods were written 		 * successfully and we may have an opportunity to use it in the 		 * future. 		 */
name|vm_page_unhold_pages
argument_list|(
name|db
operator|->
name|pages
argument_list|,
name|db
operator|->
name|npages
argument_list|)
expr_stmt|;
goto|goto
name|no_ddp
goto|;
block|}
comment|/* Wire (and then unhold) the pages, and give the chip the go-ahead. */
name|wire_ddp_buffer
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_DDP_INDICATE
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator||=
name|buf_flag
expr_stmt|;
comment|/* 	 * Wait for the DDP operation to complete and then unwire the pages. 	 * The return code from the sbwait will be the final return code of this 	 * function.  But we do need to wait for DDP no matter what. 	 */
name|rc
operator|=
name|sbwait
argument_list|(
name|sb
argument_list|)
expr_stmt|;
while|while
condition|(
name|toep
operator|->
name|ddp_flags
operator|&
name|buf_flag
condition|)
block|{
comment|/* XXXGL: shouldn't here be sbwait() call? */
name|sb
operator|->
name|sb_flags
operator||=
name|SB_WAIT
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|sb
operator|->
name|sb_acc
argument_list|,
operator|&
name|sb
operator|->
name|sb_mtx
argument_list|,
name|PSOCK
argument_list|,
literal|"sbwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|unwire_ddp_buffer
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
name|no_ddp
label|:
name|disable_ddp
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|discourage_ddp
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_DDP_INDICATE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_init_ddp
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|tom_data
modifier|*
name|td
parameter_list|)
block|{
name|td
operator|->
name|ppod_start
operator|=
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|start
expr_stmt|;
name|td
operator|->
name|ppod_arena
operator|=
name|vmem_create
argument_list|(
literal|"DDP page pods"
argument_list|,
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|start
argument_list|,
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|size
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|,
name|M_FIRSTFIT
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RX_DATA_DDP
argument_list|,
name|do_rx_data_ddp
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RX_DDP_COMPLETE
argument_list|,
name|do_rx_ddp_complete
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_uninit_ddp
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
name|__unused
parameter_list|,
name|struct
name|tom_data
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|td
operator|->
name|ppod_arena
operator|!=
name|NULL
condition|)
block|{
name|vmem_destroy
argument_list|(
name|td
operator|->
name|ppod_arena
argument_list|)
expr_stmt|;
name|td
operator|->
name|ppod_arena
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|VNET_SO_ASSERT
parameter_list|(
name|so
parameter_list|)
define|\
value|VNET_ASSERT(curvnet != NULL,					\ 	    ("%s:%d curvnet is NULL, so=%p", __func__, __LINE__, (so)));
end_define

begin_define
define|#
directive|define
name|SBLOCKWAIT
parameter_list|(
name|f
parameter_list|)
value|(((f)& MSG_DONTWAIT) ? 0 : SBL_WAIT)
end_define

begin_function
specifier|static
name|int
name|soreceive_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|CXGBE_UNIMPLEMENTED
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|ddp_magic_str
index|[]
init|=
literal|"nothing to see here"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|get_ddp_mbuf
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|CXGBE_UNIMPLEMENTED
argument_list|(
literal|"mbuf alloc failure"
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|&
name|ddp_magic_str
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_ddp_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|m
operator|->
name|m_data
operator|==
operator|&
name|ddp_magic_str
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy an mbuf chain into a uio limited by len if set.  */
end_comment

begin_function
specifier|static
name|int
name|m_mbuftouio_ddp
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|length
decl_stmt|,
name|total
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|total
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|total
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* Fill the uio with data from the mbufs. */
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|length
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|total
operator|-
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ddp_mbuf
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|enum
name|uio_seg
name|segflag
init|=
name|uio
operator|->
name|uio_segflg
decl_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_NOCOPY
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|segflag
expr_stmt|;
block|}
else|else
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|progress
operator|+=
name|length
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Based on soreceive_stream() in uipc_socket.c  */
end_comment

begin_function
name|int
name|t4_soreceive_ddp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|,
name|oresid
decl_stmt|,
name|ddp_handled
init|=
literal|0
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
comment|/* We only do stream sockets. */
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
name|flags
operator|=
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
return|return
operator|(
name|soreceive_rcvoob
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
if|if
condition|(
name|mp0
operator|!=
name|NULL
condition|)
operator|*
name|mp0
operator|=
name|NULL
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
comment|/* Prevent other readers from entering the socket. */
name|error
operator|=
name|sblock
argument_list|(
name|sb
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Easy one, no space to copyout anything. */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|oresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* We will never ever get anything unless we are or were connected. */
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTED
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|restart
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_DDP_INDICATE
operator|&&
operator|!
name|ddp_handled
condition|)
block|{
comment|/* uio should be just as it was at entry */
name|KASSERT
argument_list|(
name|oresid
operator|==
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
literal|"%s: oresid = %d, uio_resid = %zd, sbavail = %d"
operator|,
name|__func__
operator|,
name|oresid
operator|,
name|uio
operator|->
name|uio_resid
operator|,
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|handle_ddp
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ddp_handled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Abort if socket has reported problems. */
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
condition|)
goto|goto
name|deliver
goto|;
if|if
condition|(
name|oresid
operator|>
name|uio
operator|->
name|uio_resid
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Door is closed.  Deliver what is left, if any. */
if|if
condition|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
condition|)
goto|goto
name|deliver
goto|;
else|else
goto|goto
name|out
goto|;
block|}
comment|/* Socket buffer is empty and we shall not block. */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Socket buffer got some data that we shall deliver now. */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
operator|&&
operator|!
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_lowat
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|uio
operator|->
name|uio_resid
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_hiwat
operator|)
condition|)
block|{
goto|goto
name|deliver
goto|;
block|}
comment|/* On MSG_WAITALL we must wait until all data or error arrives. */
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
operator|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|uio
operator|->
name|uio_resid
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_lowat
operator|)
condition|)
goto|goto
name|deliver
goto|;
comment|/* 	 * Wait and block until (more) data comes in. 	 * NB: Drops the sockbuf lock during wait. 	 */
name|error
operator|=
name|sbwait
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_DDP_INDICATE
operator|&&
operator|!
name|ddp_handled
condition|)
block|{
operator|(
name|void
operator|)
name|handle_ddp
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ddp_handled
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
goto|goto
name|restart
goto|;
name|deliver
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: sockbuf empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: sb_mb == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_DDP_INDICATE
operator|&&
operator|!
name|ddp_handled
condition|)
goto|goto
name|restart
goto|;
comment|/* Statistics. */
if|if
condition|(
name|uio
operator|->
name|uio_td
condition|)
name|uio
operator|->
name|uio_td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
operator|++
expr_stmt|;
comment|/* Fill uio until full or current end of socket buffer is reached. */
name|len
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|sbavail
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp0
operator|!=
name|NULL
condition|)
block|{
comment|/* Dequeue as many mbufs as possible. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|&&
name|len
operator|>=
name|sb
operator|->
name|sb_mb
operator|->
name|m_len
condition|)
block|{
for|for
control|(
operator|*
name|mp0
operator|=
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_len
operator|<=
name|len
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|sbfree
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
name|m
expr_stmt|;
block|}
name|sb
operator|->
name|sb_mb
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|==
name|NULL
condition|)
name|SB_EMPTY_FIXUP
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Copy the remainder. */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: len> 0&& sb->sb_mb empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Don't flush data from sockbuf. */
else|else
name|uio
operator|->
name|uio_resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|*
name|mp0
operator|!=
name|NULL
condition|)
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
else|else
operator|*
name|mp0
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|*
name|mp0
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* NB: Must unlock socket buffer as uiomove may sleep. */
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|m_mbuftouio_ddp
argument_list|(
name|uio
argument_list|,
name|sb
operator|->
name|sb_mb
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|SBLASTRECORDCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the delivered data from the socket buffer unless we 	 * were only peeking. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|sbdrop_locked
argument_list|(
name|sb
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Notify protocol that we drained some data. */
if|if
condition|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
operator|)
operator|&&
operator|(
operator|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|MSG_SOCALLBCK
operator|)
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For MSG_WAITALL we may have to loop again and wait for 	 * more data to come in. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
goto|goto
name|restart
goto|;
name|out
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

