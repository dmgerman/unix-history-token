begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/aio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_tcb.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_do_autorcvbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_autorcvbuf
value|VNET(tcp_do_autorcvbuf)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_inc
value|VNET(tcp_autorcvbuf_inc)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_max
value|VNET(tcp_autorcvbuf_max)
end_define

begin_comment
comment|/*  * Use the 'backend3' field in AIO jobs to store the amount of data  * received by the AIO job so far.  */
end_comment

begin_define
define|#
directive|define
name|aio_received
value|backend3
end_define

begin_function_decl
specifier|static
name|void
name|aio_ddp_requeue_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ddp_complete_all
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_aio_cancel_active
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_aio_cancel_queued
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pageset
argument_list|)
name|ddp_orphan_pagesets
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ddp_orphan_pagesets_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|ddp_orphan_task
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_DDP_BUFFER_SIZE
value|(M_TCB_RX_DDP_BUF0_LEN)
end_define

begin_comment
comment|/*  * A page set holds information about a buffer used for DDP.  The page  * set holds resources such as the VM pages backing the buffer (either  * held or wired) and the page pods associated with the buffer.  * Recently used page sets are cached to allow for efficient reuse of  * buffers (avoiding the need to re-fault in pages, hold them, etc.).  * Note that cached page sets keep the backing pages wired.  The  * number of wired pages is capped by only allowing for two wired  * pagesets per connection.  This is not a perfect cap, but is a  * trade-off for performance.  *  * If an application ping-pongs two buffers for a connection via  * aio_read(2) then those buffers should remain wired and expensive VM  * fault lookups should be avoided after each buffer has been used  * once.  If an application uses more than two buffers then this will  * fall back to doing expensive VM fault lookups for each operation.  */
end_comment

begin_function
specifier|static
name|void
name|free_pageset
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|pageset
modifier|*
name|ps
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|prsv
operator|.
name|prsv_nppods
operator|>
literal|0
condition|)
name|t4_free_page_pods
argument_list|(
operator|&
name|ps
operator|->
name|prsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|flags
operator|&
name|PS_WIRED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|ps
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|p
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|vm_page_unhold_pages
argument_list|(
name|ps
operator|->
name|pages
argument_list|,
name|ps
operator|->
name|npages
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ddp_orphan_pagesets
argument_list|,
name|ps
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ddp_orphan_task
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddp_free_orphan_pagesets
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|pageset
modifier|*
name|ps
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ddp_orphan_pagesets
argument_list|)
condition|)
block|{
name|ps
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ddp_orphan_pagesets
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ddp_orphan_pagesets
argument_list|,
name|ps
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|vm
condition|)
name|vmspace_free
argument_list|(
name|ps
operator|->
name|vm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|recycle_pageset
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|pageset
modifier|*
name|ps
parameter_list|)
block|{
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_DEAD
operator|)
operator|&&
name|ps
operator|->
name|flags
operator|&
name|PS_WIRED
condition|)
block|{
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_cached_count
operator|+
name|toep
operator|->
name|ddp_active_count
operator|<
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
argument_list|,
operator|(
literal|"too many wired pagesets"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|toep
operator|->
name|ddp_cached_pagesets
argument_list|,
name|ps
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_cached_count
operator|++
expr_stmt|;
block|}
else|else
name|free_pageset
argument_list|(
name|toep
operator|->
name|td
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddp_complete_one
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|long
name|copied
decl_stmt|;
comment|/* 	 * If this job had copied data out of the socket buffer before 	 * it was cancelled, report it as a short read rather than an 	 * error. 	 */
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
if|if
condition|(
name|copied
operator|!=
literal|0
operator|||
name|error
operator|==
literal|0
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_ddp_buffer
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|ddp_buffer
modifier|*
name|db
parameter_list|)
block|{
if|if
condition|(
name|db
operator|->
name|job
condition|)
block|{
comment|/* 		 * XXX: If we are un-offloading the socket then we 		 * should requeue these on the socket somehow.  If we 		 * got a FIN from the remote end, then this completes 		 * any remaining requests with an EOF read. 		 */
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|db
operator|->
name|job
argument_list|)
condition|)
name|ddp_complete_one
argument_list|(
name|db
operator|->
name|job
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|->
name|ps
condition|)
name|free_pageset
argument_list|(
name|td
argument_list|,
name|db
operator|->
name|ps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddp_init_toep
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|toep
operator|->
name|ddp_requeue_task
argument_list|,
literal|0
argument_list|,
name|aio_ddp_requeue_task
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_active_id
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|toep
operator|->
name|ddp_lock
argument_list|,
literal|"t4 ddp"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddp_uninit_toep
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|toep
operator|->
name|ddp_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|release_ddp_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|pageset
modifier|*
name|ps
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|DDP_DEAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|free_ddp_buffer
argument_list|(
name|toep
operator|->
name|td
argument_list|,
operator|&
name|toep
operator|->
name|db
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ps
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|toep
operator|->
name|ddp_cached_pagesets
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|toep
operator|->
name|ddp_cached_pagesets
argument_list|,
name|ps
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free_pageset
argument_list|(
name|toep
operator|->
name|td
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
name|ddp_complete_all
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function
name|void
name|ddp_assert_empty
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|MPASS
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_TASK_ACTIVE
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|MPASS
argument_list|(
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|.
name|job
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|.
name|ps
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|toep
operator|->
name|ddp_cached_pagesets
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|complete_ddp_buffer
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|ddp_buffer
modifier|*
name|db
parameter_list|,
name|unsigned
name|int
name|db_idx
parameter_list|)
block|{
name|unsigned
name|int
name|db_flag
decl_stmt|;
name|toep
operator|->
name|ddp_active_count
operator|--
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_active_id
operator|==
name|db_idx
condition|)
block|{
if|if
condition|(
name|toep
operator|->
name|ddp_active_count
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|toep
operator|->
name|db
index|[
name|db_idx
operator|^
literal|1
index|]
operator|.
name|job
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: active_count mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_active_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|toep
operator|->
name|ddp_active_id
operator|^=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_TRACES
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: ddp_active_id = %d"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|ddp_active_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_active_count
operator|!=
literal|0
operator|&&
name|toep
operator|->
name|ddp_active_id
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"%s: active count mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
name|db
operator|->
name|cancel_pending
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|job
operator|=
name|NULL
expr_stmt|;
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|db
operator|->
name|ps
argument_list|)
expr_stmt|;
name|db
operator|->
name|ps
operator|=
name|NULL
expr_stmt|;
name|db_flag
operator|=
name|db_idx
operator|==
literal|1
condition|?
name|DDP_BUF1_ACTIVE
else|:
name|DDP_BUF0_ACTIVE
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_flags
operator|&
name|db_flag
argument_list|,
operator|(
literal|"%s: DDP buffer not active. toep %p, ddp_flags 0x%x"
operator|,
name|__func__
operator|,
name|toep
operator|,
name|toep
operator|->
name|ddp_flags
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator|&=
operator|~
name|db_flag
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX: handle_ddp_data code duplication */
end_comment

begin_function
name|void
name|insert_ddp_data
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|size_t
name|placed
decl_stmt|;
name|long
name|copied
decl_stmt|;
name|unsigned
name|int
name|db_flag
decl_stmt|,
name|db_idx
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|n
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_DDP_RX_FLOW_CONTROL
name|KASSERT
argument_list|(
name|tp
operator|->
name|rcv_wnd
operator|>=
name|n
argument_list|,
operator|(
literal|"%s: negative window size"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|-=
name|n
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE_DDP_RX_FLOW_CONTROL
name|toep
operator|->
name|rx_credits
operator|+=
name|n
expr_stmt|;
endif|#
directive|endif
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: placed %u bytes before falling out of DDP"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|toep
operator|->
name|ddp_active_count
operator|>
literal|0
condition|)
block|{
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_active_id
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|db_idx
operator|=
name|toep
operator|->
name|ddp_active_id
expr_stmt|;
name|db_flag
operator|=
name|db_idx
operator|==
literal|1
condition|?
name|DDP_BUF1_ACTIVE
else|:
name|DDP_BUF0_ACTIVE
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|db_flag
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|db
operator|=
operator|&
name|toep
operator|->
name|db
index|[
name|db_idx
index|]
expr_stmt|;
name|job
operator|=
name|db
operator|->
name|job
expr_stmt|;
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
name|placed
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|placed
operator|>
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|-
name|copied
condition|)
name|placed
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|-
name|copied
expr_stmt|;
if|if
condition|(
name|placed
operator|>
literal|0
condition|)
name|job
operator|->
name|msgrcv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
block|{
comment|/* 			 * Update the copied length for when 			 * t4_aio_cancel_active() completes this 			 * request. 			 */
name|job
operator|->
name|aio_received
operator|+=
name|placed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copied
operator|+
name|placed
operator|!=
literal|0
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: completing %p (copied %ld, placed %lu)"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|,
name|copied
argument_list|,
name|placed
argument_list|)
expr_stmt|;
comment|/* XXX: This always completes if there is some data. */
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
operator|+
name|placed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aio_set_cancel_function
argument_list|(
name|job
argument_list|,
name|t4_aio_cancel_queued
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_waiting_count
operator|++
expr_stmt|;
block|}
else|else
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|n
operator|-=
name|placed
expr_stmt|;
name|complete_ddp_buffer
argument_list|(
name|toep
argument_list|,
name|db
argument_list|,
name|db_idx
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|n
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SET_TCB_FIELD sent as a ULP command looks like this */
end_comment

begin_define
define|#
directive|define
name|LEN__SET_TCB_FIELD_ULP
value|(sizeof(struct ulp_txpkt) + \     sizeof(struct ulptx_idata) + sizeof(struct cpl_set_tcb_field_core))
end_define

begin_comment
comment|/* RX_DATA_ACK sent as a ULP command looks like this */
end_comment

begin_define
define|#
directive|define
name|LEN__RX_DATA_ACK_ULP
value|(sizeof(struct ulp_txpkt) + \     sizeof(struct ulptx_idata) + sizeof(struct cpl_rx_data_ack_core))
end_define

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mk_set_tcb_field_ulp
parameter_list|(
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|uint64_t
name|word
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|cpl_set_tcb_field_core
modifier|*
name|req
decl_stmt|;
name|ulpmc
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_PKT
argument_list|)
operator||
name|V_ULP_TXPKT_DEST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|howmany
argument_list|(
name|LEN__SET_TCB_FIELD_ULP
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|cpl_set_tcb_field_core
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
name|toep
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply_ctrl
operator|=
name|htobe16
argument_list|(
name|V_NO_REPLY
argument_list|(
literal|1
argument_list|)
operator||
name|V_QUEUENO
argument_list|(
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|word_cookie
operator|=
name|htobe16
argument_list|(
name|V_WORD
argument_list|(
name|word
argument_list|)
operator||
name|V_COOKIE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|LEN__SET_TCB_FIELD_ULP
operator|%
literal|16
condition|)
block|{
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_NOOP
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ulpsc
operator|+
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ulpsc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mk_rx_data_ack_ulp
parameter_list|(
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|cpl_rx_data_ack_core
modifier|*
name|req
decl_stmt|;
name|ulpmc
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_PKT
argument_list|)
operator||
name|V_ULP_TXPKT_DEST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|howmany
argument_list|(
name|LEN__RX_DATA_ACK_ULP
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|cpl_rx_data_ack_core
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RX_DATA_ACK
argument_list|,
name|toep
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|credit_dack
operator|=
name|htobe32
argument_list|(
name|F_RX_MODULATE_RX
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|LEN__RX_DATA_ACK_ULP
operator|%
literal|16
condition|)
block|{
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_NOOP
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ulpsc
operator|+
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ulpsc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wrqe
modifier|*
name|mk_update_tcb_for_ddp
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|db_idx
parameter_list|,
name|struct
name|pageset
modifier|*
name|ps
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint64_t
name|ddp_flags
parameter_list|,
name|uint64_t
name|ddp_flags_mask
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrh
decl_stmt|;
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|KASSERT
argument_list|(
name|db_idx
operator|==
literal|0
operator|||
name|db_idx
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: bad DDP buffer index %d"
operator|,
name|__func__
operator|,
name|db_idx
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We'll send a compound work request that has 3 SET_TCB_FIELDs and an 	 * RX_DATA_ACK (with RX_MODULATE to speed up delivery). 	 * 	 * The work request header is 16B and always ends at a 16B boundary. 	 * The ULPTX master commands that follow must all end at 16B boundaries 	 * too so we round up the size to 16. 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wrh
argument_list|)
operator|+
literal|3
operator|*
name|roundup2
argument_list|(
name|LEN__SET_TCB_FIELD_ULP
argument_list|,
literal|16
argument_list|)
operator|+
name|roundup2
argument_list|(
name|LEN__RX_DATA_ACK_ULP
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|len
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|wrh
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_ULPTX_WRH
argument_list|(
name|wrh
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* atomic */
name|ulpmc
operator|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
operator|(
name|wrh
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Write the buffer's tag */
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF0_TAG
operator|+
name|db_idx
argument_list|,
name|V_TCB_RX_DDP_BUF0_TAG
argument_list|(
name|M_TCB_RX_DDP_BUF0_TAG
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF0_TAG
argument_list|(
name|ps
operator|->
name|prsv
operator|.
name|prsv_tag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the current offset in the DDP buffer and its total length */
if|if
condition|(
name|db_idx
operator|==
literal|0
condition|)
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF0_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF0_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF0_LEN
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
name|offset
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
name|ps
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF1_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF1_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
operator|(
name|u64
operator|)
name|M_TCB_RX_DDP_BUF1_LEN
operator|<<
literal|32
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
name|offset
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
operator|(
name|u64
operator|)
name|ps
operator|->
name|len
operator|<<
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update DDP flags */
name|ulpmc
operator|=
name|mk_set_tcb_field_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|ddp_flags_mask
argument_list|,
name|ddp_flags
argument_list|)
expr_stmt|;
comment|/* Gratuitous RX_DATA_ACK with RX_MODULATE set to speed up delivery. */
name|ulpmc
operator|=
name|mk_rx_data_ack_ulp
argument_list|(
name|ulpmc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|wr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|handle_ddp_data
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|__be32
name|ddp_report
parameter_list|,
name|__be32
name|rcv_nxt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|uint32_t
name|report
init|=
name|be32toh
argument_list|(
name|ddp_report
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|db_idx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|long
name|copied
decl_stmt|;
name|db_idx
operator|=
name|report
operator|&
name|F_DDP_BUF_IDX
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|report
operator|&
name|F_DDP_INV
operator|)
argument_list|)
condition|)
name|CXGBE_UNIMPLEMENTED
argument_list|(
literal|"DDP buffer still valid"
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_active_id
operator|==
name|db_idx
argument_list|,
operator|(
literal|"completed DDP buffer (%d) != active_id (%d) for tid %d"
operator|,
name|db_idx
operator|,
name|toep
operator|->
name|ddp_active_id
operator|,
name|toep
operator|->
name|tid
operator|)
argument_list|)
expr_stmt|;
name|db
operator|=
operator|&
name|toep
operator|->
name|db
index|[
name|db_idx
index|]
expr_stmt|;
name|job
operator|=
name|db
operator|->
name|job
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_DROPPED
operator||
name|INP_TIMEWAIT
operator|)
argument_list|)
condition|)
block|{
comment|/* 		 * This can happen due to an administrative tcpdrop(8). 		 * Just fail the request with ECONNRESET. 		 */
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, seq 0x%x, len %d, inp_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|be32toh
argument_list|(
name|rcv_nxt
argument_list|)
argument_list|,
name|len
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
name|ddp_complete_one
argument_list|(
name|job
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
goto|goto
name|completed
goto|;
block|}
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * For RX_DDP_COMPLETE, len will be zero and rcv_nxt is the 	 * sequence number of the next byte to receive.  The length of 	 * the data received for this message must be computed by 	 * comparing the new and old values of rcv_nxt. 	 * 	 * For RX_DATA_DDP, len might be non-zero, but it is only the 	 * length of the most recent DMA.  It does not include the 	 * total length of the data received since the previous update 	 * for this DDP buffer.  rcv_nxt is the sequence number of the 	 * first received byte from the most recent DMA. 	 */
name|len
operator|+=
name|be32toh
argument_list|(
name|rcv_nxt
argument_list|)
operator|-
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|len
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_DDP_RX_FLOW_CONTROL
name|KASSERT
argument_list|(
name|tp
operator|->
name|rcv_wnd
operator|>=
name|len
argument_list|,
operator|(
literal|"%s: negative window size"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|-=
name|len
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VERBOSE_TRACES
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: DDP[%d] placed %d bytes (%#x)"
argument_list|,
name|__func__
argument_list|,
name|db_idx
argument_list|,
name|len
argument_list|,
name|report
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* receive buffer autosize */
name|MPASS
argument_list|(
name|toep
operator|->
name|vnet
operator|==
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|toep
operator|->
name|vnet
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|&&
name|V_tcp_do_autorcvbuf
operator|&&
name|sb
operator|->
name|sb_hiwat
operator|<
name|V_tcp_autorcvbuf_max
operator|&&
name|len
operator|>
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|/
literal|8
operator|*
literal|7
operator|)
condition|)
block|{
name|unsigned
name|int
name|hiwat
init|=
name|sb
operator|->
name|sb_hiwat
decl_stmt|;
name|unsigned
name|int
name|newsize
init|=
name|min
argument_list|(
name|hiwat
operator|+
name|V_tcp_autorcvbuf_inc
argument_list|,
name|V_tcp_autorcvbuf_max
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sbreserve_locked
argument_list|(
name|sb
argument_list|,
name|newsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
condition|)
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
else|else
name|toep
operator|->
name|rx_credits
operator|+=
name|newsize
operator|-
name|hiwat
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_DDP_RX_FLOW_CONTROL
name|toep
operator|->
name|rx_credits
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
name|job
operator|->
name|msgrcv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|cancel_pending
condition|)
block|{
comment|/* 		 * Update the job's length but defer completion to the 		 * TCB_RPL callback. 		 */
name|job
operator|->
name|aio_received
operator|+=
name|len
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
block|{
comment|/* 		 * Update the copied length for when 		 * t4_aio_cancel_active() completes this request. 		 */
name|job
operator|->
name|aio_received
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_TRACES
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: completing %p (copied %ld, placed %d)"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|,
name|copied
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_rcvd
argument_list|(
operator|&
name|toep
operator|->
name|td
operator|->
name|tod
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|completed
label|:
name|complete_ddp_buffer
argument_list|(
name|toep
argument_list|,
name|db
argument_list|,
name|db_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_waiting_count
operator|>
literal|0
condition|)
name|ddp_queue_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|out
label|:
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|handle_ddp_indicate
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_active_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
operator|(
name|DDP_BUF0_ACTIVE
operator||
name|DDP_BUF1_ACTIVE
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_waiting_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The pending requests that triggered the request for an 		 * an indicate were cancelled.  Those cancels should have 		 * already disabled DDP.  Just ignore this as the data is 		 * going into the socket buffer anyway. 		 */
return|return;
block|}
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d indicated (%d waiting)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|toep
operator|->
name|ddp_waiting_count
argument_list|)
expr_stmt|;
name|ddp_queue_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
block|{
name|DDP_BUF0_INVALIDATED
init|=
literal|0x2
block|,
name|DDP_BUF1_INVALIDATED
block|}
enum|;
end_enum

begin_function
name|void
name|handle_ddp_tcb_rpl
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
specifier|const
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|cpl
parameter_list|)
block|{
name|unsigned
name|int
name|db_idx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|long
name|copied
decl_stmt|;
if|if
condition|(
name|cpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|panic
argument_list|(
literal|"XXX: tcp_rpl failed: %d"
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpl
operator|->
name|cookie
condition|)
block|{
case|case
name|V_WORD
argument_list|(
name|W_TCB_RX_DDP_FLAGS
argument_list|)
operator||
name|V_COOKIE
argument_list|(
name|DDP_BUF0_INVALIDATED
argument_list|)
case|:
case|case
name|V_WORD
argument_list|(
name|W_TCB_RX_DDP_FLAGS
argument_list|)
operator||
name|V_COOKIE
argument_list|(
name|DDP_BUF1_INVALIDATED
argument_list|)
case|:
comment|/* 		 * XXX: This duplicates a lot of code with handle_ddp_data(). 		 */
name|db_idx
operator|=
name|G_COOKIE
argument_list|(
name|cpl
operator|->
name|cookie
argument_list|)
operator|-
name|DDP_BUF0_INVALIDATED
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|db
operator|=
operator|&
name|toep
operator|->
name|db
index|[
name|db_idx
index|]
expr_stmt|;
comment|/* 		 * handle_ddp_data() should leave the job around until 		 * this callback runs once a cancel is pending. 		 */
name|MPASS
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|db
operator|->
name|job
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|db
operator|->
name|cancel_pending
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: It's not clear what happens if there is data 		 * placed when the buffer is invalidated.  I suspect we 		 * need to read the TCB to see how much data was placed. 		 * 		 * For now this just pretends like nothing was placed. 		 * 		 * XXX: Note that if we did check the PCB we would need to 		 * also take care of updating the tp, etc. 		 */
name|job
operator|=
name|db
operator|->
name|job
expr_stmt|;
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
if|if
condition|(
name|copied
operator|==
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: cancelling %p"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: completing %p (copied %ld)"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|,
name|copied
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_rcvd
argument_list|(
operator|&
name|toep
operator|->
name|td
operator|->
name|tod
argument_list|,
name|intotcpcb
argument_list|(
name|inp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|complete_ddp_buffer
argument_list|(
name|toep
argument_list|,
name|db
argument_list|,
name|db_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_waiting_count
operator|>
literal|0
condition|)
name|ddp_queue_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"XXX: unknown tcb_rpl offset %#x, cookie %#x"
argument_list|,
name|G_WORD
argument_list|(
name|cpl
operator|->
name|cookie
argument_list|)
argument_list|,
name|G_COOKIE
argument_list|(
name|cpl
operator|->
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|handle_ddp_close
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|__be32
name|rcv_nxt
parameter_list|)
block|{
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|long
name|copied
decl_stmt|;
name|unsigned
name|int
name|db_flag
decl_stmt|,
name|db_idx
decl_stmt|;
name|int
name|len
decl_stmt|,
name|placed
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|toep
operator|->
name|inp
argument_list|)
expr_stmt|;
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|len
operator|=
name|be32toh
argument_list|(
name|rcv_nxt
argument_list|)
operator|-
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|len
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_DDP_RX_FLOW_CONTROL
name|toep
operator|->
name|rx_credits
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|toep
operator|->
name|ddp_active_count
operator|>
literal|0
condition|)
block|{
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_active_id
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|db_idx
operator|=
name|toep
operator|->
name|ddp_active_id
expr_stmt|;
name|db_flag
operator|=
name|db_idx
operator|==
literal|1
condition|?
name|DDP_BUF1_ACTIVE
else|:
name|DDP_BUF0_ACTIVE
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|db_flag
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|db
operator|=
operator|&
name|toep
operator|->
name|db
index|[
name|db_idx
index|]
expr_stmt|;
name|job
operator|=
name|db
operator|->
name|job
expr_stmt|;
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
name|placed
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|placed
operator|>
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|-
name|copied
condition|)
name|placed
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|-
name|copied
expr_stmt|;
if|if
condition|(
name|placed
operator|>
literal|0
condition|)
name|job
operator|->
name|msgrcv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
block|{
comment|/* 			 * Update the copied length for when 			 * t4_aio_cancel_active() completes this 			 * request. 			 */
name|job
operator|->
name|aio_received
operator|+=
name|placed
expr_stmt|;
block|}
else|else
block|{
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d completed buf %d len %d"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|db_idx
argument_list|,
name|placed
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
operator|+
name|placed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|placed
expr_stmt|;
name|complete_ddp_buffer
argument_list|(
name|toep
argument_list|,
name|db
argument_list|,
name|db_idx
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ddp_complete_all
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DDP_ERR
value|(F_DDP_PPOD_MISMATCH | F_DDP_LLIMIT_ERR | F_DDP_ULIMIT_ERR |\ 	 F_DDP_PPOD_PARITY_ERR | F_DDP_PADDING_ERR | F_DDP_OFFSET_ERR |\ 	 F_DDP_INVALID_TAG | F_DDP_COLOR_ERR | F_DDP_TID_MISMATCH |\ 	 F_DDP_INVALID_PPOD | F_DDP_HDRCRC_ERR | F_DDP_DATACRC_ERR)
end_define

begin_decl_stmt
specifier|extern
name|cpl_handler_t
name|t4_cpl_handler
index|[]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|do_rx_data_ddp
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_data_ddp
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|uint32_t
name|vld
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
operator|)
argument_list|,
operator|(
literal|"%s: toep %p claims to be a synq entry"
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|vld
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|ddpvld
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|vld
operator|&
name|DDP_ERR
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: DDP error 0x%x (tid %d, toep %p)"
argument_list|,
name|__func__
argument_list|,
name|vld
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_ISCSI
condition|)
block|{
name|t4_cpl_handler
index|[
name|CPL_RX_ISCSI_DDP
index|]
operator|(
name|iq
operator|,
name|rss
operator|,
name|m
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|handle_ddp_data
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|u
operator|.
name|ddp_report
argument_list|,
name|cpl
operator|->
name|seq
argument_list|,
name|be16toh
argument_list|(
name|cpl
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_rx_ddp_complete
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_ddp_complete
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
operator|)
argument_list|,
operator|(
literal|"%s: toep %p claims to be a synq entry"
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|handle_ddp_data
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|ddp_report
argument_list|,
name|cpl
operator|->
name|rcv_nxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_ddp
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
operator|(
name|DDP_ON
operator||
name|DDP_OK
operator||
name|DDP_SC_REQ
operator|)
operator|)
operator|==
name|DDP_OK
argument_list|,
operator|(
literal|"%s: toep %p has bad ddp_flags 0x%x"
operator|,
name|__func__
operator|,
name|toep
operator|,
name|toep
operator|->
name|ddp_flags
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u (time %u)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|time_uptime
argument_list|)
expr_stmt|;
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator||=
name|DDP_SC_REQ
expr_stmt|;
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_INDICATE_OUT
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_INDICATE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_INDICATE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_BUF0_INDICATE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_INDICATE
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|W_TCB_T_FLAGS
argument_list|,
name|V_TF_RCV_COALESCE_ENABLE
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|calculate_hcf
parameter_list|(
name|int
name|n1
parameter_list|,
name|int
name|n2
parameter_list|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|n1
operator|<=
name|n2
condition|)
block|{
name|a
operator|=
name|n1
expr_stmt|;
name|b
operator|=
name|n2
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|n2
expr_stmt|;
name|b
operator|=
name|n1
expr_stmt|;
block|}
while|while
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|t
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
operator|%
name|a
expr_stmt|;
name|b
operator|=
name|t
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pages_to_nppods
parameter_list|(
name|int
name|npages
parameter_list|,
name|int
name|ddp_page_shift
parameter_list|)
block|{
name|MPASS
argument_list|(
name|ddp_page_shift
operator|>=
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
name|howmany
argument_list|(
name|npages
operator|>>
operator|(
name|ddp_page_shift
operator|-
name|PAGE_SHIFT
operator|)
argument_list|,
name|PPOD_PAGES
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_page_pods
parameter_list|(
name|struct
name|ppod_region
modifier|*
name|pr
parameter_list|,
name|u_int
name|nppods
parameter_list|,
name|u_int
name|pgsz_idx
parameter_list|,
name|struct
name|ppod_reservation
modifier|*
name|prsv
parameter_list|)
block|{
name|vmem_addr_t
name|addr
decl_stmt|;
comment|/* relative to start of region */
if|if
condition|(
name|vmem_alloc
argument_list|(
name|pr
operator|->
name|pr_arena
argument_list|,
name|PPOD_SZ
argument_list|(
name|nppods
argument_list|)
argument_list|,
name|M_NOWAIT
operator||
name|M_FIRSTFIT
argument_list|,
operator|&
name|addr
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%-17s arena %p, addr 0x%08x, nppods %d, pgsz %d"
argument_list|,
name|__func__
argument_list|,
name|pr
operator|->
name|pr_arena
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
operator|&
name|pr
operator|->
name|pr_tag_mask
argument_list|,
name|nppods
argument_list|,
literal|1
operator|<<
name|pr
operator|->
name|pr_page_shift
index|[
name|pgsz_idx
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * The hardware tagmask includes an extra invalid bit but the arena was 	 * seeded with valid values only.  An allocation out of this arena will 	 * fit inside the tagmask but won't have the invalid bit set. 	 */
name|MPASS
argument_list|(
operator|(
name|addr
operator|&
name|pr
operator|->
name|pr_tag_mask
operator|)
operator|==
name|addr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|addr
operator|&
name|pr
operator|->
name|pr_invalid_bit
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|prsv
operator|->
name|prsv_pr
operator|=
name|pr
expr_stmt|;
name|prsv
operator|->
name|prsv_tag
operator|=
name|V_PPOD_PGSZ
argument_list|(
name|pgsz_idx
argument_list|)
operator||
name|addr
expr_stmt|;
name|prsv
operator|->
name|prsv_nppods
operator|=
name|nppods
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_alloc_page_pods_for_ps
parameter_list|(
name|struct
name|ppod_region
modifier|*
name|pr
parameter_list|,
name|struct
name|pageset
modifier|*
name|ps
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|hcf
decl_stmt|,
name|seglen
decl_stmt|,
name|idx
decl_stmt|,
name|nppods
decl_stmt|;
name|struct
name|ppod_reservation
modifier|*
name|prsv
init|=
operator|&
name|ps
operator|->
name|prsv
decl_stmt|;
name|KASSERT
argument_list|(
name|prsv
operator|->
name|prsv_nppods
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: page pods already allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The DDP page size is unrelated to the VM page size.  We combine 	 * contiguous physical pages into larger segments to get the best DDP 	 * page size possible.  This is the largest of the four sizes in 	 * A_ULP_RX_TDDP_PSZ that evenly divides the HCF of the segment sizes in 	 * the page list. 	 */
name|hcf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|seglen
operator|=
name|PAGE_SIZE
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|ps
operator|->
name|npages
operator|-
literal|1
operator|&&
name|ps
operator|->
name|pages
index|[
name|i
index|]
operator|->
name|phys_addr
operator|+
name|PAGE_SIZE
operator|==
name|ps
operator|->
name|pages
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|phys_addr
condition|)
block|{
name|seglen
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|hcf
operator|=
name|calculate_hcf
argument_list|(
name|hcf
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hcf
operator|<
operator|(
literal|1
operator|<<
name|pr
operator|->
name|pr_page_shift
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|idx
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_pgsz
goto|;
comment|/* give up, short circuit */
block|}
block|}
define|#
directive|define
name|PR_PAGE_MASK
parameter_list|(
name|x
parameter_list|)
value|((1<< pr->pr_page_shift[(x)]) - 1)
name|MPASS
argument_list|(
operator|(
name|hcf
operator|&
name|PR_PAGE_MASK
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* PAGE_SIZE is>= 4K everywhere */
for|for
control|(
name|idx
operator|=
name|nitems
argument_list|(
name|pr
operator|->
name|pr_page_shift
argument_list|)
operator|-
literal|1
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|hcf
operator|&
name|PR_PAGE_MASK
argument_list|(
name|idx
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
undef|#
directive|undef
name|PR_PAGE_MASK
name|have_pgsz
label|:
name|MPASS
argument_list|(
name|idx
operator|<=
name|M_PPOD_PGSZ
argument_list|)
expr_stmt|;
name|nppods
operator|=
name|pages_to_nppods
argument_list|(
name|ps
operator|->
name|npages
argument_list|,
name|pr
operator|->
name|pr_page_shift
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_page_pods
argument_list|(
name|pr
argument_list|,
name|nppods
argument_list|,
name|idx
argument_list|,
name|prsv
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|MPASS
argument_list|(
name|prsv
operator|->
name|prsv_nppods
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_alloc_page_pods_for_buf
parameter_list|(
name|struct
name|ppod_region
modifier|*
name|pr
parameter_list|,
name|vm_offset_t
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ppod_reservation
modifier|*
name|prsv
parameter_list|)
block|{
name|int
name|hcf
decl_stmt|,
name|seglen
decl_stmt|,
name|idx
decl_stmt|,
name|npages
decl_stmt|,
name|nppods
decl_stmt|;
name|uintptr_t
name|start_pva
decl_stmt|,
name|end_pva
decl_stmt|,
name|pva
decl_stmt|,
name|p1
decl_stmt|;
name|MPASS
argument_list|(
name|buf
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The DDP page size is unrelated to the VM page size.  We combine 	 * contiguous physical pages into larger segments to get the best DDP 	 * page size possible.  This is the largest of the four sizes in 	 * A_ULP_RX_ISCSI_PSZ that evenly divides the HCF of the segment sizes 	 * in the page list. 	 */
name|hcf
operator|=
literal|0
expr_stmt|;
name|start_pva
operator|=
name|trunc_page
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|end_pva
operator|=
name|trunc_page
argument_list|(
name|buf
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pva
operator|=
name|start_pva
expr_stmt|;
while|while
condition|(
name|pva
operator|<=
name|end_pva
condition|)
block|{
name|seglen
operator|=
name|PAGE_SIZE
expr_stmt|;
name|p1
operator|=
name|pmap_kextract
argument_list|(
name|pva
argument_list|)
expr_stmt|;
name|pva
operator|+=
name|PAGE_SIZE
expr_stmt|;
while|while
condition|(
name|pva
operator|<=
name|end_pva
operator|&&
name|p1
operator|+
name|seglen
operator|==
name|pmap_kextract
argument_list|(
name|pva
argument_list|)
condition|)
block|{
name|seglen
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|hcf
operator|=
name|calculate_hcf
argument_list|(
name|hcf
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hcf
operator|<
operator|(
literal|1
operator|<<
name|pr
operator|->
name|pr_page_shift
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|idx
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_pgsz
goto|;
comment|/* give up, short circuit */
block|}
block|}
define|#
directive|define
name|PR_PAGE_MASK
parameter_list|(
name|x
parameter_list|)
value|((1<< pr->pr_page_shift[(x)]) - 1)
name|MPASS
argument_list|(
operator|(
name|hcf
operator|&
name|PR_PAGE_MASK
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* PAGE_SIZE is>= 4K everywhere */
for|for
control|(
name|idx
operator|=
name|nitems
argument_list|(
name|pr
operator|->
name|pr_page_shift
argument_list|)
operator|-
literal|1
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|hcf
operator|&
name|PR_PAGE_MASK
argument_list|(
name|idx
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
undef|#
directive|undef
name|PR_PAGE_MASK
name|have_pgsz
label|:
name|MPASS
argument_list|(
name|idx
operator|<=
name|M_PPOD_PGSZ
argument_list|)
expr_stmt|;
name|npages
operator|=
literal|1
expr_stmt|;
name|npages
operator|+=
operator|(
name|end_pva
operator|-
name|start_pva
operator|)
operator|>>
name|pr
operator|->
name|pr_page_shift
index|[
name|idx
index|]
expr_stmt|;
name|nppods
operator|=
name|howmany
argument_list|(
name|npages
argument_list|,
name|PPOD_PAGES
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_page_pods
argument_list|(
name|pr
argument_list|,
name|nppods
argument_list|,
name|idx
argument_list|,
name|prsv
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|MPASS
argument_list|(
name|prsv
operator|->
name|prsv_nppods
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_free_page_pods
parameter_list|(
name|struct
name|ppod_reservation
modifier|*
name|prsv
parameter_list|)
block|{
name|struct
name|ppod_region
modifier|*
name|pr
init|=
name|prsv
operator|->
name|prsv_pr
decl_stmt|;
name|vmem_addr_t
name|addr
decl_stmt|;
name|MPASS
argument_list|(
name|prsv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|prsv
operator|->
name|prsv_nppods
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|prsv
operator|->
name|prsv_tag
operator|&
name|pr
operator|->
name|pr_tag_mask
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|addr
operator|&
name|pr
operator|->
name|pr_invalid_bit
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%-17s arena %p, addr 0x%08x, nppods %d"
argument_list|,
name|__func__
argument_list|,
name|pr
operator|->
name|pr_arena
argument_list|,
name|addr
argument_list|,
name|prsv
operator|->
name|prsv_nppods
argument_list|)
expr_stmt|;
name|vmem_free
argument_list|(
name|pr
operator|->
name|pr_arena
argument_list|,
name|addr
argument_list|,
name|PPOD_SZ
argument_list|(
name|prsv
operator|->
name|prsv_nppods
argument_list|)
argument_list|)
expr_stmt|;
name|prsv
operator|->
name|prsv_nppods
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NUM_ULP_TX_SC_IMM_PPODS
value|(256 / PPOD_SIZE)
end_define

begin_function
name|int
name|t4_write_page_pods_for_ps
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|,
name|int
name|tid
parameter_list|,
name|struct
name|pageset
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|ulp_mem_io
modifier|*
name|ulpmc
decl_stmt|;
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|pagepod
modifier|*
name|ppod
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|chunk
decl_stmt|,
name|len
decl_stmt|,
name|ddp_pgsz
decl_stmt|,
name|idx
decl_stmt|;
name|u_int
name|ppod_addr
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
name|struct
name|ppod_reservation
modifier|*
name|prsv
init|=
operator|&
name|ps
operator|->
name|prsv
decl_stmt|;
name|struct
name|ppod_region
modifier|*
name|pr
init|=
name|prsv
operator|->
name|prsv_pr
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|ps
operator|->
name|flags
operator|&
name|PS_PPODS_WRITTEN
operator|)
argument_list|,
operator|(
literal|"%s: page pods already written"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|prsv
operator|->
name|prsv_nppods
operator|>
literal|0
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_MEM_WRITE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
name|cmd
operator||=
name|htobe32
argument_list|(
name|F_ULP_MEMIO_ORDER
argument_list|)
expr_stmt|;
else|else
name|cmd
operator||=
name|htobe32
argument_list|(
name|F_T5_ULP_MEMIO_IMM
argument_list|)
expr_stmt|;
name|ddp_pgsz
operator|=
literal|1
operator|<<
name|pr
operator|->
name|pr_page_shift
index|[
name|G_PPOD_PGSZ
argument_list|(
name|prsv
operator|->
name|prsv_tag
argument_list|)
index|]
expr_stmt|;
name|ppod_addr
operator|=
name|pr
operator|->
name|pr_start
operator|+
operator|(
name|prsv
operator|->
name|prsv_tag
operator|&
name|pr
operator|->
name|pr_tag_mask
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prsv
operator|->
name|prsv_nppods
condition|;
name|ppod_addr
operator|+=
name|chunk
control|)
block|{
comment|/* How many page pods are we writing in this cycle */
name|n
operator|=
name|min
argument_list|(
name|prsv
operator|->
name|prsv_nppods
operator|-
name|i
argument_list|,
name|NUM_ULP_TX_SC_IMM_PPODS
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|PPOD_SZ
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|len
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ulpmc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ulpsc
argument_list|)
operator|+
name|chunk
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|len
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* ok to just bail out */
name|ulpmc
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_ULPTX_WR
argument_list|(
name|ulpmc
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|ulpmc
operator|->
name|dlen
operator|=
name|htobe32
argument_list|(
name|V_ULP_MEMIO_DATA_LEN
argument_list|(
name|chunk
operator|/
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len16
operator|=
name|htobe32
argument_list|(
name|howmany
argument_list|(
name|len
operator|-
sizeof|sizeof
argument_list|(
name|ulpmc
operator|->
name|wr
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|lock_addr
operator|=
name|htobe32
argument_list|(
name|V_ULP_MEMIO_ADDR
argument_list|(
name|ppod_addr
operator|>>
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|ppod
operator|=
operator|(
expr|struct
name|pagepod
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|j
operator|++
operator|,
name|ppod
operator|++
control|)
block|{
name|ppod
operator|->
name|vld_tid_pgsz_tag_color
operator|=
name|htobe64
argument_list|(
name|F_PPOD_VALID
operator||
name|V_PPOD_TID
argument_list|(
name|tid
argument_list|)
operator||
name|prsv
operator|->
name|prsv_tag
argument_list|)
expr_stmt|;
name|ppod
operator|->
name|len_offset
operator|=
name|htobe64
argument_list|(
name|V_PPOD_LEN
argument_list|(
name|ps
operator|->
name|len
argument_list|)
operator||
name|V_PPOD_OFST
argument_list|(
name|ps
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|ppod
operator|->
name|rsvd
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|i
operator|*
name|PPOD_PAGES
operator|*
operator|(
name|ddp_pgsz
operator|/
name|PAGE_SIZE
operator|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nitems
argument_list|(
name|ppod
operator|->
name|addr
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|<
name|ps
operator|->
name|npages
condition|)
block|{
name|ppod
operator|->
name|addr
index|[
name|k
index|]
operator|=
name|htobe64
argument_list|(
name|ps
operator|->
name|pages
index|[
name|idx
index|]
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|ddp_pgsz
operator|/
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
name|ppod
operator|->
name|addr
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|CTR5(KTR_CXGBE, 				    "%s: tid %d ppod[%d]->addr[%d] = %p", 				    __func__, toep->tid, i, k, 				    htobe64(ppod->addr[k]));
endif|#
directive|endif
block|}
block|}
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
name|ps
operator|->
name|flags
operator||=
name|PS_PPODS_WRITTEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_write_page_pods_for_buf
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|,
name|int
name|tid
parameter_list|,
name|struct
name|ppod_reservation
modifier|*
name|prsv
parameter_list|,
name|vm_offset_t
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|ulp_mem_io
modifier|*
name|ulpmc
decl_stmt|;
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|pagepod
modifier|*
name|ppod
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|chunk
decl_stmt|,
name|len
decl_stmt|,
name|ddp_pgsz
decl_stmt|;
name|u_int
name|ppod_addr
decl_stmt|,
name|offset
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
name|struct
name|ppod_region
modifier|*
name|pr
init|=
name|prsv
operator|->
name|prsv_pr
decl_stmt|;
name|uintptr_t
name|end_pva
decl_stmt|,
name|pva
decl_stmt|,
name|pa
decl_stmt|;
name|cmd
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_MEM_WRITE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
name|cmd
operator||=
name|htobe32
argument_list|(
name|F_ULP_MEMIO_ORDER
argument_list|)
expr_stmt|;
else|else
name|cmd
operator||=
name|htobe32
argument_list|(
name|F_T5_ULP_MEMIO_IMM
argument_list|)
expr_stmt|;
name|ddp_pgsz
operator|=
literal|1
operator|<<
name|pr
operator|->
name|pr_page_shift
index|[
name|G_PPOD_PGSZ
argument_list|(
name|prsv
operator|->
name|prsv_tag
argument_list|)
index|]
expr_stmt|;
name|offset
operator|=
name|buf
operator|&
name|PAGE_MASK
expr_stmt|;
name|ppod_addr
operator|=
name|pr
operator|->
name|pr_start
operator|+
operator|(
name|prsv
operator|->
name|prsv_tag
operator|&
name|pr
operator|->
name|pr_tag_mask
operator|)
expr_stmt|;
name|pva
operator|=
name|trunc_page
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|end_pva
operator|=
name|trunc_page
argument_list|(
name|buf
operator|+
name|buflen
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prsv
operator|->
name|prsv_nppods
condition|;
name|ppod_addr
operator|+=
name|chunk
control|)
block|{
comment|/* How many page pods are we writing in this cycle */
name|n
operator|=
name|min
argument_list|(
name|prsv
operator|->
name|prsv_nppods
operator|-
name|i
argument_list|,
name|NUM_ULP_TX_SC_IMM_PPODS
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|PPOD_SZ
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|len
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ulpmc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ulpsc
argument_list|)
operator|+
name|chunk
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|len
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* ok to just bail out */
name|ulpmc
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_ULPTX_WR
argument_list|(
name|ulpmc
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|ulpmc
operator|->
name|dlen
operator|=
name|htobe32
argument_list|(
name|V_ULP_MEMIO_DATA_LEN
argument_list|(
name|chunk
operator|/
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len16
operator|=
name|htobe32
argument_list|(
name|howmany
argument_list|(
name|len
operator|-
sizeof|sizeof
argument_list|(
name|ulpmc
operator|->
name|wr
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|lock_addr
operator|=
name|htobe32
argument_list|(
name|V_ULP_MEMIO_ADDR
argument_list|(
name|ppod_addr
operator|>>
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|=
operator|(
expr|struct
name|ulptx_idata
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|ppod
operator|=
operator|(
expr|struct
name|pagepod
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|j
operator|++
operator|,
name|ppod
operator|++
control|)
block|{
name|ppod
operator|->
name|vld_tid_pgsz_tag_color
operator|=
name|htobe64
argument_list|(
name|F_PPOD_VALID
operator||
name|V_PPOD_TID
argument_list|(
name|tid
argument_list|)
operator||
operator|(
name|prsv
operator|->
name|prsv_tag
operator|&
operator|~
name|V_PPOD_PGSZ
argument_list|(
name|M_PPOD_PGSZ
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ppod
operator|->
name|len_offset
operator|=
name|htobe64
argument_list|(
name|V_PPOD_LEN
argument_list|(
name|buflen
argument_list|)
operator||
name|V_PPOD_OFST
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|ppod
operator|->
name|rsvd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nitems
argument_list|(
name|ppod
operator|->
name|addr
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|pva
operator|>
name|end_pva
condition|)
name|ppod
operator|->
name|addr
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|pa
operator|=
name|pmap_kextract
argument_list|(
name|pva
argument_list|)
expr_stmt|;
name|ppod
operator|->
name|addr
index|[
name|k
index|]
operator|=
name|htobe64
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pva
operator|+=
name|ddp_pgsz
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|CTR5(KTR_CXGBE, 				    "%s: tid %d ppod[%d]->addr[%d] = %p", 				    __func__, tid, i, k, 				    htobe64(ppod->addr[k]));
endif|#
directive|endif
block|}
comment|/* 			 * Walk back 1 segment so that the first address in the 			 * next pod is the same as the last one in the current 			 * pod. 			 */
name|pva
operator|-=
name|ddp_pgsz
expr_stmt|;
block|}
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|pva
operator|<=
name|end_pva
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wire_pageset
parameter_list|(
name|struct
name|pageset
modifier|*
name|ps
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|ps
operator|->
name|flags
operator|&
name|PS_WIRED
operator|)
argument_list|,
operator|(
literal|"pageset already wired"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|ps
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unhold
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ps
operator|->
name|flags
operator||=
name|PS_WIRED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare a pageset for DDP.  This wires the pageset and sets up page  * pods.  */
end_comment

begin_function
specifier|static
name|int
name|prep_pageset
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|pageset
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ps
operator|->
name|flags
operator|&
name|PS_WIRED
operator|)
condition|)
name|wire_pageset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|prsv
operator|.
name|prsv_nppods
operator|==
literal|0
operator|&&
operator|!
name|t4_alloc_page_pods_for_ps
argument_list|(
operator|&
name|td
operator|->
name|pr
argument_list|,
name|ps
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ps
operator|->
name|flags
operator|&
name|PS_PPODS_WRITTEN
operator|)
operator|&&
name|t4_write_page_pods_for_ps
argument_list|(
name|sc
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|ps
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_init_ppod_region
parameter_list|(
name|struct
name|ppod_region
modifier|*
name|pr
parameter_list|,
name|struct
name|t4_range
modifier|*
name|r
parameter_list|,
name|u_int
name|psz
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|pr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|r
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pr
operator|->
name|pr_start
operator|=
name|r
operator|->
name|start
expr_stmt|;
name|pr
operator|->
name|pr_len
operator|=
name|r
operator|->
name|size
expr_stmt|;
name|pr
operator|->
name|pr_page_shift
index|[
literal|0
index|]
operator|=
literal|12
operator|+
name|G_HPZ0
argument_list|(
name|psz
argument_list|)
expr_stmt|;
name|pr
operator|->
name|pr_page_shift
index|[
literal|1
index|]
operator|=
literal|12
operator|+
name|G_HPZ1
argument_list|(
name|psz
argument_list|)
expr_stmt|;
name|pr
operator|->
name|pr_page_shift
index|[
literal|2
index|]
operator|=
literal|12
operator|+
name|G_HPZ2
argument_list|(
name|psz
argument_list|)
expr_stmt|;
name|pr
operator|->
name|pr_page_shift
index|[
literal|3
index|]
operator|=
literal|12
operator|+
name|G_HPZ3
argument_list|(
name|psz
argument_list|)
expr_stmt|;
comment|/* The SGL -> page pod algorithm requires the sizes to be in order. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nitems
argument_list|(
name|pr
operator|->
name|pr_page_shift
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pr
operator|->
name|pr_page_shift
index|[
name|i
index|]
operator|<=
name|pr
operator|->
name|pr_page_shift
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pr
operator|->
name|pr_tag_mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|fls
argument_list|(
name|r
operator|->
name|size
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|&
name|V_PPOD_TAG
argument_list|(
name|M_PPOD_TAG
argument_list|)
expr_stmt|;
name|pr
operator|->
name|pr_alias_mask
operator|=
name|V_PPOD_TAG
argument_list|(
name|M_PPOD_TAG
argument_list|)
operator|&
operator|~
name|pr
operator|->
name|pr_tag_mask
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_tag_mask
operator|==
literal|0
operator|||
name|pr
operator|->
name|pr_alias_mask
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pr
operator|->
name|pr_alias_shift
operator|=
name|fls
argument_list|(
name|pr
operator|->
name|pr_tag_mask
argument_list|)
expr_stmt|;
name|pr
operator|->
name|pr_invalid_bit
operator|=
literal|1
operator|<<
operator|(
name|pr
operator|->
name|pr_alias_shift
operator|-
literal|1
operator|)
expr_stmt|;
name|pr
operator|->
name|pr_arena
operator|=
name|vmem_create
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|pr
operator|->
name|pr_len
argument_list|,
name|PPOD_SIZE
argument_list|,
literal|0
argument_list|,
name|M_FIRSTFIT
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_arena
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_free_ppod_region
parameter_list|(
name|struct
name|ppod_region
modifier|*
name|pr
parameter_list|)
block|{
name|MPASS
argument_list|(
name|pr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_arena
condition|)
name|vmem_destroy
argument_list|(
name|pr
operator|->
name|pr_arena
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pscmp
parameter_list|(
name|struct
name|pageset
modifier|*
name|ps
parameter_list|,
name|struct
name|vmspace
modifier|*
name|vm
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|pgoff
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|start
operator|!=
name|start
operator|||
name|ps
operator|->
name|npages
operator|!=
name|npages
operator|||
name|ps
operator|->
name|offset
operator|!=
name|pgoff
operator|||
name|ps
operator|->
name|len
operator|!=
name|len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|ps
operator|->
name|vm
operator|!=
name|vm
operator|||
name|ps
operator|->
name|vm_timestamp
operator|!=
name|vm
operator|->
name|vm_map
operator|.
name|timestamp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hold_aio
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|,
name|struct
name|pageset
modifier|*
modifier|*
name|pps
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|pgoff
decl_stmt|;
name|struct
name|pageset
modifier|*
name|ps
decl_stmt|;
name|int
name|n
decl_stmt|;
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* 	 * The AIO subsystem will cancel and drain all requests before 	 * permitting a process to exit or exec, so p_vmspace should 	 * be stable here. 	 */
name|vm
operator|=
name|job
operator|->
name|userproc
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
name|start
operator|=
operator|(
name|uintptr_t
operator|)
name|job
operator|->
name|uaiocb
operator|.
name|aio_buf
expr_stmt|;
name|pgoff
operator|=
name|start
operator|&
name|PAGE_MASK
expr_stmt|;
name|end
operator|=
name|round_page
argument_list|(
name|start
operator|+
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
argument_list|)
expr_stmt|;
name|start
operator|=
name|trunc_page
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|start
operator|>
name|MAX_DDP_BUFFER_SIZE
condition|)
block|{
comment|/* 		 * Truncate the request to a short read. 		 * Alternatively, we could DDP in chunks to the larger 		 * buffer, but that would be quite a bit more work. 		 * 		 * When truncating, round the request down to avoid 		 * crossing a cache line on the final transaction. 		 */
name|end
operator|=
name|rounddown2
argument_list|(
name|start
operator|+
name|MAX_DDP_BUFFER_SIZE
argument_list|,
name|CACHE_LINE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_TRACES
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d, truncating size from %lu to %lu"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|end
operator|-
operator|(
name|start
operator|+
name|pgoff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|=
name|end
operator|-
operator|(
name|start
operator|+
name|pgoff
operator|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
name|round_page
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * Try to reuse a cached pageset. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|ps
argument_list|,
argument|&toep->ddp_cached_pagesets
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|pscmp
argument_list|(
name|ps
argument_list|,
name|vm
argument_list|,
name|start
argument_list|,
name|n
argument_list|,
name|pgoff
argument_list|,
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|toep
operator|->
name|ddp_cached_pagesets
argument_list|,
name|ps
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_cached_count
operator|--
expr_stmt|;
operator|*
name|pps
operator|=
name|ps
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * If there are too many cached pagesets to create a new one, 	 * free a pageset before creating a new one. 	 */
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_active_count
operator|+
name|toep
operator|->
name|ddp_cached_count
operator|<=
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
argument_list|,
operator|(
literal|"%s: too many wired pagesets"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_active_count
operator|+
name|toep
operator|->
name|ddp_cached_count
operator|==
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_cached_count
operator|>
literal|0
argument_list|,
operator|(
literal|"no cached pageset to free"
operator|)
argument_list|)
expr_stmt|;
name|ps
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|toep
operator|->
name|ddp_cached_pagesets
argument_list|,
name|pagesetq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|toep
operator|->
name|ddp_cached_pagesets
argument_list|,
name|ps
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_cached_count
operator|--
expr_stmt|;
name|free_pageset
argument_list|(
name|toep
operator|->
name|td
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* Create a new pageset. */
name|ps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ps
operator|->
name|pages
operator|=
operator|(
name|vm_page_t
operator|*
operator|)
operator|(
name|ps
operator|+
literal|1
operator|)
expr_stmt|;
name|ps
operator|->
name|vm_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
name|ps
operator|->
name|npages
operator|=
name|vm_fault_quick_hold_pages
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|VM_PROT_WRITE
argument_list|,
name|ps
operator|->
name|pages
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|npages
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|ps
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|ps
operator|->
name|npages
operator|==
name|n
argument_list|,
operator|(
literal|"hold_aio: page count mismatch: %d vs %d"
operator|,
name|ps
operator|->
name|npages
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|offset
operator|=
name|pgoff
expr_stmt|;
name|ps
operator|->
name|len
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|vm
operator|->
name|vm_refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ps
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|ps
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d, new pageset %p for job %p, npages %d"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|ps
argument_list|,
name|job
argument_list|,
name|ps
operator|->
name|npages
argument_list|)
expr_stmt|;
operator|*
name|pps
operator|=
name|ps
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddp_complete_all
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|)
condition|)
block|{
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_waiting_count
operator|--
expr_stmt|;
if|if
condition|(
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
name|ddp_complete_one
argument_list|(
name|job
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aio_ddp_cancel_one
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|long
name|copied
decl_stmt|;
comment|/* 	 * If this job had copied data out of the socket buffer before 	 * it was cancelled, report it as a short read rather than an 	 * error. 	 */
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
if|if
condition|(
name|copied
operator|!=
literal|0
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when the main loop wants to requeue a job to retry it later.  * Deals with the race of the job being cancelled while it was being  * examined.  */
end_comment

begin_function
specifier|static
name|void
name|aio_ddp_requeue_one
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_DEAD
operator|)
operator|&&
name|aio_set_cancel_function
argument_list|(
name|job
argument_list|,
name|t4_aio_cancel_queued
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_waiting_count
operator|++
expr_stmt|;
block|}
else|else
name|aio_ddp_cancel_one
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_ddp_requeue
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|td_adapter
argument_list|(
name|toep
operator|->
name|td
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|ddp_buffer
modifier|*
name|db
decl_stmt|;
name|size_t
name|copied
decl_stmt|,
name|offset
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|pageset
modifier|*
name|ps
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|ddp_flags
decl_stmt|,
name|ddp_flags_mask
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|int
name|buf_flag
decl_stmt|,
name|db_idx
decl_stmt|,
name|error
decl_stmt|;
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|restart
label|:
if|if
condition|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_DEAD
condition|)
block|{
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_waiting_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_active_count
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|toep
operator|->
name|ddp_waiting_count
operator|==
literal|0
operator|||
name|toep
operator|->
name|ddp_active_count
operator|==
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
condition|)
block|{
return|return;
block|}
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|)
expr_stmt|;
name|so
operator|=
name|job
operator|->
name|fd_file
operator|->
name|f_data
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* We will never get anything unless we are or were connected. */
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTED
operator|)
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|ddp_complete_all
argument_list|(
name|toep
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|toep
operator|->
name|ddp_active_count
operator|==
literal|0
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: pending sockbuf data and DDP is active"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Abort if socket has reported problems. */
comment|/* XXX: Wait for any queued DDP's to finish and/or flush them? */
if|if
condition|(
name|so
operator|->
name|so_error
operator|&&
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|toep
operator|->
name|ddp_waiting_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 		 * If this job has previously copied some data, report 		 * a short read and leave the error to be reported by 		 * a future request. 		 */
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
if|if
condition|(
name|copied
operator|!=
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Door is closed.  If there is pending data in the socket buffer, 	 * deliver it.  If there are pending DDP requests, wait for those 	 * to complete.  Once they have completed, return EOF reads. 	 */
if|if
condition|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|&&
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_active_count
operator|!=
literal|0
condition|)
return|return;
name|ddp_complete_all
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If DDP is not enabled and there is no pending socket buffer 	 * data, try to enable DDP. 	 */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the card to ACK that DDP is enabled before 		 * queueing any buffers.  Currently this waits for an 		 * indicate to arrive.  This could use a TCB_SET_FIELD_RPL 		 * message to know that DDP was enabled instead of waiting 		 * for the indicate which would avoid copying the indicate 		 * if no data is pending. 		 * 		 * XXX: Might want to limit the indicate size to the size 		 * of the first queued request. 		 */
if|if
condition|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_SC_REQ
operator|)
operator|==
literal|0
condition|)
name|enable_ddp
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
return|return;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * If another thread is queueing a buffer for DDP, let it 	 * drain any work and return. 	 */
if|if
condition|(
name|toep
operator|->
name|ddp_queueing
operator|!=
name|NULL
condition|)
return|return;
comment|/* Take the next job to prep it for DDP. */
name|toep
operator|->
name|ddp_waiting_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
goto|goto
name|restart
goto|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|job
expr_stmt|;
comment|/* NB: This drops DDP_LOCK while it holds the backing VM pages. */
name|error
operator|=
name|hold_aio
argument_list|(
name|toep
argument_list|,
name|job
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ddp_complete_one
argument_list|(
name|job
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
operator|&&
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
if|if
condition|(
name|copied
operator|!=
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|&&
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_active_count
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * The door is closed, but there are still pending 			 * DDP buffers.  Requeue.  These jobs will all be 			 * completed once those buffers drain. 			 */
name|aio_ddp_requeue_one
argument_list|(
name|toep
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|ddp_complete_one
argument_list|(
name|job
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ddp_complete_all
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|sbcopy
label|:
comment|/* 	 * If the toep is dead, there shouldn't be any data in the socket 	 * buffer, so the above case should have handled this. 	 */
name|MPASS
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_DEAD
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there is pending data in the socket buffer (either 	 * from before the requests were queued or a DDP indicate), 	 * copy those mbufs out directly. 	 */
name|copied
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|ps
operator|->
name|offset
operator|+
name|job
operator|->
name|aio_received
expr_stmt|;
name|MPASS
argument_list|(
name|job
operator|->
name|aio_received
operator|<=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
argument_list|)
expr_stmt|;
name|resid
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|-
name|job
operator|->
name|aio_received
expr_stmt|;
name|m
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
operator|||
name|toep
operator|->
name|ddp_active_count
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: sockbuf data with active DDP"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|resid
operator|>
literal|0
condition|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|>
name|resid
condition|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|resid
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|uiomove_fromphys
argument_list|(
name|ps
operator|->
name|pages
argument_list|,
name|offset
operator|+
name|copied
argument_list|,
name|uio
operator|.
name|uio_resid
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|.
name|uio_resid
operator|==
literal|0
argument_list|)
expr_stmt|;
name|copied
operator|+=
name|uio
operator|.
name|uio_offset
expr_stmt|;
name|resid
operator|-=
name|uio
operator|.
name|uio_offset
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|copied
operator|!=
literal|0
condition|)
block|{
name|sbdrop_locked
argument_list|(
name|sb
argument_list|,
name|copied
argument_list|)
expr_stmt|;
name|job
operator|->
name|aio_received
operator|+=
name|copied
expr_stmt|;
name|job
operator|->
name|msgrcv
operator|=
literal|1
expr_stmt|;
name|copied
operator|=
name|job
operator|->
name|aio_received
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INP_TRY_WLOCK
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* 			 * The reference on the socket file descriptor in 			 * the AIO job should keep 'sb' and 'inp' stable. 			 * Our caller has a reference on the 'toep' that 			 * keeps it stable. 			 */
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 			 * If the socket has been closed, we should detect 			 * that and complete this request if needed on 			 * the next trip around the loop. 			 */
block|}
name|t4_rcvd_locked
argument_list|(
operator|&
name|toep
operator|->
name|td
operator|->
name|tod
argument_list|,
name|intotcpcb
argument_list|(
name|inp
argument_list|)
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid
operator|==
literal|0
operator|||
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_DEAD
condition|)
block|{
comment|/* 			 * We filled the entire buffer with socket 			 * data, DDP is not being used, or the socket 			 * is being shut down, so complete the 			 * request. 			 */
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
name|copied
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 		 * If DDP is not enabled, requeue this request and restart. 		 * This will either enable DDP or wait for more data to 		 * arrive on the socket buffer. 		 */
if|if
condition|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
operator|(
name|DDP_ON
operator||
name|DDP_SC_REQ
operator|)
operator|)
operator|!=
name|DDP_ON
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|aio_ddp_requeue_one
argument_list|(
name|toep
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 		 * An indicate might have arrived and been added to 		 * the socket buffer while it was unlocked after the 		 * copy to lock the INP.  If so, restart the copy. 		 */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|sbcopy
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|prep_pageset
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|ps
argument_list|)
operator|==
literal|0
condition|)
block|{
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|aio_ddp_requeue_one
argument_list|(
name|toep
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * XXX: Need to retry this later.  Mostly need a trigger 		 * when page pods are freed up. 		 */
name|printf
argument_list|(
literal|"%s: prep_pageset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine which DDP buffer to use. */
if|if
condition|(
name|toep
operator|->
name|db
index|[
literal|0
index|]
operator|.
name|job
operator|==
name|NULL
condition|)
block|{
name|db_idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
name|toep
operator|->
name|db
index|[
literal|1
index|]
operator|.
name|job
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|db_idx
operator|=
literal|1
expr_stmt|;
block|}
name|ddp_flags
operator|=
literal|0
expr_stmt|;
name|ddp_flags_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db_idx
operator|==
literal|0
condition|)
block|{
name|ddp_flags
operator||=
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
condition|)
name|ddp_flags
operator||=
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ddp_flags_mask
operator||=
name|V_TF_DDP_PSH_NO_INVALIDATE0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSHF_ENABLE_0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|buf_flag
operator|=
name|DDP_BUF0_ACTIVE
expr_stmt|;
block|}
else|else
block|{
name|ddp_flags
operator||=
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
condition|)
name|ddp_flags
operator||=
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ddp_flags_mask
operator||=
name|V_TF_DDP_PSH_NO_INVALIDATE1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSHF_ENABLE_1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|buf_flag
operator|=
name|DDP_BUF1_ACTIVE
expr_stmt|;
block|}
name|MPASS
argument_list|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|buf_flag
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
operator|(
name|DDP_BUF0_ACTIVE
operator||
name|DDP_BUF1_ACTIVE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|MPASS
argument_list|(
name|db_idx
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_active_id
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_active_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ddp_flags_mask
operator||=
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The TID for this connection should still be valid.  If DDP_DEAD 	 * is set, SBS_CANTRCVMORE should be set, so we shouldn't be 	 * this far anyway.  Even if the socket is closing on the other 	 * end, the AIO job holds a reference on this end of the socket 	 * which will keep it open and keep the TCP PCB attached until 	 * after the job is completed. 	 */
name|wr
operator|=
name|mk_update_tcb_for_ddp
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|db_idx
argument_list|,
name|ps
argument_list|,
name|job
operator|->
name|aio_received
argument_list|,
name|ddp_flags
argument_list|,
name|ddp_flags_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|aio_ddp_requeue_one
argument_list|(
name|toep
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * XXX: Need a way to kick a retry here. 		 * 		 * XXX: We know the fixed size needed and could 		 * preallocate this using a blocking request at the 		 * start of the task to avoid having to handle this 		 * edge case. 		 */
name|printf
argument_list|(
literal|"%s: mk_update_tcb_for_ddp failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|aio_set_cancel_function
argument_list|(
name|job
argument_list|,
name|t4_aio_cancel_active
argument_list|)
condition|)
block|{
name|free_wrqe
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|recycle_pageset
argument_list|(
name|toep
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|aio_ddp_cancel_one
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE_TRACES
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: scheduling %p for DDP[%d] (flags %#lx/%#lx)"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|,
name|db_idx
argument_list|,
name|ddp_flags
argument_list|,
name|ddp_flags_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Give the chip the go-ahead. */
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|db
operator|=
operator|&
name|toep
operator|->
name|db
index|[
name|db_idx
index|]
expr_stmt|;
name|db
operator|->
name|cancel_pending
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|job
operator|=
name|job
expr_stmt|;
name|db
operator|->
name|ps
operator|=
name|ps
expr_stmt|;
name|toep
operator|->
name|ddp_queueing
operator|=
name|NULL
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator||=
name|buf_flag
expr_stmt|;
name|toep
operator|->
name|ddp_active_count
operator|++
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_active_count
operator|==
literal|1
condition|)
block|{
name|MPASS
argument_list|(
name|toep
operator|->
name|ddp_active_id
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_active_id
operator|=
name|db_idx
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: ddp_active_id = %d"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|ddp_active_id
argument_list|)
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
end_function

begin_function
name|void
name|ddp_queue_toep
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|DDP_ASSERT_LOCKED
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_TASK_ACTIVE
condition|)
return|return;
name|toep
operator|->
name|ddp_flags
operator||=
name|DDP_TASK_ACTIVE
expr_stmt|;
name|hold_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|soaio_enqueue
argument_list|(
operator|&
name|toep
operator|->
name|ddp_requeue_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_ddp_requeue_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|context
decl_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|aio_ddp_requeue
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator|&=
operator|~
name|DDP_TASK_ACTIVE
expr_stmt|;
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|free_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_aio_cancel_active
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|job
operator|->
name|fd_file
operator|->
name|f_data
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|td_adapter
argument_list|(
name|toep
operator|->
name|td
argument_list|)
decl_stmt|;
name|uint64_t
name|valid_flag
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_cancel_cleared
argument_list|(
name|job
argument_list|)
condition|)
block|{
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|aio_ddp_cancel_one
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|toep
operator|->
name|db
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|.
name|job
operator|==
name|job
condition|)
block|{
comment|/* Should only ever get one cancel request for a job. */
name|MPASS
argument_list|(
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|.
name|cancel_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Invalidate this buffer.  It will be 			 * cancelled or partially completed once the 			 * card ACKs the invalidate. 			 */
name|valid_flag
operator|=
name|i
operator|==
literal|0
condition|?
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
else|:
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|valid_flag
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|i
operator|+
name|DDP_BUF0_INVALIDATED
argument_list|,
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|toep
operator|->
name|db
index|[
name|i
index|]
operator|.
name|cancel_pending
operator|=
literal|1
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: request %p marked pending"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_aio_cancel_queued
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|job
operator|->
name|fd_file
operator|->
name|f_data
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_cancel_cleared
argument_list|(
name|job
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_waiting_count
operator|--
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ddp_waiting_count
operator|==
literal|0
condition|)
name|ddp_queue_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: request %p cancelled"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|aio_ddp_cancel_one
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t4_aio_queue_ddp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
comment|/* Ignore writes. */
if|if
condition|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|!=
name|LIO_READ
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Think about possibly returning errors for ENOTCONN, 	 * etc.  Perhaps the caller would only queue the request 	 * if it failed with EOPNOTSUPP? 	 */
ifdef|#
directive|ifdef
name|VERBOSE_TRACES
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: queueing %p"
argument_list|,
name|__func__
argument_list|,
name|job
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|aio_set_cancel_function
argument_list|(
name|job
argument_list|,
name|t4_aio_cancel_queued
argument_list|)
condition|)
name|panic
argument_list|(
literal|"new job was cancelled"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|toep
operator|->
name|ddp_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ddp_waiting_count
operator|++
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator||=
name|DDP_OK
expr_stmt|;
comment|/* 	 * Try to handle this request synchronously.  If this has 	 * to block because the task is running, it will just bail 	 * and let the task handle it instead. 	 */
name|aio_ddp_requeue
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_ddp_mod_load
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_RX_DATA_DDP
argument_list|,
name|do_rx_data_ddp
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_RX_DDP_COMPLETE
argument_list|,
name|do_rx_ddp_complete
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ddp_orphan_pagesets
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|,
literal|"ddp orphans"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ddp_orphan_task
argument_list|,
literal|0
argument_list|,
name|ddp_free_orphan_pagesets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_ddp_mod_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ddp_orphan_task
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ddp_orphan_pagesets
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ddp_orphan_pagesets_lock
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_RX_DATA_DDP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_RX_DDP_COMPLETE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

