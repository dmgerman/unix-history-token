begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012, 2015 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_tcb.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom_l2t.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_do_autosndbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_autosndbuf
value|VNET(tcp_do_autosndbuf)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autosndbuf_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autosndbuf_inc
value|VNET(tcp_autosndbuf_inc)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autosndbuf_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autosndbuf_max
value|VNET(tcp_autosndbuf_max)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_do_autorcvbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_autorcvbuf
value|VNET(tcp_do_autorcvbuf)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_inc
value|VNET(tcp_autorcvbuf_inc)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_max
value|VNET(tcp_autorcvbuf_max)
end_define

begin_function
name|void
name|send_flowc_wr
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|flowc_tx_params
modifier|*
name|ftxp
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_flowc_wr
modifier|*
name|flowc
decl_stmt|;
name|unsigned
name|int
name|nparams
init|=
name|ftxp
condition|?
literal|8
else|:
literal|6
decl_stmt|,
name|flowclen
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|toep
operator|->
name|vi
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|unsigned
name|int
name|pfvf
init|=
name|G_FW_VIID_PFN
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
operator|<<
name|S_FW_VIID_PFN
decl_stmt|;
name|struct
name|ofld_tx_sdesc
modifier|*
name|txsd
init|=
operator|&
name|toep
operator|->
name|txsd
index|[
name|toep
operator|->
name|txsd_pidx
index|]
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FLOWC_WR_SENT
operator|)
argument_list|,
operator|(
literal|"%s: flowc for tid %u sent already"
operator|,
name|__func__
operator|,
name|toep
operator|->
name|tid
operator|)
argument_list|)
expr_stmt|;
name|flowclen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|flowc
argument_list|)
operator|+
name|nparams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fw_flowc_mnemval
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|roundup2
argument_list|(
name|flowclen
argument_list|,
literal|16
argument_list|)
argument_list|,
name|toep
operator|->
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|flowc
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|flowc
argument_list|,
literal|0
argument_list|,
name|wr
operator|->
name|wr_len
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|op_to_nparams
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FLOWC_WR
argument_list|)
operator||
name|V_FW_FLOWC_WR_NPARAMS
argument_list|(
name|nparams
argument_list|)
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|flowid_len16
operator|=
name|htonl
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
name|howmany
argument_list|(
name|flowclen
argument_list|,
literal|16
argument_list|)
argument_list|)
operator||
name|V_FW_WR_FLOWID
argument_list|(
name|toep
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|0
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_PFNVFN
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|0
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pfvf
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|1
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_CH
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|2
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_PORT
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|3
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_IQID
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|3
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftxp
condition|)
block|{
name|uint32_t
name|sndbuf
init|=
name|min
argument_list|(
name|ftxp
operator|->
name|snd_space
argument_list|,
name|sc
operator|->
name|tt
operator|.
name|sndbuf
argument_list|)
decl_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|4
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_SNDNXT
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|4
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|ftxp
operator|->
name|snd_nxt
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|5
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_RCVNXT
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|5
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|ftxp
operator|->
name|rcv_nxt
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|6
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_SNDBUF
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|6
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|7
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_MSS
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|7
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|ftxp
operator|->
name|mss
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, mss %u, sndbuf %u, snd_nxt 0x%x, rcv_nxt 0x%x"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|ftxp
operator|->
name|mss
argument_list|,
name|sndbuf
argument_list|,
name|ftxp
operator|->
name|snd_nxt
argument_list|,
name|ftxp
operator|->
name|rcv_nxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flowc
operator|->
name|mnemval
index|[
literal|4
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_SNDBUF
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|4
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|5
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_MSS
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|5
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
name|txsd
operator|->
name|tx_credits
operator|=
name|howmany
argument_list|(
name|flowclen
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|plen
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tx_credits
operator|>=
name|txsd
operator|->
name|tx_credits
operator|&&
name|toep
operator|->
name|txsd_avail
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: not enough credits (%d)"
operator|,
name|__func__
operator|,
name|toep
operator|->
name|tx_credits
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tx_credits
operator|-=
name|txsd
operator|->
name|tx_credits
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|toep
operator|->
name|txsd_pidx
operator|==
name|toep
operator|->
name|txsd_total
argument_list|)
condition|)
name|toep
operator|->
name|txsd_pidx
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|txsd_avail
operator|--
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_FLOWC_WR_SENT
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_reset
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|uint32_t
name|snd_nxt
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_abort_req
modifier|*
name|req
decl_stmt|;
name|int
name|tid
init|=
name|toep
operator|->
name|tid
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
comment|/* don't use if INP_DROPPED */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d (%s), toep_flags 0x%x, inp_flags 0x%x%s"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|?
literal|"inp dropped"
else|:
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|,
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|?
literal|" (abort already in progress)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|)
return|return;
comment|/* abort already in progress */
name|toep
operator|->
name|flags
operator||=
name|TPF_ABORT_SHUTDOWN
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FLOWC_WR_SENT
argument_list|,
operator|(
literal|"%s: flowc_wr not sent for tid %d."
operator|,
name|__func__
operator|,
name|tid
operator|)
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|toep
operator|->
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|req
argument_list|,
name|CPL_ABORT_REQ
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
name|req
operator|->
name|rsvd0
operator|=
name|htobe32
argument_list|(
name|snd_nxt
argument_list|)
expr_stmt|;
else|else
name|req
operator|->
name|rsvd0
operator|=
name|htobe32
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd1
operator|=
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_TX_DATA_SENT
operator|)
expr_stmt|;
name|req
operator|->
name|cmd
operator|=
name|CPL_ABORT_SEND_RST
expr_stmt|;
comment|/* 	 * XXX: What's the correct way to tell that the inp hasn't been detached 	 * from its socket?  Should I even be flushing the snd buffer here? 	 */
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_DROPPED
operator||
name|INP_TIMEWAIT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
comment|/* because I'm not sure.  See comment above */
name|sbflush
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a connection is established to translate the TCP options  * reported by HW to FreeBSD's native format.  */
end_comment

begin_function
specifier|static
name|void
name|assign_rxopt
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|unsigned
name|int
name|opt
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|td_adapter
argument_list|(
name|toep
operator|->
name|td
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_inc
operator|.
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|sc
operator|->
name|params
operator|.
name|mtus
index|[
name|G_TCPOPT_MSS
argument_list|(
name|opt
argument_list|)
index|]
operator|-
name|n
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d, mtu_idx %u (%u)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|G_TCPOPT_MSS
argument_list|(
name|opt
argument_list|)
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
index|[
name|G_TCPOPT_MSS
argument_list|(
name|opt
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_TCPOPT_TSTAMP
argument_list|(
name|opt
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_TSTMP
expr_stmt|;
comment|/* timestamps ok */
name|tp
operator|->
name|ts_recent
operator|=
literal|0
expr_stmt|;
comment|/* hmmm */
name|tp
operator|->
name|ts_recent_age
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|G_TCPOPT_SACK
argument_list|(
name|opt
argument_list|)
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_SACK_PERMIT
expr_stmt|;
comment|/* should already be set */
else|else
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_SACK_PERMIT
expr_stmt|;
comment|/* sack disallowed by peer */
if|if
condition|(
name|G_TCPOPT_WSCALE_OK
argument_list|(
name|opt
argument_list|)
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_SCALE
expr_stmt|;
comment|/* Doing window scaling? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
name|tp
operator|->
name|snd_scale
operator|=
name|G_TCPOPT_SND_WSCALE
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Completes some final bits of initialization for just established connections  * and changes their state to TCPS_ESTABLISHED.  *  * The ISNs are from after the exchange of SYNs.  i.e., the true ISN + 1.  */
end_comment

begin_function
name|void
name|make_established
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|uint32_t
name|snd_isn
parameter_list|,
name|uint32_t
name|rcv_isn
parameter_list|,
name|uint16_t
name|opt
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|long
name|bufsize
decl_stmt|;
name|uint32_t
name|iss
init|=
name|be32toh
argument_list|(
name|snd_isn
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* true ISS */
name|uint32_t
name|irs
init|=
name|be32toh
argument_list|(
name|rcv_isn
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* true IRS */
name|uint16_t
name|tcpopt
init|=
name|be16toh
argument_list|(
name|opt
argument_list|)
decl_stmt|;
name|struct
name|flowc_tx_params
name|ftxp
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
operator|||
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
argument_list|,
operator|(
literal|"%s: TCP state %s"
operator|,
name|__func__
operator|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d, toep %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|toep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_connects
argument_list|)
expr_stmt|;
name|tp
operator|->
name|irs
operator|=
name|irs
expr_stmt|;
name|tcp_rcvseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|=
name|toep
operator|->
name|rx_credits
operator|<<
literal|10
expr_stmt|;
name|tp
operator|->
name|rcv_adv
operator|+=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|tp
operator|->
name|last_ack_sent
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
comment|/* 	 * If we were unable to send all rx credits via opt0, save the remainder 	 * in rx_credits so that they can be handed over with the next credit 	 * update. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|=
name|bufsize
operator|-
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|tp
operator|->
name|iss
operator|=
name|iss
expr_stmt|;
name|tcp_sendseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|iss
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|iss
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|snd_max
operator|=
name|iss
operator|+
literal|1
expr_stmt|;
name|assign_rxopt
argument_list|(
name|tp
argument_list|,
name|tcpopt
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|&&
name|V_tcp_do_autosndbuf
condition|)
name|bufsize
operator|=
name|V_tcp_autosndbuf_max
expr_stmt|;
else|else
name|bufsize
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|ftxp
operator|.
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_nxt
expr_stmt|;
name|ftxp
operator|.
name|rcv_nxt
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|ftxp
operator|.
name|snd_space
operator|=
name|bufsize
expr_stmt|;
name|ftxp
operator|.
name|mss
operator|=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
name|send_flowc_wr
argument_list|(
name|toep
argument_list|,
operator|&
name|ftxp
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_rx_credits
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|credits
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_rx_data_ack
modifier|*
name|req
decl_stmt|;
name|uint32_t
name|dack
init|=
name|F_RX_DACK_CHANGE
operator||
name|V_RX_DACK_MODE
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|credits
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: %d credits"
operator|,
name|__func__
operator|,
name|credits
operator|)
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|req
argument_list|,
name|CPL_RX_DATA_ACK
argument_list|,
name|toep
operator|->
name|tid
argument_list|)
expr_stmt|;
name|req
operator|->
name|credit_dack
operator|=
name|htobe32
argument_list|(
name|dack
operator||
name|V_RX_CREDITS
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
name|credits
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_rcvd_locked
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|int
name|credits
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|sb_cc
operator|>=
name|sbused
argument_list|(
name|sb
argument_list|)
argument_list|,
operator|(
literal|"%s: sb %p has more data (%d) than last time (%d)."
operator|,
name|__func__
operator|,
name|sb
operator|,
name|sbused
argument_list|(
name|sb
argument_list|)
operator|,
name|toep
operator|->
name|sb_cc
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|+=
name|toep
operator|->
name|sb_cc
operator|-
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|toep
operator|->
name|sb_cc
operator|=
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|rx_credits
operator|>
literal|0
operator|&&
operator|(
name|tp
operator|->
name|rcv_wnd
operator|<=
literal|32
operator|*
literal|1024
operator|||
name|toep
operator|->
name|rx_credits
operator|>=
literal|64
operator|*
literal|1024
operator|||
operator|(
name|toep
operator|->
name|rx_credits
operator|>=
literal|16
operator|*
literal|1024
operator|&&
name|tp
operator|->
name|rcv_wnd
operator|<=
literal|128
operator|*
literal|1024
operator|)
operator|||
name|toep
operator|->
name|sb_cc
operator|+
name|tp
operator|->
name|rcv_wnd
operator|<
name|sb
operator|->
name|sb_lowat
operator|)
condition|)
block|{
name|credits
operator|=
name|send_rx_credits
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|rx_credits
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|-=
name|credits
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|+=
name|credits
expr_stmt|;
name|tp
operator|->
name|rcv_adv
operator|+=
name|credits
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_rcvd
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|t4_rcvd_locked
argument_list|(
name|tod
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a connection by sending a CPL_CLOSE_CON_REQ message.  */
end_comment

begin_function
specifier|static
name|int
name|close_conn
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_close_con_req
modifier|*
name|req
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tid
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u%s"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|toep
operator|->
name|flags
operator|&
name|TPF_FIN_SENT
condition|?
literal|", IGNORED"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FIN_SENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FLOWC_WR_SENT
argument_list|,
operator|(
literal|"%s: flowc_wr not sent for tid %u."
operator|,
name|__func__
operator|,
name|tid
operator|)
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|toep
operator|->
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_TP_WR
argument_list|)
operator||
name|V_FW_WR_IMMDLEN
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|req
operator|->
name|wr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_mid
operator|=
name|htonl
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
operator||
name|V_FW_WR_FLOWID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|cpu_to_be64
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_CLOSE_CON_REQ
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_FIN_SENT
expr_stmt|;
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_SEND_FIN
expr_stmt|;
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_OFLD_TX_CREDITS
value|(SGE_MAX_WR_LEN / 16)
end_define

begin_define
define|#
directive|define
name|MIN_OFLD_TX_CREDITS
value|(howmany(sizeof(struct fw_ofld_tx_data_wr) + 1, 16))
end_define

begin_comment
comment|/* Maximum amount of immediate data we could stuff in a WR */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|max_imm_payload
parameter_list|(
name|int
name|tx_credits
parameter_list|)
block|{
specifier|const
name|int
name|n
init|=
literal|2
decl_stmt|;
comment|/* Use only up to 2 desc for imm. data WR */
name|KASSERT
argument_list|(
name|tx_credits
operator|>=
literal|0
operator|&&
name|tx_credits
operator|<=
name|MAX_OFLD_TX_CREDITS
argument_list|,
operator|(
literal|"%s: %d credits"
operator|,
name|__func__
operator|,
name|tx_credits
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_credits
operator|<
name|MIN_OFLD_TX_CREDITS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tx_credits
operator|>=
operator|(
name|n
operator|*
name|EQ_ESIZE
operator|)
operator|/
literal|16
condition|)
return|return
operator|(
operator|(
name|n
operator|*
name|EQ_ESIZE
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|fw_ofld_tx_data_wr
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|tx_credits
operator|*
literal|16
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|fw_ofld_tx_data_wr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Maximum number of SGL entries we could stuff in a WR */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|max_dsgl_nsegs
parameter_list|(
name|int
name|tx_credits
parameter_list|)
block|{
name|int
name|nseg
init|=
literal|1
decl_stmt|;
comment|/* ulptx_sgl has room for 1, rest ulp_tx_sge_pair */
name|int
name|sge_pair_credits
init|=
name|tx_credits
operator|-
name|MIN_OFLD_TX_CREDITS
decl_stmt|;
name|KASSERT
argument_list|(
name|tx_credits
operator|>=
literal|0
operator|&&
name|tx_credits
operator|<=
name|MAX_OFLD_TX_CREDITS
argument_list|,
operator|(
literal|"%s: %d credits"
operator|,
name|__func__
operator|,
name|tx_credits
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_credits
operator|<
name|MIN_OFLD_TX_CREDITS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nseg
operator|+=
literal|2
operator|*
operator|(
name|sge_pair_credits
operator|*
literal|16
operator|/
literal|24
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sge_pair_credits
operator|*
literal|16
operator|)
operator|%
literal|24
operator|==
literal|16
condition|)
name|nseg
operator|++
expr_stmt|;
return|return
operator|(
name|nseg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|write_tx_wr
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|immdlen
parameter_list|,
name|unsigned
name|int
name|plen
parameter_list|,
name|uint8_t
name|credits
parameter_list|,
name|int
name|shove
parameter_list|,
name|int
name|ulp_submode
parameter_list|,
name|int
name|txalign
parameter_list|)
block|{
name|struct
name|fw_ofld_tx_data_wr
modifier|*
name|txwr
init|=
name|dst
decl_stmt|;
name|txwr
operator|->
name|op_to_immdlen
operator|=
name|htobe32
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_OFLD_TX_DATA_WR
argument_list|)
operator||
name|V_FW_WR_IMMDLEN
argument_list|(
name|immdlen
argument_list|)
argument_list|)
expr_stmt|;
name|txwr
operator|->
name|flowid_len16
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_FLOWID
argument_list|(
name|toep
operator|->
name|tid
argument_list|)
operator||
name|V_FW_WR_LEN16
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
name|txwr
operator|->
name|lsodisable_to_flags
operator|=
name|htobe32
argument_list|(
name|V_TX_ULP_MODE
argument_list|(
name|toep
operator|->
name|ulp_mode
argument_list|)
operator||
name|V_TX_ULP_SUBMODE
argument_list|(
name|ulp_submode
argument_list|)
operator||
name|V_TX_URG
argument_list|(
literal|0
argument_list|)
operator||
name|V_TX_SHOVE
argument_list|(
name|shove
argument_list|)
argument_list|)
expr_stmt|;
name|txwr
operator|->
name|plen
operator|=
name|htobe32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|txalign
operator|>
literal|0
condition|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|toep
operator|->
name|inp
argument_list|)
decl_stmt|;
if|if
condition|(
name|plen
operator|<
literal|2
operator|*
name|tp
operator|->
name|t_maxseg
operator|||
name|is_10G_port
argument_list|(
name|toep
operator|->
name|vi
operator|->
name|pi
argument_list|)
condition|)
name|txwr
operator|->
name|lsodisable_to_flags
operator||=
name|htobe32
argument_list|(
name|F_FW_OFLD_TX_DATA_WR_LSODISABLE
argument_list|)
expr_stmt|;
else|else
name|txwr
operator|->
name|lsodisable_to_flags
operator||=
name|htobe32
argument_list|(
name|F_FW_OFLD_TX_DATA_WR_ALIGNPLD
operator||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NODELAY
condition|?
literal|0
else|:
name|F_FW_OFLD_TX_DATA_WR_ALIGNPLDSHOVE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate a DSGL from a starting mbuf.  The total number of segments and the  * maximum segments in any one mbuf are provided.  */
end_comment

begin_function
specifier|static
name|void
name|write_tx_sgl
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|struct
name|mbuf
modifier|*
name|start
parameter_list|,
name|struct
name|mbuf
modifier|*
name|stop
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ulptx_sgl
modifier|*
name|usgl
init|=
name|dst
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
name|n
index|]
decl_stmt|;
name|KASSERT
argument_list|(
name|nsegs
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: nsegs 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
name|n
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|cmd_nsge
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_DSGL
argument_list|)
operator||
name|V_ULPTX_NSGE
argument_list|(
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|m
operator|=
name|start
init|;
name|m
operator|!=
name|stop
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|rc
operator|=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: sglist_append %d"
argument_list|,
name|__func__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sg
operator|.
name|sg_nseg
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|usgl
operator|->
name|len0
operator|=
name|htobe32
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ss_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|addr0
operator|=
name|htobe64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ss_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|len
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ss_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|addr
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ss_paddr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|nsegs
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
name|sglist_reset
argument_list|(
operator|&
name|sg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|len
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: nsegs %d, start %p, stop %p"
operator|,
name|__func__
operator|,
name|nsegs
operator|,
name|start
operator|,
name|stop
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Max number of SGL entries an offload tx work request can have.  This is 41  * (1 + 40) for a full 512B work request.  * fw_ofld_tx_data_wr(16B) + ulptx_sgl(16B, 1) + ulptx_sge_pair(480B, 40)  */
end_comment

begin_define
define|#
directive|define
name|OFLD_SGL_LEN
value|(41)
end_define

begin_comment
comment|/*  * Send data and/or a FIN to the peer.  *  * The socket's so_snd buffer consists of a stream of data starting with sb_mb  * and linked together with m_next.  sb_sndptr, if set, is the last mbuf that  * was transmitted.  *  * drop indicates the number of bytes that should be dropped from the head of  * the send buffer.  It is an optimization that lets do_fw4_ack avoid creating  * contention on the send buffer lock (before this change it used to do  * sowwakeup and then t4_push_frames right after that when recovering from tx  * stalls).  When drop is set this function MUST drop the bytes and wake up any  * writers.  */
end_comment

begin_function
name|void
name|t4_push_frames
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|drop
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|sndptr
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|sb_sndptr
decl_stmt|;
name|struct
name|fw_ofld_tx_data_wr
modifier|*
name|txwr
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|u_int
name|plen
decl_stmt|,
name|nsegs
decl_stmt|,
name|credits
decl_stmt|,
name|max_imm
decl_stmt|,
name|max_nsegs
decl_stmt|,
name|max_nsegs_1mbuf
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_snd
decl_stmt|;
name|int
name|tx_credits
decl_stmt|,
name|shove
decl_stmt|,
name|compl
decl_stmt|,
name|sowwakeup
decl_stmt|;
name|struct
name|ofld_tx_sdesc
modifier|*
name|txsd
init|=
operator|&
name|toep
operator|->
name|txsd
index|[
name|toep
operator|->
name|txsd_pidx
index|]
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FLOWC_WR_SENT
argument_list|,
operator|(
literal|"%s: flowc_wr not sent for tid %u."
operator|,
name|__func__
operator|,
name|toep
operator|->
name|tid
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_NONE
operator|||
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
operator|||
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_RDMA
argument_list|,
operator|(
literal|"%s: ulp_mode %u for toep %p"
operator|,
name|__func__
operator|,
name|toep
operator|->
name|ulp_mode
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|)
condition|)
return|return;
comment|/* 	 * This function doesn't resume by itself.  Someone else must clear the 	 * flag and call this function. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_TX_SUSPENDED
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|drop
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: drop (%d) != 0 but tx is suspended"
operator|,
name|__func__
operator|,
name|drop
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|tx_credits
operator|=
name|min
argument_list|(
name|toep
operator|->
name|tx_credits
argument_list|,
name|MAX_OFLD_TX_CREDITS
argument_list|)
expr_stmt|;
name|max_imm
operator|=
name|max_imm_payload
argument_list|(
name|tx_credits
argument_list|)
expr_stmt|;
name|max_nsegs
operator|=
name|max_dsgl_nsegs
argument_list|(
name|tx_credits
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sowwakeup
operator|=
name|drop
expr_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
name|sbdrop_locked
argument_list|(
name|sb
argument_list|,
name|drop
argument_list|)
expr_stmt|;
name|drop
operator|=
literal|0
expr_stmt|;
block|}
name|sb_sndptr
operator|=
name|sb
operator|->
name|sb_sndptr
expr_stmt|;
name|sndptr
operator|=
name|sb_sndptr
condition|?
name|sb_sndptr
operator|->
name|m_next
else|:
name|sb
operator|->
name|sb_mb
expr_stmt|;
name|plen
operator|=
literal|0
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
name|max_nsegs_1mbuf
operator|=
literal|0
expr_stmt|;
comment|/* max # of SGL segments in any one mbuf */
for|for
control|(
name|m
operator|=
name|sndptr
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|int
name|n
init|=
name|sglist_count
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
decl_stmt|;
name|nsegs
operator|+=
name|n
expr_stmt|;
name|plen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* This mbuf sent us _over_ the nsegs limit, back out */
if|if
condition|(
name|plen
operator|>
name|max_imm
operator|&&
name|nsegs
operator|>
name|max_nsegs
condition|)
block|{
name|nsegs
operator|-=
name|n
expr_stmt|;
name|plen
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
comment|/* Too few credits */
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
if|if
condition|(
name|sowwakeup
condition|)
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
name|max_nsegs_1mbuf
operator|<
name|n
condition|)
name|max_nsegs_1mbuf
operator|=
name|n
expr_stmt|;
name|sb_sndptr
operator|=
name|m
expr_stmt|;
comment|/* new sb->sb_sndptr if all goes well */
comment|/* This mbuf put us right at the max_nsegs limit */
if|if
condition|(
name|plen
operator|>
name|max_imm
operator|&&
name|nsegs
operator|==
name|max_nsegs
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sbused
argument_list|(
name|sb
argument_list|)
operator|>
name|sb
operator|->
name|sb_hiwat
operator|*
literal|5
operator|/
literal|8
operator|&&
name|toep
operator|->
name|plen_nocompl
operator|+
name|plen
operator|>=
name|sb
operator|->
name|sb_hiwat
operator|/
literal|4
condition|)
name|compl
operator|=
literal|1
expr_stmt|;
else|else
name|compl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|&&
name|V_tcp_do_autosndbuf
operator|&&
name|sb
operator|->
name|sb_hiwat
operator|<
name|V_tcp_autosndbuf_max
operator|&&
name|sbused
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_hiwat
operator|*
literal|7
operator|/
literal|8
condition|)
block|{
name|int
name|newsize
init|=
name|min
argument_list|(
name|sb
operator|->
name|sb_hiwat
operator|+
name|V_tcp_autosndbuf_inc
argument_list|,
name|V_tcp_autosndbuf_max
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sbreserve_locked
argument_list|(
name|sb
argument_list|,
name|newsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
condition|)
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
else|else
name|sowwakeup
operator|=
literal|1
expr_stmt|;
comment|/* room available */
block|}
if|if
condition|(
name|sowwakeup
condition|)
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* nothing to send */
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: nothing to send, but m != NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FIN_SENT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: excess tx."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|shove
operator|=
name|m
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_MORETOCOME
operator|)
expr_stmt|;
if|if
condition|(
name|plen
operator|<=
name|max_imm
condition|)
block|{
comment|/* Immediate data tx */
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|txwr
argument_list|)
operator|+
name|plen
argument_list|,
literal|16
argument_list|)
argument_list|,
name|toep
operator|->
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX: how will we recover from this? */
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
return|return;
block|}
name|txwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|credits
operator|=
name|howmany
argument_list|(
name|wr
operator|->
name|wr_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_tx_wr
argument_list|(
name|txwr
argument_list|,
name|toep
argument_list|,
name|plen
argument_list|,
name|plen
argument_list|,
name|credits
argument_list|,
name|shove
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|tt
operator|.
name|tx_align
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|sndptr
argument_list|,
literal|0
argument_list|,
name|plen
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|txwr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|wr_len
decl_stmt|;
comment|/* DSGL tx */
name|wr_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|txwr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_sgl
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|*
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|/
literal|2
operator|+
operator|(
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
operator|)
operator|*
literal|8
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|roundup2
argument_list|(
name|wr_len
argument_list|,
literal|16
argument_list|)
argument_list|,
name|toep
operator|->
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX: how will we recover from this? */
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
return|return;
block|}
name|txwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|credits
operator|=
name|howmany
argument_list|(
name|wr_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_tx_wr
argument_list|(
name|txwr
argument_list|,
name|toep
argument_list|,
literal|0
argument_list|,
name|plen
argument_list|,
name|credits
argument_list|,
name|shove
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|tt
operator|.
name|tx_align
argument_list|)
expr_stmt|;
name|write_tx_sgl
argument_list|(
name|txwr
operator|+
literal|1
argument_list|,
name|sndptr
argument_list|,
name|m
argument_list|,
name|nsegs
argument_list|,
name|max_nsegs_1mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_len
operator|&
literal|0xf
condition|)
block|{
name|uint64_t
modifier|*
name|pad
init|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|txwr
operator|+
name|wr_len
operator|)
decl_stmt|;
operator|*
name|pad
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|toep
operator|->
name|tx_credits
operator|>=
name|credits
argument_list|,
operator|(
literal|"%s: not enough credits"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tx_credits
operator|-=
name|credits
expr_stmt|;
name|toep
operator|->
name|tx_nocompl
operator|+=
name|credits
expr_stmt|;
name|toep
operator|->
name|plen_nocompl
operator|+=
name|plen
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tx_credits
operator|<=
name|toep
operator|->
name|tx_total
operator|*
literal|3
operator|/
literal|8
operator|&&
name|toep
operator|->
name|tx_nocompl
operator|>=
name|toep
operator|->
name|tx_total
operator|/
literal|4
condition|)
name|compl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compl
operator|||
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_RDMA
condition|)
block|{
name|txwr
operator|->
name|op_to_immdlen
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_COMPL
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tx_nocompl
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|plen_nocompl
operator|=
literal|0
expr_stmt|;
block|}
name|tp
operator|->
name|snd_nxt
operator|+=
name|plen
expr_stmt|;
name|tp
operator|->
name|snd_max
operator|+=
name|plen
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb_sndptr
argument_list|,
operator|(
literal|"%s: sb_sndptr is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_sndptr
operator|=
name|sb_sndptr
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_DATA_SENT
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tx_credits
operator|<
name|MIN_OFLD_TX_CREDITS
condition|)
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|txsd_avail
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: no txsd"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|plen
operator|=
name|plen
expr_stmt|;
name|txsd
operator|->
name|tx_credits
operator|=
name|credits
expr_stmt|;
name|txsd
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|toep
operator|->
name|txsd_pidx
operator|==
name|toep
operator|->
name|txsd_total
argument_list|)
condition|)
block|{
name|toep
operator|->
name|txsd_pidx
operator|=
literal|0
expr_stmt|;
name|txsd
operator|=
operator|&
name|toep
operator|->
name|txsd
index|[
literal|0
index|]
expr_stmt|;
block|}
name|toep
operator|->
name|txsd_avail
operator|--
expr_stmt|;
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
comment|/* Send a FIN if requested, but only if there's no more data to send */
if|if
condition|(
name|m
operator|==
name|NULL
operator|&&
name|toep
operator|->
name|flags
operator|&
name|TPF_SEND_FIN
condition|)
name|close_conn
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rqdrop_locked
parameter_list|(
name|struct
name|mbufq
modifier|*
name|q
parameter_list|,
name|int
name|plen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
while|while
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|mbufq_dequeue
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* Too many credits. */
name|MPASS
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Partial credits. */
name|MPASS
argument_list|(
name|plen
operator|>=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|plen
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_push_pdus
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|drop
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|sndptr
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|fw_ofld_tx_data_wr
modifier|*
name|txwr
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|u_int
name|plen
decl_stmt|,
name|nsegs
decl_stmt|,
name|credits
decl_stmt|,
name|max_imm
decl_stmt|,
name|max_nsegs
decl_stmt|,
name|max_nsegs_1mbuf
decl_stmt|;
name|u_int
name|adjusted_plen
decl_stmt|,
name|ulp_submode
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|int
name|tx_credits
decl_stmt|,
name|shove
decl_stmt|;
name|struct
name|ofld_tx_sdesc
modifier|*
name|txsd
init|=
operator|&
name|toep
operator|->
name|txsd
index|[
name|toep
operator|->
name|txsd_pidx
index|]
decl_stmt|;
name|struct
name|mbufq
modifier|*
name|pduq
init|=
operator|&
name|toep
operator|->
name|ulp_pduq
decl_stmt|;
specifier|static
specifier|const
name|u_int
name|ulp_extra_len
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FLOWC_WR_SENT
argument_list|,
operator|(
literal|"%s: flowc_wr not sent for tid %u."
operator|,
name|__func__
operator|,
name|toep
operator|->
name|tid
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_ISCSI
argument_list|,
operator|(
literal|"%s: ulp_mode %u for toep %p"
operator|,
name|__func__
operator|,
name|toep
operator|->
name|ulp_mode
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|)
condition|)
return|return;
comment|/* 	 * This function doesn't resume by itself.  Someone else must clear the 	 * flag and call this function. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_TX_SUSPENDED
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|drop
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: drop (%d) != 0 but tx is suspended"
operator|,
name|__func__
operator|,
name|drop
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|drop
condition|)
name|rqdrop_locked
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pdu_reclaimq
argument_list|,
name|drop
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sndptr
operator|=
name|mbufq_first
argument_list|(
name|pduq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|sndptr
argument_list|)
expr_stmt|;
name|tx_credits
operator|=
name|min
argument_list|(
name|toep
operator|->
name|tx_credits
argument_list|,
name|MAX_OFLD_TX_CREDITS
argument_list|)
expr_stmt|;
name|max_imm
operator|=
name|max_imm_payload
argument_list|(
name|tx_credits
argument_list|)
expr_stmt|;
name|max_nsegs
operator|=
name|max_dsgl_nsegs
argument_list|(
name|tx_credits
argument_list|)
expr_stmt|;
name|plen
operator|=
literal|0
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
name|max_nsegs_1mbuf
operator|=
literal|0
expr_stmt|;
comment|/* max # of SGL segments in any one mbuf */
for|for
control|(
name|m
operator|=
name|sndptr
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|int
name|n
init|=
name|sglist_count
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
decl_stmt|;
name|nsegs
operator|+=
name|n
expr_stmt|;
name|plen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* 			 * This mbuf would send us _over_ the nsegs limit. 			 * Suspend tx because the PDU can't be sent out. 			 */
if|if
condition|(
name|plen
operator|>
name|max_imm
operator|&&
name|nsegs
operator|>
name|max_nsegs
condition|)
block|{
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|max_nsegs_1mbuf
operator|<
name|n
condition|)
name|max_nsegs_1mbuf
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FIN_SENT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: excess tx."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * We have a PDU to send.  All of it goes out in one WR so 'm' 		 * is NULL.  A PDU's length is always a multiple of 4. 		 */
name|MPASS
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|plen
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sndptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
name|plen
argument_list|)
expr_stmt|;
name|shove
operator|=
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_MORETOCOME
operator|)
expr_stmt|;
name|ulp_submode
operator|=
name|mbuf_ulp_submode
argument_list|(
name|sndptr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ulp_submode
operator|<
name|nitems
argument_list|(
name|ulp_extra_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * plen doesn't include header and data digests, which are 		 * generated and inserted in the right places by the TOE, but 		 * they do occupy TCP sequence space and need to be accounted 		 * for. 		 */
name|adjusted_plen
operator|=
name|plen
operator|+
name|ulp_extra_len
index|[
name|ulp_submode
index|]
expr_stmt|;
if|if
condition|(
name|plen
operator|<=
name|max_imm
condition|)
block|{
comment|/* Immediate data tx */
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|txwr
argument_list|)
operator|+
name|plen
argument_list|,
literal|16
argument_list|)
argument_list|,
name|toep
operator|->
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX: how will we recover from this? */
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
return|return;
block|}
name|txwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|credits
operator|=
name|howmany
argument_list|(
name|wr
operator|->
name|wr_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_tx_wr
argument_list|(
name|txwr
argument_list|,
name|toep
argument_list|,
name|plen
argument_list|,
name|adjusted_plen
argument_list|,
name|credits
argument_list|,
name|shove
argument_list|,
name|ulp_submode
argument_list|,
name|sc
operator|->
name|tt
operator|.
name|tx_align
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|sndptr
argument_list|,
literal|0
argument_list|,
name|plen
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|txwr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|wr_len
decl_stmt|;
comment|/* DSGL tx */
name|wr_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|txwr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_sgl
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|*
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|/
literal|2
operator|+
operator|(
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
operator|)
operator|*
literal|8
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|roundup2
argument_list|(
name|wr_len
argument_list|,
literal|16
argument_list|)
argument_list|,
name|toep
operator|->
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX: how will we recover from this? */
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
return|return;
block|}
name|txwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|credits
operator|=
name|howmany
argument_list|(
name|wr_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_tx_wr
argument_list|(
name|txwr
argument_list|,
name|toep
argument_list|,
literal|0
argument_list|,
name|adjusted_plen
argument_list|,
name|credits
argument_list|,
name|shove
argument_list|,
name|ulp_submode
argument_list|,
name|sc
operator|->
name|tt
operator|.
name|tx_align
argument_list|)
expr_stmt|;
name|write_tx_sgl
argument_list|(
name|txwr
operator|+
literal|1
argument_list|,
name|sndptr
argument_list|,
name|m
argument_list|,
name|nsegs
argument_list|,
name|max_nsegs_1mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_len
operator|&
literal|0xf
condition|)
block|{
name|uint64_t
modifier|*
name|pad
init|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|txwr
operator|+
name|wr_len
operator|)
decl_stmt|;
operator|*
name|pad
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|toep
operator|->
name|tx_credits
operator|>=
name|credits
argument_list|,
operator|(
literal|"%s: not enough credits"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|mbufq_dequeue
argument_list|(
name|pduq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|m
operator|==
name|sndptr
argument_list|)
expr_stmt|;
name|mbufq_enqueue
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pdu_reclaimq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tx_credits
operator|-=
name|credits
expr_stmt|;
name|toep
operator|->
name|tx_nocompl
operator|+=
name|credits
expr_stmt|;
name|toep
operator|->
name|plen_nocompl
operator|+=
name|plen
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tx_credits
operator|<=
name|toep
operator|->
name|tx_total
operator|*
literal|3
operator|/
literal|8
operator|&&
name|toep
operator|->
name|tx_nocompl
operator|>=
name|toep
operator|->
name|tx_total
operator|/
literal|4
condition|)
block|{
name|txwr
operator|->
name|op_to_immdlen
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_COMPL
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tx_nocompl
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|plen_nocompl
operator|=
literal|0
expr_stmt|;
block|}
name|tp
operator|->
name|snd_nxt
operator|+=
name|adjusted_plen
expr_stmt|;
name|tp
operator|->
name|snd_max
operator|+=
name|adjusted_plen
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_DATA_SENT
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tx_credits
operator|<
name|MIN_OFLD_TX_CREDITS
condition|)
name|toep
operator|->
name|flags
operator||=
name|TPF_TX_SUSPENDED
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|txsd_avail
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: no txsd"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|plen
operator|=
name|plen
expr_stmt|;
name|txsd
operator|->
name|tx_credits
operator|=
name|credits
expr_stmt|;
name|txsd
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|toep
operator|->
name|txsd_pidx
operator|==
name|toep
operator|->
name|txsd_total
argument_list|)
condition|)
block|{
name|toep
operator|->
name|txsd_pidx
operator|=
literal|0
expr_stmt|;
name|txsd
operator|=
operator|&
name|toep
operator|->
name|txsd
index|[
literal|0
index|]
expr_stmt|;
block|}
name|toep
operator|->
name|txsd_avail
operator|--
expr_stmt|;
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
block|}
comment|/* Send a FIN if requested, but only if there are no more PDUs to send */
if|if
condition|(
name|mbufq_first
argument_list|(
name|pduq
argument_list|)
operator|==
name|NULL
operator|&&
name|toep
operator|->
name|flags
operator|&
name|TPF_SEND_FIN
condition|)
name|close_conn
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t4_tod_output
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
endif|#
directive|endif
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: inp %p dropped."
operator|,
name|__func__
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: toep is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_ISCSI
condition|)
name|t4_push_pdus
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t4_push_frames
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_send_fin
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
endif|#
directive|endif
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: inp %p dropped."
operator|,
name|__func__
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: toep is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_SEND_FIN
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|>=
name|TCPS_ESTABLISHED
condition|)
block|{
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_ISCSI
condition|)
name|t4_push_pdus
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t4_push_frames
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_send_rst
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
endif|#
directive|endif
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: inp %p dropped."
operator|,
name|__func__
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: toep is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* hmmmm */
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_FLOWC_WR_SENT
argument_list|,
operator|(
literal|"%s: flowc for tid %u [%s] not sent already"
operator|,
name|__func__
operator|,
name|toep
operator|->
name|tid
operator|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
operator|)
argument_list|)
expr_stmt|;
name|send_reset
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Peer has sent us a FIN.  */
end_comment

begin_function
specifier|static
name|int
name|do_peer_close
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_peer_close
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_PEER_CLOSE
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
operator|(
name|void
operator|*
operator|)
name|toep
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|synqe
operator|->
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_HAS_L2TE
condition|)
block|{
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: listen socket closed but tid %u not aborted."
operator|,
name|__func__
operator|,
name|tid
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * do_pass_accept_req is still running and will 			 * eventually take care of this tid. 			 */
block|}
name|INP_WUNLOCK
argument_list|(
name|synqe
operator|->
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, synqe %p (0x%x)"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u (%s), toep_flags 0x%x, inp %p"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tp
condition|?
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
else|:
literal|"no tp"
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|)
goto|goto
name|done
goto|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
comment|/* FIN */
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
block|{
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|ddp_flags
operator|&
operator|(
name|DDP_BUF0_ACTIVE
operator||
name|DDP_BUF1_ACTIVE
operator|)
argument_list|)
condition|)
name|handle_ddp_close
argument_list|(
name|toep
argument_list|,
name|tp
argument_list|,
name|cpl
operator|->
name|rcv_nxt
argument_list|)
expr_stmt|;
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|!=
name|ULP_MODE_RDMA
condition|)
block|{
name|KASSERT
argument_list|(
name|tp
operator|->
name|rcv_nxt
operator|==
name|be32toh
argument_list|(
name|cpl
operator|->
name|rcv_nxt
argument_list|)
argument_list|,
operator|(
literal|"%s: rcv_nxt mismatch: %u %u"
operator|,
name|__func__
operator|,
name|tp
operator|->
name|rcv_nxt
operator|,
name|be32toh
argument_list|(
name|cpl
operator|->
name|rcv_nxt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_SYN_RECEIVED
case|:
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|TCPS_ESTABLISHED
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSE_WAIT
expr_stmt|;
break|break;
case|case
name|TCPS_FIN_WAIT_1
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSING
expr_stmt|;
break|break;
case|case
name|TCPS_FIN_WAIT_2
case|:
name|tcp_twstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* safe, we have a ref on the inp */
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|final_cpl_received
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: TID %u received CPL_PEER_CLOSE in state %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Peer has ACK'd our FIN.  */
end_comment

begin_function
specifier|static
name|int
name|do_close_con_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_close_con_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_CLOSE_CON_RPL
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u (%s), toep_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tp
condition|?
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
else|:
literal|"no tp"
argument_list|,
name|toep
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|)
goto|goto
name|done
goto|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|snd_nxt
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* exclude FIN */
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_CLOSING
case|:
comment|/* see TCPS_FIN_WAIT_2 in do_peer_close too */
name|tcp_twstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|release
label|:
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* safe, we have a ref on the  inp */
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|final_cpl_received
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* no more CPLs expected */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TCPS_LAST_ACK
case|:
if|if
condition|(
name|tcp_close
argument_list|(
name|tp
argument_list|)
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
case|case
name|TCPS_FIN_WAIT_1
case|:
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_2
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: TID %u received CPL_CLOSE_CON_RPL in state %s\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|send_abort_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
parameter_list|,
name|int
name|tid
parameter_list|,
name|int
name|rst_status
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_abort_rpl
modifier|*
name|cpl
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
argument_list|,
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|cpl
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|cpl
argument_list|,
name|CPL_ABORT_RPL
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|cmd
operator|=
name|rst_status
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|abort_status_to_errno
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|unsigned
name|int
name|abort_reason
parameter_list|)
block|{
switch|switch
condition|(
name|abort_reason
condition|)
block|{
case|case
name|CPL_ERR_BAD_SYN
case|:
case|case
name|CPL_ERR_CONN_RESET
case|:
return|return
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSE_WAIT
condition|?
name|EPIPE
else|:
name|ECONNRESET
operator|)
return|;
case|case
name|CPL_ERR_XMIT_TIMEDOUT
case|:
case|case
name|CPL_ERR_PERSIST_TIMEDOUT
case|:
case|case
name|CPL_ERR_FINWAIT2_TIMEDOUT
case|:
case|case
name|CPL_ERR_KEEPALIVE_TIMEDOUT
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * TCP RST from the peer, timeout, or some other such critical error.  */
end_comment

begin_function
specifier|static
name|int
name|do_abort_req
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_req_rss
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
init|=
name|toep
operator|->
name|ofld_txq
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_ABORT_REQ_RSS
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
condition|)
return|return
operator|(
name|do_abort_req_synqe
argument_list|(
name|iq
argument_list|,
name|rss
argument_list|,
name|m
argument_list|)
operator|)
return|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative_advice
argument_list|(
name|cpl
operator|->
name|status
argument_list|)
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: negative advice %d for tid %d (0x%x)"
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|status
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore negative advice */
block|}
name|inp
operator|=
name|toep
operator|->
name|inp
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* for tcp_close */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d (%s), toep_flags 0x%x, inp_flags 0x%x, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tp
condition|?
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
else|:
literal|"no tp"
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * If we'd initiated an abort earlier the reply to it is responsible for 	 * cleaning up resources.  Otherwise we tear everything down right here 	 * right now.  We owe the T4 a CPL_ABORT_RPL no matter what. 	 */
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|toep
operator|->
name|flags
operator||=
name|TPF_ABORT_SHUTDOWN
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_DROPPED
operator||
name|INP_TIMEWAIT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
name|so_error_set
argument_list|(
name|so
argument_list|,
name|abort_status_to_errno
argument_list|(
name|tp
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* re-acquire */
block|}
name|final_cpl_received
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|done
label|:
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|send_abort_rpl
argument_list|(
name|sc
argument_list|,
name|ofld_txq
argument_list|,
name|tid
argument_list|,
name|CPL_ABORT_NO_RST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reply to the CPL_ABORT_REQ (send_reset)  */
end_comment

begin_function
specifier|static
name|int
name|do_abort_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_rpl_rss
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_ABORT_RPL_RSS
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
condition|)
return|return
operator|(
name|do_abort_rpl_synqe
argument_list|(
name|iq
argument_list|,
name|rss
argument_list|,
name|m
argument_list|)
operator|)
return|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, toep %p, inp %p, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|,
name|inp
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: wasn't expecting abort reply"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|final_cpl_received
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_rx_data
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_data
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint32_t
name|ddp_placed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
operator|(
name|void
operator|*
operator|)
name|toep
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|synqe
operator|->
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_HAS_L2TE
condition|)
block|{
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: listen socket closed but tid %u not aborted."
operator|,
name|__func__
operator|,
name|tid
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * do_pass_accept_req is still running and will 			 * eventually take care of this tid. 			 */
block|}
name|INP_WUNLOCK
argument_list|(
name|synqe
operator|->
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, synqe %p (0x%x)"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* strip off CPL header */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_DROPPED
operator||
name|INP_TIMEWAIT
operator|)
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, rx (%d bytes), inp_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|len
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tp
operator|->
name|rcv_nxt
operator|!=
name|be32toh
argument_list|(
name|cpl
operator|->
name|seq
argument_list|)
argument_list|)
condition|)
name|ddp_placed
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|seq
argument_list|)
operator|-
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|rcv_wnd
operator|<
name|len
condition|)
block|{
name|KASSERT
argument_list|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_RDMA
argument_list|,
operator|(
literal|"%s: negative window size"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|rcv_wnd
operator|-=
name|len
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|DDP_LOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, excess rx (%d bytes)"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* receive buffer autosize */
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|&&
name|V_tcp_do_autorcvbuf
operator|&&
name|sb
operator|->
name|sb_hiwat
operator|<
name|V_tcp_autorcvbuf_max
operator|&&
name|len
operator|>
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|/
literal|8
operator|*
literal|7
operator|)
condition|)
block|{
name|unsigned
name|int
name|hiwat
init|=
name|sb
operator|->
name|sb_hiwat
decl_stmt|;
name|unsigned
name|int
name|newsize
init|=
name|min
argument_list|(
name|hiwat
operator|+
name|V_tcp_autorcvbuf_inc
argument_list|,
name|V_tcp_autorcvbuf_max
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sbreserve_locked
argument_list|(
name|sb
argument_list|,
name|newsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
condition|)
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
else|else
name|toep
operator|->
name|rx_credits
operator|+=
name|newsize
operator|-
name|hiwat
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|ddp_waiting_count
operator|!=
literal|0
operator|||
name|toep
operator|->
name|ddp_active_count
operator|!=
literal|0
condition|)
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, non-ddp rx (%d bytes)"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
block|{
name|int
name|changed
init|=
operator|!
operator|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_ON
operator|)
operator|^
name|cpl
operator|->
name|ddp_off
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_SC_REQ
condition|)
name|toep
operator|->
name|ddp_flags
operator|^=
name|DDP_ON
operator||
name|DDP_SC_REQ
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
name|cpl
operator|->
name|ddp_off
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: DDP switched on by itself."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Fell out of DDP mode */
name|toep
operator|->
name|ddp_flags
operator|&=
operator|~
name|DDP_ON
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: fell out of DDP mode"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|insert_ddp_data
argument_list|(
name|toep
argument_list|,
name|ddp_placed
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toep
operator|->
name|ddp_flags
operator|&
name|DDP_ON
condition|)
block|{
comment|/* 			 * CPL_RX_DATA with DDP on can only be an indicate. 			 * Start posting queued AIO requests via DDP.  The 			 * payload that arrived in this indicate is appended 			 * to the socket buffer as usual. 			 */
name|handle_ddp_indicate
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|toep
operator|->
name|sb_cc
operator|>=
name|sbused
argument_list|(
name|sb
argument_list|)
argument_list|,
operator|(
literal|"%s: sb %p has more data (%d) than last time (%d)."
operator|,
name|__func__
operator|,
name|sb
operator|,
name|sbused
argument_list|(
name|sb
argument_list|)
operator|,
name|toep
operator|->
name|sb_cc
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|+=
name|toep
operator|->
name|sb_cc
operator|-
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbappendstream_locked
argument_list|(
name|sb
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|sb_cc
operator|=
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|rx_credits
operator|>
literal|0
operator|&&
name|toep
operator|->
name|sb_cc
operator|+
name|tp
operator|->
name|rcv_wnd
operator|<
name|sb
operator|->
name|sb_lowat
condition|)
block|{
name|int
name|credits
decl_stmt|;
name|credits
operator|=
name|send_rx_credits
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|rx_credits
argument_list|)
expr_stmt|;
name|toep
operator|->
name|rx_credits
operator|-=
name|credits
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|+=
name|credits
expr_stmt|;
name|tp
operator|->
name|rcv_adv
operator|+=
name|credits
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|ddp_waiting_count
operator|>
literal|0
operator|&&
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u queueing AIO task"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ddp_queue_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|DDP_UNLOCK
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|S_CPL_FW4_ACK_OPCODE
value|24
end_define

begin_define
define|#
directive|define
name|M_CPL_FW4_ACK_OPCODE
value|0xff
end_define

begin_define
define|#
directive|define
name|V_CPL_FW4_ACK_OPCODE
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_CPL_FW4_ACK_OPCODE)
end_define

begin_define
define|#
directive|define
name|G_CPL_FW4_ACK_OPCODE
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)>> S_CPL_FW4_ACK_OPCODE)& M_CPL_FW4_ACK_OPCODE)
end_define

begin_define
define|#
directive|define
name|S_CPL_FW4_ACK_FLOWID
value|0
end_define

begin_define
define|#
directive|define
name|M_CPL_FW4_ACK_FLOWID
value|0xffffff
end_define

begin_define
define|#
directive|define
name|V_CPL_FW4_ACK_FLOWID
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_CPL_FW4_ACK_FLOWID)
end_define

begin_define
define|#
directive|define
name|G_CPL_FW4_ACK_FLOWID
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)>> S_CPL_FW4_ACK_FLOWID)& M_CPL_FW4_ACK_FLOWID)
end_define

begin_define
define|#
directive|define
name|S_CPL_FW4_ACK_CR
value|24
end_define

begin_define
define|#
directive|define
name|M_CPL_FW4_ACK_CR
value|0xff
end_define

begin_define
define|#
directive|define
name|V_CPL_FW4_ACK_CR
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_CPL_FW4_ACK_CR)
end_define

begin_define
define|#
directive|define
name|G_CPL_FW4_ACK_CR
parameter_list|(
name|x
parameter_list|)
value|(((x)>> S_CPL_FW4_ACK_CR)& M_CPL_FW4_ACK_CR)
end_define

begin_define
define|#
directive|define
name|S_CPL_FW4_ACK_SEQVAL
value|0
end_define

begin_define
define|#
directive|define
name|M_CPL_FW4_ACK_SEQVAL
value|0x1
end_define

begin_define
define|#
directive|define
name|V_CPL_FW4_ACK_SEQVAL
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_CPL_FW4_ACK_SEQVAL)
end_define

begin_define
define|#
directive|define
name|G_CPL_FW4_ACK_SEQVAL
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)>> S_CPL_FW4_ACK_SEQVAL)& M_CPL_FW4_ACK_SEQVAL)
end_define

begin_define
define|#
directive|define
name|F_CPL_FW4_ACK_SEQVAL
value|V_CPL_FW4_ACK_SEQVAL(1U)
end_define

begin_function
specifier|static
name|int
name|do_fw4_ack
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_fw4_ack
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|G_CPL_FW4_ACK_FLOWID
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|uint8_t
name|credits
init|=
name|cpl
operator|->
name|credits
decl_stmt|;
name|struct
name|ofld_tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|int
name|plen
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_FW4_ACK_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Very unusual case: we'd sent a flowc + abort_req for a synq entry and 	 * now this comes back carrying the credits for the flowc. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_SYNQE
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: credits for a synq entry %p"
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|inp
operator|=
name|toep
operator|->
name|inp
expr_stmt|;
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_FW4_ACK
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_TIMEWAIT
operator||
name|INP_DROPPED
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: inp_flags 0x%x"
operator|,
name|__func__
operator|,
name|inp
operator|->
name|inp_flags
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|flags
operator|&
name|CPL_FW4_ACK_FLAGS_SEQVAL
condition|)
block|{
name|tcp_seq
name|snd_una
init|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|snd_una
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|__predict_false
argument_list|(
name|SEQ_LT
argument_list|(
name|snd_una
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: unexpected seq# %x for TID %u, snd_una %x\n"
argument_list|,
name|__func__
argument_list|,
name|snd_una
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|snd_una
operator|!=
name|snd_una
condition|)
block|{
name|tp
operator|->
name|snd_una
operator|=
name|snd_una
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
block|}
block|}
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|txsd
operator|=
operator|&
name|toep
operator|->
name|txsd
index|[
name|toep
operator|->
name|txsd_cidx
index|]
expr_stmt|;
name|plen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|credits
condition|)
block|{
name|KASSERT
argument_list|(
name|credits
operator|>=
name|txsd
operator|->
name|tx_credits
argument_list|,
operator|(
literal|"%s: too many (or partial) credits"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|credits
operator|-=
name|txsd
operator|->
name|tx_credits
expr_stmt|;
name|toep
operator|->
name|tx_credits
operator|+=
name|txsd
operator|->
name|tx_credits
expr_stmt|;
name|plen
operator|+=
name|txsd
operator|->
name|plen
expr_stmt|;
name|txsd
operator|++
expr_stmt|;
name|toep
operator|->
name|txsd_avail
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|txsd_avail
operator|<=
name|toep
operator|->
name|txsd_total
argument_list|,
operator|(
literal|"%s: txsd avail> total"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|toep
operator|->
name|txsd_cidx
operator|==
name|toep
operator|->
name|txsd_total
argument_list|)
condition|)
block|{
name|txsd
operator|=
operator|&
name|toep
operator|->
name|txsd
index|[
literal|0
index|]
expr_stmt|;
name|toep
operator|->
name|txsd_cidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toep
operator|->
name|tx_credits
operator|==
name|toep
operator|->
name|tx_total
condition|)
block|{
name|toep
operator|->
name|tx_nocompl
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|plen_nocompl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|flags
operator|&
name|TPF_TX_SUSPENDED
operator|&&
name|toep
operator|->
name|tx_credits
operator|>=
name|toep
operator|->
name|tx_total
operator|/
literal|4
condition|)
block|{
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_TX_SUSPENDED
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_ISCSI
condition|)
name|t4_push_pdus
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|plen
argument_list|)
expr_stmt|;
else|else
name|t4_push_frames
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_snd
decl_stmt|;
name|int
name|sbu
decl_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbu
operator|=
name|sbused
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_ISCSI
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|sbu
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* 				 * The data trasmitted before the tid's ULP mode 				 * changed to ISCSI is still in so_snd. 				 * Incoming credits should account for so_snd 				 * first. 				 */
name|sbdrop_locked
argument_list|(
name|sb
argument_list|,
name|min
argument_list|(
name|sbu
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
name|plen
operator|-=
name|min
argument_list|(
name|sbu
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* unlocks so_snd */
name|rqdrop_locked
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pdu_reclaimq
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbdrop_locked
argument_list|(
name|sb
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* unlocks so_snd */
block|}
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|do_set_tcb_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_SET_TCB_RPL
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|iq
operator|!=
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
argument_list|)
expr_stmt|;
name|toep
operator|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
block|{
name|handle_ddp_tcb_rpl
argument_list|(
name|toep
argument_list|,
name|cpl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * TOM and/or other ULPs don't request replies for CPL_SET_TCB or 	 * CPL_SET_TCB_FIELD requests.  This can easily change and when it does 	 * the dispatch code will go here. 	 */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: Unexpected CPL_SET_TCB_RPL for tid %u on iq %p"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|iq
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Unexpected CPL_SET_TCB_RPL for tid %u on iq %p\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|iq
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_set_tcb_field
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|,
name|int
name|tid
parameter_list|,
name|uint16_t
name|word
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|int
name|reply
parameter_list|,
name|int
name|cookie
parameter_list|,
name|int
name|iqid
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
decl_stmt|;
name|MPASS
argument_list|(
operator|(
name|cookie
operator|&
operator|~
name|M_COOKIE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|iqid
operator|&
operator|~
name|M_QUEUENO
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|req
argument_list|,
name|CPL_SET_TCB_FIELD
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply_ctrl
operator|=
name|htobe16
argument_list|(
name|V_QUEUENO
argument_list|(
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|==
literal|0
condition|)
name|req
operator|->
name|reply_ctrl
operator||=
name|htobe16
argument_list|(
name|F_NO_REPLY
argument_list|)
expr_stmt|;
name|req
operator|->
name|word_cookie
operator|=
name|htobe16
argument_list|(
name|V_WORD
argument_list|(
name|word
argument_list|)
operator||
name|V_COOKIE
argument_list|(
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_init_cpl_io_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_PEER_CLOSE
argument_list|,
name|do_peer_close
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_CLOSE_CON_RPL
argument_list|,
name|do_close_con_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_ABORT_REQ_RSS
argument_list|,
name|do_abort_req
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_ABORT_RPL_RSS
argument_list|,
name|do_abort_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_RX_DATA
argument_list|,
name|do_rx_data
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_FW4_ACK
argument_list|,
name|do_fw4_ack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_uninit_cpl_io_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_PEER_CLOSE
argument_list|,
name|do_peer_close
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_CLOSE_CON_RPL
argument_list|,
name|do_close_con_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_ABORT_REQ_RSS
argument_list|,
name|do_abort_req
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_ABORT_RPL_RSS
argument_list|,
name|do_abort_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_RX_DATA
argument_list|,
name|do_rx_data
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_FW4_ACK
argument_list|,
name|do_fw4_ack
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

