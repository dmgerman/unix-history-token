begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom_l2t.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_comment
comment|/* atid services */
end_comment

begin_function_decl
specifier|static
name|int
name|alloc_atid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|lookup_atid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_atid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|alloc_atid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|int
name|atid
init|=
operator|-
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|afree
condition|)
block|{
name|union
name|aopen_entry
modifier|*
name|p
init|=
name|t
operator|->
name|afree
decl_stmt|;
name|atid
operator|=
name|p
operator|-
name|t
operator|->
name|atid_tab
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|ctx
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|atid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|lookup_atid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|atid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
return|return
operator|(
name|t
operator|->
name|atid_tab
index|[
name|atid
index|]
operator|.
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_atid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|atid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|union
name|aopen_entry
modifier|*
name|p
init|=
operator|&
name|t
operator|->
name|atid_tab
index|[
name|atid
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|afree
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Active open failed.  */
end_comment

begin_function
specifier|static
name|int
name|do_act_establish
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_act_establish
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_TID_TID
argument_list|(
name|ntohl
argument_list|(
name|cpl
operator|->
name|tos_atid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|atid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %u, tid %u"
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|free_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|insert_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
comment|/* socket closed by the kernel before hw told us it connected */
name|send_flowc_wr
argument_list|(
name|toep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_reset
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|be32toh
argument_list|(
name|cpl
operator|->
name|snd_isn
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|make_established
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|snd_isn
argument_list|,
name|cpl
operator|->
name|rcv_isn
argument_list|,
name|cpl
operator|->
name|tcp_opt
argument_list|)
expr_stmt|;
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|act_open_has_tid
parameter_list|(
name|unsigned
name|int
name|status
parameter_list|)
block|{
return|return
operator|(
name|status
operator|!=
name|CPL_ERR_TCAM_FULL
operator|&&
name|status
operator|!=
name|CPL_ERR_TCAM_PARITY
operator|&&
name|status
operator|!=
name|CPL_ERR_CONN_EXIST
operator|&&
name|status
operator|!=
name|CPL_ERR_ARP_MISS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an ACT_OPEN_RPL status to an errno.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|act_open_rpl_status_to_errno
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CPL_ERR_CONN_RESET
case|:
return|return
operator|(
name|ECONNREFUSED
operator|)
return|;
case|case
name|CPL_ERR_ARP_MISS
case|:
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
case|case
name|CPL_ERR_CONN_TIMEDOUT
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
case|case
name|CPL_ERR_TCAM_FULL
case|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|CPL_ERR_CONN_EXIST
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ACTIVE_OPEN_RPL: 4-tuple in use\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_act_open_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_act_open_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_TID_TID
argument_list|(
name|G_AOPEN_ATID
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|atid_status
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|G_AOPEN_STATUS
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|atid_status
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|toep
operator|->
name|td
operator|->
name|tod
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|atid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %u, status %u "
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Ignore negative advice */
if|if
condition|(
name|status
operator|==
name|CPL_ERR_RTX_NEG_ADVICE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|free_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|act_open_has_tid
argument_list|(
name|status
argument_list|)
condition|)
name|release_tid
argument_list|(
name|sc
argument_list|,
name|GET_TID
argument_list|(
name|cpl
argument_list|)
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CPL_ERR_TCAM_FULL
condition|)
block|{
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toe_connect_failed
argument_list|(
name|tod
argument_list|,
name|tp
argument_list|,
name|EAGAIN
argument_list|)
expr_stmt|;
name|final_cpl_received
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* unlocks inp */
block|}
else|else
block|{
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toe_connect_failed
argument_list|(
name|tod
argument_list|,
name|tp
argument_list|,
name|act_open_rpl_status_to_errno
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|final_cpl_received
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* unlocks inp */
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Options2 for active open.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|calc_opt2a
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|toep
operator|->
name|port
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|uint32_t
name|opt2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
condition|)
name|opt2
operator||=
name|F_SACK_EN
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_TSTMP
condition|)
name|opt2
operator||=
name|F_TSTAMPS_EN
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_SCALE
condition|)
name|opt2
operator||=
name|F_WND_SCALE_EN
expr_stmt|;
if|if
condition|(
name|V_tcp_do_ecn
condition|)
name|opt2
operator||=
name|F_CCTRL_ECN
expr_stmt|;
name|opt2
operator||=
name|V_TX_QUEUE
argument_list|(
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_modq
index|[
name|pi
operator|->
name|tx_chan
index|]
argument_list|)
expr_stmt|;
name|opt2
operator||=
name|F_RX_COALESCE_VALID
operator||
name|V_RX_COALESCE
argument_list|(
name|M_RX_COALESCE
argument_list|)
expr_stmt|;
name|opt2
operator||=
name|F_RSS_QUEUE_VALID
operator||
name|V_RSS_QUEUE
argument_list|(
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DDP_RX_FLOW_CONTROL
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|opt2
operator||=
name|F_RX_FC_VALID
operator||
name|F_RX_FC_DDP
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|htobe32
argument_list|(
name|opt2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_init_connect_cpl_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_ACT_ESTABLISH
argument_list|,
name|do_act_establish
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_ACT_OPEN_RPL
argument_list|,
name|do_act_open_rpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * active open (soconnect).  *  * State of affairs on entry:  * soisconnecting (so_state |= SS_ISCONNECTING)  * tcbinfo not locked (This has changed - used to be WLOCKed)  * inp WLOCKed  * tp->t_state = TCPS_SYN_SENT  * rtalloc1, RT_UNLOCK on rt.  */
end_comment

begin_function
name|int
name|t4_connect
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|NULL
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
init|=
name|NULL
decl_stmt|;
name|struct
name|cpl_act_open_req
modifier|*
name|cpl
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|rt_ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|int
name|atid
init|=
operator|-
literal|1
decl_stmt|,
name|mtu_idx
decl_stmt|,
name|rscale
decl_stmt|,
name|qid_atid
decl_stmt|,
name|rc
init|=
name|ENOMEM
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|CXGBE_UNIMPLEMENTED
argument_list|(
literal|"IPv6 connect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_ETHER
condition|)
name|pi
operator|=
name|rt_ifp
operator|->
name|if_softc
expr_stmt|;
elseif|else
if|if
condition|(
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_L2VLAN
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|VLAN_COOKIE
argument_list|(
name|rt_ifp
argument_list|)
decl_stmt|;
name|pi
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_IEEE8023ADLAG
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
comment|/* XXX: implement lagg support */
else|else
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|toep
operator|=
name|alloc_toepcb
argument_list|(
name|pi
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|atid
operator|=
name|alloc_atid
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
name|e
operator|=
name|t4_l2t_get
argument_list|(
name|pi
argument_list|,
name|rt_ifp
argument_list|,
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|?
name|rt
operator|->
name|rt_gateway
else|:
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|cpl
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tid
operator|=
name|atid
expr_stmt|;
name|toep
operator|->
name|l2te
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tt
operator|.
name|ddp
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_NO_DDP
operator|)
operator|==
literal|0
condition|)
name|set_tcpddp_ulp_mode
argument_list|(
name|toep
argument_list|)
expr_stmt|;
else|else
name|toep
operator|->
name|ulp_mode
operator|=
name|ULP_MODE_NONE
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* opt0 rcv_bufsiz initially, assumes its normal meaning later */
name|toep
operator|->
name|rx_credits
operator|=
name|min
argument_list|(
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
operator|>>
literal|10
argument_list|,
name|M_RCV_BUFSIZ
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|offload_socket
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
comment|/* 	 * The kernel sets request_r_scale based on sb_max whereas we need to 	 * take hardware's MAX_RCV_WND into account too.  This is normally a 	 * no-op as MAX_RCV_WND is much larger than the default sb_max. 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_SCALE
condition|)
name|rscale
operator|=
name|tp
operator|->
name|request_r_scale
operator|=
name|select_rcv_wscale
argument_list|()
expr_stmt|;
else|else
name|rscale
operator|=
literal|0
expr_stmt|;
name|mtu_idx
operator|=
name|find_best_mtu_idx
argument_list|(
name|sc
argument_list|,
operator|&
name|inp
operator|->
name|inp_inc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qid_atid
operator|=
operator|(
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
operator|<<
literal|14
operator|)
operator||
name|atid
expr_stmt|;
name|INIT_TP_WR
argument_list|(
name|cpl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ACT_OPEN_REQ
argument_list|,
name|qid_atid
argument_list|)
argument_list|)
expr_stmt|;
name|inp_4tuple_get
argument_list|(
name|inp
argument_list|,
operator|&
name|cpl
operator|->
name|local_ip
argument_list|,
operator|&
name|cpl
operator|->
name|local_port
argument_list|,
operator|&
name|cpl
operator|->
name|peer_ip
argument_list|,
operator|&
name|cpl
operator|->
name|peer_port
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|opt0
operator|=
name|calc_opt0
argument_list|(
name|so
argument_list|,
name|pi
argument_list|,
name|e
argument_list|,
name|mtu_idx
argument_list|,
name|rscale
argument_list|,
name|toep
operator|->
name|rx_credits
argument_list|,
name|toep
operator|->
name|ulp_mode
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|params
operator|=
name|select_ntuple
argument_list|(
name|pi
argument_list|,
name|e
argument_list|,
name|sc
operator|->
name|filter_mode
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|opt2
operator|=
name|calc_opt2a
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %u (%s), toep %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|toepcb_set_flag
argument_list|(
name|toep
argument_list|,
name|TPF_CPL_PENDING
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|undo_offload_socket
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|failed
label|:
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: FAILED, atid %d, toep %p, l2te %p, wr %p"
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|toep
argument_list|,
name|e
argument_list|,
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|t4_l2t_release
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
condition|)
name|free_wrqe
argument_list|(
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|>=
literal|0
condition|)
name|free_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
condition|)
name|free_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

