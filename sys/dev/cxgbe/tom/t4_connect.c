begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom_l2t.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_comment
comment|/* atid services */
end_comment

begin_function_decl
specifier|static
name|int
name|alloc_atid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|lookup_atid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_atid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|alloc_atid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|int
name|atid
init|=
operator|-
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|afree
condition|)
block|{
name|union
name|aopen_entry
modifier|*
name|p
init|=
name|t
operator|->
name|afree
decl_stmt|;
name|atid
operator|=
name|p
operator|-
name|t
operator|->
name|atid_tab
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|ctx
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|atid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|lookup_atid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|atid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
return|return
operator|(
name|t
operator|->
name|atid_tab
index|[
name|atid
index|]
operator|.
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_atid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|atid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|union
name|aopen_entry
modifier|*
name|p
init|=
operator|&
name|t
operator|->
name|atid_tab
index|[
name|atid
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|afree
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Active open succeeded.  */
end_comment

begin_function
specifier|static
name|int
name|do_act_establish
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_act_establish
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|u_int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|u_int
name|atid
init|=
name|G_TID_TID
argument_list|(
name|ntohl
argument_list|(
name|cpl
operator|->
name|tos_atid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|atid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %u, tid %u"
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|free_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|toep
operator|->
name|vnet
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|insert_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|,
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
comment|/* socket closed by the kernel before hw told us it connected */
name|send_flowc_wr
argument_list|(
name|toep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_reset
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|be32toh
argument_list|(
name|cpl
operator|->
name|snd_isn
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|make_established
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|snd_isn
argument_list|,
name|cpl
operator|->
name|rcv_isn
argument_list|,
name|cpl
operator|->
name|tcp_opt
argument_list|)
expr_stmt|;
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an ACT_OPEN_RPL status to an errno.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|act_open_rpl_status_to_errno
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CPL_ERR_CONN_RESET
case|:
return|return
operator|(
name|ECONNREFUSED
operator|)
return|;
case|case
name|CPL_ERR_ARP_MISS
case|:
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
case|case
name|CPL_ERR_CONN_TIMEDOUT
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
case|case
name|CPL_ERR_TCAM_FULL
case|:
return|return
operator|(
name|EAGAIN
operator|)
return|;
case|case
name|CPL_ERR_CONN_EXIST
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ACTIVE_OPEN_RPL: 4-tuple in use\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|act_open_failure_cleanup
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|u_int
name|atid
parameter_list|,
name|u_int
name|status
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|toep
operator|->
name|td
operator|->
name|tod
decl_stmt|;
name|free_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tid
operator|=
operator|-
literal|1
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|toep
operator|->
name|vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EAGAIN
condition|)
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toe_connect_failed
argument_list|(
name|tod
argument_list|,
name|inp
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|final_cpl_received
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* unlocks inp */
if|if
condition|(
name|status
operator|!=
name|EAGAIN
condition|)
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Active open failed.  */
end_comment

begin_function
specifier|static
name|int
name|do_act_open_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_act_open_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|u_int
name|atid
init|=
name|G_TID_TID
argument_list|(
name|G_AOPEN_ATID
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|atid_status
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|u_int
name|status
init|=
name|G_AOPEN_STATUS
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|atid_status
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_atid
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tid
operator|==
name|atid
argument_list|,
operator|(
literal|"%s: toep tid/atid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %u, status %u "
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Ignore negative advice */
if|if
condition|(
name|negative_advice
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|status
operator|&&
name|act_open_has_tid
argument_list|(
name|status
argument_list|)
condition|)
name|release_tid
argument_list|(
name|sc
argument_list|,
name|GET_TID
argument_list|(
name|cpl
argument_list|)
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
name|rc
operator|=
name|act_open_rpl_status_to_errno
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|act_open_failure_cleanup
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Options2 for active open.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|calc_opt2a
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|toep
operator|->
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|uint32_t
name|opt2
decl_stmt|;
name|opt2
operator|=
name|V_TX_QUEUE
argument_list|(
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_modq
index|[
name|pi
operator|->
name|tx_chan
index|]
argument_list|)
operator||
name|F_RSS_QUEUE_VALID
operator||
name|V_RSS_QUEUE
argument_list|(
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
condition|)
name|opt2
operator||=
name|F_SACK_EN
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_TSTMP
condition|)
name|opt2
operator||=
name|F_TSTAMPS_EN
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_SCALE
condition|)
name|opt2
operator||=
name|F_WND_SCALE_EN
expr_stmt|;
if|if
condition|(
name|V_tcp_do_ecn
condition|)
name|opt2
operator||=
name|F_CCTRL_ECN
expr_stmt|;
comment|/* RX_COALESCE is always a valid value (M_RX_COALESCE). */
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
name|opt2
operator||=
name|F_RX_COALESCE_VALID
expr_stmt|;
else|else
block|{
name|opt2
operator||=
name|F_T5_OPT_2_VALID
expr_stmt|;
name|opt2
operator||=
name|F_T5_ISS
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tt
operator|.
name|rx_coalesce
condition|)
name|opt2
operator||=
name|V_RX_COALESCE
argument_list|(
name|M_RX_COALESCE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DDP_RX_FLOW_CONTROL
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|opt2
operator||=
name|F_RX_FC_VALID
operator||
name|F_RX_FC_DDP
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|htobe32
argument_list|(
name|opt2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_init_connect_cpl_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_ACT_ESTABLISH
argument_list|,
name|do_act_establish
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_ACT_OPEN_RPL
argument_list|,
name|do_act_open_rpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_uninit_connect_cpl_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_ACT_ESTABLISH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_ACT_OPEN_RPL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DONT_OFFLOAD_ACTIVE_OPEN
parameter_list|(
name|x
parameter_list|)
value|do { \ 	reason = __LINE__; \ 	rc = (x); \ 	goto failed; \ } while (0)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|act_open_cpl_size
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|isipv6
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
specifier|static
specifier|const
name|int
name|sz_table
index|[
literal|3
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_act_open_req
argument_list|)
block|,
expr|sizeof
operator|(
expr|struct
name|cpl_act_open_req6
operator|)
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_t5_act_open_req
argument_list|)
block|,
expr|sizeof
operator|(
expr|struct
name|cpl_t5_act_open_req6
operator|)
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_t6_act_open_req
argument_list|)
block|,
expr|sizeof
operator|(
expr|struct
name|cpl_t6_act_open_req6
operator|)
block|}
block|, 	}
decl_stmt|;
name|MPASS
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>=
name|CHELSIO_T4
argument_list|)
expr_stmt|;
name|idx
operator|=
name|min
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|-
name|CHELSIO_T4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|sz_table
index|[
name|idx
index|]
index|[
operator|!
operator|!
name|isipv6
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * active open (soconnect).  *  * State of affairs on entry:  * soisconnecting (so_state |= SS_ISCONNECTING)  * tcbinfo not locked (This has changed - used to be WLOCKed)  * inp WLOCKed  * tp->t_state = TCPS_SYN_SENT  * rtalloc1, RT_UNLOCK on rt.  */
end_comment

begin_function
name|int
name|t4_connect
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|tod_td
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|NULL
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|rt_ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|int
name|mtu_idx
decl_stmt|,
name|rscale
decl_stmt|,
name|qid_atid
decl_stmt|,
name|rc
decl_stmt|,
name|isipv6
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|int
name|reason
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET
operator|||
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"%s: dest addr %p has family %u"
operator|,
name|__func__
operator|,
name|nam
operator|,
name|nam
operator|->
name|sa_family
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_ETHER
condition|)
name|vi
operator|=
name|rt_ifp
operator|->
name|if_softc
expr_stmt|;
elseif|else
if|if
condition|(
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_L2VLAN
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|VLAN_COOKIE
argument_list|(
name|rt_ifp
argument_list|)
decl_stmt|;
name|vi
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_IEEE8023ADLAG
condition|)
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOSYS
argument_list|)
expr_stmt|;
comment|/* XXX: implement lagg+TOE */
else|else
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
name|toep
operator|=
name|alloc_toepcb
argument_list|(
name|vi
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tid
operator|=
name|alloc_atid
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tid
operator|<
literal|0
condition|)
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|toep
operator|->
name|l2te
operator|=
name|t4_l2t_get
argument_list|(
name|vi
operator|->
name|pi
argument_list|,
name|rt_ifp
argument_list|,
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|?
name|rt
operator|->
name|rt_gateway
else|:
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|l2te
operator|==
name|NULL
condition|)
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|isipv6
operator|=
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|act_open_cpl_size
argument_list|(
name|sc
argument_list|,
name|isipv6
argument_list|)
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|toep
operator|->
name|vnet
operator|=
name|so
operator|->
name|so_vnet
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tt
operator|.
name|ddp
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_NO_DDP
operator|)
operator|==
literal|0
condition|)
name|set_tcpddp_ulp_mode
argument_list|(
name|toep
argument_list|)
expr_stmt|;
else|else
name|toep
operator|->
name|ulp_mode
operator|=
name|ULP_MODE_NONE
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* opt0 rcv_bufsiz initially, assumes its normal meaning later */
name|toep
operator|->
name|rx_credits
operator|=
name|min
argument_list|(
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
operator|>>
literal|10
argument_list|,
name|M_RCV_BUFSIZ
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * The kernel sets request_r_scale based on sb_max whereas we need to 	 * take hardware's MAX_RCV_WND into account too.  This is normally a 	 * no-op as MAX_RCV_WND is much larger than the default sb_max. 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_SCALE
condition|)
name|rscale
operator|=
name|tp
operator|->
name|request_r_scale
operator|=
name|select_rcv_wscale
argument_list|()
expr_stmt|;
else|else
name|rscale
operator|=
literal|0
expr_stmt|;
name|mtu_idx
operator|=
name|find_best_mtu_idx
argument_list|(
name|sc
argument_list|,
operator|&
name|inp
operator|->
name|inp_inc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qid_atid
operator|=
operator|(
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
operator|<<
literal|14
operator|)
operator||
name|toep
operator|->
name|tid
expr_stmt|;
if|if
condition|(
name|isipv6
condition|)
block|{
name|struct
name|cpl_act_open_req6
modifier|*
name|cpl
init|=
name|wrtod
argument_list|(
name|wr
argument_list|)
decl_stmt|;
name|struct
name|cpl_t5_act_open_req6
modifier|*
name|cpl5
init|=
operator|(
name|void
operator|*
operator|)
name|cpl
decl_stmt|;
name|struct
name|cpl_t6_act_open_req6
modifier|*
name|cpl6
init|=
operator|(
name|void
operator|*
operator|)
name|cpl
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|)
operator|==
literal|0
condition|)
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
name|toep
operator|->
name|ce
operator|=
name|hold_lip
argument_list|(
name|td
argument_list|,
operator|&
name|inp
operator|->
name|in6p_laddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ce
operator|==
name|NULL
condition|)
name|DONT_OFFLOAD_ACTIVE_OPEN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|CHELSIO_T4
case|:
name|INIT_TP_WR
argument_list|(
name|cpl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|params
operator|=
name|select_ntuple
argument_list|(
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T5
case|:
name|INIT_TP_WR
argument_list|(
name|cpl5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpl5
operator|->
name|iss
operator|=
name|htobe32
argument_list|(
name|tp
operator|->
name|iss
argument_list|)
expr_stmt|;
name|cpl5
operator|->
name|params
operator|=
name|select_ntuple
argument_list|(
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T6
case|:
default|default:
name|INIT_TP_WR
argument_list|(
name|cpl6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpl6
operator|->
name|iss
operator|=
name|htobe32
argument_list|(
name|tp
operator|->
name|iss
argument_list|)
expr_stmt|;
name|cpl6
operator|->
name|params
operator|=
name|select_ntuple
argument_list|(
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
break|break;
block|}
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ACT_OPEN_REQ6
argument_list|,
name|qid_atid
argument_list|)
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|local_port
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|cpl
operator|->
name|local_ip_hi
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|inp
operator|->
name|in6p_laddr
operator|.
name|s6_addr
index|[
literal|0
index|]
expr_stmt|;
name|cpl
operator|->
name|local_ip_lo
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|inp
operator|->
name|in6p_laddr
operator|.
name|s6_addr
index|[
literal|8
index|]
expr_stmt|;
name|cpl
operator|->
name|peer_port
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
name|cpl
operator|->
name|peer_ip_hi
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|inp
operator|->
name|in6p_faddr
operator|.
name|s6_addr
index|[
literal|0
index|]
expr_stmt|;
name|cpl
operator|->
name|peer_ip_lo
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|inp
operator|->
name|in6p_faddr
operator|.
name|s6_addr
index|[
literal|8
index|]
expr_stmt|;
name|cpl
operator|->
name|opt0
operator|=
name|calc_opt0
argument_list|(
name|so
argument_list|,
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|,
name|mtu_idx
argument_list|,
name|rscale
argument_list|,
name|toep
operator|->
name|rx_credits
argument_list|,
name|toep
operator|->
name|ulp_mode
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|opt2
operator|=
name|calc_opt2a
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|cpl_act_open_req
modifier|*
name|cpl
init|=
name|wrtod
argument_list|(
name|wr
argument_list|)
decl_stmt|;
name|struct
name|cpl_t5_act_open_req
modifier|*
name|cpl5
init|=
operator|(
name|void
operator|*
operator|)
name|cpl
decl_stmt|;
name|struct
name|cpl_t6_act_open_req
modifier|*
name|cpl6
init|=
operator|(
name|void
operator|*
operator|)
name|cpl
decl_stmt|;
switch|switch
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|CHELSIO_T4
case|:
name|INIT_TP_WR
argument_list|(
name|cpl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|params
operator|=
name|select_ntuple
argument_list|(
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T5
case|:
name|INIT_TP_WR
argument_list|(
name|cpl5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpl5
operator|->
name|iss
operator|=
name|htobe32
argument_list|(
name|tp
operator|->
name|iss
argument_list|)
expr_stmt|;
name|cpl5
operator|->
name|params
operator|=
name|select_ntuple
argument_list|(
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T6
case|:
default|default:
name|INIT_TP_WR
argument_list|(
name|cpl6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpl6
operator|->
name|iss
operator|=
name|htobe32
argument_list|(
name|tp
operator|->
name|iss
argument_list|)
expr_stmt|;
name|cpl6
operator|->
name|params
operator|=
name|select_ntuple
argument_list|(
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
break|break;
block|}
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ACT_OPEN_REQ
argument_list|,
name|qid_atid
argument_list|)
argument_list|)
expr_stmt|;
name|inp_4tuple_get
argument_list|(
name|inp
argument_list|,
operator|&
name|cpl
operator|->
name|local_ip
argument_list|,
operator|&
name|cpl
operator|->
name|local_port
argument_list|,
operator|&
name|cpl
operator|->
name|peer_ip
argument_list|,
operator|&
name|cpl
operator|->
name|peer_port
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|opt0
operator|=
name|calc_opt0
argument_list|(
name|so
argument_list|,
name|vi
argument_list|,
name|toep
operator|->
name|l2te
argument_list|,
name|mtu_idx
argument_list|,
name|rscale
argument_list|,
name|toep
operator|->
name|rx_credits
argument_list|,
name|toep
operator|->
name|ulp_mode
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|opt2
operator|=
name|calc_opt2a
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %u (%s), toep %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|offload_socket
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|toep
operator|->
name|flags
operator||=
name|TPF_CPL_PENDING
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|undo_offload_socket
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|reason
operator|=
name|__LINE__
expr_stmt|;
name|failed
label|:
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: not offloading (%d), rc %d"
argument_list|,
name|__func__
argument_list|,
name|reason
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
condition|)
name|free_wrqe
argument_list|(
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
condition|)
block|{
if|if
condition|(
name|toep
operator|->
name|tid
operator|>=
literal|0
condition|)
name|free_atid
argument_list|(
name|sc
argument_list|,
name|toep
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|l2te
condition|)
name|t4_l2t_release
argument_list|(
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ce
condition|)
name|release_lip
argument_list|(
name|td
argument_list|,
name|toep
operator|->
name|ce
argument_list|)
expr_stmt|;
name|free_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

