begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/fnv_hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom_l2t.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_comment
comment|/* stid services */
end_comment

begin_function_decl
specifier|static
name|int
name|alloc_stid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|listen_ctx
modifier|*
name|lookup_stid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_stid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* lctx services */
end_comment

begin_function_decl
specifier|static
name|struct
name|listen_ctx
modifier|*
name|alloc_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|vi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hold_lctx
parameter_list|(
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|listen_hash_add
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_find
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_del
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|inpcb
modifier|*
name|release_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|save_qids_in_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|vi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|get_qids_from_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_reset_synqe
parameter_list|(
name|struct
name|toedev
modifier|*
parameter_list|,
name|struct
name|synq_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|alloc_stid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|,
name|int
name|isipv6
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|u_int
name|stid
decl_stmt|,
name|n
decl_stmt|,
name|f
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|stid_region
modifier|*
name|sr
init|=
operator|&
name|lctx
operator|->
name|stid_region
decl_stmt|;
comment|/* 	 * An IPv6 server needs 2 naturally aligned stids (1 stid = 4 cells) in 	 * the TCAM.  The start of the stid region is properly aligned (the chip 	 * requires each region to be 128-cell aligned). 	 */
name|n
operator|=
name|isipv6
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|mask
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|t
operator|->
name|stid_base
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|t
operator|->
name|nstids
operator|&
name|mask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: stid region (%u, %u) not properly aligned.  n = %u"
operator|,
name|__func__
operator|,
name|t
operator|->
name|stid_base
operator|,
name|t
operator|->
name|nstids
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|t
operator|->
name|nstids
operator|-
name|t
operator|->
name|stids_in_use
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|->
name|nstids_free_head
operator|>=
name|n
condition|)
block|{
comment|/* 		 * This allocation will definitely succeed because the region 		 * starts at a good alignment and we just checked we have enough 		 * stids free. 		 */
name|f
operator|=
name|t
operator|->
name|nstids_free_head
operator|&
name|mask
expr_stmt|;
name|t
operator|->
name|nstids_free_head
operator|-=
name|n
operator|+
name|f
expr_stmt|;
name|stid
operator|=
name|t
operator|->
name|nstids_free_head
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|t
operator|->
name|stids
argument_list|,
name|sr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stid_region
modifier|*
name|s
decl_stmt|;
name|stid
operator|=
name|t
operator|->
name|nstids_free_head
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&t->stids
argument_list|,
argument|link
argument_list|)
block|{
name|stid
operator|+=
name|s
operator|->
name|used
operator|+
name|s
operator|->
name|free
expr_stmt|;
name|f
operator|=
name|stid
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|free
operator|>=
name|n
operator|+
name|f
condition|)
block|{
name|stid
operator|-=
name|n
operator|+
name|f
expr_stmt|;
name|s
operator|->
name|free
operator|-=
name|n
operator|+
name|f
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|t
operator|->
name|stids
argument_list|,
name|s
argument_list|,
name|sr
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|allocated
goto|;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|stid
operator|!=
name|t
operator|->
name|nstids
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: stids TAILQ (%p) corrupt."
literal|"  At %d instead of %d at the end of the queue."
argument_list|,
name|__func__
argument_list|,
operator|&
name|t
operator|->
name|stids
argument_list|,
name|stid
argument_list|,
name|t
operator|->
name|nstids
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|allocated
label|:
name|sr
operator|->
name|used
operator|=
name|n
expr_stmt|;
name|sr
operator|->
name|free
operator|=
name|f
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|+=
name|n
expr_stmt|;
name|t
operator|->
name|stid_tab
index|[
name|stid
index|]
operator|=
name|lctx
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|stid
operator|+
name|t
operator|->
name|stid_base
operator|)
operator|&
name|mask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: EDOOFUS."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|stid
operator|+
name|t
operator|->
name|stid_base
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|lookup_stid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|stid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
return|return
operator|(
name|t
operator|->
name|stid_tab
index|[
name|stid
operator|-
name|t
operator|->
name|stid_base
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_stid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|struct
name|stid_region
modifier|*
name|sr
init|=
operator|&
name|lctx
operator|->
name|stid_region
decl_stmt|;
name|struct
name|stid_region
modifier|*
name|s
decl_stmt|;
name|KASSERT
argument_list|(
name|sr
operator|->
name|used
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: nonsense free (%d)"
operator|,
name|__func__
operator|,
name|sr
operator|->
name|used
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
name|s
operator|=
name|TAILQ_PREV
argument_list|(
name|sr
argument_list|,
name|stid_head
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|free
operator|+=
name|sr
operator|->
name|used
operator|+
name|sr
operator|->
name|free
expr_stmt|;
else|else
name|t
operator|->
name|nstids_free_head
operator|+=
name|sr
operator|->
name|used
operator|+
name|sr
operator|->
name|free
expr_stmt|;
name|KASSERT
argument_list|(
name|t
operator|->
name|stids_in_use
operator|>=
name|sr
operator|->
name|used
argument_list|,
operator|(
literal|"%s: stids_in_use (%u)< stids being freed (%u)"
operator|,
name|__func__
operator|,
name|t
operator|->
name|stids_in_use
operator|,
name|sr
operator|->
name|used
operator|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|-=
name|sr
operator|->
name|used
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|t
operator|->
name|stids
argument_list|,
name|sr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|alloc_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_ctx
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lctx
operator|->
name|stid
operator|=
name|alloc_stid
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|,
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|stid
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|lctx
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|&&
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|in6addr_any
argument_list|,
operator|&
name|inp
operator|->
name|in6p_laddr
argument_list|)
condition|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|lctx
operator|->
name|ce
operator|=
name|hold_lip
argument_list|(
name|td
argument_list|,
operator|&
name|inp
operator|->
name|in6p_laddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|ce
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|lctx
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|lctx
operator|->
name|ctrlq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|vi
operator|->
name|pi
operator|->
name|port_id
index|]
expr_stmt|;
name|lctx
operator|->
name|ofld_rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|vi
operator|->
name|first_ofld_rxq
index|]
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|lctx
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|inp
operator|=
name|inp
expr_stmt|;
name|lctx
operator|->
name|vnet
operator|=
name|inp
operator|->
name|inp_socket
operator|->
name|so_vnet
expr_stmt|;
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Don't call this directly, use release_lctx instead */
end_comment

begin_function
specifier|static
name|int
name|free_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|refcount
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: refcount %d"
operator|,
name|__func__
operator|,
name|lctx
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
argument_list|,
operator|(
literal|"%s: synq not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: bad stid %d."
operator|,
name|__func__
operator|,
name|lctx
operator|->
name|stid
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, lctx %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|lctx
argument_list|,
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|ce
condition|)
name|release_lip
argument_list|(
name|td
argument_list|,
name|lctx
operator|->
name|ce
argument_list|)
expr_stmt|;
name|free_stid
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lctx
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hold_lctx
parameter_list|(
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|lctx
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|listen_hashfn
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
return|return
operator|(
name|fnv_32_buf
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|,
name|FNV1_32_INIT
argument_list|)
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a listen_ctx entry to the listen hash table.  */
end_comment

begin_function
specifier|static
name|void
name|listen_hash_add
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|lctx
operator|->
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|td
operator|->
name|listen_hash
index|[
name|bucket
index|]
argument_list|,
name|lctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|td
operator|->
name|lctx_count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for the listening socket's context entry in the hash and return it.  */
end_comment

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_find
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lctx
argument_list|,
argument|&td->listen_hash[bucket]
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|lctx
operator|->
name|inp
operator|==
name|inp
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes the listen_ctx structure for inp from the hash and returns it.  */
end_comment

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_del
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lctx
argument_list|,
argument|&td->listen_hash[bucket]
argument_list|,
argument|link
argument_list|,
argument|l
argument_list|)
block|{
if|if
condition|(
name|lctx
operator|->
name|inp
operator|==
name|inp
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|td
operator|->
name|lctx_count
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Releases a hold on the lctx.  Must be called with the listening socket's inp  * locked.  The inp may be freed by this function and it returns NULL to  * indicate this.  */
end_comment

begin_function
specifier|static
name|struct
name|inpcb
modifier|*
name|release_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|int
name|inp_freed
init|=
literal|0
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|lctx
operator|->
name|refcount
argument_list|)
condition|)
name|inp_freed
operator|=
name|free_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp_freed
condition|?
name|NULL
else|:
name|inp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_reset_synqe
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|synqe
operator|->
name|syn
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_flowc_wr
modifier|*
name|flowc
decl_stmt|;
name|struct
name|cpl_abort_req
modifier|*
name|req
decl_stmt|;
name|int
name|txqid
decl_stmt|,
name|rxqid
decl_stmt|,
name|flowclen
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
specifier|const
name|int
name|nparams
init|=
literal|6
decl_stmt|;
name|unsigned
name|int
name|pfvf
init|=
name|G_FW_VIID_PFN
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
operator|<<
name|S_FW_VIID_PFN
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|synqe
operator|->
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: synqe %p (0x%x), tid %d%s"
argument_list|,
name|__func__
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
name|synqe
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|?
literal|" (abort already in progress)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|)
return|return;
comment|/* abort already in progress */
name|synqe
operator|->
name|flags
operator||=
name|TPF_ABORT_SHUTDOWN
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|m
argument_list|,
operator|&
name|txqid
argument_list|,
operator|&
name|rxqid
argument_list|)
expr_stmt|;
name|ofld_txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
index|[
name|txqid
index|]
expr_stmt|;
name|ofld_rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|rxqid
index|]
expr_stmt|;
comment|/* The wrqe will have two WRs - a flowc followed by an abort_req */
name|flowclen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|flowc
argument_list|)
operator|+
name|nparams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fw_flowc_mnemval
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|roundup2
argument_list|(
name|flowclen
argument_list|,
name|EQ_ESIZE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|flowc
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|flowc
operator|+
name|roundup2
argument_list|(
name|flowclen
argument_list|,
name|EQ_ESIZE
argument_list|)
operator|)
expr_stmt|;
comment|/* First the flowc ... */
name|memset
argument_list|(
name|flowc
argument_list|,
literal|0
argument_list|,
name|wr
operator|->
name|wr_len
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|op_to_nparams
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FLOWC_WR
argument_list|)
operator||
name|V_FW_FLOWC_WR_NPARAMS
argument_list|(
name|nparams
argument_list|)
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|flowid_len16
operator|=
name|htonl
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
name|howmany
argument_list|(
name|flowclen
argument_list|,
literal|16
argument_list|)
argument_list|)
operator||
name|V_FW_WR_FLOWID
argument_list|(
name|synqe
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|0
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_PFNVFN
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|0
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pfvf
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|1
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_CH
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|2
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_PORT
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|3
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_IQID
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|3
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|4
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_SNDBUF
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|4
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|5
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_MSS
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|5
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|flags
operator||=
name|TPF_FLOWC_WR_SENT
expr_stmt|;
comment|/* ... then ABORT request */
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|req
argument_list|,
name|CPL_ABORT_REQ
argument_list|,
name|synqe
operator|->
name|tid
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd0
operator|=
literal|0
expr_stmt|;
comment|/* don't have a snd_nxt */
name|req
operator|->
name|rsvd1
operator|=
literal|1
expr_stmt|;
comment|/* no data sent yet */
name|req
operator|->
name|cmd
operator|=
name|CPL_ABORT_SEND_RST
expr_stmt|;
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_server
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_pass_open_req
modifier|*
name|req
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|lctx
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: allocation failure"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_OPEN_REQ
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|local_port
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|req
operator|->
name|peer_port
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|local_ip
operator|=
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
expr_stmt|;
name|req
operator|->
name|peer_ip
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|opt0
operator|=
name|htobe64
argument_list|(
name|V_TX_CHAN
argument_list|(
name|lctx
operator|->
name|ctrlq
operator|->
name|eq
operator|.
name|tx_chan
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt1
operator|=
name|htobe64
argument_list|(
name|V_CONN_POLICY
argument_list|(
name|CPL_CONN_POLICY_ASK
argument_list|)
operator||
name|F_SYN_RSS_ENABLE
operator||
name|V_SYN_RSS_QUEUE
argument_list|(
name|lctx
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_server6
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_pass_open_req6
modifier|*
name|req
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|lctx
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: allocation failure"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_OPEN_REQ6
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|local_port
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|req
operator|->
name|peer_port
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|local_ip_hi
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|inp
operator|->
name|in6p_laddr
operator|.
name|s6_addr
index|[
literal|0
index|]
expr_stmt|;
name|req
operator|->
name|local_ip_lo
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|inp
operator|->
name|in6p_laddr
operator|.
name|s6_addr
index|[
literal|8
index|]
expr_stmt|;
name|req
operator|->
name|peer_ip_hi
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|peer_ip_lo
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|opt0
operator|=
name|htobe64
argument_list|(
name|V_TX_CHAN
argument_list|(
name|lctx
operator|->
name|ctrlq
operator|->
name|eq
operator|.
name|tx_chan
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt1
operator|=
name|htobe64
argument_list|(
name|V_CONN_POLICY
argument_list|(
name|CPL_CONN_POLICY_ASK
argument_list|)
operator||
name|F_SYN_RSS_ENABLE
operator||
name|V_SYN_RSS_QUEUE
argument_list|(
name|lctx
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_server
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_close_listsvr_req
modifier|*
name|req
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|lctx
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_CLOSE_LISTSRV_REQ
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply_ctrl
operator|=
name|htobe16
argument_list|(
name|lctx
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd
operator|=
name|htobe16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a listening server by sending a passive open request to HW.  *  * Can't take adapter lock here and access to sc->flags,  * sc->offload_map, if_capenable are all race prone.  */
end_comment

begin_function
name|int
name|t4_listen_start
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|v
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Don't start a hardware listener for any loopback address. */
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|&&
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|inp
operator|->
name|in6p_laddr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|)
operator|&&
name|IN_LOOPBACK
argument_list|(
name|ntohl
argument_list|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
block|ADAPTER_LOCK(sc); 	if (IS_BUSY(sc)) { 		log(LOG_ERR, "%s: listen request ignored, %s is busy", 		    __func__, device_get_nameunit(sc->dev)); 		goto done; 	}  	KASSERT(uld_active(sc, ULD_TOM), 	    ("%s: TOM not initialized", __func__));
endif|#
directive|endif
comment|/* 	 * Find an initialized VI with IFCAP_TOE (4 or 6).  We'll use the first 	 * such VI's queues to send the passive open and receive the reply to 	 * it. 	 * 	 * XXX: need a way to mark a port in use by offload.  if_cxgbe should 	 * then reject any attempt to bring down such a port (and maybe reject 	 * attempts to disable IFCAP_TOE on that port too?). 	 */
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|&&
name|vi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE
condition|)
goto|goto
name|found
goto|;
block|}
block|}
goto|goto
name|done
goto|;
comment|/* no port that's UP with IFCAP_TOE enabled */
name|found
label|:
if|if
condition|(
name|listen_hash_find
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* already setup */
name|lctx
operator|=
name|alloc_lctx
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|,
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: listen request ignored, %s couldn't allocate lctx\n"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|listen_hash_add
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u (%s), lctx %p, inp %p vflag 0x%x"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|lctx
argument_list|,
name|inp
argument_list|,
name|inp
operator|->
name|inp_vflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
name|rc
operator|=
name|create_server6
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|create_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s failed to create hw listener: %d.\n"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
comment|/* can't be freed, host stack has a reference */
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inp freed"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|lctx
operator|->
name|flags
operator||=
name|LCTX_RPL_PENDING
expr_stmt|;
name|done
label|:
if|#
directive|if
literal|0
block|ADAPTER_UNLOCK(sc);
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_listen_stop
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* no hardware listener for this inp */
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, lctx %p, flags %x"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|lctx
argument_list|,
name|lctx
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * If the reply to the PASS_OPEN is still pending we'll wait for it to 	 * arrive and clean up when it does. 	 */
if|if
condition|(
name|lctx
operator|->
name|flags
operator|&
name|LCTX_RPL_PENDING
condition|)
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
argument_list|,
operator|(
literal|"%s: synq not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
block|}
comment|/* 	 * The host stack will abort all the connections on the listening 	 * socket's so_comp.  It doesn't know about the connections on the synq 	 * so we need to take care of those. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|synqe
argument_list|,
argument|&lctx->synq
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_HAS_L2TE
condition|)
name|send_reset_synqe
argument_list|(
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
block|}
name|destroy_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|hold_synqe
parameter_list|(
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|release_synqe
parameter_list|(
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|)
condition|)
block|{
name|int
name|needfree
init|=
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_NEEDFREE
decl_stmt|;
name|m_freem
argument_list|(
name|synqe
operator|->
name|syn
argument_list|)
expr_stmt|;
if|if
condition|(
name|needfree
condition|)
name|free
argument_list|(
name|synqe
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_syncache_added
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|hold_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_syncache_removed
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX */
end_comment

begin_function_decl
specifier|extern
name|void
name|tcp_dooptions
parameter_list|(
name|struct
name|tcpopt
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|t4_syncache_respond
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|wr
operator|=
operator|(
expr|struct
name|wrqe
operator|*
operator|)
name|atomic_readandclear_ptr
argument_list|(
operator|&
name|synqe
operator|->
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
name|th
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|th
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|TO_SYN
argument_list|)
expr_stmt|;
comment|/* save these for later */
name|synqe
operator|->
name|iss
operator|=
name|be32toh
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|ts
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>=
name|CHELSIO_T5
condition|)
block|{
name|struct
name|cpl_t5_pass_accept_rpl
modifier|*
name|rpl5
init|=
name|wrtod
argument_list|(
name|wr
argument_list|)
decl_stmt|;
name|rpl5
operator|->
name|iss
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
block|}
name|e
operator|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
expr_stmt|;
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* don't need this any more */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_pass_open_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_pass_open_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|cpl
operator|->
name|status
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
name|sc
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_PASS_OPEN_RPL
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %d, status %u, flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|status
argument_list|,
name|lctx
operator|->
name|flags
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|flags
operator|&=
operator|~
name|LCTX_RPL_PENDING
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"listener (stid %u) failed: %d\n"
argument_list|,
name|stid
argument_list|,
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * If the inp has been dropped (listening socket closed) then 	 * listen_stop must have run and taken the inp out of the hash. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|KASSERT
argument_list|(
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: inp %p still in listen hash"
operator|,
name|__func__
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|&&
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
if|if
condition|(
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Listening socket stopped listening earlier and now the chip tells us 	 * it has started the hardware listener.  Stop it; the lctx will be 	 * released in do_close_server_rpl. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|destroy_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Failed to start hardware listener.  Take inp out of the hash and 	 * release our reference on it.  An error message has been logged 	 * already. 	 */
if|if
condition|(
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* hardware listener open for business */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_close_server_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_close_listsvr_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|cpl
operator|->
name|status
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
name|sc
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, status %u"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed (%u) to close listener for stid %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|,
name|stid
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|done_with_synqe
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|synqe
operator|->
name|syn
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_softc
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
decl_stmt|;
name|int
name|ntids
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|ntids
operator|=
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|remove_tid
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
name|ntids
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|vi
operator|->
name|pi
operator|->
name|port_id
index|]
argument_list|)
expr_stmt|;
name|t4_l2t_release
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* removed from synq list */
block|}
end_function

begin_function
name|int
name|do_abort_req_synqe
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_req_rss
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|int
name|txqid
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_ABORT_REQ_RSS
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, synqe %p (0x%x), lctx %p, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|synqe
operator|->
name|lctx
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative_advice
argument_list|(
name|cpl
operator|->
name|status
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore negative advice */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
operator|&
name|txqid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ofld_txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
index|[
name|txqid
index|]
expr_stmt|;
comment|/* 	 * If we'd initiated an abort earlier the reply to it is responsible for 	 * cleaning up resources.  Otherwise we tear everything down right here 	 * right now.  We owe the T4 a CPL_ABORT_RPL no matter what. 	 */
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done_with_synqe
argument_list|(
name|sc
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
comment|/* inp lock released by done_with_synqe */
name|done
label|:
name|send_abort_rpl
argument_list|(
name|sc
argument_list|,
name|ofld_txq
argument_list|,
name|tid
argument_list|,
name|CPL_ABORT_NO_RST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|do_abort_rpl_synqe
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_rpl_rss
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_ABORT_RPL_RSS
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, synqe %p (0x%x), lctx %p, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|synqe
operator|->
name|lctx
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: wasn't expecting abort reply for synqe %p (0x%x)"
operator|,
name|__func__
operator|,
name|synqe
operator|,
name|synqe
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|done_with_synqe
argument_list|(
name|sc
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
comment|/* inp lock released by done_with_synqe */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_offload_socket
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|*
operator|(
expr|struct
name|toepcb
operator|*
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
decl_stmt|;
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* prevents bad race with accept() */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE
argument_list|,
operator|(
literal|"%s: %p not a synq_entry?"
operator|,
name|__func__
operator|,
name|arg
operator|)
argument_list|)
expr_stmt|;
name|offload_socket
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|make_established
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|snd_isn
argument_list|,
name|cpl
operator|->
name|rcv_isn
argument_list|,
name|cpl
operator|->
name|tcp_opt
argument_list|)
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_CPL_PENDING
expr_stmt|;
name|update_tid
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|flags
operator||=
name|TPF_SYNQE_EXPANDED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|save_qids_in_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|uint32_t
name|txqid
decl_stmt|,
name|rxqid
decl_stmt|;
name|txqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|vi
operator|->
name|nofldtxq
operator|)
operator|+
name|vi
operator|->
name|first_ofld_txq
expr_stmt|;
name|rxqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|vi
operator|->
name|nofldrxq
operator|)
operator|+
name|vi
operator|->
name|first_ofld_rxq
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
operator|(
name|txqid
operator|<<
literal|16
operator|)
operator||
operator|(
name|rxqid
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|get_qids_from_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|txqid
parameter_list|,
name|int
modifier|*
name|rxqid
parameter_list|)
block|{
if|if
condition|(
name|txqid
condition|)
operator|*
name|txqid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|rxqid
condition|)
operator|*
name|rxqid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|&
literal|0xffff
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use the trailing space in the mbuf in which the PASS_ACCEPT_REQ arrived to  * store some state temporarily.  */
end_comment

begin_function
specifier|static
name|struct
name|synq_entry
modifier|*
name|mbuf_to_synqe
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|len
init|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|synq_entry
argument_list|)
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|int
name|tspace
init|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tspace
operator|<
name|len
condition|)
block|{
name|synqe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|synqe
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|synqe
operator|->
name|flags
operator|=
name|TPF_SYNQE
operator||
name|TPF_SYNQE_NEEDFREE
expr_stmt|;
block|}
else|else
block|{
name|synqe
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|m
operator|->
name|m_len
operator|+
name|tspace
operator|-
name|len
operator|)
expr_stmt|;
name|synqe
operator|->
name|flags
operator|=
name|TPF_SYNQE
expr_stmt|;
block|}
return|return
operator|(
name|synqe
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4opt_to_tcpopt
parameter_list|(
specifier|const
name|struct
name|tcp_options
modifier|*
name|t4opt
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|)
block|{
name|bzero
argument_list|(
name|to
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4opt
operator|->
name|mss
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_MSS
expr_stmt|;
name|to
operator|->
name|to_mss
operator|=
name|be16toh
argument_list|(
name|t4opt
operator|->
name|mss
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t4opt
operator|->
name|wsf
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_SCALE
expr_stmt|;
name|to
operator|->
name|to_wscale
operator|=
name|t4opt
operator|->
name|wsf
expr_stmt|;
block|}
if|if
condition|(
name|t4opt
operator|->
name|tstamp
condition|)
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
if|if
condition|(
name|t4opt
operator|->
name|sack
condition|)
name|to
operator|->
name|to_flags
operator||=
name|TOF_SACKPERM
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Options2 for passive open.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|calc_opt2p
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|rxqid
parameter_list|,
specifier|const
name|struct
name|tcp_options
modifier|*
name|tcpopt
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|int
name|ulp_mode
parameter_list|)
block|{
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|rxqid
index|]
decl_stmt|;
name|uint32_t
name|opt2
decl_stmt|;
name|opt2
operator|=
name|V_TX_QUEUE
argument_list|(
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_modq
index|[
name|pi
operator|->
name|tx_chan
index|]
argument_list|)
operator||
name|F_RSS_QUEUE_VALID
operator||
name|V_RSS_QUEUE
argument_list|(
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_tcp_do_rfc1323
condition|)
block|{
if|if
condition|(
name|tcpopt
operator|->
name|tstamp
condition|)
name|opt2
operator||=
name|F_TSTAMPS_EN
expr_stmt|;
if|if
condition|(
name|tcpopt
operator|->
name|sack
condition|)
name|opt2
operator||=
name|F_SACK_EN
expr_stmt|;
if|if
condition|(
name|tcpopt
operator|->
name|wsf
operator|<=
literal|14
condition|)
name|opt2
operator||=
name|F_WND_SCALE_EN
expr_stmt|;
block|}
if|if
condition|(
name|V_tcp_do_ecn
operator|&&
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_ECE
operator||
name|TH_CWR
operator|)
condition|)
name|opt2
operator||=
name|F_CCTRL_ECN
expr_stmt|;
comment|/* RX_COALESCE is always a valid value (0 or M_RX_COALESCE). */
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
name|opt2
operator||=
name|F_RX_COALESCE_VALID
expr_stmt|;
else|else
block|{
name|opt2
operator||=
name|F_T5_OPT_2_VALID
expr_stmt|;
name|opt2
operator||=
name|F_CONG_CNTRL_VALID
expr_stmt|;
comment|/* OPT_2_ISS really, for T5 */
block|}
if|if
condition|(
name|sc
operator|->
name|tt
operator|.
name|rx_coalesce
condition|)
name|opt2
operator||=
name|V_RX_COALESCE
argument_list|(
name|M_RX_COALESCE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DDP_RX_FLOW_CONTROL
if|if
condition|(
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|opt2
operator||=
name|F_RX_FC_VALID
operator||
name|F_RX_FC_DDP
expr_stmt|;
endif|#
directive|endif
return|return
name|htobe32
argument_list|(
name|opt2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pass_accept_req_to_protohdrs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_pass_accept_req
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|unsigned
name|int
name|hlen
init|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|hdr_len
argument_list|)
decl_stmt|;
name|uintptr_t
name|l3hdr
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|eh
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>=
name|CHELSIO_T6
condition|)
block|{
name|l3hdr
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|eh
operator|+
name|G_T6_ETH_HDR_LEN
argument_list|(
name|hlen
argument_list|)
operator|)
expr_stmt|;
name|tcp
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|l3hdr
operator|+
name|G_T6_IP_HDR_LEN
argument_list|(
name|hlen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|l3hdr
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|eh
operator|+
name|G_ETH_HDR_LEN
argument_list|(
name|hlen
argument_list|)
operator|)
expr_stmt|;
name|tcp
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|l3hdr
operator|+
name|G_IP_HDR_LEN
argument_list|(
name|hlen
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|inc
condition|)
block|{
name|bzero
argument_list|(
name|inc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|->
name|inc_fport
operator|=
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|inc
operator|->
name|inc_lport
operator|=
name|tcp
operator|->
name|th_dport
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|l3hdr
operator|)
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|l3hdr
decl_stmt|;
name|inc
operator|->
name|inc_faddr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|inc
operator|->
name|inc_laddr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|l3hdr
decl_stmt|;
name|inc
operator|->
name|inc_flags
operator||=
name|INC_ISIPV6
expr_stmt|;
name|inc
operator|->
name|inc6_faddr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|inc
operator|->
name|inc6_laddr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
block|}
block|}
if|if
condition|(
name|th
condition|)
block|{
name|bcopy
argument_list|(
name|tcp
argument_list|,
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_fields_to_host
argument_list|(
name|th
argument_list|)
expr_stmt|;
comment|/* just like tcp_input */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ifnet_has_ip6
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|ip6
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|in6_addr
name|in6
init|=
operator|*
name|ip6
decl_stmt|;
comment|/* Just as in ip6_input */
if|if
condition|(
name|in6_clearscope
argument_list|(
operator|&
name|in6
argument_list|)
operator|||
name|in6_clearscope
argument_list|(
operator|&
name|in6
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|in6_setscope
argument_list|(
operator|&
name|in6
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
name|sin6
operator|=
operator|(
name|void
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sin6
operator|->
name|sin6_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|in6
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|l2t_entry
modifier|*
name|get_l2te_for_nexthop
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|sin6
decl_stmt|;
if|if
condition|(
name|inc
operator|->
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
block|{
name|dst
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin6_addr
operator|=
name|inc
operator|->
name|inc6_faddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|inc
operator|->
name|inc6_laddr
argument_list|)
condition|)
block|{
comment|/* no need for route lookup */
name|e
operator|=
name|t4_l2t_get
argument_list|(
name|pi
argument_list|,
name|ifp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
block|}
else|else
block|{
name|dst
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
operator|=
name|inc
operator|->
name|inc_faddr
expr_stmt|;
block|}
name|rt
operator|=
name|rtalloc1
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
block|{
name|struct
name|sockaddr
modifier|*
name|nexthop
decl_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|ifp
condition|)
name|e
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|nexthop
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
else|else
name|nexthop
operator|=
name|dst
expr_stmt|;
name|e
operator|=
name|t4_l2t_get
argument_list|(
name|pi
argument_list|,
name|ifp
argument_list|,
name|nexthop
argument_list|)
expr_stmt|;
block|}
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ifnet_has_ip
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in_addr
name|in
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
name|sin
operator|=
operator|(
name|void
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
continue|continue;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|in
operator|.
name|s_addr
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|REJECT_PASS_ACCEPT
parameter_list|()
value|do { \ 	reject_reason = __LINE__; \ 	goto reject; \ } while (0)
end_define

begin_comment
comment|/*  * The context associated with a tid entry via insert_tid could be a synq_entry  * or a toepcb.  The only way CPL handlers can tell is via a bit in these flags.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|toepcb
argument_list|,
name|flags
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|synq_entry
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Incoming SYN on a listening socket.  *  * XXX: Every use of ifp in this routine has a bad race with up/down, toe/-toe,  * etc.  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_accept_req
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
decl_stmt|;
specifier|const
name|struct
name|cpl_pass_accept_req
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
decl_stmt|;
name|struct
name|cpl_pass_accept_rpl
modifier|*
name|rpl
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|tos_stid
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
name|sc
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|hw_ifp
decl_stmt|,
modifier|*
name|ifp
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|int
name|rscale
decl_stmt|,
name|mtu_idx
decl_stmt|,
name|rx_credits
decl_stmt|,
name|rxqid
decl_stmt|,
name|ulp_mode
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|NULL
decl_stmt|;
name|int
name|reject_reason
decl_stmt|,
name|v
decl_stmt|,
name|ntids
decl_stmt|;
name|uint16_t
name|vid
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_PASS_ACCEPT_REQ
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|pass_accept_req_to_protohdrs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
name|t4opt_to_tcpopt
argument_list|(
operator|&
name|cpl
operator|->
name|tcpopt
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|G_SYN_INTF
argument_list|(
name|be16toh
argument_list|(
name|cpl
operator|->
name|l2info
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|lctx
operator|->
name|vnet
argument_list|)
expr_stmt|;
comment|/* 	 * Use the MAC index to lookup the associated VI.  If this SYN 	 * didn't match a perfect MAC filter, punt. 	 */
if|if
condition|(
operator|!
operator|(
name|be16toh
argument_list|(
name|cpl
operator|->
name|l2info
argument_list|)
operator|&
name|F_SYN_XACT_MATCH
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
if|if
condition|(
name|vi
operator|->
name|xact_addr_filt
operator|==
name|G_SYN_MAC_IDX
argument_list|(
name|be16toh
argument_list|(
name|cpl
operator|->
name|l2info
argument_list|)
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|found
label|:
name|hw_ifp
operator|=
name|vi
operator|->
name|ifp
expr_stmt|;
comment|/* the (v)cxgbeX ifnet */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|hw_ifp
expr_stmt|;
name|tod
operator|=
name|TOEDEV
argument_list|(
name|hw_ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out if there is a pseudo interface (vlan, lagg, etc.) 	 * involved.  Don't offload if the SYN had a VLAN tag and the vid 	 * doesn't match anything on this interface. 	 * 	 * XXX: lagg support, lagg + vlan support. 	 */
name|vid
operator|=
name|EVL_VLANOFTAG
argument_list|(
name|be16toh
argument_list|(
name|cpl
operator|->
name|vlan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vid
operator|!=
literal|0xfff
condition|)
block|{
name|ifp
operator|=
name|VLAN_DEVAT
argument_list|(
name|hw_ifp
argument_list|,
name|vid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
else|else
name|ifp
operator|=
name|hw_ifp
expr_stmt|;
comment|/* 	 * Don't offload if the peer requested a TCP option that's not known to 	 * the silicon. 	 */
if|if
condition|(
name|cpl
operator|->
name|tcpopt
operator|.
name|unknown
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
if|if
condition|(
name|inc
operator|.
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
block|{
comment|/* Don't offload if the ifcap isn't enabled */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE6
operator|)
operator|==
literal|0
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* 		 * SYN must be directed to an IP6 address on this ifnet.  This 		 * is more restrictive than in6_localip. 		 */
if|if
condition|(
operator|!
name|ifnet_has_ip6
argument_list|(
name|ifp
argument_list|,
operator|&
name|inc
operator|.
name|inc6_laddr
argument_list|)
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|ntids
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't offload if the ifcap isn't enabled */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE4
operator|)
operator|==
literal|0
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* 		 * SYN must be directed to an IP address on this ifnet.  This 		 * is more restrictive than in_localip. 		 */
if|if
condition|(
operator|!
name|ifnet_has_ip
argument_list|(
name|ifp
argument_list|,
name|inc
operator|.
name|inc_laddr
argument_list|)
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|ntids
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Don't offload if the ifnet that the SYN came in on is not in the same 	 * vnet as the listening socket. 	 */
if|if
condition|(
name|lctx
operator|->
name|vnet
operator|!=
name|ifp
operator|->
name|if_vnet
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|e
operator|=
name|get_l2te_for_nexthop
argument_list|(
name|pi
argument_list|,
name|ifp
argument_list|,
operator|&
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|synqe
operator|=
name|mbuf_to_synqe
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_pass_accept_rpl
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_t5_pass_accept_rpl
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|rpl
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* for 4-tuple check */
comment|/* Don't offload if the 4-tuple is already in use */
if|if
condition|(
name|toe_4tuple_check
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|,
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|inp
operator|=
name|lctx
operator|->
name|inp
expr_stmt|;
comment|/* listening socket, not owned by TOE */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Don't offload if the listening socket has closed */
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* 		 * The listening socket has closed.  The reply from the TOE to 		 * our CPL_CLOSE_LISTSRV_REQ will ultimately release all 		 * resources tied to this listen context. 		 */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|mtu_idx
operator|=
name|find_best_mtu_idx
argument_list|(
name|sc
argument_list|,
operator|&
name|inc
argument_list|,
name|be16toh
argument_list|(
name|cpl
operator|->
name|tcpopt
operator|.
name|mss
argument_list|)
argument_list|)
expr_stmt|;
name|rscale
operator|=
name|cpl
operator|->
name|tcpopt
operator|.
name|wsf
operator|&&
name|V_tcp_do_rfc1323
condition|?
name|select_rcv_wscale
argument_list|()
else|:
literal|0
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* opt0 rcv_bufsiz initially, assumes its normal meaning later */
name|rx_credits
operator|=
name|min
argument_list|(
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
operator|>>
literal|10
argument_list|,
name|M_RCV_BUFSIZ
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|save_qids_in_mbuf
argument_list|(
name|m
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
operator|&
name|rxqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|rpl
argument_list|,
name|CPL_PASS_ACCEPT_RPL
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|cpl_t5_pass_accept_rpl
modifier|*
name|rpl5
init|=
operator|(
name|void
operator|*
operator|)
name|rpl
decl_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|rpl5
argument_list|,
name|CPL_PASS_ACCEPT_RPL
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tt
operator|.
name|ddp
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_NO_DDP
operator|)
operator|==
literal|0
condition|)
block|{
name|ulp_mode
operator|=
name|ULP_MODE_TCPDDP
expr_stmt|;
name|synqe
operator|->
name|flags
operator||=
name|TPF_SYNQE_TCPDDP
expr_stmt|;
block|}
else|else
name|ulp_mode
operator|=
name|ULP_MODE_NONE
expr_stmt|;
name|rpl
operator|->
name|opt0
operator|=
name|calc_opt0
argument_list|(
name|so
argument_list|,
name|vi
argument_list|,
name|e
argument_list|,
name|mtu_idx
argument_list|,
name|rscale
argument_list|,
name|rx_credits
argument_list|,
name|ulp_mode
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt2
operator|=
name|calc_opt2p
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|rxqid
argument_list|,
operator|&
name|cpl
operator|->
name|tcpopt
argument_list|,
operator|&
name|th
argument_list|,
name|ulp_mode
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|synqe
operator|->
name|lctx
operator|=
name|lctx
expr_stmt|;
name|synqe
operator|->
name|syn
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 means extra hold */
name|synqe
operator|->
name|l2e_idx
operator|=
name|e
operator|->
name|idx
expr_stmt|;
name|synqe
operator|->
name|rcv_bufsize
operator|=
name|rx_credits
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|synqe
operator|->
name|wr
argument_list|,
operator|(
name|uintptr_t
operator|)
name|wr
argument_list|)
expr_stmt|;
name|insert_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|ntids
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|hold_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* hold for the duration it's in the synq */
name|hold_lctx
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
comment|/* A synqe on the list has a ref on its lctx */
comment|/* 	 * If all goes well t4_syncache_respond will get called during 	 * syncache_add.  Note that syncache_add releases the pcb lock. 	 */
name|toe_syncache_add
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
name|inp
argument_list|,
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* ok to assert, we have a ref on the inp */
comment|/* 	 * If we replied during syncache_add (synqe->wr has been consumed), 	 * good.  Otherwise, set it to 0 so that further syncache_respond 	 * attempts by the kernel will be ignored. 	 */
if|if
condition|(
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|synqe
operator|->
name|wr
argument_list|,
operator|(
name|uintptr_t
operator|)
name|wr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * syncache may or may not have a hold on the synqe, which may 		 * or may not be stashed in the original SYN mbuf passed to us. 		 * Just copy it over instead of dealing with all possibilities. 		 */
name|m
operator|=
name|m_dup
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|hw_ifp
expr_stmt|;
name|remove_tid
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
name|ntids
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
comment|/* Yank the synqe out of the lctx synq. */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* removed from synq list */
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* extra hold */
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p, synqe %p, SYNACK"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|flags
operator||=
name|TPF_SYNQE_HAS_L2TE
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* 		 * Listening socket closed but tod_listen_stop did not abort 		 * this tid because there was no L2T entry for the tid at that 		 * time.  Abort it now.  The reply to the abort will clean up. 		 */
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p, synqe %p (0x%x), ABORT"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_EXPANDED
operator|)
condition|)
name|send_reset_synqe
argument_list|(
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* extra hold */
return|return
operator|(
name|__LINE__
operator|)
return|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* extra hold */
return|return
operator|(
literal|0
operator|)
return|;
name|reject
label|:
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, REJECT (%d)"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|reject_reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|t4_l2t_release
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|lctx
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|hw_ifp
operator|->
name|if_input
argument_list|(
name|hw_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|reject_reason
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|synqe_to_protohdrs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|,
specifier|const
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|)
block|{
name|uint16_t
name|tcp_opt
init|=
name|be16toh
argument_list|(
name|cpl
operator|->
name|tcp_opt
argument_list|)
decl_stmt|;
comment|/* start off with the original SYN */
name|pass_accept_req_to_protohdrs
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|syn
argument_list|,
name|inc
argument_list|,
name|th
argument_list|)
expr_stmt|;
comment|/* modify parts to make it look like the ACK to our SYN|ACK */
name|th
operator|->
name|th_flags
operator|=
name|TH_ACK
expr_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|synqe
operator|->
name|iss
operator|+
literal|1
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|rcv_isn
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|to
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_TCPOPT_TSTAMP
argument_list|(
name|tcp_opt
argument_list|)
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
name|to
operator|->
name|to_tsecr
operator|=
name|synqe
operator|->
name|ts
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_pass_establish
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|const
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KTR
argument_list|)
operator|||
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
name|unsigned
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|tos_stid
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|,
modifier|*
name|new_inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|u_int
name|txqid
decl_stmt|,
name|rxqid
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_PASS_ESTABLISH
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE
argument_list|,
operator|(
literal|"%s: tid %u (ctx %p) not a synqe"
operator|,
name|__func__
operator|,
name|tid
operator|,
name|synqe
operator|)
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|lctx
operator|->
name|vnet
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* for syncache_expand */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, synqe %p (0x%x), inp_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_HAS_L2TE
condition|)
block|{
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: listen socket closed but tid %u not aborted."
operator|,
name|__func__
operator|,
name|tid
operator|)
argument_list|)
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ifp
operator|=
name|synqe
operator|->
name|syn
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|vi
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|KASSERT
argument_list|(
name|vi
operator|->
name|pi
operator|->
name|adapter
operator|==
name|sc
argument_list|,
operator|(
literal|"%s: vi %p, sc %p mismatch"
operator|,
name|__func__
operator|,
name|vi
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
operator|&
name|txqid
argument_list|,
operator|&
name|rxqid
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rxqid
operator|==
name|iq_to_ofld_rxq
argument_list|(
name|iq
argument_list|)
operator|-
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
literal|0
index|]
argument_list|,
operator|(
literal|"%s: CPL arrived on unexpected rxq.  %d %d"
operator|,
name|__func__
operator|,
name|rxqid
operator|,
call|(
name|int
call|)
argument_list|(
name|iq_to_ofld_rxq
argument_list|(
name|iq
argument_list|)
operator|-
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|=
name|alloc_toepcb
argument_list|(
name|vi
argument_list|,
name|txqid
argument_list|,
name|rxqid
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
block|{
name|reset
label|:
comment|/* 		 * The reply to this abort will perform final cleanup.  There is 		 * no need to check for HAS_L2TE here.  We can be here only if 		 * we responded to the PASS_ACCEPT_REQ, and our response had the 		 * L2T idx. 		 */
name|send_reset_synqe
argument_list|(
name|TOEDEV
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|toep
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|toep
operator|->
name|l2te
operator|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
expr_stmt|;
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_TCPDDP
condition|)
name|set_tcpddp_ulp_mode
argument_list|(
name|toep
argument_list|)
expr_stmt|;
else|else
name|toep
operator|->
name|ulp_mode
operator|=
name|ULP_MODE_NONE
expr_stmt|;
comment|/* opt0 rcv_bufsiz initially, assumes its normal meaning later */
name|toep
operator|->
name|rx_credits
operator|=
name|synqe
operator|->
name|rcv_bufsize
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: socket is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Come up with something that syncache_expand should be ok with. */
name|synqe_to_protohdrs
argument_list|(
name|sc
argument_list|,
name|synqe
argument_list|,
name|cpl
argument_list|,
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
comment|/* 	 * No more need for anything in the mbuf that carried the 	 * CPL_PASS_ACCEPT_REQ.  Drop the CPL_PASS_ESTABLISH and toep pointer 	 * there.  XXX: bad form but I don't want to increase the size of synqe. 	 */
name|m
operator|=
name|synqe
operator|->
name|syn
expr_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|toep
argument_list|)
operator|<=
name|m
operator|->
name|m_len
argument_list|,
operator|(
literal|"%s: no room in mbuf %p (m_len %d)"
operator|,
name|__func__
operator|,
name|m
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cpl
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|toepcb
operator|*
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_pass_establish
operator|*
argument_list|)
operator|+
literal|1
operator|)
operator|=
name|toep
expr_stmt|;
if|if
condition|(
operator|!
name|toe_syncache_expand
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|so
argument_list|)
operator|||
name|so
operator|==
name|NULL
condition|)
block|{
name|free_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
comment|/* New connection inpcb is already locked by syncache_expand(). */
name|new_inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|so
operator|->
name|so_vnet
operator|==
name|lctx
operator|->
name|vnet
argument_list|)
expr_stmt|;
name|toep
operator|->
name|vnet
operator|=
name|lctx
operator|->
name|vnet
expr_stmt|;
if|if
condition|(
name|inc
operator|.
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
name|toep
operator|->
name|ce
operator|=
name|hold_lip
argument_list|(
name|sc
operator|->
name|tom_softc
argument_list|,
operator|&
name|inc
operator|.
name|inc6_laddr
argument_list|,
name|lctx
operator|->
name|ce
argument_list|)
expr_stmt|;
comment|/* 	 * This is for the unlikely case where the syncache entry that we added 	 * has been evicted from the syncache, but the syncache_expand above 	 * works because of syncookies. 	 * 	 * XXX: we've held the tcbinfo lock throughout so there's no risk of 	 * anyone accept'ing a connection before we've installed our hooks, but 	 * this somewhat defeats the purpose of having a tod_offload_socket :-( 	 */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|synqe
operator|->
name|flags
operator|&
name|TPF_SYNQE_EXPANDED
operator|)
argument_list|)
condition|)
block|{
name|tcp_timer_activate
argument_list|(
name|intotcpcb
argument_list|(
name|new_inp
argument_list|)
argument_list|,
name|TT_KEEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_offload_socket
argument_list|(
name|TOEDEV
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|synqe
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
comment|/* Done with the synqe */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_init_listen_cpl_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_PASS_OPEN_RPL
argument_list|,
name|do_pass_open_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
name|do_close_server_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_PASS_ACCEPT_REQ
argument_list|,
name|do_pass_accept_req
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_PASS_ESTABLISH
argument_list|,
name|do_pass_establish
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_uninit_listen_cpl_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_PASS_OPEN_RPL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_PASS_ACCEPT_REQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_PASS_ESTABLISH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

