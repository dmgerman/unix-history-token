begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/fnv_hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom_l2t.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_comment
comment|/* stid services */
end_comment

begin_function_decl
specifier|static
name|int
name|alloc_stid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|lookup_stid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_stid
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* lctx services */
end_comment

begin_function_decl
specifier|static
name|struct
name|listen_ctx
modifier|*
name|alloc_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hold_lctx
parameter_list|(
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|listen_hash_add
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_find
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_del
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|inpcb
modifier|*
name|release_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|listen_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|save_qids_in_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|get_qids_from_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_reset_synqe
parameter_list|(
name|struct
name|toedev
modifier|*
parameter_list|,
name|struct
name|synq_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX: won't work for IPv6 */
end_comment

begin_function
specifier|static
name|int
name|alloc_stid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|int
name|stid
init|=
operator|-
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sfree
condition|)
block|{
name|union
name|serv_entry
modifier|*
name|p
init|=
name|t
operator|->
name|sfree
decl_stmt|;
name|stid
operator|=
name|p
operator|-
name|t
operator|->
name|stid_tab
expr_stmt|;
name|stid
operator|+=
name|t
operator|->
name|stid_base
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|ctx
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|stid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|lookup_stid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|stid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
return|return
operator|(
name|t
operator|->
name|stid_tab
index|[
name|stid
operator|-
name|t
operator|->
name|stid_base
index|]
operator|.
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_stid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|stid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|union
name|serv_entry
modifier|*
name|p
init|=
operator|&
name|t
operator|->
name|stid_tab
index|[
name|stid
operator|-
name|t
operator|->
name|stid_base
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|sfree
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|alloc_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_ctx
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lctx
operator|->
name|stid
operator|=
name|alloc_stid
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|stid
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|lctx
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|lctx
operator|->
name|ctrlq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
expr_stmt|;
name|lctx
operator|->
name|ofld_rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|pi
operator|->
name|first_ofld_rxq
index|]
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|lctx
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|inp
operator|=
name|inp
expr_stmt|;
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Don't call this directly, use release_lctx instead */
end_comment

begin_function
specifier|static
name|int
name|free_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|refcount
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: refcount %d"
operator|,
name|__func__
operator|,
name|lctx
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
argument_list|,
operator|(
literal|"%s: synq not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: bad stid %d."
operator|,
name|__func__
operator|,
name|lctx
operator|->
name|stid
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, lctx %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|lctx
argument_list|,
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
name|free_stid
argument_list|(
name|sc
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lctx
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hold_lctx
parameter_list|(
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|lctx
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|listen_hashfn
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
return|return
operator|(
name|fnv_32_buf
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|,
name|FNV1_32_INIT
argument_list|)
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a listen_ctx entry to the listen hash table.  */
end_comment

begin_function
specifier|static
name|void
name|listen_hash_add
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|lctx
operator|->
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|td
operator|->
name|listen_hash
index|[
name|bucket
index|]
argument_list|,
name|lctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|td
operator|->
name|lctx_count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for the listening socket's context entry in the hash and return it.  */
end_comment

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_find
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lctx
argument_list|,
argument|&td->listen_hash[bucket]
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|lctx
operator|->
name|inp
operator|==
name|inp
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes the listen_ctx structure for inp from the hash and returns it.  */
end_comment

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_del
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lctx
argument_list|,
argument|&td->listen_hash[bucket]
argument_list|,
argument|link
argument_list|,
argument|l
argument_list|)
block|{
if|if
condition|(
name|lctx
operator|->
name|inp
operator|==
name|inp
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|td
operator|->
name|lctx_count
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Releases a hold on the lctx.  Must be called with the listening socket's inp  * locked.  The inp may be freed by this function and it returns NULL to  * indicate this.  */
end_comment

begin_function
specifier|static
name|struct
name|inpcb
modifier|*
name|release_lctx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|int
name|inp_freed
init|=
literal|0
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|lctx
operator|->
name|refcount
argument_list|)
condition|)
name|inp_freed
operator|=
name|free_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp_freed
condition|?
name|NULL
else|:
name|inp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_reset_synqe
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|synqe
operator|->
name|syn
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_flowc_wr
modifier|*
name|flowc
decl_stmt|;
name|struct
name|cpl_abort_req
modifier|*
name|req
decl_stmt|;
name|int
name|txqid
decl_stmt|,
name|rxqid
decl_stmt|,
name|flowclen
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
specifier|const
name|int
name|nparams
init|=
literal|4
decl_stmt|;
name|unsigned
name|int
name|pfvf
init|=
name|G_FW_VIID_PFN
argument_list|(
name|pi
operator|->
name|viid
argument_list|)
operator|<<
name|S_FW_VIID_PFN
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|synqe
operator|->
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: synqe %p, tid %d%s"
argument_list|,
name|__func__
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
condition|?
literal|" (abort already in progress)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
condition|)
return|return;
comment|/* abort already in progress */
name|synqe_set_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|m
argument_list|,
operator|&
name|txqid
argument_list|,
operator|&
name|rxqid
argument_list|)
expr_stmt|;
name|ofld_txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
index|[
name|txqid
index|]
expr_stmt|;
name|ofld_rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|rxqid
index|]
expr_stmt|;
comment|/* The wrqe will have two WRs - a flowc followed by an abort_req */
name|flowclen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|flowc
argument_list|)
operator|+
name|nparams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fw_flowc_mnemval
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|roundup
argument_list|(
name|flowclen
argument_list|,
name|EQ_ESIZE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|ofld_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|flowc
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|flowc
operator|+
name|roundup
argument_list|(
name|flowclen
argument_list|,
name|EQ_ESIZE
argument_list|)
operator|)
expr_stmt|;
comment|/* First the flowc ... */
name|memset
argument_list|(
name|flowc
argument_list|,
literal|0
argument_list|,
name|wr
operator|->
name|wr_len
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|op_to_nparams
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FLOWC_WR
argument_list|)
operator||
name|V_FW_FLOWC_WR_NPARAMS
argument_list|(
name|nparams
argument_list|)
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|flowid_len16
operator|=
name|htonl
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
name|howmany
argument_list|(
name|flowclen
argument_list|,
literal|16
argument_list|)
argument_list|)
operator||
name|V_FW_WR_FLOWID
argument_list|(
name|synqe
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|0
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_PFNVFN
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|0
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pfvf
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|1
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_CH
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|2
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_PORT
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|3
index|]
operator|.
name|mnemonic
operator|=
name|FW_FLOWC_MNEM_IQID
expr_stmt|;
name|flowc
operator|->
name|mnemval
index|[
literal|3
index|]
operator|.
name|val
operator|=
name|htobe32
argument_list|(
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|synqe_set_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_FLOWC_WR_SENT
argument_list|)
expr_stmt|;
comment|/* ... then ABORT request */
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|req
argument_list|,
name|CPL_ABORT_REQ
argument_list|,
name|synqe
operator|->
name|tid
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd0
operator|=
literal|0
expr_stmt|;
comment|/* don't have a snd_nxt */
name|req
operator|->
name|rsvd1
operator|=
literal|1
expr_stmt|;
comment|/* no data sent yet */
name|req
operator|->
name|cmd
operator|=
name|CPL_ABORT_SEND_RST
expr_stmt|;
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_server
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_pass_open_req
modifier|*
name|req
decl_stmt|;
name|struct
name|in_conninfo
modifier|*
name|inc
init|=
operator|&
name|lctx
operator|->
name|inp
operator|->
name|inp_inc
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|lctx
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: allocation failure"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_OPEN_REQ
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|local_port
operator|=
name|inc
operator|->
name|inc_lport
expr_stmt|;
name|req
operator|->
name|peer_port
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|local_ip
operator|=
name|inc
operator|->
name|inc_laddr
operator|.
name|s_addr
expr_stmt|;
name|req
operator|->
name|peer_ip
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|opt0
operator|=
name|htobe64
argument_list|(
name|V_TX_CHAN
argument_list|(
name|lctx
operator|->
name|ctrlq
operator|->
name|eq
operator|.
name|tx_chan
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt1
operator|=
name|htobe64
argument_list|(
name|V_CONN_POLICY
argument_list|(
name|CPL_CONN_POLICY_ASK
argument_list|)
operator||
name|F_SYN_RSS_ENABLE
operator||
name|V_SYN_RSS_QUEUE
argument_list|(
name|lctx
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_server
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_close_listsvr_req
modifier|*
name|req
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|lctx
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: allocation failure."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_CLOSE_LISTSRV_REQ
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply_ctrl
operator|=
name|htobe16
argument_list|(
name|lctx
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd
operator|=
name|htobe16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a listening server by sending a passive open request to HW.  *  * Can't take adapter lock here and access to sc->flags, sc->open_device_map,  * sc->offload_map, if_capenable are all race prone.  */
end_comment

begin_function
name|int
name|t4_listen_start
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV4
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
block|ADAPTER_LOCK(sc); 	if (IS_BUSY(sc)) { 		log(LOG_ERR, "%s: listen request ignored, %s is busy", 		    __func__, device_get_nameunit(sc->dev)); 		goto done; 	}  	KASSERT(sc->flags& TOM_INIT_DONE, 	    ("%s: TOM not initialized", __func__));
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|open_device_map
operator|&
name|sc
operator|->
name|offload_map
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* no port that's UP with IFCAP_TOE enabled */
comment|/* 	 * Find a running port with IFCAP_TOE4.  We'll use the first such port's 	 * queues to send the passive open and receive the reply to it. 	 * 	 * XXX: need a way to mark a port in use by offload.  if_cxgbe should 	 * then reject any attempt to bring down such a port (and maybe reject 	 * attempts to disable IFCAP_TOE on that port too?). 	 */
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|i
argument_list|)
operator|&&
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE4
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
literal|"%s: no running port with TOE capability enabled."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|listen_hash_find
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* already setup */
name|lctx
operator|=
name|alloc_lctx
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: listen request ignored, %s couldn't allocate lctx\n"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|listen_hash_add
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u (%s), lctx %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|lctx
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|create_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s failed to create hw listener.\n"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
comment|/* can't be freed, host stack has a reference */
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inp freed"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|lctx
operator|->
name|flags
operator||=
name|LCTX_RPL_PENDING
expr_stmt|;
name|done
label|:
if|#
directive|if
literal|0
block|ADAPTER_UNLOCK(sc);
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_listen_stop
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* no hardware listener for this inp */
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, lctx %p, flags %x"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|lctx
argument_list|,
name|lctx
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * If the reply to the PASS_OPEN is still pending we'll wait for it to 	 * arrive and clean up when it does. 	 */
if|if
condition|(
name|lctx
operator|->
name|flags
operator|&
name|LCTX_RPL_PENDING
condition|)
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
argument_list|,
operator|(
literal|"%s: synq not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
block|}
comment|/* 	 * The host stack will abort all the connections on the listening 	 * socket's so_comp.  It doesn't know about the connections on the synq 	 * so we need to take care of those. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|synqe
argument_list|,
argument|&lctx->synq
argument_list|,
argument|link
argument_list|)
name|send_reset_synqe
argument_list|(
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|destroy_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|hold_synqe
parameter_list|(
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|release_synqe
parameter_list|(
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|)
condition|)
block|{
name|int
name|needfree
init|=
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_SYNQE_NEEDFREE
argument_list|)
decl_stmt|;
name|m_freem
argument_list|(
name|synqe
operator|->
name|syn
argument_list|)
expr_stmt|;
if|if
condition|(
name|needfree
condition|)
name|free
argument_list|(
name|synqe
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_syncache_added
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|hold_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_syncache_removed
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX */
end_comment

begin_function_decl
specifier|extern
name|void
name|tcp_dooptions
parameter_list|(
name|struct
name|tcpopt
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|t4_syncache_respond
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
decl_stmt|;
name|wr
operator|=
operator|(
expr|struct
name|wrqe
operator|*
operator|)
name|atomic_readandclear_ptr
argument_list|(
operator|&
name|synqe
operator|->
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EALREADY
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|TO_SYN
argument_list|)
expr_stmt|;
comment|/* save these for later */
name|synqe
operator|->
name|iss
operator|=
name|be32toh
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|ts
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
name|e
operator|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
expr_stmt|;
name|t4_l2t_send
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* don't need this any more */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_pass_open_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_pass_open_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|cpl
operator|->
name|status
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
name|sc
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_PASS_OPEN_RPL
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %d, status %u, flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|status
argument_list|,
name|lctx
operator|->
name|flags
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|flags
operator|&=
operator|~
name|LCTX_RPL_PENDING
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"listener with stid %u failed: %d"
argument_list|,
name|stid
argument_list|,
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * If the inp has been dropped (listening socket closed) then 	 * listen_stop must have run and taken the inp out of the hash. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|KASSERT
argument_list|(
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: inp %p still in listen hash"
operator|,
name|__func__
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|&&
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
if|if
condition|(
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Listening socket stopped listening earlier and now the chip tells us 	 * it has started the hardware listener.  Stop it; the lctx will be 	 * released in do_close_server_rpl. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|destroy_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Failed to start hardware listener.  Take inp out of the hash and 	 * release our reference on it.  An error message has been logged 	 * already. 	 */
if|if
condition|(
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|listen_hash_del
argument_list|(
name|sc
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* hardware listener open for business */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_close_server_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_close_listsvr_rpl
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|cpl
operator|->
name|status
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
name|sc
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, status %u"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed (%u) to close listener for stid %u"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|,
name|stid
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|done_with_synqe
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|synqe
operator|->
name|syn
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_softc
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|remove_tid
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|tid
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
argument_list|)
expr_stmt|;
name|t4_l2t_release
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* removed from synq list */
block|}
end_function

begin_function
name|int
name|do_abort_req_synqe
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_req_rss
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|int
name|txqid
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_ABORT_REQ_RSS
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, synqe %p (0x%x), lctx %p, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|synqe
operator|->
name|lctx
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|status
operator|==
name|CPL_ERR_RTX_NEG_ADVICE
operator|||
name|cpl
operator|->
name|status
operator|==
name|CPL_ERR_PERSIST_NEG_ADVICE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore negative advice */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
operator|&
name|txqid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ofld_txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
index|[
name|txqid
index|]
expr_stmt|;
comment|/* 	 * If we'd initiated an abort earlier the reply to it is responsible for 	 * cleaning up resources.  Otherwise we tear everything down right here 	 * right now.  We owe the T4 a CPL_ABORT_RPL no matter what. 	 */
if|if
condition|(
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done_with_synqe
argument_list|(
name|sc
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
comment|/* inp lock released by done_with_synqe */
name|done
label|:
name|send_abort_rpl
argument_list|(
name|sc
argument_list|,
name|ofld_txq
argument_list|,
name|tid
argument_list|,
name|CPL_ABORT_NO_RST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|do_abort_rpl_synqe
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_rpl_rss
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_ABORT_RPL_RSS
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|tid
operator|==
name|tid
argument_list|,
operator|(
literal|"%s: toep tid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %u, synqe %p (0x%x), lctx %p, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|synqe
operator|->
name|lctx
argument_list|,
name|cpl
operator|->
name|status
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
argument_list|,
operator|(
literal|"%s: wasn't expecting abort reply for synqe %p (0x%x)"
operator|,
name|__func__
operator|,
name|synqe
operator|,
name|synqe
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|done_with_synqe
argument_list|(
name|sc
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
comment|/* inp lock released by done_with_synqe */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_offload_socket
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|*
operator|(
expr|struct
name|toepcb
operator|*
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
decl_stmt|;
name|INP_INFO_LOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* prevents bad race with accept() */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_SYNQE
argument_list|)
argument_list|,
operator|(
literal|"%s: %p not a synq_entry?"
operator|,
name|__func__
operator|,
name|arg
operator|)
argument_list|)
expr_stmt|;
name|offload_socket
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|make_established
argument_list|(
name|toep
argument_list|,
name|cpl
operator|->
name|snd_isn
argument_list|,
name|cpl
operator|->
name|rcv_isn
argument_list|,
name|cpl
operator|->
name|tcp_opt
argument_list|)
expr_stmt|;
name|toepcb_set_flag
argument_list|(
name|toep
argument_list|,
name|TPF_CPL_PENDING
argument_list|)
expr_stmt|;
name|update_tid
argument_list|(
name|sc
argument_list|,
name|synqe
operator|->
name|tid
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|save_qids_in_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|uint32_t
name|txqid
decl_stmt|,
name|rxqid
decl_stmt|;
name|txqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|pi
operator|->
name|nofldtxq
operator|)
operator|+
name|pi
operator|->
name|first_ofld_txq
expr_stmt|;
name|rxqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|pi
operator|->
name|nofldrxq
operator|)
operator|+
name|pi
operator|->
name|first_ofld_rxq
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
operator|(
name|txqid
operator|<<
literal|16
operator|)
operator||
operator|(
name|rxqid
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|get_qids_from_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|txqid
parameter_list|,
name|int
modifier|*
name|rxqid
parameter_list|)
block|{
if|if
condition|(
name|txqid
condition|)
operator|*
name|txqid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|rxqid
condition|)
operator|*
name|rxqid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|&
literal|0xffff
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use the trailing space in the mbuf in which the PASS_ACCEPT_REQ arrived to  * store some state temporarily.  */
end_comment

begin_function
specifier|static
name|struct
name|synq_entry
modifier|*
name|mbuf_to_synqe
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|len
init|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|synq_entry
argument_list|)
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|int
name|tspace
init|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tspace
operator|<
name|len
condition|)
block|{
name|synqe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|synqe
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
name|synqe
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|m
operator|->
name|m_len
operator|+
name|tspace
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|synqe
argument_list|)
operator|)
expr_stmt|;
name|synqe
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|synqe_set_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_SYNQE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tspace
operator|<
name|len
condition|)
name|synqe_set_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_SYNQE_NEEDFREE
argument_list|)
expr_stmt|;
return|return
operator|(
name|synqe
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4opt_to_tcpopt
parameter_list|(
specifier|const
name|struct
name|tcp_options
modifier|*
name|t4opt
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|)
block|{
name|bzero
argument_list|(
name|to
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4opt
operator|->
name|mss
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_MSS
expr_stmt|;
name|to
operator|->
name|to_mss
operator|=
name|be16toh
argument_list|(
name|t4opt
operator|->
name|mss
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t4opt
operator|->
name|wsf
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_SCALE
expr_stmt|;
name|to
operator|->
name|to_wscale
operator|=
name|t4opt
operator|->
name|wsf
expr_stmt|;
block|}
if|if
condition|(
name|t4opt
operator|->
name|tstamp
condition|)
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
if|if
condition|(
name|t4opt
operator|->
name|sack
condition|)
name|to
operator|->
name|to_flags
operator||=
name|TOF_SACKPERM
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Options2 for passive open.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|calc_opt2p
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|rxqid
parameter_list|,
specifier|const
name|struct
name|tcp_options
modifier|*
name|tcpopt
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|uint32_t
name|opt2
init|=
literal|0
decl_stmt|;
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|rxqid
index|]
decl_stmt|;
if|if
condition|(
name|V_tcp_do_rfc1323
condition|)
block|{
if|if
condition|(
name|tcpopt
operator|->
name|tstamp
condition|)
name|opt2
operator||=
name|F_TSTAMPS_EN
expr_stmt|;
if|if
condition|(
name|tcpopt
operator|->
name|sack
condition|)
name|opt2
operator||=
name|F_SACK_EN
expr_stmt|;
if|if
condition|(
name|tcpopt
operator|->
name|wsf
operator|>
literal|0
condition|)
name|opt2
operator||=
name|F_WND_SCALE_EN
expr_stmt|;
block|}
if|if
condition|(
name|V_tcp_do_ecn
operator|&&
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_ECE
operator||
name|TH_CWR
operator|)
condition|)
name|opt2
operator||=
name|F_CCTRL_ECN
expr_stmt|;
name|opt2
operator||=
name|V_TX_QUEUE
argument_list|(
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_modq
index|[
name|pi
operator|->
name|tx_chan
index|]
argument_list|)
expr_stmt|;
name|opt2
operator||=
name|F_RX_COALESCE_VALID
operator||
name|V_RX_COALESCE
argument_list|(
name|M_RX_COALESCE
argument_list|)
expr_stmt|;
name|opt2
operator||=
name|F_RSS_QUEUE_VALID
operator||
name|V_RSS_QUEUE
argument_list|(
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
return|return
name|htobe32
argument_list|(
name|opt2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* XXX: duplication. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|tcp_fields_to_host
parameter_list|(
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|th
operator|->
name|th_seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_win
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_urp
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_urp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pass_accept_req_to_protohdrs
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_pass_accept_req
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|unsigned
name|int
name|hlen
init|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|hdr_len
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|eh
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
name|ip
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|eh
operator|+
name|G_ETH_HDR_LEN
argument_list|(
name|hlen
argument_list|)
operator|)
expr_stmt|;
name|tcp
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ip
operator|+
name|G_IP_HDR_LEN
argument_list|(
name|hlen
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|inc
condition|)
block|{
name|bzero
argument_list|(
name|inc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|->
name|inc_faddr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|inc
operator|->
name|inc_laddr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|inc
operator|->
name|inc_fport
operator|=
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|inc
operator|->
name|inc_lport
operator|=
name|tcp
operator|->
name|th_dport
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|==
literal|6
condition|)
name|inc
operator|->
name|inc_flags
operator||=
name|INC_ISIPV6
expr_stmt|;
block|}
if|if
condition|(
name|th
condition|)
block|{
name|bcopy
argument_list|(
name|tcp
argument_list|,
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_fields_to_host
argument_list|(
name|th
argument_list|)
expr_stmt|;
comment|/* just like tcp_input */
block|}
block|}
end_function

begin_define
define|#
directive|define
name|REJECT_PASS_ACCEPT
parameter_list|()
value|do { \ 	reject_reason = __LINE__; \ 	goto reject; \ } while (0)
end_define

begin_comment
comment|/*  * The context associated with a tid entry via insert_tid could be a synq_entry  * or a toepcb.  The only way CPL handlers can tell is via a bit in these flags.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|toepcb
argument_list|,
name|flags
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|synq_entry
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Incoming SYN on a listening socket.  *  * XXX: Every use of ifp in this routine has a bad race with up/down, toe/-toe,  * etc.  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_accept_req
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
decl_stmt|;
specifier|const
name|struct
name|cpl_pass_accept_req
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
decl_stmt|;
name|struct
name|cpl_pass_accept_rpl
modifier|*
name|rpl
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|tos_stid
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
name|sc
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|ifp_vlan
init|=
name|NULL
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr_in
name|nam
decl_stmt|;
name|int
name|rscale
decl_stmt|,
name|mtu_idx
decl_stmt|,
name|rx_credits
decl_stmt|,
name|rxqid
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|NULL
decl_stmt|;
name|int
name|reject_reason
decl_stmt|;
name|uint16_t
name|vid
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_PASS_ACCEPT_REQ
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|pass_accept_req_to_protohdrs
argument_list|(
name|m
argument_list|,
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
name|t4opt_to_tcpopt
argument_list|(
operator|&
name|cpl
operator|->
name|tcpopt
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|G_SYN_INTF
argument_list|(
name|be16toh
argument_list|(
name|cpl
operator|->
name|l2info
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|ifp
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|tod
operator|=
name|TOEDEV
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Don't offload if the interface that received the SYN doesn't have 	 * IFCAP_TOE enabled. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE4
operator|)
operator|==
literal|0
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* Don't offload IPv6 connections. XXX: add IPv6 support */
if|if
condition|(
name|inc
operator|.
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* 	 * Don't offload if the SYN had a VLAN tag and the vid doesn't match 	 * anything on this interface. 	 */
name|vid
operator|=
name|EVL_VLANOFTAG
argument_list|(
name|be16toh
argument_list|(
name|cpl
operator|->
name|vlan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vid
operator|!=
literal|0xfff
condition|)
block|{
name|ifp_vlan
operator|=
name|VLAN_DEVAT
argument_list|(
name|ifp
argument_list|,
name|vid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp_vlan
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Don't offload if the peer requested a TCP option that's not known to 	 * the silicon. 	 */
if|if
condition|(
name|cpl
operator|->
name|tcpopt
operator|.
name|unknown
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* 	 * Don't offload if the outgoing interface for the route back to the 	 * peer is not the same as the interface that received the SYN. 	 * XXX: too restrictive. 	 */
name|nam
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|nam
argument_list|)
expr_stmt|;
name|nam
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nam
operator|.
name|sin_addr
operator|=
name|inc
operator|.
name|inc_faddr
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nam
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
else|else
block|{
name|struct
name|sockaddr
modifier|*
name|nexthop
decl_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|nexthop
operator|=
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|?
name|rt
operator|->
name|rt_gateway
else|:
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nam
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|==
name|ifp
operator|||
operator|(
name|ifp_vlan
operator|!=
name|NULL
operator|&&
name|rt
operator|->
name|rt_ifp
operator|==
name|ifp_vlan
operator|)
condition|)
name|e
operator|=
name|t4_l2t_get
argument_list|(
name|pi
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|,
name|nexthop
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* no l2te, or ifp mismatch */
block|}
name|synqe
operator|=
name|mbuf_to_synqe
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rpl
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|rpl
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* for 4-tuple check, syncache_add */
comment|/* Don't offload if the 4-tuple is already in use */
if|if
condition|(
name|toe_4tuple_check
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|,
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|inp
operator|=
name|lctx
operator|->
name|inp
expr_stmt|;
comment|/* listening socket, not owned by TOE */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Don't offload if the listening socket has closed */
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* 		 * The listening socket has closed.  The reply from the TOE to 		 * our CPL_CLOSE_LISTSRV_REQ will ultimately release all 		 * resources tied to this listen context. 		 */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|mtu_idx
operator|=
name|find_best_mtu_idx
argument_list|(
name|sc
argument_list|,
operator|&
name|inc
argument_list|,
name|be16toh
argument_list|(
name|cpl
operator|->
name|tcpopt
operator|.
name|mss
argument_list|)
argument_list|)
expr_stmt|;
name|rscale
operator|=
name|cpl
operator|->
name|tcpopt
operator|.
name|wsf
operator|&&
name|V_tcp_do_rfc1323
condition|?
name|select_rcv_wscale
argument_list|()
else|:
literal|0
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* opt0 rcv_bufsiz initially, assumes its normal meaning later */
name|rx_credits
operator|=
name|min
argument_list|(
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
operator|>>
literal|10
argument_list|,
name|M_RCV_BUFSIZ
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|save_qids_in_mbuf
argument_list|(
name|m
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
operator|&
name|rxqid
argument_list|)
expr_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|rpl
argument_list|,
name|CPL_PASS_ACCEPT_RPL
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt0
operator|=
name|calc_opt0
argument_list|(
name|so
argument_list|,
name|pi
argument_list|,
name|e
argument_list|,
name|mtu_idx
argument_list|,
name|rscale
argument_list|,
name|rx_credits
argument_list|,
name|ULP_MODE_NONE
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt2
operator|=
name|calc_opt2p
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|rxqid
argument_list|,
operator|&
name|cpl
operator|->
name|tcpopt
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|synqe
operator|->
name|lctx
operator|=
name|lctx
expr_stmt|;
name|synqe
operator|->
name|syn
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 so that it is held for the 					     duration of this function */
name|synqe
operator|->
name|l2e_idx
operator|=
name|e
operator|->
name|idx
expr_stmt|;
name|synqe
operator|->
name|rcv_bufsize
operator|=
name|rx_credits
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|synqe
operator|->
name|wr
argument_list|,
operator|(
name|uintptr_t
operator|)
name|wr
argument_list|)
expr_stmt|;
name|insert_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|hold_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* hold for the duration it's in the synq */
name|hold_lctx
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
comment|/* A synqe on the list has a ref on its lctx */
comment|/* 	 * If all goes well t4_syncache_respond will get called during 	 * syncache_add.  Also note that syncache_add releases both pcbinfo and 	 * pcb locks. 	 */
name|toe_syncache_add
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
name|inp
argument_list|,
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* ok to assert, we have a ref on the inp */
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* 	 * If we replied during syncache_add (synqe->wr has been consumed), 	 * good.  Otherwise, set it to 0 so that further syncache_respond 	 * attempts by the kernel will be ignored. 	 * 	 * The extra hold on the synqe makes sure that it is still around, even 	 * if the listener has been dropped and the synqe was aborted and the 	 * reply to the abort has removed and released the synqe from the synq 	 * list. 	 */
if|if
condition|(
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|synqe
operator|->
name|wr
argument_list|,
operator|(
name|uintptr_t
operator|)
name|wr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* listener closed.  synqe must have been aborted. */
name|KASSERT
argument_list|(
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
argument_list|,
operator|(
literal|"%s: listener %p closed but synqe %p not aborted"
operator|,
name|__func__
operator|,
name|inp
operator|,
name|synqe
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p, synqe %p, ABORTED"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* about to exit function */
return|return
operator|(
name|__LINE__
operator|)
return|;
block|}
comment|/* 		 * synqe aborted before TOM replied to PASS_ACCEPT_REQ.  But 		 * that can only happen if the listener was closed and we just 		 * checked for that. 		 */
name|KASSERT
argument_list|(
operator|!
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
argument_list|,
operator|(
literal|"%s: synqe %p aborted, but listener %p not dropped."
operator|,
name|__func__
operator|,
name|synqe
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
comment|/* Yank the synqe out of the lctx synq. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* removed from synq list */
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 		 * syncache may or may not have a hold on the synqe, which may 		 * or may not be stashed in the original SYN mbuf passed to us. 		 * Just copy it over instead of dealing with all possibilities. 		 */
name|m
operator|=
name|m_dup
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* about to exit function */
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* about to exit function */
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p, synqe %p, SYNACK"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|reject
label|:
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, REJECT (%d)"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|reject_reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|t4_l2t_release
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|lctx
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|ifp
operator|->
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|reject_reason
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|synqe_to_protohdrs
parameter_list|(
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|,
specifier|const
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|)
block|{
name|uint16_t
name|tcp_opt
init|=
name|be16toh
argument_list|(
name|cpl
operator|->
name|tcp_opt
argument_list|)
decl_stmt|;
comment|/* start off with the original SYN */
name|pass_accept_req_to_protohdrs
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
name|inc
argument_list|,
name|th
argument_list|)
expr_stmt|;
comment|/* modify parts to make it look like the ACK to our SYN|ACK */
name|th
operator|->
name|th_flags
operator|=
name|TH_ACK
expr_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|synqe
operator|->
name|iss
operator|+
literal|1
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|rcv_isn
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|to
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_TCPOPT_TSTAMP
argument_list|(
name|tcp_opt
argument_list|)
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
name|to
operator|->
name|to_tsecr
operator|=
name|synqe
operator|->
name|ts
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_pass_establish
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|const
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KTR
argument_list|)
operator|||
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
name|unsigned
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|be32toh
argument_list|(
name|cpl
operator|->
name|tos_stid
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|u_int
name|txqid
decl_stmt|,
name|rxqid
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|opcode
init|=
name|G_CPL_OPCODE
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|opcode
operator|==
name|CPL_PASS_ESTABLISH
argument_list|,
operator|(
literal|"%s: unexpected opcode 0x%x"
operator|,
name|__func__
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: wasn't expecting payload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|==
name|stid
argument_list|,
operator|(
literal|"%s: lctx stid mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_SYNQE
argument_list|)
argument_list|,
operator|(
literal|"%s: tid %u (ctx %p) not a synqe"
operator|,
name|__func__
operator|,
name|tid
operator|,
name|synqe
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* for syncache_expand */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: stid %u, tid %u, synqe %p (0x%x), inp_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* 		 * The listening socket has closed.  The TOM must have aborted 		 * all the embryonic connections (including this one) that were 		 * on the lctx's synq.  do_abort_rpl for the tid is responsible 		 * for cleaning up. 		 */
name|KASSERT
argument_list|(
name|synqe_flag
argument_list|(
name|synqe
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
argument_list|,
operator|(
literal|"%s: listen socket dropped but tid %u not aborted."
operator|,
name|__func__
operator|,
name|tid
operator|)
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ifp
operator|=
name|synqe
operator|->
name|syn
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|pi
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|KASSERT
argument_list|(
name|pi
operator|->
name|adapter
operator|==
name|sc
argument_list|,
operator|(
literal|"%s: pi %p, sc %p mismatch"
operator|,
name|__func__
operator|,
name|pi
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|get_qids_from_mbuf
argument_list|(
name|synqe
operator|->
name|syn
argument_list|,
operator|&
name|txqid
argument_list|,
operator|&
name|rxqid
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rxqid
operator|==
name|iq_to_ofld_rxq
argument_list|(
name|iq
argument_list|)
operator|-
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
literal|0
index|]
argument_list|,
operator|(
literal|"%s: CPL arrived on unexpected rxq.  %d %d"
operator|,
name|__func__
operator|,
name|rxqid
operator|,
call|(
name|int
call|)
argument_list|(
name|iq_to_ofld_rxq
argument_list|(
name|iq
argument_list|)
operator|-
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|=
name|alloc_toepcb
argument_list|(
name|pi
argument_list|,
name|txqid
argument_list|,
name|rxqid
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
block|{
name|reset
label|:
comment|/* The reply to this abort will perform final cleanup */
name|send_reset_synqe
argument_list|(
name|TOEDEV
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|toep
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|toep
operator|->
name|l2te
operator|=
operator|&
name|sc
operator|->
name|l2t
operator|->
name|l2tab
index|[
name|synqe
operator|->
name|l2e_idx
index|]
expr_stmt|;
name|toep
operator|->
name|ulp_mode
operator|=
name|ULP_MODE_NONE
expr_stmt|;
comment|/* opt0 rcv_bufsiz initially, assumes its normal meaning later */
name|toep
operator|->
name|rx_credits
operator|=
name|synqe
operator|->
name|rcv_bufsize
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: socket is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Come up with something that syncache_expand should be ok with. */
name|synqe_to_protohdrs
argument_list|(
name|synqe
argument_list|,
name|cpl
argument_list|,
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
comment|/* 	 * No more need for anything in the mbuf that carried the 	 * CPL_PASS_ACCEPT_REQ.  Drop the CPL_PASS_ESTABLISH and toep pointer 	 * there.  XXX: bad form but I don't want to increase the size of synqe. 	 */
name|m
operator|=
name|synqe
operator|->
name|syn
expr_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|toep
argument_list|)
operator|<=
name|m
operator|->
name|m_len
argument_list|,
operator|(
literal|"%s: no room in mbuf %p (m_len %d)"
operator|,
name|__func__
operator|,
name|m
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cpl
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|toepcb
operator|*
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_pass_establish
operator|*
argument_list|)
operator|+
literal|1
operator|)
operator|=
name|toep
expr_stmt|;
if|if
condition|(
operator|!
name|toe_syncache_expand
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|so
argument_list|)
operator|||
name|so
operator|==
name|NULL
condition|)
block|{
name|free_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
comment|/* Done with the synqe */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_init_listen_cpl_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_PASS_OPEN_RPL
argument_list|,
name|do_pass_open_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
name|do_close_server_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_PASS_ACCEPT_REQ
argument_list|,
name|do_pass_accept_req
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_PASS_ESTABLISH
argument_list|,
name|do_pass_establish
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

