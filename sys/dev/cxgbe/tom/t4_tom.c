begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom_l2t.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|ddp_protosw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ddp_usrreqs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|ddp6_protosw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ddp6_usrreqs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module ops */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_tom_mod_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_tom_mod_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_tom_modevent
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ULD ops and helpers */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_tom_activate
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_tom_deactivate
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|uld_info
name|tom_uld_info
init|=
block|{
operator|.
name|uld_id
operator|=
name|ULD_TOM
block|,
operator|.
name|activate
operator|=
name|t4_tom_activate
block|,
operator|.
name|deactivate
operator|=
name|t4_tom_deactivate
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|queue_tid_release
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_offload_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_tom_data
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|tom_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|toepcb
modifier|*
name|alloc_toepcb
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|txqid
parameter_list|,
name|int
name|rxqid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|int
name|tx_credits
decl_stmt|,
name|txsd_total
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * The firmware counts tx work request credits in units of 16 bytes 	 * each.  Reserve room for an ABORT_REQ so the driver never has to worry 	 * about tx credits if it wants to abort a connection. 	 */
name|tx_credits
operator|=
name|sc
operator|->
name|params
operator|.
name|ofldq_wr_cred
expr_stmt|;
name|tx_credits
operator|-=
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_abort_req
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* 	 * Shortest possible tx work request is a fw_ofld_tx_data_wr + 1 byte 	 * immediate payload, and firmware counts tx work request credits in 	 * units of 16 byte.  Calculate the maximum work requests possible. 	 */
name|txsd_total
operator|=
name|tx_credits
operator|/
name|howmany
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_ofld_tx_data_wr
argument_list|)
operator|+
literal|1
operator|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqid
operator|<
literal|0
condition|)
name|txqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|pi
operator|->
name|nofldtxq
operator|)
operator|+
name|pi
operator|->
name|first_ofld_txq
expr_stmt|;
name|KASSERT
argument_list|(
name|txqid
operator|>=
name|pi
operator|->
name|first_ofld_txq
operator|&&
name|txqid
operator|<
name|pi
operator|->
name|first_ofld_txq
operator|+
name|pi
operator|->
name|nofldtxq
argument_list|,
operator|(
literal|"%s: txqid %d for port %p (first %d, n %d)"
operator|,
name|__func__
operator|,
name|txqid
operator|,
name|pi
operator|,
name|pi
operator|->
name|first_ofld_txq
operator|,
name|pi
operator|->
name|nofldtxq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxqid
operator|<
literal|0
condition|)
name|rxqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|pi
operator|->
name|nofldrxq
operator|)
operator|+
name|pi
operator|->
name|first_ofld_rxq
expr_stmt|;
name|KASSERT
argument_list|(
name|rxqid
operator|>=
name|pi
operator|->
name|first_ofld_rxq
operator|&&
name|rxqid
operator|<
name|pi
operator|->
name|first_ofld_rxq
operator|+
name|pi
operator|->
name|nofldrxq
argument_list|,
operator|(
literal|"%s: rxqid %d for port %p (first %d, n %d)"
operator|,
name|__func__
operator|,
name|rxqid
operator|,
name|pi
operator|,
name|pi
operator|->
name|first_ofld_rxq
operator|,
name|pi
operator|->
name|nofldrxq
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|offsetof
argument_list|(
expr|struct
name|toepcb
argument_list|,
name|txsd
argument_list|)
operator|+
name|txsd_total
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ofld_tx_sdesc
argument_list|)
expr_stmt|;
name|toep
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|toep
operator|->
name|td
operator|=
name|sc
operator|->
name|tom_softc
expr_stmt|;
name|toep
operator|->
name|port
operator|=
name|pi
expr_stmt|;
name|toep
operator|->
name|tx_credits
operator|=
name|tx_credits
expr_stmt|;
name|toep
operator|->
name|ofld_txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
index|[
name|txqid
index|]
expr_stmt|;
name|toep
operator|->
name|ofld_rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|rxqid
index|]
expr_stmt|;
name|toep
operator|->
name|ctrlq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
expr_stmt|;
name|toep
operator|->
name|txsd_total
operator|=
name|txsd_total
expr_stmt|;
name|toep
operator|->
name|txsd_avail
operator|=
name|txsd_total
expr_stmt|;
name|toep
operator|->
name|txsd_pidx
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|txsd_cidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|toep
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_toepcb
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
operator|)
argument_list|,
operator|(
literal|"%s: attached to an inpcb"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
operator|)
argument_list|,
operator|(
literal|"%s: CPL pending"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|toep
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the socket for TCP offload.  */
end_comment

begin_function
name|void
name|offload_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|toep
operator|->
name|td
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Update socket */
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
name|so
operator|->
name|so_proto
operator|=
operator|&
name|ddp6_protosw
expr_stmt|;
else|else
name|so
operator|->
name|so_proto
operator|=
operator|&
name|ddp_protosw
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Update TCP PCB */
name|tp
operator|->
name|tod
operator|=
operator|&
name|td
operator|->
name|tod
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|toep
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_TOE
expr_stmt|;
comment|/* Install an extra hold on inp */
name|toep
operator|->
name|inp
operator|=
name|inp
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_ATTACHED
expr_stmt|;
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Add the TOE PCB to the active list */
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is _not_ the normal way to "unoffload" a socket. */
end_comment

begin_function
name|void
name|undo_offload_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|toep
operator|->
name|td
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tod
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_ATTACHED
expr_stmt|;
if|if
condition|(
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: inp freed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_offload_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|toep
operator|->
name|td
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|td_adapter
argument_list|(
name|td
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|toep
operator|->
name|tid
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
operator|)
argument_list|,
operator|(
literal|"%s: %p has CPL pending."
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
operator|)
argument_list|,
operator|(
literal|"%s: %p is still attached."
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: toep %p (tid %d, l2te %p)"
argument_list|,
name|__func__
argument_list|,
name|toep
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|release_ddp_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|l2te
condition|)
name|t4_l2t_release
argument_list|(
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|>=
literal|0
condition|)
block|{
name|remove_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|free_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The kernel is done with the TCP PCB and this is our opportunity to unhook the  * toepcb hanging off of it.  If the TOE driver is also done with the toepcb (no  * pending CPL) then it is time to release all resources tied to the toepcb.  *  * Also gets called when an offloaded active open fails and the TOM wants the  * kernel to take the TCP PCB back.  */
end_comment

begin_function
specifier|static
name|void
name|t4_pcb_detach
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|KTR
argument_list|)
operator|||
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
endif|#
directive|endif
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: toep is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
argument_list|,
operator|(
literal|"%s: not attached"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTR
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
condition|)
block|{
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %d, toep %p (0x%x), inp %p (0x%x)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"t4_pcb_detach: tid %d (%s), toep %p (0x%x), inp %p (0x%x)"
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_ATTACHED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
operator|)
condition|)
name|release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The TOE driver will not receive any more CPLs for the tid associated with the  * toepcb; release the hold on the inpcb.  */
end_comment

begin_function
name|void
name|final_cpl_received
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inp is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
argument_list|,
operator|(
literal|"%s: CPL not pending already?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d, toep %p (0x%x), inp %p (0x%x)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
name|toep
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_CPL_PENDING
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
operator|)
condition|)
name|release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|ctx
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|lookup_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
return|return
operator|(
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|update_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remove_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|NULL
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|release_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|ctrlq
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_tid_release
modifier|*
name|req
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|queue_tid_release
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* defer */
return|return;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|req
argument_list|,
name|CPL_TID_RELEASE
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|queue_tid_release
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|CXGBE_UNIMPLEMENTED
argument_list|(
literal|"deferred tid release"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * What mtu_idx to use, given a 4-tuple and/or an MSS cap  */
end_comment

begin_function
name|int
name|find_best_mtu_idx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|int
name|pmss
parameter_list|)
block|{
name|unsigned
name|short
modifier|*
name|mtus
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|mtus
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mss
decl_stmt|,
name|n
decl_stmt|;
name|KASSERT
argument_list|(
name|inc
operator|!=
name|NULL
operator|||
name|pmss
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: at least one of inc/pmss must be specified"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mss
operator|=
name|inc
condition|?
name|tcp_mssopt
argument_list|(
name|inc
argument_list|)
else|:
name|pmss
expr_stmt|;
if|if
condition|(
name|pmss
operator|>
literal|0
operator|&&
name|mss
operator|>
name|pmss
condition|)
name|mss
operator|=
name|pmss
expr_stmt|;
if|if
condition|(
name|inc
operator|->
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
operator|-
literal|1
operator|&&
name|mtus
index|[
name|i
operator|+
literal|1
index|]
operator|<=
name|mss
operator|+
name|n
condition|;
name|i
operator|++
control|)
continue|continue;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the receive window size for a socket.  */
end_comment

begin_function
name|u_long
name|select_rcv_wnd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|unsigned
name|long
name|wnd
decl_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|wnd
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnd
operator|<
name|MIN_RCV_WND
condition|)
name|wnd
operator|=
name|MIN_RCV_WND
expr_stmt|;
return|return
name|min
argument_list|(
name|wnd
argument_list|,
name|MAX_RCV_WND
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|select_rcv_wscale
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|wscale
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|space
init|=
name|sb_max
decl_stmt|;
if|if
condition|(
name|space
operator|>
name|MAX_RCV_WND
condition|)
name|space
operator|=
name|MAX_RCV_WND
expr_stmt|;
while|while
condition|(
name|wscale
operator|<
name|TCP_MAX_WINSHIFT
operator|&&
operator|(
name|TCP_MAXWIN
operator|<<
name|wscale
operator|)
operator|<
name|space
condition|)
name|wscale
operator|++
expr_stmt|;
return|return
operator|(
name|wscale
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|always_keepalive
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VIID_SMACIDX
parameter_list|(
name|v
parameter_list|)
value|(((unsigned int)(v)& 0x7f)<< 1)
end_define

begin_comment
comment|/*  * socket so could be a listening socket too.  */
end_comment

begin_function
name|uint64_t
name|calc_opt0
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|,
name|int
name|mtu_idx
parameter_list|,
name|int
name|rscale
parameter_list|,
name|int
name|rx_credits
parameter_list|,
name|int
name|ulp_mode
parameter_list|)
block|{
name|uint64_t
name|opt0
decl_stmt|;
name|KASSERT
argument_list|(
name|rx_credits
operator|<=
name|M_RCV_BUFSIZ
argument_list|,
operator|(
literal|"%s: rcv_bufsiz too high"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|opt0
operator|=
name|F_TCAM_BYPASS
operator||
name|V_WND_SCALE
argument_list|(
name|rscale
argument_list|)
operator||
name|V_MSS_IDX
argument_list|(
name|mtu_idx
argument_list|)
operator||
name|V_ULP_MODE
argument_list|(
name|ulp_mode
argument_list|)
operator||
name|V_RCV_BUFSIZ
argument_list|(
name|rx_credits
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|int
name|keepalive
init|=
name|always_keepalive
operator|||
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_KEEPALIVE
decl_stmt|;
name|opt0
operator||=
name|V_NAGLE
argument_list|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NODELAY
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|opt0
operator||=
name|V_KEEP_ALIVE
argument_list|(
name|keepalive
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|opt0
operator||=
name|V_L2T_IDX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
condition|)
block|{
name|opt0
operator||=
name|V_SMAC_SEL
argument_list|(
name|VIID_SMACIDX
argument_list|(
name|pi
operator|->
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|opt0
operator||=
name|V_TX_CHAN
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
block|}
return|return
name|htobe64
argument_list|(
name|opt0
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FILTER_SEL_WIDTH_P_FC
value|(3 + 1)
end_define

begin_define
define|#
directive|define
name|FILTER_SEL_WIDTH_VIN_P_FC
value|(6 + 7 + FILTER_SEL_WIDTH_P_FC)
end_define

begin_define
define|#
directive|define
name|FILTER_SEL_WIDTH_TAG_P_FC
value|(3 + FILTER_SEL_WIDTH_VIN_P_FC)
end_define

begin_define
define|#
directive|define
name|FILTER_SEL_WIDTH_VLD_TAG_P_FC
value|(1 + FILTER_SEL_WIDTH_TAG_P_FC)
end_define

begin_define
define|#
directive|define
name|VLAN_NONE
value|0xfff
end_define

begin_define
define|#
directive|define
name|FILTER_SEL_VLAN_NONE
value|0xffff
end_define

begin_function
name|uint32_t
name|select_ntuple
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|,
name|uint32_t
name|filter_mode
parameter_list|)
block|{
name|uint16_t
name|viid
init|=
name|pi
operator|->
name|viid
decl_stmt|;
name|uint32_t
name|ntuple
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|filter_mode
operator|==
name|HW_TPL_FR_MT_PR_IV_P_FC
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|vlan
operator|==
name|VLAN_NONE
condition|)
name|ntuple
operator||=
name|FILTER_SEL_VLAN_NONE
operator|<<
name|FILTER_SEL_WIDTH_P_FC
expr_stmt|;
else|else
block|{
name|ntuple
operator||=
name|e
operator|->
name|vlan
operator|<<
name|FILTER_SEL_WIDTH_P_FC
expr_stmt|;
name|ntuple
operator||=
literal|1
operator|<<
name|FILTER_SEL_WIDTH_VLD_TAG_P_FC
expr_stmt|;
block|}
name|ntuple
operator||=
name|e
operator|->
name|lport
operator|<<
name|S_PORT
expr_stmt|;
name|ntuple
operator||=
name|IPPROTO_TCP
operator|<<
name|FILTER_SEL_WIDTH_VLD_TAG_P_FC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filter_mode
operator|==
name|HW_TPL_FR_MT_PR_OV_P_FC
condition|)
block|{
name|ntuple
operator||=
name|G_FW_VIID_VIN
argument_list|(
name|viid
argument_list|)
operator|<<
name|FILTER_SEL_WIDTH_P_FC
expr_stmt|;
name|ntuple
operator||=
name|G_FW_VIID_PFN
argument_list|(
name|viid
argument_list|)
operator|<<
name|FILTER_SEL_WIDTH_VIN_P_FC
expr_stmt|;
name|ntuple
operator||=
name|G_FW_VIID_VIVLD
argument_list|(
name|viid
argument_list|)
operator|<<
name|FILTER_SEL_WIDTH_TAG_P_FC
expr_stmt|;
name|ntuple
operator||=
name|e
operator|->
name|lport
operator|<<
name|S_PORT
expr_stmt|;
name|ntuple
operator||=
name|IPPROTO_TCP
operator|<<
name|FILTER_SEL_WIDTH_VLD_TAG_P_FC
expr_stmt|;
block|}
return|return
operator|(
name|htobe32
argument_list|(
name|ntuple
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|set_tcpddp_ulp_mode
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|toep
operator|->
name|ulp_mode
operator|=
name|ULP_MODE_TCPDDP
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator|=
name|DDP_OK
expr_stmt|;
name|toep
operator|->
name|ddp_score
operator|=
name|DDP_LOW_SCORE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|t
operator|->
name|ntids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|tid_tab
argument_list|)
operator|+
name|t
operator|->
name|natids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|atid_tab
argument_list|)
operator|+
name|t
operator|->
name|nstids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|stid_tab
argument_list|)
expr_stmt|;
name|t
operator|->
name|tid_tab
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tid_tab
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|,
literal|"atid lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|t
operator|->
name|atid_tab
operator|=
operator|(
expr|union
name|aopen_entry
operator|*
operator|)
operator|&
name|t
operator|->
name|tid_tab
index|[
name|t
operator|->
name|ntids
index|]
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|t
operator|->
name|atid_tab
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|t
operator|->
name|natids
condition|;
name|i
operator|++
control|)
name|t
operator|->
name|atid_tab
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|t
operator|->
name|atid_tab
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|atid_tab
index|[
name|t
operator|->
name|natids
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|,
literal|"stid lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|t
operator|->
name|stid_tab
operator|=
operator|(
expr|struct
name|listen_ctx
operator|*
operator|*
operator|)
operator|&
name|t
operator|->
name|atid_tab
index|[
name|t
operator|->
name|natids
index|]
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|t
operator|->
name|stids
argument_list|)
expr_stmt|;
name|t
operator|->
name|nstids_free_head
operator|=
name|t
operator|->
name|nstids
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|t
operator|->
name|tids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d tids still in use."
operator|,
name|__func__
operator|,
name|t
operator|->
name|tids_in_use
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|t
operator|->
name|atids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d atids still in use."
operator|,
name|__func__
operator|,
name|t
operator|->
name|atids_in_use
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|t
operator|->
name|stids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d tids still in use."
operator|,
name|__func__
operator|,
name|t
operator|->
name|stids_in_use
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|tid_tab
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|t
operator|->
name|tid_tab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_tom_data
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|tom_data
modifier|*
name|td
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|)
argument_list|,
operator|(
literal|"%s: TOE PCB list is not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|lctx_count
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: lctx hash table is not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|t4_uninit_l2t_cpl_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_uninit_cpl_io_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_uninit_ddp
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|listen_mask
operator|!=
literal|0
condition|)
name|hashdestroy
argument_list|(
name|td
operator|->
name|listen_hash
argument_list|,
name|M_CXGBE
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|free_tid_tabs
argument_list|(
operator|&
name|sc
operator|->
name|tids
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|td
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ground control to Major TOM  * Commencing countdown, engines on  */
end_comment

begin_function
specifier|static
name|int
name|t4_tom_activate
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* per-adapter softc for TOM */
name|td
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* List of TOE PCBs and associated lock */
name|mtx_init
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|,
literal|"PCB list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|)
expr_stmt|;
comment|/* Listen context */
name|mtx_init
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|,
literal|"lctx hash lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|td
operator|->
name|listen_hash
operator|=
name|hashinit_flags
argument_list|(
name|LISTEN_HASH_SIZE
argument_list|,
name|M_CXGBE
argument_list|,
operator|&
name|td
operator|->
name|listen_mask
argument_list|,
name|HASH_NOWAIT
argument_list|)
expr_stmt|;
comment|/* TID tables */
name|rc
operator|=
name|alloc_tid_tabs
argument_list|(
operator|&
name|sc
operator|->
name|tids
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|t4_init_ddp
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* CPL handlers */
name|t4_init_connect_cpl_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_init_l2t_cpl_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_init_listen_cpl_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_init_cpl_io_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* toedev ops */
name|tod
operator|=
operator|&
name|td
operator|->
name|tod
expr_stmt|;
name|init_toedev
argument_list|(
name|tod
argument_list|)
expr_stmt|;
name|tod
operator|->
name|tod_softc
operator|=
name|sc
expr_stmt|;
name|tod
operator|->
name|tod_connect
operator|=
name|t4_connect
expr_stmt|;
name|tod
operator|->
name|tod_listen_start
operator|=
name|t4_listen_start
expr_stmt|;
name|tod
operator|->
name|tod_listen_stop
operator|=
name|t4_listen_stop
expr_stmt|;
name|tod
operator|->
name|tod_rcvd
operator|=
name|t4_rcvd
expr_stmt|;
name|tod
operator|->
name|tod_output
operator|=
name|t4_tod_output
expr_stmt|;
name|tod
operator|->
name|tod_send_rst
operator|=
name|t4_send_rst
expr_stmt|;
name|tod
operator|->
name|tod_send_fin
operator|=
name|t4_send_fin
expr_stmt|;
name|tod
operator|->
name|tod_pcb_detach
operator|=
name|t4_pcb_detach
expr_stmt|;
name|tod
operator|->
name|tod_l2_update
operator|=
name|t4_l2_update
expr_stmt|;
name|tod
operator|->
name|tod_syncache_added
operator|=
name|t4_syncache_added
expr_stmt|;
name|tod
operator|->
name|tod_syncache_removed
operator|=
name|t4_syncache_removed
expr_stmt|;
name|tod
operator|->
name|tod_syncache_respond
operator|=
name|t4_syncache_respond
expr_stmt|;
name|tod
operator|->
name|tod_offload_socket
operator|=
name|t4_offload_socket
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
name|TOEDEV
argument_list|(
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|->
name|ifp
argument_list|)
operator|=
operator|&
name|td
operator|->
name|tod
expr_stmt|;
name|sc
operator|->
name|tom_softc
operator|=
name|td
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|TOM_INIT_DONE
expr_stmt|;
name|register_toedev
argument_list|(
name|sc
operator|->
name|tom_softc
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|free_tom_data
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_tom_deactivate
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX. KASSERT? */
if|if
condition|(
name|sc
operator|->
name|offload_map
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* at least one port has IFCAP_TOE enabled */
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|)
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|lctx_count
operator|>
literal|0
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|unregister_toedev
argument_list|(
name|sc
operator|->
name|tom_softc
argument_list|)
expr_stmt|;
name|free_tom_data
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tom_softc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|TOM_INIT_DONE
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_tom_mod_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|protosw
modifier|*
name|tcp_protosw
decl_stmt|,
modifier|*
name|tcp6_protosw
decl_stmt|;
name|tcp_protosw
operator|=
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp_protosw
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
name|bcopy
argument_list|(
name|tcp_protosw
argument_list|,
operator|&
name|ddp_protosw
argument_list|,
sizeof|sizeof
argument_list|(
name|ddp_protosw
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tcp_protosw
operator|->
name|pr_usrreqs
argument_list|,
operator|&
name|ddp_usrreqs
argument_list|,
sizeof|sizeof
argument_list|(
name|ddp_usrreqs
argument_list|)
argument_list|)
expr_stmt|;
name|ddp_usrreqs
operator|.
name|pru_soreceive
operator|=
name|t4_soreceive_ddp
expr_stmt|;
name|ddp_protosw
operator|.
name|pr_usrreqs
operator|=
operator|&
name|ddp_usrreqs
expr_stmt|;
name|tcp6_protosw
operator|=
name|pffindproto
argument_list|(
name|PF_INET6
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp6_protosw
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
name|bcopy
argument_list|(
name|tcp6_protosw
argument_list|,
operator|&
name|ddp6_protosw
argument_list|,
sizeof|sizeof
argument_list|(
name|ddp6_protosw
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tcp6_protosw
operator|->
name|pr_usrreqs
argument_list|,
operator|&
name|ddp6_usrreqs
argument_list|,
sizeof|sizeof
argument_list|(
name|ddp6_usrreqs
argument_list|)
argument_list|)
expr_stmt|;
name|ddp6_usrreqs
operator|.
name|pru_soreceive
operator|=
name|t4_soreceive_ddp
expr_stmt|;
name|ddp6_protosw
operator|.
name|pr_usrreqs
operator|=
operator|&
name|ddp6_usrreqs
expr_stmt|;
name|rc
operator|=
name|t4_register_uld
argument_list|(
operator|&
name|tom_uld_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|t4_tom_mod_unload
argument_list|()
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tom_uninit
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|HOLD_LOCK
argument_list|,
literal|"t4tomun"
argument_list|)
condition|)
return|return;
comment|/* Try to free resources (works only if no port has IFCAP_TOE) */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
condition|)
name|t4_deactivate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_tom_mod_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_iterate
argument_list|(
name|tom_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_unregister_uld
argument_list|(
operator|&
name|tom_uld_info
argument_list|)
operator|==
name|EBUSY
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCP_OFFLOAD */
end_comment

begin_function
specifier|static
name|int
name|t4_tom_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|rc
operator|=
name|t4_tom_mod_load
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|rc
operator|=
name|t4_tom_mod_unload
argument_list|()
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"t4_tom: compiled without TCP_OFFLOAD support.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|t4_tom_moddata
init|=
block|{
literal|"t4_tom"
block|,
name|t4_tom_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t4_tom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t4_tom
argument_list|,
name|toecore
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t4_tom
argument_list|,
name|t4nex
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|t4_tom
argument_list|,
name|t4_tom_moddata
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

