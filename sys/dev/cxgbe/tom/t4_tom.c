begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ratelimit.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_tcb.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom_l2t.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|toe_protosw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|toe_usrreqs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|toe6_protosw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|toe6_usrreqs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module ops */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_tom_mod_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_tom_mod_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_tom_modevent
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ULD ops and helpers */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_tom_activate
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_tom_deactivate
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|uld_info
name|tom_uld_info
init|=
block|{
operator|.
name|uld_id
operator|=
name|ULD_TOM
block|,
operator|.
name|activate
operator|=
name|t4_tom_activate
block|,
operator|.
name|deactivate
operator|=
name|t4_tom_deactivate
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|queue_tid_release
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_offload_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_lip
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|in6_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|delete_lip
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|in6_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|clip_entry
modifier|*
name|search_lip
parameter_list|(
name|struct
name|tom_data
modifier|*
parameter_list|,
name|struct
name|in6_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_clip_table
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|tom_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_clip
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_clip_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_clip_table
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|tom_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_clip_table
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|tom_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_tom_data
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|tom_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reclaim_wr_resources
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|in6_ifaddr_gen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|ifaddr_evhandler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeout_task
name|clip_task
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|toepcb
modifier|*
name|alloc_toepcb
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|int
name|txqid
parameter_list|,
name|int
name|rxqid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|int
name|tx_credits
decl_stmt|,
name|txsd_total
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * The firmware counts tx work request credits in units of 16 bytes 	 * each.  Reserve room for an ABORT_REQ so the driver never has to worry 	 * about tx credits if it wants to abort a connection. 	 */
name|tx_credits
operator|=
name|sc
operator|->
name|params
operator|.
name|ofldq_wr_cred
expr_stmt|;
name|tx_credits
operator|-=
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_abort_req
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* 	 * Shortest possible tx work request is a fw_ofld_tx_data_wr + 1 byte 	 * immediate payload, and firmware counts tx work request credits in 	 * units of 16 byte.  Calculate the maximum work requests possible. 	 */
name|txsd_total
operator|=
name|tx_credits
operator|/
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_ofld_tx_data_wr
argument_list|)
operator|+
literal|1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqid
operator|<
literal|0
condition|)
name|txqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|vi
operator|->
name|nofldtxq
operator|)
operator|+
name|vi
operator|->
name|first_ofld_txq
expr_stmt|;
name|KASSERT
argument_list|(
name|txqid
operator|>=
name|vi
operator|->
name|first_ofld_txq
operator|&&
name|txqid
operator|<
name|vi
operator|->
name|first_ofld_txq
operator|+
name|vi
operator|->
name|nofldtxq
argument_list|,
operator|(
literal|"%s: txqid %d for vi %p (first %d, n %d)"
operator|,
name|__func__
operator|,
name|txqid
operator|,
name|vi
operator|,
name|vi
operator|->
name|first_ofld_txq
operator|,
name|vi
operator|->
name|nofldtxq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxqid
operator|<
literal|0
condition|)
name|rxqid
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
name|vi
operator|->
name|nofldrxq
operator|)
operator|+
name|vi
operator|->
name|first_ofld_rxq
expr_stmt|;
name|KASSERT
argument_list|(
name|rxqid
operator|>=
name|vi
operator|->
name|first_ofld_rxq
operator|&&
name|rxqid
operator|<
name|vi
operator|->
name|first_ofld_rxq
operator|+
name|vi
operator|->
name|nofldrxq
argument_list|,
operator|(
literal|"%s: rxqid %d for vi %p (first %d, n %d)"
operator|,
name|__func__
operator|,
name|rxqid
operator|,
name|vi
operator|,
name|vi
operator|->
name|first_ofld_rxq
operator|,
name|vi
operator|->
name|nofldrxq
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|offsetof
argument_list|(
expr|struct
name|toepcb
argument_list|,
name|txsd
argument_list|)
operator|+
name|txsd_total
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ofld_tx_sdesc
argument_list|)
expr_stmt|;
name|toep
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|refcount_init
argument_list|(
operator|&
name|toep
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|toep
operator|->
name|td
operator|=
name|sc
operator|->
name|tom_softc
expr_stmt|;
name|toep
operator|->
name|vi
operator|=
name|vi
expr_stmt|;
name|toep
operator|->
name|tc_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|toep
operator|->
name|tx_total
operator|=
name|tx_credits
expr_stmt|;
name|toep
operator|->
name|tx_credits
operator|=
name|tx_credits
expr_stmt|;
name|toep
operator|->
name|ofld_txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
index|[
name|txqid
index|]
expr_stmt|;
name|toep
operator|->
name|ofld_rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|rxqid
index|]
expr_stmt|;
name|toep
operator|->
name|ctrlq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pduq
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pdu_reclaimq
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|toep
operator|->
name|txsd_total
operator|=
name|txsd_total
expr_stmt|;
name|toep
operator|->
name|txsd_avail
operator|=
name|txsd_total
expr_stmt|;
name|toep
operator|->
name|txsd_pidx
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|txsd_cidx
operator|=
literal|0
expr_stmt|;
name|aiotx_init_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|ddp_init_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|toep
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|toepcb
modifier|*
name|hold_toepcb
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|toep
operator|->
name|refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|toep
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_toepcb
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|toep
operator|->
name|refcount
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
operator|)
argument_list|,
operator|(
literal|"%s: attached to an inpcb"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
operator|)
argument_list|,
operator|(
literal|"%s: CPL pending"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ddp_uninit_toep
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|toep
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the socket for TCP offload.  */
end_comment

begin_function
name|void
name|offload_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|toep
operator|->
name|td
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Update socket */
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
name|so
operator|->
name|so_proto
operator|=
operator|&
name|toe6_protosw
expr_stmt|;
else|else
name|so
operator|->
name|so_proto
operator|=
operator|&
name|toe_protosw
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Update TCP PCB */
name|tp
operator|->
name|tod
operator|=
operator|&
name|td
operator|->
name|tod
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|toep
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_TOE
expr_stmt|;
comment|/* Install an extra hold on inp */
name|toep
operator|->
name|inp
operator|=
name|inp
expr_stmt|;
name|toep
operator|->
name|flags
operator||=
name|TPF_ATTACHED
expr_stmt|;
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Add the TOE PCB to the active list */
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is _not_ the normal way to "unoffload" a socket. */
end_comment

begin_function
name|void
name|undo_offload_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|toep
operator|->
name|td
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tod
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_ATTACHED
expr_stmt|;
if|if
condition|(
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: inp freed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_offload_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|toep
operator|->
name|td
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|td_adapter
argument_list|(
name|td
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|toep
operator|->
name|tid
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
operator|)
argument_list|,
operator|(
literal|"%s: %p has CPL pending."
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
operator|)
argument_list|,
operator|(
literal|"%s: %p is still attached."
operator|,
name|__func__
operator|,
name|toep
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: toep %p (tid %d, l2te %p, ce %p)"
argument_list|,
name|__func__
argument_list|,
name|toep
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|l2te
argument_list|,
name|toep
operator|->
name|ce
argument_list|)
expr_stmt|;
comment|/* 	 * These queues should have been emptied at approximately the same time 	 * that a normal connection's socket's so_snd would have been purged or 	 * drained.  Do _not_ clean up here. 	 */
name|MPASS
argument_list|(
name|mbufq_len
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pduq
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|mbufq_len
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pdu_reclaimq
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|ddp_assert_empty
argument_list|(
name|toep
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|toep
operator|->
name|l2te
condition|)
name|t4_l2t_release
argument_list|(
name|toep
operator|->
name|l2te
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|>=
literal|0
condition|)
block|{
name|remove_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|ce
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|ce
condition|)
name|release_lip
argument_list|(
name|td
argument_list|,
name|toep
operator|->
name|ce
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RATELIMIT
if|if
condition|(
name|toep
operator|->
name|tc_idx
operator|!=
operator|-
literal|1
condition|)
name|t4_release_cl_rl_kbps
argument_list|(
name|sc
argument_list|,
name|toep
operator|->
name|vi
operator|->
name|pi
operator|->
name|port_id
argument_list|,
name|toep
operator|->
name|tc_idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|free_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The kernel is done with the TCP PCB and this is our opportunity to unhook the  * toepcb hanging off of it.  If the TOE driver is also done with the toepcb (no  * pending CPL) then it is time to release all resources tied to the toepcb.  *  * Also gets called when an offloaded active open fails and the TOM wants the  * kernel to take the TCP PCB back.  */
end_comment

begin_function
specifier|static
name|void
name|t4_pcb_detach
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|KTR
argument_list|)
operator|||
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
endif|#
directive|endif
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: toep is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
argument_list|,
operator|(
literal|"%s: not attached"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTR
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
condition|)
block|{
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %d, toep %p (0x%x), inp %p (0x%x)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"t4_pcb_detach: tid %d (%s), toep %p (0x%x), inp %p (0x%x)"
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_ATTACHED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
operator|)
condition|)
name|release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setsockopt handler.  */
end_comment

begin_function
specifier|static
name|void
name|t4_ctloutput
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|name
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|SOPT_GET
condition|)
return|return;
name|CTR4
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tp %p, dir %u, name %u"
argument_list|,
name|__func__
argument_list|,
name|tp
argument_list|,
name|dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|TCP_NODELAY
case|:
name|t4_set_tcb_field
argument_list|(
name|sc
argument_list|,
name|toep
operator|->
name|ctrlq
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|W_TCB_T_FLAGS
argument_list|,
name|V_TF_NAGLE
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_NAGLE
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NODELAY
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|toep
operator|->
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * The TOE driver will not receive any more CPLs for the tid associated with the  * toepcb; release the hold on the inpcb.  */
end_comment

begin_function
name|void
name|final_cpl_received
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|inp
decl_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inp is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|flags
operator|&
name|TPF_CPL_PENDING
argument_list|,
operator|(
literal|"%s: CPL not pending already?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: tid %d, toep %p (0x%x), inp %p (0x%x)"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|flags
argument_list|,
name|inp
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|release_ddp_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|toep
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
name|toep
operator|->
name|flags
operator|&=
operator|~
name|TPF_CPL_PENDING
expr_stmt|;
name|mbufq_drain
argument_list|(
operator|&
name|toep
operator|->
name|ulp_pdu_reclaimq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|flags
operator|&
name|TPF_ATTACHED
operator|)
condition|)
name|release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|ntids
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|ctx
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
name|ntids
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|lookup_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
return|return
operator|(
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|update_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remove_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|,
name|int
name|ntids
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|NULL
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
name|ntids
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|release_tid
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|ctrlq
parameter_list|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_tid_release
modifier|*
name|req
decl_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|ctrlq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|queue_tid_release
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* defer */
return|return;
block|}
name|req
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|INIT_TP_WR_MIT_CPL
argument_list|(
name|req
argument_list|,
name|CPL_TID_RELEASE
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|queue_tid_release
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|CXGBE_UNIMPLEMENTED
argument_list|(
literal|"deferred tid release"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * What mtu_idx to use, given a 4-tuple and/or an MSS cap  */
end_comment

begin_function
name|int
name|find_best_mtu_idx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|int
name|pmss
parameter_list|)
block|{
name|unsigned
name|short
modifier|*
name|mtus
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|mtus
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mss
decl_stmt|,
name|n
decl_stmt|;
name|KASSERT
argument_list|(
name|inc
operator|!=
name|NULL
operator|||
name|pmss
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: at least one of inc/pmss must be specified"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mss
operator|=
name|inc
condition|?
name|tcp_mssopt
argument_list|(
name|inc
argument_list|)
else|:
name|pmss
expr_stmt|;
if|if
condition|(
name|pmss
operator|>
literal|0
operator|&&
name|mss
operator|>
name|pmss
condition|)
name|mss
operator|=
name|pmss
expr_stmt|;
if|if
condition|(
name|inc
operator|->
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
operator|-
literal|1
operator|&&
name|mtus
index|[
name|i
operator|+
literal|1
index|]
operator|<=
name|mss
operator|+
name|n
condition|;
name|i
operator|++
control|)
continue|continue;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the receive window size for a socket.  */
end_comment

begin_function
name|u_long
name|select_rcv_wnd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|unsigned
name|long
name|wnd
decl_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|wnd
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnd
operator|<
name|MIN_RCV_WND
condition|)
name|wnd
operator|=
name|MIN_RCV_WND
expr_stmt|;
return|return
name|min
argument_list|(
name|wnd
argument_list|,
name|MAX_RCV_WND
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|select_rcv_wscale
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|wscale
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|space
init|=
name|sb_max
decl_stmt|;
if|if
condition|(
name|space
operator|>
name|MAX_RCV_WND
condition|)
name|space
operator|=
name|MAX_RCV_WND
expr_stmt|;
while|while
condition|(
name|wscale
operator|<
name|TCP_MAX_WINSHIFT
operator|&&
operator|(
name|TCP_MAXWIN
operator|<<
name|wscale
operator|)
operator|<
name|space
condition|)
name|wscale
operator|++
expr_stmt|;
return|return
operator|(
name|wscale
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|always_keepalive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * socket so could be a listening socket too.  */
end_comment

begin_function
name|uint64_t
name|calc_opt0
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|,
name|int
name|mtu_idx
parameter_list|,
name|int
name|rscale
parameter_list|,
name|int
name|rx_credits
parameter_list|,
name|int
name|ulp_mode
parameter_list|)
block|{
name|uint64_t
name|opt0
decl_stmt|;
name|KASSERT
argument_list|(
name|rx_credits
operator|<=
name|M_RCV_BUFSIZ
argument_list|,
operator|(
literal|"%s: rcv_bufsiz too high"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|opt0
operator|=
name|F_TCAM_BYPASS
operator||
name|V_WND_SCALE
argument_list|(
name|rscale
argument_list|)
operator||
name|V_MSS_IDX
argument_list|(
name|mtu_idx
argument_list|)
operator||
name|V_ULP_MODE
argument_list|(
name|ulp_mode
argument_list|)
operator||
name|V_RCV_BUFSIZ
argument_list|(
name|rx_credits
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|int
name|keepalive
init|=
name|always_keepalive
operator|||
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_KEEPALIVE
decl_stmt|;
name|opt0
operator||=
name|V_NAGLE
argument_list|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NODELAY
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|opt0
operator||=
name|V_KEEP_ALIVE
argument_list|(
name|keepalive
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|opt0
operator||=
name|V_L2T_IDX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|!=
name|NULL
condition|)
block|{
name|opt0
operator||=
name|V_SMAC_SEL
argument_list|(
name|vi
operator|->
name|smt_idx
argument_list|)
expr_stmt|;
name|opt0
operator||=
name|V_TX_CHAN
argument_list|(
name|vi
operator|->
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
block|}
return|return
name|htobe64
argument_list|(
name|opt0
argument_list|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|select_ntuple
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|tp_params
modifier|*
name|tp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|uint16_t
name|viid
init|=
name|vi
operator|->
name|viid
decl_stmt|;
name|uint64_t
name|ntuple
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initialize each of the fields which we care about which are present 	 * in the Compressed Filter Tuple. 	 */
if|if
condition|(
name|tp
operator|->
name|vlan_shift
operator|>=
literal|0
operator|&&
name|e
operator|->
name|vlan
operator|!=
name|CPL_L2T_VLAN_NONE
condition|)
name|ntuple
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|F_FT_VLAN_VLD
operator||
name|e
operator|->
name|vlan
argument_list|)
operator|<<
name|tp
operator|->
name|vlan_shift
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|port_shift
operator|>=
literal|0
condition|)
name|ntuple
operator||=
operator|(
name|uint64_t
operator|)
name|e
operator|->
name|lport
operator|<<
name|tp
operator|->
name|port_shift
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|protocol_shift
operator|>=
literal|0
condition|)
name|ntuple
operator||=
operator|(
name|uint64_t
operator|)
name|IPPROTO_TCP
operator|<<
name|tp
operator|->
name|protocol_shift
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|vnic_shift
operator|>=
literal|0
condition|)
block|{
name|uint32_t
name|vf
init|=
name|G_FW_VIID_VIN
argument_list|(
name|viid
argument_list|)
decl_stmt|;
name|uint32_t
name|pf
init|=
name|G_FW_VIID_PFN
argument_list|(
name|viid
argument_list|)
decl_stmt|;
name|uint32_t
name|vld
init|=
name|G_FW_VIID_VIVLD
argument_list|(
name|viid
argument_list|)
decl_stmt|;
name|ntuple
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|V_FT_VNID_ID_VF
argument_list|(
name|vf
argument_list|)
operator||
name|V_FT_VNID_ID_PF
argument_list|(
name|pf
argument_list|)
operator||
name|V_FT_VNID_ID_VLD
argument_list|(
name|vld
argument_list|)
argument_list|)
operator|<<
name|tp
operator|->
name|vnic_shift
expr_stmt|;
block|}
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|htobe32
argument_list|(
operator|(
name|uint32_t
operator|)
name|ntuple
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|htobe64
argument_list|(
name|V_FILTER_TUPLE
argument_list|(
name|ntuple
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|set_tcpddp_ulp_mode
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|toep
operator|->
name|ulp_mode
operator|=
name|ULP_MODE_TCPDDP
expr_stmt|;
name|toep
operator|->
name|ddp_flags
operator|=
name|DDP_OK
expr_stmt|;
block|}
end_function

begin_function
name|int
name|negative_advice
parameter_list|(
name|int
name|status
parameter_list|)
block|{
return|return
operator|(
name|status
operator|==
name|CPL_ERR_RTX_NEG_ADVICE
operator|||
name|status
operator|==
name|CPL_ERR_PERSIST_NEG_ADVICE
operator|||
name|status
operator|==
name|CPL_ERR_KEEPALV_NEG_ADVICE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|t
operator|->
name|ntids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|tid_tab
argument_list|)
operator|+
name|t
operator|->
name|natids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|atid_tab
argument_list|)
operator|+
name|t
operator|->
name|nstids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|stid_tab
argument_list|)
expr_stmt|;
name|t
operator|->
name|tid_tab
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tid_tab
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|,
literal|"atid lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|t
operator|->
name|atid_tab
operator|=
operator|(
expr|union
name|aopen_entry
operator|*
operator|)
operator|&
name|t
operator|->
name|tid_tab
index|[
name|t
operator|->
name|ntids
index|]
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|t
operator|->
name|atid_tab
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|t
operator|->
name|natids
condition|;
name|i
operator|++
control|)
name|t
operator|->
name|atid_tab
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|t
operator|->
name|atid_tab
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|atid_tab
index|[
name|t
operator|->
name|natids
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|,
literal|"stid lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|t
operator|->
name|stid_tab
operator|=
operator|(
expr|struct
name|listen_ctx
operator|*
operator|*
operator|)
operator|&
name|t
operator|->
name|atid_tab
index|[
name|t
operator|->
name|natids
index|]
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|t
operator|->
name|stids
argument_list|)
expr_stmt|;
name|t
operator|->
name|nstids_free_head
operator|=
name|t
operator|->
name|nstids
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|t
operator|->
name|tids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d tids still in use."
operator|,
name|__func__
operator|,
name|t
operator|->
name|tids_in_use
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|t
operator|->
name|atids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d atids still in use."
operator|,
name|__func__
operator|,
name|t
operator|->
name|atids_in_use
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|t
operator|->
name|stids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d tids still in use."
operator|,
name|__func__
operator|,
name|t
operator|->
name|stids_in_use
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|tid_tab
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|t
operator|->
name|tid_tab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_lip
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|lip
parameter_list|)
block|{
name|struct
name|fw_clip_cmd
name|c
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* mtx_assert(&td->clip_table_lock, MA_OWNED); */
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_write
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CLIP_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_CLIP_CMD_ALLOC
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|ip_hi
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|lip
operator|->
name|s6_addr
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|.
name|ip_lo
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|lip
operator|->
name|s6_addr
index|[
literal|8
index|]
expr_stmt|;
return|return
operator|(
operator|-
name|t4_wr_mbox_ns
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|delete_lip
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|lip
parameter_list|)
block|{
name|struct
name|fw_clip_cmd
name|c
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* mtx_assert(&td->clip_table_lock, MA_OWNED); */
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_write
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CLIP_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_CLIP_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|ip_hi
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|lip
operator|->
name|s6_addr
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|.
name|ip_lo
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|lip
operator|->
name|s6_addr
index|[
literal|8
index|]
expr_stmt|;
return|return
operator|(
operator|-
name|t4_wr_mbox_ns
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|clip_entry
modifier|*
name|search_lip
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|lip
parameter_list|)
block|{
name|struct
name|clip_entry
modifier|*
name|ce
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ce
argument_list|,
argument|&td->clip_table
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ce
operator|->
name|lip
argument_list|,
name|lip
argument_list|)
condition|)
return|return
operator|(
name|ce
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|clip_entry
modifier|*
name|hold_lip
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|lip
parameter_list|,
name|struct
name|clip_entry
modifier|*
name|ce
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
name|ce
operator|=
name|search_lip
argument_list|(
name|td
argument_list|,
name|lip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
name|NULL
condition|)
name|ce
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ce
operator|)
return|;
block|}
end_function

begin_function
name|void
name|release_lip
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|clip_entry
modifier|*
name|ce
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|search_lip
argument_list|(
name|td
argument_list|,
operator|&
name|ce
operator|->
name|lip
argument_list|)
operator|==
name|ce
argument_list|,
operator|(
literal|"%s: CLIP entry %p p not in CLIP table."
operator|,
name|__func__
operator|,
name|ce
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ce
operator|->
name|refcount
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: CLIP entry %p has refcount 0"
operator|,
name|__func__
operator|,
name|ce
operator|)
argument_list|)
expr_stmt|;
operator|--
name|ce
operator|->
name|refcount
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_clip_table
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|tom_data
modifier|*
name|td
parameter_list|)
block|{
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|,
literal|"CLIP table lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|td
operator|->
name|clip_table
argument_list|)
expr_stmt|;
name|td
operator|->
name|clip_gen
operator|=
operator|-
literal|1
expr_stmt|;
name|update_clip_table
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_clip
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|HOLD_LOCK
argument_list|,
literal|"t4tomuc"
argument_list|)
condition|)
return|return;
if|if
condition|(
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
condition|)
name|update_clip_table
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tom_softc
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_clip_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|t4_iterate
argument_list|(
name|update_clip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_clip_table
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|tom_data
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|in6_ifa_tracker
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|lip
decl_stmt|,
name|tlip
decl_stmt|;
name|struct
name|clip_head
name|stale
decl_stmt|;
name|struct
name|clip_entry
modifier|*
name|ce
decl_stmt|,
modifier|*
name|ce_temp
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|gen
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uintptr_t
name|last_vnet
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IN6_IFADDR_RLOCK
argument_list|(
operator|&
name|in6_ifa_tracker
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
name|gen
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|in6_ifaddr_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|==
name|td
operator|->
name|clip_gen
condition|)
goto|goto
name|done
goto|;
name|TAILQ_INIT
argument_list|(
operator|&
name|stale
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|stale
argument_list|,
operator|&
name|td
operator|->
name|clip_table
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * last_vnet optimizes the common cases where all if_vnet = NULL (no 	 * VIMAGE) or all if_vnet = vnet0. 	 */
name|last_vnet
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
name|for_each_vi
argument_list|(
argument|sc->port[i]
argument_list|,
argument|j
argument_list|,
argument|vi
argument_list|)
block|{
if|if
condition|(
name|last_vnet
operator|==
operator|(
name|uintptr_t
operator|)
name|vi
operator|->
name|ifp
operator|->
name|if_vnet
condition|)
continue|continue;
comment|/* XXX: races with if_vmove */
name|CURVNET_SET
argument_list|(
name|vi
operator|->
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ia
argument_list|,
argument|&V_in6_ifaddrhead
argument_list|,
argument|ia_link
argument_list|)
block|{
name|lip
operator|=
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|sin6_addr
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|lip
argument_list|)
argument_list|,
operator|(
literal|"%s: mcast address in in6_ifaddr list"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
name|lip
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|IN6_IS_SCOPE_EMBED
argument_list|(
name|lip
argument_list|)
condition|)
block|{
comment|/* Remove the embedded scope */
name|tlip
operator|=
operator|*
name|lip
expr_stmt|;
name|lip
operator|=
operator|&
name|tlip
expr_stmt|;
name|in6_clearscope
argument_list|(
name|lip
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * XXX: how to weed out the link local address for the 			 * loopback interface?  It's fe80::1 usually (always?). 			 */
comment|/* 			 * If it's in the main list then we already know it's 			 * not stale. 			 */
name|TAILQ_FOREACH
argument_list|(
argument|ce
argument_list|,
argument|&td->clip_table
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ce
operator|->
name|lip
argument_list|,
name|lip
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
comment|/* 			 * If it's in the stale list we should move it to the 			 * main list. 			 */
name|TAILQ_FOREACH
argument_list|(
argument|ce
argument_list|,
argument|&stale
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ce
operator|->
name|lip
argument_list|,
name|lip
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stale
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|td
operator|->
name|clip_table
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
comment|/* A new IP6 address; add it to the CLIP table */
name|ce
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ce
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ce
operator|->
name|lip
argument_list|,
name|lip
argument_list|,
sizeof|sizeof
argument_list|(
name|ce
operator|->
name|lip
argument_list|)
argument_list|)
expr_stmt|;
name|ce
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|add_lip
argument_list|(
name|sc
argument_list|,
name|lip
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|td
operator|->
name|clip_table
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|ip
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ce
operator|->
name|lip
argument_list|,
operator|&
name|ip
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: could not add %s (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|ip
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
name|next
label|:
continue|continue;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|last_vnet
operator|=
operator|(
name|uintptr_t
operator|)
name|vi
operator|->
name|ifp
operator|->
name|if_vnet
expr_stmt|;
block|}
comment|/* 	 * Remove stale addresses (those no longer in V_in6_ifaddrhead) that are 	 * no longer referenced by the driver. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ce
argument_list|,
argument|&stale
argument_list|,
argument|link
argument_list|,
argument|ce_temp
argument_list|)
block|{
if|if
condition|(
name|ce
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|delete_lip
argument_list|(
name|sc
argument_list|,
operator|&
name|ce
operator|->
name|lip
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stale
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|ip
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ce
operator|->
name|lip
argument_list|,
operator|&
name|ip
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: could not delete %s (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|ip
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The ones that are still referenced need to stay in the CLIP table */
name|TAILQ_CONCAT
argument_list|(
operator|&
name|td
operator|->
name|clip_table
argument_list|,
operator|&
name|stale
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|td
operator|->
name|clip_gen
operator|=
name|gen
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
name|IN6_IFADDR_RUNLOCK
argument_list|(
operator|&
name|in6_ifa_tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_clip_table
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|tom_data
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|clip_entry
modifier|*
name|ce
decl_stmt|,
modifier|*
name|ce_temp
decl_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ce
argument_list|,
argument|&td->clip_table
argument_list|,
argument|link
argument_list|,
argument|ce_temp
argument_list|)
block|{
name|KASSERT
argument_list|(
name|ce
operator|->
name|refcount
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: CLIP entry %p still in use (%d)"
operator|,
name|__func__
operator|,
name|ce
operator|,
name|ce
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|td
operator|->
name|clip_table
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|delete_lip
argument_list|(
name|sc
argument_list|,
operator|&
name|ce
operator|->
name|lip
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|td
operator|->
name|clip_table_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_tom_data
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|tom_data
modifier|*
name|td
parameter_list|)
block|{
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|)
argument_list|,
operator|(
literal|"%s: TOE PCB list is not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|lctx_count
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: lctx hash table is not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|t4_free_ppod_region
argument_list|(
operator|&
name|td
operator|->
name|pr
argument_list|)
expr_stmt|;
name|destroy_clip_table
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|listen_mask
operator|!=
literal|0
condition|)
name|hashdestroy
argument_list|(
name|td
operator|->
name|listen_hash
argument_list|,
name|M_CXGBE
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|free_tid_tabs
argument_list|(
operator|&
name|sc
operator|->
name|tids
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|td
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reclaim_wr_resources
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|arg
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|wrqe
argument_list|)
name|twr_list
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|twr_list
argument_list|)
expr_stmt|;
name|struct
name|cpl_act_open_req
modifier|*
name|cpl
decl_stmt|;
name|u_int
name|opcode
decl_stmt|,
name|atid
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_lock
argument_list|)
expr_stmt|;
name|STAILQ_SWAP
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_list
argument_list|,
operator|&
name|twr_list
argument_list|,
name|wrqe
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|twr_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|twr_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cpl
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|GET_OPCODE
argument_list|(
name|cpl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CPL_ACT_OPEN_REQ
case|:
case|case
name|CPL_ACT_OPEN_REQ6
case|:
name|atid
operator|=
name|G_TID_TID
argument_list|(
name|be32toh
argument_list|(
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|td_adapter
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_CXGBE
argument_list|,
literal|"%s: atid %u "
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|act_open_failure_cleanup
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: leaked work request %p, wr_len %d, "
literal|"opcode %x\n"
argument_list|,
name|__func__
argument_list|,
name|wr
argument_list|,
name|wr
operator|->
name|wr_len
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
comment|/* WR not freed here; go look at it with a debugger.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Ground control to Major TOM  * Commencing countdown, engines on  */
end_comment

begin_function
specifier|static
name|int
name|t4_tom_activate
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
decl_stmt|,
name|v
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* per-adapter softc for TOM */
name|td
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* List of TOE PCBs and associated lock */
name|mtx_init
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|,
literal|"PCB list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|)
expr_stmt|;
comment|/* Listen context */
name|mtx_init
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|,
literal|"lctx hash lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|td
operator|->
name|listen_hash
operator|=
name|hashinit_flags
argument_list|(
name|LISTEN_HASH_SIZE
argument_list|,
name|M_CXGBE
argument_list|,
operator|&
name|td
operator|->
name|listen_mask
argument_list|,
name|HASH_NOWAIT
argument_list|)
expr_stmt|;
comment|/* List of WRs for which L2 resolution failed */
name|mtx_init
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_lock
argument_list|,
literal|"Unsent WR list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_list
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|td
operator|->
name|reclaim_wr_resources
argument_list|,
literal|0
argument_list|,
name|reclaim_wr_resources
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* TID tables */
name|rc
operator|=
name|alloc_tid_tabs
argument_list|(
operator|&
name|sc
operator|->
name|tids
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|rc
operator|=
name|t4_init_ppod_region
argument_list|(
operator|&
name|td
operator|->
name|pr
argument_list|,
operator|&
name|sc
operator|->
name|vres
operator|.
name|ddp
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_TDDP_PSZ
argument_list|)
argument_list|,
literal|"TDDP page pods"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_TDDP_TAGMASK
argument_list|,
name|V_TDDPTAGMASK
argument_list|(
name|M_TDDPTAGMASK
argument_list|)
argument_list|,
name|td
operator|->
name|pr
operator|.
name|pr_tag_mask
argument_list|)
expr_stmt|;
comment|/* CLIP table for IPv6 offload */
name|init_clip_table
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* toedev ops */
name|tod
operator|=
operator|&
name|td
operator|->
name|tod
expr_stmt|;
name|init_toedev
argument_list|(
name|tod
argument_list|)
expr_stmt|;
name|tod
operator|->
name|tod_softc
operator|=
name|sc
expr_stmt|;
name|tod
operator|->
name|tod_connect
operator|=
name|t4_connect
expr_stmt|;
name|tod
operator|->
name|tod_listen_start
operator|=
name|t4_listen_start
expr_stmt|;
name|tod
operator|->
name|tod_listen_stop
operator|=
name|t4_listen_stop
expr_stmt|;
name|tod
operator|->
name|tod_rcvd
operator|=
name|t4_rcvd
expr_stmt|;
name|tod
operator|->
name|tod_output
operator|=
name|t4_tod_output
expr_stmt|;
name|tod
operator|->
name|tod_send_rst
operator|=
name|t4_send_rst
expr_stmt|;
name|tod
operator|->
name|tod_send_fin
operator|=
name|t4_send_fin
expr_stmt|;
name|tod
operator|->
name|tod_pcb_detach
operator|=
name|t4_pcb_detach
expr_stmt|;
name|tod
operator|->
name|tod_l2_update
operator|=
name|t4_l2_update
expr_stmt|;
name|tod
operator|->
name|tod_syncache_added
operator|=
name|t4_syncache_added
expr_stmt|;
name|tod
operator|->
name|tod_syncache_removed
operator|=
name|t4_syncache_removed
expr_stmt|;
name|tod
operator|->
name|tod_syncache_respond
operator|=
name|t4_syncache_respond
expr_stmt|;
name|tod
operator|->
name|tod_offload_socket
operator|=
name|t4_offload_socket
expr_stmt|;
name|tod
operator|->
name|tod_ctloutput
operator|=
name|t4_ctloutput
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|for_each_vi
argument_list|(
argument|sc->port[i]
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
name|TOEDEV
argument_list|(
name|vi
operator|->
name|ifp
argument_list|)
operator|=
operator|&
name|td
operator|->
name|tod
expr_stmt|;
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|j
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|ofld_rxq
operator|->
name|iq
operator|.
name|set_tcb_rpl
operator|=
name|do_set_tcb_rpl
expr_stmt|;
name|ofld_rxq
operator|->
name|iq
operator|.
name|l2t_write_rpl
operator|=
name|do_l2t_write_rpl2
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|tom_softc
operator|=
name|td
expr_stmt|;
name|register_toedev
argument_list|(
name|sc
operator|->
name|tom_softc
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|free_tom_data
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_tom_deactivate
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX. KASSERT? */
if|if
condition|(
name|sc
operator|->
name|offload_map
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* at least one port has IFCAP_TOE enabled */
if|if
condition|(
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_IWARP
argument_list|)
operator|||
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_ISCSI
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* both iWARP and iSCSI rely on the TOE. */
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|)
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|lctx_count
operator|>
literal|0
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|td
operator|->
name|reclaim_wr_resources
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_list
argument_list|)
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|unsent_wr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|unregister_toedev
argument_list|(
name|sc
operator|->
name|tom_softc
argument_list|)
expr_stmt|;
name|free_tom_data
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tom_softc
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_tom_ifaddr_event
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|atomic_add_rel_int
argument_list|(
operator|&
name|in6_ifaddr_gen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|clip_task
argument_list|,
operator|-
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_aio_queue_tom
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|toep
operator|->
name|ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
block|{
name|error
operator|=
name|t4_aio_queue_ddp
argument_list|(
name|so
argument_list|,
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EOPNOTSUPP
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|t4_aio_queue_aiotx
argument_list|(
name|so
argument_list|,
name|job
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_tom_mod_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|protosw
modifier|*
name|tcp_protosw
decl_stmt|,
modifier|*
name|tcp6_protosw
decl_stmt|;
comment|/* CPL handlers */
name|t4_init_connect_cpl_handlers
argument_list|()
expr_stmt|;
name|t4_init_listen_cpl_handlers
argument_list|()
expr_stmt|;
name|t4_init_cpl_io_handlers
argument_list|()
expr_stmt|;
name|rc
operator|=
name|t4_ddp_mod_load
argument_list|()
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|tcp_protosw
operator|=
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp_protosw
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
name|bcopy
argument_list|(
name|tcp_protosw
argument_list|,
operator|&
name|toe_protosw
argument_list|,
sizeof|sizeof
argument_list|(
name|toe_protosw
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tcp_protosw
operator|->
name|pr_usrreqs
argument_list|,
operator|&
name|toe_usrreqs
argument_list|,
sizeof|sizeof
argument_list|(
name|toe_usrreqs
argument_list|)
argument_list|)
expr_stmt|;
name|toe_usrreqs
operator|.
name|pru_aio_queue
operator|=
name|t4_aio_queue_tom
expr_stmt|;
name|toe_protosw
operator|.
name|pr_usrreqs
operator|=
operator|&
name|toe_usrreqs
expr_stmt|;
name|tcp6_protosw
operator|=
name|pffindproto
argument_list|(
name|PF_INET6
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp6_protosw
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
name|bcopy
argument_list|(
name|tcp6_protosw
argument_list|,
operator|&
name|toe6_protosw
argument_list|,
sizeof|sizeof
argument_list|(
name|toe6_protosw
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tcp6_protosw
operator|->
name|pr_usrreqs
argument_list|,
operator|&
name|toe6_usrreqs
argument_list|,
sizeof|sizeof
argument_list|(
name|toe6_usrreqs
argument_list|)
argument_list|)
expr_stmt|;
name|toe6_usrreqs
operator|.
name|pru_aio_queue
operator|=
name|t4_aio_queue_tom
expr_stmt|;
name|toe6_protosw
operator|.
name|pr_usrreqs
operator|=
operator|&
name|toe6_usrreqs
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|clip_task
argument_list|,
literal|0
argument_list|,
name|t4_clip_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifaddr_evhandler
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifaddr_event
argument_list|,
name|t4_tom_ifaddr_event
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_register_uld
argument_list|(
operator|&
name|tom_uld_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|t4_tom_mod_unload
argument_list|()
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tom_uninit
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4tomun"
argument_list|)
condition|)
return|return;
comment|/* Try to free resources (works only if no port has IFCAP_TOE) */
if|if
condition|(
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
condition|)
name|t4_deactivate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_tom_mod_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_iterate
argument_list|(
name|tom_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_unregister_uld
argument_list|(
operator|&
name|tom_uld_info
argument_list|)
operator|==
name|EBUSY
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|ifaddr_evhandler
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifaddr_event
argument_list|,
name|ifaddr_evhandler
argument_list|)
expr_stmt|;
name|taskqueue_cancel_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|clip_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|t4_ddp_mod_unload
argument_list|()
expr_stmt|;
name|t4_uninit_connect_cpl_handlers
argument_list|()
expr_stmt|;
name|t4_uninit_listen_cpl_handlers
argument_list|()
expr_stmt|;
name|t4_uninit_cpl_io_handlers
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCP_OFFLOAD */
end_comment

begin_function
specifier|static
name|int
name|t4_tom_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|rc
operator|=
name|t4_tom_mod_load
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|rc
operator|=
name|t4_tom_mod_unload
argument_list|()
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"t4_tom: compiled without TCP_OFFLOAD support.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|t4_tom_moddata
init|=
block|{
literal|"t4_tom"
block|,
name|t4_tom_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t4_tom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t4_tom
argument_list|,
name|toecore
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t4_tom
argument_list|,
name|t4nex
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|t4_tom
argument_list|,
name|t4_tom_moddata
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

