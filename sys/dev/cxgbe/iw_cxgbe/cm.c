begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2013, 2016 Chelsio, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *	  copyright notice, this list of conditions and the following  *	  disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *	  copyright notice, this list of conditions and the following  *	  disclaimer in the documentation and/or other materials  *	  provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_struct_decl
struct_decl|struct
name|sge_iq
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rss_header
struct_decl|;
end_struct_decl

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|"offload.h"
end_include

begin_include
include|#
directive|include
file|"tom/t4_tom.h"
end_include

begin_define
define|#
directive|define
name|TOEPCB
parameter_list|(
name|so
parameter_list|)
value|((struct toepcb *)(so_sototcpcb((so))->t_toe))
end_define

begin_include
include|#
directive|include
file|"iw_cxgbe.h"
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/workqueue.h>
end_include

begin_include
include|#
directive|include
file|<linux/notifier.h>
end_include

begin_include
include|#
directive|include
file|<linux/inetdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_vlan.h>
end_include

begin_include
include|#
directive|include
file|<net/netevent.h>
end_include

begin_decl_stmt
specifier|static
name|spinlock_t
name|req_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|c4iw_ep_list
argument_list|,
argument|c4iw_ep_common
argument_list|)
name|req_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|work_struct
name|c4iw_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|workqueue_struct
modifier|*
name|c4iw_taskq
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|err_cqe_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|spinlock_t
name|err_cqe_lock
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|process_req
parameter_list|(
name|struct
name|work_struct
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_ep_timer
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stop_ep_timer
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_tcpinfo
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_timeout
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_err_cqes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|c4iw_ep_state
name|state_read
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__state_set
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|,
name|enum
name|c4iw_ep_state
name|tostate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|state_set
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|,
name|enum
name|c4iw_ep_state
name|tostate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|alloc_ep
parameter_list|(
name|int
name|size
parameter_list|,
name|gfp_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|rtentry
modifier|*
name|find_route
parameter_list|(
name|__be32
name|local_ip
parameter_list|,
name|__be32
name|peer_ip
parameter_list|,
name|__be16
name|local_port
parameter_list|,
name|__be16
name|peer_port
parameter_list|,
name|u8
name|tos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|send_mpa_req
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|send_mpa_reject
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|send_mpa_reply
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_complete_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|send_abort
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peer_close_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peer_abort_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_reply_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|connect_request_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|established_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_mpa_reply
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_mpa_request
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_peer_close
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_conn_error
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_close_complete
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ep_timeout
parameter_list|(
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_iwarp_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uninit_iwarp_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_data
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_connected
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|c4iw_so_upcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_socket_event
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_ep_resources
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_terminate
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|terminate
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_ep_to_req_list
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
name|int
name|ep_events
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|START_EP_TIMER
parameter_list|(
name|ep
parameter_list|)
define|\
value|do { \ 	    CTR3(KTR_IW_CXGBE, "start_ep_timer (%s:%d) ep %p", \ 		__func__, __LINE__, (ep)); \ 	    start_ep_timer(ep); \     } while (0)
end_define

begin_define
define|#
directive|define
name|STOP_EP_TIMER
parameter_list|(
name|ep
parameter_list|)
define|\
value|({ \ 	    CTR3(KTR_IW_CXGBE, "stop_ep_timer (%s:%d) ep %p", \ 		__func__, __LINE__, (ep)); \ 	    stop_ep_timer(ep); \     })
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|states
index|[]
init|=
block|{
literal|"idle"
block|,
literal|"listen"
block|,
literal|"connecting"
block|,
literal|"mpa_wait_req"
block|,
literal|"mpa_req_sent"
block|,
literal|"mpa_req_rcvd"
block|,
literal|"mpa_rep_sent"
block|,
literal|"fpdu_mode"
block|,
literal|"aborting"
block|,
literal|"closing"
block|,
literal|"moribund"
block|,
literal|"dead"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|deref_cm_id
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|)
block|{
name|epc
operator|->
name|cm_id
operator|->
name|rem_ref
argument_list|(
name|epc
operator|->
name|cm_id
argument_list|)
expr_stmt|;
name|epc
operator|->
name|cm_id
operator|=
name|NULL
expr_stmt|;
name|set_bit
argument_list|(
name|CM_ID_DEREFED
argument_list|,
operator|&
name|epc
operator|->
name|history
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ref_cm_id
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|)
block|{
name|set_bit
argument_list|(
name|CM_ID_REFED
argument_list|,
operator|&
name|epc
operator|->
name|history
argument_list|)
expr_stmt|;
name|epc
operator|->
name|cm_id
operator|->
name|add_ref
argument_list|(
name|epc
operator|->
name|cm_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|deref_qp
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|c4iw_qp_rem_ref
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|ibqp
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|QP_REFERENCED
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|QP_DEREFED
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ref_qp
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|set_bit
argument_list|(
name|QP_REFERENCED
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|QP_REFED
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
name|c4iw_qp_add_ref
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|ibqp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_timeout
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|int
name|abort
init|=
literal|1
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s ep :%p, tid:%u, state %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|TIMEDOUT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|MPA_REQ_SENT
case|:
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_WAIT
case|:
case|case
name|MPA_REQ_RCVD
case|:
case|case
name|MPA_REP_SENT
case|:
case|case
name|FPDU_MODE
case|:
break|break;
case|case
name|CLOSING
case|:
case|case
name|MORIBUND
case|:
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|&&
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_ERROR
expr_stmt|;
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|dev
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|close_complete_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABORTING
case|:
case|case
name|DEAD
case|:
comment|/* 		 * These states are expected if the ep timed out at the same 		 * time as another thread was calling stop_ep_timer(). 		 * So we silently do nothing for these states. 		 */
name|abort
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s unexpected state ep %p tid %u state %u\n"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
name|abort
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort
condition|)
name|c4iw_ep_disconnect
argument_list|(
name|ep
argument_list|,
literal|1
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_struct
struct|struct
name|cqe_list_entry
block|{
name|struct
name|list_head
name|entry
decl_stmt|;
name|struct
name|c4iw_dev
modifier|*
name|rhp
decl_stmt|;
name|struct
name|t4_cqe
name|err_cqe
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|process_err_cqes
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flag
decl_stmt|;
name|struct
name|cqe_list_entry
modifier|*
name|cle
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|err_cqe_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|err_cqe_list
argument_list|)
condition|)
block|{
name|struct
name|list_head
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|err_cqe_list
operator|.
name|next
expr_stmt|;
name|list_del
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|tmp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|err_cqe_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|cle
operator|=
name|list_entry
argument_list|(
name|tmp
argument_list|,
expr|struct
name|cqe_list_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|c4iw_ev_dispatch
argument_list|(
name|cle
operator|->
name|rhp
argument_list|,
operator|&
name|cle
operator|->
name|err_cqe
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cle
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|err_cqe_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|err_cqe_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_req
parameter_list|(
name|struct
name|work_struct
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|c4iw_ep_common
modifier|*
name|epc
decl_stmt|;
name|unsigned
name|long
name|flag
decl_stmt|;
name|int
name|ep_events
decl_stmt|;
name|process_err_cqes
argument_list|()
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|req_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|req_list
argument_list|)
condition|)
block|{
name|epc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|req_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|req_list
argument_list|,
name|epc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|epc
operator|->
name|entry
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|ep_events
operator|=
name|epc
operator|->
name|ep_events
expr_stmt|;
name|epc
operator|->
name|ep_events
operator|=
literal|0
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|req_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: so %p, ep %p, events 0x%x"
argument_list|,
name|__func__
argument_list|,
name|epc
operator|->
name|so
argument_list|,
name|epc
argument_list|,
name|ep_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_events
operator|&
name|C4IW_EVENT_TERM
condition|)
name|process_terminate
argument_list|(
operator|(
expr|struct
name|c4iw_ep
operator|*
operator|)
name|epc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_events
operator|&
name|C4IW_EVENT_TIMEOUT
condition|)
name|process_timeout
argument_list|(
operator|(
expr|struct
name|c4iw_ep
operator|*
operator|)
name|epc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_events
operator|&
name|C4IW_EVENT_SOCKET
condition|)
name|process_socket_event
argument_list|(
operator|(
expr|struct
name|c4iw_ep
operator|*
operator|)
name|epc
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
name|epc
argument_list|)
expr_stmt|;
name|process_err_cqes
argument_list|()
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|req_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|req_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX: doesn't belong here in the iWARP driver.  * XXX: assumes that the connection was offloaded by cxgbe/t4_tom if TF_TOE is  *      set.  Is this a valid assumption for active open?  */
end_comment

begin_function
specifier|static
name|int
name|set_tcpinfo
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|ep
operator|->
name|com
operator|.
name|so
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: connection not offloaded (so %p, ep %p)\n"
argument_list|,
name|__func__
argument_list|,
name|so
argument_list|,
name|ep
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|toep
operator|=
name|TOEPCB
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ep
operator|->
name|hwtid
operator|=
name|toep
operator|->
name|tid
expr_stmt|;
name|ep
operator|->
name|snd_seq
operator|=
name|tp
operator|->
name|snd_nxt
expr_stmt|;
name|ep
operator|->
name|rcv_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|ep
operator|->
name|emss
operator|=
name|max
argument_list|(
name|tp
operator|->
name|t_maxseg
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rtentry
modifier|*
name|find_route
parameter_list|(
name|__be32
name|local_ip
parameter_list|,
name|__be32
name|peer_ip
parameter_list|,
name|__be16
name|local_port
parameter_list|,
name|__be16
name|peer_port
parameter_list|,
name|u8
name|tos
parameter_list|)
block|{
name|struct
name|route
name|iproute
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|dst
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|iproute
operator|.
name|ro_dst
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:frtB %x, %x, %d, %d"
argument_list|,
name|__func__
argument_list|,
name|local_ip
argument_list|,
name|peer_ip
argument_list|,
name|ntohs
argument_list|(
name|local_port
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|peer_port
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|iproute
argument_list|,
sizeof|sizeof
name|iproute
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|->
name|sin_len
operator|=
sizeof|sizeof
expr|*
name|dst
expr_stmt|;
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|peer_ip
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|iproute
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:frtE %p"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uint64_t
operator|)
name|iproute
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return
name|iproute
operator|.
name|ro_rt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|uninit_iwarp_socket
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sodisconnect
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_peer_close
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|int
name|disconnect
init|=
literal|1
decl_stmt|;
name|int
name|release
init|=
literal|0
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppcB ep %p so %p state %s"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|MPA_REQ_WAIT
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc1 %p MPA_REQ_WAIT CLOSING"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_SENT
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc2 %p MPA_REQ_SENT CLOSING"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|disconnect
operator|=
literal|0
expr_stmt|;
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|close_socket
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|)
expr_stmt|;
name|deref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|release
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MPA_REQ_RCVD
case|:
comment|/* 			 * We're gonna mark this puppy DEAD, but keep 			 * the reference on it until the ULP accepts or 			 * rejects the CR. 			 */
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc3 %p MPA_REQ_RCVD CLOSING"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
name|c4iw_get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REP_SENT
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc4 %p MPA_REP_SENT CLOSING"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPDU_MODE
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc5 %p FPDU_MODE CLOSING"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|START_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_CLOSING
expr_stmt|;
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|dev
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peer_close_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABORTING
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc6 %p ABORTING (disconn)"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLOSING
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc7 %p CLOSING MORIBUND"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MORIBUND
argument_list|)
expr_stmt|;
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MORIBUND
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc8 %p MORIBUND DEAD"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|&&
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_IDLE
expr_stmt|;
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|close_socket
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|)
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|release
operator|=
literal|1
expr_stmt|;
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DEAD
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppc9 %p DEAD (disconn)"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: ep %p state %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|disconnect
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppca %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|c4iw_ep_disconnect
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|release
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppcb %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ppcE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_conn_error
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|state
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|state
operator|=
name|ep
operator|->
name|com
operator|.
name|state
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pceB ep %p so %p so->so_error %u state %s"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_error
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MPA_REQ_WAIT
case|:
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_SENT
case|:
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ECONNRESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REP_SENT
case|:
name|ep
operator|->
name|com
operator|.
name|rpl_err
operator|=
name|ECONNRESET
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"waking up ep %p"
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_RCVD
case|:
comment|/* 			 * We're gonna mark this puppy DEAD, but keep 			 * the reference on it until the ULP accepts or 			 * rejects the CR. 			 */
name|c4iw_get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
break|break;
case|case
name|MORIBUND
case|:
case|case
name|CLOSING
case|:
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|FPDU_MODE
case|:
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|&&
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_ERROR
expr_stmt|;
name|ret
operator|=
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s - qp<- error failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|peer_abort_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABORTING
case|:
break|break;
case|case
name|DEAD
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s so_error %d IN DEAD STATE!!!!"
argument_list|,
name|__func__
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_error
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"%s: ep %p state %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|!=
name|ABORTING
condition|)
block|{
name|close_socket
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pceE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_close_complete
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|int
name|release
init|=
literal|0
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pccB ep %p so %p state %s"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
comment|/* The cm_id may be null if we failed to connect */
name|mutex_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|CLOSE_CON_RPL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|CLOSING
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcc1 %p CLOSING MORIBUND"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MORIBUND
argument_list|)
expr_stmt|;
break|break;
case|case
name|MORIBUND
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcc1 %p MORIBUND DEAD"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|)
operator|&&
operator|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcc2 %p QP_STATE_IDLE"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_IDLE
expr_stmt|;
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|dev
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|close_socket
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|)
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|release
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ABORTING
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcc5 %p ABORTING"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEAD
case|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcc6 %p DEAD"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcc7 %p unknown ep state"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s:pcc6 %p unknown ep state"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|release
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcc8 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pccE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|init_iwarp_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
comment|/* Note that SOCK_LOCK(so) is same as SOCKBUF_LOCK(&so->so_rcv) */
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soupcall_set
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|,
name|c4iw_so_upcall
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_NBIO
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|TCP_NODELAY
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|on
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|on
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: can't set TCP_NODELAY on so %p (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|so
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uninit_iwarp_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_data
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|local
decl_stmt|,
modifier|*
name|remote
decl_stmt|;
name|int
name|disconnect
init|=
literal|0
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: so %p, ep %p, state %s, sb_cc %d"
argument_list|,
name|__func__
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|ep
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
condition|)
block|{
case|case
name|MPA_REQ_SENT
case|:
name|disconnect
operator|=
name|process_mpa_reply
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_WAIT
case|:
name|in_getsockaddr
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|local
argument_list|)
expr_stmt|;
name|in_getpeeraddr
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|remote
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|local_addr
operator|=
operator|*
name|local
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|remote_addr
operator|=
operator|*
name|remote
expr_stmt|;
name|free
argument_list|(
name|local
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|disconnect
operator|=
name|process_mpa_request
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Unexpected streaming data.  "
literal|"ep %p, state %d, so %p, so_state 0x%x, sb_cc %u\n"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_state
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|disconnect
condition|)
name|c4iw_ep_disconnect
argument_list|(
name|ep
argument_list|,
name|disconnect
operator|==
literal|2
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_connected
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|ep
operator|->
name|com
operator|.
name|so
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|&&
operator|!
name|so
operator|->
name|so_error
condition|)
block|{
if|if
condition|(
name|send_mpa_req
argument_list|(
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|so
operator|->
name|so_error
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return;
name|err
label|:
name|close_socket
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|process_newconn
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|parent_cm_id
parameter_list|,
name|struct
name|socket
modifier|*
name|child_so
parameter_list|)
block|{
name|struct
name|c4iw_ep
modifier|*
name|child_ep
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|local
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|remote
decl_stmt|;
name|struct
name|c4iw_ep
modifier|*
name|parent_ep
init|=
name|parent_cm_id
operator|->
name|provider_data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|MPASS
argument_list|(
name|child_so
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|child_ep
operator|=
name|alloc_ep
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|child_ep
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: parent so %p, parent ep %p, child so %p, child ep %p"
argument_list|,
name|__func__
argument_list|,
name|parent_ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|parent_ep
argument_list|,
name|child_so
argument_list|,
name|child_ep
argument_list|)
expr_stmt|;
name|in_getsockaddr
argument_list|(
name|child_so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|local
argument_list|)
expr_stmt|;
name|in_getpeeraddr
argument_list|(
name|child_so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|remote
argument_list|)
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|local_addr
operator|=
operator|*
name|local
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|remote_addr
operator|=
operator|*
name|remote
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|dev
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|dev
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|so
operator|=
name|child_so
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|NULL
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|thread
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|thread
expr_stmt|;
name|child_ep
operator|->
name|parent_ep
operator|=
name|parent_ep
expr_stmt|;
name|free
argument_list|(
name|local
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|init_iwarp_socket
argument_list|(
name|child_so
argument_list|,
operator|&
name|child_ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|c4iw_get_ep
argument_list|(
operator|&
name|parent_ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|init_timer
argument_list|(
operator|&
name|child_ep
operator|->
name|timer
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|child_ep
operator|->
name|com
argument_list|,
name|MPA_REQ_WAIT
argument_list|)
expr_stmt|;
name|START_EP_TIMER
argument_list|(
name|child_ep
argument_list|)
expr_stmt|;
comment|/* maybe the request has already been queued up on the socket... */
name|ret
operator|=
name|process_mpa_request
argument_list|(
name|child_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
comment|/* ABORT */
name|c4iw_ep_disconnect
argument_list|(
name|child_ep
argument_list|,
literal|1
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
comment|/* CLOSE */
name|c4iw_ep_disconnect
argument_list|(
name|child_ep
argument_list|,
literal|0
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|add_ep_to_req_list
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
name|int
name|new_ep_event
parameter_list|)
block|{
name|unsigned
name|long
name|flag
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|req_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|&&
name|ep
operator|->
name|com
operator|.
name|so
condition|)
block|{
name|ep
operator|->
name|com
operator|.
name|ep_events
operator||=
name|new_ep_event
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|com
operator|.
name|entry
operator|.
name|tqe_prev
condition|)
block|{
name|c4iw_get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|req_list
argument_list|,
operator|&
name|ep
operator|->
name|com
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|c4iw_taskq
argument_list|,
operator|&
name|c4iw_task
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|req_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|c4iw_so_upcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
block|{
name|struct
name|c4iw_ep
modifier|*
name|ep
init|=
name|arg
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: so %p, so_state 0x%x, ep %p, ep_state %s, tqe_prev %p"
argument_list|,
name|__func__
argument_list|,
name|so
argument_list|,
name|so
operator|->
name|so_state
argument_list|,
name|ep
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|,
name|ep
operator|->
name|com
operator|.
name|entry
operator|.
name|tqe_prev
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
operator|==
name|so
argument_list|)
expr_stmt|;
name|add_ep_to_req_list
argument_list|(
name|ep
argument_list|,
name|C4IW_EVENT_SOCKET
argument_list|)
expr_stmt|;
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|terminate
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_rdma_terminate
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|c4iw_ep
modifier|*
name|ep
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|toep
operator|->
name|inp
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|toep
operator|->
name|inp
argument_list|)
expr_stmt|;
name|ep
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_upcallarg
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|toep
operator|->
name|inp
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: so %p, ep %p"
argument_list|,
name|__func__
argument_list|,
name|so
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|add_ep_to_req_list
argument_list|(
name|ep
argument_list|,
name|C4IW_EVENT_TERM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_socket_event
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|int
name|state
init|=
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|ep
operator|->
name|com
operator|.
name|so
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"process_socket_event: so %p, so_state 0x%x, "
literal|"so_err %d, sb_state 0x%x, ep %p, ep_state %s"
argument_list|,
name|so
argument_list|,
name|so
operator|->
name|so_state
argument_list|,
name|so
operator|->
name|so_error
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
argument_list|,
name|ep
argument_list|,
name|states
index|[
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|CONNECTING
condition|)
block|{
name|process_connected
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|LISTEN
condition|)
block|{
comment|/* socket listening events are handled at IWCM */
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s Invalid ep state:%u, ep:%p"
argument_list|,
name|__func__
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|BUG
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* connection error */
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|process_conn_error
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* peer close */
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|&&
name|state
operator|<=
name|CLOSING
condition|)
block|{
name|process_peer_close
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* 		 * check whether socket disconnect event is pending before 		 * returning. Fallthrough if yes. 		 */
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTED
operator|)
condition|)
return|return;
block|}
comment|/* close complete */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTED
condition|)
block|{
name|process_close_complete
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* rx data */
name|process_data
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|iw_cxgbe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"iw_cxgbe driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|dack_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.dack_mode"
argument_list|,
operator|&
name|dack_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|dack_mode
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dack_mode
argument_list|,
literal|0
argument_list|,
literal|"Delayed ack mode (default = 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c4iw_max_read_depth
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.c4iw_max_read_depth"
argument_list|,
operator|&
name|c4iw_max_read_depth
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|c4iw_max_read_depth
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|c4iw_max_read_depth
argument_list|,
literal|0
argument_list|,
literal|"Per-connection max ORD/IRD (default = 8)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_tcp_timestamps
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.enable_tcp_timestamps"
argument_list|,
operator|&
name|enable_tcp_timestamps
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_tcp_timestamps
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_tcp_timestamps
argument_list|,
literal|0
argument_list|,
literal|"Enable tcp timestamps (default = 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_tcp_sack
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.enable_tcp_sack"
argument_list|,
operator|&
name|enable_tcp_sack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_tcp_sack
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_tcp_sack
argument_list|,
literal|0
argument_list|,
literal|"Enable tcp SACK (default = 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_tcp_window_scaling
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.enable_tcp_window_scaling"
argument_list|,
operator|&
name|enable_tcp_window_scaling
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_tcp_window_scaling
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_tcp_window_scaling
argument_list|,
literal|0
argument_list|,
literal|"Enable tcp window scaling (default = 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c4iw_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.c4iw_debug"
argument_list|,
operator|&
name|c4iw_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|c4iw_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|c4iw_debug
argument_list|,
literal|0
argument_list|,
literal|"Enable debug logging (default = 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|peer2peer
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.peer2peer"
argument_list|,
operator|&
name|peer2peer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|peer2peer
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|peer2peer
argument_list|,
literal|0
argument_list|,
literal|"Support peer2peer ULPs (default = 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|p2p_type
init|=
name|FW_RI_INIT_P2PTYPE_READ_REQ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.p2p_type"
argument_list|,
operator|&
name|p2p_type
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|p2p_type
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|p2p_type
argument_list|,
literal|0
argument_list|,
literal|"RDMAP opcode to use for the RTR message: 1 = RDMA_READ 0 = RDMA_WRITE (default 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ep_timeout_secs
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.ep_timeout_secs"
argument_list|,
operator|&
name|ep_timeout_secs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|ep_timeout_secs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ep_timeout_secs
argument_list|,
literal|0
argument_list|,
literal|"CM Endpoint operation timeout in seconds (default = 60)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mpa_rev
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.mpa_rev"
argument_list|,
operator|&
name|mpa_rev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|mpa_rev
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mpa_rev
argument_list|,
literal|0
argument_list|,
literal|"MPA Revision, 0 supports amso1100, 1 is RFC5044 spec compliant, 2 is IETF MPA Peer Connect Draft compliant (default = 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|markers_enabled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.markers_enabled"
argument_list|,
operator|&
name|markers_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|markers_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|markers_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable MPA MARKERS (default(0) = disabled)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|crc_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.crc_enabled"
argument_list|,
operator|&
name|crc_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|crc_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|crc_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable MPA CRC (default(1) = enabled)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|rcv_win
init|=
literal|256
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.rcv_win"
argument_list|,
operator|&
name|rcv_win
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|rcv_win
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rcv_win
argument_list|,
literal|0
argument_list|,
literal|"TCP receive window in bytes (default = 256KB)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|snd_win
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgbe.snd_win"
argument_list|,
operator|&
name|snd_win
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|snd_win
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|snd_win
argument_list|,
literal|0
argument_list|,
literal|"TCP send window in bytes (default = 128KB)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|start_ep_timer
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
name|timer_pending
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: ep %p, already started"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|printk
argument_list|(
name|KERN_ERR
literal|"%s timer already started! ep %p\n"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
name|clear_bit
argument_list|(
name|TIMEOUT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
expr_stmt|;
name|c4iw_get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|ep
operator|->
name|timer
operator|.
name|expires
operator|=
name|jiffies
operator|+
name|ep_timeout_secs
operator|*
name|HZ
expr_stmt|;
name|ep
operator|->
name|timer
operator|.
name|data
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ep
expr_stmt|;
name|ep
operator|->
name|timer
operator|.
name|function
operator|=
name|ep_timeout
expr_stmt|;
name|add_timer
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stop_ep_timer
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|del_timer_sync
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test_and_set_bit
argument_list|(
name|TIMEOUT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
condition|)
block|{
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|c4iw_ep_state
name|state_read
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|)
block|{
name|enum
name|c4iw_ep_state
name|state
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|epc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|state
operator|=
name|epc
operator|->
name|state
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|epc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__state_set
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|,
name|enum
name|c4iw_ep_state
name|new
parameter_list|)
block|{
name|epc
operator|->
name|state
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_set
parameter_list|(
name|struct
name|c4iw_ep_common
modifier|*
name|epc
parameter_list|,
name|enum
name|c4iw_ep_state
name|new
parameter_list|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|epc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
name|epc
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|epc
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|alloc_ep
parameter_list|(
name|int
name|size
parameter_list|,
name|gfp_t
name|gfp
parameter_list|)
block|{
name|struct
name|c4iw_ep_common
modifier|*
name|epc
decl_stmt|;
name|epc
operator|=
name|kzalloc
argument_list|(
name|size
argument_list|,
name|gfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|epc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|kref_init
argument_list|(
operator|&
name|epc
operator|->
name|kref
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|epc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|c4iw_init_wr_wait
argument_list|(
operator|&
name|epc
operator|->
name|wr_wait
argument_list|)
expr_stmt|;
return|return
operator|(
name|epc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_c4iw_free_ep
parameter_list|(
name|struct
name|kref
modifier|*
name|kref
parameter_list|)
block|{
name|struct
name|c4iw_ep
modifier|*
name|ep
decl_stmt|;
name|struct
name|c4iw_ep_common
modifier|*
name|epc
decl_stmt|;
name|ep
operator|=
name|container_of
argument_list|(
name|kref
argument_list|,
expr|struct
name|c4iw_ep
argument_list|,
name|com
operator|.
name|kref
argument_list|)
expr_stmt|;
name|epc
operator|=
operator|&
name|ep
operator|->
name|com
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|epc
operator|->
name|entry
operator|.
name|tqe_prev
argument_list|,
operator|(
literal|"%s epc %p still on req list"
operator|,
name|__func__
operator|,
name|epc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|QP_REFERENCED
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
condition|)
name|deref_qp
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_ep_resources
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:rerB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|RELEASE_RESOURCES
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:rerE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_mpa_req
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|int
name|mpalen
decl_stmt|;
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|struct
name|mpa_v2_conn_params
name|mpa_v2_params
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
name|mpa_rev_to_use
init|=
name|mpa_rev
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|retry_with_mpa_v1
condition|)
name|mpa_rev_to_use
operator|=
literal|1
expr_stmt|;
name|mpalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|ep
operator|->
name|plen
expr_stmt|;
if|if
condition|(
name|mpa_rev_to_use
operator|==
literal|2
condition|)
name|mpalen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
expr_stmt|;
name|mpa
operator|=
name|malloc
argument_list|(
name|mpalen
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpa
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smr1 ep: %p , error: %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memset
argument_list|(
name|mpa
argument_list|,
literal|0
argument_list|,
name|mpalen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REQ
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|flags
operator|=
operator|(
name|crc_enabled
condition|?
name|MPA_CRC
else|:
literal|0
operator|)
operator||
operator|(
name|markers_enabled
condition|?
name|MPA_MARKERS
else|:
literal|0
operator|)
operator||
operator|(
name|mpa_rev_to_use
operator|==
literal|2
condition|?
name|MPA_ENHANCED_RDMA_CONN
else|:
literal|0
operator|)
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|=
name|htons
argument_list|(
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|revision
operator|=
name|mpa_rev_to_use
expr_stmt|;
if|if
condition|(
name|mpa_rev_to_use
operator|==
literal|1
condition|)
block|{
name|ep
operator|->
name|tried_with_mpa_v1
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|retry_with_mpa_v1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mpa_rev_to_use
operator|==
literal|2
condition|)
block|{
name|mpa
operator|->
name|private_data_size
operator|+=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|)
expr_stmt|;
name|mpa_v2_params
operator|.
name|ird
operator|=
name|htons
argument_list|(
operator|(
name|u16
operator|)
name|ep
operator|->
name|ird
argument_list|)
expr_stmt|;
name|mpa_v2_params
operator|.
name|ord
operator|=
name|htons
argument_list|(
operator|(
name|u16
operator|)
name|ep
operator|->
name|ord
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer2peer
condition|)
block|{
name|mpa_v2_params
operator|.
name|ird
operator||=
name|htons
argument_list|(
name|MPA_V2_PEER2PEER_MODEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_type
operator|==
name|FW_RI_INIT_P2PTYPE_RDMA_WRITE
condition|)
block|{
name|mpa_v2_params
operator|.
name|ord
operator||=
name|htons
argument_list|(
name|MPA_V2_RDMA_WRITE_RTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_type
operator|==
name|FW_RI_INIT_P2PTYPE_READ_REQ
condition|)
block|{
name|mpa_v2_params
operator|.
name|ord
operator||=
name|htons
argument_list|(
name|MPA_V2_RDMA_READ_RTR
argument_list|)
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
operator|&
name|mpa_v2_params
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|plen
condition|)
block|{
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|,
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ep
operator|->
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smr7 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m_getm
argument_list|(
name|NULL
argument_list|,
name|mpalen
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smr2 ep: %p , error: %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpa
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|mpalen
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mpa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpa
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|sosend
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|MSG_DONTWAIT
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smr3 ep: %p , error: %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|START_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MPA_REQ_SENT
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|initiator
operator|=
literal|1
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrE %p, error: %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrE %p, error: %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_mpa_reject
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|plen
parameter_list|)
block|{
name|int
name|mpalen
decl_stmt|;
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|struct
name|mpa_v2_conn_params
name|mpa_v2_params
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|err
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrejB %p %u %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
name|mpalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|==
literal|2
operator|&&
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
condition|)
block|{
name|mpalen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrej1 %p %u %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|version
argument_list|,
name|mpalen
argument_list|)
expr_stmt|;
block|}
name|mpa
operator|=
name|malloc
argument_list|(
name|mpalen
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpa
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|mpa
argument_list|,
literal|0
argument_list|,
name|mpalen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REP
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|flags
operator|=
name|MPA_REJECT
expr_stmt|;
name|mpa
operator|->
name|revision
operator|=
name|mpa_rev
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|==
literal|2
operator|&&
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
condition|)
block|{
name|mpa
operator|->
name|flags
operator||=
name|MPA_ENHANCED_RDMA_CONN
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|+=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|)
expr_stmt|;
name|mpa_v2_params
operator|.
name|ird
operator|=
name|htons
argument_list|(
operator|(
operator|(
name|u16
operator|)
name|ep
operator|->
name|ird
operator|)
operator||
operator|(
name|peer2peer
condition|?
name|MPA_V2_PEER2PEER_MODEL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|mpa_v2_params
operator|.
name|ord
operator|=
name|htons
argument_list|(
operator|(
operator|(
name|u16
operator|)
name|ep
operator|->
name|ord
operator|)
operator||
operator|(
name|peer2peer
condition|?
operator|(
name|p2p_type
operator|==
name|FW_RI_INIT_P2PTYPE_RDMA_WRITE
condition|?
name|MPA_V2_RDMA_WRITE_RTR
else|:
name|p2p_type
operator|==
name|FW_RI_INIT_P2PTYPE_READ_REQ
condition|?
name|MPA_V2_RDMA_READ_RTR
else|:
literal|0
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
operator|&
name|mpa_v2_params
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|,
name|pdata
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrej3 %p %d %d %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|mpa_v2_params
operator|.
name|ird
argument_list|,
name|mpa_v2_params
operator|.
name|ord
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
name|pdata
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_getm
argument_list|(
name|NULL
argument_list|,
name|mpalen
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mpa
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|mpalen
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mpa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpa
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|sosend
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|MSG_DONTWAIT
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|ep
operator|->
name|snd_seq
operator|+=
name|mpalen
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrejE %p %u %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_mpa_reply
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|plen
parameter_list|)
block|{
name|int
name|mpalen
decl_stmt|;
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mpa_v2_conn_params
name|mpa_v2_params
decl_stmt|;
name|int
name|err
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrepB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mpalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|==
literal|2
operator|&&
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrep1 %p %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|version
argument_list|)
expr_stmt|;
name|mpalen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
expr_stmt|;
block|}
name|mpa
operator|=
name|malloc
argument_list|(
name|mpalen
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpa
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|mpa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REP
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|flags
operator|=
operator|(
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
condition|?
name|MPA_CRC
else|:
literal|0
operator|)
operator||
operator|(
name|markers_enabled
condition|?
name|MPA_MARKERS
else|:
literal|0
operator|)
expr_stmt|;
name|mpa
operator|->
name|revision
operator|=
name|ep
operator|->
name|mpa_attr
operator|.
name|version
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|==
literal|2
operator|&&
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
condition|)
block|{
name|mpa
operator|->
name|flags
operator||=
name|MPA_ENHANCED_RDMA_CONN
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|+=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|)
expr_stmt|;
name|mpa_v2_params
operator|.
name|ird
operator|=
name|htons
argument_list|(
operator|(
name|u16
operator|)
name|ep
operator|->
name|ird
argument_list|)
expr_stmt|;
name|mpa_v2_params
operator|.
name|ord
operator|=
name|htons
argument_list|(
operator|(
name|u16
operator|)
name|ep
operator|->
name|ord
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrep3 %p %d %d %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|version
argument_list|,
name|mpa_v2_params
operator|.
name|ird
argument_list|,
name|mpa_v2_params
operator|.
name|ord
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer2peer
operator|&&
operator|(
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|!=
name|FW_RI_INIT_P2PTYPE_DISABLED
operator|)
condition|)
block|{
name|mpa_v2_params
operator|.
name|ird
operator||=
name|htons
argument_list|(
name|MPA_V2_PEER2PEER_MODEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_type
operator|==
name|FW_RI_INIT_P2PTYPE_RDMA_WRITE
condition|)
block|{
name|mpa_v2_params
operator|.
name|ord
operator||=
name|htons
argument_list|(
name|MPA_V2_RDMA_WRITE_RTR
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrep4 %p %d %d %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|p2p_type
argument_list|,
name|mpa_v2_params
operator|.
name|ird
argument_list|,
name|mpa_v2_params
operator|.
name|ord
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_type
operator|==
name|FW_RI_INIT_P2PTYPE_READ_REQ
condition|)
block|{
name|mpa_v2_params
operator|.
name|ord
operator||=
name|htons
argument_list|(
name|MPA_V2_RDMA_READ_RTR
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrep5 %p %d %d %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|p2p_type
argument_list|,
name|mpa_v2_params
operator|.
name|ird
argument_list|,
name|mpa_v2_params
operator|.
name|ord
argument_list|)
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
operator|&
name|mpa_v2_params
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
argument_list|,
name|pdata
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
name|pdata
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_getm
argument_list|(
name|NULL
argument_list|,
name|mpalen
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mpa
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|mpalen
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mpa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpa
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MPA_REP_SENT
argument_list|)
expr_stmt|;
name|ep
operator|->
name|snd_seq
operator|+=
name|mpalen
expr_stmt|;
name|err
operator|=
operator|-
name|sosend
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|MSG_DONTWAIT
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:smrepE %p %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_complete_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ccuB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CLOSE
expr_stmt|;
name|event
operator|.
name|status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ccu1 %1"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|deref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|CLOSE_UPCALL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ccuE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_abort
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|ep
operator|->
name|com
operator|.
name|so
decl_stmt|;
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|linger
name|l
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s ep %p so %p state %s tid %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|l
operator|.
name|l_linger
operator|=
literal|0
expr_stmt|;
comment|/* linger_time of 0 forces RST to be sent */
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_LINGER
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|l
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|l
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: sosetopt(%p, linger = 0) failed with %d.\n"
argument_list|,
name|__func__
argument_list|,
name|so
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|uninit_iwarp_socket
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sodisconnect
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|ABORT_CONN
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
comment|/* 	 * TBD: iw_cxgbe driver should receive ABORT reply for every ABORT 	 * request it has sent. But the current TOE driver is not propagating 	 * this ABORT reply event (via do_abort_rpl) to iw_cxgbe. So as a work- 	 * around de-refer 'ep' (which was refered before sending ABORT request) 	 * here instead of doing it in abort_rpl() handler of iw_cxgbe driver. 	 */
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|peer_close_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcuB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_DISCONNECT
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcu1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|DISCONN_UPCALL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pcuE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|peer_abort_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pauB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CLOSE
expr_stmt|;
name|event
operator|.
name|status
operator|=
operator|-
name|ECONNRESET
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pau1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|deref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|ABORT_UPCALL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pauE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connect_reply_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cruB %p, status: %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CONNECT_REPLY
expr_stmt|;
name|event
operator|.
name|status
operator|=
operator|(
operator|(
name|status
operator|==
operator|-
name|ECONNABORTED
operator|)
operator|||
operator|(
name|status
operator|==
operator|-
name|EPIPE
operator|)
operator|)
condition|?
operator|-
name|ECONNRESET
else|:
name|status
expr_stmt|;
name|event
operator|.
name|local_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|local_addr
expr_stmt|;
name|event
operator|.
name|remote_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|remote_addr
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|)
operator|||
operator|(
name|status
operator|==
operator|-
name|ECONNREFUSED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ep
operator|->
name|tried_with_mpa_v1
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cru1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* this means MPA_v2 is used */
name|event
operator|.
name|private_data_len
operator|=
name|ep
operator|->
name|plen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
expr_stmt|;
name|event
operator|.
name|private_data
operator|=
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cru2 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* this means MPA_v1 is used */
name|event
operator|.
name|private_data_len
operator|=
name|ep
operator|->
name|plen
expr_stmt|;
name|event
operator|.
name|private_data
operator|=
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cru3 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|CONN_RPL_UPCALL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
operator|-
name|ECONNABORTED
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cruE %p %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cru4 %p %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|deref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cruE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|connect_request_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: ep %p, mpa_v1 %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|tried_with_mpa_v1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CONNECT_REQUEST
expr_stmt|;
name|event
operator|.
name|local_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|local_addr
expr_stmt|;
name|event
operator|.
name|remote_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|remote_addr
expr_stmt|;
name|event
operator|.
name|provider_data
operator|=
name|ep
expr_stmt|;
name|event
operator|.
name|so
operator|=
name|ep
operator|->
name|com
operator|.
name|so
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|tried_with_mpa_v1
condition|)
block|{
comment|/* this means MPA_v2 is used */
name|event
operator|.
name|ord
operator|=
name|ep
operator|->
name|ord
expr_stmt|;
name|event
operator|.
name|ird
operator|=
name|ep
operator|->
name|ird
expr_stmt|;
name|event
operator|.
name|private_data_len
operator|=
name|ep
operator|->
name|plen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
expr_stmt|;
name|event
operator|.
name|private_data
operator|=
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_v2_conn_params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this means MPA_v1 is used. Send max supported */
name|event
operator|.
name|ord
operator|=
name|c4iw_max_read_depth
expr_stmt|;
name|event
operator|.
name|ird
operator|=
name|c4iw_max_read_depth
expr_stmt|;
name|event
operator|.
name|private_data_len
operator|=
name|ep
operator|->
name|plen
expr_stmt|;
name|event
operator|.
name|private_data
operator|=
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
expr_stmt|;
block|}
name|c4iw_get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|CONNREQ_UPCALL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|parent_ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|established_upcall
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:euB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_ESTABLISHED
expr_stmt|;
name|event
operator|.
name|ird
operator|=
name|ep
operator|->
name|ird
expr_stmt|;
name|event
operator|.
name|ord
operator|=
name|ep
operator|->
name|ord
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:eu1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|ESTAB_UPCALL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:euE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process_mpa_reply - process streaming mode MPA reply  *  * Returns:  *  * 0 upon success indicating a connect request was delivered to the ULP  * or the mpa request is incomplete but valid so far.  *  * 1 if a failure requires the caller to close the connection.  *  * 2 if a failure requires the caller to abort the connection.  */
end_comment

begin_function
specifier|static
name|int
name|process_mpa_reply
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|struct
name|mpa_v2_conn_params
modifier|*
name|mpa_v2_params
decl_stmt|;
name|u16
name|plen
decl_stmt|;
name|u16
name|resp_ird
decl_stmt|,
name|resp_ord
decl_stmt|;
name|u8
name|rtr_mismatch
init|=
literal|0
decl_stmt|,
name|insuff_ird
init|=
literal|0
decl_stmt|;
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|enum
name|c4iw_qp_attr_mask
name|mask
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|flags
init|=
name|MSG_DONTWAIT
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|int
name|disconnect
init|=
literal|0
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 	 * Stop mpa timer.  If it expired, then 	 * we ignore the MPA reply.  process_timeout() 	 * will abort the connection. 	 */
if|if
condition|(
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
condition|)
return|return
literal|0
return|;
name|uio
operator|.
name|uio_resid
operator|=
literal|1000000
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|ep
operator|->
name|com
operator|.
name|thread
expr_stmt|;
name|err
operator|=
name|soreceive
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|uio
argument_list|,
operator|&
name|top
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|START_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|err
operator|=
operator|-
name|err
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr2 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr3 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s data after soreceive called! so %p sb_mb %p top %p\n"
argument_list|,
name|__func__
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|top
expr_stmt|;
do|do
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr4 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 		 * If we get more than the supported amount of private data 		 * then we must fail this connection. 		 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|+
name|m
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|mpa_pkt
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr5 %p %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|mpa_pkt_len
operator|+
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|-
name|EINVAL
operator|)
expr_stmt|;
goto|goto
name|err_stop_timer
goto|;
block|}
comment|/* 		 * copy the new data into our accumulation buffer. 		 */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
operator|&
operator|(
name|ep
operator|->
name|mpa_pkt
index|[
name|ep
operator|->
name|mpa_pkt_len
index|]
operator|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_pkt_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
else|else
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
comment|/* 	 * if we don't even have the mpa message, then bail. 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|mpa
operator|=
operator|(
expr|struct
name|mpa_message
operator|*
operator|)
name|ep
operator|->
name|mpa_pkt
expr_stmt|;
comment|/* Validate MPA header. */
if|if
condition|(
name|mpa
operator|->
name|revision
operator|>
name|mpa_rev
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr6 %p %d %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|mpa
operator|->
name|revision
argument_list|,
name|mpa_rev
argument_list|)
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR MOD
literal|"%s MPA version mismatch. Local = %d, "
literal|" Received = %d\n"
argument_list|,
argument|__func__
argument_list|,
argument|mpa_rev
argument_list|,
argument|mpa->revision
argument_list|)
empty_stmt|;
name|err
operator|=
operator|-
name|EPROTO
expr_stmt|;
goto|goto
name|err_stop_timer
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REP
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr7 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTO
expr_stmt|;
goto|goto
name|err_stop_timer
goto|;
block|}
name|plen
operator|=
name|ntohs
argument_list|(
name|mpa
operator|->
name|private_data_size
argument_list|)
expr_stmt|;
comment|/* 	 * Fail if there's too much private data. 	 */
if|if
condition|(
name|plen
operator|>
name|MPA_MAX_PRIVATE_DATA
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr8 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTO
expr_stmt|;
goto|goto
name|err_stop_timer
goto|;
block|}
comment|/* 	 * If plen does not account for pkt size 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|>
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmr9 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTO
expr_stmt|;
goto|goto
name|err_stop_timer
goto|;
block|}
name|ep
operator|->
name|plen
operator|=
operator|(
name|u8
operator|)
name|plen
expr_stmt|;
comment|/* 	 * If we don't have all the pdata yet, then bail. 	 * We'll continue process when more data arrives. 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmra %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mpa
operator|->
name|flags
operator|&
name|MPA_REJECT
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrb %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|err_stop_timer
goto|;
block|}
comment|/* 	 * If we get here we have accumulated the entire mpa 	 * start reply message including private data. And 	 * the MPA header is valid. 	 */
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|FPDU_MODE
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
operator|=
operator|(
name|mpa
operator|->
name|flags
operator|&
name|MPA_CRC
operator|)
operator||
name|crc_enabled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
operator|=
name|markers_enabled
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
operator|=
name|mpa
operator|->
name|flags
operator|&
name|MPA_MARKERS
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|=
name|mpa
operator|->
name|revision
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|FW_RI_INIT_P2PTYPE_DISABLED
expr_stmt|;
if|if
condition|(
name|mpa
operator|->
name|revision
operator|==
literal|2
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrc %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
operator|=
name|mpa
operator|->
name|flags
operator|&
name|MPA_ENHANCED_RDMA_CONN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrd %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mpa_v2_params
operator|=
operator|(
expr|struct
name|mpa_v2_conn_params
operator|*
operator|)
operator|(
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|)
expr_stmt|;
name|resp_ird
operator|=
name|ntohs
argument_list|(
name|mpa_v2_params
operator|->
name|ird
argument_list|)
operator|&
name|MPA_V2_IRD_ORD_MASK
expr_stmt|;
name|resp_ord
operator|=
name|ntohs
argument_list|(
name|mpa_v2_params
operator|->
name|ord
argument_list|)
operator|&
name|MPA_V2_IRD_ORD_MASK
expr_stmt|;
comment|/* 			 * This is a double-check. Ideally, below checks are 			 * not required since ird/ord stuff has been taken 			 * care of in c4iw_accept_cr 			 */
if|if
condition|(
operator|(
name|ep
operator|->
name|ird
operator|<
name|resp_ord
operator|)
operator|||
operator|(
name|ep
operator|->
name|ord
operator|>
name|resp_ird
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmre %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|ep
operator|->
name|ird
operator|=
name|resp_ord
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
name|resp_ird
expr_stmt|;
name|insuff_ird
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|mpa_v2_params
operator|->
name|ird
argument_list|)
operator|&
name|MPA_V2_PEER2PEER_MODEL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrf %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|mpa_v2_params
operator|->
name|ord
argument_list|)
operator|&
name|MPA_V2_RDMA_WRITE_RTR
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrg %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|FW_RI_INIT_P2PTYPE_RDMA_WRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|mpa_v2_params
operator|->
name|ord
argument_list|)
operator|&
name|MPA_V2_RDMA_READ_RTR
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrh %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|FW_RI_INIT_P2PTYPE_READ_REQ
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmri %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpa
operator|->
name|revision
operator|==
literal|1
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrj %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer2peer
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrk %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|p2p_type
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|set_tcpinfo
argument_list|(
name|ep
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrl %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s set_tcpinfo error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ECONNRESET
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|CTR6
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s - crc_enabled = %d, recv_marker_enabled = %d, "
literal|"xmit_marker_enabled = %d, version = %d p2p_type = %d"
argument_list|,
name|__func__
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|version
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
argument_list|)
expr_stmt|;
comment|/* 	 * If responder's RTR does not match with that of initiator, assign 	 * FW_RI_INIT_P2PTYPE_DISABLED in mpa attributes so that RTR is not 	 * generated when moving QP to RTS state. 	 * A TERM message will be sent after QP has moved to RTS state 	 */
if|if
condition|(
operator|(
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|==
literal|2
operator|)
operator|&&
name|peer2peer
operator|&&
operator|(
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|!=
name|p2p_type
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrm %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|FW_RI_INIT_P2PTYPE_DISABLED
expr_stmt|;
name|rtr_mismatch
operator|=
literal|1
expr_stmt|;
block|}
comment|//ep->ofld_txq = TOEPCB(ep->com.so)->ofld_txq;
name|attrs
operator|.
name|mpa_attr
operator|=
name|ep
operator|->
name|mpa_attr
expr_stmt|;
name|attrs
operator|.
name|max_ird
operator|=
name|ep
operator|->
name|ird
expr_stmt|;
name|attrs
operator|.
name|max_ord
operator|=
name|ep
operator|->
name|ord
expr_stmt|;
name|attrs
operator|.
name|llp_stream_handle
operator|=
name|ep
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_RTS
expr_stmt|;
name|mask
operator|=
name|C4IW_QP_ATTR_NEXT_STATE
operator||
name|C4IW_QP_ATTR_LLP_STREAM_HANDLE
operator||
name|C4IW_QP_ATTR_MPA_ATTR
operator||
name|C4IW_QP_ATTR_MAX_IRD
operator||
name|C4IW_QP_ATTR_MAX_ORD
expr_stmt|;
comment|/* bind QP and TID with INIT_WR */
name|err
operator|=
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|mask
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrn %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * If responder's RTR requirement did not match with what initiator 	 * supports, generate TERM message 	 */
if|if
condition|(
name|rtr_mismatch
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmro %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: RTR mismatch, sending TERM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|layer_etype
operator|=
name|LAYER_MPA
operator||
name|DDP_LLP
expr_stmt|;
name|attrs
operator|.
name|ecode
operator|=
name|MPA_NOMATCH_RTR
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_TERMINATE
expr_stmt|;
name|err
operator|=
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|disconnect
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Generate TERM if initiator IRD is not sufficient for responder 	 * provided ORD. Currently, we do the same behaviour even when 	 * responder provided IRD is also not sufficient as regards to 	 * initiator ORD. 	 */
if|if
condition|(
name|insuff_ird
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrp %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: Insufficient IRD, sending TERM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|layer_etype
operator|=
name|LAYER_MPA
operator||
name|DDP_LLP
expr_stmt|;
name|attrs
operator|.
name|ecode
operator|=
name|MPA_INSUFF_IRD
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_TERMINATE
expr_stmt|;
name|err
operator|=
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|disconnect
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
goto|goto
name|out
goto|;
name|err_stop_timer
label|:
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|err
label|:
name|disconnect
operator|=
literal|2
expr_stmt|;
name|out
label|:
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:pmrE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
name|disconnect
return|;
block|}
end_function

begin_comment
comment|/*  * process_mpa_request - process streaming mode MPA request  *  * Returns:  *  * 0 upon success indicating a connect request was delivered to the ULP  * or the mpa request is incomplete but valid so far.  *  * 1 if a failure requires the caller to close the connection.  *  * 2 if a failure requires the caller to abort the connection.  */
end_comment

begin_function
specifier|static
name|int
name|process_mpa_request
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|u16
name|plen
decl_stmt|;
name|int
name|flags
init|=
name|MSG_DONTWAIT
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|enum
name|c4iw_ep_state
name|state
init|=
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: ep %p, state %s"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|states
index|[
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|MPA_REQ_WAIT
condition|)
return|return
literal|0
return|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|ep
operator|->
name|mpa_pkt
index|[
name|ep
operator|->
name|mpa_pkt_len
index|]
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|mpa_pkt
argument_list|)
operator|-
name|ep
operator|->
name|mpa_pkt_len
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|mpa_pkt
argument_list|)
operator|-
name|ep
operator|->
name|mpa_pkt_len
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|NULL
expr_stmt|;
comment|/* uio.uio_td = ep->com.thread; */
name|rc
operator|=
name|soreceive
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|uio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EAGAIN
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|rc
condition|)
goto|goto
name|err_stop_timer
goto|;
name|KASSERT
argument_list|(
name|uio
operator|.
name|uio_offset
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: sorecieve on so %p read no data"
operator|,
name|__func__
operator|,
name|ep
operator|->
name|com
operator|.
name|so
operator|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_pkt_len
operator|+=
name|uio
operator|.
name|uio_offset
expr_stmt|;
comment|/* 	 * If we get more than the supported amount of private data then we must 	 * fail this connection.  XXX: check so_rcv->sb_cc, or peek with another 	 * soreceive, or increase the size of mpa_pkt by 1 and abort if the last 	 * byte is filled by the soreceive above. 	 */
comment|/* Don't even have the MPA message.  Wait for more data to arrive. */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
condition|)
return|return
literal|0
return|;
name|mpa
operator|=
operator|(
expr|struct
name|mpa_message
operator|*
operator|)
name|ep
operator|->
name|mpa_pkt
expr_stmt|;
comment|/* 	 * Validate MPA Header. 	 */
if|if
condition|(
name|mpa
operator|->
name|revision
operator|>
name|mpa_rev
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: MPA version mismatch. Local = %d,"
literal|" Received = %d\n"
argument_list|,
name|__func__
argument_list|,
name|mpa_rev
argument_list|,
name|mpa
operator|->
name|revision
argument_list|)
expr_stmt|;
goto|goto
name|err_stop_timer
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REQ
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
condition|)
goto|goto
name|err_stop_timer
goto|;
comment|/* 	 * Fail if there's too much private data. 	 */
name|plen
operator|=
name|ntohs
argument_list|(
name|mpa
operator|->
name|private_data_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|MPA_MAX_PRIVATE_DATA
condition|)
goto|goto
name|err_stop_timer
goto|;
comment|/* 	 * If plen does not account for pkt size 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|>
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
goto|goto
name|err_stop_timer
goto|;
name|ep
operator|->
name|plen
operator|=
operator|(
name|u8
operator|)
name|plen
expr_stmt|;
comment|/* 	 * If we don't have all the pdata yet, then bail. 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * If we get here we have accumulated the entire mpa 	 * start reply message including private data. 	 */
name|ep
operator|->
name|mpa_attr
operator|.
name|initiator
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
operator|=
operator|(
name|mpa
operator|->
name|flags
operator|&
name|MPA_CRC
operator|)
operator||
name|crc_enabled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
operator|=
name|markers_enabled
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
operator|=
name|mpa
operator|->
name|flags
operator|&
name|MPA_MARKERS
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|=
name|mpa
operator|->
name|revision
expr_stmt|;
if|if
condition|(
name|mpa
operator|->
name|revision
operator|==
literal|1
condition|)
name|ep
operator|->
name|tried_with_mpa_v1
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|FW_RI_INIT_P2PTYPE_DISABLED
expr_stmt|;
if|if
condition|(
name|mpa
operator|->
name|revision
operator|==
literal|2
condition|)
block|{
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
operator|=
name|mpa
operator|->
name|flags
operator|&
name|MPA_ENHANCED_RDMA_CONN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
condition|)
block|{
name|struct
name|mpa_v2_conn_params
modifier|*
name|mpa_v2_params
decl_stmt|;
name|u16
name|ird
decl_stmt|,
name|ord
decl_stmt|;
name|mpa_v2_params
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ep
operator|->
name|mpa_pkt
index|[
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
index|]
expr_stmt|;
name|ird
operator|=
name|ntohs
argument_list|(
name|mpa_v2_params
operator|->
name|ird
argument_list|)
expr_stmt|;
name|ord
operator|=
name|ntohs
argument_list|(
name|mpa_v2_params
operator|->
name|ord
argument_list|)
expr_stmt|;
name|ep
operator|->
name|ird
operator|=
name|ird
operator|&
name|MPA_V2_IRD_ORD_MASK
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
name|ord
operator|&
name|MPA_V2_IRD_ORD_MASK
expr_stmt|;
if|if
condition|(
name|ird
operator|&
name|MPA_V2_PEER2PEER_MODEL
operator|&&
name|peer2peer
condition|)
block|{
if|if
condition|(
name|ord
operator|&
name|MPA_V2_RDMA_WRITE_RTR
condition|)
block|{
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|FW_RI_INIT_P2PTYPE_RDMA_WRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ord
operator|&
name|MPA_V2_RDMA_READ_RTR
condition|)
block|{
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|FW_RI_INIT_P2PTYPE_READ_REQ
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mpa
operator|->
name|revision
operator|==
literal|1
operator|&&
name|peer2peer
condition|)
name|ep
operator|->
name|mpa_attr
operator|.
name|p2p_type
operator|=
name|p2p_type
expr_stmt|;
if|if
condition|(
name|set_tcpinfo
argument_list|(
name|ep
argument_list|)
condition|)
goto|goto
name|err_stop_timer
goto|;
name|CTR5
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: crc_enabled = %d, recv_marker_enabled = %d, "
literal|"xmit_marker_enabled = %d, version = %d"
argument_list|,
name|__func__
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|version
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MPA_REQ_RCVD
argument_list|)
expr_stmt|;
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* drive upcall */
name|mutex_lock
argument_list|(
operator|&
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|state
operator|!=
name|DEAD
condition|)
block|{
if|if
condition|(
name|connect_request_upcall
argument_list|(
name|ep
argument_list|)
condition|)
goto|goto
name|err_unlock_parent
goto|;
block|}
else|else
goto|goto
name|err_unlock_parent
goto|;
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unlock_parent
label|:
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
name|err_stop_timer
label|:
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|err_out
label|:
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/*  * Upcall from the adapter indicating data has been transmitted.  * For us its just the single MPA request or reply.  We can now free  * the skb holding the mpa message.  */
end_comment

begin_function
name|int
name|c4iw_reject_cr
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|pdata_len
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|c4iw_ep
modifier|*
name|ep
init|=
name|to_ep
argument_list|(
name|cm_id
argument_list|)
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:crcB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|int
name|abort
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|==
name|DEAD
operator|)
operator|||
operator|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|!=
name|MPA_REQ_RCVD
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:crc1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
operator|-
name|ECONNRESET
return|;
block|}
name|set_bit
argument_list|(
name|ULP_REJECT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpa_rev
operator|==
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:crc2 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|abort
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:crc3 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|abort
operator|=
name|send_mpa_reject
argument_list|(
name|ep
argument_list|,
name|pdata
argument_list|,
name|pdata_len
argument_list|)
expr_stmt|;
block|}
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
name|c4iw_ep_disconnect
argument_list|(
name|ep
argument_list|,
name|abort
operator|!=
literal|0
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:crc4 %p, err: %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|c4iw_accept_cr
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|conn_param
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|enum
name|c4iw_qp_attr_mask
name|mask
decl_stmt|;
name|struct
name|c4iw_ep
modifier|*
name|ep
init|=
name|to_ep
argument_list|(
name|cm_id
argument_list|)
decl_stmt|;
name|struct
name|c4iw_dev
modifier|*
name|h
init|=
name|to_c4iw_dev
argument_list|(
name|cm_id
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|c4iw_qp
modifier|*
name|qp
init|=
name|get_qhp
argument_list|(
name|h
argument_list|,
name|conn_param
operator|->
name|qpn
argument_list|)
decl_stmt|;
name|int
name|abort
init|=
literal|0
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cacB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|==
name|DEAD
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ECONNRESET
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|BUG_ON
argument_list|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|!=
name|MPA_REQ_RCVD
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|qp
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|ULP_ACCEPT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conn_param
operator|->
name|ord
operator|>
name|c4iw_max_read_depth
operator|)
operator|||
operator|(
name|conn_param
operator|->
name|ird
operator|>
name|c4iw_max_read_depth
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac2 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_abort
goto|;
block|}
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|==
literal|2
operator|&&
name|ep
operator|->
name|mpa_attr
operator|.
name|enhanced_rdma_conn
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac3 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn_param
operator|->
name|ord
operator|>
name|ep
operator|->
name|ird
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac4 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|ird
operator|=
name|conn_param
operator|->
name|ird
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
name|conn_param
operator|->
name|ord
expr_stmt|;
name|send_mpa_reject
argument_list|(
name|ep
argument_list|,
name|conn_param
operator|->
name|private_data
argument_list|,
name|conn_param
operator|->
name|private_data_len
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_abort
goto|;
block|}
if|if
condition|(
name|conn_param
operator|->
name|ird
operator|>
name|ep
operator|->
name|ord
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac5 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|ord
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac6 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|conn_param
operator|->
name|ird
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac7 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_abort
goto|;
block|}
block|}
block|}
name|ep
operator|->
name|ird
operator|=
name|conn_param
operator|->
name|ird
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
name|conn_param
operator|->
name|ord
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|!=
literal|2
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac8 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer2peer
operator|&&
name|ep
operator|->
name|ird
operator|==
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cac9 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|ird
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|cm_id
expr_stmt|;
name|ref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|qp
expr_stmt|;
name|ref_qp
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|//ep->ofld_txq = TOEPCB(ep->com.so)->ofld_txq;
comment|/* bind QP to EP and move to RTS */
name|attrs
operator|.
name|mpa_attr
operator|=
name|ep
operator|->
name|mpa_attr
expr_stmt|;
name|attrs
operator|.
name|max_ird
operator|=
name|ep
operator|->
name|ird
expr_stmt|;
name|attrs
operator|.
name|max_ord
operator|=
name|ep
operator|->
name|ord
expr_stmt|;
name|attrs
operator|.
name|llp_stream_handle
operator|=
name|ep
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_RTS
expr_stmt|;
comment|/* bind QP and TID with INIT_WR */
name|mask
operator|=
name|C4IW_QP_ATTR_NEXT_STATE
operator||
name|C4IW_QP_ATTR_LLP_STREAM_HANDLE
operator||
name|C4IW_QP_ATTR_MPA_ATTR
operator||
name|C4IW_QP_ATTR_MAX_IRD
operator||
name|C4IW_QP_ATTR_MAX_ORD
expr_stmt|;
name|err
operator|=
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|mask
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:caca %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
goto|goto
name|err_defef_cm_id
goto|;
block|}
name|err
operator|=
name|send_mpa_reply
argument_list|(
name|ep
argument_list|,
name|conn_param
operator|->
name|private_data
argument_list|,
name|conn_param
operator|->
name|private_data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:caca %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
goto|goto
name|err_defef_cm_id
goto|;
block|}
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|FPDU_MODE
argument_list|)
expr_stmt|;
name|established_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cacE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_defef_cm_id
label|:
name|deref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|err_abort
label|:
name|abort
operator|=
literal|1
expr_stmt|;
name|err_out
label|:
if|if
condition|(
name|abort
condition|)
name|c4iw_ep_disconnect
argument_list|(
name|ep
argument_list|,
literal|1
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cacE err %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|c4iw_connect
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|conn_param
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|c4iw_dev
modifier|*
name|dev
init|=
name|to_c4iw_dev
argument_list|(
name|cm_id
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|c4iw_ep
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ccB %p"
argument_list|,
name|__func__
argument_list|,
name|cm_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conn_param
operator|->
name|ord
operator|>
name|c4iw_max_read_depth
operator|)
operator|||
operator|(
name|conn_param
operator|->
name|ird
operator|>
name|c4iw_max_read_depth
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cc1 %p"
argument_list|,
name|__func__
argument_list|,
name|cm_id
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ep
operator|=
name|alloc_ep
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|init_timer
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ep
operator|->
name|plen
operator|=
name|conn_param
operator|->
name|private_data_len
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|plen
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cc3 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
argument_list|,
name|conn_param
operator|->
name|private_data
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|ird
operator|=
name|conn_param
operator|->
name|ird
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
name|conn_param
operator|->
name|ord
expr_stmt|;
if|if
condition|(
name|peer2peer
operator|&&
name|ep
operator|->
name|ord
operator|==
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cc4 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
literal|1
expr_stmt|;
block|}
name|ep
operator|->
name|com
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|cm_id
expr_stmt|;
name|ref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|get_qhp
argument_list|(
name|dev
argument_list|,
name|conn_param
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cc5 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ref_qp
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|thread
operator|=
name|curthread
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|so
operator|=
name|cm_id
operator|->
name|so
expr_stmt|;
comment|/* find a route */
name|rt
operator|=
name|find_route
argument_list|(
name|cm_id
operator|->
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|cm_id
operator|->
name|remote_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|cm_id
operator|->
name|local_addr
operator|.
name|sin_port
argument_list|,
name|cm_id
operator|->
name|remote_addr
operator|.
name|sin_port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rt
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cc7 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR MOD
literal|"%s - cannot find route.\n"
argument_list|,
argument|__func__
argument_list|)
empty_stmt|;
name|err
operator|=
operator|-
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE
operator|)
operator|||
name|TOEDEV
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|ENOPROTOOPT
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CONNECTING
argument_list|)
expr_stmt|;
name|ep
operator|->
name|tos
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|local_addr
operator|=
name|cm_id
operator|->
name|local_addr
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|remote_addr
operator|=
name|cm_id
operator|->
name|remote_addr
expr_stmt|;
name|err
operator|=
operator|-
name|soconnect
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ep
operator|->
name|com
operator|.
name|remote_addr
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|init_iwarp_socket
argument_list|(
name|cm_id
operator|->
name|so
argument_list|,
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
goto|goto
name|fail2
goto|;
block|}
name|fail3
label|:
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|fail2
label|:
name|deref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
comment|/* CTR shouldn't display already-freed ep. */
name|out
label|:
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ccE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * iwcm->create_listen_ep.  Returns -errno on failure.  */
end_comment

begin_function
name|int
name|c4iw_create_listen_ep
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
name|struct
name|c4iw_dev
modifier|*
name|dev
init|=
name|to_c4iw_dev
argument_list|(
name|cm_id
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|c4iw_listen_ep
modifier|*
name|ep
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|cm_id
operator|->
name|so
decl_stmt|;
name|ep
operator|=
name|alloc_ep
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|cm_id
expr_stmt|;
name|ref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|ep
operator|->
name|backlog
operator|=
name|backlog
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|local_addr
operator|=
name|cm_id
operator|->
name|local_addr
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|thread
operator|=
name|curthread
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|LISTEN
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|so
operator|=
name|so
expr_stmt|;
name|cm_id
operator|->
name|provider_data
operator|=
name|ep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|c4iw_destroy_listen_ep
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|c4iw_listen_ep
modifier|*
name|ep
init|=
name|to_listen_ep
argument_list|(
name|cm_id
argument_list|)
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s: cm_id %p, so %p, state %s"
argument_list|,
name|__func__
argument_list|,
name|cm_id
argument_list|,
name|cm_id
operator|->
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|deref_cm_id
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|c4iw_put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|c4iw_ep_disconnect
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|,
name|int
name|abrupt
parameter_list|,
name|gfp_t
name|gfp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|close
init|=
literal|0
decl_stmt|;
name|int
name|fatal
init|=
literal|0
decl_stmt|;
name|struct
name|c4iw_rdev
modifier|*
name|rdev
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cedB %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|rdev
operator|=
operator|&
name|ep
operator|->
name|com
operator|.
name|dev
operator|->
name|rdev
expr_stmt|;
if|if
condition|(
name|c4iw_fatal_error
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ced1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|fatal
operator|=
literal|1
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ECONNRESET
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|DEAD
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ced2 %p %s"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|MPA_REQ_WAIT
case|:
case|case
name|MPA_REQ_SENT
case|:
case|case
name|MPA_REQ_RCVD
case|:
case|case
name|MPA_REP_SENT
case|:
case|case
name|FPDU_MODE
case|:
name|close
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|abrupt
condition|)
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|ABORTING
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|CLOSING
expr_stmt|;
name|START_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|set_bit
argument_list|(
name|CLOSE_SENT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSING
case|:
if|if
condition|(
operator|!
name|test_and_set_bit
argument_list|(
name|CLOSE_SENT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
condition|)
block|{
name|close
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|abrupt
condition|)
block|{
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|ABORTING
expr_stmt|;
block|}
else|else
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|MORIBUND
expr_stmt|;
block|}
break|break;
case|case
name|MORIBUND
case|:
case|case
name|ABORTING
case|:
case|case
name|DEAD
case|:
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s ignoring disconnect ep %p state %u"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
break|break;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ced3 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|abrupt
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ced4 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|EP_DISC_ABORT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ECONNRESET
argument_list|)
expr_stmt|;
name|ret
operator|=
name|send_abort
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ced5 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|EP_DISC_CLOSE
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|parent_ep
condition|)
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MORIBUND
argument_list|)
expr_stmt|;
name|sodisconnect
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fatal
condition|)
block|{
name|set_bit
argument_list|(
name|EP_DISC_FAIL
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|history
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abrupt
condition|)
block|{
name|STOP_EP_TIMER
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|EIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_ERROR
expr_stmt|;
name|ret
operator|=
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|dev
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ced7 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s - qp<- error failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
name|release_ep_resources
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|DEAD
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:ced6 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:cedE %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|C4IW_EP_REDIRECT
end_ifdef

begin_function
name|int
name|c4iw_ep_redirect
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|struct
name|dst_entry
modifier|*
name|old
parameter_list|,
name|struct
name|dst_entry
modifier|*
name|new
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|l2t
parameter_list|)
block|{
name|struct
name|c4iw_ep
modifier|*
name|ep
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|dst
operator|!=
name|old
condition|)
return|return
literal|0
return|;
name|PDBG
argument_list|(
literal|"%s ep %p redirect to dst %p l2t %p\n"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|new
argument_list|,
name|l2t
argument_list|)
expr_stmt|;
name|dst_hold
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|cxgb4_l2t_release
argument_list|(
name|ep
operator|->
name|l2t
argument_list|)
expr_stmt|;
name|ep
operator|->
name|l2t
operator|=
name|l2t
expr_stmt|;
name|dst_release
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|ep
operator|->
name|dst
operator|=
name|new
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ep_timeout
parameter_list|(
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|c4iw_ep
modifier|*
name|ep
init|=
operator|(
expr|struct
name|c4iw_ep
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|test_and_set_bit
argument_list|(
name|TIMEOUT
argument_list|,
operator|&
name|ep
operator|->
name|com
operator|.
name|flags
argument_list|)
condition|)
block|{
comment|/* 		 * Only insert if it is not already on the list. 		 */
if|if
condition|(
operator|!
operator|(
name|ep
operator|->
name|com
operator|.
name|ep_events
operator|&
name|C4IW_EVENT_TIMEOUT
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:et1 %p"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|add_ep_to_req_list
argument_list|(
name|ep
argument_list|,
name|C4IW_EVENT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fw6_wr_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
name|uint64_t
name|val
init|=
name|be64toh
argument_list|(
operator|*
name|rpl
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|c4iw_wr_wait
modifier|*
name|wr_waitp
decl_stmt|;
name|ret
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|wr_waitp
operator|=
operator|(
expr|struct
name|c4iw_wr_wait
operator|*
operator|)
name|rpl
index|[
literal|1
index|]
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s wr_waitp %p ret %u"
argument_list|,
name|__func__
argument_list|,
name|wr_waitp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_waitp
condition|)
name|c4iw_wake_up
argument_list|(
name|wr_waitp
argument_list|,
name|ret
condition|?
operator|-
name|ret
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw6_cqe_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
name|struct
name|cqe_list_entry
modifier|*
name|cle
decl_stmt|;
name|unsigned
name|long
name|flag
decl_stmt|;
name|cle
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cle
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|cle
operator|->
name|rhp
operator|=
name|sc
operator|->
name|iwarp_softc
expr_stmt|;
name|cle
operator|->
name|err_cqe
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|t4_cqe
operator|*
operator|)
operator|(
operator|&
name|rpl
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|err_cqe_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|cle
operator|->
name|entry
argument_list|,
operator|&
name|err_cqe_list
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|c4iw_taskq
argument_list|,
operator|&
name|c4iw_task
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|err_cqe_lock
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_terminate
parameter_list|(
name|struct
name|c4iw_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|c4iw_qp_attributes
name|attrs
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:tB %p %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|&&
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|printk
argument_list|(
argument|KERN_WARNING MOD
literal|"TERM received tid %u qpid %u\n"
argument_list|,
argument|ep->hwtid
argument_list|,
argument|ep->com.qp->wq.sq.qid
argument_list|)
empty_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|C4IW_QP_STATE_TERMINATE
expr_stmt|;
name|c4iw_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|dev
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|C4IW_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|printk
argument_list|(
argument|KERN_WARNING MOD
literal|"TERM received tid %u no ep/qp\n"
argument_list|,
argument|ep->hwtid
argument_list|)
empty_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGBE
argument_list|,
literal|"%s:tE %p %d"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|__init
name|c4iw_cm_init
parameter_list|(
name|void
parameter_list|)
block|{
name|t4_register_cpl_handler
argument_list|(
name|CPL_RDMA_TERMINATE
argument_list|,
name|terminate
argument_list|)
expr_stmt|;
name|t4_register_fw_msg_handler
argument_list|(
name|FW6_TYPE_WR_RPL
argument_list|,
name|fw6_wr_rpl
argument_list|)
expr_stmt|;
name|t4_register_fw_msg_handler
argument_list|(
name|FW6_TYPE_CQE
argument_list|,
name|fw6_cqe_handler
argument_list|)
expr_stmt|;
name|t4_register_an_handler
argument_list|(
name|c4iw_ev_handler
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|req_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|req_lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|err_cqe_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|err_cqe_lock
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|c4iw_task
argument_list|,
name|process_req
argument_list|)
expr_stmt|;
name|c4iw_taskq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"iw_cxgbe"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c4iw_taskq
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|__exit
name|c4iw_cm_term
parameter_list|(
name|void
parameter_list|)
block|{
name|WARN_ON
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|req_list
argument_list|)
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|list_empty
argument_list|(
operator|&
name|err_cqe_list
argument_list|)
argument_list|)
expr_stmt|;
name|flush_workqueue
argument_list|(
name|c4iw_taskq
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|c4iw_taskq
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_RDMA_TERMINATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_fw_msg_handler
argument_list|(
name|FW6_TYPE_WR_RPL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_fw_msg_handler
argument_list|(
name|FW6_TYPE_CQE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_register_an_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

