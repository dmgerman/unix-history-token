begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|fl_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXXNM */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|cxgbe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"cxgbe netmap parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * 0 = normal netmap rx  * 1 = black hole  * 2 = supermassive black hole (buffer packing enabled)  */
end_comment

begin_decl_stmt
name|int
name|black_hole
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|nm_black_hole
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|black_hole
argument_list|,
literal|0
argument_list|,
literal|"Sink incoming packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|rx_ndesc
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|nm_rx_ndesc
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|rx_ndesc
argument_list|,
literal|0
argument_list|,
literal|"# of rx descriptors after which the hw cidx is updated."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|holdoff_tmr_idx
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|nm_holdoff_tmr_idx
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|holdoff_tmr_idx
argument_list|,
literal|0
argument_list|,
literal|"Holdoff timer index for netmap rx queues."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Congestion drops.  * -1: no congestion feedback (not recommended).  *  0: backpressure the channel instead of dropping packets right away.  *  1: no backpressure, drop packets for the congested queue immediately.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nm_cong_drop
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nm_cong_drop"
argument_list|,
operator|&
name|nm_cong_drop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|alloc_nm_rxq_hwq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
parameter_list|,
name|int
name|cong
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|,
name|i
decl_stmt|;
name|__be32
name|v
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_params
modifier|*
name|sp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|vi
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|MPASS
argument_list|(
name|na
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|iq_desc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|fl_desc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nm_rxq
operator|->
name|iq_desc
argument_list|,
name|vi
operator|->
name|qsize_rxq
operator|*
name|IQ_ESIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nm_rxq
operator|->
name|fl_desc
argument_list|,
name|na
operator|->
name|num_rx_desc
operator|*
name|EQ_ESIZE
operator|+
name|sp
operator|->
name|spg_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_IQ_CMD_ALLOC
operator||
name|F_FW_IQ_CMD_IQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_RXQ
condition|)
block|{
name|KASSERT
argument_list|(
name|nm_rxq
operator|->
name|intr_idx
operator|<
name|sc
operator|->
name|intr_count
argument_list|,
operator|(
literal|"%s: invalid direct intr_idx %d"
operator|,
name|__func__
operator|,
name|nm_rxq
operator|->
name|intr_idx
operator|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|V_FW_IQ_CMD_IQANDSTINDEX
argument_list|(
name|nm_rxq
operator|->
name|intr_idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CXGBE_UNIMPLEMENTED
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXXNM: needs review */
name|v
operator|=
name|V_FW_IQ_CMD_IQANDSTINDEX
argument_list|(
name|nm_rxq
operator|->
name|intr_idx
argument_list|)
operator||
name|F_FW_IQ_CMD_IQANDST
expr_stmt|;
block|}
name|c
operator|.
name|type_to_iqandstindex
operator|=
name|htobe32
argument_list|(
name|v
operator||
name|V_FW_IQ_CMD_TYPE
argument_list|(
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|)
operator||
name|V_FW_IQ_CMD_VIID
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
operator||
name|V_FW_IQ_CMD_IQANUD
argument_list|(
name|X_UPDATEDELIVERY_INTERRUPT
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqdroprss_to_iqesize
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_IQPCIECH
argument_list|(
name|vi
operator|->
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_IQ_CMD_IQGTSMODE
operator||
name|V_FW_IQ_CMD_IQINTCNTTHRESH
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_IQ_CMD_IQESIZE
argument_list|(
name|ilog2
argument_list|(
name|IQ_ESIZE
argument_list|)
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqsize
operator|=
name|htobe16
argument_list|(
name|vi
operator|->
name|qsize_rxq
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqaddr
operator|=
name|htobe64
argument_list|(
name|nm_rxq
operator|->
name|iq_ba
argument_list|)
expr_stmt|;
if|if
condition|(
name|cong
operator|>=
literal|0
condition|)
block|{
name|c
operator|.
name|iqns_to_fl0congen
operator|=
name|htobe32
argument_list|(
name|F_FW_IQ_CMD_IQFLINTCONGEN
operator||
name|V_FW_IQ_CMD_FL0CNGCHMAP
argument_list|(
name|cong
argument_list|)
operator||
name|F_FW_IQ_CMD_FL0CONGCIF
operator||
name|F_FW_IQ_CMD_FL0CONGEN
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|iqns_to_fl0congen
operator||=
name|htobe32
argument_list|(
name|V_FW_IQ_CMD_FL0HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
operator||
name|F_FW_IQ_CMD_FL0FETCHRO
operator||
name|F_FW_IQ_CMD_FL0DATARO
operator||
operator|(
name|fl_pad
condition|?
name|F_FW_IQ_CMD_FL0PADEN
else|:
literal|0
operator|)
operator||
operator|(
name|black_hole
operator|==
literal|2
condition|?
name|F_FW_IQ_CMD_FL0PACKEN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0dcaen_to_fl0cidxfthresh
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_FL0FBMIN
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|X_FETCHBURSTMIN_128B
else|:
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_IQ_CMD_FL0FBMAX
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|X_FETCHBURSTMAX_512B
else|:
name|X_FETCHBURSTMAX_256B
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0size
operator|=
name|htobe16
argument_list|(
name|na
operator|->
name|num_rx_desc
operator|/
literal|8
operator|+
name|sp
operator|->
name|spg_len
operator|/
name|EQ_ESIZE
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0addr
operator|=
name|htobe64
argument_list|(
name|nm_rxq
operator|->
name|fl_ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create netmap ingress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|nm_rxq
operator|->
name|iq_cidx
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|iq_sidx
operator|==
name|vi
operator|->
name|qsize_rxq
operator|-
name|sp
operator|->
name|spg_len
operator|/
name|IQ_ESIZE
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|iq_gen
operator|=
name|F_RSPD_GEN
expr_stmt|;
name|nm_rxq
operator|->
name|iq_cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|iqid
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|iq_abs_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|physiqid
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|nm_rxq
operator|->
name|iq_cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|iq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|niq
condition|)
block|{
name|panic
argument_list|(
literal|"%s: nm_rxq->iq_cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|niq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sge
operator|.
name|iqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|nm_rxq
expr_stmt|;
name|nm_rxq
operator|->
name|fl_cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|fl0id
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_pidx
operator|=
name|nm_rxq
operator|->
name|fl_cidx
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|fl_sidx
operator|==
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|nm_rxq
operator|->
name|fl_cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
block|{
name|panic
argument_list|(
literal|"%s: nm_rxq->fl_cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|nm_rxq
expr_stmt|;
name|nm_rxq
operator|->
name|fl_db_val
operator|=
name|V_QID
argument_list|(
name|nm_rxq
operator|->
name|fl_cntxt_id
argument_list|)
operator||
name|sc
operator|->
name|chip_params
operator|->
name|sge_fl_db
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>=
name|CHELSIO_T5
operator|&&
name|cong
operator|>=
literal|0
condition|)
block|{
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|;
name|param
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DMAQ
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DMAQ_CONM_CTXT
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
expr_stmt|;
name|param
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DMAQ
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DMAQ_CONM_CTXT
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cong
operator|==
literal|0
condition|)
name|val
operator|=
literal|1
operator|<<
literal|19
expr_stmt|;
else|else
block|{
name|val
operator|=
literal|2
operator|<<
literal|19
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cong
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|val
operator||=
literal|1
operator|<<
operator|(
name|i
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* report error but carry on */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to set congestion manager context for "
literal|"ingress queue %d: %d\n"
argument_list|,
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
block|}
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_gts_reg
argument_list|,
name|V_INGRESSQID
argument_list|(
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|holdoff_tmr_idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_nm_rxq_hwq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
operator|-
name|t4_iq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|,
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|,
name|nm_rxq
operator|->
name|fl_cntxt_id
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed for iq %d, fl %d: %d\n"
argument_list|,
name|__func__
argument_list|,
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|,
name|nm_rxq
operator|->
name|fl_cntxt_id
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|iq_cntxt_id
operator|=
name|INVALID_NM_RXQ_CNTXT_ID
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_nm_txq_hwq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|vi
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|fw_eq_eth_cmd
name|c
decl_stmt|;
name|MPASS
argument_list|(
name|na
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|desc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|na
operator|->
name|num_tx_desc
operator|*
name|EQ_ESIZE
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
expr_stmt|;
name|bzero
argument_list|(
name|nm_txq
operator|->
name|desc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_ETH_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_ETH_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_EQ_ETH_CMD_ALLOC
operator||
name|F_FW_EQ_ETH_CMD_EQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|autoequiqe_to_viid
operator|=
name|htobe32
argument_list|(
name|F_FW_EQ_ETH_CMD_AUTOEQUIQE
operator||
name|F_FW_EQ_ETH_CMD_AUTOEQUEQE
operator||
name|V_FW_EQ_ETH_CMD_VIID
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fetchszm_to_iqid
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_PCIECHN
argument_list|(
name|vi
operator|->
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_EQ_ETH_CMD_FETCHRO
operator||
name|V_FW_EQ_ETH_CMD_IQID
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|nm_rxq
index|[
name|nm_txq
operator|->
name|iqidx
index|]
operator|.
name|iq_cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|dcaen_to_eqsize
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_EQSIZE
argument_list|(
name|len
operator|/
name|EQ_ESIZE
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqaddr
operator|=
name|htobe64
argument_list|(
name|nm_txq
operator|->
name|ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|vi
operator|->
name|dev
argument_list|,
literal|"failed to create netmap egress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|nm_txq
operator|->
name|cntxt_id
operator|=
name|G_FW_EQ_ETH_CMD_EQID
argument_list|(
name|be32toh
argument_list|(
name|c
operator|.
name|eqid_pkd
argument_list|)
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|nm_txq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
name|panic
argument_list|(
literal|"%s: nm_txq->cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|nm_txq
expr_stmt|;
name|nm_txq
operator|->
name|pidx
operator|=
name|nm_txq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|sidx
operator|==
name|na
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equiqidx
operator|=
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|dbidx
operator|=
literal|0
expr_stmt|;
name|nm_txq
operator|->
name|doorbells
operator|=
name|sc
operator|->
name|doorbells
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
operator|||
name|isset
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDBWC
argument_list|)
operator|||
name|isset
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
condition|)
block|{
name|uint32_t
name|s_qpp
init|=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|eq_s_qpp
decl_stmt|;
name|uint32_t
name|mask
init|=
operator|(
literal|1
operator|<<
name|s_qpp
operator|)
operator|-
literal|1
decl_stmt|;
specifier|volatile
name|uint8_t
modifier|*
name|udb
decl_stmt|;
name|udb
operator|=
name|sc
operator|->
name|udbs_base
operator|+
name|UDBS_DB_OFFSET
expr_stmt|;
name|udb
operator|+=
operator|(
name|nm_txq
operator|->
name|cntxt_id
operator|>>
name|s_qpp
operator|)
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|nm_txq
operator|->
name|udb_qid
operator|=
name|nm_txq
operator|->
name|cntxt_id
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|nm_txq
operator|->
name|udb_qid
operator|>=
name|PAGE_SIZE
operator|/
name|UDBS_SEG_SIZE
condition|)
name|clrbit
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
else|else
block|{
name|udb
operator|+=
name|nm_txq
operator|->
name|udb_qid
operator|<<
name|UDBS_SEG_SHIFT
expr_stmt|;
name|nm_txq
operator|->
name|udb_qid
operator|=
literal|0
expr_stmt|;
block|}
name|nm_txq
operator|->
name|udb
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|udb
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_nm_txq_hwq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
operator|-
name|t4_eth_eq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|nm_txq
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed for eq %d: %d\n"
argument_list|,
name|__func__
argument_list|,
name|nm_txq
operator|->
name|cntxt_id
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|cntxt_id
operator|=
name|INVALID_NM_TXQ_CNTXT_ID
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_on
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|hwidx
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|hwb
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|hwb
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_FLBUF_SIZES
condition|;
name|i
operator|++
operator|,
name|hwb
operator|++
control|)
block|{
if|if
condition|(
name|hwb
operator|->
name|size
operator|==
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|SGE_FLBUF_SIZES
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"no hwidx for netmap buffer size %d.\n"
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|hwidx
operator|=
name|i
expr_stmt|;
comment|/* Must set caps before calling netmap_reset */
name|nm_set_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|for_each_nm_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|struct
name|irq
modifier|*
name|irq
init|=
operator|&
name|sc
operator|->
name|irq
index|[
name|vi
operator|->
name|first_intr
operator|+
name|i
index|]
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|nm_rxq
operator|->
name|nid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|nm_kring_pending_on
argument_list|(
name|kring
argument_list|)
operator|||
name|nm_rxq
operator|->
name|iq_cntxt_id
operator|!=
name|INVALID_NM_RXQ_CNTXT_ID
condition|)
continue|continue;
name|alloc_nm_rxq_hwq
argument_list|(
name|vi
argument_list|,
name|nm_rxq
argument_list|,
name|tnl_cong
argument_list|(
name|vi
operator|->
name|pi
argument_list|,
name|nm_cong_drop
argument_list|)
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_hwidx
operator|=
name|hwidx
expr_stmt|;
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|slot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXXNM: error check, not assert */
comment|/* We deal with 8 bufs at a time */
name|MPASS
argument_list|(
operator|(
name|na
operator|->
name|num_rx_desc
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|na
operator|->
name|num_rx_desc
operator|==
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nm_rxq
operator|->
name|fl_sidx
condition|;
name|j
operator|++
control|)
block|{
name|uint64_t
name|ba
decl_stmt|;
name|PNMB
argument_list|(
name|na
argument_list|,
operator|&
name|slot
index|[
name|j
index|]
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ba
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_desc
index|[
name|j
index|]
operator|=
name|htobe64
argument_list|(
name|ba
operator||
name|hwidx
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|nm_rxq
operator|->
name|fl_pidx
operator|=
name|nm_rxq
operator|->
name|fl_sidx
operator|-
literal|8
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|j
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|j
operator|/=
literal|8
expr_stmt|;
comment|/* driver pidx to hardware pidx */
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_cmpset_int
argument_list|(
operator|&
name|irq
operator|->
name|nm_state
argument_list|,
name|NM_OFF
argument_list|,
name|NM_ON
argument_list|)
expr_stmt|;
block|}
name|for_each_nm_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_txq
argument_list|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|nm_txq
operator|->
name|nid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|nm_kring_pending_on
argument_list|(
name|kring
argument_list|)
operator|||
name|nm_txq
operator|->
name|cntxt_id
operator|!=
name|INVALID_NM_TXQ_CNTXT_ID
condition|)
continue|continue;
name|alloc_nm_txq_hwq
argument_list|(
name|vi
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|slot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXXNM: error check, not assert */
block|}
if|if
condition|(
name|vi
operator|->
name|nm_rss
operator|==
name|NULL
condition|)
block|{
name|vi
operator|->
name|nm_rss
operator|=
name|malloc
argument_list|(
name|vi
operator|->
name|rss_size
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vi
operator|->
name|rss_size
condition|;
control|)
block|{
name|for_each_nm_rxq
argument_list|(
argument|vi
argument_list|,
argument|j
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|vi
operator|->
name|nm_rss
index|[
name|i
operator|++
index|]
operator|=
name|nm_rxq
operator|->
name|iq_abs_id
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|vi
operator|->
name|rss_size
condition|)
break|break;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_config_rss_range
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|,
name|vi
operator|->
name|nm_rss
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"netmap rss_config failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_off
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rc
operator|=
operator|-
name|t4_config_rss_range
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|,
name|vi
operator|->
name|rss
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to restore RSS config: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|nm_clear_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|for_each_nm_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_txq
argument_list|)
block|{
name|struct
name|sge_qstat
modifier|*
name|spg
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|sidx
index|]
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|nm_txq
operator|->
name|nid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|nm_kring_pending_off
argument_list|(
name|kring
argument_list|)
operator|||
name|nm_txq
operator|->
name|cntxt_id
operator|==
name|INVALID_NM_TXQ_CNTXT_ID
condition|)
continue|continue;
comment|/* Wait for hw pidx to catch up ... */
while|while
condition|(
name|be16toh
argument_list|(
name|nm_txq
operator|->
name|pidx
argument_list|)
operator|!=
name|spg
operator|->
name|pidx
condition|)
name|pause
argument_list|(
literal|"nmpidx"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... and then for the cidx. */
while|while
condition|(
name|spg
operator|->
name|pidx
operator|!=
name|spg
operator|->
name|cidx
condition|)
name|pause
argument_list|(
literal|"nmcidx"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_nm_txq_hwq
argument_list|(
name|vi
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
block|}
name|for_each_nm_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|struct
name|irq
modifier|*
name|irq
init|=
operator|&
name|sc
operator|->
name|irq
index|[
name|vi
operator|->
name|first_intr
operator|+
name|i
index|]
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|nm_rxq
operator|->
name|nid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|nm_kring_pending_off
argument_list|(
name|kring
argument_list|)
operator|||
name|nm_rxq
operator|->
name|iq_cntxt_id
operator|==
name|INVALID_NM_RXQ_CNTXT_ID
condition|)
continue|continue;
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|irq
operator|->
name|nm_state
argument_list|,
name|NM_ON
argument_list|,
name|NM_OFF
argument_list|)
condition|)
name|pause
argument_list|(
literal|"nmst"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_nm_rxq_hwq
argument_list|(
name|vi
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4nmreg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|on
condition|)
name|rc
operator|=
name|cxgbe_netmap_on
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|cxgbe_netmap_off
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How many packets can a single type1 WR carry in n descriptors */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ndesc_to_npkt
parameter_list|(
specifier|const
name|int
name|n
parameter_list|)
block|{
name|MPASS
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<=
name|SGE_MAX_WR_NDESC
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|*
literal|2
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_NPKT_IN_TYPE1_WR
value|(ndesc_to_npkt(SGE_MAX_WR_NDESC))
end_define

begin_comment
comment|/* Space (in descriptors) needed for a type1 WR that carries n packets */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|npkt_to_ndesc
parameter_list|(
specifier|const
name|int
name|n
parameter_list|)
block|{
name|MPASS
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<=
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|n
operator|+
literal|2
operator|)
operator|/
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Space (in 16B units) needed for a type1 WR that carries n packets */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|npkt_to_len16
parameter_list|(
specifier|const
name|int
name|n
parameter_list|)
block|{
name|MPASS
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<=
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|*
literal|2
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NMIDXDIFF
parameter_list|(
name|q
parameter_list|,
name|idx
parameter_list|)
value|IDXDIFF((q)->pidx, (q)->idx, (q)->sidx)
end_define

begin_function
specifier|static
name|void
name|ring_nm_txq_db
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|u_int
name|db
init|=
name|nm_txq
operator|->
name|doorbells
decl_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|pidx
operator|!=
name|nm_txq
operator|->
name|dbidx
argument_list|)
expr_stmt|;
name|n
operator|=
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|dbidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|clrbit
argument_list|(
operator|&
name|db
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffs
argument_list|(
name|db
argument_list|)
operator|-
literal|1
condition|)
block|{
case|case
name|DOORBELL_UDB
case|:
operator|*
name|nm_txq
operator|->
name|udb
operator|=
name|htole32
argument_list|(
name|V_QID
argument_list|(
name|nm_txq
operator|->
name|udb_qid
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOORBELL_WCWR
case|:
block|{
specifier|volatile
name|uint64_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
comment|/* 		 * Queues whose 128B doorbell segment fits in the page do not 		 * use relative qid (udb_qid is always 0).  Only queues with 		 * doorbell segments can do WCWR. 		 */
name|KASSERT
argument_list|(
name|nm_txq
operator|->
name|udb_qid
operator|==
literal|0
operator|&&
name|n
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: inappropriate doorbell (0x%x, %d, %d) for nm_txq %p"
operator|,
name|__func__
operator|,
name|nm_txq
operator|->
name|doorbells
operator|,
name|n
operator|,
name|nm_txq
operator|->
name|pidx
operator|,
name|nm_txq
operator|)
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|nm_txq
operator|->
name|udb
operator|+
name|UDBS_WR_OFFSET
operator|-
name|UDBS_DB_OFFSET
operator|)
expr_stmt|;
name|src
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|dbidx
index|]
expr_stmt|;
while|while
condition|(
name|src
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|dbidx
operator|+
literal|1
index|]
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DOORBELL_UDBWC
case|:
operator|*
name|nm_txq
operator|->
name|udb
operator|=
name|htole32
argument_list|(
name|V_QID
argument_list|(
name|nm_txq
operator|->
name|udb_qid
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
break|break;
case|case
name|DOORBELL_KDB
case|:
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|V_QID
argument_list|(
name|nm_txq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|nm_txq
operator|->
name|dbidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|lazy_tx_credit_flush
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write work requests to send 'npkt' frames and ring the doorbell to send them  * on their way.  No need to check for wraparound.  */
end_comment

begin_function
specifier|static
name|void
name|cxgbe_nm_tx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|npkt
parameter_list|,
name|int
name|npkt_remaining
parameter_list|,
name|int
name|txcsum
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
specifier|const
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
name|wr
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|pidx
index|]
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint64_t
name|ba
decl_stmt|;
name|struct
name|cpl_tx_pkt_core
modifier|*
name|cpl
decl_stmt|;
name|struct
name|ulptx_sgl
modifier|*
name|usgl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
while|while
condition|(
name|npkt
condition|)
block|{
name|n
operator|=
name|min
argument_list|(
name|npkt
argument_list|,
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|pidx
index|]
expr_stmt|;
name|wr
operator|->
name|op_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKTS_WR
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
name|npkt_to_len16
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|npkt
operator|=
name|n
expr_stmt|;
name|wr
operator|->
name|r3
operator|=
literal|0
expr_stmt|;
name|wr
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|kring
operator|->
name|nr_hwcur
index|]
expr_stmt|;
name|PNMB
argument_list|(
name|kring
operator|->
name|na
argument_list|,
name|slot
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ba
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|ctrl0
operator|=
name|nm_txq
operator|->
name|cpl_ctrl0
expr_stmt|;
name|cpl
operator|->
name|pack
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 			 * netmap(4) says "netmap does not use features such as 			 * checksum offloading, TCP segmentation offloading, 			 * encryption, VLAN encapsulation/decapsulation, etc." 			 * 			 * So the ncxl interfaces have tx hardware checksumming 			 * disabled by default.  But you can override netmap by 			 * enabling IFCAP_TXCSUM on the interface manully. 			 */
name|cpl
operator|->
name|ctrl1
operator|=
name|txcsum
condition|?
literal|0
else|:
name|htobe64
argument_list|(
name|F_TXPKT_IPCSUM_DIS
operator||
name|F_TXPKT_L4CSUM_DIS
argument_list|)
expr_stmt|;
name|usgl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
name|usgl
operator|->
name|cmd_nsge
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_DSGL
argument_list|)
operator||
name|V_ULPTX_NSGE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|len0
operator|=
name|htobe32
argument_list|(
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|addr0
operator|=
name|htobe64
argument_list|(
name|ba
argument_list|)
expr_stmt|;
name|slot
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NS_REPORT
operator||
name|NS_BUF_CHANGED
operator|)
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|usgl
operator|+
literal|1
operator|)
expr_stmt|;
name|MPASS
argument_list|(
name|slot
operator|->
name|len
operator|+
name|len
operator|<=
name|UINT16_MAX
argument_list|)
expr_stmt|;
name|len
operator|+=
name|slot
operator|->
name|len
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|wr
operator|->
name|plen
operator|=
name|htobe16
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|npkt
operator|-=
name|n
expr_stmt|;
name|nm_txq
operator|->
name|pidx
operator|+=
name|npkt_to_ndesc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|pidx
operator|<=
name|nm_txq
operator|->
name|sidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|nm_txq
operator|->
name|pidx
operator|==
name|nm_txq
operator|->
name|sidx
argument_list|)
condition|)
block|{
comment|/* 			 * This routine doesn't know how to write WRs that wrap 			 * around.  Make sure it wasn't asked to. 			 */
name|MPASS
argument_list|(
name|npkt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|npkt
operator|==
literal|0
operator|&&
name|npkt_remaining
operator|==
literal|0
condition|)
block|{
comment|/* All done. */
if|if
condition|(
name|lazy_tx_credit_flush
operator|==
literal|0
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
operator||
name|F_FW_WR_EQUIQ
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
name|nm_txq
operator|->
name|equiqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
name|ring_nm_txq_db
argument_list|(
name|sc
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|equiqidx
argument_list|)
operator|>=
name|nm_txq
operator|->
name|sidx
operator|/
literal|2
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
operator||
name|F_FW_WR_EQUIQ
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
name|nm_txq
operator|->
name|equiqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|equeqidx
argument_list|)
operator|>=
literal|64
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
if|if
condition|(
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|dbidx
argument_list|)
operator|>=
literal|2
operator|*
name|SGE_MAX_WR_NDESC
condition|)
name|ring_nm_txq_db
argument_list|(
name|sc
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
block|}
comment|/* Will get called again. */
name|MPASS
argument_list|(
name|npkt_remaining
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How many contiguous free descriptors starting at pidx */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|contiguous_ndesc_available
parameter_list|(
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
if|if
condition|(
name|nm_txq
operator|->
name|cidx
operator|>
name|nm_txq
operator|->
name|pidx
condition|)
return|return
operator|(
name|nm_txq
operator|->
name|cidx
operator|-
name|nm_txq
operator|->
name|pidx
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|nm_txq
operator|->
name|cidx
operator|>
literal|0
condition|)
return|return
operator|(
name|nm_txq
operator|->
name|sidx
operator|-
name|nm_txq
operator|->
name|pidx
operator|)
return|;
else|else
return|return
operator|(
name|nm_txq
operator|->
name|sidx
operator|-
name|nm_txq
operator|->
name|pidx
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reclaim_nm_tx_desc
parameter_list|(
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|struct
name|sge_qstat
modifier|*
name|spg
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|sidx
index|]
decl_stmt|;
name|uint16_t
name|hw_cidx
init|=
name|spg
operator|->
name|cidx
decl_stmt|;
comment|/* snapshot */
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
name|wr
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|hw_cidx
operator|=
name|be16toh
argument_list|(
name|hw_cidx
argument_list|)
expr_stmt|;
while|while
condition|(
name|nm_txq
operator|->
name|cidx
operator|!=
name|hw_cidx
condition|)
block|{
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|cidx
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|op_pkd
operator|==
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKTS_WR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|type
operator|==
literal|1
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|npkt
operator|>
literal|0
operator|&&
name|wr
operator|->
name|npkt
operator|<=
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
name|n
operator|+=
name|wr
operator|->
name|npkt
expr_stmt|;
name|nm_txq
operator|->
name|cidx
operator|+=
name|npkt_to_ndesc
argument_list|(
name|wr
operator|->
name|npkt
argument_list|)
expr_stmt|;
comment|/* 		 * We never sent a WR that wrapped around so the credits coming 		 * back, WR by WR, should never cause the cidx to wrap around 		 * either. 		 */
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|cidx
operator|<=
name|nm_txq
operator|->
name|sidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|nm_txq
operator|->
name|cidx
operator|==
name|nm_txq
operator|->
name|sidx
argument_list|)
condition|)
name|nm_txq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|nm_txq
index|[
name|vi
operator|->
name|first_nm_txq
operator|+
name|kring
operator|->
name|ring_id
index|]
decl_stmt|;
specifier|const
name|u_int
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
name|reclaimed
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|d
decl_stmt|,
name|npkt_remaining
decl_stmt|,
name|ndesc_remaining
decl_stmt|,
name|txcsum
decl_stmt|;
comment|/* 	 * Tx was at kring->nr_hwcur last time around and now we need to advance 	 * to kring->rhead.  Note that the driver's pidx moves independent of 	 * netmap's kring->nr_hwcur (pidx counts descriptors and the relation 	 * between descriptors and frames isn't 1:1). 	 */
name|npkt_remaining
operator|=
name|head
operator|>=
name|kring
operator|->
name|nr_hwcur
condition|?
name|head
operator|-
name|kring
operator|->
name|nr_hwcur
else|:
name|kring
operator|->
name|nkr_num_slots
operator|-
name|kring
operator|->
name|nr_hwcur
operator|+
name|head
expr_stmt|;
name|txcsum
operator|=
name|ifp
operator|->
name|if_capenable
operator|&
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TXCSUM_IPV6
operator|)
expr_stmt|;
while|while
condition|(
name|npkt_remaining
condition|)
block|{
name|reclaimed
operator|+=
name|reclaim_nm_tx_desc
argument_list|(
name|nm_txq
argument_list|)
expr_stmt|;
name|ndesc_remaining
operator|=
name|contiguous_ndesc_available
argument_list|(
name|nm_txq
argument_list|)
expr_stmt|;
comment|/* Can't run out of descriptors with packets still remaining */
name|MPASS
argument_list|(
name|ndesc_remaining
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* # of desc needed to tx all remaining packets */
name|d
operator|=
operator|(
name|npkt_remaining
operator|/
name|MAX_NPKT_IN_TYPE1_WR
operator|)
operator|*
name|SGE_MAX_WR_NDESC
expr_stmt|;
if|if
condition|(
name|npkt_remaining
operator|%
name|MAX_NPKT_IN_TYPE1_WR
condition|)
name|d
operator|+=
name|npkt_to_ndesc
argument_list|(
name|npkt_remaining
operator|%
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<=
name|ndesc_remaining
condition|)
name|n
operator|=
name|npkt_remaining
expr_stmt|;
else|else
block|{
comment|/* Can't send all, calculate how many can be sent */
name|n
operator|=
operator|(
name|ndesc_remaining
operator|/
name|SGE_MAX_WR_NDESC
operator|)
operator|*
name|MAX_NPKT_IN_TYPE1_WR
expr_stmt|;
if|if
condition|(
name|ndesc_remaining
operator|%
name|SGE_MAX_WR_NDESC
condition|)
name|n
operator|+=
name|ndesc_to_npkt
argument_list|(
name|ndesc_remaining
operator|%
name|SGE_MAX_WR_NDESC
argument_list|)
expr_stmt|;
block|}
comment|/* Send n packets and update nm_txq->pidx and kring->nr_hwcur */
name|npkt_remaining
operator|-=
name|n
expr_stmt|;
name|cxgbe_nm_tx
argument_list|(
name|sc
argument_list|,
name|nm_txq
argument_list|,
name|kring
argument_list|,
name|n
argument_list|,
name|npkt_remaining
argument_list|,
name|txcsum
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|npkt_remaining
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|kring
operator|->
name|nr_hwcur
operator|==
name|head
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|dbidx
operator|==
name|nm_txq
operator|->
name|pidx
argument_list|)
expr_stmt|;
comment|/* 	 * Second part: reclaim buffers for completed transmissions. 	 */
if|if
condition|(
name|reclaimed
operator|||
name|flags
operator|&
name|NAF_FORCE_RECLAIM
operator|||
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|reclaimed
operator|+=
name|reclaim_nm_tx_desc
argument_list|(
name|nm_txq
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|+=
name|reclaimed
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
name|kring
operator|->
name|nr_hwtail
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|nm_rxq
index|[
name|vi
operator|->
name|first_nm_rxq
operator|+
name|kring
operator|->
name|ring_id
index|]
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|int
name|force_update
init|=
operator|(
name|flags
operator|&
name|NAF_FORCE_READ
operator|)
operator|||
name|kring
operator|->
name|nr_kflags
operator|&
name|NKR_PENDINTR
decl_stmt|;
if|if
condition|(
name|black_hole
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No updates ever. */
if|if
condition|(
name|netmap_no_pendintr
operator|||
name|force_update
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
block|}
comment|/* Userspace done with buffers from kring->nr_hwcur to head */
name|n
operator|=
name|head
operator|>=
name|kring
operator|->
name|nr_hwcur
condition|?
name|head
operator|-
name|kring
operator|->
name|nr_hwcur
else|:
name|kring
operator|->
name|nkr_num_slots
operator|-
name|kring
operator|->
name|nr_hwcur
operator|+
name|head
expr_stmt|;
name|n
operator|&=
operator|~
literal|7U
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|u_int
name|fl_pidx
init|=
name|nm_rxq
operator|->
name|fl_pidx
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|fl_pidx
index|]
decl_stmt|;
name|uint64_t
name|ba
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dbinc
init|=
literal|0
decl_stmt|,
name|hwidx
init|=
name|nm_rxq
operator|->
name|fl_hwidx
decl_stmt|;
comment|/* 		 * We always deal with 8 buffers at a time.  We must have 		 * stopped at an 8B boundary (fl_pidx) last time around and we 		 * must have a multiple of 8B buffers to give to the freelist. 		 */
name|MPASS
argument_list|(
operator|(
name|fl_pidx
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|n
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|IDXINCR
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|n
argument_list|,
name|kring
operator|->
name|nkr_num_slots
argument_list|)
expr_stmt|;
name|IDXINCR
argument_list|(
name|nm_rxq
operator|->
name|fl_pidx
argument_list|,
name|n
argument_list|,
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|fl_pidx
operator|++
operator|,
name|slot
operator|++
control|)
block|{
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ba
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_desc
index|[
name|fl_pidx
index|]
operator|=
name|htobe64
argument_list|(
name|ba
operator||
name|hwidx
argument_list|)
expr_stmt|;
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|MPASS
argument_list|(
name|fl_pidx
operator|<=
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
block|}
name|n
operator|-=
literal|8
expr_stmt|;
if|if
condition|(
name|fl_pidx
operator|==
name|nm_rxq
operator|->
name|fl_sidx
condition|)
block|{
name|fl_pidx
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|dbinc
operator|==
literal|8
operator|&&
name|n
operator|>=
literal|32
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|dbinc
argument_list|)
argument_list|)
expr_stmt|;
name|dbinc
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|fl_pidx
operator|==
name|fl_pidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbinc
operator|>
literal|0
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|dbinc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxgbe_nm_attach
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|netmap_adapter
name|na
decl_stmt|;
name|MPASS
argument_list|(
name|vi
operator|->
name|nnmrxq
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|vi
operator|->
name|ifp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pi
operator|=
name|vi
operator|->
name|pi
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|na
argument_list|,
sizeof|sizeof
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|.
name|ifp
operator|=
name|vi
operator|->
name|ifp
expr_stmt|;
name|na
operator|.
name|na_flags
operator|=
name|NAF_BDG_MAYSLEEP
expr_stmt|;
comment|/* Netmap doesn't know about the space reserved for the status page. */
name|na
operator|.
name|num_tx_desc
operator|=
name|vi
operator|->
name|qsize_txq
operator|-
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|EQ_ESIZE
expr_stmt|;
comment|/* 	 * The freelist's cidx/pidx drives netmap's rx cidx/pidx.  So 	 * num_rx_desc is based on the number of buffers that can be held in the 	 * freelist, and not the number of entries in the iq.  (These two are 	 * not exactly the same due to the space taken up by the status page). 	 */
name|na
operator|.
name|num_rx_desc
operator|=
name|rounddown
argument_list|(
name|vi
operator|->
name|qsize_rxq
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|na
operator|.
name|nm_txsync
operator|=
name|cxgbe_netmap_txsync
expr_stmt|;
name|na
operator|.
name|nm_rxsync
operator|=
name|cxgbe_netmap_rxsync
expr_stmt|;
name|na
operator|.
name|nm_register
operator|=
name|cxgbe_netmap_reg
expr_stmt|;
name|na
operator|.
name|num_tx_rings
operator|=
name|vi
operator|->
name|nnmtxq
expr_stmt|;
name|na
operator|.
name|num_rx_rings
operator|=
name|vi
operator|->
name|nnmrxq
expr_stmt|;
name|netmap_attach
argument_list|(
operator|&
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgbe_nm_detach
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|MPASS
argument_list|(
name|vi
operator|->
name|nnmrxq
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|vi
operator|->
name|ifp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|netmap_detach
argument_list|(
name|vi
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|void
modifier|*
name|unwrap_nm_fw6_msg
parameter_list|(
specifier|const
name|struct
name|cpl_fw6_msg
modifier|*
name|cpl
parameter_list|)
block|{
name|MPASS
argument_list|(
name|cpl
operator|->
name|type
operator|==
name|FW_TYPE_RSSCPL
operator|||
name|cpl
operator|->
name|type
operator|==
name|FW6_TYPE_RSSCPL
argument_list|)
expr_stmt|;
comment|/* data[0] is RSS header */
return|return
operator|(
operator|&
name|cpl
operator|->
name|data
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_nm_sge_egr_update
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|cpl_sge_egr_update
modifier|*
name|egr
parameter_list|)
block|{
name|uint32_t
name|oq
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
name|oq
operator|=
name|be32toh
argument_list|(
name|egr
operator|->
name|opcode_qid
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|G_CPL_OPCODE
argument_list|(
name|oq
argument_list|)
operator|==
name|CPL_SGE_EGR_UPDATE
argument_list|)
expr_stmt|;
name|nm_txq
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|G_EGR_QID
argument_list|(
name|oq
argument_list|)
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
index|]
expr_stmt|;
name|netmap_tx_irq
argument_list|(
name|ifp
argument_list|,
name|nm_txq
operator|->
name|nid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_nm_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
init|=
name|arg
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|nm_rxq
operator|->
name|vi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vi
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|nm_rxq
operator|->
name|nid
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|iq_desc
modifier|*
name|d
init|=
operator|&
name|nm_rxq
operator|->
name|iq_desc
index|[
name|nm_rxq
operator|->
name|iq_cidx
index|]
decl_stmt|;
specifier|const
name|void
modifier|*
name|cpl
decl_stmt|;
name|uint32_t
name|lq
decl_stmt|;
name|u_int
name|n
init|=
literal|0
decl_stmt|,
name|work
init|=
literal|0
decl_stmt|;
name|uint8_t
name|opcode
decl_stmt|;
name|uint32_t
name|fl_cidx
init|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|)
decl_stmt|;
name|u_int
name|fl_credits
init|=
name|fl_cidx
operator|&
literal|7
decl_stmt|;
while|while
condition|(
operator|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
operator|&
name|F_RSPD_GEN
operator|)
operator|==
name|nm_rxq
operator|->
name|iq_gen
condition|)
block|{
name|rmb
argument_list|()
expr_stmt|;
name|lq
operator|=
name|be32toh
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|pldbuflen_qid
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|d
operator|->
name|rss
operator|.
name|opcode
expr_stmt|;
name|cpl
operator|=
operator|&
name|d
operator|->
name|cpl
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|G_RSPD_TYPE
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
argument_list|)
condition|)
block|{
case|case
name|X_RSPD_TYPE_FLBUF
case|:
if|if
condition|(
name|black_hole
operator|!=
literal|2
condition|)
block|{
comment|/* No buffer packing so new buf every time */
name|MPASS
argument_list|(
name|lq
operator|&
name|F_RSPD_NEWBUF
argument_list|)
expr_stmt|;
block|}
comment|/* fall through */
case|case
name|X_RSPD_TYPE_CPL
case|:
name|MPASS
argument_list|(
name|opcode
operator|<
name|NUM_CPL_CMDS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CPL_FW4_MSG
case|:
case|case
name|CPL_FW6_MSG
case|:
name|cpl
operator|=
name|unwrap_nm_fw6_msg
argument_list|(
name|cpl
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|CPL_SGE_EGR_UPDATE
case|:
name|handle_nm_sge_egr_update
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|cpl
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPL_RX_PKT
case|:
name|ring
operator|->
name|slot
index|[
name|fl_cidx
index|]
operator|.
name|len
operator|=
name|G_RSPD_LEN
argument_list|(
name|lq
argument_list|)
operator|-
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|fl_pktshift
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|fl_cidx
index|]
operator|.
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
name|fl_cidx
operator|+=
operator|(
name|lq
operator|&
name|F_RSPD_NEWBUF
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|fl_credits
operator|+=
operator|(
name|lq
operator|&
name|F_RSPD_NEWBUF
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|fl_cidx
operator|==
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
condition|)
name|fl_cidx
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unexpected opcode 0x%x on nm_rxq %p"
argument_list|,
name|__func__
argument_list|,
name|opcode
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|X_RSPD_TYPE_INTR
case|:
comment|/* Not equipped to handle forwarded interrupts. */
name|panic
argument_list|(
literal|"%s: netmap queue received interrupt for iq %u\n"
argument_list|,
name|__func__
argument_list|,
name|lq
argument_list|)
expr_stmt|;
default|default:
name|panic
argument_list|(
literal|"%s: illegal response type %d on nm_rxq %p"
argument_list|,
name|__func__
argument_list|,
name|G_RSPD_TYPE
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
argument_list|)
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|nm_rxq
operator|->
name|iq_cidx
operator|==
name|nm_rxq
operator|->
name|iq_sidx
argument_list|)
condition|)
block|{
name|nm_rxq
operator|->
name|iq_cidx
operator|=
literal|0
expr_stmt|;
name|d
operator|=
operator|&
name|nm_rxq
operator|->
name|iq_desc
index|[
literal|0
index|]
expr_stmt|;
name|nm_rxq
operator|->
name|iq_gen
operator|^=
name|F_RSPD_GEN
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|n
operator|==
name|rx_ndesc
argument_list|)
condition|)
block|{
name|atomic_store_rel_32
argument_list|(
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|,
name|fl_cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|black_hole
operator|&&
name|fl_credits
operator|>=
literal|8
condition|)
block|{
name|fl_credits
operator|/=
literal|8
expr_stmt|;
name|IDXINCR
argument_list|(
name|nm_rxq
operator|->
name|fl_pidx
argument_list|,
name|fl_credits
operator|*
literal|8
argument_list|,
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|fl_credits
argument_list|)
argument_list|)
expr_stmt|;
name|fl_credits
operator|=
name|fl_cidx
operator|&
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|black_hole
condition|)
block|{
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|nm_rxq
operator|->
name|nid
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|work
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_gts_reg
argument_list|,
name|V_CIDXINC
argument_list|(
name|n
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|X_TIMERREG_UPDATE_CIDX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|atomic_store_rel_32
argument_list|(
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|,
name|fl_cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|black_hole
condition|)
block|{
name|fl_credits
operator|/=
literal|8
expr_stmt|;
name|IDXINCR
argument_list|(
name|nm_rxq
operator|->
name|fl_pidx
argument_list|,
name|fl_credits
operator|*
literal|8
argument_list|,
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|fl_credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|nm_rxq
operator|->
name|nid
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_gts_reg
argument_list|,
name|V_CIDXINC
argument_list|(
name|n
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
operator|(
name|u32
operator|)
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|holdoff_tmr_idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

