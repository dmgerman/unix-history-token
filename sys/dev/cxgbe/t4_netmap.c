begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|fl_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXXNM */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|spg_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXXNM */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fl_pktshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXXNM */
end_comment

begin_comment
comment|/* netmap ifnet routines */
end_comment

begin_function_decl
specifier|static
name|void
name|cxgbe_nm_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_nm_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_nm_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_nm_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_nm_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_nm_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|cxgbe_nm_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4nminit"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|cxgbe_nm_init_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_nm_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|nm_ifp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already running */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|adapter_full_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
if|if
condition|(
operator|!
operator|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|port_full_init
argument_list|(
name|pi
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_nm_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|nm_ifp
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_nm_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|mtu
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|MPASS
argument_list|(
name|pi
operator|->
name|nm_ifp
operator|==
name|ifp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4nmtu"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_MTU
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4nflg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|pi
operator|->
name|nmif_flags
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_PROMISC
operator||
name|XGMAC_ALLMULTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|rc
operator|=
name|cxgbe_nm_init_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|nmif_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|cxgbe_nm_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* these two are called with a mutex held :-( */
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|HOLD_LOCK
argument_list|,
literal|"t4nmulti"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_MCADDRS
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|pi
operator|->
name|nm_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_nm_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_nm_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_nm_rxq_hwq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|__be32
name|v
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|pi
operator|->
name|nm_ifp
argument_list|)
decl_stmt|;
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|MPASS
argument_list|(
name|na
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|iq_desc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|fl_desc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nm_rxq
operator|->
name|iq_desc
argument_list|,
name|pi
operator|->
name|qsize_rxq
operator|*
name|IQ_ESIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nm_rxq
operator|->
name|fl_desc
argument_list|,
name|na
operator|->
name|num_rx_desc
operator|*
name|EQ_ESIZE
operator|+
name|spg_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_IQ_CMD_ALLOC
operator||
name|F_FW_IQ_CMD_IQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|INTR_NM_RXQ
condition|)
block|{
name|KASSERT
argument_list|(
name|nm_rxq
operator|->
name|intr_idx
operator|<
name|sc
operator|->
name|intr_count
argument_list|,
operator|(
literal|"%s: invalid direct intr_idx %d"
operator|,
name|__func__
operator|,
name|nm_rxq
operator|->
name|intr_idx
operator|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|V_FW_IQ_CMD_IQANDSTINDEX
argument_list|(
name|nm_rxq
operator|->
name|intr_idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CXGBE_UNIMPLEMENTED
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXXNM: needs review */
name|v
operator|=
name|V_FW_IQ_CMD_IQANDSTINDEX
argument_list|(
name|nm_rxq
operator|->
name|intr_idx
argument_list|)
operator||
name|F_FW_IQ_CMD_IQANDST
expr_stmt|;
block|}
name|c
operator|.
name|type_to_iqandstindex
operator|=
name|htobe32
argument_list|(
name|v
operator||
name|V_FW_IQ_CMD_TYPE
argument_list|(
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|)
operator||
name|V_FW_IQ_CMD_VIID
argument_list|(
name|pi
operator|->
name|nm_viid
argument_list|)
operator||
name|V_FW_IQ_CMD_IQANUD
argument_list|(
name|X_UPDATEDELIVERY_INTERRUPT
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqdroprss_to_iqesize
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_IQPCIECH
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_IQ_CMD_IQGTSMODE
operator||
name|V_FW_IQ_CMD_IQINTCNTTHRESH
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_IQ_CMD_IQESIZE
argument_list|(
name|ilog2
argument_list|(
name|IQ_ESIZE
argument_list|)
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqsize
operator|=
name|htobe16
argument_list|(
name|pi
operator|->
name|qsize_rxq
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqaddr
operator|=
name|htobe64
argument_list|(
name|nm_rxq
operator|->
name|iq_ba
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqns_to_fl0congen
operator||=
name|htobe32
argument_list|(
name|V_FW_IQ_CMD_FL0HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
operator||
name|F_FW_IQ_CMD_FL0FETCHRO
operator||
name|F_FW_IQ_CMD_FL0DATARO
operator||
operator|(
name|fl_pad
condition|?
name|F_FW_IQ_CMD_FL0PADEN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0dcaen_to_fl0cidxfthresh
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_FL0FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_IQ_CMD_FL0FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0size
operator|=
name|htobe16
argument_list|(
name|na
operator|->
name|num_rx_desc
operator|+
name|spg_len
operator|/
name|EQ_ESIZE
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0addr
operator|=
name|htobe64
argument_list|(
name|nm_rxq
operator|->
name|fl_ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create netmap ingress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|nm_rxq
operator|->
name|iq_cidx
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|iq_sidx
operator|==
name|pi
operator|->
name|qsize_rxq
operator|-
name|spg_len
operator|/
name|IQ_ESIZE
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|iq_gen
operator|=
name|F_RSPD_GEN
expr_stmt|;
name|nm_rxq
operator|->
name|iq_cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|iqid
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|iq_abs_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|physiqid
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|nm_rxq
operator|->
name|iq_cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|iq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|niq
condition|)
block|{
name|panic
argument_list|(
literal|"%s: nm_rxq->iq_cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|niq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sge
operator|.
name|iqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|nm_rxq
expr_stmt|;
name|nm_rxq
operator|->
name|fl_cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|fl0id
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_pidx
operator|=
name|nm_rxq
operator|->
name|fl_cidx
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|fl_sidx
operator|==
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|nm_rxq
operator|->
name|fl_cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
block|{
name|panic
argument_list|(
literal|"%s: nm_rxq->fl_cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|nm_rxq
expr_stmt|;
name|nm_rxq
operator|->
name|fl_db_val
operator|=
name|F_DBPRIO
operator||
name|V_QID
argument_list|(
name|nm_rxq
operator|->
name|fl_cntxt_id
argument_list|)
operator||
name|V_PIDX
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
name|nm_rxq
operator|->
name|fl_db_val
operator||=
name|F_DBTYPE
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_SEINTARM
argument_list|(
name|F_QINTR_CNT_EN
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_nm_rxq_hwq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
operator|-
name|t4_iq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|,
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|,
name|nm_rxq
operator|->
name|fl_cntxt_id
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed for iq %d, fl %d: %d\n"
argument_list|,
name|__func__
argument_list|,
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|,
name|nm_rxq
operator|->
name|fl_cntxt_id
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_nm_txq_hwq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|pi
operator|->
name|nm_ifp
argument_list|)
decl_stmt|;
name|struct
name|fw_eq_eth_cmd
name|c
decl_stmt|;
name|MPASS
argument_list|(
name|na
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|desc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|na
operator|->
name|num_tx_desc
operator|*
name|EQ_ESIZE
operator|+
name|spg_len
expr_stmt|;
name|bzero
argument_list|(
name|nm_txq
operator|->
name|desc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_ETH_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_ETH_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_EQ_ETH_CMD_ALLOC
operator||
name|F_FW_EQ_ETH_CMD_EQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|autoequiqe_to_viid
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_VIID
argument_list|(
name|pi
operator|->
name|nm_viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fetchszm_to_iqid
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_PCIECHN
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_EQ_ETH_CMD_FETCHRO
operator||
name|V_FW_EQ_ETH_CMD_IQID
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|nm_rxq
index|[
name|nm_txq
operator|->
name|iqidx
index|]
operator|.
name|iq_cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|dcaen_to_eqsize
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_EQSIZE
argument_list|(
name|len
operator|/
name|EQ_ESIZE
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqaddr
operator|=
name|htobe64
argument_list|(
name|nm_txq
operator|->
name|ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"failed to create netmap egress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|nm_txq
operator|->
name|cntxt_id
operator|=
name|G_FW_EQ_ETH_CMD_EQID
argument_list|(
name|be32toh
argument_list|(
name|c
operator|.
name|eqid_pkd
argument_list|)
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|nm_txq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
name|panic
argument_list|(
literal|"%s: nm_txq->cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|nm_txq
expr_stmt|;
name|nm_txq
operator|->
name|pidx
operator|=
name|nm_txq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|sidx
operator|==
name|na
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equiqidx
operator|=
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|dbidx
operator|=
literal|0
expr_stmt|;
name|nm_txq
operator|->
name|doorbells
operator|=
name|sc
operator|->
name|doorbells
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
operator|||
name|isset
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDBWC
argument_list|)
operator|||
name|isset
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
condition|)
block|{
name|uint32_t
name|s_qpp
init|=
name|sc
operator|->
name|sge
operator|.
name|eq_s_qpp
decl_stmt|;
name|uint32_t
name|mask
init|=
operator|(
literal|1
operator|<<
name|s_qpp
operator|)
operator|-
literal|1
decl_stmt|;
specifier|volatile
name|uint8_t
modifier|*
name|udb
decl_stmt|;
name|udb
operator|=
name|sc
operator|->
name|udbs_base
operator|+
name|UDBS_DB_OFFSET
expr_stmt|;
name|udb
operator|+=
operator|(
name|nm_txq
operator|->
name|cntxt_id
operator|>>
name|s_qpp
operator|)
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|nm_txq
operator|->
name|udb_qid
operator|=
name|nm_txq
operator|->
name|cntxt_id
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|nm_txq
operator|->
name|udb_qid
operator|>=
name|PAGE_SIZE
operator|/
name|UDBS_SEG_SIZE
condition|)
name|clrbit
argument_list|(
operator|&
name|nm_txq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
else|else
block|{
name|udb
operator|+=
name|nm_txq
operator|->
name|udb_qid
operator|<<
name|UDBS_SEG_SHIFT
expr_stmt|;
name|nm_txq
operator|->
name|udb_qid
operator|=
literal|0
expr_stmt|;
block|}
name|nm_txq
operator|->
name|udb
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|udb
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_nm_txq_hwq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
operator|-
name|t4_eth_eq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|nm_txq
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed for eq %d: %d\n"
argument_list|,
name|__func__
argument_list|,
name|nm_txq
operator|->
name|cntxt_id
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_on
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|hwidx
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|hwb
decl_stmt|;
name|uint16_t
modifier|*
name|rss
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|hwb
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_FLBUF_SIZES
condition|;
name|i
operator|++
operator|,
name|hwb
operator|++
control|)
block|{
if|if
condition|(
name|hwb
operator|->
name|size
operator|==
name|NETMAP_BUF_SIZE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|SGE_FLBUF_SIZES
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"no hwidx for netmap buffer size %d.\n"
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|hwidx
operator|=
name|i
expr_stmt|;
comment|/* Must set caps before calling netmap_reset */
name|na
operator|->
name|na_flags
operator||=
operator|(
name|NAF_NATIVE_ON
operator||
name|NAF_NETMAP_ON
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_NETMAP
expr_stmt|;
name|for_each_nm_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|alloc_nm_rxq_hwq
argument_list|(
name|pi
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_hwidx
operator|=
name|hwidx
expr_stmt|;
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|slot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXXNM: error check, not assert */
comment|/* We deal with 8 bufs at a time */
name|MPASS
argument_list|(
operator|(
name|na
operator|->
name|num_rx_desc
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|na
operator|->
name|num_rx_desc
operator|==
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nm_rxq
operator|->
name|fl_sidx
operator|-
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|uint64_t
name|ba
decl_stmt|;
name|PNMB
argument_list|(
operator|&
name|slot
index|[
name|j
index|]
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_desc
index|[
name|j
index|]
operator|=
name|htobe64
argument_list|(
name|ba
operator||
name|hwidx
argument_list|)
expr_stmt|;
block|}
name|nm_rxq
operator|->
name|fl_pidx
operator|=
name|j
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|j
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|j
operator|/=
literal|8
expr_stmt|;
comment|/* driver pidx to hardware pidx */
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_KDOORBELL
argument_list|)
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|for_each_nm_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|nm_txq
argument_list|)
block|{
name|alloc_nm_txq_hwq
argument_list|(
name|pi
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|slot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXXNM: error check, not assert */
block|}
name|rss
operator|=
name|malloc
argument_list|(
name|pi
operator|->
name|nm_rss_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rss
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|->
name|nm_rss_size
condition|;
control|)
block|{
name|for_each_nm_rxq
argument_list|(
argument|pi
argument_list|,
argument|j
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|rss
index|[
name|i
operator|++
index|]
operator|=
name|nm_rxq
operator|->
name|iq_abs_id
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|pi
operator|->
name|nm_rss_size
condition|)
break|break;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_config_rss_range
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|nm_viid
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|nm_rss_size
argument_list|,
name|rss
argument_list|,
name|pi
operator|->
name|nm_rss_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"netmap rss_config failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rss
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|nm_viid
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"netmap enable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_off
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|nm_viid
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"netmap disable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_flags
operator|&=
operator|~
operator|(
name|NAF_NATIVE_ON
operator||
name|NAF_NETMAP_ON
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_NETMAP
expr_stmt|;
comment|/* 	 * XXXNM: We need to make sure that the tx queues are quiet and won't 	 * request any more SGE_EGR_UPDATEs. 	 */
name|for_each_nm_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|nm_txq
argument_list|)
block|{
name|free_nm_txq_hwq
argument_list|(
name|pi
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
block|}
name|for_each_nm_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|free_nm_rxq_hwq
argument_list|(
name|pi
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4nmreg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|on
condition|)
name|rc
operator|=
name|cxgbe_netmap_on
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|cxgbe_netmap_off
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How many packets can a single type1 WR carry in n descriptors */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ndesc_to_npkt
parameter_list|(
specifier|const
name|int
name|n
parameter_list|)
block|{
name|MPASS
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<=
name|SGE_MAX_WR_NDESC
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|*
literal|2
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_NPKT_IN_TYPE1_WR
value|(ndesc_to_npkt(SGE_MAX_WR_NDESC))
end_define

begin_comment
comment|/* Space (in descriptors) needed for a type1 WR that carries n packets */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|npkt_to_ndesc
parameter_list|(
specifier|const
name|int
name|n
parameter_list|)
block|{
name|MPASS
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<=
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|n
operator|+
literal|2
operator|)
operator|/
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Space (in 16B units) needed for a type1 WR that carries n packets */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|npkt_to_len16
parameter_list|(
specifier|const
name|int
name|n
parameter_list|)
block|{
name|MPASS
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<=
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|*
literal|2
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NMIDXDIFF
parameter_list|(
name|q
parameter_list|,
name|idx
parameter_list|)
value|IDXDIFF((q)->pidx, (q)->idx, (q)->sidx)
end_define

begin_function
specifier|static
name|void
name|ring_nm_txq_db
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|u_int
name|db
init|=
name|nm_txq
operator|->
name|doorbells
decl_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|pidx
operator|!=
name|nm_txq
operator|->
name|dbidx
argument_list|)
expr_stmt|;
name|n
operator|=
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|dbidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|clrbit
argument_list|(
operator|&
name|db
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffs
argument_list|(
name|db
argument_list|)
operator|-
literal|1
condition|)
block|{
case|case
name|DOORBELL_UDB
case|:
operator|*
name|nm_txq
operator|->
name|udb
operator|=
name|htole32
argument_list|(
name|V_QID
argument_list|(
name|nm_txq
operator|->
name|udb_qid
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOORBELL_WCWR
case|:
block|{
specifier|volatile
name|uint64_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
comment|/* 		 * Queues whose 128B doorbell segment fits in the page do not 		 * use relative qid (udb_qid is always 0).  Only queues with 		 * doorbell segments can do WCWR. 		 */
name|KASSERT
argument_list|(
name|nm_txq
operator|->
name|udb_qid
operator|==
literal|0
operator|&&
name|n
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: inappropriate doorbell (0x%x, %d, %d) for nm_txq %p"
operator|,
name|__func__
operator|,
name|nm_txq
operator|->
name|doorbells
operator|,
name|n
operator|,
name|nm_txq
operator|->
name|pidx
operator|,
name|nm_txq
operator|)
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|nm_txq
operator|->
name|udb
operator|+
name|UDBS_WR_OFFSET
operator|-
name|UDBS_DB_OFFSET
operator|)
expr_stmt|;
name|src
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|dbidx
index|]
expr_stmt|;
while|while
condition|(
name|src
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|dbidx
operator|+
literal|1
index|]
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DOORBELL_UDBWC
case|:
operator|*
name|nm_txq
operator|->
name|udb
operator|=
name|htole32
argument_list|(
name|V_QID
argument_list|(
name|nm_txq
operator|->
name|udb_qid
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
break|break;
case|case
name|DOORBELL_KDB
case|:
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_KDOORBELL
argument_list|)
argument_list|,
name|V_QID
argument_list|(
name|nm_txq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|nm_txq
operator|->
name|dbidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|lazy_tx_credit_flush
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write work requests to send 'npkt' frames and ring the doorbell to send them  * on their way.  No need to check for wraparound.  */
end_comment

begin_function
specifier|static
name|void
name|cxgbe_nm_tx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|npkt
parameter_list|,
name|int
name|npkt_remaining
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
specifier|const
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
name|wr
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|pidx
index|]
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint64_t
name|ba
decl_stmt|;
name|struct
name|cpl_tx_pkt_core
modifier|*
name|cpl
decl_stmt|;
name|struct
name|ulptx_sgl
modifier|*
name|usgl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
while|while
condition|(
name|npkt
condition|)
block|{
name|n
operator|=
name|min
argument_list|(
name|npkt
argument_list|,
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|pidx
index|]
expr_stmt|;
name|wr
operator|->
name|op_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKTS_WR
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
name|npkt_to_len16
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|npkt
operator|=
name|n
expr_stmt|;
name|wr
operator|->
name|r3
operator|=
literal|0
expr_stmt|;
name|wr
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|kring
operator|->
name|nr_hwcur
index|]
expr_stmt|;
name|PNMB
argument_list|(
name|slot
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|ctrl0
operator|=
name|nm_txq
operator|->
name|cpl_ctrl0
expr_stmt|;
name|cpl
operator|->
name|pack
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 			 * netmap(4) says "netmap does not use features such as 			 * checksum offloading, TCP segmentation offloading, 			 * encryption, VLAN encapsulation/decapsulation, etc." 			 * 			 * XXXNM: it makes sense to enable checksum offload. 			 */
name|cpl
operator|->
name|ctrl1
operator|=
name|htobe64
argument_list|(
name|F_TXPKT_IPCSUM_DIS
operator||
name|F_TXPKT_L4CSUM_DIS
argument_list|)
expr_stmt|;
name|usgl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
name|usgl
operator|->
name|cmd_nsge
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_DSGL
argument_list|)
operator||
name|V_ULPTX_NSGE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|len0
operator|=
name|htobe32
argument_list|(
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|addr0
operator|=
name|htobe64
argument_list|(
name|ba
argument_list|)
expr_stmt|;
name|slot
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NS_REPORT
operator||
name|NS_BUF_CHANGED
operator|)
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|usgl
operator|+
literal|1
operator|)
expr_stmt|;
name|MPASS
argument_list|(
name|slot
operator|->
name|len
operator|+
name|len
operator|<=
name|UINT16_MAX
argument_list|)
expr_stmt|;
name|len
operator|+=
name|slot
operator|->
name|len
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|wr
operator|->
name|plen
operator|=
name|htobe16
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|npkt
operator|-=
name|n
expr_stmt|;
name|nm_txq
operator|->
name|pidx
operator|+=
name|npkt_to_ndesc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|pidx
operator|<=
name|nm_txq
operator|->
name|sidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|nm_txq
operator|->
name|pidx
operator|==
name|nm_txq
operator|->
name|sidx
argument_list|)
condition|)
block|{
comment|/* 			 * This routine doesn't know how to write WRs that wrap 			 * around.  Make sure it wasn't asked to. 			 */
name|MPASS
argument_list|(
name|npkt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|npkt
operator|==
literal|0
operator|&&
name|npkt_remaining
operator|==
literal|0
condition|)
block|{
comment|/* All done. */
if|if
condition|(
name|lazy_tx_credit_flush
operator|==
literal|0
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
operator||
name|F_FW_WR_EQUIQ
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
name|nm_txq
operator|->
name|equiqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
name|ring_nm_txq_db
argument_list|(
name|sc
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|equiqidx
argument_list|)
operator|>=
name|nm_txq
operator|->
name|sidx
operator|/
literal|2
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
operator||
name|F_FW_WR_EQUIQ
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
name|nm_txq
operator|->
name|equiqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|equeqidx
argument_list|)
operator|>=
literal|64
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
argument_list|)
expr_stmt|;
name|nm_txq
operator|->
name|equeqidx
operator|=
name|nm_txq
operator|->
name|pidx
expr_stmt|;
block|}
if|if
condition|(
name|NMIDXDIFF
argument_list|(
name|nm_txq
argument_list|,
name|dbidx
argument_list|)
operator|>=
literal|2
operator|*
name|SGE_MAX_WR_NDESC
condition|)
name|ring_nm_txq_db
argument_list|(
name|sc
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
block|}
comment|/* Will get called again. */
name|MPASS
argument_list|(
name|npkt_remaining
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How many contiguous free descriptors starting at pidx */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|contiguous_ndesc_available
parameter_list|(
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
if|if
condition|(
name|nm_txq
operator|->
name|cidx
operator|>
name|nm_txq
operator|->
name|pidx
condition|)
return|return
operator|(
name|nm_txq
operator|->
name|cidx
operator|-
name|nm_txq
operator|->
name|pidx
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|nm_txq
operator|->
name|cidx
operator|>
literal|0
condition|)
return|return
operator|(
name|nm_txq
operator|->
name|sidx
operator|-
name|nm_txq
operator|->
name|pidx
operator|)
return|;
else|else
return|return
operator|(
name|nm_txq
operator|->
name|sidx
operator|-
name|nm_txq
operator|->
name|pidx
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reclaim_nm_tx_desc
parameter_list|(
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|struct
name|sge_qstat
modifier|*
name|spg
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|sidx
index|]
decl_stmt|;
name|uint16_t
name|hw_cidx
init|=
name|spg
operator|->
name|cidx
decl_stmt|;
comment|/* snapshot */
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
name|wr
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|hw_cidx
operator|=
name|be16toh
argument_list|(
name|hw_cidx
argument_list|)
expr_stmt|;
while|while
condition|(
name|nm_txq
operator|->
name|cidx
operator|!=
name|hw_cidx
condition|)
block|{
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
index|[
name|nm_txq
operator|->
name|cidx
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|op_pkd
operator|==
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKTS_WR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|type
operator|==
literal|1
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|npkt
operator|>
literal|0
operator|&&
name|wr
operator|->
name|npkt
operator|<=
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
name|n
operator|+=
name|wr
operator|->
name|npkt
expr_stmt|;
name|nm_txq
operator|->
name|cidx
operator|+=
name|npkt_to_ndesc
argument_list|(
name|wr
operator|->
name|npkt
argument_list|)
expr_stmt|;
comment|/* 		 * We never sent a WR that wrapped around so the credits coming 		 * back, WR by WR, should never cause the cidx to wrap around 		 * either. 		 */
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|cidx
operator|<=
name|nm_txq
operator|->
name|sidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|nm_txq
operator|->
name|cidx
operator|==
name|nm_txq
operator|->
name|sidx
argument_list|)
condition|)
name|nm_txq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_txsync
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|nm_txq
index|[
name|pi
operator|->
name|first_nm_txq
operator|+
name|ring_nr
index|]
decl_stmt|;
specifier|const
name|u_int
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
name|reclaimed
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|d
decl_stmt|,
name|npkt_remaining
decl_stmt|,
name|ndesc_remaining
decl_stmt|;
comment|/* 	 * Tx was at kring->nr_hwcur last time around and now we need to advance 	 * to kring->rhead.  Note that the driver's pidx moves independent of 	 * netmap's kring->nr_hwcur (pidx counts descriptors and the relation 	 * between descriptors and frames isn't 1:1). 	 */
name|npkt_remaining
operator|=
name|head
operator|>=
name|kring
operator|->
name|nr_hwcur
condition|?
name|head
operator|-
name|kring
operator|->
name|nr_hwcur
else|:
name|kring
operator|->
name|nkr_num_slots
operator|-
name|kring
operator|->
name|nr_hwcur
operator|+
name|head
expr_stmt|;
while|while
condition|(
name|npkt_remaining
condition|)
block|{
name|reclaimed
operator|+=
name|reclaim_nm_tx_desc
argument_list|(
name|nm_txq
argument_list|)
expr_stmt|;
name|ndesc_remaining
operator|=
name|contiguous_ndesc_available
argument_list|(
name|nm_txq
argument_list|)
expr_stmt|;
comment|/* Can't run out of descriptors with packets still remaining */
name|MPASS
argument_list|(
name|ndesc_remaining
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* # of desc needed to tx all remaining packets */
name|d
operator|=
operator|(
name|npkt_remaining
operator|/
name|MAX_NPKT_IN_TYPE1_WR
operator|)
operator|*
name|SGE_MAX_WR_NDESC
expr_stmt|;
if|if
condition|(
name|npkt_remaining
operator|%
name|MAX_NPKT_IN_TYPE1_WR
condition|)
name|d
operator|+=
name|npkt_to_ndesc
argument_list|(
name|npkt_remaining
operator|%
name|MAX_NPKT_IN_TYPE1_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<=
name|ndesc_remaining
condition|)
name|n
operator|=
name|npkt_remaining
expr_stmt|;
else|else
block|{
comment|/* Can't send all, calculate how many can be sent */
name|n
operator|=
operator|(
name|ndesc_remaining
operator|/
name|SGE_MAX_WR_NDESC
operator|)
operator|*
name|MAX_NPKT_IN_TYPE1_WR
expr_stmt|;
if|if
condition|(
name|ndesc_remaining
operator|%
name|SGE_MAX_WR_NDESC
condition|)
name|n
operator|+=
name|ndesc_to_npkt
argument_list|(
name|ndesc_remaining
operator|%
name|SGE_MAX_WR_NDESC
argument_list|)
expr_stmt|;
block|}
comment|/* Send n packets and update nm_txq->pidx and kring->nr_hwcur */
name|npkt_remaining
operator|-=
name|n
expr_stmt|;
name|cxgbe_nm_tx
argument_list|(
name|sc
argument_list|,
name|nm_txq
argument_list|,
name|kring
argument_list|,
name|n
argument_list|,
name|npkt_remaining
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|npkt_remaining
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|kring
operator|->
name|nr_hwcur
operator|==
name|head
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nm_txq
operator|->
name|dbidx
operator|==
name|nm_txq
operator|->
name|pidx
argument_list|)
expr_stmt|;
comment|/* 	 * Second part: reclaim buffers for completed transmissions. 	 */
if|if
condition|(
name|reclaimed
operator|||
name|flags
operator|&
name|NAF_FORCE_RECLAIM
operator|||
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|reclaimed
operator|+=
name|reclaim_nm_tx_desc
argument_list|(
name|nm_txq
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|+=
name|reclaimed
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
name|kring
operator|->
name|nr_hwtail
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
block|}
name|nm_txsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_netmap_rxsync
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|nm_rxq
index|[
name|pi
operator|->
name|first_nm_rxq
operator|+
name|ring_nr
index|]
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|nm_rxsync_prologue
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|int
name|force_update
init|=
operator|(
name|flags
operator|&
name|NAF_FORCE_READ
operator|)
operator|||
name|kring
operator|->
name|nr_kflags
operator|&
name|NKR_PENDINTR
decl_stmt|;
if|if
condition|(
name|netmap_no_pendintr
operator|||
name|force_update
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
block|}
comment|/* Userspace done with buffers from kring->nr_hwcur to head */
name|n
operator|=
name|head
operator|>=
name|kring
operator|->
name|nr_hwcur
condition|?
name|head
operator|-
name|kring
operator|->
name|nr_hwcur
else|:
name|kring
operator|->
name|nkr_num_slots
operator|-
name|kring
operator|->
name|nr_hwcur
operator|+
name|head
expr_stmt|;
name|n
operator|&=
operator|~
literal|7U
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|u_int
name|fl_pidx
init|=
name|nm_rxq
operator|->
name|fl_pidx
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|fl_pidx
index|]
decl_stmt|;
name|uint64_t
name|ba
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dbinc
init|=
literal|0
decl_stmt|,
name|hwidx
init|=
name|nm_rxq
operator|->
name|fl_hwidx
decl_stmt|;
comment|/* 		 * We always deal with 8 buffers at a time.  We must have 		 * stopped at an 8B boundary (fl_pidx) last time around and we 		 * must have a multiple of 8B buffers to give to the freelist. 		 */
name|MPASS
argument_list|(
operator|(
name|fl_pidx
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|n
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|IDXINCR
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|n
argument_list|,
name|kring
operator|->
name|nkr_num_slots
argument_list|)
expr_stmt|;
name|IDXINCR
argument_list|(
name|nm_rxq
operator|->
name|fl_pidx
argument_list|,
name|n
argument_list|,
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|fl_pidx
operator|++
operator|,
name|slot
operator|++
control|)
block|{
name|PNMB
argument_list|(
name|slot
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
name|nm_rxq
operator|->
name|fl_desc
index|[
name|fl_pidx
index|]
operator|=
name|htobe64
argument_list|(
name|ba
operator||
name|hwidx
argument_list|)
expr_stmt|;
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|MPASS
argument_list|(
name|fl_pidx
operator|<=
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
expr_stmt|;
block|}
name|n
operator|-=
literal|8
expr_stmt|;
if|if
condition|(
name|fl_pidx
operator|==
name|nm_rxq
operator|->
name|fl_sidx
condition|)
block|{
name|fl_pidx
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|dbinc
operator|==
literal|8
operator|&&
name|n
operator|>=
literal|32
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_KDOORBELL
argument_list|)
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|dbinc
argument_list|)
argument_list|)
expr_stmt|;
name|dbinc
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|MPASS
argument_list|(
name|nm_rxq
operator|->
name|fl_pidx
operator|==
name|fl_pidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbinc
operator|>
literal|0
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_KDOORBELL
argument_list|)
argument_list|,
name|nm_rxq
operator|->
name|fl_db_val
operator||
name|V_PIDX
argument_list|(
name|dbinc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|nm_rxsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an ifnet solely for netmap use and register it with the kernel.  */
end_comment

begin_function
name|int
name|create_netmap_ifnet
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|netmap_adapter
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|pi
operator|->
name|dev
decl_stmt|;
name|uint8_t
name|mac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|nnmtxq
operator|<=
literal|0
operator|||
name|pi
operator|->
name|nnmrxq
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|MPASS
argument_list|(
name|pi
operator|->
name|nm_ifp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a virtual interface exclusively for netmap use.  Give it the 	 * MAC address normally reserved for use by a TOE interface.  (The TOE 	 * driver on FreeBSD doesn't use it). 	 */
name|rc
operator|=
name|t4_alloc_vi_func
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|mac
index|[
literal|0
index|]
argument_list|,
operator|&
name|pi
operator|->
name|nm_rss_size
argument_list|,
name|FW_VI_FUNC_OFLD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate netmap virtual "
literal|"interface for port %d: %d\n"
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
operator|-
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|rc
operator|)
return|;
block|}
name|pi
operator|->
name|nm_viid
operator|=
name|rc
expr_stmt|;
name|pi
operator|->
name|nm_xact_addr_filt
operator|=
operator|-
literal|1
expr_stmt|;
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate netmap ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pi
operator|->
name|nm_ifp
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|pi
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|is_t4
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|?
literal|"ncxgbe"
else|:
literal|"ncxl"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgbe_nm_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgbe_nm_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|cxgbe_nm_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|cxgbe_nm_qflush
expr_stmt|;
comment|/* 	 * netmap(4) says "netmap does not use features such as checksum 	 * offloading, TCP segmentation offloading, encryption, VLAN 	 * encapsulation/decapsulation, etc." 	 * 	 * By default we comply with the statement above.  But we do declare the 	 * ifnet capable of L3/L4 checksumming so that a user can override 	 * netmap and have the hardware do the L3/L4 checksums. 	 */
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
operator||
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
comment|/* nm_media has already been setup by the caller */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* 	 * Register with netmap in the kernel. 	 */
name|bzero
argument_list|(
operator|&
name|na
argument_list|,
sizeof|sizeof
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|.
name|ifp
operator|=
name|pi
operator|->
name|nm_ifp
expr_stmt|;
name|na
operator|.
name|na_flags
operator|=
name|NAF_BDG_MAYSLEEP
expr_stmt|;
comment|/* Netmap doesn't know about the space reserved for the status page. */
name|na
operator|.
name|num_tx_desc
operator|=
name|pi
operator|->
name|qsize_txq
operator|-
name|spg_len
operator|/
name|EQ_ESIZE
expr_stmt|;
comment|/* 	 * The freelist's cidx/pidx drives netmap's rx cidx/pidx.  So 	 * num_rx_desc is based on the number of buffers that can be held in the 	 * freelist, and not the number of entries in the iq.  (These two are 	 * not exactly the same due to the space taken up by the status page). 	 */
name|na
operator|.
name|num_rx_desc
operator|=
operator|(
name|pi
operator|->
name|qsize_rxq
operator|/
literal|8
operator|)
operator|*
literal|8
expr_stmt|;
name|na
operator|.
name|nm_txsync
operator|=
name|cxgbe_netmap_txsync
expr_stmt|;
name|na
operator|.
name|nm_rxsync
operator|=
name|cxgbe_netmap_rxsync
expr_stmt|;
name|na
operator|.
name|nm_register
operator|=
name|cxgbe_netmap_reg
expr_stmt|;
name|na
operator|.
name|num_tx_rings
operator|=
name|pi
operator|->
name|nnmtxq
expr_stmt|;
name|na
operator|.
name|num_rx_rings
operator|=
name|pi
operator|->
name|nnmrxq
expr_stmt|;
name|netmap_attach
argument_list|(
operator|&
name|na
argument_list|)
expr_stmt|;
comment|/* This adds IFCAP_NETMAP to if_capabilities */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|destroy_netmap_ifnet
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|nm_ifp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|netmap_detach
argument_list|(
name|pi
operator|->
name|nm_ifp
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|pi
operator|->
name|nm_media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|pi
operator|->
name|nm_ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|pi
operator|->
name|nm_ifp
argument_list|)
expr_stmt|;
name|t4_free_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|nm_viid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_nm_fw6_msg
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|cpl_fw6_msg
modifier|*
name|cpl
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_sge_egr_update
modifier|*
name|egr
decl_stmt|;
name|uint32_t
name|oq
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
if|if
condition|(
name|cpl
operator|->
name|type
operator|!=
name|FW_TYPE_RSSCPL
operator|&&
name|cpl
operator|->
name|type
operator|!=
name|FW6_TYPE_RSSCPL
condition|)
name|panic
argument_list|(
literal|"%s: FW_TYPE 0x%x on nm_rxq."
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* data[0] is RSS header */
name|egr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|cpl
operator|->
name|data
index|[
literal|1
index|]
expr_stmt|;
name|oq
operator|=
name|be32toh
argument_list|(
name|egr
operator|->
name|opcode_qid
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|G_CPL_OPCODE
argument_list|(
name|oq
argument_list|)
operator|==
name|CPL_SGE_EGR_UPDATE
argument_list|)
expr_stmt|;
name|nm_txq
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|G_EGR_QID
argument_list|(
name|oq
argument_list|)
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
index|]
expr_stmt|;
name|netmap_tx_irq
argument_list|(
name|ifp
argument_list|,
name|nm_txq
operator|->
name|nid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_nm_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
init|=
name|arg
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|nm_rxq
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|nm_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|nm_rxq
operator|->
name|nid
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|iq_desc
modifier|*
name|d
init|=
operator|&
name|nm_rxq
operator|->
name|iq_desc
index|[
name|nm_rxq
operator|->
name|iq_cidx
index|]
decl_stmt|;
name|uint32_t
name|lq
decl_stmt|;
name|u_int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|uint8_t
name|opcode
decl_stmt|;
name|uint32_t
name|fl_cidx
init|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
operator|&
name|F_RSPD_GEN
operator|)
operator|==
name|nm_rxq
operator|->
name|iq_gen
condition|)
block|{
name|rmb
argument_list|()
expr_stmt|;
name|lq
operator|=
name|be32toh
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|pldbuflen_qid
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|d
operator|->
name|rss
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|G_RSPD_TYPE
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
argument_list|)
condition|)
block|{
case|case
name|X_RSPD_TYPE_FLBUF
case|:
comment|/* No buffer packing so new buf every time */
name|MPASS
argument_list|(
name|lq
operator|&
name|F_RSPD_NEWBUF
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|X_RSPD_TYPE_CPL
case|:
name|MPASS
argument_list|(
name|opcode
operator|<
name|NUM_CPL_CMDS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CPL_FW4_MSG
case|:
case|case
name|CPL_FW6_MSG
case|:
name|handle_nm_fw6_msg
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|d
operator|->
name|cpl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPL_RX_PKT
case|:
name|ring
operator|->
name|slot
index|[
name|fl_cidx
index|]
operator|.
name|len
operator|=
name|G_RSPD_LEN
argument_list|(
name|lq
argument_list|)
operator|-
name|fl_pktshift
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|fl_cidx
index|]
operator|.
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|fl_cidx
operator|==
name|nm_rxq
operator|->
name|fl_sidx
argument_list|)
condition|)
name|fl_cidx
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unexpected opcode 0x%x on nm_rxq %p"
argument_list|,
name|__func__
argument_list|,
name|opcode
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|X_RSPD_TYPE_INTR
case|:
comment|/* Not equipped to handle forwarded interrupts. */
name|panic
argument_list|(
literal|"%s: netmap queue received interrupt for iq %u\n"
argument_list|,
name|__func__
argument_list|,
name|lq
argument_list|)
expr_stmt|;
default|default:
name|panic
argument_list|(
literal|"%s: illegal response type %d on nm_rxq %p"
argument_list|,
name|__func__
argument_list|,
name|G_RSPD_TYPE
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
argument_list|)
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|nm_rxq
operator|->
name|iq_cidx
operator|==
name|nm_rxq
operator|->
name|iq_sidx
argument_list|)
condition|)
block|{
name|nm_rxq
operator|->
name|iq_cidx
operator|=
literal|0
expr_stmt|;
name|d
operator|=
operator|&
name|nm_rxq
operator|->
name|iq_desc
index|[
literal|0
index|]
expr_stmt|;
name|nm_rxq
operator|->
name|iq_gen
operator|^=
name|F_RSPD_GEN
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|n
operator|==
literal|64
argument_list|)
condition|)
block|{
comment|/* XXXNM: tune */
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|n
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|X_TIMERREG_UPDATE_CIDX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fl_cidx
operator|!=
name|nm_rxq
operator|->
name|fl_cidx
condition|)
block|{
name|atomic_store_rel_32
argument_list|(
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|,
name|fl_cidx
argument_list|)
expr_stmt|;
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|nm_rxq
operator|->
name|nid
argument_list|,
operator|&
name|processed
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|n
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
operator|(
name|u32
operator|)
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|F_QINTR_CNT_EN
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

