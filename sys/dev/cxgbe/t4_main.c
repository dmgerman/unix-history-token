begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"t4_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"t4_l2t.h"
end_include

begin_comment
comment|/* T4 bus driver interface */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|t4_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|t4_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|t4_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|t4_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|t4_driver
init|=
block|{
literal|"t4nex"
block|,
name|t4_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T4 port (cxgbe) interface */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgbe_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgbe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgbe_driver
init|=
block|{
literal|"cxgbe"
block|,
name|cxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|port_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|t4_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|t4_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|t4_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|t4_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|t4_open
block|,
operator|.
name|d_close
operator|=
name|t4_close
block|,
operator|.
name|d_ioctl
operator|=
name|t4_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"t4nex"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T5 bus driver interface */
end_comment

begin_function_decl
specifier|static
name|int
name|t5_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|t5_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|t5_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|t4_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|t4_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|t5_driver
init|=
block|{
literal|"t5nex"
block|,
name|t5_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T5 port (cxl) interface */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|cxl_driver
init|=
block|{
literal|"cxl"
block|,
name|cxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|port_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|t5_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|t4_open
block|,
operator|.
name|d_close
operator|=
name|t4_close
block|,
operator|.
name|d_ioctl
operator|=
name|t4_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"t5nex"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ifnet + media interface */
end_comment

begin_function_decl
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CXGBE
argument_list|,
literal|"cxgbe"
argument_list|,
literal|"Chelsio T4/T5 Ethernet driver and services"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Correct lock order when you need to acquire multiple locks is t4_list_lock,  * then ADAPTER_LOCK, then t4_uld_list_lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|t4_list_lock
decl_stmt|;
end_decl_stmt

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|adapter
argument_list|)
end_macro

begin_expr_stmt
name|t4_list
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sx
name|t4_uld_list_lock
decl_stmt|;
end_decl_stmt

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|uld_info
argument_list|)
end_macro

begin_expr_stmt
name|t4_uld_list
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Tunables.  See tweak_tunables() too.  *  * Each tunable is set to a default value here if it's known at compile-time.  * Otherwise it is set to -1 as an indication to tweak_tunables() that it should  * provide a reasonable default when the driver is loaded.  *  * Tunables applicable to both T4 and T5 are under hw.cxgbe.  Those specific to  * T5 are under hw.cxl.  */
end_comment

begin_comment
comment|/*  * Number of queues for tx and rx, 10G and 1G, NIC and offload.  */
end_comment

begin_define
define|#
directive|define
name|NTXQ_10G
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_ntxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.ntxq10g"
argument_list|,
operator|&
name|t4_ntxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NRXQ_10G
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nrxq10g"
argument_list|,
operator|&
name|t4_nrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NTXQ_1G
value|4
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_ntxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.ntxq1g"
argument_list|,
operator|&
name|t4_ntxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NRXQ_1G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nrxq1g"
argument_list|,
operator|&
name|t4_nrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_rsrv_noflowq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.rsrv_noflowq"
argument_list|,
operator|&
name|t4_rsrv_noflowq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_define
define|#
directive|define
name|NOFLDTXQ_10G
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldtxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldtxq10g"
argument_list|,
operator|&
name|t4_nofldtxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDRXQ_10G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldrxq10g"
argument_list|,
operator|&
name|t4_nofldrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDTXQ_1G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldtxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldtxq1g"
argument_list|,
operator|&
name|t4_nofldtxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDRXQ_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldrxq1g"
argument_list|,
operator|&
name|t4_nofldrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_define
define|#
directive|define
name|NNMTXQ_10G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmtxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmtxq10g"
argument_list|,
operator|&
name|t4_nnmtxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NNMRXQ_10G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmrxq10g"
argument_list|,
operator|&
name|t4_nnmrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NNMTXQ_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmtxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmtxq1g"
argument_list|,
operator|&
name|t4_nnmtxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NNMRXQ_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmrxq1g"
argument_list|,
operator|&
name|t4_nnmrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Holdoff parameters for 10G and 1G ports.  */
end_comment

begin_define
define|#
directive|define
name|TMR_IDX_10G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_tmr_idx_10g
init|=
name|TMR_IDX_10G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_10G"
argument_list|,
operator|&
name|t4_tmr_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PKTC_IDX_10G
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_pktc_idx_10g
init|=
name|PKTC_IDX_10G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_10G"
argument_list|,
operator|&
name|t4_pktc_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TMR_IDX_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_tmr_idx_1g
init|=
name|TMR_IDX_1G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_1G"
argument_list|,
operator|&
name|t4_tmr_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PKTC_IDX_1G
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_pktc_idx_1g
init|=
name|PKTC_IDX_1G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_1G"
argument_list|,
operator|&
name|t4_pktc_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Size (# of entries) of each tx and rx queue.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_qsize_txq
init|=
name|TX_EQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_txq"
argument_list|,
operator|&
name|t4_qsize_txq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_qsize_rxq
init|=
name|RX_IQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_rxq"
argument_list|,
operator|&
name|t4_qsize_rxq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Interrupt types allowed (bits 0, 1, 2 = INTx, MSI, MSI-X respectively).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_intr_types
init|=
name|INTR_MSIX
operator||
name|INTR_MSI
operator||
name|INTR_INTX
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.interrupt_types"
argument_list|,
operator|&
name|t4_intr_types
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Configuration file.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_CF
value|"default"
end_define

begin_define
define|#
directive|define
name|FLASH_CF
value|"flash"
end_define

begin_define
define|#
directive|define
name|UWIRE_CF
value|"uwire"
end_define

begin_define
define|#
directive|define
name|FPGA_CF
value|"fpga"
end_define

begin_decl_stmt
specifier|static
name|char
name|t4_cfg_file
index|[
literal|32
index|]
init|=
name|DEFAULT_CF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
literal|"hw.cxgbe.config_file"
argument_list|,
name|t4_cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|t4_cfg_file
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Firmware auto-install by driver during attach (0, 1, 2 = prohibited, allowed,  * encouraged respectively).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_fw_install
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fw_install"
argument_list|,
operator|&
name|t4_fw_install
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ASIC features that will be used.  Disable the ones you don't want so that the  * chip resources aren't wasted on features that will not be used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_linkcaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* No DCBX, PPP, etc. by default */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.linkcaps_allowed"
argument_list|,
operator|&
name|t4_linkcaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_niccaps_allowed
init|=
name|FW_CAPS_CONFIG_NIC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.niccaps_allowed"
argument_list|,
operator|&
name|t4_niccaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_toecaps_allowed
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.toecaps_allowed"
argument_list|,
operator|&
name|t4_toecaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_rdmacaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.rdmacaps_allowed"
argument_list|,
operator|&
name|t4_rdmacaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_iscsicaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.iscsicaps_allowed"
argument_list|,
operator|&
name|t4_iscsicaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_fcoecaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fcoecaps_allowed"
argument_list|,
operator|&
name|t4_fcoecaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t5_write_combine
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxl.write_combine"
argument_list|,
operator|&
name|t5_write_combine
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|intrs_and_queues
block|{
name|uint16_t
name|intr_type
decl_stmt|;
comment|/* INTx, MSI, or MSI-X */
name|uint16_t
name|nirq
decl_stmt|;
comment|/* Total # of vectors */
name|uint16_t
name|intr_flags_10g
decl_stmt|;
comment|/* Interrupt flags for each 10G port */
name|uint16_t
name|intr_flags_1g
decl_stmt|;
comment|/* Interrupt flags for each 1G port */
name|uint16_t
name|ntxq10g
decl_stmt|;
comment|/* # of NIC txq's for each 10G port */
name|uint16_t
name|nrxq10g
decl_stmt|;
comment|/* # of NIC rxq's for each 10G port */
name|uint16_t
name|ntxq1g
decl_stmt|;
comment|/* # of NIC txq's for each 1G port */
name|uint16_t
name|nrxq1g
decl_stmt|;
comment|/* # of NIC rxq's for each 1G port */
name|uint16_t
name|rsrv_noflowq
decl_stmt|;
comment|/* Flag whether to reserve queue 0 */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|uint16_t
name|nofldtxq10g
decl_stmt|;
comment|/* # of TOE txq's for each 10G port */
name|uint16_t
name|nofldrxq10g
decl_stmt|;
comment|/* # of TOE rxq's for each 10G port */
name|uint16_t
name|nofldtxq1g
decl_stmt|;
comment|/* # of TOE txq's for each 1G port */
name|uint16_t
name|nofldrxq1g
decl_stmt|;
comment|/* # of TOE rxq's for each 1G port */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|uint16_t
name|nnmtxq10g
decl_stmt|;
comment|/* # of netmap txq's for each 10G port */
name|uint16_t
name|nnmrxq10g
decl_stmt|;
comment|/* # of netmap rxq's for each 10G port */
name|uint16_t
name|nnmtxq1g
decl_stmt|;
comment|/* # of netmap txq's for each 1G port */
name|uint16_t
name|nnmrxq1g
decl_stmt|;
comment|/* # of netmap rxq's for each 1G port */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|filter_entry
block|{
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/* filter allocated and valid */
name|uint32_t
name|locked
range|:
literal|1
decl_stmt|;
comment|/* filter is administratively locked */
name|uint32_t
name|pending
range|:
literal|1
decl_stmt|;
comment|/* filter action is pending firmware reply */
name|uint32_t
name|smtidx
range|:
literal|8
decl_stmt|;
comment|/* Source MAC Table index for smac */
name|struct
name|l2t_entry
modifier|*
name|l2t
decl_stmt|;
comment|/* Layer Two Table entry for dmac */
name|struct
name|t4_filter_specification
name|fs
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|map_bars_0_and_4
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_bar_2
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_mem_range
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwmtype_to_hwmtype
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_mt_off_len
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|memwin_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|position_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|partition_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_params__pre_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|ifmedia
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_intr_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_eq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_iq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_iq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_fl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_intr_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_regdump
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_vlan_config
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|an_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fw_msg_not_handled
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|__be64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_bitfield
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_btphy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_noflowq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_temperature
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SBUF_DRAIN
end_ifdef

begin_function_decl
specifier|static
name|int
name|sysctl_cctrl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_ibq_obq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_ma_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_pif_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_qcfg
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cpl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_ddp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_devlog
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_fcoe_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_sched
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_lb_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_linkdnrc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_meminfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_mps_tcam
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_path_mtus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_pm_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_rdma_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tcp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tids
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tp_err_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tp_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tx_rate
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_ulprx_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_wcwr_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|inline
name|void
name|txq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fconf_to_mode
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|mode_to_fconf
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fspec_to_fconf
parameter_list|(
name|struct
name|t4_filter_specification
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint64_t
name|get_filter_hits
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_filter
parameter_list|(
name|struct
name|filter_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_sge_context
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_sge_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_fw
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_card_mem
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|t4_mem_range
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_i2c
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_i2c_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_sched_class
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_sched_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_sched_queue
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_sched_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function_decl
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
block|{
name|uint16_t
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|t4_pciids
index|[]
init|=
block|{
block|{
literal|0xa000
block|,
literal|"Chelsio Terminator 4 FPGA"
block|}
block|,
block|{
literal|0x4400
block|,
literal|"Chelsio T440-dbg"
block|}
block|,
block|{
literal|0x4401
block|,
literal|"Chelsio T420-CR"
block|}
block|,
block|{
literal|0x4402
block|,
literal|"Chelsio T422-CR"
block|}
block|,
block|{
literal|0x4403
block|,
literal|"Chelsio T440-CR"
block|}
block|,
block|{
literal|0x4404
block|,
literal|"Chelsio T420-BCH"
block|}
block|,
block|{
literal|0x4405
block|,
literal|"Chelsio T440-BCH"
block|}
block|,
block|{
literal|0x4406
block|,
literal|"Chelsio T440-CH"
block|}
block|,
block|{
literal|0x4407
block|,
literal|"Chelsio T420-SO"
block|}
block|,
block|{
literal|0x4408
block|,
literal|"Chelsio T420-CX"
block|}
block|,
block|{
literal|0x4409
block|,
literal|"Chelsio T420-BT"
block|}
block|,
block|{
literal|0x440a
block|,
literal|"Chelsio T404-BT"
block|}
block|,
block|{
literal|0x440e
block|,
literal|"Chelsio T440-LP-CR"
block|}
block|, }
struct|,
name|t5_pciids
index|[]
init|=
block|{
block|{
literal|0xb000
block|,
literal|"Chelsio Terminator 5 FPGA"
block|}
block|,
block|{
literal|0x5400
block|,
literal|"Chelsio T580-dbg"
block|}
block|,
block|{
literal|0x5401
block|,
literal|"Chelsio T520-CR"
block|}
block|,
comment|/* 2 x 10G */
block|{
literal|0x5402
block|,
literal|"Chelsio T522-CR"
block|}
block|,
comment|/* 2 x 10G, 2 X 1G */
block|{
literal|0x5403
block|,
literal|"Chelsio T540-CR"
block|}
block|,
comment|/* 4 x 10G */
block|{
literal|0x5407
block|,
literal|"Chelsio T520-SO"
block|}
block|,
comment|/* 2 x 10G, nomem */
block|{
literal|0x5409
block|,
literal|"Chelsio T520-BT"
block|}
block|,
comment|/* 2 x 10GBaseT */
block|{
literal|0x540a
block|,
literal|"Chelsio T504-BT"
block|}
block|,
comment|/* 4 x 1G */
block|{
literal|0x540d
block|,
literal|"Chelsio T580-CR"
block|}
block|,
comment|/* 2 x 40G */
block|{
literal|0x540e
block|,
literal|"Chelsio T540-LP-CR"
block|}
block|,
comment|/* 4 x 10G */
block|{
literal|0x5410
block|,
literal|"Chelsio T580-LP-CR"
block|}
block|,
comment|/* 2 x 40G */
block|{
literal|0x5411
block|,
literal|"Chelsio T520-LL-CR"
block|}
block|,
comment|/* 2 x 10G */
block|{
literal|0x5412
block|,
literal|"Chelsio T560-CR"
block|}
block|,
comment|/* 1 x 40G, 2 x 10G */
block|{
literal|0x5414
block|,
literal|"Chelsio T580-LP-SO-CR"
block|}
block|,
comment|/* 2 x 40G, nomem */
ifdef|#
directive|ifdef
name|notyet
block|{
literal|0x5404
block|,
literal|"Chelsio T520-BCH"
block|}
block|,
block|{
literal|0x5405
block|,
literal|"Chelsio T540-BCH"
block|}
block|,
block|{
literal|0x5406
block|,
literal|"Chelsio T540-CH"
block|}
block|,
block|{
literal|0x5408
block|,
literal|"Chelsio T520-CX"
block|}
block|,
block|{
literal|0x540b
block|,
literal|"Chelsio B520-SR"
block|}
block|,
block|{
literal|0x540c
block|,
literal|"Chelsio B504-BT"
block|}
block|,
block|{
literal|0x540f
block|,
literal|"Chelsio Amsterdam"
block|}
block|,
block|{
literal|0x5413
block|,
literal|"Chelsio T580-CHR"
block|}
block|,
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_comment
comment|/*  * service_iq() has an iq and needs the fl.  Offset of fl from the iq should be  * exactly the same for both rxq and ofld_rxq.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|,
name|iq
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|sge_rxq
argument_list|,
name|iq
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|,
name|fl
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|sge_rxq
argument_list|,
name|fl
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No easy way to include t4_msg.h before adapter.h so we check this way */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|nitems
argument_list|(
operator|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
literal|0
operator|)
operator|->
name|cpl_handler
argument_list|)
operator|==
name|NUM_CPL_CMDS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|nitems
argument_list|(
operator|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
literal|0
operator|)
operator|->
name|fw_msg_handler
argument_list|)
operator|==
name|NUM_FW6_TYPES
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cluster_metadata
argument_list|)
operator|<=
name|CL_METADATA_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|v
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|d
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|f
init|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|PCI_VENDOR_ID_CHELSIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Attach only to PF0 of the FPGA */
if|if
condition|(
name|d
operator|==
literal|0xa000
operator|&&
name|f
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t4_pciids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|==
name|t4_pciids
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t4_pciids
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t5_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|v
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|d
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|f
init|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|PCI_VENDOR_ID_CHELSIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Attach only to PF0 of the FPGA */
if|if
condition|(
name|d
operator|==
literal|0xb000
operator|&&
name|f
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t5_pciids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|==
name|t5_pciids
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t5_pciids
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|n10g
decl_stmt|,
name|n1g
decl_stmt|,
name|rqidx
decl_stmt|,
name|tqidx
decl_stmt|;
name|struct
name|intrs_and_queues
name|iaq
decl_stmt|;
name|struct
name|sge
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|int
name|ofld_rqidx
decl_stmt|,
name|ofld_tqidx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|int
name|nm_rqidx
decl_stmt|,
name|nm_tqidx
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|pcie_ts
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|pci_set_max_read_req
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|i
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|v
operator||=
name|PCIEM_CTL_RELAXED_ORD_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|i
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|traceq
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|ifp_lock
argument_list|,
name|sc
operator|->
name|ifp_lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|ifp_lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ifp_lockname
argument_list|)
argument_list|,
literal|"%s tracer"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|sc
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t4_list
argument_list|,
name|sc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|,
literal|"starving freelists"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sfl
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_bars_0_and_4
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * This is the real PF# to which we're attaching.  Works from within PCI 	 * passthrough environments too, where pci_get_function() could return a 	 * different PF# depending on the passthrough configuration.  We need to 	 * use the real PF# in all our communication with the firmware. 	 */
name|sc
operator|->
name|pf
operator|=
name|G_SOURCEPF
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_WHOAMI
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbox
operator|=
name|sc
operator|->
name|pf
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_handler
operator|=
name|an_not_handled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|cpl_handler
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|cpl_handler
index|[
name|i
index|]
operator|=
name|cpl_not_handled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|fw_msg_handler
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|fw_msg_handler
index|[
name|i
index|]
operator|=
name|fw_msg_not_handled
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_SET_TCB_RPL
argument_list|,
name|t4_filter_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_TRACE_PKT
argument_list|,
name|t4_trace_pkt
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_TRACE_PKT_T5
argument_list|,
name|t5_trace_pkt
argument_list|)
expr_stmt|;
name|t4_init_sge_cpl_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare the adapter for operation */
name|rc
operator|=
operator|-
name|t4_prep_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to prepare adapter: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Do this really early, with the memory windows set up even before the 	 * character device.  The userland tool's register i/o and mem read 	 * will work even in "recovery mode". 	 */
name|setup_memwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|make_dev
argument_list|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
operator|&
name|t4_cdevsw
else|:
operator|&
name|t5_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create nexus char device.\n"
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Go no further if recovery mode has been requested. */
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.cxgbe.sos"
argument_list|,
operator|&
name|i
argument_list|)
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"recovery mode.\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Prepare the firmware for operation */
name|rc
operator|=
name|prep_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|get_params__post_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|set_params__post_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|map_bar_2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|t4_create_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * First pass over all the ports - allocate VIs and initialize some 	 * basic parameters like mac address, port type, etc.  We also figure 	 * out whether a port is 10G or 1G and use that information when 	 * calculating how many interrupts to attempt to allocate. 	 */
name|n10g
operator|=
name|n1g
operator|=
literal|0
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|pi
expr_stmt|;
comment|/* These must be set before t4_port_init */
name|pi
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|pi
operator|->
name|port_id
operator|=
name|i
expr_stmt|;
comment|/* Allocate the vi and initialize parameters like mac addr */
name|rc
operator|=
operator|-
name|t4_port_init
argument_list|(
name|pi
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize port %d: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
operator|-
name|t4_link_start
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
operator|&
name|pi
operator|->
name|link_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"port %d l1cfg failed: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|snprintf
argument_list|(
name|pi
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%sp%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|,
name|pi
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chan_map
index|[
name|pi
operator|->
name|tx_chan
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|n10g
operator|++
expr_stmt|;
name|pi
operator|->
name|tmr_idx
operator|=
name|t4_tmr_idx_10g
expr_stmt|;
name|pi
operator|->
name|pktc_idx
operator|=
name|t4_pktc_idx_10g
expr_stmt|;
block|}
else|else
block|{
name|n1g
operator|++
expr_stmt|;
name|pi
operator|->
name|tmr_idx
operator|=
name|t4_tmr_idx_1g
expr_stmt|;
name|pi
operator|->
name|pktc_idx
operator|=
name|t4_pktc_idx_1g
expr_stmt|;
block|}
name|pi
operator|->
name|xact_addr_filt
operator|=
operator|-
literal|1
expr_stmt|;
name|pi
operator|->
name|linkdnrc
operator|=
operator|-
literal|1
expr_stmt|;
name|pi
operator|->
name|qsize_rxq
operator|=
name|t4_qsize_rxq
expr_stmt|;
name|pi
operator|->
name|qsize_txq
operator|=
name|t4_qsize_txq
expr_stmt|;
name|pi
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
literal|"cxgbe"
else|:
literal|"cxl"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add device for port %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|device_set_softc
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Interrupt type, # of interrupts, # of rx/tx queues, etc. 	 */
name|rc
operator|=
name|cfg_itype_and_nqueues
argument_list|(
name|sc
argument_list|,
name|n10g
argument_list|,
name|n1g
argument_list|,
operator|&
name|iaq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|sc
operator|->
name|intr_type
operator|=
name|iaq
operator|.
name|intr_type
expr_stmt|;
name|sc
operator|->
name|intr_count
operator|=
name|iaq
operator|.
name|nirq
expr_stmt|;
name|s
operator|=
operator|&
name|sc
operator|->
name|sge
expr_stmt|;
name|s
operator|->
name|nrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nrxq1g
expr_stmt|;
name|s
operator|->
name|ntxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|ntxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|ntxq1g
expr_stmt|;
name|s
operator|->
name|neq
operator|=
name|s
operator|->
name|ntxq
operator|+
name|s
operator|->
name|nrxq
expr_stmt|;
comment|/* the free list in an rxq is an eq */
name|s
operator|->
name|neq
operator|+=
name|sc
operator|->
name|params
operator|.
name|nports
operator|+
literal|1
expr_stmt|;
comment|/* ctrl queues: 1 per port + 1 mgmt */
name|s
operator|->
name|niq
operator|=
name|s
operator|->
name|nrxq
operator|+
literal|1
expr_stmt|;
comment|/* 1 extra for firmware event queue */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|s
operator|->
name|nofldrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nofldrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nofldrxq1g
expr_stmt|;
name|s
operator|->
name|nofldtxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nofldtxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nofldtxq1g
expr_stmt|;
name|s
operator|->
name|neq
operator|+=
name|s
operator|->
name|nofldtxq
operator|+
name|s
operator|->
name|nofldrxq
expr_stmt|;
name|s
operator|->
name|niq
operator|+=
name|s
operator|->
name|nofldrxq
expr_stmt|;
name|s
operator|->
name|ofld_rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nofldrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|ofld_txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nofldtxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_wrq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|s
operator|->
name|nnmrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nnmrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nnmrxq1g
expr_stmt|;
name|s
operator|->
name|nnmtxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nnmtxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nnmtxq1g
expr_stmt|;
name|s
operator|->
name|neq
operator|+=
name|s
operator|->
name|nnmtxq
operator|+
name|s
operator|->
name|nnmrxq
expr_stmt|;
name|s
operator|->
name|niq
operator|+=
name|s
operator|->
name|nnmrxq
expr_stmt|;
name|s
operator|->
name|nm_rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nnmrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_nm_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|nm_txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nnmtxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_nm_txq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|ctrlq
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|params
operator|.
name|nports
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_wrq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|ntxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_txq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|iqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|niq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_iq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|eqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|neq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_eq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|intr_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|irq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_init_l2t
argument_list|(
name|sc
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Second pass over the ports.  This time we know the number of rx and 	 * tx queues that each port should get. 	 */
name|rqidx
operator|=
name|tqidx
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|ofld_rqidx
operator|=
name|ofld_tqidx
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|nm_rqidx
operator|=
name|nm_tqidx
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
continue|continue;
name|pi
operator|->
name|first_rxq
operator|=
name|rqidx
expr_stmt|;
name|pi
operator|->
name|first_txq
operator|=
name|tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pi
operator|->
name|flags
operator||=
name|iaq
operator|.
name|intr_flags_10g
expr_stmt|;
name|pi
operator|->
name|nrxq
operator|=
name|iaq
operator|.
name|nrxq10g
expr_stmt|;
name|pi
operator|->
name|ntxq
operator|=
name|iaq
operator|.
name|ntxq10g
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|flags
operator||=
name|iaq
operator|.
name|intr_flags_1g
expr_stmt|;
name|pi
operator|->
name|nrxq
operator|=
name|iaq
operator|.
name|nrxq1g
expr_stmt|;
name|pi
operator|->
name|ntxq
operator|=
name|iaq
operator|.
name|ntxq1g
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|->
name|ntxq
operator|>
literal|1
condition|)
name|pi
operator|->
name|rsrv_noflowq
operator|=
name|iaq
operator|.
name|rsrv_noflowq
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|pi
operator|->
name|rsrv_noflowq
operator|=
literal|0
expr_stmt|;
name|rqidx
operator|+=
name|pi
operator|->
name|nrxq
expr_stmt|;
name|tqidx
operator|+=
name|pi
operator|->
name|ntxq
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|pi
operator|->
name|first_ofld_rxq
operator|=
name|ofld_rqidx
expr_stmt|;
name|pi
operator|->
name|first_ofld_txq
operator|=
name|ofld_tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pi
operator|->
name|nofldrxq
operator|=
name|iaq
operator|.
name|nofldrxq10g
expr_stmt|;
name|pi
operator|->
name|nofldtxq
operator|=
name|iaq
operator|.
name|nofldtxq10g
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|nofldrxq
operator|=
name|iaq
operator|.
name|nofldrxq1g
expr_stmt|;
name|pi
operator|->
name|nofldtxq
operator|=
name|iaq
operator|.
name|nofldtxq1g
expr_stmt|;
block|}
name|ofld_rqidx
operator|+=
name|pi
operator|->
name|nofldrxq
expr_stmt|;
name|ofld_tqidx
operator|+=
name|pi
operator|->
name|nofldtxq
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|pi
operator|->
name|first_nm_rxq
operator|=
name|nm_rqidx
expr_stmt|;
name|pi
operator|->
name|first_nm_txq
operator|=
name|nm_tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pi
operator|->
name|nnmrxq
operator|=
name|iaq
operator|.
name|nnmrxq10g
expr_stmt|;
name|pi
operator|->
name|nnmtxq
operator|=
name|iaq
operator|.
name|nnmtxq10g
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|nnmrxq
operator|=
name|iaq
operator|.
name|nnmrxq1g
expr_stmt|;
name|pi
operator|->
name|nnmtxq
operator|=
name|iaq
operator|.
name|nnmtxq1g
expr_stmt|;
block|}
name|nm_rqidx
operator|+=
name|pi
operator|->
name|nnmrxq
expr_stmt|;
name|nm_tqidx
operator|+=
name|pi
operator|->
name|nnmtxq
expr_stmt|;
endif|#
directive|endif
block|}
name|rc
operator|=
name|setup_intr_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to setup interrupt handlers: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach all child ports: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|speed
condition|)
block|{
case|case
literal|0x1
case|:
name|pcie_ts
operator|=
literal|"2.5"
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|pcie_ts
operator|=
literal|"5.0"
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|pcie_ts
operator|=
literal|"8.0"
expr_stmt|;
break|break;
default|default:
name|pcie_ts
operator|=
literal|"??"
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCIe x%d (%s GTS/s) (%d), %d ports, %d %s interrupt%s, %d eq, %d iq\n"
argument_list|,
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|width
argument_list|,
name|pcie_ts
argument_list|,
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|speed
argument_list|,
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
name|sc
operator|->
name|intr_count
argument_list|,
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSIX
condition|?
literal|"MSI-X"
else|:
operator|(
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSI
condition|?
literal|"MSI"
else|:
literal|"INTx"
operator|)
argument_list|,
name|sc
operator|->
name|intr_count
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|niq
argument_list|)
expr_stmt|;
name|t4_set_desc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|cdev
condition|)
block|{
comment|/* cdev was created and so cxgbetool works; recover that way. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error during attach, adapter is now in recovery mode.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|t4_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
name|t4_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
condition|)
block|{
name|destroy_dev
argument_list|(
name|sc
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|NULL
expr_stmt|;
block|}
name|rc
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to detach child devices: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
name|t4_free_irq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NPORTS
condition|;
name|i
operator|++
control|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
name|t4_free_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|viid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
name|adapter_full_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FW_OK
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSI
operator|||
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSIX
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|regs_rid
argument_list|,
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|udbs_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|udbs_rid
argument_list|,
name|sc
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_rid
argument_list|,
name|sc
operator|->
name|msix_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|l2t
condition|)
name|t4_free_l2t
argument_list|(
name|sc
operator|->
name|l2t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|nm_rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|nm_txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sc
operator|->
name|irq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ctrlq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|iqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|eqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|t4_destroy_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|t4_list
argument_list|,
name|sc
argument_list|,
name|adapter
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|ifp_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|ifp_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"port %d"
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | \     IFCAP_VLAN_HWCSUM | IFCAP_TSO | IFCAP_JUMBO_MTU | IFCAP_LRO | \     IFCAP_VLAN_HWTSO | IFCAP_LINKSTATE | IFCAP_HWCSUM_IPV6 | IFCAP_HWSTATS)
end_define

begin_define
define|#
directive|define
name|T4_CAP_ENABLE
value|(T4_CAP)
end_define

begin_function
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|,
name|o
decl_stmt|;
comment|/* Allocate an ifnet and set it up */
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pi
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|pi
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgbe_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgbe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|cxgbe_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|cxgbe_qflush
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|T4_CAP
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TOE
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_capenable
operator|=
name|T4_CAP_ENABLE
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
expr_stmt|;
comment|/* Initialize ifmedia for this port */
name|ifmedia_init
argument_list|(
operator|&
name|pi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgbe_media_change
argument_list|,
name|cxgbe_media_status
argument_list|)
expr_stmt|;
name|build_medialist
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|media
argument_list|)
expr_stmt|;
name|pi
operator|->
name|vlan_c
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|cxgbe_vlan_config
argument_list|,
name|ifp
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|pi
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
name|n
operator|=
literal|128
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|n
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|o
operator|=
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"%d txq, %d rxq (NIC)"
argument_list|,
name|pi
operator|->
name|ntxq
argument_list|,
name|pi
operator|->
name|nrxq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
name|o
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|)
block|{
name|o
operator|+=
name|snprintf
argument_list|(
name|s
operator|+
name|o
argument_list|,
name|n
operator|-
name|o
argument_list|,
literal|"; %d txq, %d rxq (TOE)"
argument_list|,
name|pi
operator|->
name|nofldtxq
argument_list|,
name|pi
operator|->
name|nofldrxq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
name|o
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|o
operator|+=
name|snprintf
argument_list|(
name|s
operator|+
name|o
argument_list|,
name|n
operator|-
name|o
argument_list|,
literal|"; %d txq, %d rxq (netmap)"
argument_list|,
name|pi
operator|->
name|nnmtxq
argument_list|,
name|pi
operator|->
name|nnmrxq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
name|o
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* nm_media handled here to keep implementation private to this file */
name|ifmedia_init
argument_list|(
operator|&
name|pi
operator|->
name|nm_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgbe_media_change
argument_list|,
name|cxgbe_media_status
argument_list|)
expr_stmt|;
name|build_medialist
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|nm_media
argument_list|)
expr_stmt|;
name|create_netmap_ifnet
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* logs errors it something fails */
endif|#
directive|endif
name|cxgbe_sysctls
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
comment|/* Tell if_ioctl and if_init that the port is going away */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SET_DOOMED
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|0
argument_list|,
literal|"t4detach"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sc
operator|->
name|last_op
operator|=
literal|"t4detach"
expr_stmt|;
name|sc
operator|->
name|last_op_thr
operator|=
name|curthread
expr_stmt|;
endif|#
directive|endif
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|HAS_TRACEQ
condition|)
block|{
name|sc
operator|->
name|traceq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* cloner should not create ifnet */
name|t4_tracer_port_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|->
name|vlan_c
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|pi
operator|->
name|vlan_c
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* Let detach proceed even if these fail. */
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|port_full_uninit
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|pi
operator|->
name|media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* XXXNM: equivalent of cxgbe_uninit_synchronized to ifdown nm_ifp */
name|destroy_netmap_ifnet
argument_list|(
name|pi
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4init"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|cxgbe_init_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|mtu
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4mtu"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
block|{
name|t4_update_fl_bufsize
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_MTU
argument_list|)
expr_stmt|;
block|}
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4flg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|pi
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_PROMISC
operator||
name|XGMAC_ALLMULTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|rc
operator|=
name|cxgbe_init_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* these two are called with a mutex held :-( */
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|HOLD_LOCK
argument_list|,
literal|"t4multi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_MCADDRS
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4cap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso4 disabled due to -txcsum.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso6 disabled due to -txcsum6.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
comment|/* 		 * Note that we leave CSUM_TSO alone (it is always set).  The 		 * kernel takes both IFCAP_TSOx and CSUM_TSO into account before 		 * sending a TSO request our way, so it's sufficient to toggle 		 * IFCAP_TSOx only. 		 */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum first.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum6 first.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
name|rxq
operator|->
name|iq
operator|.
name|flags
operator||=
name|IQ_LRO_ENABLED
expr_stmt|;
else|else
name|rxq
operator|->
name|iq
operator|.
name|flags
operator|&=
operator|~
name|IQ_LRO_ENABLED
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|mask
operator|&
name|IFCAP_TOE
condition|)
block|{
name|int
name|enable
init|=
operator|(
name|ifp
operator|->
name|if_capenable
operator|^
name|mask
operator|)
operator|&
name|IFCAP_TOE
decl_stmt|;
name|rc
operator|=
name|toe_capability
argument_list|(
name|pi
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|mask
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_VLANEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* Need to find out how to disable auto-mtu-inflation */
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
ifdef|#
directive|ifdef
name|VLAN_CAPABILITIES
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fail
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|pi
operator|->
name|media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|txq
index|[
name|pi
operator|->
name|first_txq
index|]
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
operator|==
literal|0
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
name|txq
operator|+=
operator|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
operator|(
name|pi
operator|->
name|ntxq
operator|-
name|pi
operator|->
name|rsrv_noflowq
operator|)
operator|)
operator|+
name|pi
operator|->
name|rsrv_noflowq
operator|)
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|br
expr_stmt|;
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
comment|/* 		 * It is possible that t4_eth_tx finishes up and releases the 		 * lock between the TRYLOCK above and the drbr_enqueue here.  We 		 * need to make sure that this mbuf doesn't just sit there in 		 * the drbr. 		 */
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|callout_pending
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_DOOMED
operator|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|,
literal|1
argument_list|,
name|t4_tx_callout
argument_list|,
name|eq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* 	 * txq->m is the mbuf that is held up due to a temporary shortage of 	 * resources and it should be put on the wire first.  Then what's in 	 * drbr and finally the mbuf that was just passed in to us. 	 * 	 * Return code should indicate the fate of the mbuf that was passed in 	 * this time. 	 */
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|drbr_needs_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
operator|||
name|txq
operator|->
name|m
condition|)
block|{
comment|/* Queued for transmission. */
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|txq
operator|->
name|m
condition|?
name|txq
operator|->
name|m
else|:
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Direct transmission. */
name|rc
operator|=
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|&&
name|txq
operator|->
name|m
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* held, will be transmitted soon (hopefully) */
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* queues do not exist if !PORT_INIT_DONE. */
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
block|{
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txq
operator|->
name|m
argument_list|)
expr_stmt|;
name|txq
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txq
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"%s unimplemented.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|media
init|=
name|NULL
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|cur
decl_stmt|;
name|int
name|speed
init|=
name|pi
operator|->
name|link_cfg
operator|.
name|speed
decl_stmt|;
name|int
name|data
init|=
operator|(
name|pi
operator|->
name|port_type
operator|<<
literal|8
operator|)
operator||
name|pi
operator|->
name|mod_type
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|pi
operator|->
name|ifp
condition|)
name|media
operator|=
operator|&
name|pi
operator|->
name|media
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
elseif|else
if|if
condition|(
name|ifp
operator|==
name|pi
operator|->
name|nm_ifp
condition|)
name|media
operator|=
operator|&
name|pi
operator|->
name|nm_media
expr_stmt|;
endif|#
directive|endif
name|MPASS
argument_list|(
name|media
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cur
operator|=
name|media
operator|->
name|ifm_cur
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|ifm_data
operator|!=
name|data
condition|)
block|{
name|build_medialist
argument_list|(
name|pi
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|cur
operator|=
name|media
operator|->
name|ifm_cur
expr_stmt|;
block|}
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* active and current will differ iff current media is autoselect. */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|cur
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
return|return;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_10000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_100
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_10
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
else|else
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: link up but speed unknown (%u)"
operator|,
name|__func__
operator|,
name|speed
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_fatal_err
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"%s: encountered fatal error, adapter stopped.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bars_0_and_4
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|regs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map registers.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mmio_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_KDB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|msix_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map MSI-X BAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bar_2
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * T4: only iWARP driver uses the userspace doorbells.  There is no need 	 * to map it if RDMA is disabled. 	 */
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|sc
operator|->
name|rdmacaps
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|udbs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|udbs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|udbs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|udbs_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map doorbell BAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|udbs_base
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|t5_write_combine
condition|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* 			 * Enable write combining on BAR2.  This is the 			 * userspace doorbell BAR and is split into 128B 			 * (UDBS_SEG_SIZE) doorbell regions, each associated 			 * with an egress queue.  The first 64B has the doorbell 			 * and the second 64B can be used to submit a tx work 			 * request with an implicit doorbell. 			 */
name|rc
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sc
operator|->
name|udbs_base
argument_list|,
name|rman_get_size
argument_list|(
name|sc
operator|->
name|udbs_res
argument_list|)
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDBWC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't enable write combining: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_CFG
argument_list|,
name|V_STATSOURCE_T5
argument_list|(
literal|7
argument_list|)
operator||
name|V_STATMODE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|memwin
name|t4_memwin
index|[]
init|=
block|{
block|{
name|MEMWIN0_BASE
block|,
name|MEMWIN0_APERTURE
block|}
block|,
block|{
name|MEMWIN1_BASE
block|,
name|MEMWIN1_APERTURE
block|}
block|,
block|{
name|MEMWIN2_BASE_T4
block|,
name|MEMWIN2_APERTURE_T4
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|memwin
name|t5_memwin
index|[]
init|=
block|{
block|{
name|MEMWIN0_BASE
block|,
name|MEMWIN0_APERTURE
block|}
block|,
block|{
name|MEMWIN1_BASE
block|,
name|MEMWIN1_APERTURE
block|}
block|,
block|{
name|MEMWIN2_BASE_T5
block|,
name|MEMWIN2_APERTURE_T5
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|memwin
modifier|*
name|mw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint32_t
name|bar0
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * Read low 32b of bar0 indirectly via the hardware backdoor 		 * mechanism.  Works from within PCI passthrough environments 		 * too, where rman_get_start() can return a different value.  We 		 * need to program the T4 memory window decoders with the actual 		 * addresses that will be coming across the PCIe link. 		 */
name|bar0
operator|=
name|t4_hw_pci_read_cfg4
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bar0
operator|&=
operator|(
name|uint32_t
operator|)
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|mw
operator|=
operator|&
name|t4_memwin
index|[
literal|0
index|]
expr_stmt|;
name|n
operator|=
name|nitems
argument_list|(
name|t4_memwin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* T5 uses the relative offset inside the PCIe BAR */
name|bar0
operator|=
literal|0
expr_stmt|;
name|mw
operator|=
operator|&
name|t5_memwin
index|[
literal|0
index|]
expr_stmt|;
name|n
operator|=
name|nitems
argument_list|(
name|t5_memwin
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|mw
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|mw
operator|->
name|base
operator|+
name|bar0
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|mw
operator|->
name|aperture
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush */
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that the memory range specified by the addr/len pair is valid and lies  * entirely within a single region (EDCx or MCx).  */
end_comment

begin_function
specifier|static
name|int
name|validate_mem_range
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|uint32_t
name|em
decl_stmt|,
name|addr_len
decl_stmt|,
name|maddr
decl_stmt|,
name|mlen
decl_stmt|;
comment|/* Memory can only be accessed in naturally aligned 4 byte units */
if|if
condition|(
name|addr
operator|&
literal|3
operator|||
name|len
operator|&
literal|3
operator|||
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Enabled memories */
name|em
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|em
operator|&
name|F_EDRAM0_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EDRAM0_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
literal|0
operator|&&
name|addr
operator|>=
name|maddr
operator|&&
name|addr
operator|<
name|maddr
operator|+
name|mlen
operator|&&
name|addr
operator|+
name|len
operator|<=
name|maddr
operator|+
name|mlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|em
operator|&
name|F_EDRAM1_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EDRAM1_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
literal|0
operator|&&
name|addr
operator|>=
name|maddr
operator|&&
name|addr
operator|<
name|maddr
operator|+
name|mlen
operator|&&
name|addr
operator|+
name|len
operator|<=
name|maddr
operator|+
name|mlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|em
operator|&
name|F_EXT_MEM_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EXT_MEM_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
literal|0
operator|&&
name|addr
operator|>=
name|maddr
operator|&&
name|addr
operator|<
name|maddr
operator|+
name|mlen
operator|&&
name|addr
operator|+
name|len
operator|<=
name|maddr
operator|+
name|mlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|em
operator|&
name|F_EXT_MEM1_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY1_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EXT_MEM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EXT_MEM1_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
literal|0
operator|&&
name|addr
operator|>=
name|maddr
operator|&&
name|addr
operator|<
name|maddr
operator|+
name|mlen
operator|&&
name|addr
operator|+
name|len
operator|<=
name|maddr
operator|+
name|mlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwmtype_to_hwmtype
parameter_list|(
name|int
name|mtype
parameter_list|)
block|{
switch|switch
condition|(
name|mtype
condition|)
block|{
case|case
name|FW_MEMTYPE_EDC0
case|:
return|return
operator|(
name|MEM_EDC0
operator|)
return|;
case|case
name|FW_MEMTYPE_EDC1
case|:
return|return
operator|(
name|MEM_EDC1
operator|)
return|;
case|case
name|FW_MEMTYPE_EXTMEM
case|:
return|return
operator|(
name|MEM_MC0
operator|)
return|;
case|case
name|FW_MEMTYPE_EXTMEM1
case|:
return|return
operator|(
name|MEM_MC1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: cannot translate fw mtype %d."
argument_list|,
name|__func__
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Verify that the memory range specified by the memtype/offset/len pair is  * valid and lies entirely within the memtype specified.  The global address of  * the start of the range is returned in addr.  */
end_comment

begin_function
specifier|static
name|int
name|validate_mt_off_len
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|mtype
parameter_list|,
name|uint32_t
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|em
decl_stmt|,
name|addr_len
decl_stmt|,
name|maddr
decl_stmt|,
name|mlen
decl_stmt|;
comment|/* Memory can only be accessed in naturally aligned 4 byte units */
if|if
condition|(
name|off
operator|&
literal|3
operator|||
name|len
operator|&
literal|3
operator|||
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|em
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fwmtype_to_hwmtype
argument_list|(
name|mtype
argument_list|)
condition|)
block|{
case|case
name|MEM_EDC0
case|:
if|if
condition|(
operator|!
operator|(
name|em
operator|&
name|F_EDRAM0_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EDRAM0_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|MEM_EDC1
case|:
if|if
condition|(
operator|!
operator|(
name|em
operator|&
name|F_EDRAM1_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EDRAM1_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|MEM_MC
case|:
if|if
condition|(
operator|!
operator|(
name|em
operator|&
name|F_EXT_MEM_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EXT_MEM_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|MEM_MC1
case|:
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|||
operator|!
operator|(
name|em
operator|&
name|F_EXT_MEM1_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY1_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EXT_MEM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|mlen
operator|=
name|G_EXT_MEM1_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mlen
operator|>
literal|0
operator|&&
name|off
operator|<
name|mlen
operator|&&
name|off
operator|+
name|len
operator|<=
name|mlen
condition|)
block|{
operator|*
name|addr
operator|=
name|maddr
operator|+
name|off
expr_stmt|;
comment|/* global address */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memwin_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|win
parameter_list|,
name|uint32_t
modifier|*
name|base
parameter_list|,
name|uint32_t
modifier|*
name|aperture
parameter_list|)
block|{
specifier|const
name|struct
name|memwin
modifier|*
name|mw
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|win
operator|>=
literal|0
operator|&&
name|win
operator|<
name|nitems
argument_list|(
name|t4_memwin
argument_list|)
argument_list|,
operator|(
literal|"%s: incorrect memwin# (%d)"
operator|,
name|__func__
operator|,
name|win
operator|)
argument_list|)
expr_stmt|;
name|mw
operator|=
operator|&
name|t4_memwin
index|[
name|win
index|]
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|win
operator|>=
literal|0
operator|&&
name|win
operator|<
name|nitems
argument_list|(
name|t5_memwin
argument_list|)
argument_list|,
operator|(
literal|"%s: incorrect memwin# (%d)"
operator|,
name|__func__
operator|,
name|win
operator|)
argument_list|)
expr_stmt|;
name|mw
operator|=
operator|&
name|t5_memwin
index|[
name|win
index|]
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|!=
name|NULL
condition|)
operator|*
name|base
operator|=
name|mw
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|aperture
operator|!=
name|NULL
condition|)
operator|*
name|aperture
operator|=
name|mw
operator|->
name|aperture
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Positions the memory window such that it can be used to access the specified  * address in the chip's address space.  The return value is the offset of addr  * from the start of the window.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|position_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|uint32_t
name|start
decl_stmt|,
name|pf
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|KASSERT
argument_list|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<=
literal|3
argument_list|,
operator|(
literal|"%s: invalid window %d."
operator|,
name|__func__
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|addr
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: addr (0x%x) is not at a 4B boundary."
operator|,
name|__func__
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|pf
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|addr
operator|&
operator|~
literal|0xf
expr_stmt|;
comment|/* start must be 16B aligned */
block|}
else|else
block|{
name|pf
operator|=
name|V_PFNUM
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
expr_stmt|;
name|start
operator|=
name|addr
operator|&
operator|~
literal|0x7f
expr_stmt|;
comment|/* start must be 128B aligned */
block|}
name|reg
operator|=
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|start
operator||
name|pf
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|-
name|start
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|n10g
parameter_list|,
name|int
name|n1g
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
name|iaq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|itype
decl_stmt|,
name|navail
decl_stmt|,
name|nrxq10g
decl_stmt|,
name|nrxq1g
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nofldrxq10g
init|=
literal|0
decl_stmt|,
name|nofldrxq1g
init|=
literal|0
decl_stmt|;
name|int
name|nnmrxq10g
init|=
literal|0
decl_stmt|,
name|nnmrxq1g
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|iaq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iaq
argument_list|)
argument_list|)
expr_stmt|;
name|iaq
operator|->
name|ntxq10g
operator|=
name|t4_ntxq10g
expr_stmt|;
name|iaq
operator|->
name|ntxq1g
operator|=
name|t4_ntxq1g
expr_stmt|;
name|iaq
operator|->
name|nrxq10g
operator|=
name|nrxq10g
operator|=
name|t4_nrxq10g
expr_stmt|;
name|iaq
operator|->
name|nrxq1g
operator|=
name|nrxq1g
operator|=
name|t4_nrxq1g
expr_stmt|;
name|iaq
operator|->
name|rsrv_noflowq
operator|=
name|t4_rsrv_noflowq
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iaq
operator|->
name|nofldtxq10g
operator|=
name|t4_nofldtxq10g
expr_stmt|;
name|iaq
operator|->
name|nofldtxq1g
operator|=
name|t4_nofldtxq1g
expr_stmt|;
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|nofldrxq10g
operator|=
name|t4_nofldrxq10g
expr_stmt|;
name|iaq
operator|->
name|nofldrxq1g
operator|=
name|nofldrxq1g
operator|=
name|t4_nofldrxq1g
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmtxq10g
operator|=
name|t4_nnmtxq10g
expr_stmt|;
name|iaq
operator|->
name|nnmtxq1g
operator|=
name|t4_nnmtxq1g
expr_stmt|;
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|nnmrxq10g
operator|=
name|t4_nnmrxq10g
expr_stmt|;
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|nnmrxq1g
operator|=
name|t4_nnmrxq1g
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|itype
operator|=
name|INTR_MSIX
init|;
name|itype
condition|;
name|itype
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|itype
operator|&
name|t4_intr_types
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* not allowed */
if|if
condition|(
name|itype
operator|==
name|INTR_MSIX
condition|)
name|navail
operator|=
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
name|INTR_MSI
condition|)
name|navail
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
else|else
name|navail
operator|=
literal|1
expr_stmt|;
name|restart
label|:
if|if
condition|(
name|navail
operator|==
literal|0
condition|)
continue|continue;
name|iaq
operator|->
name|intr_type
operator|=
name|itype
expr_stmt|;
name|iaq
operator|->
name|intr_flags_10g
operator|=
literal|0
expr_stmt|;
name|iaq
operator|->
name|intr_flags_1g
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Best option: an interrupt vector for errors, one for the 		 * firmware event queue, and one for every rxq (NIC, TOE, and 		 * netmap). 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
operator|(
name|nrxq10g
operator|+
name|nofldrxq10g
operator|+
name|nnmrxq10g
operator|)
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
operator|(
name|nrxq1g
operator|+
name|nofldrxq1g
operator|+
name|nnmrxq1g
operator|)
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
operator|&&
operator|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
operator|)
condition|)
block|{
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|INTR_ALL
expr_stmt|;
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|INTR_ALL
expr_stmt|;
goto|goto
name|allocate
goto|;
block|}
comment|/* 		 * Second best option: a vector for errors, one for the firmware 		 * event queue, and vectors for either all the NIC rx queues or 		 * all the TOE rx queues.  The queues that don't get vectors 		 * will forward their interrupts to those that do. 		 * 		 * Note: netmap rx queues cannot be created early and so they 		 * can't be setup to receive forwarded interrupts for others. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
if|if
condition|(
name|nrxq10g
operator|>=
name|nofldrxq10g
condition|)
block|{
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|INTR_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
name|nrxq10g
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|min
argument_list|(
name|nnmrxq10g
argument_list|,
name|nrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|INTR_OFLD_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
name|nofldrxq10g
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|min
argument_list|(
name|nnmrxq10g
argument_list|,
name|nofldrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|nrxq1g
operator|>=
name|nofldrxq1g
condition|)
block|{
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|INTR_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
name|nrxq1g
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|min
argument_list|(
name|nnmrxq1g
argument_list|,
name|nrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|INTR_OFLD_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
name|nofldrxq1g
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|min
argument_list|(
name|nnmrxq1g
argument_list|,
name|nofldrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
operator|&&
operator|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
operator|)
condition|)
goto|goto
name|allocate
goto|;
comment|/* 		 * Next best option: an interrupt vector for errors, one for the 		 * firmware event queue, and at least one per port.  At this 		 * point we know we'll have to downsize nrxq and/or nofldrxq 		 * and/or nnmrxq to fit what's available to us. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|+
name|n1g
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
condition|)
block|{
name|int
name|leftover
init|=
name|navail
operator|-
name|iaq
operator|->
name|nirq
decl_stmt|;
if|if
condition|(
name|n10g
operator|>
literal|0
condition|)
block|{
name|int
name|target
init|=
name|max
argument_list|(
name|nrxq10g
argument_list|,
name|nofldrxq10g
argument_list|)
decl_stmt|;
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|nrxq10g
operator|>=
name|nofldrxq10g
condition|?
name|INTR_RXQ
else|:
name|INTR_OFLD_RXQ
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|target
operator|&&
name|leftover
operator|>=
name|n10g
condition|)
block|{
name|leftover
operator|-=
name|n10g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|iaq
operator|->
name|nrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nrxq10g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nofldrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nnmrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|n1g
operator|>
literal|0
condition|)
block|{
name|int
name|target
init|=
name|max
argument_list|(
name|nrxq1g
argument_list|,
name|nofldrxq1g
argument_list|)
decl_stmt|;
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|nrxq1g
operator|>=
name|nofldrxq1g
condition|?
name|INTR_RXQ
else|:
name|INTR_OFLD_RXQ
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|target
operator|&&
name|leftover
operator|>=
name|n1g
condition|)
block|{
name|leftover
operator|-=
name|n1g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|iaq
operator|->
name|nrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nrxq1g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|iaq
operator|->
name|nofldrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nofldrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nnmrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
condition|)
goto|goto
name|allocate
goto|;
block|}
comment|/* 		 * Least desirable option: one interrupt vector for everything. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|iaq
operator|->
name|nrxq10g
operator|=
name|iaq
operator|->
name|nrxq1g
operator|=
literal|1
expr_stmt|;
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|iaq
operator|->
name|intr_flags_1g
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|iaq
operator|->
name|nofldrxq1g
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|iaq
operator|->
name|nnmrxq1g
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|allocate
label|:
name|navail
operator|=
name|iaq
operator|->
name|nirq
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|itype
operator|==
name|INTR_MSIX
condition|)
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
name|INTR_MSI
condition|)
name|rc
operator|=
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|navail
operator|==
name|iaq
operator|->
name|nirq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * Didn't get the number requested.  Use whatever number 			 * the kernel is willing to allocate (it's in navail). 			 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"fewer vectors than requested, "
literal|"type=%d, req=%d, rcvd=%d; will downshift req.\n"
argument_list|,
name|itype
argument_list|,
name|iaq
operator|->
name|nirq
argument_list|,
name|navail
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate vectors:%d, type=%d, req=%d, rcvd=%d\n"
argument_list|,
name|itype
argument_list|,
name|rc
argument_list|,
name|iaq
operator|->
name|nirq
argument_list|,
name|navail
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to find a usable interrupt type.  "
literal|"allowed=%d, msi-x=%d, msi=%d, intx=1"
argument_list|,
name|t4_intr_types
argument_list|,
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_VERSION
parameter_list|(
name|chip
parameter_list|)
value|( \     V_FW_HDR_FW_VER_MAJOR(chip##FW_VERSION_MAJOR) | \     V_FW_HDR_FW_VER_MINOR(chip##FW_VERSION_MINOR) | \     V_FW_HDR_FW_VER_MICRO(chip##FW_VERSION_MICRO) | \     V_FW_HDR_FW_VER_BUILD(chip##FW_VERSION_BUILD))
end_define

begin_define
define|#
directive|define
name|FW_INTFVER
parameter_list|(
name|chip
parameter_list|,
name|intf
parameter_list|)
value|(chip##FW_HDR_INTFVER_##intf)
end_define

begin_struct
struct|struct
name|fw_info
block|{
name|uint8_t
name|chip
decl_stmt|;
name|char
modifier|*
name|kld_name
decl_stmt|;
name|char
modifier|*
name|fw_mod_name
decl_stmt|;
name|struct
name|fw_hdr
name|fw_hdr
decl_stmt|;
comment|/* XXX: waste of space, need a sparse struct */
block|}
name|fw_info
index|[]
init|=
block|{
block|{
operator|.
name|chip
operator|=
name|CHELSIO_T4
block|,
operator|.
name|kld_name
operator|=
literal|"t4fw_cfg"
block|,
operator|.
name|fw_mod_name
operator|=
literal|"t4fw"
block|,
operator|.
name|fw_hdr
operator|=
block|{
operator|.
name|chip
operator|=
name|FW_HDR_CHIP_T4
block|,
operator|.
name|fw_ver
operator|=
name|htobe32_const
argument_list|(
name|FW_VERSION
argument_list|(
name|T4
argument_list|)
argument_list|)
block|,
operator|.
name|intfver_nic
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|NIC
argument_list|)
block|,
operator|.
name|intfver_vnic
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|VNIC
argument_list|)
block|,
operator|.
name|intfver_ofld
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|OFLD
argument_list|)
block|,
operator|.
name|intfver_ri
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|RI
argument_list|)
block|,
operator|.
name|intfver_iscsipdu
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|ISCSIPDU
argument_list|)
block|,
operator|.
name|intfver_iscsi
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|ISCSI
argument_list|)
block|,
operator|.
name|intfver_fcoepdu
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|FCOEPDU
argument_list|)
block|,
operator|.
name|intfver_fcoe
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|FCOE
argument_list|)
block|, 		}
block|, 	}
block|,
block|{
operator|.
name|chip
operator|=
name|CHELSIO_T5
block|,
operator|.
name|kld_name
operator|=
literal|"t5fw_cfg"
block|,
operator|.
name|fw_mod_name
operator|=
literal|"t5fw"
block|,
operator|.
name|fw_hdr
operator|=
block|{
operator|.
name|chip
operator|=
name|FW_HDR_CHIP_T5
block|,
operator|.
name|fw_ver
operator|=
name|htobe32_const
argument_list|(
name|FW_VERSION
argument_list|(
name|T5
argument_list|)
argument_list|)
block|,
operator|.
name|intfver_nic
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|NIC
argument_list|)
block|,
operator|.
name|intfver_vnic
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|VNIC
argument_list|)
block|,
operator|.
name|intfver_ofld
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|OFLD
argument_list|)
block|,
operator|.
name|intfver_ri
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|RI
argument_list|)
block|,
operator|.
name|intfver_iscsipdu
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|ISCSIPDU
argument_list|)
block|,
operator|.
name|intfver_iscsi
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|ISCSI
argument_list|)
block|,
operator|.
name|intfver_fcoepdu
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|FCOEPDU
argument_list|)
block|,
operator|.
name|intfver_fcoe
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|FCOE
argument_list|)
block|, 		}
block|, 	}
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|fw_info
modifier|*
name|find_fw_info
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|fw_info
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fw_info
index|[
name|i
index|]
operator|.
name|chip
operator|==
name|chip
condition|)
return|return
operator|(
operator|&
name|fw_info
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is the given firmware API compatible with the one the driver was compiled  * with?  */
end_comment

begin_function
specifier|static
name|int
name|fw_compatible
parameter_list|(
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr1
parameter_list|,
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr2
parameter_list|)
block|{
comment|/* short circuit if it's the exact same firmware version */
if|if
condition|(
name|hdr1
operator|->
name|chip
operator|==
name|hdr2
operator|->
name|chip
operator|&&
name|hdr1
operator|->
name|fw_ver
operator|==
name|hdr2
operator|->
name|fw_ver
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * XXX: Is this too conservative?  Perhaps I should limit this to the 	 * features that are supported in the driver. 	 */
define|#
directive|define
name|SAME_INTF
parameter_list|(
name|x
parameter_list|)
value|(hdr1->intfver_##x == hdr2->intfver_##x)
if|if
condition|(
name|hdr1
operator|->
name|chip
operator|==
name|hdr2
operator|->
name|chip
operator|&&
name|SAME_INTF
argument_list|(
name|nic
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|vnic
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|ofld
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|ri
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|iscsipdu
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|iscsi
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|fcoepdu
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|fcoe
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
undef|#
directive|undef
name|SAME_INTF
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware in the KLD is usable, but should it be installed?  This routine  * explains itself in detail if it indicates the KLD firmware should be  * installed.  */
end_comment

begin_function
specifier|static
name|int
name|should_install_kld_fw
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|card_fw_usable
parameter_list|,
name|int
name|k
parameter_list|,
name|int
name|c
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
if|if
condition|(
operator|!
name|card_fw_usable
condition|)
block|{
name|reason
operator|=
literal|"incompatible or unusable"
expr_stmt|;
goto|goto
name|install
goto|;
block|}
if|if
condition|(
name|k
operator|>
name|c
condition|)
block|{
name|reason
operator|=
literal|"older than the version bundled with this driver"
expr_stmt|;
goto|goto
name|install
goto|;
block|}
if|if
condition|(
name|t4_fw_install
operator|==
literal|2
operator|&&
name|k
operator|!=
name|c
condition|)
block|{
name|reason
operator|=
literal|"different than the version bundled with this driver"
expr_stmt|;
goto|goto
name|install
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|install
label|:
if|if
condition|(
name|t4_fw_install
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware on card (%u.%u.%u.%u) is %s, "
literal|"but the driver is prohibited from installing a different "
literal|"firmware on the card.\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|c
argument_list|)
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware on card (%u.%u.%u.%u) is %s, "
literal|"installing firmware %u.%u.%u.%u on card.\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|c
argument_list|)
argument_list|,
name|reason
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Establish contact with the firmware and determine if we are the master driver  * or not, and whether we are responsible for chip initialization.  */
end_comment

begin_function
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
init|=
name|NULL
decl_stmt|,
modifier|*
name|default_cfg
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|pf
decl_stmt|,
name|card_fw_usable
decl_stmt|,
name|kld_fw_usable
decl_stmt|,
name|need_fw_reset
init|=
literal|1
decl_stmt|;
name|enum
name|dev_state
name|state
decl_stmt|;
name|struct
name|fw_info
modifier|*
name|fw_info
decl_stmt|;
name|struct
name|fw_hdr
modifier|*
name|card_fw
decl_stmt|;
comment|/* fw on the card */
specifier|const
name|struct
name|fw_hdr
modifier|*
name|kld_fw
decl_stmt|;
comment|/* fw in the KLD */
specifier|const
name|struct
name|fw_hdr
modifier|*
name|drv_fw
decl_stmt|;
comment|/* fw header the driver was compiled 					   against */
comment|/* Contact firmware. */
name|rc
operator|=
name|t4_fw_hello
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|MASTER_MAY
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
operator|||
name|state
operator|==
name|DEV_STATE_ERR
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to connect to the firmware: %d, %d.\n"
argument_list|,
name|rc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|pf
operator|=
name|rc
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|sc
operator|->
name|mbox
condition|)
name|sc
operator|->
name|flags
operator||=
name|MASTER_PF
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|DEV_STATE_UNINIT
condition|)
block|{
comment|/* 		 * We didn't get to be the master so we definitely won't be 		 * configuring the chip.  It's a bug if someone else hasn't 		 * configured it already. 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't be master(%d), "
literal|"device not already initialized either(%d).\n"
argument_list|,
name|rc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
comment|/* This is the firmware whose headers the driver was compiled against */
name|fw_info
operator|=
name|find_fw_info
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_info
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to look up firmware information for chip %d.\n"
argument_list|,
name|chip_id
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|drv_fw
operator|=
operator|&
name|fw_info
operator|->
name|fw_hdr
expr_stmt|;
comment|/* 	 * The firmware KLD contains many modules.  The KLD name is also the 	 * name of the module that contains the default config file. 	 */
name|default_cfg
operator|=
name|firmware_get
argument_list|(
name|fw_info
operator|->
name|kld_name
argument_list|)
expr_stmt|;
comment|/* Read the header of the firmware on the card */
name|card_fw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|card_fw
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_read_flash
argument_list|(
name|sc
argument_list|,
name|FLASH_FW_START
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|card_fw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|card_fw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|card_fw_usable
operator|=
name|fw_compatible
argument_list|(
name|drv_fw
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|card_fw
argument_list|)
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to read card's firmware header: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|card_fw_usable
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This is the firmware in the KLD */
name|fw
operator|=
name|firmware_get
argument_list|(
name|fw_info
operator|->
name|fw_mod_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
block|{
name|kld_fw
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
name|kld_fw_usable
operator|=
name|fw_compatible
argument_list|(
name|drv_fw
argument_list|,
name|kld_fw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kld_fw
operator|=
name|NULL
expr_stmt|;
name|kld_fw_usable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|card_fw_usable
operator|&&
name|card_fw
operator|->
name|fw_ver
operator|==
name|drv_fw
operator|->
name|fw_ver
operator|&&
operator|(
operator|!
name|kld_fw_usable
operator|||
name|kld_fw
operator|->
name|fw_ver
operator|==
name|drv_fw
operator|->
name|fw_ver
operator|)
condition|)
block|{
comment|/* 		 * Common case: the firmware on the card is an exact match and 		 * the KLD is an exact match too, or the KLD is 		 * absent/incompatible.  Note that t4_fw_install = 2 is ignored 		 * here -- use cxgbetool loadfw if you want to reinstall the 		 * same firmware as the one on the card. 		 */
block|}
elseif|else
if|if
condition|(
name|kld_fw_usable
operator|&&
name|state
operator|==
name|DEV_STATE_UNINIT
operator|&&
name|should_install_kld_fw
argument_list|(
name|sc
argument_list|,
name|card_fw_usable
argument_list|,
name|be32toh
argument_list|(
name|kld_fw
operator|->
name|fw_ver
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|card_fw
operator|->
name|fw_ver
argument_list|)
argument_list|)
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_fw_upgrade
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to install firmware: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Installed successfully, update the cached header too. */
name|memcpy
argument_list|(
name|card_fw
argument_list|,
name|kld_fw
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|card_fw
argument_list|)
argument_list|)
expr_stmt|;
name|card_fw_usable
operator|=
literal|1
expr_stmt|;
name|need_fw_reset
operator|=
literal|0
expr_stmt|;
comment|/* already reset as part of load_fw */
block|}
if|if
condition|(
operator|!
name|card_fw_usable
condition|)
block|{
name|uint32_t
name|d
decl_stmt|,
name|c
decl_stmt|,
name|k
decl_stmt|;
name|d
operator|=
name|ntohl
argument_list|(
name|drv_fw
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
name|c
operator|=
name|ntohl
argument_list|(
name|card_fw
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
name|k
operator|=
name|kld_fw
condition|?
name|ntohl
argument_list|(
name|kld_fw
operator|->
name|fw_ver
argument_list|)
else|:
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find a usable firmware: "
literal|"fw_install %d, chip state %d, "
literal|"driver compiled with %d.%d.%d.%d, "
literal|"card has %d.%d.%d.%d, KLD has %d.%d.%d.%d\n"
argument_list|,
name|t4_fw_install
argument_list|,
name|state
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* We're using whatever's on the card and it's known to be good. */
name|sc
operator|->
name|params
operator|.
name|fw_vers
operator|=
name|ntohl
argument_list|(
name|card_fw
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|)
expr_stmt|;
name|t4_get_tp_version
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|tp_vers
argument_list|)
expr_stmt|;
comment|/* Reset device */
if|if
condition|(
name|need_fw_reset
operator|&&
operator|(
name|rc
operator|=
operator|-
name|t4_fw_reset
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|F_PIORSTMODE
operator||
name|F_PIORST
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware reset failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ETIMEDOUT
operator|&&
name|rc
operator|!=
name|EIO
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|flags
operator||=
name|FW_OK
expr_stmt|;
name|rc
operator|=
name|get_params__pre_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* Partition adapter resources as specified in the config file. */
if|if
condition|(
name|state
operator|==
name|DEV_STATE_UNINIT
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|MASTER_PF
argument_list|,
operator|(
literal|"%s: trying to change chip settings when not master."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|partition_resources
argument_list|(
name|sc
argument_list|,
name|default_cfg
argument_list|,
name|fw_info
operator|->
name|kld_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|t4_tweak_chip_settings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get basic stuff going */
name|rc
operator|=
operator|-
name|t4_fw_initialize
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"fw init failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"pf%d"
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cfcsum
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|card_fw
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_cfg
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|default_cfg
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_PARAM_DEV
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_##param))
end_define

begin_define
define|#
directive|define
name|FW_PARAM_PFVF
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_PFVF) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_PFVF_##param))
end_define

begin_comment
comment|/*  * Partition chip resources for use between various PFs, VFs, etc.  */
end_comment

begin_function
specifier|static
name|int
name|partition_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
name|default_cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|name_prefix
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|fw_caps_config_cmd
name|caps
decl_stmt|;
name|uint32_t
name|mtype
decl_stmt|,
name|moff
decl_stmt|,
name|finicsum
decl_stmt|,
name|cfcsum
decl_stmt|;
comment|/* 	 * Figure out what configuration file to use.  Pick the default config 	 * file for the card if the user hasn't specified one explicitly. 	 */
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|t4_cfg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|t4_cfg_file
argument_list|,
name|DEFAULT_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|t4_cfg_file
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Card specific overrides go here. */
if|if
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|==
literal|0x440a
condition|)
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
name|UWIRE_CF
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_fpga
argument_list|(
name|sc
argument_list|)
condition|)
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
name|FPGA_CF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to load another module if the profile is anything except 	 * "default" or "flash". 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|DEFAULT_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|FLASH_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|s
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%s_%s"
argument_list|,
name|name_prefix
argument_list|,
name|sc
operator|->
name|cfg_file
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|firmware_get
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|default_cfg
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to load module \"%s\" for "
literal|"configuration profile \"%s\", will use "
literal|"the default config file instead.\n"
argument_list|,
name|s
argument_list|,
name|sc
operator|->
name|cfg_file
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|DEFAULT_CF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to load module \"%s\" for "
literal|"configuration profile \"%s\", will use "
literal|"the config file on the card's flash "
literal|"instead.\n"
argument_list|,
name|s
argument_list|,
name|sc
operator|->
name|cfg_file
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|FLASH_CF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|DEFAULT_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|default_cfg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"default config file not available, will use the config "
literal|"file on the card's flash instead.\n"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|FLASH_CF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|FLASH_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|cflen
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|cfdata
decl_stmt|;
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|,
name|addr
decl_stmt|,
name|off
decl_stmt|,
name|mw_base
decl_stmt|,
name|mw_aperture
decl_stmt|;
name|KASSERT
argument_list|(
name|cfg
operator|!=
name|NULL
operator|||
name|default_cfg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no config to upload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Ask the firmware where it wants us to upload the config file. 		 */
name|param
operator|=
name|FW_PARAM_DEV
argument_list|(
name|CF
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* No support for config file?  Shouldn't happen. */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query config file location: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtype
operator|=
name|G_FW_PARAMS_PARAM_Y
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|moff
operator|=
name|G_FW_PARAMS_PARAM_Z
argument_list|(
name|val
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* 		 * XXX: sheer laziness.  We deliberately added 4 bytes of 		 * useless stuffing/comments at the end of the config file so 		 * it's ok to simply throw away the last remaining bytes when 		 * the config file is not an exact multiple of 4.  This also 		 * helps with the validate_mt_off_len check. 		 */
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
block|{
name|cflen
operator|=
name|cfg
operator|->
name|datasize
operator|&
operator|~
literal|3
expr_stmt|;
name|cfdata
operator|=
name|cfg
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|cflen
operator|=
name|default_cfg
operator|->
name|datasize
operator|&
operator|~
literal|3
expr_stmt|;
name|cfdata
operator|=
name|default_cfg
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
name|cflen
operator|>
name|FLASH_CFG_MAX_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"config file too long (%d, max allowed is %d).  "
literal|"Will try to use the config on the card, if any.\n"
argument_list|,
name|cflen
argument_list|,
name|FLASH_CFG_MAX_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|use_config_on_flash
goto|;
block|}
name|rc
operator|=
name|validate_mt_off_len
argument_list|(
name|sc
argument_list|,
name|mtype
argument_list|,
name|moff
argument_list|,
name|cflen
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: addr (%d/0x%x) or len %d is not valid: %d.  "
literal|"Will try to use the config on the card, if any.\n"
argument_list|,
name|__func__
argument_list|,
name|mtype
argument_list|,
name|moff
argument_list|,
name|cflen
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|use_config_on_flash
goto|;
block|}
name|memwin_info
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
operator|&
name|mw_base
argument_list|,
operator|&
name|mw_aperture
argument_list|)
expr_stmt|;
while|while
condition|(
name|cflen
condition|)
block|{
name|off
operator|=
name|position_memwin
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|cflen
argument_list|,
name|mw_aperture
operator|-
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|4
control|)
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|mw_base
operator|+
name|off
operator|+
name|i
argument_list|,
operator|*
name|cfdata
operator|++
argument_list|)
expr_stmt|;
name|cflen
operator|-=
name|n
expr_stmt|;
name|addr
operator|+=
name|n
expr_stmt|;
block|}
block|}
else|else
block|{
name|use_config_on_flash
label|:
name|mtype
operator|=
name|FW_MEMTYPE_FLASH
expr_stmt|;
name|moff
operator|=
name|t4_flash_cfg_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_CAPS_CONFIG_CMD_CFVALID
operator||
name|V_FW_CAPS_CONFIG_CMD_MEMTYPE_CF
argument_list|(
name|mtype
argument_list|)
operator||
name|V_FW_CAPS_CONFIG_CMD_MEMADDR64K_CF
argument_list|(
name|moff
operator|>>
literal|16
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to pre-process config file: %d "
literal|"(mtype %d, moff 0x%x).\n"
argument_list|,
name|rc
argument_list|,
name|mtype
argument_list|,
name|moff
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|finicsum
operator|=
name|be32toh
argument_list|(
name|caps
operator|.
name|finicsum
argument_list|)
expr_stmt|;
name|cfcsum
operator|=
name|be32toh
argument_list|(
name|caps
operator|.
name|cfcsum
argument_list|)
expr_stmt|;
if|if
condition|(
name|finicsum
operator|!=
name|cfcsum
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING: config file checksum mismatch: %08x %08x\n"
argument_list|,
name|finicsum
argument_list|,
name|cfcsum
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cfcsum
operator|=
name|cfcsum
expr_stmt|;
define|#
directive|define
name|LIMIT_CAPS
parameter_list|(
name|x
parameter_list|)
value|do { \ 	caps.x&= htobe16(t4_##x##_allowed); \ } while (0)
comment|/* 	 * Let the firmware know what features will (not) be used so it can tune 	 * things accordingly. 	 */
name|LIMIT_CAPS
argument_list|(
name|linkcaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|niccaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|toecaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|rdmacaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|iscsicaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|fcoecaps
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|LIMIT_CAPS
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to process config file: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|cfg
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve parameters that are needed (or nice to have) very early.  */
end_comment

begin_function
specifier|static
name|int
name|get_params__pre_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|param
index|[
literal|2
index|]
decl_stmt|,
name|val
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|fw_devlog_cmd
name|cmd
decl_stmt|;
name|struct
name|devlog_params
modifier|*
name|dlog
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|devlog
decl_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|PORTVEC
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|CCLK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query parameters (pre_init): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|params
operator|.
name|portvec
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|nports
operator|=
name|bitcount32
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
comment|/* Read device log parameters. */
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_DEVLOG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get devlog parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dlog
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dlog
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* devlog isn't critical for device operation */
block|}
else|else
block|{
name|val
index|[
literal|0
index|]
operator|=
name|be32toh
argument_list|(
name|cmd
operator|.
name|memtype_devlog_memaddr16_devlog
argument_list|)
expr_stmt|;
name|dlog
operator|->
name|memtype
operator|=
name|G_FW_DEVLOG_CMD_MEMTYPE_DEVLOG
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dlog
operator|->
name|start
operator|=
name|G_FW_DEVLOG_CMD_MEMADDR16_DEVLOG
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|dlog
operator|->
name|size
operator|=
name|be32toh
argument_list|(
name|cmd
operator|.
name|memsize_devlog
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve various parameters that are of interest to the driver.  The device  * has been initialized by the firmware at this point.  */
end_comment

begin_function
specifier|static
name|int
name|get_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|param
index|[
literal|7
index|]
decl_stmt|,
name|val
index|[
literal|7
index|]
decl_stmt|;
name|struct
name|fw_caps_config_cmd
name|caps
decl_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|IQFLINT_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|EQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|L2T_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|L2T_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query parameters (post_init): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|sge
operator|.
name|iq_start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eq_start
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nftids
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ftid_min
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ftid_max
operator|=
name|val
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|size
operator|<=
name|L2T_SIZE
argument_list|,
operator|(
literal|"%s: L2 table size (%u) larger than expected (%u)"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|size
operator|,
name|L2T_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* get capabilites */
name|bzero
argument_list|(
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get card capabilities: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
define|#
directive|define
name|READ_CAPS
parameter_list|(
name|x
parameter_list|)
value|do { \ 	sc->x = htobe16(caps.x); \ } while (0)
name|READ_CAPS
argument_list|(
name|linkcaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|niccaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|toecaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|rdmacaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|iscsicaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|fcoecaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|niccaps
operator|&
name|FW_CAPS_CONFIG_NIC_ETHOFLD
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ETHOFLD_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ETHOFLD_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|FLOWC_BUFFIFO_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query NIC parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|tids
operator|.
name|etid_base
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|etid_min
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|netids
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|netids
operator|=
name|sc
operator|->
name|tids
operator|.
name|netids
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|eo_wr_cred
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ethoffload
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|toecaps
condition|)
block|{
comment|/* query offload-related parameters */
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|NTID
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|FLOWC_BUFFIFO_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query TOE parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|natids
operator|=
name|min
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|/
literal|2
argument_list|,
name|MAX_ATIDS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|stid_base
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nstids
operator|=
name|val
index|[
literal|2
index|]
operator|-
name|val
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|start
operator|=
name|val
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|size
operator|=
name|val
index|[
literal|4
index|]
operator|-
name|val
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ofldq_wr_cred
operator|=
name|val
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|offload
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rdmacaps
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query RDMA parameters(1): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|size
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SQRQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SQRQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|OCQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|OCQ_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query RDMA parameters(2): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|qp
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|qp
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|cq
operator|.
name|start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|cq
operator|.
name|size
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|iscsicaps
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query iSCSI parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * We've got the params we wanted to query via the firmware.  Now grab 	 * some others directly from the chip. 	 */
name|rc
operator|=
name|t4_read_chip_settings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|;
comment|/* ask for encapsulated CPLs */
name|param
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CPLFW4MSG_ENCAP
argument_list|)
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|FW_PARAM_PFVF
end_undef

begin_undef
undef|#
directive|undef
name|FW_PARAM_DEV
end_undef

begin_function
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|adapter_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Chelsio %s %sNIC (rev %d), S/N:%s, "
literal|"P/N:%s, E/C:%s"
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|id
argument_list|,
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|?
literal|"R"
else|:
literal|""
argument_list|,
name|chip_rev
argument_list|(
name|sc
argument_list|)
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|sn
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|pn
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|ec
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|ifmedia
modifier|*
name|media
parameter_list|)
block|{
name|int
name|data
decl_stmt|,
name|m
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
name|media
argument_list|)
expr_stmt|;
name|m
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
name|data
operator|=
operator|(
name|pi
operator|->
name|port_type
operator|<<
literal|8
operator|)
operator||
name|pi
operator|->
name|mod_type
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|port_type
condition|)
block|{
case|case
name|FW_PORT_TYPE_BT_XFI
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_BT_XAUI
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|FW_PORT_TYPE_BT_SGMII
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_1000_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_100_TX
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_CX4
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_QSFP_10G
case|:
case|case
name|FW_PORT_TYPE_SFP
case|:
case|case
name|FW_PORT_TYPE_FIBER_XFI
case|:
case|case
name|FW_PORT_TYPE_FIBER_XAUI
case|:
switch|switch
condition|(
name|pi
operator|->
name|mod_type
condition|)
block|{
case|case
name|FW_PORT_MOD_TYPE_LR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_SR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_LRM
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_TWINAX_PASSIVE
case|:
case|case
name|FW_PORT_MOD_TYPE_TWINAX_ACTIVE
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NONE
case|:
name|m
operator|&=
operator|~
name|IFM_FDX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NA
case|:
case|case
name|FW_PORT_MOD_TYPE_ER
case|:
default|default:
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"unknown port_type (%d), mod_type (%d)\n"
argument_list|,
name|pi
operator|->
name|port_type
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FW_PORT_TYPE_QSFP
case|:
switch|switch
condition|(
name|pi
operator|->
name|mod_type
condition|)
block|{
case|case
name|FW_PORT_MOD_TYPE_LR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_LR4
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_LR4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_SR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_SR4
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_SR4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_TWINAX_PASSIVE
case|:
case|case
name|FW_PORT_MOD_TYPE_TWINAX_ACTIVE
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_CR4
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_CR4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NONE
case|:
name|m
operator|&=
operator|~
name|IFM_FDX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"unknown port_type (%d), mod_type (%d)\n"
argument_list|,
name|pi
operator|->
name|port_type
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"unknown port_type (%d), mod_type (%d)\n"
argument_list|,
name|pi
operator|->
name|port_type
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_MAC_EXACT_CHUNK
value|7
end_define

begin_comment
comment|/*  * Program the port's XGMAC based on parameters in ifnet.  The caller also  * indicates which parameters should be programmed (the rest are left alone).  */
end_comment

begin_function
name|int
name|update_mac_settings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|mtu
init|=
operator|-
literal|1
decl_stmt|,
name|promisc
init|=
operator|-
literal|1
decl_stmt|,
name|allmulti
init|=
operator|-
literal|1
decl_stmt|,
name|vlanex
init|=
operator|-
literal|1
decl_stmt|;
name|uint16_t
name|viid
init|=
literal|0xffff
decl_stmt|;
name|int16_t
modifier|*
name|xact_addr_filt
init|=
name|NULL
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|flags
argument_list|,
operator|(
literal|"%s: not told what to update."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|pi
operator|->
name|ifp
condition|)
block|{
name|viid
operator|=
name|pi
operator|->
name|viid
expr_stmt|;
name|xact_addr_filt
operator|=
operator|&
name|pi
operator|->
name|xact_addr_filt
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
elseif|else
if|if
condition|(
name|ifp
operator|==
name|pi
operator|->
name|nm_ifp
condition|)
block|{
name|viid
operator|=
name|pi
operator|->
name|nm_viid
expr_stmt|;
name|xact_addr_filt
operator|=
operator|&
name|pi
operator|->
name|nm_xact_addr_filt
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|XGMAC_MTU
condition|)
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_PROMISC
condition|)
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_ALLMULTI
condition|)
name|allmulti
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_VLANEX
condition|)
name|vlanex
operator|=
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|XGMAC_MTU
operator||
name|XGMAC_PROMISC
operator||
name|XGMAC_ALLMULTI
operator||
name|XGMAC_VLANEX
operator|)
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_set_rxmode
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|viid
argument_list|,
name|mtu
argument_list|,
name|promisc
argument_list|,
name|allmulti
argument_list|,
literal|1
argument_list|,
name|vlanex
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"set_rxmode (%x) failed: %d\n"
argument_list|,
name|flags
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_UCADDR
condition|)
block|{
name|uint8_t
name|ucaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ucaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ucaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_change_mac
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|viid
argument_list|,
operator|*
name|xact_addr_filt
argument_list|,
name|ucaddr
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"change_mac failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
else|else
block|{
operator|*
name|xact_addr_filt
operator|=
name|rc
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_MCADDRS
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|mcaddr
index|[
name|FW_MAC_EXACT_CHUNK
index|]
decl_stmt|;
name|int
name|del
init|=
literal|1
decl_stmt|;
name|uint64_t
name|hash
init|=
literal|0
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcaddr
index|[
name|i
operator|++
index|]
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FW_MAC_EXACT_CHUNK
condition|)
block|{
name|rc
operator|=
name|t4_alloc_mac_filt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|viid
argument_list|,
name|del
argument_list|,
name|i
argument_list|,
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to add mc address"
literal|" %02x:%02x:%02x:"
literal|"%02x:%02x:%02x rc=%d\n"
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|3
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|4
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|5
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mcfail
goto|;
block|}
name|del
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|t4_alloc_mac_filt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|viid
argument_list|,
name|del
argument_list|,
name|i
argument_list|,
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to add mc address"
literal|" %02x:%02x:%02x:"
literal|"%02x:%02x:%02x rc=%d\n"
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|3
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|4
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|5
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mcfail
goto|;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_set_addr_hash
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|viid
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to set mc address hash: %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|mcfail
label|:
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|begin_synchronized_op
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|pri
decl_stmt|;
ifdef|#
directive|ifdef
name|WITNESS
comment|/* the caller thinks it's ok to sleep, but is it really? */
if|if
condition|(
name|flags
operator|&
name|SLEEP_OK
condition|)
name|pause
argument_list|(
literal|"t4slptst"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|INTR_OK
condition|)
name|pri
operator|=
name|PCATCH
expr_stmt|;
else|else
name|pri
operator|=
literal|0
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pi
operator|&&
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SLEEP_OK
operator|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|pri
argument_list|,
name|wmesg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sc
operator|->
name|last_op
operator|=
name|wmesg
expr_stmt|;
name|sc
operator|->
name|last_op_thr
operator|=
name|curthread
expr_stmt|;
endif|#
directive|endif
name|done
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HOLD_LOCK
operator|)
operator|||
name|rc
condition|)
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|end_synchronized_op
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOCK_HELD
condition|)
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
argument_list|,
operator|(
literal|"mismatch between open_device_map and if_drv_flags"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already running */
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|adapter_full_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
if|if
condition|(
operator|!
operator|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|port_full_init
argument_list|(
name|pi
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * The first iq of the first port to come up is used for tracing. 	 */
if|if
condition|(
name|sc
operator|->
name|traceq
operator|<
literal|0
condition|)
block|{
name|sc
operator|->
name|traceq
operator|=
name|sc
operator|->
name|sge
operator|.
name|rxq
index|[
name|pi
operator|->
name|first_rxq
index|]
operator|.
name|iq
operator|.
name|abs_id
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
name|A_MPS_TRC_RSS_CONTROL
else|:
name|A_MPS_T5_TRC_RSS_CONTROL
argument_list|,
name|V_RSSCONTROL
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|V_QUEUENUMBER
argument_list|(
name|sc
operator|->
name|traceq
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|flags
operator||=
name|HAS_TRACEQ
expr_stmt|;
block|}
comment|/* all ok */
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|,
name|cxgbe_tick
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable the VI so that all its data in either direction is discarded 	 * by the MPS.  Leave everything else (the queues, interrupts, and 1Hz 	 * tick) intact as the TP can deliver negative advice or data that it's 	 * holding in its RAM (for an offloaded connection) even after the VI is 	 * disabled. 	 */
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"disable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|linkdnrc
operator|=
operator|-
literal|1
expr_stmt|;
name|t4_os_link_changed
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * It is ok for this function to fail midway and return right away.  t4_detach  * will walk the entire sc->irq list and clean up whatever is valid.  */
end_comment

begin_function
specifier|static
name|int
name|setup_intr_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|rid
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|;
name|char
name|s
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|irq
modifier|*
name|irq
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Setup interrupts. 	 */
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
index|[
literal|0
index|]
expr_stmt|;
name|rid
operator|=
name|sc
operator|->
name|intr_type
operator|==
name|INTR_INTX
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
condition|)
return|return
operator|(
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_all
argument_list|,
name|sc
argument_list|,
literal|"all"
argument_list|)
operator|)
return|;
comment|/* Multiple interrupts. */
name|KASSERT
argument_list|(
name|sc
operator|->
name|intr_count
operator|>=
name|T4_EXTRA_INTR
operator|+
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
literal|"%s: too few intr."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* The first one is always error intr */
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_err
argument_list|,
name|sc
argument_list|,
literal|"err"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
comment|/* The second one is always the firmware event queue */
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_evt
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
argument_list|,
literal|"evt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|p
argument_list|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|INTR_RXQ
condition|)
block|{
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|q
argument_list|,
argument|rxq
argument_list|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d.%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr
argument_list|,
name|rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|INTR_OFLD_RXQ
condition|)
block|{
name|for_each_ofld_rxq
argument_list|(
argument|pi
argument_list|,
argument|q
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d,%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr
argument_list|,
name|ofld_rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|INTR_NM_RXQ
condition|)
block|{
name|for_each_nm_rxq
argument_list|(
argument|pi
argument_list|,
argument|q
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d-%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_nm_intr
argument_list|,
name|nm_rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|MPASS
argument_list|(
name|irq
operator|==
operator|&
name|sc
operator|->
name|irq
index|[
name|sc
operator|->
name|intr_count
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adapter_full_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: FULL_INIT_DONE already"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * queues that belong to the adapter (not any particular port). 	 */
name|rc
operator|=
name|t4_setup_adapter_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|=
name|taskqueue_create
argument_list|(
literal|"t4 taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate task queue %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s tq%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|t4_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FULL_INIT_DONE
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|adapter_full_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adapter_full_uninit
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_teardown_adapter_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
operator|&&
name|sc
operator|->
name|tq
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FULL_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|port_full_init
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|uint16_t
modifier|*
name|rss
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: PORT_INIT_DONE already"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|pi
operator|->
name|flags
operator||=
name|PORT_SYSCTL_CTX
expr_stmt|;
comment|/* 	 * Allocate tx/rx/fl queues for this port. 	 */
name|rc
operator|=
name|t4_setup_port_queues
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * Setup RSS for this port.  Save a copy of the RSS table for later use. 	 */
name|rss
operator|=
name|malloc
argument_list|(
name|pi
operator|->
name|rss_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rss
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|->
name|rss_size
condition|;
control|)
block|{
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|j
argument_list|,
argument|rxq
argument_list|)
block|{
name|rss
index|[
name|i
operator|++
index|]
operator|=
name|rxq
operator|->
name|iq
operator|.
name|abs_id
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|pi
operator|->
name|rss_size
condition|)
break|break;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_config_rss_range
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|rss_size
argument_list|,
name|rss
argument_list|,
name|pi
operator|->
name|rss_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"rss_config failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pi
operator|->
name|rss
operator|=
name|rss
expr_stmt|;
name|pi
operator|->
name|flags
operator||=
name|PORT_INIT_DONE
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|port_full_uninit
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
name|int
name|port_full_uninit
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
block|{
comment|/* Need to quiesce queues.  XXX: ctrl queues? */
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|quiesce_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|txq
operator|->
name|eq
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|ofld_txq
argument_list|)
block|{
name|quiesce_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_txq
operator|->
name|eq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|quiesce_iq
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|iq
argument_list|)
expr_stmt|;
name|quiesce_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|quiesce_iq
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
argument_list|)
expr_stmt|;
name|quiesce_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|pi
operator|->
name|rss
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
name|t4_teardown_port_queues
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|flags
operator|&=
operator|~
name|PORT_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_eq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|EQ_LOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|eq
operator|->
name|flags
operator||=
name|EQ_DOOMED
expr_stmt|;
comment|/* 	 * Wait for the response to a credit flush if one's 	 * pending. 	 */
while|while
condition|(
name|eq
operator|->
name|flags
operator|&
name|EQ_CRFLUSHED
condition|)
name|mtx_sleep
argument_list|(
name|eq
argument_list|,
operator|&
name|eq
operator|->
name|eq_lock
argument_list|,
literal|0
argument_list|,
literal|"crflush"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|)
expr_stmt|;
comment|/* XXX: iffy */
name|pause
argument_list|(
literal|"callout"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Still iffy */
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
index|[
name|eq
operator|->
name|tx_chan
index|]
argument_list|,
operator|&
name|eq
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_iq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* unused */
comment|/* Synchronize with the interrupt handler */
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|,
name|IQS_DISABLED
argument_list|)
condition|)
name|pause
argument_list|(
literal|"iqfree"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_fl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|flags
operator||=
name|FL_DOOMED
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|FL_STARVING
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: still starving"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_intr_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|irq
operator|->
name|rid
operator|=
name|rid
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate IRQ for rid %d, name %s.\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|&
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup interrupt for rid %d, name %s: %d\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
condition|)
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|)
block|{
if|if
condition|(
name|irq
operator|->
name|tag
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|rid
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|irq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|irq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|start
operator|)
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
operator|*
name|p
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_regdump
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|const
name|unsigned
name|int
modifier|*
name|reg_ranges
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|t4_reg_ranges
index|[]
init|=
block|{
literal|0x1008
block|,
literal|0x1108
block|,
literal|0x1180
block|,
literal|0x11b4
block|,
literal|0x11fc
block|,
literal|0x123c
block|,
literal|0x1300
block|,
literal|0x173c
block|,
literal|0x1800
block|,
literal|0x18fc
block|,
literal|0x3000
block|,
literal|0x30d8
block|,
literal|0x30e0
block|,
literal|0x5924
block|,
literal|0x5960
block|,
literal|0x59d4
block|,
literal|0x5a00
block|,
literal|0x5af8
block|,
literal|0x6000
block|,
literal|0x6098
block|,
literal|0x6100
block|,
literal|0x6150
block|,
literal|0x6200
block|,
literal|0x6208
block|,
literal|0x6240
block|,
literal|0x6248
block|,
literal|0x6280
block|,
literal|0x6338
block|,
literal|0x6370
block|,
literal|0x638c
block|,
literal|0x6400
block|,
literal|0x643c
block|,
literal|0x6500
block|,
literal|0x6524
block|,
literal|0x6a00
block|,
literal|0x6a38
block|,
literal|0x6a60
block|,
literal|0x6a78
block|,
literal|0x6b00
block|,
literal|0x6b84
block|,
literal|0x6bf0
block|,
literal|0x6c84
block|,
literal|0x6cf0
block|,
literal|0x6d84
block|,
literal|0x6df0
block|,
literal|0x6e84
block|,
literal|0x6ef0
block|,
literal|0x6f84
block|,
literal|0x6ff0
block|,
literal|0x7084
block|,
literal|0x70f0
block|,
literal|0x7184
block|,
literal|0x71f0
block|,
literal|0x7284
block|,
literal|0x72f0
block|,
literal|0x7384
block|,
literal|0x73f0
block|,
literal|0x7450
block|,
literal|0x7500
block|,
literal|0x7530
block|,
literal|0x7600
block|,
literal|0x761c
block|,
literal|0x7680
block|,
literal|0x76cc
block|,
literal|0x7700
block|,
literal|0x7798
block|,
literal|0x77c0
block|,
literal|0x77fc
block|,
literal|0x7900
block|,
literal|0x79fc
block|,
literal|0x7b00
block|,
literal|0x7c38
block|,
literal|0x7d00
block|,
literal|0x7efc
block|,
literal|0x8dc0
block|,
literal|0x8e1c
block|,
literal|0x8e30
block|,
literal|0x8e78
block|,
literal|0x8ea0
block|,
literal|0x8f6c
block|,
literal|0x8fc0
block|,
literal|0x9074
block|,
literal|0x90fc
block|,
literal|0x90fc
block|,
literal|0x9400
block|,
literal|0x9458
block|,
literal|0x9600
block|,
literal|0x96bc
block|,
literal|0x9800
block|,
literal|0x9808
block|,
literal|0x9820
block|,
literal|0x983c
block|,
literal|0x9850
block|,
literal|0x9864
block|,
literal|0x9c00
block|,
literal|0x9c6c
block|,
literal|0x9c80
block|,
literal|0x9cec
block|,
literal|0x9d00
block|,
literal|0x9d6c
block|,
literal|0x9d80
block|,
literal|0x9dec
block|,
literal|0x9e00
block|,
literal|0x9e6c
block|,
literal|0x9e80
block|,
literal|0x9eec
block|,
literal|0x9f00
block|,
literal|0x9f6c
block|,
literal|0x9f80
block|,
literal|0x9fec
block|,
literal|0xd004
block|,
literal|0xd03c
block|,
literal|0xdfc0
block|,
literal|0xdfe0
block|,
literal|0xe000
block|,
literal|0xea7c
block|,
literal|0xf000
block|,
literal|0x11110
block|,
literal|0x11118
block|,
literal|0x11190
block|,
literal|0x19040
block|,
literal|0x1906c
block|,
literal|0x19078
block|,
literal|0x19080
block|,
literal|0x1908c
block|,
literal|0x19124
block|,
literal|0x19150
block|,
literal|0x191b0
block|,
literal|0x191d0
block|,
literal|0x191e8
block|,
literal|0x19238
block|,
literal|0x1924c
block|,
literal|0x193f8
block|,
literal|0x19474
block|,
literal|0x19490
block|,
literal|0x194f8
block|,
literal|0x19800
block|,
literal|0x19f30
block|,
literal|0x1a000
block|,
literal|0x1a06c
block|,
literal|0x1a0b0
block|,
literal|0x1a120
block|,
literal|0x1a128
block|,
literal|0x1a138
block|,
literal|0x1a190
block|,
literal|0x1a1c4
block|,
literal|0x1a1fc
block|,
literal|0x1a1fc
block|,
literal|0x1e040
block|,
literal|0x1e04c
block|,
literal|0x1e284
block|,
literal|0x1e28c
block|,
literal|0x1e2c0
block|,
literal|0x1e2c0
block|,
literal|0x1e2e0
block|,
literal|0x1e2e0
block|,
literal|0x1e300
block|,
literal|0x1e384
block|,
literal|0x1e3c0
block|,
literal|0x1e3c8
block|,
literal|0x1e440
block|,
literal|0x1e44c
block|,
literal|0x1e684
block|,
literal|0x1e68c
block|,
literal|0x1e6c0
block|,
literal|0x1e6c0
block|,
literal|0x1e6e0
block|,
literal|0x1e6e0
block|,
literal|0x1e700
block|,
literal|0x1e784
block|,
literal|0x1e7c0
block|,
literal|0x1e7c8
block|,
literal|0x1e840
block|,
literal|0x1e84c
block|,
literal|0x1ea84
block|,
literal|0x1ea8c
block|,
literal|0x1eac0
block|,
literal|0x1eac0
block|,
literal|0x1eae0
block|,
literal|0x1eae0
block|,
literal|0x1eb00
block|,
literal|0x1eb84
block|,
literal|0x1ebc0
block|,
literal|0x1ebc8
block|,
literal|0x1ec40
block|,
literal|0x1ec4c
block|,
literal|0x1ee84
block|,
literal|0x1ee8c
block|,
literal|0x1eec0
block|,
literal|0x1eec0
block|,
literal|0x1eee0
block|,
literal|0x1eee0
block|,
literal|0x1ef00
block|,
literal|0x1ef84
block|,
literal|0x1efc0
block|,
literal|0x1efc8
block|,
literal|0x1f040
block|,
literal|0x1f04c
block|,
literal|0x1f284
block|,
literal|0x1f28c
block|,
literal|0x1f2c0
block|,
literal|0x1f2c0
block|,
literal|0x1f2e0
block|,
literal|0x1f2e0
block|,
literal|0x1f300
block|,
literal|0x1f384
block|,
literal|0x1f3c0
block|,
literal|0x1f3c8
block|,
literal|0x1f440
block|,
literal|0x1f44c
block|,
literal|0x1f684
block|,
literal|0x1f68c
block|,
literal|0x1f6c0
block|,
literal|0x1f6c0
block|,
literal|0x1f6e0
block|,
literal|0x1f6e0
block|,
literal|0x1f700
block|,
literal|0x1f784
block|,
literal|0x1f7c0
block|,
literal|0x1f7c8
block|,
literal|0x1f840
block|,
literal|0x1f84c
block|,
literal|0x1fa84
block|,
literal|0x1fa8c
block|,
literal|0x1fac0
block|,
literal|0x1fac0
block|,
literal|0x1fae0
block|,
literal|0x1fae0
block|,
literal|0x1fb00
block|,
literal|0x1fb84
block|,
literal|0x1fbc0
block|,
literal|0x1fbc8
block|,
literal|0x1fc40
block|,
literal|0x1fc4c
block|,
literal|0x1fe84
block|,
literal|0x1fe8c
block|,
literal|0x1fec0
block|,
literal|0x1fec0
block|,
literal|0x1fee0
block|,
literal|0x1fee0
block|,
literal|0x1ff00
block|,
literal|0x1ff84
block|,
literal|0x1ffc0
block|,
literal|0x1ffc8
block|,
literal|0x20000
block|,
literal|0x2002c
block|,
literal|0x20100
block|,
literal|0x2013c
block|,
literal|0x20190
block|,
literal|0x201c8
block|,
literal|0x20200
block|,
literal|0x20318
block|,
literal|0x20400
block|,
literal|0x20528
block|,
literal|0x20540
block|,
literal|0x20614
block|,
literal|0x21000
block|,
literal|0x21040
block|,
literal|0x2104c
block|,
literal|0x21060
block|,
literal|0x210c0
block|,
literal|0x210ec
block|,
literal|0x21200
block|,
literal|0x21268
block|,
literal|0x21270
block|,
literal|0x21284
block|,
literal|0x212fc
block|,
literal|0x21388
block|,
literal|0x21400
block|,
literal|0x21404
block|,
literal|0x21500
block|,
literal|0x21518
block|,
literal|0x2152c
block|,
literal|0x2153c
block|,
literal|0x21550
block|,
literal|0x21554
block|,
literal|0x21600
block|,
literal|0x21600
block|,
literal|0x21608
block|,
literal|0x21628
block|,
literal|0x21630
block|,
literal|0x2163c
block|,
literal|0x21700
block|,
literal|0x2171c
block|,
literal|0x21780
block|,
literal|0x2178c
block|,
literal|0x21800
block|,
literal|0x21c38
block|,
literal|0x21c80
block|,
literal|0x21d7c
block|,
literal|0x21e00
block|,
literal|0x21e04
block|,
literal|0x22000
block|,
literal|0x2202c
block|,
literal|0x22100
block|,
literal|0x2213c
block|,
literal|0x22190
block|,
literal|0x221c8
block|,
literal|0x22200
block|,
literal|0x22318
block|,
literal|0x22400
block|,
literal|0x22528
block|,
literal|0x22540
block|,
literal|0x22614
block|,
literal|0x23000
block|,
literal|0x23040
block|,
literal|0x2304c
block|,
literal|0x23060
block|,
literal|0x230c0
block|,
literal|0x230ec
block|,
literal|0x23200
block|,
literal|0x23268
block|,
literal|0x23270
block|,
literal|0x23284
block|,
literal|0x232fc
block|,
literal|0x23388
block|,
literal|0x23400
block|,
literal|0x23404
block|,
literal|0x23500
block|,
literal|0x23518
block|,
literal|0x2352c
block|,
literal|0x2353c
block|,
literal|0x23550
block|,
literal|0x23554
block|,
literal|0x23600
block|,
literal|0x23600
block|,
literal|0x23608
block|,
literal|0x23628
block|,
literal|0x23630
block|,
literal|0x2363c
block|,
literal|0x23700
block|,
literal|0x2371c
block|,
literal|0x23780
block|,
literal|0x2378c
block|,
literal|0x23800
block|,
literal|0x23c38
block|,
literal|0x23c80
block|,
literal|0x23d7c
block|,
literal|0x23e00
block|,
literal|0x23e04
block|,
literal|0x24000
block|,
literal|0x2402c
block|,
literal|0x24100
block|,
literal|0x2413c
block|,
literal|0x24190
block|,
literal|0x241c8
block|,
literal|0x24200
block|,
literal|0x24318
block|,
literal|0x24400
block|,
literal|0x24528
block|,
literal|0x24540
block|,
literal|0x24614
block|,
literal|0x25000
block|,
literal|0x25040
block|,
literal|0x2504c
block|,
literal|0x25060
block|,
literal|0x250c0
block|,
literal|0x250ec
block|,
literal|0x25200
block|,
literal|0x25268
block|,
literal|0x25270
block|,
literal|0x25284
block|,
literal|0x252fc
block|,
literal|0x25388
block|,
literal|0x25400
block|,
literal|0x25404
block|,
literal|0x25500
block|,
literal|0x25518
block|,
literal|0x2552c
block|,
literal|0x2553c
block|,
literal|0x25550
block|,
literal|0x25554
block|,
literal|0x25600
block|,
literal|0x25600
block|,
literal|0x25608
block|,
literal|0x25628
block|,
literal|0x25630
block|,
literal|0x2563c
block|,
literal|0x25700
block|,
literal|0x2571c
block|,
literal|0x25780
block|,
literal|0x2578c
block|,
literal|0x25800
block|,
literal|0x25c38
block|,
literal|0x25c80
block|,
literal|0x25d7c
block|,
literal|0x25e00
block|,
literal|0x25e04
block|,
literal|0x26000
block|,
literal|0x2602c
block|,
literal|0x26100
block|,
literal|0x2613c
block|,
literal|0x26190
block|,
literal|0x261c8
block|,
literal|0x26200
block|,
literal|0x26318
block|,
literal|0x26400
block|,
literal|0x26528
block|,
literal|0x26540
block|,
literal|0x26614
block|,
literal|0x27000
block|,
literal|0x27040
block|,
literal|0x2704c
block|,
literal|0x27060
block|,
literal|0x270c0
block|,
literal|0x270ec
block|,
literal|0x27200
block|,
literal|0x27268
block|,
literal|0x27270
block|,
literal|0x27284
block|,
literal|0x272fc
block|,
literal|0x27388
block|,
literal|0x27400
block|,
literal|0x27404
block|,
literal|0x27500
block|,
literal|0x27518
block|,
literal|0x2752c
block|,
literal|0x2753c
block|,
literal|0x27550
block|,
literal|0x27554
block|,
literal|0x27600
block|,
literal|0x27600
block|,
literal|0x27608
block|,
literal|0x27628
block|,
literal|0x27630
block|,
literal|0x2763c
block|,
literal|0x27700
block|,
literal|0x2771c
block|,
literal|0x27780
block|,
literal|0x2778c
block|,
literal|0x27800
block|,
literal|0x27c38
block|,
literal|0x27c80
block|,
literal|0x27d7c
block|,
literal|0x27e00
block|,
literal|0x27e04
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|t5_reg_ranges
index|[]
init|=
block|{
literal|0x1008
block|,
literal|0x1148
block|,
literal|0x1180
block|,
literal|0x11b4
block|,
literal|0x11fc
block|,
literal|0x123c
block|,
literal|0x1280
block|,
literal|0x173c
block|,
literal|0x1800
block|,
literal|0x18fc
block|,
literal|0x3000
block|,
literal|0x3028
block|,
literal|0x3060
block|,
literal|0x30d8
block|,
literal|0x30e0
block|,
literal|0x30fc
block|,
literal|0x3140
block|,
literal|0x357c
block|,
literal|0x35a8
block|,
literal|0x35cc
block|,
literal|0x35ec
block|,
literal|0x35ec
block|,
literal|0x3600
block|,
literal|0x5624
block|,
literal|0x56cc
block|,
literal|0x575c
block|,
literal|0x580c
block|,
literal|0x5814
block|,
literal|0x5890
block|,
literal|0x58bc
block|,
literal|0x5940
block|,
literal|0x59dc
block|,
literal|0x59fc
block|,
literal|0x5a18
block|,
literal|0x5a60
block|,
literal|0x5a9c
block|,
literal|0x5b94
block|,
literal|0x5bfc
block|,
literal|0x6000
block|,
literal|0x6040
block|,
literal|0x6058
block|,
literal|0x614c
block|,
literal|0x7700
block|,
literal|0x7798
block|,
literal|0x77c0
block|,
literal|0x78fc
block|,
literal|0x7b00
block|,
literal|0x7c54
block|,
literal|0x7d00
block|,
literal|0x7efc
block|,
literal|0x8dc0
block|,
literal|0x8de0
block|,
literal|0x8df8
block|,
literal|0x8e84
block|,
literal|0x8ea0
block|,
literal|0x8f84
block|,
literal|0x8fc0
block|,
literal|0x90f8
block|,
literal|0x9400
block|,
literal|0x9470
block|,
literal|0x9600
block|,
literal|0x96f4
block|,
literal|0x9800
block|,
literal|0x9808
block|,
literal|0x9820
block|,
literal|0x983c
block|,
literal|0x9850
block|,
literal|0x9864
block|,
literal|0x9c00
block|,
literal|0x9c6c
block|,
literal|0x9c80
block|,
literal|0x9cec
block|,
literal|0x9d00
block|,
literal|0x9d6c
block|,
literal|0x9d80
block|,
literal|0x9dec
block|,
literal|0x9e00
block|,
literal|0x9e6c
block|,
literal|0x9e80
block|,
literal|0x9eec
block|,
literal|0x9f00
block|,
literal|0x9f6c
block|,
literal|0x9f80
block|,
literal|0xa020
block|,
literal|0xd004
block|,
literal|0xd03c
block|,
literal|0xdfc0
block|,
literal|0xdfe0
block|,
literal|0xe000
block|,
literal|0x11088
block|,
literal|0x1109c
block|,
literal|0x11110
block|,
literal|0x11118
block|,
literal|0x1117c
block|,
literal|0x11190
block|,
literal|0x11204
block|,
literal|0x19040
block|,
literal|0x1906c
block|,
literal|0x19078
block|,
literal|0x19080
block|,
literal|0x1908c
block|,
literal|0x19124
block|,
literal|0x19150
block|,
literal|0x191b0
block|,
literal|0x191d0
block|,
literal|0x191e8
block|,
literal|0x19238
block|,
literal|0x19290
block|,
literal|0x193f8
block|,
literal|0x19474
block|,
literal|0x19490
block|,
literal|0x194cc
block|,
literal|0x194f0
block|,
literal|0x194f8
block|,
literal|0x19c00
block|,
literal|0x19c60
block|,
literal|0x19c94
block|,
literal|0x19e10
block|,
literal|0x19e50
block|,
literal|0x19f34
block|,
literal|0x19f40
block|,
literal|0x19f50
block|,
literal|0x19f90
block|,
literal|0x19fe4
block|,
literal|0x1a000
block|,
literal|0x1a06c
block|,
literal|0x1a0b0
block|,
literal|0x1a120
block|,
literal|0x1a128
block|,
literal|0x1a138
block|,
literal|0x1a190
block|,
literal|0x1a1c4
block|,
literal|0x1a1fc
block|,
literal|0x1a1fc
block|,
literal|0x1e008
block|,
literal|0x1e00c
block|,
literal|0x1e040
block|,
literal|0x1e04c
block|,
literal|0x1e284
block|,
literal|0x1e290
block|,
literal|0x1e2c0
block|,
literal|0x1e2c0
block|,
literal|0x1e2e0
block|,
literal|0x1e2e0
block|,
literal|0x1e300
block|,
literal|0x1e384
block|,
literal|0x1e3c0
block|,
literal|0x1e3c8
block|,
literal|0x1e408
block|,
literal|0x1e40c
block|,
literal|0x1e440
block|,
literal|0x1e44c
block|,
literal|0x1e684
block|,
literal|0x1e690
block|,
literal|0x1e6c0
block|,
literal|0x1e6c0
block|,
literal|0x1e6e0
block|,
literal|0x1e6e0
block|,
literal|0x1e700
block|,
literal|0x1e784
block|,
literal|0x1e7c0
block|,
literal|0x1e7c8
block|,
literal|0x1e808
block|,
literal|0x1e80c
block|,
literal|0x1e840
block|,
literal|0x1e84c
block|,
literal|0x1ea84
block|,
literal|0x1ea90
block|,
literal|0x1eac0
block|,
literal|0x1eac0
block|,
literal|0x1eae0
block|,
literal|0x1eae0
block|,
literal|0x1eb00
block|,
literal|0x1eb84
block|,
literal|0x1ebc0
block|,
literal|0x1ebc8
block|,
literal|0x1ec08
block|,
literal|0x1ec0c
block|,
literal|0x1ec40
block|,
literal|0x1ec4c
block|,
literal|0x1ee84
block|,
literal|0x1ee90
block|,
literal|0x1eec0
block|,
literal|0x1eec0
block|,
literal|0x1eee0
block|,
literal|0x1eee0
block|,
literal|0x1ef00
block|,
literal|0x1ef84
block|,
literal|0x1efc0
block|,
literal|0x1efc8
block|,
literal|0x1f008
block|,
literal|0x1f00c
block|,
literal|0x1f040
block|,
literal|0x1f04c
block|,
literal|0x1f284
block|,
literal|0x1f290
block|,
literal|0x1f2c0
block|,
literal|0x1f2c0
block|,
literal|0x1f2e0
block|,
literal|0x1f2e0
block|,
literal|0x1f300
block|,
literal|0x1f384
block|,
literal|0x1f3c0
block|,
literal|0x1f3c8
block|,
literal|0x1f408
block|,
literal|0x1f40c
block|,
literal|0x1f440
block|,
literal|0x1f44c
block|,
literal|0x1f684
block|,
literal|0x1f690
block|,
literal|0x1f6c0
block|,
literal|0x1f6c0
block|,
literal|0x1f6e0
block|,
literal|0x1f6e0
block|,
literal|0x1f700
block|,
literal|0x1f784
block|,
literal|0x1f7c0
block|,
literal|0x1f7c8
block|,
literal|0x1f808
block|,
literal|0x1f80c
block|,
literal|0x1f840
block|,
literal|0x1f84c
block|,
literal|0x1fa84
block|,
literal|0x1fa90
block|,
literal|0x1fac0
block|,
literal|0x1fac0
block|,
literal|0x1fae0
block|,
literal|0x1fae0
block|,
literal|0x1fb00
block|,
literal|0x1fb84
block|,
literal|0x1fbc0
block|,
literal|0x1fbc8
block|,
literal|0x1fc08
block|,
literal|0x1fc0c
block|,
literal|0x1fc40
block|,
literal|0x1fc4c
block|,
literal|0x1fe84
block|,
literal|0x1fe90
block|,
literal|0x1fec0
block|,
literal|0x1fec0
block|,
literal|0x1fee0
block|,
literal|0x1fee0
block|,
literal|0x1ff00
block|,
literal|0x1ff84
block|,
literal|0x1ffc0
block|,
literal|0x1ffc8
block|,
literal|0x30000
block|,
literal|0x30030
block|,
literal|0x30100
block|,
literal|0x30144
block|,
literal|0x30190
block|,
literal|0x301d0
block|,
literal|0x30200
block|,
literal|0x30318
block|,
literal|0x30400
block|,
literal|0x3052c
block|,
literal|0x30540
block|,
literal|0x3061c
block|,
literal|0x30800
block|,
literal|0x30834
block|,
literal|0x308c0
block|,
literal|0x30908
block|,
literal|0x30910
block|,
literal|0x309ac
block|,
literal|0x30a00
block|,
literal|0x30a2c
block|,
literal|0x30a44
block|,
literal|0x30a50
block|,
literal|0x30a74
block|,
literal|0x30c24
block|,
literal|0x30d00
block|,
literal|0x30d00
block|,
literal|0x30d08
block|,
literal|0x30d14
block|,
literal|0x30d1c
block|,
literal|0x30d20
block|,
literal|0x30d3c
block|,
literal|0x30d50
block|,
literal|0x31200
block|,
literal|0x3120c
block|,
literal|0x31220
block|,
literal|0x31220
block|,
literal|0x31240
block|,
literal|0x31240
block|,
literal|0x31600
block|,
literal|0x3160c
block|,
literal|0x31a00
block|,
literal|0x31a1c
block|,
literal|0x31e00
block|,
literal|0x31e20
block|,
literal|0x31e38
block|,
literal|0x31e3c
block|,
literal|0x31e80
block|,
literal|0x31e80
block|,
literal|0x31e88
block|,
literal|0x31ea8
block|,
literal|0x31eb0
block|,
literal|0x31eb4
block|,
literal|0x31ec8
block|,
literal|0x31ed4
block|,
literal|0x31fb8
block|,
literal|0x32004
block|,
literal|0x32200
block|,
literal|0x32200
block|,
literal|0x32208
block|,
literal|0x32240
block|,
literal|0x32248
block|,
literal|0x32280
block|,
literal|0x32288
block|,
literal|0x322c0
block|,
literal|0x322c8
block|,
literal|0x322fc
block|,
literal|0x32600
block|,
literal|0x32630
block|,
literal|0x32a00
block|,
literal|0x32abc
block|,
literal|0x32b00
block|,
literal|0x32b70
block|,
literal|0x33000
block|,
literal|0x33048
block|,
literal|0x33060
block|,
literal|0x3309c
block|,
literal|0x330f0
block|,
literal|0x33148
block|,
literal|0x33160
block|,
literal|0x3319c
block|,
literal|0x331f0
block|,
literal|0x332e4
block|,
literal|0x332f8
block|,
literal|0x333e4
block|,
literal|0x333f8
block|,
literal|0x33448
block|,
literal|0x33460
block|,
literal|0x3349c
block|,
literal|0x334f0
block|,
literal|0x33548
block|,
literal|0x33560
block|,
literal|0x3359c
block|,
literal|0x335f0
block|,
literal|0x336e4
block|,
literal|0x336f8
block|,
literal|0x337e4
block|,
literal|0x337f8
block|,
literal|0x337fc
block|,
literal|0x33814
block|,
literal|0x33814
block|,
literal|0x3382c
block|,
literal|0x3382c
block|,
literal|0x33880
block|,
literal|0x3388c
block|,
literal|0x338e8
block|,
literal|0x338ec
block|,
literal|0x33900
block|,
literal|0x33948
block|,
literal|0x33960
block|,
literal|0x3399c
block|,
literal|0x339f0
block|,
literal|0x33ae4
block|,
literal|0x33af8
block|,
literal|0x33b10
block|,
literal|0x33b28
block|,
literal|0x33b28
block|,
literal|0x33b3c
block|,
literal|0x33b50
block|,
literal|0x33bf0
block|,
literal|0x33c10
block|,
literal|0x33c28
block|,
literal|0x33c28
block|,
literal|0x33c3c
block|,
literal|0x33c50
block|,
literal|0x33cf0
block|,
literal|0x33cfc
block|,
literal|0x34000
block|,
literal|0x34030
block|,
literal|0x34100
block|,
literal|0x34144
block|,
literal|0x34190
block|,
literal|0x341d0
block|,
literal|0x34200
block|,
literal|0x34318
block|,
literal|0x34400
block|,
literal|0x3452c
block|,
literal|0x34540
block|,
literal|0x3461c
block|,
literal|0x34800
block|,
literal|0x34834
block|,
literal|0x348c0
block|,
literal|0x34908
block|,
literal|0x34910
block|,
literal|0x349ac
block|,
literal|0x34a00
block|,
literal|0x34a2c
block|,
literal|0x34a44
block|,
literal|0x34a50
block|,
literal|0x34a74
block|,
literal|0x34c24
block|,
literal|0x34d00
block|,
literal|0x34d00
block|,
literal|0x34d08
block|,
literal|0x34d14
block|,
literal|0x34d1c
block|,
literal|0x34d20
block|,
literal|0x34d3c
block|,
literal|0x34d50
block|,
literal|0x35200
block|,
literal|0x3520c
block|,
literal|0x35220
block|,
literal|0x35220
block|,
literal|0x35240
block|,
literal|0x35240
block|,
literal|0x35600
block|,
literal|0x3560c
block|,
literal|0x35a00
block|,
literal|0x35a1c
block|,
literal|0x35e00
block|,
literal|0x35e20
block|,
literal|0x35e38
block|,
literal|0x35e3c
block|,
literal|0x35e80
block|,
literal|0x35e80
block|,
literal|0x35e88
block|,
literal|0x35ea8
block|,
literal|0x35eb0
block|,
literal|0x35eb4
block|,
literal|0x35ec8
block|,
literal|0x35ed4
block|,
literal|0x35fb8
block|,
literal|0x36004
block|,
literal|0x36200
block|,
literal|0x36200
block|,
literal|0x36208
block|,
literal|0x36240
block|,
literal|0x36248
block|,
literal|0x36280
block|,
literal|0x36288
block|,
literal|0x362c0
block|,
literal|0x362c8
block|,
literal|0x362fc
block|,
literal|0x36600
block|,
literal|0x36630
block|,
literal|0x36a00
block|,
literal|0x36abc
block|,
literal|0x36b00
block|,
literal|0x36b70
block|,
literal|0x37000
block|,
literal|0x37048
block|,
literal|0x37060
block|,
literal|0x3709c
block|,
literal|0x370f0
block|,
literal|0x37148
block|,
literal|0x37160
block|,
literal|0x3719c
block|,
literal|0x371f0
block|,
literal|0x372e4
block|,
literal|0x372f8
block|,
literal|0x373e4
block|,
literal|0x373f8
block|,
literal|0x37448
block|,
literal|0x37460
block|,
literal|0x3749c
block|,
literal|0x374f0
block|,
literal|0x37548
block|,
literal|0x37560
block|,
literal|0x3759c
block|,
literal|0x375f0
block|,
literal|0x376e4
block|,
literal|0x376f8
block|,
literal|0x377e4
block|,
literal|0x377f8
block|,
literal|0x377fc
block|,
literal|0x37814
block|,
literal|0x37814
block|,
literal|0x3782c
block|,
literal|0x3782c
block|,
literal|0x37880
block|,
literal|0x3788c
block|,
literal|0x378e8
block|,
literal|0x378ec
block|,
literal|0x37900
block|,
literal|0x37948
block|,
literal|0x37960
block|,
literal|0x3799c
block|,
literal|0x379f0
block|,
literal|0x37ae4
block|,
literal|0x37af8
block|,
literal|0x37b10
block|,
literal|0x37b28
block|,
literal|0x37b28
block|,
literal|0x37b3c
block|,
literal|0x37b50
block|,
literal|0x37bf0
block|,
literal|0x37c10
block|,
literal|0x37c28
block|,
literal|0x37c28
block|,
literal|0x37c3c
block|,
literal|0x37c50
block|,
literal|0x37cf0
block|,
literal|0x37cfc
block|,
literal|0x38000
block|,
literal|0x38030
block|,
literal|0x38100
block|,
literal|0x38144
block|,
literal|0x38190
block|,
literal|0x381d0
block|,
literal|0x38200
block|,
literal|0x38318
block|,
literal|0x38400
block|,
literal|0x3852c
block|,
literal|0x38540
block|,
literal|0x3861c
block|,
literal|0x38800
block|,
literal|0x38834
block|,
literal|0x388c0
block|,
literal|0x38908
block|,
literal|0x38910
block|,
literal|0x389ac
block|,
literal|0x38a00
block|,
literal|0x38a2c
block|,
literal|0x38a44
block|,
literal|0x38a50
block|,
literal|0x38a74
block|,
literal|0x38c24
block|,
literal|0x38d00
block|,
literal|0x38d00
block|,
literal|0x38d08
block|,
literal|0x38d14
block|,
literal|0x38d1c
block|,
literal|0x38d20
block|,
literal|0x38d3c
block|,
literal|0x38d50
block|,
literal|0x39200
block|,
literal|0x3920c
block|,
literal|0x39220
block|,
literal|0x39220
block|,
literal|0x39240
block|,
literal|0x39240
block|,
literal|0x39600
block|,
literal|0x3960c
block|,
literal|0x39a00
block|,
literal|0x39a1c
block|,
literal|0x39e00
block|,
literal|0x39e20
block|,
literal|0x39e38
block|,
literal|0x39e3c
block|,
literal|0x39e80
block|,
literal|0x39e80
block|,
literal|0x39e88
block|,
literal|0x39ea8
block|,
literal|0x39eb0
block|,
literal|0x39eb4
block|,
literal|0x39ec8
block|,
literal|0x39ed4
block|,
literal|0x39fb8
block|,
literal|0x3a004
block|,
literal|0x3a200
block|,
literal|0x3a200
block|,
literal|0x3a208
block|,
literal|0x3a240
block|,
literal|0x3a248
block|,
literal|0x3a280
block|,
literal|0x3a288
block|,
literal|0x3a2c0
block|,
literal|0x3a2c8
block|,
literal|0x3a2fc
block|,
literal|0x3a600
block|,
literal|0x3a630
block|,
literal|0x3aa00
block|,
literal|0x3aabc
block|,
literal|0x3ab00
block|,
literal|0x3ab70
block|,
literal|0x3b000
block|,
literal|0x3b048
block|,
literal|0x3b060
block|,
literal|0x3b09c
block|,
literal|0x3b0f0
block|,
literal|0x3b148
block|,
literal|0x3b160
block|,
literal|0x3b19c
block|,
literal|0x3b1f0
block|,
literal|0x3b2e4
block|,
literal|0x3b2f8
block|,
literal|0x3b3e4
block|,
literal|0x3b3f8
block|,
literal|0x3b448
block|,
literal|0x3b460
block|,
literal|0x3b49c
block|,
literal|0x3b4f0
block|,
literal|0x3b548
block|,
literal|0x3b560
block|,
literal|0x3b59c
block|,
literal|0x3b5f0
block|,
literal|0x3b6e4
block|,
literal|0x3b6f8
block|,
literal|0x3b7e4
block|,
literal|0x3b7f8
block|,
literal|0x3b7fc
block|,
literal|0x3b814
block|,
literal|0x3b814
block|,
literal|0x3b82c
block|,
literal|0x3b82c
block|,
literal|0x3b880
block|,
literal|0x3b88c
block|,
literal|0x3b8e8
block|,
literal|0x3b8ec
block|,
literal|0x3b900
block|,
literal|0x3b948
block|,
literal|0x3b960
block|,
literal|0x3b99c
block|,
literal|0x3b9f0
block|,
literal|0x3bae4
block|,
literal|0x3baf8
block|,
literal|0x3bb10
block|,
literal|0x3bb28
block|,
literal|0x3bb28
block|,
literal|0x3bb3c
block|,
literal|0x3bb50
block|,
literal|0x3bbf0
block|,
literal|0x3bc10
block|,
literal|0x3bc28
block|,
literal|0x3bc28
block|,
literal|0x3bc3c
block|,
literal|0x3bc50
block|,
literal|0x3bcf0
block|,
literal|0x3bcfc
block|,
literal|0x3c000
block|,
literal|0x3c030
block|,
literal|0x3c100
block|,
literal|0x3c144
block|,
literal|0x3c190
block|,
literal|0x3c1d0
block|,
literal|0x3c200
block|,
literal|0x3c318
block|,
literal|0x3c400
block|,
literal|0x3c52c
block|,
literal|0x3c540
block|,
literal|0x3c61c
block|,
literal|0x3c800
block|,
literal|0x3c834
block|,
literal|0x3c8c0
block|,
literal|0x3c908
block|,
literal|0x3c910
block|,
literal|0x3c9ac
block|,
literal|0x3ca00
block|,
literal|0x3ca2c
block|,
literal|0x3ca44
block|,
literal|0x3ca50
block|,
literal|0x3ca74
block|,
literal|0x3cc24
block|,
literal|0x3cd00
block|,
literal|0x3cd00
block|,
literal|0x3cd08
block|,
literal|0x3cd14
block|,
literal|0x3cd1c
block|,
literal|0x3cd20
block|,
literal|0x3cd3c
block|,
literal|0x3cd50
block|,
literal|0x3d200
block|,
literal|0x3d20c
block|,
literal|0x3d220
block|,
literal|0x3d220
block|,
literal|0x3d240
block|,
literal|0x3d240
block|,
literal|0x3d600
block|,
literal|0x3d60c
block|,
literal|0x3da00
block|,
literal|0x3da1c
block|,
literal|0x3de00
block|,
literal|0x3de20
block|,
literal|0x3de38
block|,
literal|0x3de3c
block|,
literal|0x3de80
block|,
literal|0x3de80
block|,
literal|0x3de88
block|,
literal|0x3dea8
block|,
literal|0x3deb0
block|,
literal|0x3deb4
block|,
literal|0x3dec8
block|,
literal|0x3ded4
block|,
literal|0x3dfb8
block|,
literal|0x3e004
block|,
literal|0x3e200
block|,
literal|0x3e200
block|,
literal|0x3e208
block|,
literal|0x3e240
block|,
literal|0x3e248
block|,
literal|0x3e280
block|,
literal|0x3e288
block|,
literal|0x3e2c0
block|,
literal|0x3e2c8
block|,
literal|0x3e2fc
block|,
literal|0x3e600
block|,
literal|0x3e630
block|,
literal|0x3ea00
block|,
literal|0x3eabc
block|,
literal|0x3eb00
block|,
literal|0x3eb70
block|,
literal|0x3f000
block|,
literal|0x3f048
block|,
literal|0x3f060
block|,
literal|0x3f09c
block|,
literal|0x3f0f0
block|,
literal|0x3f148
block|,
literal|0x3f160
block|,
literal|0x3f19c
block|,
literal|0x3f1f0
block|,
literal|0x3f2e4
block|,
literal|0x3f2f8
block|,
literal|0x3f3e4
block|,
literal|0x3f3f8
block|,
literal|0x3f448
block|,
literal|0x3f460
block|,
literal|0x3f49c
block|,
literal|0x3f4f0
block|,
literal|0x3f548
block|,
literal|0x3f560
block|,
literal|0x3f59c
block|,
literal|0x3f5f0
block|,
literal|0x3f6e4
block|,
literal|0x3f6f8
block|,
literal|0x3f7e4
block|,
literal|0x3f7f8
block|,
literal|0x3f7fc
block|,
literal|0x3f814
block|,
literal|0x3f814
block|,
literal|0x3f82c
block|,
literal|0x3f82c
block|,
literal|0x3f880
block|,
literal|0x3f88c
block|,
literal|0x3f8e8
block|,
literal|0x3f8ec
block|,
literal|0x3f900
block|,
literal|0x3f948
block|,
literal|0x3f960
block|,
literal|0x3f99c
block|,
literal|0x3f9f0
block|,
literal|0x3fae4
block|,
literal|0x3faf8
block|,
literal|0x3fb10
block|,
literal|0x3fb28
block|,
literal|0x3fb28
block|,
literal|0x3fb3c
block|,
literal|0x3fb50
block|,
literal|0x3fbf0
block|,
literal|0x3fc10
block|,
literal|0x3fc28
block|,
literal|0x3fc28
block|,
literal|0x3fc3c
block|,
literal|0x3fc50
block|,
literal|0x3fcf0
block|,
literal|0x3fcfc
block|,
literal|0x40000
block|,
literal|0x4000c
block|,
literal|0x40040
block|,
literal|0x40068
block|,
literal|0x4007c
block|,
literal|0x40144
block|,
literal|0x40180
block|,
literal|0x4018c
block|,
literal|0x40200
block|,
literal|0x40298
block|,
literal|0x402ac
block|,
literal|0x4033c
block|,
literal|0x403f8
block|,
literal|0x403fc
block|,
literal|0x41304
block|,
literal|0x413c4
block|,
literal|0x41400
block|,
literal|0x4141c
block|,
literal|0x41480
block|,
literal|0x414d0
block|,
literal|0x44000
block|,
literal|0x44078
block|,
literal|0x440c0
block|,
literal|0x44278
block|,
literal|0x442c0
block|,
literal|0x44478
block|,
literal|0x444c0
block|,
literal|0x44678
block|,
literal|0x446c0
block|,
literal|0x44878
block|,
literal|0x448c0
block|,
literal|0x449fc
block|,
literal|0x45000
block|,
literal|0x45068
block|,
literal|0x45080
block|,
literal|0x45084
block|,
literal|0x450a0
block|,
literal|0x450b0
block|,
literal|0x45200
block|,
literal|0x45268
block|,
literal|0x45280
block|,
literal|0x45284
block|,
literal|0x452a0
block|,
literal|0x452b0
block|,
literal|0x460c0
block|,
literal|0x460e4
block|,
literal|0x47000
block|,
literal|0x4708c
block|,
literal|0x47200
block|,
literal|0x47250
block|,
literal|0x47400
block|,
literal|0x47420
block|,
literal|0x47600
block|,
literal|0x47618
block|,
literal|0x47800
block|,
literal|0x47814
block|,
literal|0x48000
block|,
literal|0x4800c
block|,
literal|0x48040
block|,
literal|0x48068
block|,
literal|0x4807c
block|,
literal|0x48144
block|,
literal|0x48180
block|,
literal|0x4818c
block|,
literal|0x48200
block|,
literal|0x48298
block|,
literal|0x482ac
block|,
literal|0x4833c
block|,
literal|0x483f8
block|,
literal|0x483fc
block|,
literal|0x49304
block|,
literal|0x493c4
block|,
literal|0x49400
block|,
literal|0x4941c
block|,
literal|0x49480
block|,
literal|0x494d0
block|,
literal|0x4c000
block|,
literal|0x4c078
block|,
literal|0x4c0c0
block|,
literal|0x4c278
block|,
literal|0x4c2c0
block|,
literal|0x4c478
block|,
literal|0x4c4c0
block|,
literal|0x4c678
block|,
literal|0x4c6c0
block|,
literal|0x4c878
block|,
literal|0x4c8c0
block|,
literal|0x4c9fc
block|,
literal|0x4d000
block|,
literal|0x4d068
block|,
literal|0x4d080
block|,
literal|0x4d084
block|,
literal|0x4d0a0
block|,
literal|0x4d0b0
block|,
literal|0x4d200
block|,
literal|0x4d268
block|,
literal|0x4d280
block|,
literal|0x4d284
block|,
literal|0x4d2a0
block|,
literal|0x4d2b0
block|,
literal|0x4e0c0
block|,
literal|0x4e0e4
block|,
literal|0x4f000
block|,
literal|0x4f08c
block|,
literal|0x4f200
block|,
literal|0x4f250
block|,
literal|0x4f400
block|,
literal|0x4f420
block|,
literal|0x4f600
block|,
literal|0x4f618
block|,
literal|0x4f800
block|,
literal|0x4f814
block|,
literal|0x50000
block|,
literal|0x500cc
block|,
literal|0x50400
block|,
literal|0x50400
block|,
literal|0x50800
block|,
literal|0x508cc
block|,
literal|0x50c00
block|,
literal|0x50c00
block|,
literal|0x51000
block|,
literal|0x5101c
block|,
literal|0x51300
block|,
literal|0x51308
block|, 	}
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|reg_ranges
operator|=
operator|&
name|t4_reg_ranges
index|[
literal|0
index|]
expr_stmt|;
name|n
operator|=
name|nitems
argument_list|(
name|t4_reg_ranges
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg_ranges
operator|=
operator|&
name|t5_reg_ranges
index|[
literal|0
index|]
expr_stmt|;
name|n
operator|=
name|nitems
argument_list|(
name|t5_reg_ranges
argument_list|)
expr_stmt|;
block|}
name|regs
operator|->
name|version
operator|=
name|chip_id
argument_list|(
name|sc
argument_list|)
operator||
name|chip_rev
argument_list|(
name|sc
argument_list|)
operator|<<
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|2
control|)
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|reg_ranges
index|[
name|i
index|]
argument_list|,
name|reg_ranges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|drops
decl_stmt|;
name|struct
name|port_stats
modifier|*
name|s
init|=
operator|&
name|pi
operator|->
name|stats
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return;
comment|/* without scheduling another callout */
block|}
name|t4_get_port_stats
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|s
operator|->
name|tx_frames
operator|-
name|s
operator|->
name|tx_pause
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|=
name|s
operator|->
name|rx_frames
operator|-
name|s
operator|->
name|rx_pause
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|s
operator|->
name|tx_octets
operator|-
name|s
operator|->
name|tx_pause
operator|*
literal|64
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|s
operator|->
name|rx_octets
operator|-
name|s
operator|->
name|rx_pause
operator|*
literal|64
expr_stmt|;
name|ifp
operator|->
name|if_omcasts
operator|=
name|s
operator|->
name|tx_mcast_frames
operator|-
name|s
operator|->
name|tx_pause
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|s
operator|->
name|rx_mcast_frames
operator|-
name|s
operator|->
name|rx_pause
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|=
name|s
operator|->
name|rx_ovflow0
operator|+
name|s
operator|->
name|rx_ovflow1
operator|+
name|s
operator|->
name|rx_ovflow2
operator|+
name|s
operator|->
name|rx_ovflow3
operator|+
name|s
operator|->
name|rx_trunc0
operator|+
name|s
operator|->
name|rx_trunc1
operator|+
name|s
operator|->
name|rx_trunc2
operator|+
name|s
operator|->
name|rx_trunc3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pi
operator|->
name|rx_chan_map
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|uint32_t
name|v
decl_stmt|;
comment|/* 			 * XXX: indirect reads from the same ADDR/DATA pair can 			 * race with each other. 			 */
name|t4_read_indirect
argument_list|(
name|sc
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
operator|&
name|v
argument_list|,
literal|1
argument_list|,
name|A_TP_MIB_TNL_CNG_DROP_0
operator|+
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|+=
name|v
expr_stmt|;
block|}
block|}
name|drops
operator|=
name|s
operator|->
name|tx_drop
expr_stmt|;
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
name|drops
operator|+=
name|txq
operator|->
name|br
operator|->
name|br_drops
expr_stmt|;
name|ifp
operator|->
name|if_oqdrops
operator|=
name|drops
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|=
name|s
operator|->
name|tx_error_frames
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|=
name|s
operator|->
name|rx_jabber
operator|+
name|s
operator|->
name|rx_runt
operator|+
name|s
operator|->
name|rx_too_long
operator|+
name|s
operator|->
name|rx_fcs_err
operator|+
name|s
operator|->
name|rx_len_err
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_vlan_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|vid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|vlan
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|ifp
operator|||
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_ETHER
condition|)
return|return;
name|vlan
operator|=
name|VLAN_DEVAT
argument_list|(
name|ifp
argument_list|,
name|vid
argument_list|)
expr_stmt|;
name|VLAN_SETCOOKIE
argument_list|(
name|vlan
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: opcode 0x%02x on iq %p with payload %p"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: opcode 0x%02x on iq %p with payload %p\n"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_cpl_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|opcode
parameter_list|,
name|cpl_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|opcode
operator|>=
name|nitems
argument_list|(
name|sc
operator|->
name|cpl_handler
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|cpl_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|cpl_handler
index|[
name|opcode
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
name|ctrl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: async notification on iq %p (ctrl %p)"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: async notification on iq %p (ctrl %p)\n"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_an_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|an_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|an_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_handler
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_msg_not_handled
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_fw6_msg
modifier|*
name|cpl
init|=
name|__containerof
argument_list|(
name|rpl
argument_list|,
expr|struct
name|cpl_fw6_msg
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: fw_msg type %d"
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: fw_msg type %d\n"
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_fw_msg_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|,
name|fw_msg_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|nitems
argument_list|(
name|sc
operator|->
name|fw_msg_handler
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * These are dispatched by the handler for FW{4|6}_CPL_MSG using the CPL 	 * handler dispatch table.  Reject any attempt to install a handler for 	 * this subtype. 	 */
if|if
condition|(
name|type
operator|==
name|FW_TYPE_RSSCPL
operator|||
name|type
operator|==
name|FW6_TYPE_RSSCPL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|fw_msg_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|fw_msg_handler
index|[
name|type
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|,
modifier|*
name|c0
decl_stmt|;
specifier|static
name|char
modifier|*
name|caps
index|[]
init|=
block|{
literal|"\20\1PPP\2QFC\3DCBX"
block|,
comment|/* caps[0] linkcaps */
literal|"\20\1NIC\2VM\3IDS\4UM\5UM_ISGL"
comment|/* caps[1] niccaps */
literal|"\6HASHFILTER\7ETHOFLD"
block|,
literal|"\20\1TOE"
block|,
comment|/* caps[2] toecaps */
literal|"\20\1RDDP\2RDMAC"
block|,
comment|/* caps[3] rdmacaps */
literal|"\20\1INITIATOR_PDU\2TARGET_PDU"
comment|/* caps[4] iscsicaps */
literal|"\3INITIATOR_CNXOFLD\4TARGET_CNXOFLD"
literal|"\5INITIATOR_SSNOFLD\6TARGET_SSNOFLD"
block|,
literal|"\20\1INITIATOR\2TARGET\3CTRL_OFLD"
comment|/* caps[5] fcoecaps */
literal|"\4PO_INITIAOR\5PO_TARGET"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|doorbells
init|=
block|{
literal|"\20\1UDB\2WCWR\3UDBWC\4KDB"
block|}
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.t4nex.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|c0
operator|=
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_do_rxcopy
operator|=
literal|1
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"do_rx_copy"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_do_rxcopy
argument_list|,
literal|1
argument_list|,
literal|"Do RX copy of small frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nports"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
literal|"# of ports"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_revision"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|chip_rev
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"chip hardware revision"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cf"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|cfg_file
argument_list|,
literal|0
argument_list|,
literal|"configuration file"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cfcsum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|cfcsum
argument_list|,
literal|"config file checksum"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"doorbells"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|doorbells
argument_list|,
name|sc
operator|->
name|doorbells
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available doorbells"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"linkcaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|linkcaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available link capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"niccaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|niccaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available NIC capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"toecaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|toecaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available TCP offload capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdmacaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|rdmacaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available RDMA capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"iscsicaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|iscsicaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available iSCSI capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fcoecaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|5
index|]
argument_list|,
name|sc
operator|->
name|fcoecaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available FCoE capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"core_clock"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
argument_list|,
literal|"core clock frequency (in KHz)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_timers"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|timer_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|timer_val
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff timer values (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pkt_counts"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|counter_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|counter_val
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff packet counter values"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nfilters"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|tids
operator|.
name|nftids
argument_list|,
literal|"number of filters"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"temperature"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_temperature
argument_list|,
literal|"I"
argument_list|,
literal|"chip temperature (in Celsius)"
argument_list|)
expr_stmt|;
name|t4_sge_sysctls
argument_list|(
name|sc
argument_list|,
name|ctx
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lro_timeout
operator|=
literal|100
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_timeout"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|lro_timeout
argument_list|,
literal|0
argument_list|,
literal|"lro inactive-flush timeout (in us)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SBUF_DRAIN
comment|/* 	 * dev.t4nex.X.misc.  Marked CTLFLAG_SKIP to avoid information overload. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|c0
argument_list|,
name|OID_AUTO
argument_list|,
literal|"misc"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_SKIP
argument_list|,
name|NULL
argument_list|,
literal|"logs and miscellaneous information"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cctrl"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cctrl
argument_list|,
literal|"A"
argument_list|,
literal|"congestion control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_tp0"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 0 (TP0)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_tp1"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 1 (TP1)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_ulp"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|2
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 2 (ULP)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_sge0"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|3
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 3 (SGE0)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_sge1"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|4
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 4 (SGE1)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_ncsi"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|5
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 5 (NCSI)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_la
argument_list|,
literal|"A"
argument_list|,
literal|"CIM logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ma_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_ma_la
argument_list|,
literal|"A"
argument_list|,
literal|"CIM MA logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp0"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 0 (ULP0)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp1"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|1
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 1 (ULP1)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp2"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|2
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 2 (ULP2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp3"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|3
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 3 (ULP3)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_sge"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|4
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 4 (SGE)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ncsi"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|5
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 5 (NCSI)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_sge0_rx"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|6
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 6 (SGE0-RX)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_sge1_rx"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|7
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 7 (SGE1-RX)"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_pif_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_pif_la
argument_list|,
literal|"A"
argument_list|,
literal|"CIM PIF logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_qcfg"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_qcfg
argument_list|,
literal|"A"
argument_list|,
literal|"CIM queue configuration"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpl_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cpl_stats
argument_list|,
literal|"A"
argument_list|,
literal|"CPL statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_ddp_stats
argument_list|,
literal|"A"
argument_list|,
literal|"DDP statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"devlog"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_devlog
argument_list|,
literal|"A"
argument_list|,
literal|"firmware's device log"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fcoe_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_fcoe_stats
argument_list|,
literal|"A"
argument_list|,
literal|"FCoE statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_sched"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_sched
argument_list|,
literal|"A"
argument_list|,
literal|"hardware scheduler "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"l2t"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_l2t
argument_list|,
literal|"A"
argument_list|,
literal|"hardware L2 table"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lb_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_lb_stats
argument_list|,
literal|"A"
argument_list|,
literal|"loopback statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"meminfo"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_meminfo
argument_list|,
literal|"A"
argument_list|,
literal|"memory regions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mps_tcam"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_mps_tcam
argument_list|,
literal|"A"
argument_list|,
literal|"MPS TCAM entries"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"path_mtus"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_path_mtus
argument_list|,
literal|"A"
argument_list|,
literal|"path MTUs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pm_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_pm_stats
argument_list|,
literal|"A"
argument_list|,
literal|"PM statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdma_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_rdma_stats
argument_list|,
literal|"A"
argument_list|,
literal|"RDMA statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tcp_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tcp_stats
argument_list|,
literal|"A"
argument_list|,
literal|"TCP statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tids"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tids
argument_list|,
literal|"A"
argument_list|,
literal|"TID information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tp_err_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tp_err_stats
argument_list|,
literal|"A"
argument_list|,
literal|"TP error statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tp_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tp_la
argument_list|,
literal|"A"
argument_list|,
literal|"TP logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_rate"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tx_rate
argument_list|,
literal|"A"
argument_list|,
literal|"Tx rate"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ulprx_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_ulprx_la
argument_list|,
literal|"A"
argument_list|,
literal|"ULPRX logic analyzer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wcwr_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_wcwr_stats
argument_list|,
literal|"A"
argument_list|,
literal|"write combined work requests"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * dev.t4nex.X.toe. 		 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|c0
argument_list|,
name|OID_AUTO
argument_list|,
literal|"toe"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"TOE parameters"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|sndbuf
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sndbuf"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|sndbuf
argument_list|,
literal|0
argument_list|,
literal|"max hardware send buffer size"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|ddp
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|ddp
argument_list|,
literal|0
argument_list|,
literal|"DDP allowed"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|indsz
operator|=
name|G_INDICATESIZE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG5
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"indsz"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|indsz
argument_list|,
literal|0
argument_list|,
literal|"DDP max indicate size allowed"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|ddp_thres
operator|=
name|G_RXCOALESCESIZE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG2
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp_thres"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|ddp_thres
argument_list|,
literal|0
argument_list|,
literal|"DDP threshold"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|rx_coalesce
operator|=
literal|1
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_coalesce"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|rx_coalesce
argument_list|,
literal|0
argument_list|,
literal|"receive coalescing"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"linkdnrc"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_linkdnrc
argument_list|,
literal|"A"
argument_list|,
literal|"reason why link is down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|port_type
operator|==
name|FW_PORT_TYPE_BT_XAUI
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"temperature"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_btphy
argument_list|,
literal|"I"
argument_list|,
literal|"PHY temperature (in Celsius)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pi
argument_list|,
literal|1
argument_list|,
name|sysctl_btphy
argument_list|,
literal|"I"
argument_list|,
literal|"PHY firmware version"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ntxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|ntxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first tx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rsrv_noflowq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_noflowq
argument_list|,
literal|"IU"
argument_list|,
literal|"Reserve queue 0 for non-flowid packets"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nofldrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nofldrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nofldtxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nofldtxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_ofld_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_ofld_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first TOE rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_ofld_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_ofld_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first TOE tx queue"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nnmrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nnmrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues for netmap"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nnmtxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nnmtxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues for netmap"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_nm_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_nm_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first netmap rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_nm_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_nm_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first netmap tx queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_tmr_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_tmr_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff timer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pktc_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_pktc_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff packet counter index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_rxq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_rxq
argument_list|,
literal|"I"
argument_list|,
literal|"rx queue size"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_txq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_txq
argument_list|,
literal|"I"
argument_list|,
literal|"tx queue size"
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X.stats. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"port statistics"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
define|#
directive|define
name|SYSCTL_ADD_T4_REG64
parameter_list|(
name|pi
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|,
name|reg
parameter_list|)
define|\
value|SYSCTL_ADD_OID(ctx, children, OID_AUTO, name, \ 	    CTLTYPE_U64 | CTLFLAG_RD, sc, reg, \ 	    sysctl_handle_t4_reg64, "QU", desc)
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_error_frames"
argument_list|,
literal|"# of error frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_64"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1024_1518"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1519_max"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_drop"
argument_list|,
literal|"# of dropped tx frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_DROP_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_pause"
argument_list|,
literal|"# of pause frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_too_long"
argument_list|,
literal|"# of frames exceeding MTU"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_jabber"
argument_list|,
literal|"# of jabber frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_fcs_err"
argument_list|,
literal|"# of frames received with bad FCS"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_len_err"
argument_list|,
literal|"# of frames received with length error"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LEN_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_symbol_err"
argument_list|,
literal|"symbol errors"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_SYM_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_runt"
argument_list|,
literal|"# of short frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LESS_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_64"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1024_1518"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1519_max"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_pause"
argument_list|,
literal|"# of pause frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_REG64
define|#
directive|define
name|SYSCTL_ADD_T4_PORTSTAT
parameter_list|(
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|SYSCTL_ADD_UQUAD(ctx, children, OID_AUTO, #name, CTLFLAG_RD, \&pi->stats.name, desc)
comment|/* We get these from port_stats and they may be stale by upto 1s */
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow0
argument_list|,
literal|"# drops due to buffer-group 0 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow1
argument_list|,
literal|"# drops due to buffer-group 1 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow2
argument_list|,
literal|"# drops due to buffer-group 2 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow3
argument_list|,
literal|"# drops due to buffer-group 3 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc0
argument_list|,
literal|"# of buffer-group 0 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc1
argument_list|,
literal|"# of buffer-group 1 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc2
argument_list|,
literal|"# of buffer-group 2 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc3
argument_list|,
literal|"# of buffer-group 3 truncated packets"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_PORTSTAT
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|32
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg1
init|;
name|arg2
condition|;
name|arg2
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%d "
argument_list|,
operator|*
name|i
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_bitfield
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%b"
argument_list|,
operator|(
name|int
operator|)
name|arg2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_btphy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|int
name|op
init|=
name|arg2
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|u_int
name|v
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4btt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* XXX: magic numbers */
name|rc
operator|=
operator|-
name|t4_mdio_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|mdio_addr
argument_list|,
literal|0x1e
argument_list|,
name|op
condition|?
literal|0x20
else|:
literal|0xc820
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
name|v
operator|/=
literal|256
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|v
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_noflowq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|pi
operator|->
name|rsrv_noflowq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|(
name|val
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|pi
operator|->
name|ntxq
operator|>
literal|1
operator|)
condition|)
name|pi
operator|->
name|rsrv_noflowq
operator|=
literal|1
expr_stmt|;
else|else
name|pi
operator|->
name|rsrv_noflowq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
endif|#
directive|endif
name|uint8_t
name|v
decl_stmt|;
name|idx
operator|=
name|pi
operator|->
name|tmr_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|SGE_NTIMERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4tmr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|v
operator|=
name|V_QINTR_TIMER_IDX
argument_list|(
name|idx
argument_list|)
operator||
name|V_QINTR_CNT_EN
argument_list|(
name|pi
operator|->
name|pktc_idx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
ifdef|#
directive|ifdef
name|atomic_store_rel_8
name|atomic_store_rel_8
argument_list|(
operator|&
name|rxq
operator|->
name|iq
operator|.
name|intr_params
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|#
directive|else
name|rxq
operator|->
name|iq
operator|.
name|intr_params
operator|=
name|v
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
ifdef|#
directive|ifdef
name|atomic_store_rel_8
name|atomic_store_rel_8
argument_list|(
operator|&
name|ofld_rxq
operator|->
name|iq
operator|.
name|intr_params
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|#
directive|else
name|ofld_rxq
operator|->
name|iq
operator|.
name|intr_params
operator|=
name|v
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|pi
operator|->
name|tmr_idx
operator|=
name|idx
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|;
name|idx
operator|=
name|pi
operator|->
name|pktc_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
operator|-
literal|1
operator|||
name|idx
operator|>=
name|SGE_NCOUNTERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4pktc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
else|else
name|pi
operator|->
name|pktc_idx
operator|=
name|idx
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|pi
operator|->
name|qsize_rxq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|qsize
operator|<
literal|128
operator|||
operator|(
name|qsize
operator|&
literal|7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4rxqs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
else|else
name|pi
operator|->
name|qsize_rxq
operator|=
name|qsize
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|pi
operator|->
name|qsize_txq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* bufring size must be powerof2 */
if|if
condition|(
name|qsize
operator|<
literal|128
operator|||
operator|!
name|powerof2
argument_list|(
name|qsize
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4txqs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
else|else
name|pi
operator|->
name|qsize_txq
operator|=
name|qsize
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|reg
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_temperature
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|t
decl_stmt|;
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4temp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|param
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_DIAG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_Y
argument_list|(
name|FW_PARAM_DEV_DIAG_TMP
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* unknown is returned as 0 but we display -1 in that case */
name|t
operator|=
name|val
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
name|val
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|t
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SBUF_DRAIN
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_cctrl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|incr
index|[
name|NMTUS
index|]
index|[
name|NCCTRL_WIN
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|dec_fac
index|[]
init|=
block|{
literal|"0.5"
block|,
literal|"0.5625"
block|,
literal|"0.625"
block|,
literal|"0.6875"
block|,
literal|"0.75"
block|,
literal|"0.8125"
block|,
literal|"0.875"
block|,
literal|"0.9375"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_read_cong_tbl
argument_list|(
name|sc
argument_list|,
name|incr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|i
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%2d: %4u %4u %4u %4u %4u %4u %4u %4u\n"
argument_list|,
name|i
argument_list|,
name|incr
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|2
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|3
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|4
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|5
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|6
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|7
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%8u %4u %4u %4u %4u %4u %4u %4u %5u %s\n"
argument_list|,
name|incr
index|[
literal|8
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|9
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|10
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|11
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|12
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|13
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|14
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|15
index|]
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|a_wnd
index|[
name|i
index|]
argument_list|,
name|dec_fac
index|[
name|sc
operator|->
name|params
operator|.
name|b_wnd
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|qname
index|[
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
index|]
init|=
block|{
literal|"TP0"
block|,
literal|"TP1"
block|,
literal|"ULP"
block|,
literal|"SGE0"
block|,
literal|"SGE1"
block|,
literal|"NC-SI"
block|,
comment|/* ibq's */
literal|"ULP0"
block|,
literal|"ULP1"
block|,
literal|"ULP2"
block|,
literal|"ULP3"
block|,
literal|"SGE"
block|,
literal|"NC-SI"
block|,
comment|/* obq's */
literal|"SGE0-RX"
block|,
literal|"SGE1-RX"
comment|/* additional obq's (T5 onwards) */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_cim_ibq_obq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|qid
init|=
name|arg2
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|qtype
decl_stmt|;
name|u_int
name|cim_num_obq
init|=
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
name|CIM_NUM_OBQ
else|:
name|CIM_NUM_OBQ_T5
decl_stmt|;
name|KASSERT
argument_list|(
name|qid
operator|>=
literal|0
operator|&&
name|qid
operator|<
name|CIM_NUM_IBQ
operator|+
name|cim_num_obq
argument_list|,
operator|(
literal|"%s: bad qid %d\n"
operator|,
name|__func__
operator|,
name|qid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|<
name|CIM_NUM_IBQ
condition|)
block|{
comment|/* inbound queue */
name|qtype
operator|=
literal|"IBQ"
expr_stmt|;
name|n
operator|=
literal|4
operator|*
name|CIM_IBQ_SIZE
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_read_cim_ibq
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* outbound queue */
name|qtype
operator|=
literal|"OBQ"
expr_stmt|;
name|qid
operator|-=
name|CIM_NUM_IBQ
expr_stmt|;
name|n
operator|=
literal|4
operator|*
name|cim_num_obq
operator|*
name|CIM_OBQ_SIZE
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_read_cim_obq
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|n
operator|=
name|rc
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* rc has # of words actually read */
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s%d %s"
argument_list|,
name|qtype
argument_list|,
name|qid
argument_list|,
name|qname
index|[
name|arg2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buf
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|16
operator|,
name|p
operator|+=
literal|4
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%#06x: %08x %08x %08x %08x"
argument_list|,
name|i
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|cfg
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read
argument_list|(
name|sc
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|params
operator|.
name|cim_la_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Status   Data      PC%s"
argument_list|,
name|cfg
operator|&
name|F_UPDBGLACAPTPCONLY
condition|?
literal|""
else|:
literal|"     LS0Stat  LS0Addr             LS0Data"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|params
operator|.
name|cim_la_size
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: p will walk off the end of buf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<
operator|&
name|buf
index|[
name|sc
operator|->
name|params
operator|.
name|cim_la_size
index|]
condition|;
name|p
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|cfg
operator|&
name|F_UPDBGLACAPTPCONLY
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %08x %08x"
argument_list|,
name|p
index|[
literal|5
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %02x%06x %02x%06x"
argument_list|,
operator|(
name|p
index|[
literal|3
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|4
index|]
operator|>>
literal|8
argument_list|,
name|p
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|5
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %x%07x %x%07x"
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|0
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|1
index|]
operator|>>
literal|4
argument_list|,
name|p
index|[
literal|1
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|2
index|]
operator|>>
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %x%07x %x%07x %08x %08x "
literal|"%08x%08x%08x%08x"
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|0
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|1
index|]
operator|>>
literal|4
argument_list|,
name|p
index|[
literal|1
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|2
index|]
operator|>>
literal|4
argument_list|,
name|p
index|[
literal|2
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_ma_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|CIM_MALA_SIZE
operator|*
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_cim_read_ma_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
literal|5
operator|*
name|CIM_MALA_SIZE
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|5
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%02x%08x%08x%08x%08x"
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n\nCnt ID Tag UE       Data       RDY VLD"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|5
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%3u %2u  %x   %u %08x%08x  %u   %u"
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|10
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|7
operator|)
operator|&
literal|7
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0xf
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|2
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|p
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|3
operator|)
operator|<<
literal|30
operator|)
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|3
operator|)
operator|<<
literal|30
operator|)
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|&
literal|1
argument_list|,
name|p
index|[
literal|0
index|]
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_pif_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|CIM_PIFLA_SIZE
operator|*
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_cim_read_pif_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
literal|6
operator|*
name|CIM_PIFLA_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Cntl ID DataBE   Addr                 Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|6
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n %02x  %02x  %04x  %08x %08x%08x%08x%08x"
argument_list|,
operator|(
name|p
index|[
literal|5
index|]
operator|>>
literal|22
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|p
index|[
literal|5
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0x3f
argument_list|,
name|p
index|[
literal|5
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n\nCntl ID               Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|6
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n %02x  %02x %08x%08x%08x%08x"
argument_list|,
operator|(
name|p
index|[
literal|4
index|]
operator|>>
literal|6
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|4
index|]
operator|&
literal|0x3f
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_qcfg
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|base
index|[
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
index|]
decl_stmt|;
name|uint16_t
name|size
index|[
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
index|]
decl_stmt|;
name|uint16_t
name|thres
index|[
name|CIM_NUM_IBQ
index|]
decl_stmt|;
name|uint32_t
name|obq_wr
index|[
literal|2
operator|*
name|CIM_NUM_OBQ_T5
index|]
decl_stmt|,
modifier|*
name|wr
init|=
name|obq_wr
decl_stmt|;
name|uint32_t
name|stat
index|[
literal|4
operator|*
operator|(
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
operator|)
index|]
decl_stmt|,
modifier|*
name|p
init|=
name|stat
decl_stmt|;
name|u_int
name|cim_num_obq
decl_stmt|,
name|ibq_rdaddr
decl_stmt|,
name|obq_rdaddr
decl_stmt|,
name|nq
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|cim_num_obq
operator|=
name|CIM_NUM_OBQ
expr_stmt|;
name|ibq_rdaddr
operator|=
name|A_UP_IBQ_0_RDADDR
expr_stmt|;
name|obq_rdaddr
operator|=
name|A_UP_OBQ_0_REALADDR
expr_stmt|;
block|}
else|else
block|{
name|cim_num_obq
operator|=
name|CIM_NUM_OBQ_T5
expr_stmt|;
name|ibq_rdaddr
operator|=
name|A_UP_IBQ_0_SHADOW_RDADDR
expr_stmt|;
name|obq_rdaddr
operator|=
name|A_UP_OBQ_0_SHADOW_REALADDR
expr_stmt|;
block|}
name|nq
operator|=
name|CIM_NUM_IBQ
operator|+
name|cim_num_obq
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read
argument_list|(
name|sc
argument_list|,
name|ibq_rdaddr
argument_list|,
literal|4
operator|*
name|nq
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|rc
operator|=
operator|-
name|t4_cim_read
argument_list|(
name|sc
argument_list|,
name|obq_rdaddr
argument_list|,
literal|2
operator|*
name|cim_num_obq
argument_list|,
name|obq_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|t4_read_cimq_cfg
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|thres
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Queue  Base  Size Thres RdPtr WrPtr  SOP  EOP Avail"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_NUM_IBQ
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|4
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%7s %5x %5u %5u %6x  %4x %4u %4u %5u"
argument_list|,
name|qname
index|[
name|i
index|]
argument_list|,
name|base
index|[
name|i
index|]
argument_list|,
name|size
index|[
name|i
index|]
argument_list|,
name|thres
index|[
name|i
index|]
argument_list|,
name|G_IBQRDADDR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|G_IBQWRADDR
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|G_QUESOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEEOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEREMFLITS
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nq
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|4
operator|,
name|wr
operator|+=
literal|2
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%7s %5x %5u %12x  %4x %4u %4u %5u"
argument_list|,
name|qname
index|[
name|i
index|]
argument_list|,
name|base
index|[
name|i
index|]
argument_list|,
name|size
index|[
name|i
index|]
argument_list|,
name|G_QUERDADDR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0x3fff
argument_list|,
name|wr
index|[
literal|0
index|]
operator|-
name|base
index|[
name|i
index|]
argument_list|,
name|G_QUESOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEEOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEREMFLITS
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cpl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_cpl_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_cpl_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1  channel 2  "
literal|"channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"CPL requests:   %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|req
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"CPL responses:  %10u %10u %10u %10u"
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_ddp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_usm_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_usm_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Frames: %u\n"
argument_list|,
name|stats
operator|.
name|frames
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Octets: %ju\n"
argument_list|,
name|stats
operator|.
name|octets
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Drops:  %u"
argument_list|,
name|stats
operator|.
name|drops
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|devlog_level_strings
index|[]
init|=
block|{
index|[
name|FW_DEVLOG_LEVEL_EMERG
index|]
operator|=
literal|"EMERG"
block|,
index|[
name|FW_DEVLOG_LEVEL_CRIT
index|]
operator|=
literal|"CRIT"
block|,
index|[
name|FW_DEVLOG_LEVEL_ERR
index|]
operator|=
literal|"ERR"
block|,
index|[
name|FW_DEVLOG_LEVEL_NOTICE
index|]
operator|=
literal|"NOTICE"
block|,
index|[
name|FW_DEVLOG_LEVEL_INFO
index|]
operator|=
literal|"INFO"
block|,
index|[
name|FW_DEVLOG_LEVEL_DEBUG
index|]
operator|=
literal|"DEBUG"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|devlog_facility_strings
index|[]
init|=
block|{
index|[
name|FW_DEVLOG_FACILITY_CORE
index|]
operator|=
literal|"CORE"
block|,
index|[
name|FW_DEVLOG_FACILITY_CF
index|]
operator|=
literal|"CF"
block|,
index|[
name|FW_DEVLOG_FACILITY_SCHED
index|]
operator|=
literal|"SCHED"
block|,
index|[
name|FW_DEVLOG_FACILITY_TIMER
index|]
operator|=
literal|"TIMER"
block|,
index|[
name|FW_DEVLOG_FACILITY_RES
index|]
operator|=
literal|"RES"
block|,
index|[
name|FW_DEVLOG_FACILITY_HW
index|]
operator|=
literal|"HW"
block|,
index|[
name|FW_DEVLOG_FACILITY_FLR
index|]
operator|=
literal|"FLR"
block|,
index|[
name|FW_DEVLOG_FACILITY_DMAQ
index|]
operator|=
literal|"DMAQ"
block|,
index|[
name|FW_DEVLOG_FACILITY_PHY
index|]
operator|=
literal|"PHY"
block|,
index|[
name|FW_DEVLOG_FACILITY_MAC
index|]
operator|=
literal|"MAC"
block|,
index|[
name|FW_DEVLOG_FACILITY_PORT
index|]
operator|=
literal|"PORT"
block|,
index|[
name|FW_DEVLOG_FACILITY_VI
index|]
operator|=
literal|"VI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FILTER
index|]
operator|=
literal|"FILTER"
block|,
index|[
name|FW_DEVLOG_FACILITY_ACL
index|]
operator|=
literal|"ACL"
block|,
index|[
name|FW_DEVLOG_FACILITY_TM
index|]
operator|=
literal|"TM"
block|,
index|[
name|FW_DEVLOG_FACILITY_QFC
index|]
operator|=
literal|"QFC"
block|,
index|[
name|FW_DEVLOG_FACILITY_DCB
index|]
operator|=
literal|"DCB"
block|,
index|[
name|FW_DEVLOG_FACILITY_ETH
index|]
operator|=
literal|"ETH"
block|,
index|[
name|FW_DEVLOG_FACILITY_OFLD
index|]
operator|=
literal|"OFLD"
block|,
index|[
name|FW_DEVLOG_FACILITY_RI
index|]
operator|=
literal|"RI"
block|,
index|[
name|FW_DEVLOG_FACILITY_ISCSI
index|]
operator|=
literal|"ISCSI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FCOE
index|]
operator|=
literal|"FCOE"
block|,
index|[
name|FW_DEVLOG_FACILITY_FOISCSI
index|]
operator|=
literal|"FOISCSI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FOFCOE
index|]
operator|=
literal|"FOFCOE"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_devlog
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|devlog_params
modifier|*
name|dparams
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|devlog
decl_stmt|;
name|struct
name|fw_devlog_e
modifier|*
name|buf
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
decl_stmt|,
name|nentries
decl_stmt|,
name|first
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint64_t
name|ftstamp
init|=
name|UINT64_MAX
decl_stmt|;
if|if
condition|(
name|dparams
operator|->
name|start
operator|==
literal|0
condition|)
block|{
name|dparams
operator|->
name|memtype
operator|=
name|FW_MEMTYPE_EDC0
expr_stmt|;
name|dparams
operator|->
name|start
operator|=
literal|0x84000
expr_stmt|;
name|dparams
operator|->
name|size
operator|=
literal|32768
expr_stmt|;
block|}
name|nentries
operator|=
name|dparams
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|fw_devlog_e
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|dparams
operator|->
name|size
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|m
operator|=
name|fwmtype_to_hwmtype
argument_list|(
name|dparams
operator|->
name|memtype
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_mem_read
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|dparams
operator|->
name|start
argument_list|,
name|dparams
operator|->
name|size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|==
literal|0
condition|)
break|break;
comment|/* end */
name|e
operator|->
name|timestamp
operator|=
name|be64toh
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|e
operator|->
name|seqno
operator|=
name|be32toh
argument_list|(
name|e
operator|->
name|seqno
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|e
operator|->
name|params
index|[
name|j
index|]
operator|=
name|be32toh
argument_list|(
name|e
operator|->
name|params
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|<
name|ftstamp
condition|)
block|{
name|ftstamp
operator|=
name|e
operator|->
name|timestamp
expr_stmt|;
name|first
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|first
index|]
operator|.
name|timestamp
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* nothing in the log */
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10s  %15s  %8s  %8s  %s\n"
argument_list|,
literal|"Seq#"
argument_list|,
literal|"Tstamp"
argument_list|,
literal|"Level"
argument_list|,
literal|"Facility"
argument_list|,
literal|"Message"
argument_list|)
expr_stmt|;
name|i
operator|=
name|first
expr_stmt|;
do|do
block|{
name|e
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|==
literal|0
condition|)
break|break;
comment|/* end */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10d  %15ju  %8s  %8s  "
argument_list|,
name|e
operator|->
name|seqno
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
operator|(
name|e
operator|->
name|level
operator|<
name|nitems
argument_list|(
name|devlog_level_strings
argument_list|)
condition|?
name|devlog_level_strings
index|[
name|e
operator|->
name|level
index|]
else|:
literal|"UNKNOWN"
operator|)
argument_list|,
operator|(
name|e
operator|->
name|facility
operator|<
name|nitems
argument_list|(
name|devlog_facility_strings
argument_list|)
condition|?
name|devlog_facility_strings
index|[
name|e
operator|->
name|facility
index|]
else|:
literal|"UNKNOWN"
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
name|e
operator|->
name|fmt
argument_list|,
name|e
operator|->
name|params
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|1
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|2
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|3
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|4
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|5
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|6
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|nentries
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|first
condition|)
do|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_fcoe_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_fcoe_stats
name|stats
index|[
literal|4
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|&
name|stats
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
operator|&
name|stats
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
operator|&
name|stats
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|,
operator|&
name|stats
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                   channel 0        channel 1        "
literal|"channel 2        channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"octetsDDP:  %16ju %16ju %16ju %16ju\n"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|octetsDDP
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|octetsDDP
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|octetsDDP
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|octetsDDP
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"framesDDP:  %16u %16u %16u %16u\n"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|framesDDP
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|framesDDP
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|framesDDP
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|framesDDP
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"framesDrop: %16u %16u %16u %16u"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|framesDrop
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|framesDrop
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|framesDrop
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|framesDrop
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_sched
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|map
decl_stmt|,
name|kbps
decl_stmt|,
name|ipg
decl_stmt|,
name|mode
decl_stmt|;
name|unsigned
name|int
name|pace_tab
index|[
name|NTX_SCHED
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|map
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|)
expr_stmt|;
name|mode
operator|=
name|G_TIMERMODE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_MOD_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|t4_read_pace_tbl
argument_list|(
name|sc
argument_list|,
name|pace_tab
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Scheduler  Mode   Channel  Rate (Kbps)   "
literal|"Class IPG (0.1 ns)   Flow IPG (us)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTX_SCHED
condition|;
operator|++
name|i
operator|,
name|map
operator|>>=
literal|2
control|)
block|{
name|t4_get_tx_sched
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|kbps
argument_list|,
operator|&
name|ipg
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n    %u      %-5s     %u     "
argument_list|,
name|i
argument_list|,
operator|(
name|mode
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"flow"
else|:
literal|"class"
argument_list|,
name|map
operator|&
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbps
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%9u     "
argument_list|,
name|kbps
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" disabled     "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipg
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%13u        "
argument_list|,
name|ipg
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"     disabled        "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pace_tab
index|[
name|i
index|]
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10u"
argument_list|,
name|pace_tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"  disabled"
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_lb_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|struct
name|lb_port_stats
name|s
index|[
literal|2
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|stat_name
index|[]
init|=
block|{
literal|"OctetsOK:"
block|,
literal|"FramesOK:"
block|,
literal|"BcastFrames:"
block|,
literal|"McastFrames:"
block|,
literal|"UcastFrames:"
block|,
literal|"ErrorFrames:"
block|,
literal|"Frames64:"
block|,
literal|"Frames65To127:"
block|,
literal|"Frames128To255:"
block|,
literal|"Frames256To511:"
block|,
literal|"Frames512To1023:"
block|,
literal|"Frames1024To1518:"
block|,
literal|"Frames1519ToMax:"
block|,
literal|"FramesDropped:"
block|,
literal|"BG0FramesDropped:"
block|,
literal|"BG1FramesDropped:"
block|,
literal|"BG2FramesDropped:"
block|,
literal|"BG3FramesDropped:"
block|,
literal|"BG0FramesTrunc:"
block|,
literal|"BG1FramesTrunc:"
block|,
literal|"BG2FramesTrunc:"
block|,
literal|"BG3FramesTrunc:"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|t4_get_lb_stats
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t4_get_lb_stats
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p0
operator|=
operator|&
name|s
index|[
literal|0
index|]
operator|.
name|octets
expr_stmt|;
name|p1
operator|=
operator|&
name|s
index|[
literal|1
index|]
operator|.
name|octets
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s                       Loopback %u"
literal|"           Loopback %u"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nitems
argument_list|(
name|stat_name
argument_list|)
condition|;
name|j
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-17s %20ju %20ju"
argument_list|,
name|stat_name
index|[
name|j
index|]
argument_list|,
operator|*
name|p0
operator|++
argument_list|,
operator|*
name|p1
operator|++
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_linkdnrc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|linkdnreasons
index|[]
init|=
block|{
literal|"non-specific"
block|,
literal|"remote fault"
block|,
literal|"autoneg failed"
block|,
literal|"reserved3"
block|,
literal|"PHY overheated"
block|,
literal|"unknown"
block|,
literal|"rx los"
block|,
literal|"reserved7"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|pi
operator|->
name|linkdnrc
operator|<
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"n/a"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|linkdnrc
operator|<
name|nitems
argument_list|(
name|linkdnreasons
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|linkdnreasons
index|[
name|pi
operator|->
name|linkdnrc
index|]
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%d"
argument_list|,
name|pi
operator|->
name|linkdnrc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|mem_desc
block|{
name|unsigned
name|int
name|base
decl_stmt|;
name|unsigned
name|int
name|limit
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|mem_desc_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|mem_desc
operator|*
operator|)
name|a
operator|)
operator|->
name|base
operator|-
operator|(
operator|(
specifier|const
expr|struct
name|mem_desc
operator|*
operator|)
name|b
operator|)
operator|->
name|base
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_region_show
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|size
operator|=
name|to
operator|-
name|from
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
comment|/* XXX: need humanize_number(3) in libkern for a more readable 'size' */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%-15s %#x-%#x [%u]\n"
argument_list|,
name|name
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_meminfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint32_t
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|used
decl_stmt|,
name|alloc
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|memory
index|[]
init|=
block|{
literal|"EDC0:"
block|,
literal|"EDC1:"
block|,
literal|"MC:"
block|,
literal|"MC0:"
block|,
literal|"MC1:"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|region
index|[]
init|=
block|{
literal|"DBQ contexts:"
block|,
literal|"IMSG contexts:"
block|,
literal|"FLM cache:"
block|,
literal|"TCBs:"
block|,
literal|"Pstructs:"
block|,
literal|"Timers:"
block|,
literal|"Rx FL:"
block|,
literal|"Tx FL:"
block|,
literal|"Pstruct FL:"
block|,
literal|"Tx payload:"
block|,
literal|"Rx payload:"
block|,
literal|"LE hash:"
block|,
literal|"iSCSI region:"
block|,
literal|"TDDP region:"
block|,
literal|"TPT region:"
block|,
literal|"STAG region:"
block|,
literal|"RQ region:"
block|,
literal|"RQUDP region:"
block|,
literal|"PBL region:"
block|,
literal|"TXPBL region:"
block|,
literal|"DBVFIFO region:"
block|,
literal|"ULPRX state:"
block|,
literal|"ULPTX state:"
block|,
literal|"On-chip queues:"
block|}
decl_stmt|;
name|struct
name|mem_desc
name|avail
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|mem_desc
name|mem
index|[
name|nitems
argument_list|(
name|region
argument_list|)
operator|+
literal|3
index|]
decl_stmt|;
comment|/* up to 3 holes */
name|struct
name|mem_desc
modifier|*
name|md
init|=
name|mem
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mem
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|mem
index|[
name|i
index|]
operator|.
name|limit
operator|=
literal|0
expr_stmt|;
name|mem
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|i
expr_stmt|;
block|}
comment|/* Find and sort the populated memory ranges */
name|i
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|&
name|F_EDRAM0_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EDRAM0_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EDRAM1_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EDRAM1_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EXT_MEM_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EXT_MEM_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
comment|/* Call it MC for T4 */
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|lo
operator|&
name|F_EXT_MEM1_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY1_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EXT_MEM1_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EXT_MEM1_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
comment|/* no memory available */
return|return
literal|0
return|;
name|qsort
argument_list|(
name|avail
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_desc
argument_list|)
argument_list|,
name|mem_desc_cmp
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_DBQ_CTXT_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_IMSG_CTXT_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_FLM_CACHE_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TCB_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TIMER_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_RX_FLST_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_TX_FLST_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_PS_FLST_BASE
argument_list|)
expr_stmt|;
comment|/* the next few have explicit upper bounds */
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|-
literal|1
operator|+
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|)
operator|*
name|G_PMTXMAXPAGE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|-
literal|1
operator|+
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|)
operator|*
name|G_PMRXMAXPAGE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_CONFIG
argument_list|)
operator|&
name|F_HASHEN
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_HASH_TID_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
operator|(
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|-
name|hi
operator|)
operator|*
literal|16
operator|+
name|md
operator|->
name|base
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|idx
operator|=
name|nitems
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|/* hide it */
block|}
name|md
operator|++
expr_stmt|;
define|#
directive|define
name|ulp_region
parameter_list|(
name|reg
parameter_list|)
define|\
value|md->base = t4_read_reg(sc, A_ULP_ ## reg ## _LLIMIT);\ 	(md++)->limit = t4_read_reg(sc, A_ULP_ ## reg ## _ULIMIT)
name|ulp_region
argument_list|(
name|RX_ISCSI
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_TDDP
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|TX_TPT
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_STAG
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_RQ
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_RQUDP
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_PBL
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|TX_PBL
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ulp_region
name|md
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|idx
operator|=
name|nitems
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL2
argument_list|)
operator|&
name|F_VFIFO_ENABLE
condition|)
block|{
name|md
operator|->
name|base
operator|=
name|G_BASEADDR
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_DBVFIFO_BADDR
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
operator|(
name|G_DBVFIFO_SIZE
argument_list|(
operator|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_DBVFIFO_SIZE
argument_list|)
operator|)
argument_list|)
operator|<<
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_CTX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|-
literal|1
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_TX_ERR_TABLE_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|-
literal|1
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
condition|)
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
operator|-
literal|1
expr_stmt|;
else|else
name|md
operator|->
name|idx
operator|=
name|nitems
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|/* hide it */
name|md
operator|++
expr_stmt|;
comment|/* add any address-space holes, there can be up to 3 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|-
literal|1
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|avail
index|[
name|n
index|]
operator|.
name|limit
operator|<
name|avail
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|base
condition|)
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|avail
index|[
name|n
index|]
operator|.
name|limit
expr_stmt|;
if|if
condition|(
name|avail
index|[
name|n
index|]
operator|.
name|limit
condition|)
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|avail
index|[
name|n
index|]
operator|.
name|limit
expr_stmt|;
name|n
operator|=
name|md
operator|-
name|mem
expr_stmt|;
name|qsort
argument_list|(
name|mem
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_desc
argument_list|)
argument_list|,
name|mem_desc_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|lo
operator|=
literal|0
init|;
name|lo
operator|<
name|i
condition|;
name|lo
operator|++
control|)
name|mem_region_show
argument_list|(
name|sb
argument_list|,
name|memory
index|[
name|avail
index|[
name|lo
index|]
operator|.
name|idx
index|]
argument_list|,
name|avail
index|[
name|lo
index|]
operator|.
name|base
argument_list|,
name|avail
index|[
name|lo
index|]
operator|.
name|limit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mem
index|[
name|i
index|]
operator|.
name|idx
operator|>=
name|nitems
argument_list|(
name|region
argument_list|)
condition|)
continue|continue;
comment|/* skip holes */
if|if
condition|(
operator|!
name|mem
index|[
name|i
index|]
operator|.
name|limit
condition|)
name|mem
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|i
operator|<
name|n
operator|-
literal|1
condition|?
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|base
operator|-
literal|1
else|:
operator|~
literal|0
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
name|region
index|[
name|mem
index|[
name|i
index|]
operator|.
name|idx
index|]
argument_list|,
name|mem
index|[
name|i
index|]
operator|.
name|base
argument_list|,
name|mem
index|[
name|i
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_SDRAM_BASE_ADDR
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_SDRAM_ADDR_SIZE
argument_list|)
operator|+
name|lo
operator|-
literal|1
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
literal|"uP RAM:"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_EXTMEM2_BASE_ADDR
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_EXTMEM2_ADDR_SIZE
argument_list|)
operator|+
name|lo
operator|-
literal|1
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
literal|"uP Extmem2:"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%u Rx pages of size %uKiB for %u channels\n"
argument_list|,
name|G_PMRXMAXPAGE
argument_list|(
name|lo
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|)
operator|>>
literal|10
argument_list|,
operator|(
name|lo
operator|&
name|F_PMRXNUMCHN
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u Tx pages of size %u%ciB for %u channels\n"
argument_list|,
name|G_PMTXMAXPAGE
argument_list|(
name|lo
argument_list|)
argument_list|,
name|hi
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|?
operator|(
name|hi
operator|>>
literal|20
operator|)
else|:
operator|(
name|hi
operator|>>
literal|10
operator|)
argument_list|,
name|hi
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|?
literal|'M'
else|:
literal|'K'
argument_list|,
literal|1
operator|<<
name|G_PMTXNUMCHN
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u p-structs\n"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_MAX_PSTRUCT
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_PG_RSV0
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|used
operator|=
name|G_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|used
operator|=
name|G_T5_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_T5_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nPort %d using %u pages out of %u allocated"
argument_list|,
name|i
argument_list|,
name|used
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_PG_RSV4
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|used
operator|=
name|G_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|used
operator|=
name|G_T5_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_T5_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nLoopback %d using %u pages out of %u allocated"
argument_list|,
name|i
argument_list|,
name|used
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|tcamxy2valmask
parameter_list|(
name|uint64_t
name|x
parameter_list|,
name|uint64_t
name|y
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint64_t
modifier|*
name|mask
parameter_list|)
block|{
operator|*
name|mask
operator|=
name|x
operator||
name|y
expr_stmt|;
name|y
operator|=
name|htobe64
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
operator|+
literal|2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_mps_tcam
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Idx  Ethernet address     Mask     Vld Ports PF"
literal|"  VF              Replication             P0 P1 P2 P3  ML"
argument_list|)
expr_stmt|;
name|n
operator|=
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
name|NUM_MPS_CLS_SRAM_L_INSTANCES
else|:
name|NUM_MPS_T5_CLS_SRAM_L_INSTANCES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|tcamx
decl_stmt|,
name|tcamy
decl_stmt|,
name|mask
decl_stmt|;
name|uint32_t
name|cls_lo
decl_stmt|,
name|cls_hi
decl_stmt|;
name|uint8_t
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|tcamy
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_TCAM_Y_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tcamx
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_TCAM_X_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|cls_lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_SRAM_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|cls_hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_SRAM_H
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcamx
operator|&
name|tcamy
condition|)
continue|continue;
name|tcamxy2valmask
argument_list|(
name|tcamx
argument_list|,
name|tcamy
argument_list|,
name|addr
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%3u %02x:%02x:%02x:%02x:%02x:%02x %012jx"
literal|"  %c   %#x%4u%4d"
argument_list|,
name|i
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|,
name|addr
index|[
literal|4
index|]
argument_list|,
name|addr
index|[
literal|5
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mask
argument_list|,
operator|(
name|cls_lo
operator|&
name|F_SRAM_VLD
operator|)
condition|?
literal|'Y'
else|:
literal|'N'
argument_list|,
name|G_PORTMAP
argument_list|(
name|cls_hi
argument_list|)
argument_list|,
name|G_PF
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
operator|(
name|cls_lo
operator|&
name|F_VF_VALID
operator|)
condition|?
name|G_VF
argument_list|(
name|cls_lo
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cls_lo
operator|&
name|F_REPLICATE
condition|)
block|{
name|struct
name|fw_ldst_cmd
name|ldst_cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ldst_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|op_to_addrspace
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_MPS
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|cycles_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|fid_ctl
operator|=
name|htobe16
argument_list|(
name|V_FW_LDST_CMD_FID
argument_list|(
name|FW_LDST_MPS_RPLC
argument_list|)
operator||
name|V_FW_LDST_CMD_CTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4mps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
break|break;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|ldst_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|,
operator|&
name|ldst_cmd
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" ------------ error %3u ------------"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %08x %08x %08x %08x"
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc127_96
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc95_64
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc63_32
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc31_0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%36s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%4u%3u%3u%3u %#3x"
argument_list|,
name|G_SRAM_PRIO0
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_SRAM_PRIO1
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_SRAM_PRIO2
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_SRAM_PRIO3
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
operator|(
name|cls_lo
operator|>>
name|S_MULTILISTEN0
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
operator|(
name|void
operator|)
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_path_mtus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|uint16_t
name|mtus
index|[
name|NMTUS
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_read_mtu_tbl
argument_list|(
name|sc
argument_list|,
name|mtus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u"
argument_list|,
name|mtus
index|[
literal|0
index|]
argument_list|,
name|mtus
index|[
literal|1
index|]
argument_list|,
name|mtus
index|[
literal|2
index|]
argument_list|,
name|mtus
index|[
literal|3
index|]
argument_list|,
name|mtus
index|[
literal|4
index|]
argument_list|,
name|mtus
index|[
literal|5
index|]
argument_list|,
name|mtus
index|[
literal|6
index|]
argument_list|,
name|mtus
index|[
literal|7
index|]
argument_list|,
name|mtus
index|[
literal|8
index|]
argument_list|,
name|mtus
index|[
literal|9
index|]
argument_list|,
name|mtus
index|[
literal|10
index|]
argument_list|,
name|mtus
index|[
literal|11
index|]
argument_list|,
name|mtus
index|[
literal|12
index|]
argument_list|,
name|mtus
index|[
literal|13
index|]
argument_list|,
name|mtus
index|[
literal|14
index|]
argument_list|,
name|mtus
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_pm_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|cnt
index|[
name|PM_NSTATS
index|]
decl_stmt|;
name|uint64_t
name|cyc
index|[
name|PM_NSTATS
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|rx_stats
index|[]
init|=
block|{
literal|"Read:"
block|,
literal|"Write bypass:"
block|,
literal|"Write mem:"
block|,
literal|"Flush:"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|tx_stats
index|[]
init|=
block|{
literal|"Read:"
block|,
literal|"Write bypass:"
block|,
literal|"Write mem:"
block|,
literal|"Bypass + mem:"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_pmtx_get_stats
argument_list|(
name|sc
argument_list|,
name|cnt
argument_list|,
name|cyc
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                Tx pcmds             Tx bytes"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|tx_stats
argument_list|)
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|tx_stats
index|[
name|i
index|]
argument_list|,
name|cnt
index|[
name|i
index|]
argument_list|,
name|cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t4_pmrx_get_stats
argument_list|(
name|sc
argument_list|,
name|cnt
argument_list|,
name|cyc
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n                Rx pcmds             Rx bytes"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rx_stats
argument_list|)
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|rx_stats
index|[
name|i
index|]
argument_list|,
name|cnt
index|[
name|i
index|]
argument_list|,
name|cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_rdma_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_rdma_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_rdma_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NoRQEModDefferals: %u\n"
argument_list|,
name|stats
operator|.
name|rqe_dfr_mod
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NoRQEPktDefferals: %u"
argument_list|,
name|stats
operator|.
name|rqe_dfr_pkt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tcp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_tcp_stats
name|v4
decl_stmt|,
name|v6
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_tcp_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|v4
argument_list|,
operator|&
name|v6
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                                IP                 IPv6\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"OutRsts:      %20u %20u\n"
argument_list|,
name|v4
operator|.
name|tcpOutRsts
argument_list|,
name|v6
operator|.
name|tcpOutRsts
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"InSegs:       %20ju %20ju\n"
argument_list|,
name|v4
operator|.
name|tcpInSegs
argument_list|,
name|v6
operator|.
name|tcpInSegs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"OutSegs:      %20ju %20ju\n"
argument_list|,
name|v4
operator|.
name|tcpOutSegs
argument_list|,
name|v6
operator|.
name|tcpOutSegs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"RetransSegs:  %20ju %20ju"
argument_list|,
name|v4
operator|.
name|tcpRetransSegs
argument_list|,
name|v6
operator|.
name|tcpRetransSegs
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tids
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|natids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ATID range: 0-%u, in use: %u\n"
argument_list|,
name|t
operator|->
name|natids
operator|-
literal|1
argument_list|,
name|t
operator|->
name|atids_in_use
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|ntids
condition|)
block|{
if|if
condition|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_CONFIG
argument_list|)
operator|&
name|F_HASHEN
condition|)
block|{
name|uint32_t
name|b
init|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_SERVER_INDEX
argument_list|)
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: 0-%u, %u-%u"
argument_list|,
name|b
operator|-
literal|1
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: %u-%u"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: 0-%u"
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|", in use: %u\n"
argument_list|,
name|atomic_load_acq_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|nstids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"STID range: %u-%u, in use: %u\n"
argument_list|,
name|t
operator|->
name|stid_base
argument_list|,
name|t
operator|->
name|stid_base
operator|+
name|t
operator|->
name|nstids
operator|-
literal|1
argument_list|,
name|t
operator|->
name|stids_in_use
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|nftids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"FTID range: %u-%u\n"
argument_list|,
name|t
operator|->
name|ftid_base
argument_list|,
name|t
operator|->
name|ftid_base
operator|+
name|t
operator|->
name|nftids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|netids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ETID range: %u-%u\n"
argument_list|,
name|t
operator|->
name|etid_base
argument_list|,
name|t
operator|->
name|etid_base
operator|+
name|t
operator|->
name|netids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"HW TID usage: %u IP users, %u IPv6 users"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_ACT_CNT_IPV4
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_ACT_CNT_IPV6
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tp_err_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_err_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_err_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1  channel 2  "
literal|"channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"macInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"hdrInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcpInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcp6InErrs:     %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlCongDrops:   %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlTxDrops:     %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldVlanDrops:  %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldChanDrops:  %10u %10u %10u %10u\n\n"
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldNoNeigh:    %u\nofldCongDefer:  %u"
argument_list|,
name|stats
operator|.
name|ofldNoNeigh
argument_list|,
name|stats
operator|.
name|ofldCongDefer
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|field_desc
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|start
decl_stmt|;
name|u_int
name|width
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|field_desc_show
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
name|v
parameter_list|,
specifier|const
name|struct
name|field_desc
modifier|*
name|f
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|line_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|name
condition|)
block|{
name|uint64_t
name|mask
init|=
operator|(
literal|1ULL
operator|<<
name|f
operator|->
name|width
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s: %ju"
argument_list|,
name|f
operator|->
name|name
argument_list|,
operator|(
operator|(
name|uintmax_t
operator|)
name|v
operator|>>
name|f
operator|->
name|start
operator|)
operator|&
name|mask
argument_list|)
decl_stmt|;
if|if
condition|(
name|line_size
operator|+
name|len
operator|>=
literal|79
condition|)
block|{
name|line_size
operator|=
literal|8
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n        "
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|line_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|field_desc
name|tp_la0
index|[]
init|=
block|{
block|{
literal|"RcfOpCodeOut"
block|,
literal|60
block|,
literal|4
block|}
block|,
block|{
literal|"State"
block|,
literal|56
block|,
literal|4
block|}
block|,
block|{
literal|"WcfState"
block|,
literal|52
block|,
literal|4
block|}
block|,
block|{
literal|"RcfOpcSrcOut"
block|,
literal|50
block|,
literal|2
block|}
block|,
block|{
literal|"CRxError"
block|,
literal|49
block|,
literal|1
block|}
block|,
block|{
literal|"ERxError"
block|,
literal|48
block|,
literal|1
block|}
block|,
block|{
literal|"SanityFailed"
block|,
literal|47
block|,
literal|1
block|}
block|,
block|{
literal|"SpuriousMsg"
block|,
literal|46
block|,
literal|1
block|}
block|,
block|{
literal|"FlushInputMsg"
block|,
literal|45
block|,
literal|1
block|}
block|,
block|{
literal|"FlushInputCpl"
block|,
literal|44
block|,
literal|1
block|}
block|,
block|{
literal|"RssUpBit"
block|,
literal|43
block|,
literal|1
block|}
block|,
block|{
literal|"RssFilterHit"
block|,
literal|42
block|,
literal|1
block|}
block|,
block|{
literal|"Tid"
block|,
literal|32
block|,
literal|10
block|}
block|,
block|{
literal|"InitTcb"
block|,
literal|31
block|,
literal|1
block|}
block|,
block|{
literal|"LineNumber"
block|,
literal|24
block|,
literal|7
block|}
block|,
block|{
literal|"Emsg"
block|,
literal|23
block|,
literal|1
block|}
block|,
block|{
literal|"EdataOut"
block|,
literal|22
block|,
literal|1
block|}
block|,
block|{
literal|"Cmsg"
block|,
literal|21
block|,
literal|1
block|}
block|,
block|{
literal|"CdataOut"
block|,
literal|20
block|,
literal|1
block|}
block|,
block|{
literal|"EreadPdu"
block|,
literal|19
block|,
literal|1
block|}
block|,
block|{
literal|"CreadPdu"
block|,
literal|18
block|,
literal|1
block|}
block|,
block|{
literal|"TunnelPkt"
block|,
literal|17
block|,
literal|1
block|}
block|,
block|{
literal|"RcfPeerFin"
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
literal|"RcfReasonOut"
block|,
literal|12
block|,
literal|4
block|}
block|,
block|{
literal|"TxCchannel"
block|,
literal|10
block|,
literal|2
block|}
block|,
block|{
literal|"RcfTxChannel"
block|,
literal|8
block|,
literal|2
block|}
block|,
block|{
literal|"RxEchannel"
block|,
literal|6
block|,
literal|2
block|}
block|,
block|{
literal|"RcfRxChannel"
block|,
literal|5
block|,
literal|1
block|}
block|,
block|{
literal|"RcfDataOutSrdy"
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
literal|"RxDvld"
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|"RxOoDvld"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"RxCongestion"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"TxCongestion"
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|field_desc
name|tp_la1
index|[]
init|=
block|{
block|{
literal|"CplCmdIn"
block|,
literal|56
block|,
literal|8
block|}
block|,
block|{
literal|"CplCmdOut"
block|,
literal|48
block|,
literal|8
block|}
block|,
block|{
literal|"ESynOut"
block|,
literal|47
block|,
literal|1
block|}
block|,
block|{
literal|"EAckOut"
block|,
literal|46
block|,
literal|1
block|}
block|,
block|{
literal|"EFinOut"
block|,
literal|45
block|,
literal|1
block|}
block|,
block|{
literal|"ERstOut"
block|,
literal|44
block|,
literal|1
block|}
block|,
block|{
literal|"SynIn"
block|,
literal|43
block|,
literal|1
block|}
block|,
block|{
literal|"AckIn"
block|,
literal|42
block|,
literal|1
block|}
block|,
block|{
literal|"FinIn"
block|,
literal|41
block|,
literal|1
block|}
block|,
block|{
literal|"RstIn"
block|,
literal|40
block|,
literal|1
block|}
block|,
block|{
literal|"DataIn"
block|,
literal|39
block|,
literal|1
block|}
block|,
block|{
literal|"DataInVld"
block|,
literal|38
block|,
literal|1
block|}
block|,
block|{
literal|"PadIn"
block|,
literal|37
block|,
literal|1
block|}
block|,
block|{
literal|"RxBufEmpty"
block|,
literal|36
block|,
literal|1
block|}
block|,
block|{
literal|"RxDdp"
block|,
literal|35
block|,
literal|1
block|}
block|,
block|{
literal|"RxFbCongestion"
block|,
literal|34
block|,
literal|1
block|}
block|,
block|{
literal|"TxFbCongestion"
block|,
literal|33
block|,
literal|1
block|}
block|,
block|{
literal|"TxPktSumSrdy"
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"RcfUlpType"
block|,
literal|28
block|,
literal|4
block|}
block|,
block|{
literal|"Eread"
block|,
literal|27
block|,
literal|1
block|}
block|,
block|{
literal|"Ebypass"
block|,
literal|26
block|,
literal|1
block|}
block|,
block|{
literal|"Esave"
block|,
literal|25
block|,
literal|1
block|}
block|,
block|{
literal|"Static0"
block|,
literal|24
block|,
literal|1
block|}
block|,
block|{
literal|"Cread"
block|,
literal|23
block|,
literal|1
block|}
block|,
block|{
literal|"Cbypass"
block|,
literal|22
block|,
literal|1
block|}
block|,
block|{
literal|"Csave"
block|,
literal|21
block|,
literal|1
block|}
block|,
block|{
literal|"CPktOut"
block|,
literal|20
block|,
literal|1
block|}
block|,
block|{
literal|"RxPagePoolFull"
block|,
literal|18
block|,
literal|2
block|}
block|,
block|{
literal|"RxLpbkPkt"
block|,
literal|17
block|,
literal|1
block|}
block|,
block|{
literal|"TxLpbkPkt"
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
literal|"RxVfValid"
block|,
literal|15
block|,
literal|1
block|}
block|,
block|{
literal|"SynLearned"
block|,
literal|14
block|,
literal|1
block|}
block|,
block|{
literal|"SetDelEntry"
block|,
literal|13
block|,
literal|1
block|}
block|,
block|{
literal|"SetInvEntry"
block|,
literal|12
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdDvld"
block|,
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdSave"
block|,
literal|10
block|,
literal|1
block|}
block|,
block|{
literal|"RxPstructsFull"
block|,
literal|8
block|,
literal|2
block|}
block|,
block|{
literal|"EpcmdDvld"
block|,
literal|7
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdFlush"
block|,
literal|6
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPrefix"
block|,
literal|5
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPostfix"
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp4Pkt"
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp6Pkt"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"ERssTcpUdpPkt"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"ERssFceFipPkt"
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|field_desc
name|tp_la2
index|[]
init|=
block|{
block|{
literal|"CplCmdIn"
block|,
literal|56
block|,
literal|8
block|}
block|,
block|{
literal|"MpsVfVld"
block|,
literal|55
block|,
literal|1
block|}
block|,
block|{
literal|"MpsPf"
block|,
literal|52
block|,
literal|3
block|}
block|,
block|{
literal|"MpsVf"
block|,
literal|44
block|,
literal|8
block|}
block|,
block|{
literal|"SynIn"
block|,
literal|43
block|,
literal|1
block|}
block|,
block|{
literal|"AckIn"
block|,
literal|42
block|,
literal|1
block|}
block|,
block|{
literal|"FinIn"
block|,
literal|41
block|,
literal|1
block|}
block|,
block|{
literal|"RstIn"
block|,
literal|40
block|,
literal|1
block|}
block|,
block|{
literal|"DataIn"
block|,
literal|39
block|,
literal|1
block|}
block|,
block|{
literal|"DataInVld"
block|,
literal|38
block|,
literal|1
block|}
block|,
block|{
literal|"PadIn"
block|,
literal|37
block|,
literal|1
block|}
block|,
block|{
literal|"RxBufEmpty"
block|,
literal|36
block|,
literal|1
block|}
block|,
block|{
literal|"RxDdp"
block|,
literal|35
block|,
literal|1
block|}
block|,
block|{
literal|"RxFbCongestion"
block|,
literal|34
block|,
literal|1
block|}
block|,
block|{
literal|"TxFbCongestion"
block|,
literal|33
block|,
literal|1
block|}
block|,
block|{
literal|"TxPktSumSrdy"
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"RcfUlpType"
block|,
literal|28
block|,
literal|4
block|}
block|,
block|{
literal|"Eread"
block|,
literal|27
block|,
literal|1
block|}
block|,
block|{
literal|"Ebypass"
block|,
literal|26
block|,
literal|1
block|}
block|,
block|{
literal|"Esave"
block|,
literal|25
block|,
literal|1
block|}
block|,
block|{
literal|"Static0"
block|,
literal|24
block|,
literal|1
block|}
block|,
block|{
literal|"Cread"
block|,
literal|23
block|,
literal|1
block|}
block|,
block|{
literal|"Cbypass"
block|,
literal|22
block|,
literal|1
block|}
block|,
block|{
literal|"Csave"
block|,
literal|21
block|,
literal|1
block|}
block|,
block|{
literal|"CPktOut"
block|,
literal|20
block|,
literal|1
block|}
block|,
block|{
literal|"RxPagePoolFull"
block|,
literal|18
block|,
literal|2
block|}
block|,
block|{
literal|"RxLpbkPkt"
block|,
literal|17
block|,
literal|1
block|}
block|,
block|{
literal|"TxLpbkPkt"
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
literal|"RxVfValid"
block|,
literal|15
block|,
literal|1
block|}
block|,
block|{
literal|"SynLearned"
block|,
literal|14
block|,
literal|1
block|}
block|,
block|{
literal|"SetDelEntry"
block|,
literal|13
block|,
literal|1
block|}
block|,
block|{
literal|"SetInvEntry"
block|,
literal|12
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdDvld"
block|,
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdSave"
block|,
literal|10
block|,
literal|1
block|}
block|,
block|{
literal|"RxPstructsFull"
block|,
literal|8
block|,
literal|2
block|}
block|,
block|{
literal|"EpcmdDvld"
block|,
literal|7
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdFlush"
block|,
literal|6
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPrefix"
block|,
literal|5
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPostfix"
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp4Pkt"
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp6Pkt"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"ERssTcpUdpPkt"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"ERssFceFipPkt"
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tp_la_show
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
modifier|*
name|p
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|field_desc_show
argument_list|(
name|sb
argument_list|,
operator|*
name|p
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tp_la_show2
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
modifier|*
name|p
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
operator|(
name|TPLA_SIZE
operator|/
literal|2
operator|-
literal|1
operator|)
operator|||
name|p
index|[
literal|1
index|]
operator|!=
operator|~
literal|0ULL
condition|)
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tp_la_show3
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
modifier|*
name|p
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
operator|(
name|TPLA_SIZE
operator|/
literal|2
operator|-
literal|1
operator|)
operator|||
name|p
index|[
literal|1
index|]
operator|!=
operator|~
literal|0ULL
condition|)
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|)
condition|?
name|tp_la2
else|:
name|tp_la1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tp_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint64_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|inc
decl_stmt|;
name|void
function_decl|(
modifier|*
name|show_func
function_decl|)
parameter_list|(
name|struct
name|sbuf
modifier|*
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|TPLA_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_tp_read_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
switch|switch
condition|(
name|G_DBGLAMODE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|inc
operator|=
literal|2
expr_stmt|;
name|show_func
operator|=
name|tp_la_show2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|inc
operator|=
literal|2
expr_stmt|;
name|show_func
operator|=
name|tp_la_show3
expr_stmt|;
break|break;
default|default:
name|inc
operator|=
literal|1
expr_stmt|;
name|show_func
operator|=
name|tp_la_show
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TPLA_SIZE
operator|/
name|inc
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
name|inc
control|)
call|(
modifier|*
name|show_func
call|)
argument_list|(
name|sb
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tx_rate
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u64
name|nrate
index|[
name|NCHAN
index|]
decl_stmt|,
name|orate
index|[
name|NCHAN
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_chan_txrate
argument_list|(
name|sc
argument_list|,
name|nrate
argument_list|,
name|orate
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"              channel 0   channel 1   channel 2   "
literal|"channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NIC B/s:     %10ju  %10ju  %10ju  %10ju\n"
argument_list|,
name|nrate
index|[
literal|0
index|]
argument_list|,
name|nrate
index|[
literal|1
index|]
argument_list|,
name|nrate
index|[
literal|2
index|]
argument_list|,
name|nrate
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Offload B/s: %10ju  %10ju  %10ju  %10ju"
argument_list|,
name|orate
index|[
literal|0
index|]
argument_list|,
name|orate
index|[
literal|1
index|]
argument_list|,
name|orate
index|[
literal|2
index|]
argument_list|,
name|orate
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_ulprx_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|ULPRX_LA_SIZE
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_ulprx_read_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"      Pcmd        Type   Message"
literal|"                Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ULPRX_LA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|8
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%08x%08x  %4x  %08x  %08x%08x%08x%08x"
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_wcwr_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|v
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_STATSOURCE_T5
argument_list|(
name|v
argument_list|)
operator|==
literal|7
condition|)
block|{
if|if
condition|(
name|G_STATMODE
argument_list|(
name|v
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"total %d, incomplete %d"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_TOTAL
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_MATCH
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|G_STATMODE
argument_list|(
name|v
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"total %d, data overflow %d"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_TOTAL
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_MATCH
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|txq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|br
expr_stmt|;
name|m
operator|=
name|txq
operator|->
name|m
condition|?
name|txq
operator|->
name|m
else|:
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_tx_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|EQ_TRYLOCK
argument_list|(
name|eq
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|reschedule
goto|;
if|if
condition|(
name|eq
operator|->
name|flags
operator|&
name|EQ_STALLED
operator|&&
operator|!
name|can_resume_tx
argument_list|(
name|eq
argument_list|)
condition|)
block|{
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|reschedule
label|:
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
operator|(
name|eq
operator|->
name|flags
operator|&&
name|EQ_DOOMED
operator|)
argument_list|)
condition|)
name|callout_schedule
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|EQ_LOCK_ASSERT_OWNED
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_DOOMED
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
operator|)
operator|==
name|EQ_ETH
condition|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|arg
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|txq
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sge_wrq
modifier|*
name|wrq
init|=
name|arg
decl_stmt|;
name|sc
operator|=
name|wrq
operator|->
name|adapter
expr_stmt|;
block|}
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
index|[
name|eq
operator|->
name|tx_chan
index|]
argument_list|,
operator|&
name|eq
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_tx_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
name|arg
decl_stmt|;
name|EQ_LOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
operator|)
operator|==
name|EQ_ETH
condition|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|arg
decl_stmt|;
name|txq_start
argument_list|(
name|txq
operator|->
name|ifp
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sge_wrq
modifier|*
name|wrq
init|=
name|arg
decl_stmt|;
name|t4_wrq_tx_locked
argument_list|(
name|wrq
operator|->
name|adapter
argument_list|,
name|wrq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fconf_to_mode
parameter_list|(
name|uint32_t
name|fconf
parameter_list|)
block|{
name|uint32_t
name|mode
decl_stmt|;
name|mode
operator|=
name|T4_FILTER_IPv4
operator||
name|T4_FILTER_IPv6
operator||
name|T4_FILTER_IP_SADDR
operator||
name|T4_FILTER_IP_DADDR
operator||
name|T4_FILTER_IP_SPORT
operator||
name|T4_FILTER_IP_DPORT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_FRAGMENTATION
condition|)
name|mode
operator||=
name|T4_FILTER_IP_FRAGMENT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_MPSHITTYPE
condition|)
name|mode
operator||=
name|T4_FILTER_MPS_HIT_TYPE
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_MACMATCH
condition|)
name|mode
operator||=
name|T4_FILTER_MAC_IDX
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_ETHERTYPE
condition|)
name|mode
operator||=
name|T4_FILTER_ETH_TYPE
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_PROTOCOL
condition|)
name|mode
operator||=
name|T4_FILTER_IP_PROTO
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_TOS
condition|)
name|mode
operator||=
name|T4_FILTER_IP_TOS
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_VLAN
condition|)
name|mode
operator||=
name|T4_FILTER_VLAN
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_VNIC_ID
condition|)
name|mode
operator||=
name|T4_FILTER_VNIC
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_PORT
condition|)
name|mode
operator||=
name|T4_FILTER_PORT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_FCOE
condition|)
name|mode
operator||=
name|T4_FILTER_FCoE
expr_stmt|;
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|mode_to_fconf
parameter_list|(
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|fconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_FRAGMENT
condition|)
name|fconf
operator||=
name|F_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MPS_HIT_TYPE
condition|)
name|fconf
operator||=
name|F_MPSHITTYPE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MAC_IDX
condition|)
name|fconf
operator||=
name|F_MACMATCH
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_ETH_TYPE
condition|)
name|fconf
operator||=
name|F_ETHERTYPE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_PROTO
condition|)
name|fconf
operator||=
name|F_PROTOCOL
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_TOS
condition|)
name|fconf
operator||=
name|F_TOS
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VLAN
condition|)
name|fconf
operator||=
name|F_VLAN
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VNIC
condition|)
name|fconf
operator||=
name|F_VNIC_ID
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_PORT
condition|)
name|fconf
operator||=
name|F_PORT
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_FCoE
condition|)
name|fconf
operator||=
name|F_FCOE
expr_stmt|;
return|return
operator|(
name|fconf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fspec_to_fconf
parameter_list|(
name|struct
name|t4_filter_specification
modifier|*
name|fs
parameter_list|)
block|{
name|uint32_t
name|fconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|frag
operator|||
name|fs
operator|->
name|mask
operator|.
name|frag
condition|)
name|fconf
operator||=
name|F_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|matchtype
operator|||
name|fs
operator|->
name|mask
operator|.
name|matchtype
condition|)
name|fconf
operator||=
name|F_MPSHITTYPE
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|macidx
operator|||
name|fs
operator|->
name|mask
operator|.
name|macidx
condition|)
name|fconf
operator||=
name|F_MACMATCH
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|ethtype
operator|||
name|fs
operator|->
name|mask
operator|.
name|ethtype
condition|)
name|fconf
operator||=
name|F_ETHERTYPE
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|proto
operator|||
name|fs
operator|->
name|mask
operator|.
name|proto
condition|)
name|fconf
operator||=
name|F_PROTOCOL
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|tos
operator|||
name|fs
operator|->
name|mask
operator|.
name|tos
condition|)
name|fconf
operator||=
name|F_TOS
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|vlan_vld
operator|||
name|fs
operator|->
name|mask
operator|.
name|vlan_vld
condition|)
name|fconf
operator||=
name|F_VLAN
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|vnic_vld
operator|||
name|fs
operator|->
name|mask
operator|.
name|vnic_vld
condition|)
name|fconf
operator||=
name|F_VNIC_ID
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|iport
operator|||
name|fs
operator|->
name|mask
operator|.
name|iport
condition|)
name|fconf
operator||=
name|F_PORT
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|fcoe
operator|||
name|fs
operator|->
name|mask
operator|.
name|fcoe
condition|)
name|fconf
operator||=
name|F_FCOE
expr_stmt|;
return|return
operator|(
name|fconf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|fconf
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4getfm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|t4_read_indirect
argument_list|(
name|sc
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|fconf
argument_list|,
literal|1
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
operator|!=
name|fconf
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: cached filter mode out of sync %x %x.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
argument_list|,
name|fconf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
operator|=
name|fconf
expr_stmt|;
block|}
operator|*
name|mode
operator|=
name|fconf_to_mode
argument_list|(
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|fconf
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|fconf
operator|=
name|mode_to_fconf
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setfm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|sc
operator|->
name|offload_map
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
name|rc
operator|=
operator|-
name|t4_set_filter_mode
argument_list|(
name|sc
argument_list|,
name|fconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|sc
operator|->
name|filter_mode
operator|=
name|fconf
expr_stmt|;
else|#
directive|else
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
endif|#
directive|endif
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|get_filter_hits
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|fid
parameter_list|)
block|{
name|uint32_t
name|mw_base
decl_stmt|,
name|off
decl_stmt|,
name|tcb_base
init|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TCB_BASE
argument_list|)
decl_stmt|;
name|uint64_t
name|hits
decl_stmt|;
name|memwin_info
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|&
name|mw_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|off
operator|=
name|position_memwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|tcb_base
operator|+
operator|(
name|fid
operator|+
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|)
operator|*
name|TCB_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|hits
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|mw_base
operator|+
name|off
operator|+
literal|16
argument_list|)
expr_stmt|;
name|hits
operator|=
name|be64toh
argument_list|(
name|hits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hits
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|mw_base
operator|+
name|off
operator|+
literal|24
argument_list|)
expr_stmt|;
name|hits
operator|=
name|be32toh
argument_list|(
name|hits
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hits
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|nfilters
init|=
name|sc
operator|->
name|tids
operator|.
name|nftids
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4getf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
operator|||
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
operator|||
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
block|{
name|t
operator|->
name|idx
operator|=
literal|0xffffffff
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|t
operator|->
name|idx
init|;
name|i
operator|<
name|nfilters
condition|;
name|i
operator|++
operator|,
name|f
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|valid
condition|)
block|{
name|t
operator|->
name|idx
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|l2tidx
operator|=
name|f
operator|->
name|l2t
condition|?
name|f
operator|->
name|l2t
operator|->
name|idx
else|:
literal|0
expr_stmt|;
name|t
operator|->
name|smtidx
operator|=
name|f
operator|->
name|smtidx
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|hitcnts
condition|)
name|t
operator|->
name|hits
operator|=
name|get_filter_hits
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|hits
operator|=
name|UINT64_MAX
expr_stmt|;
name|t
operator|->
name|fs
operator|=
name|f
operator|->
name|fs
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|t
operator|->
name|idx
operator|=
literal|0xffffffff
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|nfilters
decl_stmt|,
name|nports
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|nfilters
operator|=
name|sc
operator|->
name|tids
operator|.
name|nftids
expr_stmt|;
name|nports
operator|=
name|sc
operator|->
name|params
operator|.
name|nports
expr_stmt|;
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Validate against the global filter mode */
if|if
condition|(
operator|(
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
operator||
name|fspec_to_fconf
argument_list|(
operator|&
name|t
operator|->
name|fs
argument_list|)
operator|)
operator|!=
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
condition|)
block|{
name|rc
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
operator|&&
name|t
operator|->
name|fs
operator|.
name|eport
operator|>=
name|nports
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
operator|>=
name|nports
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Can't specify an iq if not steering to it */
if|if
condition|(
operator|!
name|t
operator|->
name|fs
operator|.
name|dirsteer
operator|&&
name|t
operator|->
name|fs
operator|.
name|iq
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* IPv6 filter idx must be 4 aligned */
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|type
operator|==
literal|1
operator|&&
operator|(
operator|(
name|t
operator|->
name|idx
operator|&
literal|0x3
operator|)
operator|||
name|t
operator|->
name|idx
operator|+
literal|4
operator|>=
name|nfilters
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: no memory allocated but filters_in_use> 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filter_entry
argument_list|)
operator|*
name|nfilters
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|,
literal|"T4 filters"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|pending
operator|||
name|f
operator|->
name|valid
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|locked
condition|)
block|{
name|rc
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|type
operator|==
literal|0
condition|)
break|break;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
name|f
operator|->
name|fs
operator|=
name|t
operator|->
name|fs
expr_stmt|;
name|rc
operator|=
name|set_filter_wr
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|f
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|f
operator|->
name|valid
condition|?
literal|0
else|:
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|,
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4setfw"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINPROGRESS
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|nfilters
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4delf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|nfilters
operator|=
name|sc
operator|->
name|tids
operator|.
name|nftids
expr_stmt|;
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
operator|||
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
operator|||
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|pending
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|locked
condition|)
block|{
name|rc
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|valid
condition|)
block|{
name|t
operator|->
name|fs
operator|=
name|f
operator|->
name|fs
expr_stmt|;
comment|/* extra info for the caller */
name|rc
operator|=
name|del_filter_wr
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|f
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|f
operator|->
name|valid
condition|?
name|EIO
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|,
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4delfw"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINPROGRESS
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_filter
parameter_list|(
name|struct
name|filter_entry
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|l2t
condition|)
name|t4_l2t_release
argument_list|(
name|f
operator|->
name|l2t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|f
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|fidx
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|f
init|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|fidx
index|]
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_filter_wr
modifier|*
name|fwr
decl_stmt|;
name|unsigned
name|int
name|ftid
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|newdmac
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
condition|)
block|{
comment|/* This filter needs an L2T entry; allocate one. */
name|f
operator|->
name|l2t
operator|=
name|t4_l2t_alloc_switching
argument_list|(
name|sc
operator|->
name|l2t
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|l2t
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|t4_l2t_set_switching
argument_list|(
name|sc
argument_list|,
name|f
operator|->
name|l2t
argument_list|,
name|f
operator|->
name|fs
operator|.
name|vlan
argument_list|,
name|f
operator|->
name|fs
operator|.
name|eport
argument_list|,
name|f
operator|->
name|fs
operator|.
name|dmac
argument_list|)
condition|)
block|{
name|t4_l2t_release
argument_list|(
name|f
operator|->
name|l2t
argument_list|)
expr_stmt|;
name|f
operator|->
name|l2t
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|ftid
operator|=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|+
name|fidx
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fwr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|op_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FILTER_WR
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|len16_pkd
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|tid_to_iq
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_TID
argument_list|(
name|ftid
argument_list|)
operator||
name|V_FW_FILTER_WR_RQTYPE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|type
argument_list|)
operator||
name|V_FW_FILTER_WR_NOREPLY
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_FILTER_WR_IQ
argument_list|(
name|f
operator|->
name|fs
operator|.
name|iq
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|del_filter_to_l2tix
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_RPTTID
argument_list|(
name|f
operator|->
name|fs
operator|.
name|rpttid
argument_list|)
operator||
name|V_FW_FILTER_WR_DROP
argument_list|(
name|f
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_DROP
argument_list|)
operator||
name|V_FW_FILTER_WR_DIRSTEER
argument_list|(
name|f
operator|->
name|fs
operator|.
name|dirsteer
argument_list|)
operator||
name|V_FW_FILTER_WR_MASKHASH
argument_list|(
name|f
operator|->
name|fs
operator|.
name|maskhash
argument_list|)
operator||
name|V_FW_FILTER_WR_DIRSTEERHASH
argument_list|(
name|f
operator|->
name|fs
operator|.
name|dirsteerhash
argument_list|)
operator||
name|V_FW_FILTER_WR_LPBK
argument_list|(
name|f
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
argument_list|)
operator||
name|V_FW_FILTER_WR_DMAC
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newdmac
argument_list|)
operator||
name|V_FW_FILTER_WR_SMAC
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newsmac
argument_list|)
operator||
name|V_FW_FILTER_WR_INSVLAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_INSERT
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
argument_list|)
operator||
name|V_FW_FILTER_WR_RMVLAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REMOVE
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
argument_list|)
operator||
name|V_FW_FILTER_WR_HITCNTS
argument_list|(
name|f
operator|->
name|fs
operator|.
name|hitcnts
argument_list|)
operator||
name|V_FW_FILTER_WR_TXCHAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|eport
argument_list|)
operator||
name|V_FW_FILTER_WR_PRIO
argument_list|(
name|f
operator|->
name|fs
operator|.
name|prio
argument_list|)
operator||
name|V_FW_FILTER_WR_L2TIX
argument_list|(
name|f
operator|->
name|l2t
condition|?
name|f
operator|->
name|l2t
operator|->
name|idx
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ethtype
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|ethtype
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ethtypem
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|ethtype
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|frag_to_ovlan_vldm
operator|=
operator|(
name|V_FW_FILTER_WR_FRAG
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|frag
argument_list|)
operator||
name|V_FW_FILTER_WR_FRAGM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|frag
argument_list|)
operator||
name|V_FW_FILTER_WR_IVLAN_VLD
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_OVLAN_VLD
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_IVLAN_VLDM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_OVLAN_VLDM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic_vld
argument_list|)
operator|)
expr_stmt|;
name|fwr
operator|->
name|smac_sel
operator|=
literal|0
expr_stmt|;
name|fwr
operator|->
name|rx_chan_rx_rpl_iq
operator|=
name|htobe16
argument_list|(
name|V_FW_FILTER_WR_RX_CHAN
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_FILTER_WR_RX_RPL_IQ
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|maci_to_matchtypem
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_MACI
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|macidx
argument_list|)
operator||
name|V_FW_FILTER_WR_MACIM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|macidx
argument_list|)
operator||
name|V_FW_FILTER_WR_FCOE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|fcoe
argument_list|)
operator||
name|V_FW_FILTER_WR_FCOEM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|fcoe
argument_list|)
operator||
name|V_FW_FILTER_WR_PORT
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
argument_list|)
operator||
name|V_FW_FILTER_WR_PORTM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|iport
argument_list|)
operator||
name|V_FW_FILTER_WR_MATCHTYPE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|matchtype
argument_list|)
operator||
name|V_FW_FILTER_WR_MATCHTYPEM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|matchtype
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ptcl
operator|=
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|proto
expr_stmt|;
name|fwr
operator|->
name|ptclm
operator|=
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|proto
expr_stmt|;
name|fwr
operator|->
name|ttyp
operator|=
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|tos
expr_stmt|;
name|fwr
operator|->
name|ttypm
operator|=
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|tos
expr_stmt|;
name|fwr
operator|->
name|ivlan
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ivlanm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ovlan
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ovlanm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|dip
argument_list|,
name|fwr
operator|->
name|lip
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|lip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|dip
argument_list|,
name|fwr
operator|->
name|lipm
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|lipm
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|sip
argument_list|,
name|fwr
operator|->
name|fip
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|fip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|sip
argument_list|,
name|fwr
operator|->
name|fipm
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|fipm
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|lp
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|dport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|lpm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|dport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|fp
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|sport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|fpm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|newsmac
condition|)
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|smac
argument_list|,
name|fwr
operator|->
name|sma
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|sma
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|++
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|fidx
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|f
init|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|fidx
index|]
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_filter_wr
modifier|*
name|fwr
decl_stmt|;
name|unsigned
name|int
name|ftid
decl_stmt|;
name|ftid
operator|=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|+
name|fidx
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fwr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|t4_mk_filtdelwr
argument_list|(
name|ftid
argument_list|,
name|fwr
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_filter_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|rpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|idx
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rc
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: payload with opcode %02x"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ftid
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|idx
operator|-=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
expr_stmt|;
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|idx
index|]
expr_stmt|;
name|rc
operator|=
name|G_COOKIE
argument_list|(
name|rpl
operator|->
name|cookie
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|FW_FILTER_WR_FLT_ADDED
condition|)
block|{
name|KASSERT
argument_list|(
name|f
operator|->
name|pending
argument_list|,
operator|(
literal|"%s: filter[%u] isn't pending."
operator|,
name|__func__
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|smtidx
operator|=
operator|(
name|be64toh
argument_list|(
name|rpl
operator|->
name|oldval
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
comment|/* asynchronous setup completed */
name|f
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rc
operator|!=
name|FW_FILTER_WR_FLT_DELETED
condition|)
block|{
comment|/* Add or delete failed, display an error */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filter %u setup failed with error %u\n"
argument_list|,
name|idx
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|clear_filter
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|--
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_sge_context
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_sge_context
modifier|*
name|cntxt
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|cntxt
operator|->
name|cid
operator|>
name|M_CTXTQID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_EGRESS
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_INGRESS
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_FLM
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_CNM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4ctxt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FW_OK
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_sge_ctxt_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|cntxt
operator|->
name|cid
argument_list|,
name|cntxt
operator|->
name|mem_id
argument_list|,
operator|&
name|cntxt
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Read via firmware failed or wasn't even attempted.  Read directly via 	 * the backdoor. 	 */
name|rc
operator|=
operator|-
name|t4_sge_ctxt_rd_bd
argument_list|(
name|sc
argument_list|,
name|cntxt
operator|->
name|cid
argument_list|,
name|cntxt
operator|->
name|mem_id
argument_list|,
operator|&
name|cntxt
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_fw
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_data
modifier|*
name|fw
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint8_t
modifier|*
name|fw_data
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4ldfw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fw_data
operator|=
name|malloc
argument_list|(
name|fw
operator|->
name|len
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_data
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|copyin
argument_list|(
name|fw
operator|->
name|data
argument_list|,
name|fw_data
argument_list|,
name|fw
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|rc
operator|=
operator|-
name|t4_load_fw
argument_list|(
name|sc
argument_list|,
name|fw_data
argument_list|,
name|fw
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fw_data
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_card_mem
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|win
parameter_list|,
name|struct
name|t4_mem_range
modifier|*
name|mr
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|,
name|off
decl_stmt|,
name|remaining
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|uint32_t
name|mw_base
decl_stmt|,
name|mw_aperture
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|uint8_t
modifier|*
name|dst
decl_stmt|;
name|rc
operator|=
name|validate_mem_range
argument_list|(
name|sc
argument_list|,
name|mr
operator|->
name|addr
argument_list|,
name|mr
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|memwin_info
argument_list|(
name|sc
argument_list|,
name|win
argument_list|,
operator|&
name|mw_base
argument_list|,
operator|&
name|mw_aperture
argument_list|)
expr_stmt|;
name|buf
operator|=
name|b
operator|=
name|malloc
argument_list|(
name|min
argument_list|(
name|mr
operator|->
name|len
argument_list|,
name|mw_aperture
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mr
operator|->
name|addr
expr_stmt|;
name|remaining
operator|=
name|mr
operator|->
name|len
expr_stmt|;
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
name|mr
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|remaining
condition|)
block|{
name|off
operator|=
name|position_memwin
argument_list|(
name|sc
argument_list|,
name|win
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* number of bytes that we'll copy in the inner loop */
name|n
operator|=
name|min
argument_list|(
name|remaining
argument_list|,
name|mw_aperture
operator|-
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|4
control|)
operator|*
name|b
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|mw_base
operator|+
name|off
operator|+
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|dst
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
name|b
operator|=
name|buf
expr_stmt|;
name|dst
operator|+=
name|n
expr_stmt|;
name|remaining
operator|-=
name|n
expr_stmt|;
name|addr
operator|+=
name|n
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_i2c
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_i2c_data
modifier|*
name|i2cd
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|i2cd
operator|->
name|len
operator|==
literal|0
operator|||
name|i2cd
operator|->
name|port_id
operator|>=
name|sc
operator|->
name|params
operator|.
name|nports
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|i2cd
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|i2cd
operator|->
name|data
argument_list|)
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4i2crd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
operator|-
name|t4_i2c_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|i2cd
operator|->
name|port_id
argument_list|,
name|i2cd
operator|->
name|dev_addr
argument_list|,
name|i2cd
operator|->
name|offset
argument_list|,
name|i2cd
operator|->
name|len
argument_list|,
operator|&
name|i2cd
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|in_range
parameter_list|(
name|int
name|val
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
return|return
operator|(
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|<=
name|hi
operator|&&
name|val
operator|>=
name|lo
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_sched_class
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_sched_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|fw_subcmd
decl_stmt|,
name|fw_type
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setsc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Translate the cxgbetool parameters into T4 firmware parameters.  (The 	 * sub-command and type are in common locations.) 	 */
if|if
condition|(
name|p
operator|->
name|subcmd
operator|==
name|SCHED_CLASS_SUBCMD_CONFIG
condition|)
name|fw_subcmd
operator|=
name|FW_SCHED_SC_CONFIG
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|subcmd
operator|==
name|SCHED_CLASS_SUBCMD_PARAMS
condition|)
name|fw_subcmd
operator|=
name|FW_SCHED_SC_PARAMS
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|SCHED_CLASS_TYPE_PACKET
condition|)
name|fw_type
operator|=
name|FW_SCHED_TYPE_PKTSCHED
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|fw_subcmd
operator|==
name|FW_SCHED_SC_CONFIG
condition|)
block|{
comment|/* Vet our parameters ..*/
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|config
operator|.
name|minmax
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* And pass the request to the firmware ...*/
name|rc
operator|=
operator|-
name|t4_sched_config
argument_list|(
name|sc
argument_list|,
name|fw_type
argument_list|,
name|p
operator|->
name|u
operator|.
name|config
operator|.
name|minmax
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|fw_subcmd
operator|==
name|FW_SCHED_SC_PARAMS
condition|)
block|{
name|int
name|fw_level
decl_stmt|;
name|int
name|fw_mode
decl_stmt|;
name|int
name|fw_rateunit
decl_stmt|;
name|int
name|fw_ratemode
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_RL
condition|)
name|fw_level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CL_RL
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_WRR
condition|)
name|fw_level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CL_WRR
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CH_RL
condition|)
name|fw_level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CH_RL
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|mode
operator|==
name|SCHED_CLASS_MODE_CLASS
condition|)
name|fw_mode
operator|=
name|FW_SCHED_PARAMS_MODE_CLASS
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|mode
operator|==
name|SCHED_CLASS_MODE_FLOW
condition|)
name|fw_mode
operator|=
name|FW_SCHED_PARAMS_MODE_FLOW
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|rateunit
operator|==
name|SCHED_CLASS_RATEUNIT_BITS
condition|)
name|fw_rateunit
operator|=
name|FW_SCHED_PARAMS_UNIT_BITRATE
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|rateunit
operator|==
name|SCHED_CLASS_RATEUNIT_PKTS
condition|)
name|fw_rateunit
operator|=
name|FW_SCHED_PARAMS_UNIT_PKTRATE
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|ratemode
operator|==
name|SCHED_CLASS_RATEMODE_REL
condition|)
name|fw_ratemode
operator|=
name|FW_SCHED_PARAMS_RATE_REL
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|ratemode
operator|==
name|SCHED_CLASS_RATEMODE_ABS
condition|)
name|fw_ratemode
operator|=
name|FW_SCHED_PARAMS_RATE_ABS
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Vet our parameters ... */
if|if
condition|(
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|channel
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|cl
argument_list|,
literal|0
argument_list|,
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
literal|15
else|:
literal|16
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Translate any unset parameters into the firmware's 		 * nomenclature and/or fail the call if the parameters 		 * are required ... 		 */
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|rateunit
operator|<
literal|0
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|ratemode
operator|<
literal|0
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|channel
operator|<
literal|0
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|cl
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
operator|<
literal|0
condition|)
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_RL
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CH_RL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_WRR
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|pktsize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_RL
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CH_RL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|pktsize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See what the firmware thinks of the request ... */
name|rc
operator|=
operator|-
name|t4_sched_params
argument_list|(
name|sc
argument_list|,
name|fw_type
argument_list|,
name|fw_level
argument_list|,
name|fw_mode
argument_list|,
name|fw_rateunit
argument_list|,
name|fw_ratemode
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|channel
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|cl
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|pktsize
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_sched_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_sched_queue
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|NULL
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|uint32_t
name|fw_mnem
decl_stmt|,
name|fw_queue
decl_stmt|,
name|fw_class
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setsq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|port
operator|>=
name|sc
operator|->
name|params
operator|.
name|nports
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|p
operator|->
name|port
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|queue
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|ntxq
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|cl
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Create a template for the FW_PARAMS_CMD mnemonic and value (TX 	 * Scheduling Class in this case). 	 */
name|fw_mnem
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DMAQ
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DMAQ_EQ_SCHEDCLASS_ETH
argument_list|)
operator|)
expr_stmt|;
name|fw_class
operator|=
name|p
operator|->
name|cl
operator|<
literal|0
condition|?
literal|0xffffffff
else|:
name|p
operator|->
name|cl
expr_stmt|;
comment|/* 	 * If op.queue is non-negative, then we're only changing the scheduling 	 * on a single specified TX queue. 	 */
if|if
condition|(
name|p
operator|->
name|queue
operator|>=
literal|0
condition|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|txq
index|[
name|pi
operator|->
name|first_txq
operator|+
name|p
operator|->
name|queue
index|]
expr_stmt|;
name|fw_queue
operator|=
operator|(
name|fw_mnem
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|txq
operator|->
name|eq
operator|.
name|cntxt_id
argument_list|)
operator|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|fw_queue
argument_list|,
operator|&
name|fw_class
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Change the scheduling on all the TX queues for the 	 * interface. 	 */
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|fw_queue
operator|=
operator|(
name|fw_mnem
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|txq
operator|->
name|eq
operator|.
name|cntxt_id
argument_list|)
operator|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|fw_queue
argument_list|,
operator|&
name|fw_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_find_pci_capability
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
return|return
operator|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|cap
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|?
name|i
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_os_portmod_changed
parameter_list|(
specifier|const
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|mod_str
index|[]
init|=
block|{
name|NULL
block|,
literal|"LR"
block|,
literal|"SR"
block|,
literal|"ER"
block|,
literal|"TWINAX"
block|,
literal|"active TWINAX"
block|,
literal|"LRM"
block|}
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_NONE
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"transceiver unplugged.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_UNKNOWN
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"unknown transceiver inserted.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_NOTSUPPORTED
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"unsupported transceiver inserted.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|>
literal|0
operator|&&
name|pi
operator|->
name|mod_type
operator|<
name|nitems
argument_list|(
name|mod_str
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"%s transceiver inserted.\n"
argument_list|,
name|mod_str
index|[
name|pi
operator|->
name|mod_type
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"transceiver (type %d) inserted.\n"
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_os_link_changed
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|link_stat
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|link_stat
condition|)
block|{
name|pi
operator|->
name|linkdnrc
operator|=
operator|-
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|pi
operator|->
name|link_cfg
operator|.
name|speed
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reason
operator|>=
literal|0
condition|)
name|pi
operator|->
name|linkdnrc
operator|=
name|reason
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_iterate
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&t4_list
argument_list|,
argument|link
argument_list|)
block|{
comment|/* 		 * func should not make any assumptions about what state sc is 		 * in - the only guarantee is that sc->sc_lock is a valid lock. 		 */
name|func
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|rc
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHELSIO_T4_GETREG
case|:
block|{
name|struct
name|t4_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|4
condition|)
name|edata
operator|->
name|val
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|8
condition|)
name|edata
operator|->
name|val
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|CHELSIO_T4_SETREG
case|:
block|{
name|struct
name|t4_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|edata
operator|->
name|val
operator|&
literal|0xffffffff00000000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
operator|(
name|uint32_t
operator|)
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|8
condition|)
name|t4_write_reg64
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|CHELSIO_T4_REGDUMP
case|:
block|{
name|struct
name|t4_regdump
modifier|*
name|regs
init|=
operator|(
expr|struct
name|t4_regdump
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|reglen
init|=
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
name|T4_REGDUMP_SIZE
else|:
name|T5_REGDUMP_SIZE
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|regs
operator|->
name|len
operator|<
name|reglen
condition|)
block|{
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
comment|/* hint to the caller */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|reglen
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|t4_get_regs
argument_list|(
name|sc
argument_list|,
name|regs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rc
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|regs
operator|->
name|data
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_T4_GET_FILTER_MODE
case|:
name|rc
operator|=
name|get_filter_mode
argument_list|(
name|sc
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_FILTER_MODE
case|:
name|rc
operator|=
name|set_filter_mode
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_FILTER
case|:
name|rc
operator|=
name|get_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_FILTER
case|:
name|rc
operator|=
name|set_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_DEL_FILTER
case|:
name|rc
operator|=
name|del_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_SGE_CONTEXT
case|:
name|rc
operator|=
name|get_sge_context
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_sge_context
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_LOAD_FW
case|:
name|rc
operator|=
name|load_fw
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_data
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_MEM
case|:
name|rc
operator|=
name|read_card_mem
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
operator|(
expr|struct
name|t4_mem_range
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_I2C
case|:
name|rc
operator|=
name|read_i2c
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_i2c_data
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_CLEAR_STATS
case|:
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|port_id
init|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
name|port_id
operator|>=
name|sc
operator|->
name|params
operator|.
name|nports
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|port_id
index|]
expr_stmt|;
comment|/* MAC stats */
name|t4_clr_port_stats
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
block|{
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|wrq
decl_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|rxq
operator|->
name|lro
operator|.
name|lro_queued
operator|=
literal|0
expr_stmt|;
name|rxq
operator|->
name|lro
operator|.
name|lro_flushed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|rxq
operator|->
name|rxcsum
operator|=
literal|0
expr_stmt|;
name|rxq
operator|->
name|vlan_extraction
operator|=
literal|0
expr_stmt|;
block|}
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|txq
operator|->
name|txcsum
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|tso_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|vlan_insertion
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|imm_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|sgl_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkt_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkts_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkts_pkts
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|br
operator|->
name|br_drops
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|no_dmamap
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|no_desc
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
comment|/* nothing to clear for each ofld_rxq */
name|for_each_ofld_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|wrq
argument_list|)
block|{
name|wrq
operator|->
name|tx_wrs
operator|=
literal|0
expr_stmt|;
name|wrq
operator|->
name|no_desc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|wrq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
expr_stmt|;
name|wrq
operator|->
name|tx_wrs
operator|=
literal|0
expr_stmt|;
name|wrq
operator|->
name|no_desc
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CHELSIO_T4_SCHED_CLASS
case|:
name|rc
operator|=
name|set_sched_class
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_sched_params
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SCHED_QUEUE
case|:
name|rc
operator|=
name|set_sched_queue
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_sched_queue
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_TRACER
case|:
name|rc
operator|=
name|t4_get_tracer
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_tracer
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_TRACER
case|:
name|rc
operator|=
name|t4_set_tracer
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_tracer
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|cxgbe_init_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|t4_activate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EAGAIN
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"You must kldload t4_tom.ko before trying "
literal|"to enable TOE on a cxgbe interface.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|tom_softc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: TOM activated but softc NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
argument_list|,
operator|(
literal|"%s: TOM activated but flag not set"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
argument_list|,
operator|(
literal|"%s: TOM never initialized?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an upper layer driver to the global list.  */
end_comment

begin_function
name|int
name|t4_register_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|->
name|uld_id
operator|==
name|ui
operator|->
name|uld_id
condition|)
block|{
name|rc
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t4_uld_list
argument_list|,
name|ui
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ui
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_unregister_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|==
name|ui
condition|)
block|{
if|if
condition|(
name|ui
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|t4_uld_list
argument_list|,
name|ui
argument_list|,
name|uld_info
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_activate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
init|=
name|EAGAIN
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
name|rc
operator|=
name|ui
operator|->
name|activate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|ui
operator|->
name|refcount
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_deactivate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
name|rc
operator|=
name|ui
operator|->
name|deactivate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|ui
operator|->
name|refcount
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Come up with reasonable defaults for some of the tunables, provided they're  * not set by the user (in which case we'll use the values as is).  */
end_comment

begin_function
specifier|static
name|void
name|tweak_tunables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nc
init|=
name|mp_ncpus
decl_stmt|;
comment|/* our snapshot of the number of CPUs */
if|if
condition|(
name|t4_ntxq10g
operator|<
literal|1
condition|)
name|t4_ntxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NTXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_ntxq1g
operator|<
literal|1
condition|)
name|t4_ntxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NTXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nrxq10g
operator|<
literal|1
condition|)
name|t4_nrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NRXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nrxq1g
operator|<
literal|1
condition|)
name|t4_nrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NRXQ_1G
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|t4_nofldtxq10g
operator|<
literal|1
condition|)
name|t4_nofldtxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDTXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldtxq1g
operator|<
literal|1
condition|)
name|t4_nofldtxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDTXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldrxq10g
operator|<
literal|1
condition|)
name|t4_nofldrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDRXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldrxq1g
operator|<
literal|1
condition|)
name|t4_nofldrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDRXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_toecaps_allowed
operator|==
operator|-
literal|1
condition|)
name|t4_toecaps_allowed
operator|=
name|FW_CAPS_CONFIG_TOE
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|t4_toecaps_allowed
operator|==
operator|-
literal|1
condition|)
name|t4_toecaps_allowed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|t4_nnmtxq10g
operator|<
literal|1
condition|)
name|t4_nnmtxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMTXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nnmtxq1g
operator|<
literal|1
condition|)
name|t4_nnmtxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMTXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nnmrxq10g
operator|<
literal|1
condition|)
name|t4_nnmrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMRXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nnmrxq1g
operator|<
literal|1
condition|)
name|t4_nnmrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMRXQ_1G
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t4_tmr_idx_10g
operator|<
literal|0
operator|||
name|t4_tmr_idx_10g
operator|>=
name|SGE_NTIMERS
condition|)
name|t4_tmr_idx_10g
operator|=
name|TMR_IDX_10G
expr_stmt|;
if|if
condition|(
name|t4_pktc_idx_10g
operator|<
operator|-
literal|1
operator|||
name|t4_pktc_idx_10g
operator|>=
name|SGE_NCOUNTERS
condition|)
name|t4_pktc_idx_10g
operator|=
name|PKTC_IDX_10G
expr_stmt|;
if|if
condition|(
name|t4_tmr_idx_1g
operator|<
literal|0
operator|||
name|t4_tmr_idx_1g
operator|>=
name|SGE_NTIMERS
condition|)
name|t4_tmr_idx_1g
operator|=
name|TMR_IDX_1G
expr_stmt|;
if|if
condition|(
name|t4_pktc_idx_1g
operator|<
operator|-
literal|1
operator|||
name|t4_pktc_idx_1g
operator|>=
name|SGE_NCOUNTERS
condition|)
name|t4_pktc_idx_1g
operator|=
name|PKTC_IDX_1G
expr_stmt|;
if|if
condition|(
name|t4_qsize_txq
operator|<
literal|128
condition|)
name|t4_qsize_txq
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|t4_qsize_rxq
operator|<
literal|128
condition|)
name|t4_qsize_rxq
operator|=
literal|128
expr_stmt|;
while|while
condition|(
name|t4_qsize_rxq
operator|&
literal|7
condition|)
name|t4_qsize_rxq
operator|++
expr_stmt|;
name|t4_intr_types
operator|&=
name|INTR_MSIX
operator||
name|INTR_MSI
operator||
name|INTR_INTX
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sx
name|mlu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mod load unload */
end_comment

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|cxgbe_mlu
argument_list|,
operator|&
name|mlu
argument_list|,
literal|"cxgbe mod load/unload"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|loaded
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|sx_xlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
if|if
condition|(
name|loaded
operator|++
operator|==
literal|0
condition|)
block|{
name|t4_sge_modload
argument_list|()
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|t4_list_lock
argument_list|,
literal|"T4/T5 adapters"
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t4_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_init
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|,
literal|"T4/T5 ULDs"
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t4_uld_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t4_tracer_modload
argument_list|()
expr_stmt|;
name|tweak_tunables
argument_list|()
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|sx_xlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loaded
operator|==
literal|0
condition|)
block|{
name|int
name|tries
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t4_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
goto|goto
name|done_unload
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_slock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t4_uld_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
goto|goto
name|done_unload
goto|;
block|}
endif|#
directive|endif
name|tries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|5
operator|&&
name|t4_sge_extfree_refs
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"%ju clusters with custom free routine "
literal|"still is use.\n"
argument_list|,
name|t4_sge_extfree_refs
argument_list|()
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"t4unload"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_sge_extfree_refs
argument_list|()
operator|==
literal|0
condition|)
block|{
name|t4_tracer_modunload
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_destroy
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sx_destroy
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|t4_sge_modunload
argument_list|()
expr_stmt|;
name|loaded
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|loaded
operator|++
expr_stmt|;
comment|/* undo earlier decrement */
block|}
block|}
name|done_unload
label|:
name|sx_xunlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|t4_devclass
decl_stmt|,
name|t5_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgbe_devclass
decl_stmt|,
name|cxl_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|t4nex
argument_list|,
name|pci
argument_list|,
name|t4_driver
argument_list|,
name|t4_devclass
argument_list|,
name|mod_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t4nex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t4nex
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|t5nex
argument_list|,
name|pci
argument_list|,
name|t5_driver
argument_list|,
name|t5_devclass
argument_list|,
name|mod_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t5nex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t5nex
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgbe
argument_list|,
name|t4nex
argument_list|,
name|cxgbe_driver
argument_list|,
name|cxgbe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxgbe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxl
argument_list|,
name|t5nex
argument_list|,
name|cxl_driver
argument_list|,
name|cxl_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

