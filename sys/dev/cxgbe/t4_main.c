begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"t4_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"t4_l2t.h"
end_include

begin_comment
comment|/* T4 bus driver interface */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|t4_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|t4_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|t4_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|t4_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|t4_driver
init|=
block|{
literal|"t4nex"
block|,
name|t4_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T4 port (cxgbe) interface */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgbe_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgbe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgbe_driver
init|=
block|{
literal|"cxgbe"
block|,
name|cxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|port_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|t4_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|t4_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|t4_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|t4_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|t4_open
block|,
operator|.
name|d_close
operator|=
name|t4_close
block|,
operator|.
name|d_ioctl
operator|=
name|t4_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"t4nex"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ifnet + media interface */
end_comment

begin_function_decl
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CXGBE
argument_list|,
literal|"cxgbe"
argument_list|,
literal|"Chelsio T4 Ethernet driver and services"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Correct lock order when you need to acquire multiple locks is t4_list_lock,  * then ADAPTER_LOCK, then t4_uld_list_lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|t4_list_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|adapter
argument_list|)
name|t4_list
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|t4_uld_list_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|uld_info
argument_list|)
name|t4_uld_list
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Tunables.  See tweak_tunables() too.  */
end_comment

begin_comment
comment|/*  * Number of queues for tx and rx, 10G and 1G, NIC and offload.  */
end_comment

begin_define
define|#
directive|define
name|NTXQ_10G
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_ntxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.ntxq10g"
argument_list|,
operator|&
name|t4_ntxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NRXQ_10G
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nrxq10g"
argument_list|,
operator|&
name|t4_nrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NTXQ_1G
value|4
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_ntxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.ntxq1g"
argument_list|,
operator|&
name|t4_ntxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NRXQ_1G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nrxq1g"
argument_list|,
operator|&
name|t4_nrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_define
define|#
directive|define
name|NOFLDTXQ_10G
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldtxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldtxq10g"
argument_list|,
operator|&
name|t4_nofldtxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDRXQ_10G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldrxq10g"
argument_list|,
operator|&
name|t4_nofldrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDTXQ_1G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldtxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldtxq1g"
argument_list|,
operator|&
name|t4_nofldtxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDRXQ_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldrxq1g"
argument_list|,
operator|&
name|t4_nofldrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Holdoff parameters for 10G and 1G ports.  */
end_comment

begin_define
define|#
directive|define
name|TMR_IDX_10G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_tmr_idx_10g
init|=
name|TMR_IDX_10G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_10G"
argument_list|,
operator|&
name|t4_tmr_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PKTC_IDX_10G
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_pktc_idx_10g
init|=
name|PKTC_IDX_10G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_10G"
argument_list|,
operator|&
name|t4_pktc_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TMR_IDX_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_tmr_idx_1g
init|=
name|TMR_IDX_1G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_1G"
argument_list|,
operator|&
name|t4_tmr_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PKTC_IDX_1G
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_pktc_idx_1g
init|=
name|PKTC_IDX_1G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_1G"
argument_list|,
operator|&
name|t4_pktc_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Size (# of entries) of each tx and rx queue.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_qsize_txq
init|=
name|TX_EQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_txq"
argument_list|,
operator|&
name|t4_qsize_txq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_qsize_rxq
init|=
name|RX_IQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_rxq"
argument_list|,
operator|&
name|t4_qsize_rxq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Interrupt types allowed (bits 0, 1, 2 = INTx, MSI, MSI-X respectively).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_intr_types
init|=
name|INTR_MSIX
operator||
name|INTR_MSI
operator||
name|INTR_INTX
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.interrupt_types"
argument_list|,
operator|&
name|t4_intr_types
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Configuration file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|t4_cfg_file
index|[
literal|32
index|]
init|=
literal|"default"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
literal|"hw.cxgbe.config_file"
argument_list|,
name|t4_cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|t4_cfg_file
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ASIC features that will be used.  Disable the ones you don't want so that the  * chip resources aren't wasted on features that will not be used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_linkcaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* No DCBX, PPP, etc. by default */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.linkcaps_allowed"
argument_list|,
operator|&
name|t4_linkcaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_niccaps_allowed
init|=
name|FW_CAPS_CONFIG_NIC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.niccaps_allowed"
argument_list|,
operator|&
name|t4_niccaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_toecaps_allowed
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.toecaps_allowed"
argument_list|,
operator|&
name|t4_toecaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_rdmacaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.rdmacaps_allowed"
argument_list|,
operator|&
name|t4_rdmacaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_iscsicaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.iscsicaps_allowed"
argument_list|,
operator|&
name|t4_iscsicaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_fcoecaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fcoecaps_allowed"
argument_list|,
operator|&
name|t4_fcoecaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|intrs_and_queues
block|{
name|int
name|intr_type
decl_stmt|;
comment|/* INTx, MSI, or MSI-X */
name|int
name|nirq
decl_stmt|;
comment|/* Number of vectors */
name|int
name|intr_flags
decl_stmt|;
name|int
name|ntxq10g
decl_stmt|;
comment|/* # of NIC txq's for each 10G port */
name|int
name|nrxq10g
decl_stmt|;
comment|/* # of NIC rxq's for each 10G port */
name|int
name|ntxq1g
decl_stmt|;
comment|/* # of NIC txq's for each 1G port */
name|int
name|nrxq1g
decl_stmt|;
comment|/* # of NIC rxq's for each 1G port */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|int
name|nofldtxq10g
decl_stmt|;
comment|/* # of TOE txq's for each 10G port */
name|int
name|nofldrxq10g
decl_stmt|;
comment|/* # of TOE rxq's for each 10G port */
name|int
name|nofldtxq1g
decl_stmt|;
comment|/* # of TOE txq's for each 1G port */
name|int
name|nofldrxq1g
decl_stmt|;
comment|/* # of TOE rxq's for each 1G port */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|filter_entry
block|{
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/* filter allocated and valid */
name|uint32_t
name|locked
range|:
literal|1
decl_stmt|;
comment|/* filter is administratively locked */
name|uint32_t
name|pending
range|:
literal|1
decl_stmt|;
comment|/* filter action is pending firmware reply */
name|uint32_t
name|smtidx
range|:
literal|8
decl_stmt|;
comment|/* Source MAC Table index for smac */
name|struct
name|l2t_entry
modifier|*
name|l2t
decl_stmt|;
comment|/* Layer Two Table entry for dmac */
name|struct
name|t4_filter_specification
name|fs
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|XGMAC_MTU
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|XGMAC_PROMISC
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|XGMAC_ALLMULTI
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|XGMAC_VLANEX
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|XGMAC_UCADDR
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|XGMAC_MCADDRS
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|XGMAC_ALL
init|=
literal|0xffff
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|map_bars
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upload_config_file
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|partition_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_params__pre_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_mac_settings
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_uninit_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adapter_full_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adapter_full_uninit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|port_full_init
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|port_full_uninit
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_eq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_iq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_iq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_fl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_intr_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_regdump
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_vlan_config
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|an_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_bitfield
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SBUF_DRAIN
end_ifdef

begin_function_decl
specifier|static
name|int
name|sysctl_cctrl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cpl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_ddp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_devlog
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_fcoe_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_sched
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_lb_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_meminfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_path_mtus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_pm_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_rdma_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tcp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tids
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tp_err_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tx_rate
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|inline
name|void
name|txq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fconf_to_mode
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|mode_to_fconf
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fspec_to_fconf
parameter_list|(
name|struct
name|t4_filter_specification
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint64_t
name|get_filter_hits
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_filter
parameter_list|(
name|struct
name|filter_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filter_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_sge_context
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_sge_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_card_mem
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_mem_range
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function_decl
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|t4_mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|t4_pciids
block|{
name|uint16_t
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|t4_pciids
index|[]
init|=
block|{
block|{
literal|0xa000
block|,
literal|"Chelsio Terminator 4 FPGA"
block|}
block|,
block|{
literal|0x4400
block|,
literal|"Chelsio T440-dbg"
block|}
block|,
block|{
literal|0x4401
block|,
literal|"Chelsio T420-CR"
block|}
block|,
block|{
literal|0x4402
block|,
literal|"Chelsio T422-CR"
block|}
block|,
block|{
literal|0x4403
block|,
literal|"Chelsio T440-CR"
block|}
block|,
block|{
literal|0x4404
block|,
literal|"Chelsio T420-BCH"
block|}
block|,
block|{
literal|0x4405
block|,
literal|"Chelsio T440-BCH"
block|}
block|,
block|{
literal|0x4406
block|,
literal|"Chelsio T440-CH"
block|}
block|,
block|{
literal|0x4407
block|,
literal|"Chelsio T420-SO"
block|}
block|,
block|{
literal|0x4408
block|,
literal|"Chelsio T420-CX"
block|}
block|,
block|{
literal|0x4409
block|,
literal|"Chelsio T420-BT"
block|}
block|,
block|{
literal|0x440a
block|,
literal|"Chelsio T404-BT"
block|}
block|, }
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_comment
comment|/*  * service_iq() has an iq and needs the fl.  Offset of fl from the iq should be  * exactly the same for both rxq and ofld_rxq.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|,
name|iq
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|sge_rxq
argument_list|,
name|iq
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|,
name|fl
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|sge_rxq
argument_list|,
name|fl
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|v
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|d
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|f
init|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|PCI_VENDOR_ID_CHELSIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Attach only to PF0 of the FPGA */
if|if
condition|(
name|d
operator|==
literal|0xa000
operator|&&
name|f
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|t4_pciids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|==
name|t4_pciids
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t4_pciids
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|n10g
decl_stmt|,
name|n1g
decl_stmt|,
name|rqidx
decl_stmt|,
name|tqidx
decl_stmt|;
name|struct
name|intrs_and_queues
name|iaq
decl_stmt|;
name|struct
name|sge
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|int
name|ofld_rqidx
decl_stmt|,
name|ofld_tqidx
decl_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|pci_set_max_read_req
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|i
operator|+
name|PCIR_EXPRESS_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|v
operator||=
name|PCIM_EXP_CTL_RELAXED_ORD_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|i
operator|+
name|PCIR_EXPRESS_DEVICE_CTL
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|sc
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|sc
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t4_list
argument_list|,
name|sc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|,
literal|"starving freelists"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sfl
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * This is the real PF# to which we're attaching.  Works from within PCI 	 * passthrough environments too, where pci_get_function() could return a 	 * different PF# depending on the passthrough configuration.  We need to 	 * use the real PF# in all our communication with the firmware. 	 */
name|sc
operator|->
name|pf
operator|=
name|G_SOURCEPF
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_WHOAMI
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbox
operator|=
name|sc
operator|->
name|pf
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_handler
operator|=
name|an_not_handled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|sc
operator|->
name|cpl_handler
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|cpl_handler
index|[
name|i
index|]
operator|=
name|cpl_not_handled
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_SET_TCB_RPL
argument_list|,
name|filter_rpl
argument_list|)
expr_stmt|;
comment|/* Prepare the adapter for operation */
name|rc
operator|=
operator|-
name|t4_prep_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to prepare adapter: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Do this really early, with the memory windows set up even before the 	 * character device.  The userland tool's register i/o and mem read 	 * will work even in "recovery mode". 	 */
name|setup_memwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|t4_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Go no further if recovery mode has been requested. */
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.cxgbe.sos"
argument_list|,
operator|&
name|i
argument_list|)
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"recovery mode.\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Prepare the firmware for operation */
name|rc
operator|=
name|prep_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|get_params__pre_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|t4_sge_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|MASTER_PF
condition|)
block|{
comment|/* get basic stuff going */
name|rc
operator|=
operator|-
name|t4_fw_initialize
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"early init failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|rc
operator|=
name|get_params__post_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|MASTER_PF
condition|)
block|{
comment|/* final tweaks to some settings */
name|t4_load_mtus
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|sc
operator|->
name|params
operator|.
name|a_wnd
argument_list|,
name|sc
operator|->
name|params
operator|.
name|b_wnd
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_TDDP_PSZ
argument_list|,
name|V_HPZ0
argument_list|(
name|PAGE_SHIFT
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
name|F_TUNNELCNGDROP0
operator||
name|F_TUNNELCNGDROP1
operator||
name|F_TUNNELCNGDROP2
operator||
name|F_TUNNELCNGDROP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG5
argument_list|,
name|V_INDICATESIZE
argument_list|(
name|M_INDICATESIZE
argument_list|)
operator||
name|F_REARMDDPOFFSET
operator||
name|F_RESETDDPOFFSET
argument_list|,
name|V_INDICATESIZE
argument_list|(
name|M_INDICATESIZE
argument_list|)
operator||
name|F_REARMDDPOFFSET
operator||
name|F_RESETDDPOFFSET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX: Verify that we can live with whatever the master driver 		 * has done so far, and hope that it doesn't change any global 		 * setting from underneath us in the future. 		 */
block|}
name|t4_read_indirect
argument_list|(
name|sc
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|sc
operator|->
name|filter_mode
argument_list|,
literal|1
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_modq
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|rc
operator|=
name|t4_create_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * First pass over all the ports - allocate VIs and initialize some 	 * basic parameters like mac address, port type, etc.  We also figure 	 * out whether a port is 10G or 1G and use that information when 	 * calculating how many interrupts to attempt to allocate. 	 */
name|n10g
operator|=
name|n1g
operator|=
literal|0
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|pi
expr_stmt|;
comment|/* These must be set before t4_port_init */
name|pi
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|pi
operator|->
name|port_id
operator|=
name|i
expr_stmt|;
comment|/* Allocate the vi and initialize parameters like mac addr */
name|rc
operator|=
operator|-
name|t4_port_init
argument_list|(
name|pi
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize port %d: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|snprintf
argument_list|(
name|pi
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%sp%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|,
name|pi
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|n10g
operator|++
expr_stmt|;
name|pi
operator|->
name|tmr_idx
operator|=
name|t4_tmr_idx_10g
expr_stmt|;
name|pi
operator|->
name|pktc_idx
operator|=
name|t4_pktc_idx_10g
expr_stmt|;
block|}
else|else
block|{
name|n1g
operator|++
expr_stmt|;
name|pi
operator|->
name|tmr_idx
operator|=
name|t4_tmr_idx_1g
expr_stmt|;
name|pi
operator|->
name|pktc_idx
operator|=
name|t4_pktc_idx_1g
expr_stmt|;
block|}
name|pi
operator|->
name|xact_addr_filt
operator|=
operator|-
literal|1
expr_stmt|;
name|pi
operator|->
name|qsize_rxq
operator|=
name|t4_qsize_rxq
expr_stmt|;
name|pi
operator|->
name|qsize_txq
operator|=
name|t4_qsize_txq
expr_stmt|;
name|pi
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"cxgbe"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add device for port %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|device_set_softc
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Interrupt type, # of interrupts, # of rx/tx queues, etc. 	 */
name|rc
operator|=
name|cfg_itype_and_nqueues
argument_list|(
name|sc
argument_list|,
name|n10g
argument_list|,
name|n1g
argument_list|,
operator|&
name|iaq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|sc
operator|->
name|intr_type
operator|=
name|iaq
operator|.
name|intr_type
expr_stmt|;
name|sc
operator|->
name|intr_count
operator|=
name|iaq
operator|.
name|nirq
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|iaq
operator|.
name|intr_flags
expr_stmt|;
name|s
operator|=
operator|&
name|sc
operator|->
name|sge
expr_stmt|;
name|s
operator|->
name|nrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nrxq1g
expr_stmt|;
name|s
operator|->
name|ntxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|ntxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|ntxq1g
expr_stmt|;
name|s
operator|->
name|neq
operator|=
name|s
operator|->
name|ntxq
operator|+
name|s
operator|->
name|nrxq
expr_stmt|;
comment|/* the free list in an rxq is an eq */
name|s
operator|->
name|neq
operator|+=
name|sc
operator|->
name|params
operator|.
name|nports
operator|+
literal|1
expr_stmt|;
comment|/* ctrl queues: 1 per port + 1 mgmt */
name|s
operator|->
name|niq
operator|=
name|s
operator|->
name|nrxq
operator|+
literal|1
expr_stmt|;
comment|/* 1 extra for firmware event queue */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|s
operator|->
name|nofldrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nofldrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nofldrxq1g
expr_stmt|;
name|s
operator|->
name|nofldtxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nofldtxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nofldtxq1g
expr_stmt|;
name|s
operator|->
name|neq
operator|+=
name|s
operator|->
name|nofldtxq
operator|+
name|s
operator|->
name|nofldrxq
expr_stmt|;
name|s
operator|->
name|niq
operator|+=
name|s
operator|->
name|nofldrxq
expr_stmt|;
name|s
operator|->
name|ofld_rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nofldrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|ofld_txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nofldtxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_wrq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|->
name|ctrlq
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|params
operator|.
name|nports
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_wrq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|ntxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_txq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|iqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|niq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_iq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|eqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|neq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_eq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|intr_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|irq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_init_l2t
argument_list|(
name|sc
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Second pass over the ports.  This time we know the number of rx and 	 * tx queues that each port should get. 	 */
name|rqidx
operator|=
name|tqidx
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|ofld_rqidx
operator|=
name|ofld_tqidx
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
continue|continue;
name|pi
operator|->
name|first_rxq
operator|=
name|rqidx
expr_stmt|;
name|pi
operator|->
name|first_txq
operator|=
name|tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pi
operator|->
name|nrxq
operator|=
name|iaq
operator|.
name|nrxq10g
expr_stmt|;
name|pi
operator|->
name|ntxq
operator|=
name|iaq
operator|.
name|ntxq10g
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|nrxq
operator|=
name|iaq
operator|.
name|nrxq1g
expr_stmt|;
name|pi
operator|->
name|ntxq
operator|=
name|iaq
operator|.
name|ntxq1g
expr_stmt|;
block|}
name|rqidx
operator|+=
name|pi
operator|->
name|nrxq
expr_stmt|;
name|tqidx
operator|+=
name|pi
operator|->
name|ntxq
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|pi
operator|->
name|first_ofld_rxq
operator|=
name|ofld_rqidx
expr_stmt|;
name|pi
operator|->
name|first_ofld_txq
operator|=
name|ofld_tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pi
operator|->
name|nofldrxq
operator|=
name|iaq
operator|.
name|nofldrxq10g
expr_stmt|;
name|pi
operator|->
name|nofldtxq
operator|=
name|iaq
operator|.
name|nofldtxq10g
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|nofldrxq
operator|=
name|iaq
operator|.
name|nofldrxq1g
expr_stmt|;
name|pi
operator|->
name|nofldtxq
operator|=
name|iaq
operator|.
name|nofldtxq1g
expr_stmt|;
block|}
name|ofld_rqidx
operator|+=
name|pi
operator|->
name|nofldrxq
expr_stmt|;
name|ofld_tqidx
operator|+=
name|pi
operator|->
name|nofldtxq
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|rc
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach all child ports: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCIe x%d, %d ports, %d %s interrupt%s, %d eq, %d iq\n"
argument_list|,
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|width
argument_list|,
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
name|sc
operator|->
name|intr_count
argument_list|,
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSIX
condition|?
literal|"MSI-X"
else|:
operator|(
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSI
condition|?
literal|"MSI"
else|:
literal|"INTx"
operator|)
argument_list|,
name|sc
operator|->
name|intr_count
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|niq
argument_list|)
expr_stmt|;
name|t4_set_desc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|cdev
condition|)
block|{
comment|/* cdev was created and so cxgbetool works; recover that way. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error during attach, adapter is now in recovery mode.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|t4_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
name|t4_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
condition|)
block|{
name|destroy_dev
argument_list|(
name|sc
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|NULL
expr_stmt|;
block|}
name|rc
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to detach child devices: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NPORTS
condition|;
name|i
operator|++
control|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
name|t4_free_vi
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|viid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
name|adapter_full_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FW_OK
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSI
operator|||
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSIX
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|regs_rid
argument_list|,
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_rid
argument_list|,
name|sc
operator|->
name|msix_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|l2t
condition|)
name|t4_free_l2t
argument_list|(
name|sc
operator|->
name|l2t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sc
operator|->
name|irq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ctrlq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|iqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|eqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|t4_destroy_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|t4_list
argument_list|,
name|sc
argument_list|,
name|adapter
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"port %d"
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | \     IFCAP_VLAN_HWCSUM | IFCAP_TSO | IFCAP_JUMBO_MTU | IFCAP_LRO | \     IFCAP_VLAN_HWTSO | IFCAP_LINKSTATE | IFCAP_HWCSUM_IPV6)
end_define

begin_define
define|#
directive|define
name|T4_CAP_ENABLE
value|(T4_CAP& ~IFCAP_TSO6)
end_define

begin_function
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* Allocate an ifnet and set it up */
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pi
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|pi
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgbe_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgbe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|cxgbe_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|cxgbe_qflush
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|T4_CAP
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TOE4
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_capenable
operator|=
name|T4_CAP_ENABLE
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
expr_stmt|;
comment|/* Initialize ifmedia for this port */
name|ifmedia_init
argument_list|(
operator|&
name|pi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgbe_media_change
argument_list|,
name|cxgbe_media_status
argument_list|)
expr_stmt|;
name|build_medialist
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|vlan_c
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|cxgbe_vlan_config
argument_list|,
name|ifp
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|pi
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%d txq, %d rxq (NIC); %d txq, %d rxq (TOE)\n"
argument_list|,
name|pi
operator|->
name|ntxq
argument_list|,
name|pi
operator|->
name|nrxq
argument_list|,
name|pi
operator|->
name|nofldtxq
argument_list|,
name|pi
operator|->
name|nofldrxq
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%d txq, %d rxq\n"
argument_list|,
name|pi
operator|->
name|ntxq
argument_list|,
name|pi
operator|->
name|nrxq
argument_list|)
expr_stmt|;
name|cxgbe_sysctls
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
comment|/* Tell if_ioctl and if_init that the port is going away */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SET_DOOMED
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|0
argument_list|,
literal|"t4detach"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|vlan_c
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|pi
operator|->
name|vlan_c
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* Let detach proceed even if these fail. */
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|port_full_uninit
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|pi
operator|->
name|media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cxgbe_init_locked
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* releases adapter lock */
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|mtu
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fail
label|:
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|t4_update_fl_bufsize
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_MTU
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|pi
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_PROMISC
operator||
name|XGMAC_ALLMULTI
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|rc
operator|=
name|cxgbe_init_locked
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|cxgbe_uninit_locked
argument_list|(
name|pi
argument_list|)
expr_stmt|;
else|else
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* these two can be called with a mutex held :-( */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_MCADDRS
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|fail
goto|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso4 disabled due to -txcsum.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso6 disabled due to -txcsum6.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
comment|/* 		 * Note that we leave CSUM_TSO alone (it is always set).  The 		 * kernel takes both IFCAP_TSOx and CSUM_TSO into account before 		 * sending a TSO request our way, so it's sufficient to toggle 		 * IFCAP_TSOx only. 		 */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum first.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum6 first.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
name|rxq
operator|->
name|iq
operator|.
name|flags
operator||=
name|IQ_LRO_ENABLED
expr_stmt|;
else|else
name|rxq
operator|->
name|iq
operator|.
name|flags
operator|&=
operator|~
name|IQ_LRO_ENABLED
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|mask
operator|&
name|IFCAP_TOE
condition|)
block|{
name|int
name|enable
init|=
operator|(
name|ifp
operator|->
name|if_capenable
operator|^
name|mask
operator|)
operator|&
name|IFCAP_TOE
decl_stmt|;
name|rc
operator|=
name|toe_capability
argument_list|(
name|pi
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|mask
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_VLANEX
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* Need to find out how to disable auto-mtu-inflation */
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
ifdef|#
directive|ifdef
name|VLAN_CAPABILITIES
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|pi
operator|->
name|media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|txq
index|[
name|pi
operator|->
name|first_txq
index|]
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
operator|==
literal|0
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
name|txq
operator|+=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|pi
operator|->
name|ntxq
operator|)
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|br
expr_stmt|;
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
comment|/* 		 * It is possible that t4_eth_tx finishes up and releases the 		 * lock between the TRYLOCK above and the drbr_enqueue here.  We 		 * need to make sure that this mbuf doesn't just sit there in 		 * the drbr. 		 */
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|callout_pending
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_DOOMED
operator|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|,
literal|1
argument_list|,
name|t4_tx_callout
argument_list|,
name|eq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* 	 * txq->m is the mbuf that is held up due to a temporary shortage of 	 * resources and it should be put on the wire first.  Then what's in 	 * drbr and finally the mbuf that was just passed in to us. 	 * 	 * Return code should indicate the fate of the mbuf that was passed in 	 * this time. 	 */
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|drbr_needs_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
operator|||
name|txq
operator|->
name|m
condition|)
block|{
comment|/* Queued for transmission. */
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|txq
operator|->
name|m
condition|?
name|txq
operator|->
name|m
else|:
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Direct transmission. */
name|rc
operator|=
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|&&
name|txq
operator|->
name|m
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* held, will be transmitted soon (hopefully) */
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* queues do not exist if !PORT_INIT_DONE. */
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
block|{
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txq
operator|->
name|m
argument_list|)
expr_stmt|;
name|txq
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txq
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"%s unimplemented.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|cur
init|=
name|pi
operator|->
name|media
operator|.
name|ifm_cur
decl_stmt|;
name|int
name|speed
init|=
name|pi
operator|->
name|link_cfg
operator|.
name|speed
decl_stmt|;
name|int
name|data
init|=
operator|(
name|pi
operator|->
name|port_type
operator|<<
literal|8
operator|)
operator||
name|pi
operator|->
name|mod_type
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|ifm_data
operator|!=
name|data
condition|)
block|{
name|build_medialist
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|cur
operator|=
name|pi
operator|->
name|media
operator|.
name|ifm_cur
expr_stmt|;
block|}
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* active and current will differ iff current media is autoselect. */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|cur
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
return|return;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_10000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_100
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_10
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
else|else
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: link up but speed unknown (%u)"
operator|,
name|__func__
operator|,
name|speed
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_fatal_err
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"%s: encountered fatal error, adapter stopped.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bars
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|regs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map registers.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mmio_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|msix_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map MSI-X BAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|bar0
decl_stmt|;
comment|/* 	 * Read low 32b of bar0 indirectly via the hardware backdoor mechanism. 	 * Works from within PCI passthrough environments too, where 	 * rman_get_start() can return a different value.  We need to program 	 * the memory window decoders with the actual addresses that will be 	 * coming across the PCIe link. 	 */
name|bar0
operator|=
name|t4_hw_pci_read_cfg4
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bar0
operator|&=
operator|(
name|uint32_t
operator|)
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bar0
operator|+
name|MEMWIN0_BASE
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|MEMWIN0_APERTURE
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|bar0
operator|+
name|MEMWIN1_BASE
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|MEMWIN1_APERTURE
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|(
name|bar0
operator|+
name|MEMWIN2_BASE
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|MEMWIN2_APERTURE
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush */
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|n10g
parameter_list|,
name|int
name|n1g
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
name|iaq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|itype
decl_stmt|,
name|navail
decl_stmt|,
name|nrxq10g
decl_stmt|,
name|nrxq1g
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nofldrxq10g
init|=
literal|0
decl_stmt|,
name|nofldrxq1g
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|iaq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iaq
argument_list|)
argument_list|)
expr_stmt|;
name|iaq
operator|->
name|ntxq10g
operator|=
name|t4_ntxq10g
expr_stmt|;
name|iaq
operator|->
name|ntxq1g
operator|=
name|t4_ntxq1g
expr_stmt|;
name|iaq
operator|->
name|nrxq10g
operator|=
name|nrxq10g
operator|=
name|t4_nrxq10g
expr_stmt|;
name|iaq
operator|->
name|nrxq1g
operator|=
name|nrxq1g
operator|=
name|t4_nrxq1g
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iaq
operator|->
name|nofldtxq10g
operator|=
name|t4_nofldtxq10g
expr_stmt|;
name|iaq
operator|->
name|nofldtxq1g
operator|=
name|t4_nofldtxq1g
expr_stmt|;
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|nofldrxq10g
operator|=
name|t4_nofldrxq10g
expr_stmt|;
name|iaq
operator|->
name|nofldrxq1g
operator|=
name|nofldrxq1g
operator|=
name|t4_nofldrxq1g
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|itype
operator|=
name|INTR_MSIX
init|;
name|itype
condition|;
name|itype
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|itype
operator|&
name|t4_intr_types
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* not allowed */
if|if
condition|(
name|itype
operator|==
name|INTR_MSIX
condition|)
name|navail
operator|=
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
name|INTR_MSI
condition|)
name|navail
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
else|else
name|navail
operator|=
literal|1
expr_stmt|;
name|restart
label|:
if|if
condition|(
name|navail
operator|==
literal|0
condition|)
continue|continue;
name|iaq
operator|->
name|intr_type
operator|=
name|itype
expr_stmt|;
name|iaq
operator|->
name|intr_flags
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Best option: an interrupt vector for errors, one for the 		 * firmware event queue, and one each for each rxq (NIC as well 		 * as offload). 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
operator|(
name|nrxq10g
operator|+
name|nofldrxq10g
operator|)
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
operator|(
name|nrxq1g
operator|+
name|nofldrxq1g
operator|)
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
operator|&&
operator|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
operator|)
condition|)
block|{
name|iaq
operator|->
name|intr_flags
operator||=
name|INTR_DIRECT
expr_stmt|;
goto|goto
name|allocate
goto|;
block|}
comment|/* 		 * Second best option: an interrupt vector for errors, one for 		 * the firmware event queue, and one each for either NIC or 		 * offload rxq's. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
name|max
argument_list|(
name|nrxq10g
argument_list|,
name|nofldrxq10g
argument_list|)
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
name|max
argument_list|(
name|nrxq1g
argument_list|,
name|nofldrxq1g
argument_list|)
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
operator|&&
operator|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
operator|)
condition|)
goto|goto
name|allocate
goto|;
comment|/* 		 * Next best option: an interrupt vector for errors, one for the 		 * firmware event queue, and at least one per port.  At this 		 * point we know we'll have to downsize nrxq or nofldrxq to fit 		 * what's available to us. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|+
name|n1g
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
condition|)
block|{
name|int
name|leftover
init|=
name|navail
operator|-
name|iaq
operator|->
name|nirq
decl_stmt|;
if|if
condition|(
name|n10g
operator|>
literal|0
condition|)
block|{
name|int
name|target
init|=
name|max
argument_list|(
name|nrxq10g
argument_list|,
name|nofldrxq10g
argument_list|)
decl_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|target
operator|&&
name|leftover
operator|>=
name|n10g
condition|)
block|{
name|leftover
operator|-=
name|n10g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|iaq
operator|->
name|nrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nrxq10g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nofldrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|n1g
operator|>
literal|0
condition|)
block|{
name|int
name|target
init|=
name|max
argument_list|(
name|nrxq1g
argument_list|,
name|nofldrxq1g
argument_list|)
decl_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|target
operator|&&
name|leftover
operator|>=
name|n1g
condition|)
block|{
name|leftover
operator|-=
name|n1g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|iaq
operator|->
name|nrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nrxq1g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
name|iaq
operator|->
name|nofldrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nofldrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
condition|)
goto|goto
name|allocate
goto|;
block|}
comment|/* 		 * Least desirable option: one interrupt vector for everything. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|iaq
operator|->
name|nrxq10g
operator|=
name|iaq
operator|->
name|nrxq1g
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|iaq
operator|->
name|nofldrxq1g
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|allocate
label|:
name|navail
operator|=
name|iaq
operator|->
name|nirq
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|itype
operator|==
name|INTR_MSIX
condition|)
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
name|INTR_MSI
condition|)
name|rc
operator|=
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|navail
operator|==
name|iaq
operator|->
name|nirq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * Didn't get the number requested.  Use whatever number 			 * the kernel is willing to allocate (it's in navail). 			 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"fewer vectors than requested, "
literal|"type=%d, req=%d, rcvd=%d; will downshift req.\n"
argument_list|,
name|itype
argument_list|,
name|iaq
operator|->
name|nirq
argument_list|,
name|navail
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate vectors:%d, type=%d, req=%d, rcvd=%d\n"
argument_list|,
name|itype
argument_list|,
name|rc
argument_list|,
name|iaq
operator|->
name|nirq
argument_list|,
name|navail
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to find a usable interrupt type.  "
literal|"allowed=%d, msi-x=%d, msi=%d, intx=1"
argument_list|,
name|t4_intr_types
argument_list|,
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Install a compatible firmware (if required), establish contact with it (by  * saying hello), and reset the device.  If we end up as the master driver,  * partition adapter resources by providing a configuration file to the  * firmware.  */
end_comment

begin_function
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
init|=
name|NULL
decl_stmt|,
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|,
modifier|*
name|default_cfg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|enum
name|dev_state
name|state
decl_stmt|;
name|default_cfg
operator|=
name|firmware_get
argument_list|(
name|T4_CFGNAME
argument_list|)
expr_stmt|;
comment|/* Check firmware version and install a different one if necessary */
name|rc
operator|=
name|t4_check_fw_version
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|v
init|=
literal|0
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|T4_FWNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|fw
operator|->
name|data
decl_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
comment|/* 			 * The firmware module will not be used if it isn't the 			 * same major version as what the driver was compiled 			 * with. 			 */
if|if
condition|(
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|v
argument_list|)
operator|!=
name|FW_VERSION_MAJOR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Found firmware image but version %d "
literal|"can not be used with this driver (%d)\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|v
argument_list|)
argument_list|,
name|FW_VERSION_MAJOR
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|fw
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fw
operator|==
name|NULL
operator|&&
name|rc
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"No usable firmware. "
literal|"card has %d.%d.%d, driver compiled with %d.%d.%d"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|,
name|FW_VERSION_MICRO
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Always upgrade, even for minor/micro/build mismatches. 		 * Downgrade only for a major version mismatch or if 		 * force_firmware_install was specified. 		 */
if|if
condition|(
name|fw
operator|!=
name|NULL
operator|&&
operator|(
name|rc
operator|<
literal|0
operator|||
name|v
operator|>
name|sc
operator|->
name|params
operator|.
name|fw_vers
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"installing firmware %d.%d.%d.%d on card.\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_load_fw
argument_list|(
name|sc
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to install firmware: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* refresh */
operator|(
name|void
operator|)
name|t4_check_fw_version
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Contact firmware.  */
name|rc
operator|=
name|t4_fw_hello
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|MASTER_MAY
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to connect to the firmware: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|rc
operator|==
name|sc
operator|->
name|mbox
condition|)
name|sc
operator|->
name|flags
operator||=
name|MASTER_PF
expr_stmt|;
comment|/* Reset device */
name|rc
operator|=
operator|-
name|t4_fw_reset
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|F_PIORSTMODE
operator||
name|F_PIORST
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware reset failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ETIMEDOUT
operator|&&
name|rc
operator|!=
name|EIO
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Partition adapter resources as specified in the config file. */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|MASTER_PF
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|t4_cfg_file
argument_list|,
literal|"default"
argument_list|,
sizeof|sizeof
argument_list|(
name|t4_cfg_file
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|s
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"t4fw_cfg_%s"
argument_list|,
name|t4_cfg_file
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|firmware_get
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to locate %s module, "
literal|"will use default config file.\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|partition_resources
argument_list|(
name|sc
argument_list|,
name|cfg
condition|?
name|cfg
else|:
name|default_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
block|}
name|sc
operator|->
name|flags
operator||=
name|FW_OK
expr_stmt|;
name|done
label|:
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|cfg
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_cfg
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|default_cfg
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_PARAM_DEV
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_##param))
end_define

begin_define
define|#
directive|define
name|FW_PARAM_PFVF
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_PFVF) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_PFVF_##param))
end_define

begin_comment
comment|/*  * Upload configuration file to card's memory.  */
end_comment

begin_function
specifier|static
name|int
name|upload_config_file
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
name|fw
parameter_list|,
name|uint32_t
modifier|*
name|mt
parameter_list|,
name|uint32_t
modifier|*
name|ma
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|,
name|mtype
decl_stmt|,
name|maddr
decl_stmt|,
name|bar
decl_stmt|,
name|off
decl_stmt|,
name|win
decl_stmt|,
name|remaining
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|b
decl_stmt|;
comment|/* Figure out where the firmware wants us to upload it. */
name|param
operator|=
name|FW_PARAM_DEV
argument_list|(
name|CF
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* Firmwares without config file support will fail this way */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query config file location: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
operator|*
name|mt
operator|=
name|mtype
operator|=
name|G_FW_PARAMS_PARAM_Y
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|ma
operator|=
name|maddr
operator|=
name|G_FW_PARAMS_PARAM_Z
argument_list|(
name|val
argument_list|)
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|maddr
operator|&
literal|3
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot upload config file (type %u, addr %x).\n"
argument_list|,
name|mtype
argument_list|,
name|maddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* Translate mtype/maddr to an address suitable for the PCIe window */
name|val
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
name|val
operator|&=
name|F_EDRAM0_ENABLE
operator||
name|F_EDRAM1_ENABLE
operator||
name|F_EXT_MEM_ENABLE
expr_stmt|;
switch|switch
condition|(
name|mtype
condition|)
block|{
case|case
name|FW_MEMTYPE_CF_EDC0
case|:
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|F_EDRAM0_ENABLE
operator|)
condition|)
goto|goto
name|err
goto|;
name|bar
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|+=
name|G_EDRAM0_BASE
argument_list|(
name|bar
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|FW_MEMTYPE_CF_EDC1
case|:
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|F_EDRAM1_ENABLE
operator|)
condition|)
goto|goto
name|err
goto|;
name|bar
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|+=
name|G_EDRAM1_BASE
argument_list|(
name|bar
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|FW_MEMTYPE_CF_EXTMEM
case|:
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|F_EXT_MEM_ENABLE
operator|)
condition|)
goto|goto
name|err
goto|;
name|bar
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|+=
name|G_EXT_MEM_BASE
argument_list|(
name|bar
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
default|default:
name|err
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot upload config file (type %u, enabled %u).\n"
argument_list|,
name|mtype
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 	 * Position the PCIe window (we use memwin2) to the 16B aligned area 	 * just at/before the upload location. 	 */
name|win
operator|=
name|maddr
operator|&
operator|~
literal|0xf
expr_stmt|;
name|off
operator|=
name|maddr
operator|-
name|win
expr_stmt|;
comment|/* offset from the start of the window. */
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
literal|2
argument_list|)
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|fw
operator|->
name|datasize
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
name|FLASH_CFG_MAX_SIZE
operator|||
name|remaining
operator|>
name|MEMWIN2_APERTURE
operator|-
name|off
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot upload config file all at once "
literal|"(size %u, max %u, room %u).\n"
argument_list|,
name|remaining
argument_list|,
name|FLASH_CFG_MAX_SIZE
argument_list|,
name|MEMWIN2_APERTURE
operator|-
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
comment|/* 	 * XXX: sheer laziness.  We deliberately added 4 bytes of useless 	 * stuffing/comments at the end of the config file so it's ok to simply 	 * throw away the last remaining bytes when the config file is not an 	 * exact multiple of 4. 	 */
name|b
operator|=
name|fw
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|remaining
operator|>=
literal|4
condition|;
name|i
operator|+=
literal|4
operator|,
name|remaining
operator|-=
literal|4
control|)
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MEMWIN2_BASE
operator|+
name|off
operator|+
name|i
argument_list|,
operator|*
name|b
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Partition chip resources for use between various PFs, VFs, etc.  This is done  * by uploading the firmware configuration file to the adapter and instructing  * the firmware to process it.  */
end_comment

begin_function
specifier|static
name|int
name|partition_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|fw_caps_config_cmd
name|caps
decl_stmt|;
name|uint32_t
name|mtype
decl_stmt|,
name|maddr
decl_stmt|,
name|finicsum
decl_stmt|,
name|cfcsum
decl_stmt|;
name|rc
operator|=
name|cfg
condition|?
name|upload_config_file
argument_list|(
name|sc
argument_list|,
name|cfg
argument_list|,
operator|&
name|mtype
argument_list|,
operator|&
name|maddr
argument_list|)
else|:
name|ENOENT
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|mtype
operator|=
name|FW_MEMTYPE_CF_FLASH
expr_stmt|;
name|maddr
operator|=
name|t4_flash_cfg_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_CAPS_CONFIG_CMD_CFVALID
operator||
name|V_FW_CAPS_CONFIG_CMD_MEMTYPE_CF
argument_list|(
name|mtype
argument_list|)
operator||
name|V_FW_CAPS_CONFIG_CMD_MEMADDR64K_CF
argument_list|(
name|maddr
operator|>>
literal|16
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to pre-process config file: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|finicsum
operator|=
name|be32toh
argument_list|(
name|caps
operator|.
name|finicsum
argument_list|)
expr_stmt|;
name|cfcsum
operator|=
name|be32toh
argument_list|(
name|caps
operator|.
name|cfcsum
argument_list|)
expr_stmt|;
if|if
condition|(
name|finicsum
operator|!=
name|cfcsum
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING: config file checksum mismatch: %08x %08x\n"
argument_list|,
name|finicsum
argument_list|,
name|cfcsum
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cfcsum
operator|=
name|cfcsum
expr_stmt|;
define|#
directive|define
name|LIMIT_CAPS
parameter_list|(
name|x
parameter_list|)
value|do { \ 	caps.x&= htobe16(t4_##x##_allowed); \ 	sc->x = htobe16(caps.x); \ } while (0)
comment|/* 	 * Let the firmware know what features will (not) be used so it can tune 	 * things accordingly. 	 */
name|LIMIT_CAPS
argument_list|(
name|linkcaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|niccaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|toecaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|rdmacaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|iscsicaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|fcoecaps
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|LIMIT_CAPS
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to process config file: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve parameters that are needed (or nice to have) prior to calling  * t4_sge_init and t4_fw_initialize.  */
end_comment

begin_function
specifier|static
name|int
name|get_params__pre_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|param
index|[
literal|2
index|]
decl_stmt|,
name|val
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|fw_devlog_cmd
name|cmd
decl_stmt|;
name|struct
name|devlog_params
modifier|*
name|dlog
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|devlog
decl_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|PORTVEC
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|CCLK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query parameters (pre_init): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|params
operator|.
name|portvec
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|nports
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|val
index|[
literal|0
index|]
condition|)
block|{
name|sc
operator|->
name|params
operator|.
name|nports
operator|++
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|&=
name|val
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
comment|/* Read device log parameters. */
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_DEVLOG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get devlog parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dlog
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dlog
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* devlog isn't critical for device operation */
block|}
else|else
block|{
name|val
index|[
literal|0
index|]
operator|=
name|be32toh
argument_list|(
name|cmd
operator|.
name|memtype_devlog_memaddr16_devlog
argument_list|)
expr_stmt|;
name|dlog
operator|->
name|memtype
operator|=
name|G_FW_DEVLOG_CMD_MEMTYPE_DEVLOG
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dlog
operator|->
name|start
operator|=
name|G_FW_DEVLOG_CMD_MEMADDR16_DEVLOG
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|dlog
operator|->
name|size
operator|=
name|be32toh
argument_list|(
name|cmd
operator|.
name|memsize_devlog
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve various parameters that are of interest to the driver.  The device  * has been initialized by the firmware at this point.  */
end_comment

begin_function
specifier|static
name|int
name|get_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|param
index|[
literal|7
index|]
decl_stmt|,
name|val
index|[
literal|7
index|]
decl_stmt|;
name|struct
name|fw_caps_config_cmd
name|caps
decl_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|IQFLINT_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|EQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query parameters (post_init): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|sge
operator|.
name|iq_start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eq_start
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nftids
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
comment|/* get capabilites */
name|bzero
argument_list|(
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get card capabilities: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|caps
operator|.
name|toecaps
condition|)
block|{
comment|/* query offload-related parameters */
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|NTID
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|FLOWC_BUFFIFO_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query TOE parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|natids
operator|=
name|min
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|/
literal|2
argument_list|,
name|MAX_ATIDS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|stid_base
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nstids
operator|=
name|val
index|[
literal|2
index|]
operator|-
name|val
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|start
operator|=
name|val
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|size
operator|=
name|val
index|[
literal|4
index|]
operator|-
name|val
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ofldq_wr_cred
operator|=
name|val
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|offload
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|caps
operator|.
name|rdmacaps
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query RDMA parameters(1): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|size
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SQRQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SQRQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|OCQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|OCQ_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query RDMA parameters(2): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|qp
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|qp
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|cq
operator|.
name|start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|cq
operator|.
name|size
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|caps
operator|.
name|iscsicaps
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query iSCSI parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
comment|/* These are finalized by FW initialization, load their values now */
name|val
index|[
literal|0
index|]
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_TIMER_RESOLUTION
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|tre
operator|=
name|G_TIMERRESOLUTION
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|dack_re
operator|=
name|G_DELAYEDACKRESOLUTION
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t4_read_mtu_tbl
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|FW_PARAM_PFVF
end_undef

begin_undef
undef|#
directive|undef
name|FW_PARAM_DEV
end_undef

begin_function
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|adapter_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Chelsio %s %sNIC (rev %d), S/N:%s, E/C:%s"
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|id
argument_list|,
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|?
literal|"R"
else|:
literal|""
argument_list|,
name|p
operator|->
name|rev
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|sn
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|ec
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|ifmedia
modifier|*
name|media
init|=
operator|&
name|pi
operator|->
name|media
decl_stmt|;
name|int
name|data
decl_stmt|,
name|m
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
name|media
argument_list|)
expr_stmt|;
name|m
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
name|data
operator|=
operator|(
name|pi
operator|->
name|port_type
operator|<<
literal|8
operator|)
operator||
name|pi
operator|->
name|mod_type
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|port_type
condition|)
block|{
case|case
name|FW_PORT_TYPE_BT_XFI
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_BT_XAUI
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|FW_PORT_TYPE_BT_SGMII
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_1000_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_100_TX
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_CX4
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_SFP
case|:
case|case
name|FW_PORT_TYPE_FIBER_XFI
case|:
case|case
name|FW_PORT_TYPE_FIBER_XAUI
case|:
switch|switch
condition|(
name|pi
operator|->
name|mod_type
condition|)
block|{
case|case
name|FW_PORT_MOD_TYPE_LR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_SR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_LRM
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_TWINAX_PASSIVE
case|:
case|case
name|FW_PORT_MOD_TYPE_TWINAX_ACTIVE
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NONE
case|:
name|m
operator|&=
operator|~
name|IFM_FDX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NA
case|:
case|case
name|FW_PORT_MOD_TYPE_ER
case|:
default|default:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FW_PORT_TYPE_KX4
case|:
case|case
name|FW_PORT_TYPE_KX
case|:
case|case
name|FW_PORT_TYPE_KR
case|:
default|default:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_MAC_EXACT_CHUNK
value|7
end_define

begin_comment
comment|/*  * Program the port's XGMAC based on parameters in ifnet.  The caller also  * indicates which parameters should be programmed (the rest are left alone).  */
end_comment

begin_function
specifier|static
name|int
name|update_mac_settings
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|mtu
init|=
operator|-
literal|1
decl_stmt|,
name|promisc
init|=
operator|-
literal|1
decl_stmt|,
name|allmulti
init|=
operator|-
literal|1
decl_stmt|,
name|vlanex
init|=
operator|-
literal|1
decl_stmt|;
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|flags
argument_list|,
operator|(
literal|"%s: not told what to update."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_MTU
condition|)
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_PROMISC
condition|)
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_ALLMULTI
condition|)
name|allmulti
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_VLANEX
condition|)
name|vlanex
operator|=
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_set_rxmode
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|mtu
argument_list|,
name|promisc
argument_list|,
name|allmulti
argument_list|,
literal|1
argument_list|,
name|vlanex
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"set_rxmode (%x) failed: %d\n"
argument_list|,
name|flags
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_UCADDR
condition|)
block|{
name|uint8_t
name|ucaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ucaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ucaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_change_mac
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|pi
operator|->
name|xact_addr_filt
argument_list|,
name|ucaddr
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"change_mac failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
else|else
block|{
name|pi
operator|->
name|xact_addr_filt
operator|=
name|rc
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_MCADDRS
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|mcaddr
index|[
name|FW_MAC_EXACT_CHUNK
index|]
decl_stmt|;
name|int
name|del
init|=
literal|1
decl_stmt|;
name|uint64_t
name|hash
init|=
literal|0
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcaddr
index|[
name|i
operator|++
index|]
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FW_MAC_EXACT_CHUNK
condition|)
block|{
name|rc
operator|=
name|t4_alloc_mac_filt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|del
argument_list|,
name|i
argument_list|,
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to add mc address"
literal|" %02x:%02x:%02x:"
literal|"%02x:%02x:%02x rc=%d\n"
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|3
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|4
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|5
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mcfail
goto|;
block|}
name|del
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|t4_alloc_mac_filt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|del
argument_list|,
name|i
argument_list|,
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to add mc address"
literal|" %02x:%02x:%02x:"
literal|"%02x:%02x:%02x rc=%d\n"
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|3
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|4
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|5
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mcfail
goto|;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_set_addr_hash
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to set mc address hash: %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|mcfail
label|:
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
operator|&&
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4init"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Give up the adapter lock, port init code can sleep. */
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cxgbe_init_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|done
label|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
argument_list|,
operator|(
literal|"mismatch between open_device_map and if_drv_flags"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already running */
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|adapter_full_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
if|if
condition|(
operator|!
operator|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|port_full_init
argument_list|(
name|pi
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_ALL
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
operator|-
name|t4_link_start
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
operator|&
name|pi
operator|->
name|link_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"start_link failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* all ok */
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|,
name|cxgbe_tick
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_uninit_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
operator|&&
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4uninit"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|done
label|:
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable the VI so that all its data in either direction is discarded 	 * by the MPS.  Leave everything else (the queues, interrupts, and 1Hz 	 * tick) intact as the TP can deliver negative advice or data that it's 	 * holding in its RAM (for an offloaded connection) even after the VI is 	 * disabled. 	 */
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"disable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|t4_os_link_changed
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_ALLOC_IRQ
parameter_list|(
name|sc
parameter_list|,
name|irq
parameter_list|,
name|rid
parameter_list|,
name|handler
parameter_list|,
name|arg
parameter_list|,
name|name
parameter_list|)
value|do { \ 	rc = t4_alloc_irq(sc, irq, rid, handler, arg, name); \ 	if (rc != 0) \ 		goto done; \ } while (0)
end_define

begin_function
specifier|static
name|int
name|adapter_full_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|;
name|char
name|s
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|irq
modifier|*
name|irq
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
endif|#
directive|endif
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: FULL_INIT_DONE already"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * queues that belong to the adapter (not any particular port). 	 */
name|rc
operator|=
name|t4_setup_adapter_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|=
name|taskqueue_create
argument_list|(
literal|"t4 taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate task queue %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s tq%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup interrupts. 	 */
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
index|[
literal|0
index|]
expr_stmt|;
name|rid
operator|=
name|sc
operator|->
name|intr_type
operator|==
name|INTR_INTX
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|INTR_DIRECT
operator|)
argument_list|,
operator|(
literal|"%s: single interrupt&& INTR_DIRECT?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_all
argument_list|,
name|sc
argument_list|,
literal|"all"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Multiple interrupts. */
name|KASSERT
argument_list|(
name|sc
operator|->
name|intr_count
operator|>=
name|T4_EXTRA_INTR
operator|+
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
literal|"%s: too few intr."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* The first one is always error intr */
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_err
argument_list|,
name|sc
argument_list|,
literal|"err"
argument_list|)
expr_stmt|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
comment|/* The second one is always the firmware event queue */
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_evt
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
argument_list|,
literal|"evt"
argument_list|)
expr_stmt|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
comment|/* 		 * Note that if INTR_DIRECT is not set then either the NIC rx 		 * queues or (exclusive or) the TOE rx queueus will be taking 		 * direct interrupts. 		 * 		 * There is no need to check for is_offload(sc) as nofldrxq 		 * will be 0 if offload is disabled. 		 */
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|p
argument_list|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
comment|/* 			 * Skip over the NIC queues if they aren't taking direct 			 * interrupts. 			 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|INTR_DIRECT
operator|)
operator|&&
name|pi
operator|->
name|nofldrxq
operator|>
name|pi
operator|->
name|nrxq
condition|)
goto|goto
name|ofld_queues
goto|;
endif|#
directive|endif
name|rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|rxq
index|[
name|pi
operator|->
name|first_rxq
index|]
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|pi
operator|->
name|nrxq
condition|;
name|q
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d.%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr
argument_list|,
name|rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
comment|/* 			 * Skip over the offload queues if they aren't taking 			 * direct interrupts. 			 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|INTR_DIRECT
operator|)
condition|)
continue|continue;
name|ofld_queues
label|:
name|ofld_rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
index|[
name|pi
operator|->
name|first_ofld_rxq
index|]
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|pi
operator|->
name|nofldrxq
condition|;
name|q
operator|++
operator|,
name|ofld_rxq
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d,%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr
argument_list|,
name|ofld_rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|t4_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FULL_INIT_DONE
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|adapter_full_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|T4_ALLOC_IRQ
end_undef

begin_function
specifier|static
name|int
name|adapter_full_uninit
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_teardown_adapter_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
name|t4_free_irq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
operator|&&
name|sc
operator|->
name|tq
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FULL_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|port_full_init
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|uint16_t
modifier|*
name|rss
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: PORT_INIT_DONE already"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|pi
operator|->
name|flags
operator||=
name|PORT_SYSCTL_CTX
expr_stmt|;
comment|/* 	 * Allocate tx/rx/fl queues for this port. 	 */
name|rc
operator|=
name|t4_setup_port_queues
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * Setup RSS for this port. 	 */
name|rss
operator|=
name|malloc
argument_list|(
name|pi
operator|->
name|nrxq
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rss
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|rss
index|[
name|i
index|]
operator|=
name|rxq
operator|->
name|iq
operator|.
name|abs_id
expr_stmt|;
block|}
name|rc
operator|=
operator|-
name|t4_config_rss_range
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|rss_size
argument_list|,
name|rss
argument_list|,
name|pi
operator|->
name|nrxq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rss
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"rss_config failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pi
operator|->
name|flags
operator||=
name|PORT_INIT_DONE
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|port_full_uninit
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
specifier|static
name|int
name|port_full_uninit
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
block|{
comment|/* Need to quiesce queues.  XXX: ctrl queues? */
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|quiesce_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|txq
operator|->
name|eq
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|ofld_txq
argument_list|)
block|{
name|quiesce_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_txq
operator|->
name|eq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|quiesce_iq
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|iq
argument_list|)
expr_stmt|;
name|quiesce_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|quiesce_iq
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
argument_list|)
expr_stmt|;
name|quiesce_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|t4_teardown_port_queues
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|flags
operator|&=
operator|~
name|PORT_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_eq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|EQ_LOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|eq
operator|->
name|flags
operator||=
name|EQ_DOOMED
expr_stmt|;
comment|/* 	 * Wait for the response to a credit flush if one's 	 * pending. 	 */
while|while
condition|(
name|eq
operator|->
name|flags
operator|&
name|EQ_CRFLUSHED
condition|)
name|mtx_sleep
argument_list|(
name|eq
argument_list|,
operator|&
name|eq
operator|->
name|eq_lock
argument_list|,
literal|0
argument_list|,
literal|"crflush"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|)
expr_stmt|;
comment|/* XXX: iffy */
name|pause
argument_list|(
literal|"callout"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Still iffy */
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
index|[
name|eq
operator|->
name|tx_chan
index|]
argument_list|,
operator|&
name|eq
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_iq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* unused */
comment|/* Synchronize with the interrupt handler */
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|,
name|IQS_DISABLED
argument_list|)
condition|)
name|pause
argument_list|(
literal|"iqfree"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_fl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|flags
operator||=
name|FL_DOOMED
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|FL_STARVING
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: still starving"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_intr_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|irq
operator|->
name|rid
operator|=
name|rid
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate IRQ for rid %d, name %s.\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|&
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup interrupt for rid %d, name %s: %d\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
condition|)
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|)
block|{
if|if
condition|(
name|irq
operator|->
name|tag
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|rid
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|irq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|irq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|start
operator|)
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
operator|*
name|p
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_regdump
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|reg_ranges
index|[]
init|=
block|{
literal|0x1008
block|,
literal|0x1108
block|,
literal|0x1180
block|,
literal|0x11b4
block|,
literal|0x11fc
block|,
literal|0x123c
block|,
literal|0x1300
block|,
literal|0x173c
block|,
literal|0x1800
block|,
literal|0x18fc
block|,
literal|0x3000
block|,
literal|0x30d8
block|,
literal|0x30e0
block|,
literal|0x5924
block|,
literal|0x5960
block|,
literal|0x59d4
block|,
literal|0x5a00
block|,
literal|0x5af8
block|,
literal|0x6000
block|,
literal|0x6098
block|,
literal|0x6100
block|,
literal|0x6150
block|,
literal|0x6200
block|,
literal|0x6208
block|,
literal|0x6240
block|,
literal|0x6248
block|,
literal|0x6280
block|,
literal|0x6338
block|,
literal|0x6370
block|,
literal|0x638c
block|,
literal|0x6400
block|,
literal|0x643c
block|,
literal|0x6500
block|,
literal|0x6524
block|,
literal|0x6a00
block|,
literal|0x6a38
block|,
literal|0x6a60
block|,
literal|0x6a78
block|,
literal|0x6b00
block|,
literal|0x6b84
block|,
literal|0x6bf0
block|,
literal|0x6c84
block|,
literal|0x6cf0
block|,
literal|0x6d84
block|,
literal|0x6df0
block|,
literal|0x6e84
block|,
literal|0x6ef0
block|,
literal|0x6f84
block|,
literal|0x6ff0
block|,
literal|0x7084
block|,
literal|0x70f0
block|,
literal|0x7184
block|,
literal|0x71f0
block|,
literal|0x7284
block|,
literal|0x72f0
block|,
literal|0x7384
block|,
literal|0x73f0
block|,
literal|0x7450
block|,
literal|0x7500
block|,
literal|0x7530
block|,
literal|0x7600
block|,
literal|0x761c
block|,
literal|0x7680
block|,
literal|0x76cc
block|,
literal|0x7700
block|,
literal|0x7798
block|,
literal|0x77c0
block|,
literal|0x77fc
block|,
literal|0x7900
block|,
literal|0x79fc
block|,
literal|0x7b00
block|,
literal|0x7c38
block|,
literal|0x7d00
block|,
literal|0x7efc
block|,
literal|0x8dc0
block|,
literal|0x8e1c
block|,
literal|0x8e30
block|,
literal|0x8e78
block|,
literal|0x8ea0
block|,
literal|0x8f6c
block|,
literal|0x8fc0
block|,
literal|0x9074
block|,
literal|0x90fc
block|,
literal|0x90fc
block|,
literal|0x9400
block|,
literal|0x9458
block|,
literal|0x9600
block|,
literal|0x96bc
block|,
literal|0x9800
block|,
literal|0x9808
block|,
literal|0x9820
block|,
literal|0x983c
block|,
literal|0x9850
block|,
literal|0x9864
block|,
literal|0x9c00
block|,
literal|0x9c6c
block|,
literal|0x9c80
block|,
literal|0x9cec
block|,
literal|0x9d00
block|,
literal|0x9d6c
block|,
literal|0x9d80
block|,
literal|0x9dec
block|,
literal|0x9e00
block|,
literal|0x9e6c
block|,
literal|0x9e80
block|,
literal|0x9eec
block|,
literal|0x9f00
block|,
literal|0x9f6c
block|,
literal|0x9f80
block|,
literal|0x9fec
block|,
literal|0xd004
block|,
literal|0xd03c
block|,
literal|0xdfc0
block|,
literal|0xdfe0
block|,
literal|0xe000
block|,
literal|0xea7c
block|,
literal|0xf000
block|,
literal|0x11190
block|,
literal|0x19040
block|,
literal|0x1906c
block|,
literal|0x19078
block|,
literal|0x19080
block|,
literal|0x1908c
block|,
literal|0x19124
block|,
literal|0x19150
block|,
literal|0x191b0
block|,
literal|0x191d0
block|,
literal|0x191e8
block|,
literal|0x19238
block|,
literal|0x1924c
block|,
literal|0x193f8
block|,
literal|0x19474
block|,
literal|0x19490
block|,
literal|0x194f8
block|,
literal|0x19800
block|,
literal|0x19f30
block|,
literal|0x1a000
block|,
literal|0x1a06c
block|,
literal|0x1a0b0
block|,
literal|0x1a120
block|,
literal|0x1a128
block|,
literal|0x1a138
block|,
literal|0x1a190
block|,
literal|0x1a1c4
block|,
literal|0x1a1fc
block|,
literal|0x1a1fc
block|,
literal|0x1e040
block|,
literal|0x1e04c
block|,
literal|0x1e284
block|,
literal|0x1e28c
block|,
literal|0x1e2c0
block|,
literal|0x1e2c0
block|,
literal|0x1e2e0
block|,
literal|0x1e2e0
block|,
literal|0x1e300
block|,
literal|0x1e384
block|,
literal|0x1e3c0
block|,
literal|0x1e3c8
block|,
literal|0x1e440
block|,
literal|0x1e44c
block|,
literal|0x1e684
block|,
literal|0x1e68c
block|,
literal|0x1e6c0
block|,
literal|0x1e6c0
block|,
literal|0x1e6e0
block|,
literal|0x1e6e0
block|,
literal|0x1e700
block|,
literal|0x1e784
block|,
literal|0x1e7c0
block|,
literal|0x1e7c8
block|,
literal|0x1e840
block|,
literal|0x1e84c
block|,
literal|0x1ea84
block|,
literal|0x1ea8c
block|,
literal|0x1eac0
block|,
literal|0x1eac0
block|,
literal|0x1eae0
block|,
literal|0x1eae0
block|,
literal|0x1eb00
block|,
literal|0x1eb84
block|,
literal|0x1ebc0
block|,
literal|0x1ebc8
block|,
literal|0x1ec40
block|,
literal|0x1ec4c
block|,
literal|0x1ee84
block|,
literal|0x1ee8c
block|,
literal|0x1eec0
block|,
literal|0x1eec0
block|,
literal|0x1eee0
block|,
literal|0x1eee0
block|,
literal|0x1ef00
block|,
literal|0x1ef84
block|,
literal|0x1efc0
block|,
literal|0x1efc8
block|,
literal|0x1f040
block|,
literal|0x1f04c
block|,
literal|0x1f284
block|,
literal|0x1f28c
block|,
literal|0x1f2c0
block|,
literal|0x1f2c0
block|,
literal|0x1f2e0
block|,
literal|0x1f2e0
block|,
literal|0x1f300
block|,
literal|0x1f384
block|,
literal|0x1f3c0
block|,
literal|0x1f3c8
block|,
literal|0x1f440
block|,
literal|0x1f44c
block|,
literal|0x1f684
block|,
literal|0x1f68c
block|,
literal|0x1f6c0
block|,
literal|0x1f6c0
block|,
literal|0x1f6e0
block|,
literal|0x1f6e0
block|,
literal|0x1f700
block|,
literal|0x1f784
block|,
literal|0x1f7c0
block|,
literal|0x1f7c8
block|,
literal|0x1f840
block|,
literal|0x1f84c
block|,
literal|0x1fa84
block|,
literal|0x1fa8c
block|,
literal|0x1fac0
block|,
literal|0x1fac0
block|,
literal|0x1fae0
block|,
literal|0x1fae0
block|,
literal|0x1fb00
block|,
literal|0x1fb84
block|,
literal|0x1fbc0
block|,
literal|0x1fbc8
block|,
literal|0x1fc40
block|,
literal|0x1fc4c
block|,
literal|0x1fe84
block|,
literal|0x1fe8c
block|,
literal|0x1fec0
block|,
literal|0x1fec0
block|,
literal|0x1fee0
block|,
literal|0x1fee0
block|,
literal|0x1ff00
block|,
literal|0x1ff84
block|,
literal|0x1ffc0
block|,
literal|0x1ffc8
block|,
literal|0x20000
block|,
literal|0x2002c
block|,
literal|0x20100
block|,
literal|0x2013c
block|,
literal|0x20190
block|,
literal|0x201c8
block|,
literal|0x20200
block|,
literal|0x20318
block|,
literal|0x20400
block|,
literal|0x20528
block|,
literal|0x20540
block|,
literal|0x20614
block|,
literal|0x21000
block|,
literal|0x21040
block|,
literal|0x2104c
block|,
literal|0x21060
block|,
literal|0x210c0
block|,
literal|0x210ec
block|,
literal|0x21200
block|,
literal|0x21268
block|,
literal|0x21270
block|,
literal|0x21284
block|,
literal|0x212fc
block|,
literal|0x21388
block|,
literal|0x21400
block|,
literal|0x21404
block|,
literal|0x21500
block|,
literal|0x21518
block|,
literal|0x2152c
block|,
literal|0x2153c
block|,
literal|0x21550
block|,
literal|0x21554
block|,
literal|0x21600
block|,
literal|0x21600
block|,
literal|0x21608
block|,
literal|0x21628
block|,
literal|0x21630
block|,
literal|0x2163c
block|,
literal|0x21700
block|,
literal|0x2171c
block|,
literal|0x21780
block|,
literal|0x2178c
block|,
literal|0x21800
block|,
literal|0x21c38
block|,
literal|0x21c80
block|,
literal|0x21d7c
block|,
literal|0x21e00
block|,
literal|0x21e04
block|,
literal|0x22000
block|,
literal|0x2202c
block|,
literal|0x22100
block|,
literal|0x2213c
block|,
literal|0x22190
block|,
literal|0x221c8
block|,
literal|0x22200
block|,
literal|0x22318
block|,
literal|0x22400
block|,
literal|0x22528
block|,
literal|0x22540
block|,
literal|0x22614
block|,
literal|0x23000
block|,
literal|0x23040
block|,
literal|0x2304c
block|,
literal|0x23060
block|,
literal|0x230c0
block|,
literal|0x230ec
block|,
literal|0x23200
block|,
literal|0x23268
block|,
literal|0x23270
block|,
literal|0x23284
block|,
literal|0x232fc
block|,
literal|0x23388
block|,
literal|0x23400
block|,
literal|0x23404
block|,
literal|0x23500
block|,
literal|0x23518
block|,
literal|0x2352c
block|,
literal|0x2353c
block|,
literal|0x23550
block|,
literal|0x23554
block|,
literal|0x23600
block|,
literal|0x23600
block|,
literal|0x23608
block|,
literal|0x23628
block|,
literal|0x23630
block|,
literal|0x2363c
block|,
literal|0x23700
block|,
literal|0x2371c
block|,
literal|0x23780
block|,
literal|0x2378c
block|,
literal|0x23800
block|,
literal|0x23c38
block|,
literal|0x23c80
block|,
literal|0x23d7c
block|,
literal|0x23e00
block|,
literal|0x23e04
block|,
literal|0x24000
block|,
literal|0x2402c
block|,
literal|0x24100
block|,
literal|0x2413c
block|,
literal|0x24190
block|,
literal|0x241c8
block|,
literal|0x24200
block|,
literal|0x24318
block|,
literal|0x24400
block|,
literal|0x24528
block|,
literal|0x24540
block|,
literal|0x24614
block|,
literal|0x25000
block|,
literal|0x25040
block|,
literal|0x2504c
block|,
literal|0x25060
block|,
literal|0x250c0
block|,
literal|0x250ec
block|,
literal|0x25200
block|,
literal|0x25268
block|,
literal|0x25270
block|,
literal|0x25284
block|,
literal|0x252fc
block|,
literal|0x25388
block|,
literal|0x25400
block|,
literal|0x25404
block|,
literal|0x25500
block|,
literal|0x25518
block|,
literal|0x2552c
block|,
literal|0x2553c
block|,
literal|0x25550
block|,
literal|0x25554
block|,
literal|0x25600
block|,
literal|0x25600
block|,
literal|0x25608
block|,
literal|0x25628
block|,
literal|0x25630
block|,
literal|0x2563c
block|,
literal|0x25700
block|,
literal|0x2571c
block|,
literal|0x25780
block|,
literal|0x2578c
block|,
literal|0x25800
block|,
literal|0x25c38
block|,
literal|0x25c80
block|,
literal|0x25d7c
block|,
literal|0x25e00
block|,
literal|0x25e04
block|,
literal|0x26000
block|,
literal|0x2602c
block|,
literal|0x26100
block|,
literal|0x2613c
block|,
literal|0x26190
block|,
literal|0x261c8
block|,
literal|0x26200
block|,
literal|0x26318
block|,
literal|0x26400
block|,
literal|0x26528
block|,
literal|0x26540
block|,
literal|0x26614
block|,
literal|0x27000
block|,
literal|0x27040
block|,
literal|0x2704c
block|,
literal|0x27060
block|,
literal|0x270c0
block|,
literal|0x270ec
block|,
literal|0x27200
block|,
literal|0x27268
block|,
literal|0x27270
block|,
literal|0x27284
block|,
literal|0x272fc
block|,
literal|0x27388
block|,
literal|0x27400
block|,
literal|0x27404
block|,
literal|0x27500
block|,
literal|0x27518
block|,
literal|0x2752c
block|,
literal|0x2753c
block|,
literal|0x27550
block|,
literal|0x27554
block|,
literal|0x27600
block|,
literal|0x27600
block|,
literal|0x27608
block|,
literal|0x27628
block|,
literal|0x27630
block|,
literal|0x2763c
block|,
literal|0x27700
block|,
literal|0x2771c
block|,
literal|0x27780
block|,
literal|0x2778c
block|,
literal|0x27800
block|,
literal|0x27c38
block|,
literal|0x27c80
block|,
literal|0x27d7c
block|,
literal|0x27e00
block|,
literal|0x27e04
block|}
decl_stmt|;
name|regs
operator|->
name|version
operator|=
literal|4
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_ranges
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|reg_ranges
index|[
name|i
index|]
argument_list|,
name|reg_ranges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|drops
decl_stmt|;
name|struct
name|port_stats
modifier|*
name|s
init|=
operator|&
name|pi
operator|->
name|stats
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return;
comment|/* without scheduling another callout */
block|}
name|t4_get_port_stats
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|s
operator|->
name|tx_frames
operator|-
name|s
operator|->
name|tx_pause
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|=
name|s
operator|->
name|rx_frames
operator|-
name|s
operator|->
name|rx_pause
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|s
operator|->
name|tx_octets
operator|-
name|s
operator|->
name|tx_pause
operator|*
literal|64
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|s
operator|->
name|rx_octets
operator|-
name|s
operator|->
name|rx_pause
operator|*
literal|64
expr_stmt|;
name|ifp
operator|->
name|if_omcasts
operator|=
name|s
operator|->
name|tx_mcast_frames
operator|-
name|s
operator|->
name|tx_pause
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|s
operator|->
name|rx_mcast_frames
operator|-
name|s
operator|->
name|rx_pause
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|=
name|s
operator|->
name|rx_ovflow0
operator|+
name|s
operator|->
name|rx_ovflow1
operator|+
name|s
operator|->
name|rx_ovflow2
operator|+
name|s
operator|->
name|rx_ovflow3
expr_stmt|;
name|drops
operator|=
name|s
operator|->
name|tx_drop
expr_stmt|;
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
name|drops
operator|+=
name|txq
operator|->
name|br
operator|->
name|br_drops
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drops
operator|=
name|drops
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|=
name|s
operator|->
name|tx_error_frames
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|=
name|s
operator|->
name|rx_jabber
operator|+
name|s
operator|->
name|rx_runt
operator|+
name|s
operator|->
name|rx_too_long
operator|+
name|s
operator|->
name|rx_fcs_err
operator|+
name|s
operator|->
name|rx_len_err
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_vlan_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|vid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|vlan
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|ifp
condition|)
return|return;
name|vlan
operator|=
name|VLAN_DEVAT
argument_list|(
name|ifp
argument_list|,
name|vid
argument_list|)
expr_stmt|;
name|VLAN_SETCOOKIE
argument_list|(
name|vlan
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: opcode 0x%02x on iq %p with payload %p"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: opcode 0x%02x on iq %p with payload %p"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_cpl_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|opcode
parameter_list|,
name|cpl_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|opcode
operator|>=
name|ARRAY_SIZE
argument_list|(
name|sc
operator|->
name|cpl_handler
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|cpl_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|cpl_handler
index|[
name|opcode
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
name|ctrl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: async notification on iq %p (ctrl %p)"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: async notification on iq %p (ctrl %p)"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_an_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|an_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|an_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_handler
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|,
modifier|*
name|c0
decl_stmt|;
specifier|static
name|char
modifier|*
name|caps
index|[]
init|=
block|{
literal|"\20\1PPP\2QFC\3DCBX"
block|,
comment|/* caps[0] linkcaps */
literal|"\20\1NIC\2VM\3IDS\4UM\5UM_ISGL"
block|,
comment|/* caps[1] niccaps */
literal|"\20\1TOE"
block|,
comment|/* caps[2] toecaps */
literal|"\20\1RDDP\2RDMAC"
block|,
comment|/* caps[3] rdmacaps */
literal|"\20\1INITIATOR_PDU\2TARGET_PDU"
comment|/* caps[4] iscsicaps */
literal|"\3INITIATOR_CNXOFLD\4TARGET_CNXOFLD"
literal|"\5INITIATOR_SSNOFLD\6TARGET_SSNOFLD"
block|,
literal|"\20\1INITIATOR\2TARGET\3CTRL_OFLD"
comment|/* caps[5] fcoecaps */
block|}
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.t4nex.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|c0
operator|=
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nports"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
literal|0
argument_list|,
literal|"# of ports"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_revision"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|rev
argument_list|,
literal|0
argument_list|,
literal|"chip hardware revision"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cf"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|t4_cfg_file
argument_list|,
literal|0
argument_list|,
literal|"configuration file"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cfcsum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|cfcsum
argument_list|,
literal|0
argument_list|,
literal|"config file checksum"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"linkcaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|linkcaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available link capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"niccaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|niccaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available NIC capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"toecaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|toecaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available TCP offload capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdmacaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|rdmacaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available RDMA capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"iscsicaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|iscsicaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available iSCSI capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fcoecaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|5
index|]
argument_list|,
name|sc
operator|->
name|fcoecaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available FCoE capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"core_clock"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
argument_list|,
literal|0
argument_list|,
literal|"core clock frequency (in KHz)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_timers"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|timer_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|timer_val
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff timer values (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pkt_counts"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|counter_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|counter_val
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff packet counter values"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SBUF_DRAIN
comment|/* 	 * dev.t4nex.X.misc.  Marked CTLFLAG_SKIP to avoid information overload. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|c0
argument_list|,
name|OID_AUTO
argument_list|,
literal|"misc"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_SKIP
argument_list|,
name|NULL
argument_list|,
literal|"logs and miscellaneous information"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cctrl"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cctrl
argument_list|,
literal|"A"
argument_list|,
literal|"congestion control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpl_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cpl_stats
argument_list|,
literal|"A"
argument_list|,
literal|"CPL statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_ddp_stats
argument_list|,
literal|"A"
argument_list|,
literal|"DDP statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"devlog"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_devlog
argument_list|,
literal|"A"
argument_list|,
literal|"firmware's device log"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fcoe_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_fcoe_stats
argument_list|,
literal|"A"
argument_list|,
literal|"FCoE statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_sched"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_sched
argument_list|,
literal|"A"
argument_list|,
literal|"hardware scheduler "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"l2t"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_l2t
argument_list|,
literal|"A"
argument_list|,
literal|"hardware L2 table"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lb_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_lb_stats
argument_list|,
literal|"A"
argument_list|,
literal|"loopback statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"meminfo"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_meminfo
argument_list|,
literal|"A"
argument_list|,
literal|"memory regions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"path_mtus"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_path_mtus
argument_list|,
literal|"A"
argument_list|,
literal|"path MTUs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pm_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_pm_stats
argument_list|,
literal|"A"
argument_list|,
literal|"PM statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdma_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_rdma_stats
argument_list|,
literal|"A"
argument_list|,
literal|"RDMA statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tcp_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tcp_stats
argument_list|,
literal|"A"
argument_list|,
literal|"TCP statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tids"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tids
argument_list|,
literal|"A"
argument_list|,
literal|"TID information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tp_err_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tp_err_stats
argument_list|,
literal|"A"
argument_list|,
literal|"TP error statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_rate"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tx_rate
argument_list|,
literal|"A"
argument_list|,
literal|"Tx rate"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * dev.t4nex.X.toe. 		 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|c0
argument_list|,
name|OID_AUTO
argument_list|,
literal|"toe"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"TOE parameters"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|sndbuf
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sndbuf"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|sndbuf
argument_list|,
literal|0
argument_list|,
literal|"max hardware send buffer size"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|ddp
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|ddp
argument_list|,
literal|0
argument_list|,
literal|"DDP allowed"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|indsz
operator|=
name|M_INDICATESIZE
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"indsz"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|indsz
argument_list|,
literal|0
argument_list|,
literal|"DDP max indicate size allowed"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|ddp_thres
operator|=
literal|3
operator|*
literal|4096
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp_thres"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|ddp_thres
argument_list|,
literal|0
argument_list|,
literal|"DDP threshold"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ntxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|ntxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first tx queue"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nofldrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nofldrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nofldtxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nofldtxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_ofld_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_ofld_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first TOE rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_ofld_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_ofld_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first TOE tx queue"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_tmr_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_tmr_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff timer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pktc_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_pktc_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff packet counter index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_rxq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_rxq
argument_list|,
literal|"I"
argument_list|,
literal|"rx queue size"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_txq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_txq
argument_list|,
literal|"I"
argument_list|,
literal|"tx queue size"
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X.stats. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"port statistics"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
define|#
directive|define
name|SYSCTL_ADD_T4_REG64
parameter_list|(
name|pi
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|,
name|reg
parameter_list|)
define|\
value|SYSCTL_ADD_OID(ctx, children, OID_AUTO, name, \ 	    CTLTYPE_U64 | CTLFLAG_RD, pi->adapter, reg, \ 	    sysctl_handle_t4_reg64, "QU", desc)
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_error_frames"
argument_list|,
literal|"# of error frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_64"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1024_1518"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1519_max"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_drop"
argument_list|,
literal|"# of dropped tx frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_DROP_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_pause"
argument_list|,
literal|"# of pause frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_too_long"
argument_list|,
literal|"# of frames exceeding MTU"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_jabber"
argument_list|,
literal|"# of jabber frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_fcs_err"
argument_list|,
literal|"# of frames received with bad FCS"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_len_err"
argument_list|,
literal|"# of frames received with length error"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LEN_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_symbol_err"
argument_list|,
literal|"symbol errors"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_SYM_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_runt"
argument_list|,
literal|"# of short frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LESS_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_64"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1024_1518"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1519_max"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_pause"
argument_list|,
literal|"# of pause frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_REG64
define|#
directive|define
name|SYSCTL_ADD_T4_PORTSTAT
parameter_list|(
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|SYSCTL_ADD_UQUAD(ctx, children, OID_AUTO, #name, CTLFLAG_RD, \&pi->stats.name, desc)
comment|/* We get these from port_stats and they may be stale by upto 1s */
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow0
argument_list|,
literal|"# drops due to buffer-group 0 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow1
argument_list|,
literal|"# drops due to buffer-group 1 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow2
argument_list|,
literal|"# drops due to buffer-group 2 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow3
argument_list|,
literal|"# drops due to buffer-group 3 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc0
argument_list|,
literal|"# of buffer-group 0 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc1
argument_list|,
literal|"# of buffer-group 1 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc2
argument_list|,
literal|"# of buffer-group 2 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc3
argument_list|,
literal|"# of buffer-group 3 truncated packets"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_PORTSTAT
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|32
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg1
init|;
name|arg2
condition|;
name|arg2
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%d "
argument_list|,
operator|*
name|i
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_bitfield
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%b"
argument_list|,
operator|(
name|int
operator|)
name|arg2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|idx
operator|=
name|pi
operator|->
name|tmr_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|SGE_NTIMERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
name|v
operator|=
name|V_QINTR_TIMER_IDX
argument_list|(
name|idx
argument_list|)
operator||
name|V_QINTR_CNT_EN
argument_list|(
name|pi
operator|->
name|pktc_idx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
ifdef|#
directive|ifdef
name|atomic_store_rel_8
name|atomic_store_rel_8
argument_list|(
operator|&
name|rxq
operator|->
name|iq
operator|.
name|intr_params
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|#
directive|else
name|rxq
operator|->
name|iq
operator|.
name|intr_params
operator|=
name|v
expr_stmt|;
endif|#
directive|endif
block|}
name|pi
operator|->
name|tmr_idx
operator|=
name|idx
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|;
name|idx
operator|=
name|pi
operator|->
name|pktc_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
operator|-
literal|1
operator|||
name|idx
operator|>=
name|SGE_NCOUNTERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|pi
operator|->
name|pktc_idx
operator|=
name|idx
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|pi
operator|->
name|qsize_rxq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|qsize
operator|<
literal|128
operator|||
operator|(
name|qsize
operator|&
literal|7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|pi
operator|->
name|qsize_rxq
operator|=
name|qsize
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|pi
operator|->
name|qsize_txq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|qsize
operator|<
literal|128
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|pi
operator|->
name|flags
operator|&
name|PORT_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|pi
operator|->
name|qsize_txq
operator|=
name|qsize
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|reg
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SBUF_DRAIN
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_cctrl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|incr
index|[
name|NMTUS
index|]
index|[
name|NCCTRL_WIN
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|dec_fac
index|[]
init|=
block|{
literal|"0.5"
block|,
literal|"0.5625"
block|,
literal|"0.625"
block|,
literal|"0.6875"
block|,
literal|"0.75"
block|,
literal|"0.8125"
block|,
literal|"0.875"
block|,
literal|"0.9375"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_read_cong_tbl
argument_list|(
name|sc
argument_list|,
name|incr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|i
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%2d: %4u %4u %4u %4u %4u %4u %4u %4u\n"
argument_list|,
name|i
argument_list|,
name|incr
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|2
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|3
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|4
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|5
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|6
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|7
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%8u %4u %4u %4u %4u %4u %4u %4u %5u %s\n"
argument_list|,
name|incr
index|[
literal|8
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|9
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|10
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|11
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|12
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|13
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|14
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|15
index|]
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|a_wnd
index|[
name|i
index|]
argument_list|,
name|dec_fac
index|[
name|sc
operator|->
name|params
operator|.
name|b_wnd
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cpl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_cpl_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_cpl_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1  channel 2  "
literal|"channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"CPL requests:   %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|req
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"CPL responses:  %10u %10u %10u %10u"
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_ddp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_usm_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_usm_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Frames: %u\n"
argument_list|,
name|stats
operator|.
name|frames
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Octets: %ju\n"
argument_list|,
name|stats
operator|.
name|octets
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Drops:  %u"
argument_list|,
name|stats
operator|.
name|drops
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|devlog_level_strings
index|[]
init|=
block|{
index|[
name|FW_DEVLOG_LEVEL_EMERG
index|]
operator|=
literal|"EMERG"
block|,
index|[
name|FW_DEVLOG_LEVEL_CRIT
index|]
operator|=
literal|"CRIT"
block|,
index|[
name|FW_DEVLOG_LEVEL_ERR
index|]
operator|=
literal|"ERR"
block|,
index|[
name|FW_DEVLOG_LEVEL_NOTICE
index|]
operator|=
literal|"NOTICE"
block|,
index|[
name|FW_DEVLOG_LEVEL_INFO
index|]
operator|=
literal|"INFO"
block|,
index|[
name|FW_DEVLOG_LEVEL_DEBUG
index|]
operator|=
literal|"DEBUG"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|devlog_facility_strings
index|[]
init|=
block|{
index|[
name|FW_DEVLOG_FACILITY_CORE
index|]
operator|=
literal|"CORE"
block|,
index|[
name|FW_DEVLOG_FACILITY_SCHED
index|]
operator|=
literal|"SCHED"
block|,
index|[
name|FW_DEVLOG_FACILITY_TIMER
index|]
operator|=
literal|"TIMER"
block|,
index|[
name|FW_DEVLOG_FACILITY_RES
index|]
operator|=
literal|"RES"
block|,
index|[
name|FW_DEVLOG_FACILITY_HW
index|]
operator|=
literal|"HW"
block|,
index|[
name|FW_DEVLOG_FACILITY_FLR
index|]
operator|=
literal|"FLR"
block|,
index|[
name|FW_DEVLOG_FACILITY_DMAQ
index|]
operator|=
literal|"DMAQ"
block|,
index|[
name|FW_DEVLOG_FACILITY_PHY
index|]
operator|=
literal|"PHY"
block|,
index|[
name|FW_DEVLOG_FACILITY_MAC
index|]
operator|=
literal|"MAC"
block|,
index|[
name|FW_DEVLOG_FACILITY_PORT
index|]
operator|=
literal|"PORT"
block|,
index|[
name|FW_DEVLOG_FACILITY_VI
index|]
operator|=
literal|"VI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FILTER
index|]
operator|=
literal|"FILTER"
block|,
index|[
name|FW_DEVLOG_FACILITY_ACL
index|]
operator|=
literal|"ACL"
block|,
index|[
name|FW_DEVLOG_FACILITY_TM
index|]
operator|=
literal|"TM"
block|,
index|[
name|FW_DEVLOG_FACILITY_QFC
index|]
operator|=
literal|"QFC"
block|,
index|[
name|FW_DEVLOG_FACILITY_DCB
index|]
operator|=
literal|"DCB"
block|,
index|[
name|FW_DEVLOG_FACILITY_ETH
index|]
operator|=
literal|"ETH"
block|,
index|[
name|FW_DEVLOG_FACILITY_OFLD
index|]
operator|=
literal|"OFLD"
block|,
index|[
name|FW_DEVLOG_FACILITY_RI
index|]
operator|=
literal|"RI"
block|,
index|[
name|FW_DEVLOG_FACILITY_ISCSI
index|]
operator|=
literal|"ISCSI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FCOE
index|]
operator|=
literal|"FCOE"
block|,
index|[
name|FW_DEVLOG_FACILITY_FOISCSI
index|]
operator|=
literal|"FOISCSI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FOFCOE
index|]
operator|=
literal|"FOFCOE"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_devlog
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|devlog_params
modifier|*
name|dparams
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|devlog
decl_stmt|;
name|struct
name|fw_devlog_e
modifier|*
name|buf
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
decl_stmt|,
name|nentries
decl_stmt|,
name|first
init|=
literal|0
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint64_t
name|ftstamp
init|=
name|UINT64_MAX
decl_stmt|;
if|if
condition|(
name|dparams
operator|->
name|start
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|nentries
operator|=
name|dparams
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|fw_devlog_e
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|dparams
operator|->
name|size
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
operator|-
name|t4_mem_read
argument_list|(
name|sc
argument_list|,
name|dparams
operator|->
name|memtype
argument_list|,
name|dparams
operator|->
name|start
argument_list|,
name|dparams
operator|->
name|size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|==
literal|0
condition|)
break|break;
comment|/* end */
name|e
operator|->
name|timestamp
operator|=
name|be64toh
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|e
operator|->
name|seqno
operator|=
name|be32toh
argument_list|(
name|e
operator|->
name|seqno
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|e
operator|->
name|params
index|[
name|j
index|]
operator|=
name|be32toh
argument_list|(
name|e
operator|->
name|params
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|<
name|ftstamp
condition|)
block|{
name|ftstamp
operator|=
name|e
operator|->
name|timestamp
expr_stmt|;
name|first
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|first
index|]
operator|.
name|timestamp
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* nothing in the log */
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10s  %15s  %8s  %8s  %s\n"
argument_list|,
literal|"Seq#"
argument_list|,
literal|"Tstamp"
argument_list|,
literal|"Level"
argument_list|,
literal|"Facility"
argument_list|,
literal|"Message"
argument_list|)
expr_stmt|;
name|i
operator|=
name|first
expr_stmt|;
do|do
block|{
name|e
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|==
literal|0
condition|)
break|break;
comment|/* end */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10d  %15ju  %8s  %8s  "
argument_list|,
name|e
operator|->
name|seqno
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
operator|(
name|e
operator|->
name|level
operator|<
name|ARRAY_SIZE
argument_list|(
name|devlog_level_strings
argument_list|)
condition|?
name|devlog_level_strings
index|[
name|e
operator|->
name|level
index|]
else|:
literal|"UNKNOWN"
operator|)
argument_list|,
operator|(
name|e
operator|->
name|facility
operator|<
name|ARRAY_SIZE
argument_list|(
name|devlog_facility_strings
argument_list|)
condition|?
name|devlog_facility_strings
index|[
name|e
operator|->
name|facility
index|]
else|:
literal|"UNKNOWN"
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
name|e
operator|->
name|fmt
argument_list|,
name|e
operator|->
name|params
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|1
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|2
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|3
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|4
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|5
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|6
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|nentries
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|first
condition|)
do|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_fcoe_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_fcoe_stats
name|stats
index|[
literal|4
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|&
name|stats
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
operator|&
name|stats
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
operator|&
name|stats
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|,
operator|&
name|stats
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                   channel 0        channel 1        "
literal|"channel 2        channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"octetsDDP:  %16ju %16ju %16ju %16ju\n"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|octetsDDP
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|octetsDDP
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|octetsDDP
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|octetsDDP
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"framesDDP:  %16u %16u %16u %16u\n"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|framesDDP
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|framesDDP
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|framesDDP
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|framesDDP
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"framesDrop: %16u %16u %16u %16u"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|framesDrop
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|framesDrop
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|framesDrop
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|framesDrop
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_sched
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|map
decl_stmt|,
name|kbps
decl_stmt|,
name|ipg
decl_stmt|,
name|mode
decl_stmt|;
name|unsigned
name|int
name|pace_tab
index|[
name|NTX_SCHED
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|map
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|)
expr_stmt|;
name|mode
operator|=
name|G_TIMERMODE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_MOD_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|t4_read_pace_tbl
argument_list|(
name|sc
argument_list|,
name|pace_tab
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Scheduler  Mode   Channel  Rate (Kbps)   "
literal|"Class IPG (0.1 ns)   Flow IPG (us)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTX_SCHED
condition|;
operator|++
name|i
operator|,
name|map
operator|>>=
literal|2
control|)
block|{
name|t4_get_tx_sched
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|kbps
argument_list|,
operator|&
name|ipg
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n    %u      %-5s     %u     "
argument_list|,
name|i
argument_list|,
operator|(
name|mode
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"flow"
else|:
literal|"class"
argument_list|,
name|map
operator|&
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbps
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%9u     "
argument_list|,
name|kbps
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" disabled     "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipg
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%13u        "
argument_list|,
name|ipg
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"     disabled        "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pace_tab
index|[
name|i
index|]
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10u"
argument_list|,
name|pace_tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"  disabled"
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_lb_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|struct
name|lb_port_stats
name|s
index|[
literal|2
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|stat_name
index|[]
init|=
block|{
literal|"OctetsOK:"
block|,
literal|"FramesOK:"
block|,
literal|"BcastFrames:"
block|,
literal|"McastFrames:"
block|,
literal|"UcastFrames:"
block|,
literal|"ErrorFrames:"
block|,
literal|"Frames64:"
block|,
literal|"Frames65To127:"
block|,
literal|"Frames128To255:"
block|,
literal|"Frames256To511:"
block|,
literal|"Frames512To1023:"
block|,
literal|"Frames1024To1518:"
block|,
literal|"Frames1519ToMax:"
block|,
literal|"FramesDropped:"
block|,
literal|"BG0FramesDropped:"
block|,
literal|"BG1FramesDropped:"
block|,
literal|"BG2FramesDropped:"
block|,
literal|"BG3FramesDropped:"
block|,
literal|"BG0FramesTrunc:"
block|,
literal|"BG1FramesTrunc:"
block|,
literal|"BG2FramesTrunc:"
block|,
literal|"BG3FramesTrunc:"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|t4_get_lb_stats
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t4_get_lb_stats
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p0
operator|=
operator|&
name|s
index|[
literal|0
index|]
operator|.
name|octets
expr_stmt|;
name|p1
operator|=
operator|&
name|s
index|[
literal|1
index|]
operator|.
name|octets
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s                       Loopback %u"
literal|"           Loopback %u"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|stat_name
argument_list|)
condition|;
name|j
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-17s %20ju %20ju"
argument_list|,
name|stat_name
index|[
name|j
index|]
argument_list|,
operator|*
name|p0
operator|++
argument_list|,
operator|*
name|p1
operator|++
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|mem_desc
block|{
name|unsigned
name|int
name|base
decl_stmt|;
name|unsigned
name|int
name|limit
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|mem_desc_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|mem_desc
operator|*
operator|)
name|a
operator|)
operator|->
name|base
operator|-
operator|(
operator|(
specifier|const
expr|struct
name|mem_desc
operator|*
operator|)
name|b
operator|)
operator|->
name|base
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_region_show
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|size
operator|=
name|to
operator|-
name|from
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
comment|/* XXX: need humanize_number(3) in libkern for a more readable 'size' */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%-15s %#x-%#x [%u]\n"
argument_list|,
name|name
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_meminfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint32_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|memory
index|[]
init|=
block|{
literal|"EDC0:"
block|,
literal|"EDC1:"
block|,
literal|"MC:"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|region
index|[]
init|=
block|{
literal|"DBQ contexts:"
block|,
literal|"IMSG contexts:"
block|,
literal|"FLM cache:"
block|,
literal|"TCBs:"
block|,
literal|"Pstructs:"
block|,
literal|"Timers:"
block|,
literal|"Rx FL:"
block|,
literal|"Tx FL:"
block|,
literal|"Pstruct FL:"
block|,
literal|"Tx payload:"
block|,
literal|"Rx payload:"
block|,
literal|"LE hash:"
block|,
literal|"iSCSI region:"
block|,
literal|"TDDP region:"
block|,
literal|"TPT region:"
block|,
literal|"STAG region:"
block|,
literal|"RQ region:"
block|,
literal|"RQUDP region:"
block|,
literal|"PBL region:"
block|,
literal|"TXPBL region:"
block|,
literal|"ULPRX state:"
block|,
literal|"ULPTX state:"
block|,
literal|"On-chip queues:"
block|}
decl_stmt|;
name|struct
name|mem_desc
name|avail
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|mem_desc
name|mem
index|[
name|ARRAY_SIZE
argument_list|(
name|region
argument_list|)
operator|+
literal|3
index|]
decl_stmt|;
comment|/* up to 3 holes */
name|struct
name|mem_desc
modifier|*
name|md
init|=
name|mem
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mem
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|mem
index|[
name|i
index|]
operator|.
name|limit
operator|=
literal|0
expr_stmt|;
name|mem
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|i
expr_stmt|;
block|}
comment|/* Find and sort the populated memory ranges */
name|i
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|&
name|F_EDRAM0_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EDRAM0_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EDRAM1_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EDRAM1_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EXT_MEM_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EXT_MEM_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|2
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
comment|/* no memory available */
return|return
literal|0
return|;
name|qsort
argument_list|(
name|avail
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_desc
argument_list|)
argument_list|,
name|mem_desc_cmp
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_DBQ_CTXT_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_IMSG_CTXT_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_FLM_CACHE_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TCB_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TIMER_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_RX_FLST_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_TX_FLST_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_PS_FLST_BASE
argument_list|)
expr_stmt|;
comment|/* the next few have explicit upper bounds */
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|-
literal|1
operator|+
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|)
operator|*
name|G_PMTXMAXPAGE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|-
literal|1
operator|+
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|)
operator|*
name|G_PMRXMAXPAGE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_CONFIG
argument_list|)
operator|&
name|F_HASHEN
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_HASH_TID_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
operator|(
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|-
name|hi
operator|)
operator|*
literal|16
operator|+
name|md
operator|->
name|base
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|idx
operator|=
name|ARRAY_SIZE
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|/* hide it */
block|}
name|md
operator|++
expr_stmt|;
define|#
directive|define
name|ulp_region
parameter_list|(
name|reg
parameter_list|)
define|\
value|md->base = t4_read_reg(sc, A_ULP_ ## reg ## _LLIMIT);\ 	(md++)->limit = t4_read_reg(sc, A_ULP_ ## reg ## _ULIMIT)
name|ulp_region
argument_list|(
name|RX_ISCSI
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_TDDP
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|TX_TPT
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_STAG
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_RQ
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_RQUDP
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_PBL
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|TX_PBL
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ulp_region
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_CTX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|-
literal|1
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_TX_ERR_TABLE_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|-
literal|1
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
condition|)
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
operator|-
literal|1
expr_stmt|;
else|else
name|md
operator|->
name|idx
operator|=
name|ARRAY_SIZE
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|/* hide it */
name|md
operator|++
expr_stmt|;
comment|/* add any address-space holes, there can be up to 3 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|-
literal|1
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|avail
index|[
name|n
index|]
operator|.
name|limit
operator|<
name|avail
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|base
condition|)
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|avail
index|[
name|n
index|]
operator|.
name|limit
expr_stmt|;
if|if
condition|(
name|avail
index|[
name|n
index|]
operator|.
name|limit
condition|)
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|avail
index|[
name|n
index|]
operator|.
name|limit
expr_stmt|;
name|n
operator|=
name|md
operator|-
name|mem
expr_stmt|;
name|qsort
argument_list|(
name|mem
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_desc
argument_list|)
argument_list|,
name|mem_desc_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|lo
operator|=
literal|0
init|;
name|lo
operator|<
name|i
condition|;
name|lo
operator|++
control|)
name|mem_region_show
argument_list|(
name|sb
argument_list|,
name|memory
index|[
name|avail
index|[
name|lo
index|]
operator|.
name|idx
index|]
argument_list|,
name|avail
index|[
name|lo
index|]
operator|.
name|base
argument_list|,
name|avail
index|[
name|lo
index|]
operator|.
name|limit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mem
index|[
name|i
index|]
operator|.
name|idx
operator|>=
name|ARRAY_SIZE
argument_list|(
name|region
argument_list|)
condition|)
continue|continue;
comment|/* skip holes */
if|if
condition|(
operator|!
name|mem
index|[
name|i
index|]
operator|.
name|limit
condition|)
name|mem
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|i
operator|<
name|n
operator|-
literal|1
condition|?
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|base
operator|-
literal|1
else|:
operator|~
literal|0
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
name|region
index|[
name|mem
index|[
name|i
index|]
operator|.
name|idx
index|]
argument_list|,
name|mem
index|[
name|i
index|]
operator|.
name|base
argument_list|,
name|mem
index|[
name|i
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_SDRAM_BASE_ADDR
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_SDRAM_ADDR_SIZE
argument_list|)
operator|+
name|lo
operator|-
literal|1
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
literal|"uP RAM:"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_EXTMEM2_BASE_ADDR
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_EXTMEM2_ADDR_SIZE
argument_list|)
operator|+
name|lo
operator|-
literal|1
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
literal|"uP Extmem2:"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%u Rx pages of size %uKiB for %u channels\n"
argument_list|,
name|G_PMRXMAXPAGE
argument_list|(
name|lo
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|)
operator|>>
literal|10
argument_list|,
operator|(
name|lo
operator|&
name|F_PMRXNUMCHN
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u Tx pages of size %u%ciB for %u channels\n"
argument_list|,
name|G_PMTXMAXPAGE
argument_list|(
name|lo
argument_list|)
argument_list|,
name|hi
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|?
operator|(
name|hi
operator|>>
literal|20
operator|)
else|:
operator|(
name|hi
operator|>>
literal|10
operator|)
argument_list|,
name|hi
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|?
literal|'M'
else|:
literal|'K'
argument_list|,
literal|1
operator|<<
name|G_PMTXNUMCHN
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u p-structs\n"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_MAX_PSTRUCT
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_PG_RSV0
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nPort %d using %u pages out of %u allocated"
argument_list|,
name|i
argument_list|,
name|G_USED
argument_list|(
name|lo
argument_list|)
argument_list|,
name|G_ALLOC
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_PG_RSV4
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nLoopback %d using %u pages out of %u allocated"
argument_list|,
name|i
argument_list|,
name|G_USED
argument_list|(
name|lo
argument_list|)
argument_list|,
name|G_ALLOC
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_path_mtus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|uint16_t
name|mtus
index|[
name|NMTUS
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_read_mtu_tbl
argument_list|(
name|sc
argument_list|,
name|mtus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u"
argument_list|,
name|mtus
index|[
literal|0
index|]
argument_list|,
name|mtus
index|[
literal|1
index|]
argument_list|,
name|mtus
index|[
literal|2
index|]
argument_list|,
name|mtus
index|[
literal|3
index|]
argument_list|,
name|mtus
index|[
literal|4
index|]
argument_list|,
name|mtus
index|[
literal|5
index|]
argument_list|,
name|mtus
index|[
literal|6
index|]
argument_list|,
name|mtus
index|[
literal|7
index|]
argument_list|,
name|mtus
index|[
literal|8
index|]
argument_list|,
name|mtus
index|[
literal|9
index|]
argument_list|,
name|mtus
index|[
literal|10
index|]
argument_list|,
name|mtus
index|[
literal|11
index|]
argument_list|,
name|mtus
index|[
literal|12
index|]
argument_list|,
name|mtus
index|[
literal|13
index|]
argument_list|,
name|mtus
index|[
literal|14
index|]
argument_list|,
name|mtus
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_pm_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|tx_cnt
index|[
name|PM_NSTATS
index|]
decl_stmt|,
name|rx_cnt
index|[
name|PM_NSTATS
index|]
decl_stmt|;
name|uint64_t
name|tx_cyc
index|[
name|PM_NSTATS
index|]
decl_stmt|,
name|rx_cyc
index|[
name|PM_NSTATS
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|pm_stats
index|[]
init|=
block|{
literal|"Read:"
block|,
literal|"Write bypass:"
block|,
literal|"Write mem:"
block|,
literal|"Flush:"
block|,
literal|"FIFO wait:"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_pmtx_get_stats
argument_list|(
name|sc
argument_list|,
name|tx_cnt
argument_list|,
name|tx_cyc
argument_list|)
expr_stmt|;
name|t4_pmrx_get_stats
argument_list|(
name|sc
argument_list|,
name|rx_cnt
argument_list|,
name|rx_cyc
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                Tx count            Tx cycles    "
literal|"Rx count            Rx cycles"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PM_NSTATS
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju  %10u %20ju"
argument_list|,
name|pm_stats
index|[
name|i
index|]
argument_list|,
name|tx_cnt
index|[
name|i
index|]
argument_list|,
name|tx_cyc
index|[
name|i
index|]
argument_list|,
name|rx_cnt
index|[
name|i
index|]
argument_list|,
name|rx_cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_rdma_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_rdma_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_rdma_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NoRQEModDefferals: %u\n"
argument_list|,
name|stats
operator|.
name|rqe_dfr_mod
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NoRQEPktDefferals: %u"
argument_list|,
name|stats
operator|.
name|rqe_dfr_pkt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tcp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_tcp_stats
name|v4
decl_stmt|,
name|v6
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_tcp_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|v4
argument_list|,
operator|&
name|v6
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                                IP                 IPv6\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"OutRsts:      %20u %20u\n"
argument_list|,
name|v4
operator|.
name|tcpOutRsts
argument_list|,
name|v6
operator|.
name|tcpOutRsts
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"InSegs:       %20ju %20ju\n"
argument_list|,
name|v4
operator|.
name|tcpInSegs
argument_list|,
name|v6
operator|.
name|tcpInSegs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"OutSegs:      %20ju %20ju\n"
argument_list|,
name|v4
operator|.
name|tcpOutSegs
argument_list|,
name|v6
operator|.
name|tcpOutSegs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"RetransSegs:  %20ju %20ju"
argument_list|,
name|v4
operator|.
name|tcpRetransSegs
argument_list|,
name|v6
operator|.
name|tcpRetransSegs
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tids
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|natids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ATID range: 0-%u, in use: %u\n"
argument_list|,
name|t
operator|->
name|natids
operator|-
literal|1
argument_list|,
name|t
operator|->
name|atids_in_use
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|ntids
condition|)
block|{
if|if
condition|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_CONFIG
argument_list|)
operator|&
name|F_HASHEN
condition|)
block|{
name|uint32_t
name|b
init|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_SERVER_INDEX
argument_list|)
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: 0-%u, %u-%u"
argument_list|,
name|b
operator|-
literal|1
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: %u-%u"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: 0-%u"
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|", in use: %u\n"
argument_list|,
name|atomic_load_acq_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|nstids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"STID range: %u-%u, in use: %u\n"
argument_list|,
name|t
operator|->
name|stid_base
argument_list|,
name|t
operator|->
name|stid_base
operator|+
name|t
operator|->
name|nstids
operator|-
literal|1
argument_list|,
name|t
operator|->
name|stids_in_use
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|nftids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"FTID range: %u-%u\n"
argument_list|,
name|t
operator|->
name|ftid_base
argument_list|,
name|t
operator|->
name|ftid_base
operator|+
name|t
operator|->
name|nftids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"HW TID usage: %u IP users, %u IPv6 users"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_ACT_CNT_IPV4
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_ACT_CNT_IPV6
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tp_err_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_err_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_tp_get_err_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1  channel 2  "
literal|"channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"macInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|macInErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"hdrInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|hdrInErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcpInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tcpInErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcp6InErrs:     %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tcp6InErrs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlCongDrops:   %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tnlCongDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlTxDrops:     %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tnlTxDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldVlanDrops:  %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|ofldVlanDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldChanDrops:  %10u %10u %10u %10u\n\n"
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|ofldChanDrops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldNoNeigh:    %u\nofldCongDefer:  %u"
argument_list|,
name|stats
operator|.
name|ofldNoNeigh
argument_list|,
name|stats
operator|.
name|ofldCongDefer
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tx_rate
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u64
name|nrate
index|[
name|NCHAN
index|]
decl_stmt|,
name|orate
index|[
name|NCHAN
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_chan_txrate
argument_list|(
name|sc
argument_list|,
name|nrate
argument_list|,
name|orate
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"              channel 0   channel 1   channel 2   "
literal|"channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NIC B/s:     %10ju  %10ju  %10ju  %10ju\n"
argument_list|,
name|nrate
index|[
literal|0
index|]
argument_list|,
name|nrate
index|[
literal|1
index|]
argument_list|,
name|nrate
index|[
literal|2
index|]
argument_list|,
name|nrate
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Offload B/s: %10ju  %10ju  %10ju  %10ju"
argument_list|,
name|orate
index|[
literal|0
index|]
argument_list|,
name|orate
index|[
literal|1
index|]
argument_list|,
name|orate
index|[
literal|2
index|]
argument_list|,
name|orate
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|txq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|br
expr_stmt|;
name|m
operator|=
name|txq
operator|->
name|m
condition|?
name|txq
operator|->
name|m
else|:
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_tx_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|EQ_TRYLOCK
argument_list|(
name|eq
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|reschedule
goto|;
if|if
condition|(
name|eq
operator|->
name|flags
operator|&
name|EQ_STALLED
operator|&&
operator|!
name|can_resume_tx
argument_list|(
name|eq
argument_list|)
condition|)
block|{
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|reschedule
label|:
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
operator|(
name|eq
operator|->
name|flags
operator|&&
name|EQ_DOOMED
operator|)
argument_list|)
condition|)
name|callout_schedule
argument_list|(
operator|&
name|eq
operator|->
name|tx_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|EQ_LOCK_ASSERT_OWNED
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_DOOMED
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
operator|)
operator|==
name|EQ_ETH
condition|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|arg
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|txq
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sge_wrq
modifier|*
name|wrq
init|=
name|arg
decl_stmt|;
name|sc
operator|=
name|wrq
operator|->
name|adapter
expr_stmt|;
block|}
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
index|[
name|eq
operator|->
name|tx_chan
index|]
argument_list|,
operator|&
name|eq
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_tx_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
name|arg
decl_stmt|;
name|EQ_LOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
operator|)
operator|==
name|EQ_ETH
condition|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|arg
decl_stmt|;
name|txq_start
argument_list|(
name|txq
operator|->
name|ifp
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sge_wrq
modifier|*
name|wrq
init|=
name|arg
decl_stmt|;
name|t4_wrq_tx_locked
argument_list|(
name|wrq
operator|->
name|adapter
argument_list|,
name|wrq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fconf_to_mode
parameter_list|(
name|uint32_t
name|fconf
parameter_list|)
block|{
name|uint32_t
name|mode
decl_stmt|;
name|mode
operator|=
name|T4_FILTER_IPv4
operator||
name|T4_FILTER_IPv6
operator||
name|T4_FILTER_IP_SADDR
operator||
name|T4_FILTER_IP_DADDR
operator||
name|T4_FILTER_IP_SPORT
operator||
name|T4_FILTER_IP_DPORT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_FRAGMENTATION
condition|)
name|mode
operator||=
name|T4_FILTER_IP_FRAGMENT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_MPSHITTYPE
condition|)
name|mode
operator||=
name|T4_FILTER_MPS_HIT_TYPE
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_MACMATCH
condition|)
name|mode
operator||=
name|T4_FILTER_MAC_IDX
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_ETHERTYPE
condition|)
name|mode
operator||=
name|T4_FILTER_ETH_TYPE
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_PROTOCOL
condition|)
name|mode
operator||=
name|T4_FILTER_IP_PROTO
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_TOS
condition|)
name|mode
operator||=
name|T4_FILTER_IP_TOS
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_VLAN
condition|)
name|mode
operator||=
name|T4_FILTER_VLAN
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_VNIC_ID
condition|)
name|mode
operator||=
name|T4_FILTER_VNIC
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_PORT
condition|)
name|mode
operator||=
name|T4_FILTER_PORT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_FCOE
condition|)
name|mode
operator||=
name|T4_FILTER_FCoE
expr_stmt|;
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|mode_to_fconf
parameter_list|(
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|fconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_FRAGMENT
condition|)
name|fconf
operator||=
name|F_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MPS_HIT_TYPE
condition|)
name|fconf
operator||=
name|F_MPSHITTYPE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MAC_IDX
condition|)
name|fconf
operator||=
name|F_MACMATCH
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_ETH_TYPE
condition|)
name|fconf
operator||=
name|F_ETHERTYPE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_PROTO
condition|)
name|fconf
operator||=
name|F_PROTOCOL
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_TOS
condition|)
name|fconf
operator||=
name|F_TOS
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VLAN
condition|)
name|fconf
operator||=
name|F_VLAN
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VNIC
condition|)
name|fconf
operator||=
name|F_VNIC_ID
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_PORT
condition|)
name|fconf
operator||=
name|F_PORT
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_FCoE
condition|)
name|fconf
operator||=
name|F_FCOE
expr_stmt|;
return|return
operator|(
name|fconf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fspec_to_fconf
parameter_list|(
name|struct
name|t4_filter_specification
modifier|*
name|fs
parameter_list|)
block|{
name|uint32_t
name|fconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|frag
operator|||
name|fs
operator|->
name|mask
operator|.
name|frag
condition|)
name|fconf
operator||=
name|F_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|matchtype
operator|||
name|fs
operator|->
name|mask
operator|.
name|matchtype
condition|)
name|fconf
operator||=
name|F_MPSHITTYPE
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|macidx
operator|||
name|fs
operator|->
name|mask
operator|.
name|macidx
condition|)
name|fconf
operator||=
name|F_MACMATCH
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|ethtype
operator|||
name|fs
operator|->
name|mask
operator|.
name|ethtype
condition|)
name|fconf
operator||=
name|F_ETHERTYPE
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|proto
operator|||
name|fs
operator|->
name|mask
operator|.
name|proto
condition|)
name|fconf
operator||=
name|F_PROTOCOL
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|tos
operator|||
name|fs
operator|->
name|mask
operator|.
name|tos
condition|)
name|fconf
operator||=
name|F_TOS
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|vlan_vld
operator|||
name|fs
operator|->
name|mask
operator|.
name|vlan_vld
condition|)
name|fconf
operator||=
name|F_VLAN
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|vnic_vld
operator|||
name|fs
operator|->
name|mask
operator|.
name|vnic_vld
condition|)
name|fconf
operator||=
name|F_VNIC_ID
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|iport
operator|||
name|fs
operator|->
name|mask
operator|.
name|iport
condition|)
name|fconf
operator||=
name|F_PORT
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|fcoe
operator|||
name|fs
operator|->
name|mask
operator|.
name|fcoe
condition|)
name|fconf
operator||=
name|F_FCOE
expr_stmt|;
return|return
operator|(
name|fconf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|mode
parameter_list|)
block|{
name|uint32_t
name|fconf
decl_stmt|;
name|t4_read_indirect
argument_list|(
name|sc
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|fconf
argument_list|,
literal|1
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|filter_mode
operator|!=
name|fconf
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: cached filter mode out of sync %x %x.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|filter_mode
argument_list|,
name|fconf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|filter_mode
operator|=
name|fconf
expr_stmt|;
block|}
operator|*
name|mode
operator|=
name|fconf_to_mode
argument_list|(
name|sc
operator|->
name|filter_mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|fconf
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|fconf
operator|=
name|mode_to_fconf
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|sc
operator|->
name|offload_map
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
name|rc
operator|=
operator|-
name|t4_set_filter_mode
argument_list|(
name|sc
argument_list|,
name|fconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|sc
operator|->
name|filter_mode
operator|=
name|fconf
expr_stmt|;
else|#
directive|else
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
endif|#
directive|endif
name|done
label|:
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|get_filter_hits
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|fid
parameter_list|)
block|{
name|uint32_t
name|tcb_base
init|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TCB_BASE
argument_list|)
decl_stmt|;
name|uint64_t
name|hits
decl_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tcb_base
operator|+
operator|(
name|fid
operator|+
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|)
operator|*
name|TCB_SIZE
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hits
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|MEMWIN0_BASE
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
operator|(
name|be64toh
argument_list|(
name|hits
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nfilters
init|=
name|sc
operator|->
name|tids
operator|.
name|nftids
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
operator|||
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
operator|||
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
block|{
name|t
operator|->
name|idx
operator|=
literal|0xffffffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|t
operator|->
name|idx
init|;
name|i
operator|<
name|nfilters
condition|;
name|i
operator|++
operator|,
name|f
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|valid
condition|)
block|{
name|t
operator|->
name|idx
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|l2tidx
operator|=
name|f
operator|->
name|l2t
condition|?
name|f
operator|->
name|l2t
operator|->
name|idx
else|:
literal|0
expr_stmt|;
name|t
operator|->
name|smtidx
operator|=
name|f
operator|->
name|smtidx
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|hitcnts
condition|)
name|t
operator|->
name|hits
operator|=
name|get_filter_hits
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|hits
operator|=
name|UINT64_MAX
expr_stmt|;
name|t
operator|->
name|fs
operator|=
name|f
operator|->
name|fs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|t
operator|->
name|idx
operator|=
literal|0xffffffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|nfilters
decl_stmt|,
name|nports
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nfilters
operator|=
name|sc
operator|->
name|tids
operator|.
name|nftids
expr_stmt|;
name|nports
operator|=
name|sc
operator|->
name|params
operator|.
name|nports
expr_stmt|;
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Validate against the global filter mode */
if|if
condition|(
operator|(
name|sc
operator|->
name|filter_mode
operator||
name|fspec_to_fconf
argument_list|(
operator|&
name|t
operator|->
name|fs
argument_list|)
operator|)
operator|!=
name|sc
operator|->
name|filter_mode
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
operator|&&
name|t
operator|->
name|fs
operator|.
name|eport
operator|>=
name|nports
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
operator|>=
name|nports
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Can't specify an iq if not steering to it */
if|if
condition|(
operator|!
name|t
operator|->
name|fs
operator|.
name|dirsteer
operator|&&
name|t
operator|->
name|fs
operator|.
name|iq
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* IPv6 filter idx must be 4 aligned */
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|type
operator|==
literal|1
operator|&&
operator|(
operator|(
name|t
operator|->
name|idx
operator|&
literal|0x3
operator|)
operator|||
name|t
operator|->
name|idx
operator|+
literal|4
operator|>=
name|nfilters
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: no memory allocated but filters_in_use> 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filter_entry
argument_list|)
operator|*
name|nfilters
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|pending
operator|||
name|f
operator|->
name|valid
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|f
operator|->
name|locked
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|type
operator|==
literal|0
condition|)
break|break;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
name|f
operator|->
name|fs
operator|=
name|t
operator|->
name|fs
expr_stmt|;
return|return
name|set_filter_wr
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|nfilters
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|nfilters
operator|=
name|sc
operator|->
name|tids
operator|.
name|nftids
expr_stmt|;
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
operator|||
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
operator|||
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|pending
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|f
operator|->
name|locked
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|f
operator|->
name|valid
condition|)
block|{
name|t
operator|->
name|fs
operator|=
name|f
operator|->
name|fs
expr_stmt|;
comment|/* extra info for the caller */
return|return
name|del_filter_wr
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_filter
parameter_list|(
name|struct
name|filter_entry
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|l2t
condition|)
name|t4_l2t_release
argument_list|(
name|f
operator|->
name|l2t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|f
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|fidx
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|f
init|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|fidx
index|]
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_filter_wr
modifier|*
name|fwr
decl_stmt|;
name|unsigned
name|int
name|ftid
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|newdmac
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
condition|)
block|{
comment|/* This filter needs an L2T entry; allocate one. */
name|f
operator|->
name|l2t
operator|=
name|t4_l2t_alloc_switching
argument_list|(
name|sc
operator|->
name|l2t
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|l2t
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|t4_l2t_set_switching
argument_list|(
name|sc
argument_list|,
name|f
operator|->
name|l2t
argument_list|,
name|f
operator|->
name|fs
operator|.
name|vlan
argument_list|,
name|f
operator|->
name|fs
operator|.
name|eport
argument_list|,
name|f
operator|->
name|fs
operator|.
name|dmac
argument_list|)
condition|)
block|{
name|t4_l2t_release
argument_list|(
name|f
operator|->
name|l2t
argument_list|)
expr_stmt|;
name|f
operator|->
name|l2t
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|ftid
operator|=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|+
name|fidx
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fwr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|op_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FILTER_WR
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|len16_pkd
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|tid_to_iq
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_TID
argument_list|(
name|ftid
argument_list|)
operator||
name|V_FW_FILTER_WR_RQTYPE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|type
argument_list|)
operator||
name|V_FW_FILTER_WR_NOREPLY
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_FILTER_WR_IQ
argument_list|(
name|f
operator|->
name|fs
operator|.
name|iq
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|del_filter_to_l2tix
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_RPTTID
argument_list|(
name|f
operator|->
name|fs
operator|.
name|rpttid
argument_list|)
operator||
name|V_FW_FILTER_WR_DROP
argument_list|(
name|f
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_DROP
argument_list|)
operator||
name|V_FW_FILTER_WR_DIRSTEER
argument_list|(
name|f
operator|->
name|fs
operator|.
name|dirsteer
argument_list|)
operator||
name|V_FW_FILTER_WR_MASKHASH
argument_list|(
name|f
operator|->
name|fs
operator|.
name|maskhash
argument_list|)
operator||
name|V_FW_FILTER_WR_DIRSTEERHASH
argument_list|(
name|f
operator|->
name|fs
operator|.
name|dirsteerhash
argument_list|)
operator||
name|V_FW_FILTER_WR_LPBK
argument_list|(
name|f
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
argument_list|)
operator||
name|V_FW_FILTER_WR_DMAC
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newdmac
argument_list|)
operator||
name|V_FW_FILTER_WR_SMAC
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newsmac
argument_list|)
operator||
name|V_FW_FILTER_WR_INSVLAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_INSERT
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
argument_list|)
operator||
name|V_FW_FILTER_WR_RMVLAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REMOVE
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
argument_list|)
operator||
name|V_FW_FILTER_WR_HITCNTS
argument_list|(
name|f
operator|->
name|fs
operator|.
name|hitcnts
argument_list|)
operator||
name|V_FW_FILTER_WR_TXCHAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|eport
argument_list|)
operator||
name|V_FW_FILTER_WR_PRIO
argument_list|(
name|f
operator|->
name|fs
operator|.
name|prio
argument_list|)
operator||
name|V_FW_FILTER_WR_L2TIX
argument_list|(
name|f
operator|->
name|l2t
condition|?
name|f
operator|->
name|l2t
operator|->
name|idx
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ethtype
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|ethtype
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ethtypem
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|ethtype
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|frag_to_ovlan_vldm
operator|=
operator|(
name|V_FW_FILTER_WR_FRAG
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|frag
argument_list|)
operator||
name|V_FW_FILTER_WR_FRAGM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|frag
argument_list|)
operator||
name|V_FW_FILTER_WR_IVLAN_VLD
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_OVLAN_VLD
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_IVLAN_VLDM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_OVLAN_VLDM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic_vld
argument_list|)
operator|)
expr_stmt|;
name|fwr
operator|->
name|smac_sel
operator|=
literal|0
expr_stmt|;
name|fwr
operator|->
name|rx_chan_rx_rpl_iq
operator|=
name|htobe16
argument_list|(
name|V_FW_FILTER_WR_RX_CHAN
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_FILTER_WR_RX_RPL_IQ
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|maci_to_matchtypem
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_MACI
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|macidx
argument_list|)
operator||
name|V_FW_FILTER_WR_MACIM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|macidx
argument_list|)
operator||
name|V_FW_FILTER_WR_FCOE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|fcoe
argument_list|)
operator||
name|V_FW_FILTER_WR_FCOEM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|fcoe
argument_list|)
operator||
name|V_FW_FILTER_WR_PORT
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
argument_list|)
operator||
name|V_FW_FILTER_WR_PORTM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|iport
argument_list|)
operator||
name|V_FW_FILTER_WR_MATCHTYPE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|matchtype
argument_list|)
operator||
name|V_FW_FILTER_WR_MATCHTYPEM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|matchtype
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ptcl
operator|=
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|proto
expr_stmt|;
name|fwr
operator|->
name|ptclm
operator|=
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|proto
expr_stmt|;
name|fwr
operator|->
name|ttyp
operator|=
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|tos
expr_stmt|;
name|fwr
operator|->
name|ttypm
operator|=
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|tos
expr_stmt|;
name|fwr
operator|->
name|ivlan
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ivlanm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ovlan
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ovlanm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|dip
argument_list|,
name|fwr
operator|->
name|lip
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|lip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|dip
argument_list|,
name|fwr
operator|->
name|lipm
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|lipm
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|sip
argument_list|,
name|fwr
operator|->
name|fip
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|fip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|sip
argument_list|,
name|fwr
operator|->
name|fipm
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|fipm
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|lp
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|dport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|lpm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|dport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|fp
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|sport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|fpm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|newsmac
condition|)
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|smac
argument_list|,
name|fwr
operator|->
name|sma
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|sma
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|++
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|fidx
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|f
init|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|fidx
index|]
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_filter_wr
modifier|*
name|fwr
decl_stmt|;
name|unsigned
name|int
name|ftid
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ftid
operator|=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|+
name|fidx
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fwr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|t4_mk_filtdelwr
argument_list|(
name|ftid
argument_list|,
name|fwr
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filter_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|rpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|idx
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: payload with opcode %02x"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|&&
operator|(
name|idx
operator|-=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|)
operator|<
name|sc
operator|->
name|tids
operator|.
name|nftids
condition|)
block|{
name|unsigned
name|int
name|rc
init|=
name|G_COOKIE
argument_list|(
name|rpl
operator|->
name|cookie
argument_list|)
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
init|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|idx
index|]
decl_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|FW_FILTER_WR_FLT_ADDED
condition|)
block|{
name|f
operator|->
name|smtidx
operator|=
operator|(
name|be64toh
argument_list|(
name|rpl
operator|->
name|oldval
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
comment|/* asynchronous setup completed */
name|f
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rc
operator|!=
name|FW_FILTER_WR_FLT_DELETED
condition|)
block|{
comment|/* Add or delete failed, display an error */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filter %u setup failed with error %u\n"
argument_list|,
name|idx
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|clear_filter
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|--
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_sge_context
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_sge_context
modifier|*
name|cntxt
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|cntxt
operator|->
name|cid
operator|>
name|M_CTXTQID
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_EGRESS
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_INGRESS
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_FLM
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_CNM
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FW_OK
condition|)
block|{
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Avoid parallel t4_wr_mbox */
name|rc
operator|=
operator|-
name|t4_sge_ctxt_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|cntxt
operator|->
name|cid
argument_list|,
name|cntxt
operator|->
name|mem_id
argument_list|,
operator|&
name|cntxt
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* Read via firmware failed or wasn't even attempted */
name|rc
operator|=
operator|-
name|t4_sge_ctxt_rd_bd
argument_list|(
name|sc
argument_list|,
name|cntxt
operator|->
name|cid
argument_list|,
name|cntxt
operator|->
name|mem_id
argument_list|,
operator|&
name|cntxt
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_card_mem
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_mem_range
modifier|*
name|mr
parameter_list|)
block|{
name|uint32_t
name|base
decl_stmt|,
name|size
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|win
decl_stmt|,
name|off
decl_stmt|,
name|remaining
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* reads are in multiples of 32 bits */
if|if
condition|(
name|mr
operator|->
name|addr
operator|&
literal|3
operator|||
name|mr
operator|->
name|len
operator|&
literal|3
operator|||
name|mr
operator|->
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * We don't want to deal with potential holes so we mandate that the 	 * requested region must lie entirely within one of the 3 memories. 	 */
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|&
name|F_EDRAM0_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|base
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|size
operator|=
name|G_EDRAM0_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|mr
operator|->
name|addr
operator|>=
name|base
operator|&&
name|mr
operator|->
name|addr
operator|<
name|base
operator|+
name|size
operator|&&
name|mr
operator|->
name|addr
operator|+
name|mr
operator|->
name|len
operator|<=
name|base
operator|+
name|size
condition|)
goto|goto
name|proceed
goto|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EDRAM1_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|base
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|size
operator|=
name|G_EDRAM1_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|mr
operator|->
name|addr
operator|>=
name|base
operator|&&
name|mr
operator|->
name|addr
operator|<
name|base
operator|+
name|size
operator|&&
name|mr
operator|->
name|addr
operator|+
name|mr
operator|->
name|len
operator|<=
name|base
operator|+
name|size
condition|)
goto|goto
name|proceed
goto|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EXT_MEM_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|base
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|size
operator|=
name|G_EXT_MEM_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|mr
operator|->
name|addr
operator|>=
name|base
operator|&&
name|mr
operator|->
name|addr
operator|<
name|base
operator|+
name|size
operator|&&
name|mr
operator|->
name|addr
operator|+
name|mr
operator|->
name|len
operator|<=
name|base
operator|+
name|size
condition|)
goto|goto
name|proceed
goto|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
name|proceed
label|:
name|buf
operator|=
name|b
operator|=
name|malloc
argument_list|(
name|mr
operator|->
name|len
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Position the PCIe window (we use memwin2) to the 16B aligned area 	 * just at/before the requested region. 	 */
name|win
operator|=
name|mr
operator|->
name|addr
operator|&
operator|~
literal|0xf
expr_stmt|;
name|off
operator|=
name|mr
operator|->
name|addr
operator|-
name|win
expr_stmt|;
comment|/* offset of the requested region in the win */
name|remaining
operator|=
name|mr
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|remaining
condition|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
literal|2
argument_list|)
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* number of bytes that we'll copy in the inner loop */
name|n
operator|=
name|min
argument_list|(
name|remaining
argument_list|,
name|MEMWIN2_APERTURE
operator|-
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|4
operator|,
name|remaining
operator|-=
literal|4
control|)
operator|*
name|b
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|MEMWIN2_BASE
operator|+
name|off
operator|+
name|i
argument_list|)
expr_stmt|;
name|win
operator|+=
name|MEMWIN2_APERTURE
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
name|rc
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|mr
operator|->
name|data
argument_list|,
name|mr
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_find_pci_capability
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
return|return
operator|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|cap
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|?
name|i
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_os_portmod_changed
parameter_list|(
specifier|const
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|mod_str
index|[]
init|=
block|{
name|NULL
block|,
literal|"LR"
block|,
literal|"SR"
block|,
literal|"ER"
block|,
literal|"TWINAX"
block|,
literal|"active TWINAX"
block|,
literal|"LRM"
block|}
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_NONE
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"transceiver unplugged.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_UNKNOWN
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"unknown transceiver inserted.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_NOTSUPPORTED
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"unsupported transceiver inserted.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|>
literal|0
operator|&&
name|pi
operator|->
name|mod_type
operator|<
name|ARRAY_SIZE
argument_list|(
name|mod_str
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"%s transceiver inserted.\n"
argument_list|,
name|mod_str
index|[
name|pi
operator|->
name|mod_type
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"transceiver (type %d) inserted.\n"
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_os_link_changed
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|link_stat
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|link_stat
condition|)
block|{
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|pi
operator|->
name|link_cfg
operator|.
name|speed
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_iterate
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&t4_list
argument_list|,
argument|link
argument_list|)
block|{
comment|/* 		 * func should not make any assumptions about what state sc is 		 * in - the only guarantee is that sc->sc_lock is a valid lock. 		 */
name|func
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|rc
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHELSIO_T4_GETREG
case|:
block|{
name|struct
name|t4_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|4
condition|)
name|edata
operator|->
name|val
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|8
condition|)
name|edata
operator|->
name|val
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|CHELSIO_T4_SETREG
case|:
block|{
name|struct
name|t4_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|edata
operator|->
name|val
operator|&
literal|0xffffffff00000000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
operator|(
name|uint32_t
operator|)
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|8
condition|)
name|t4_write_reg64
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|CHELSIO_T4_REGDUMP
case|:
block|{
name|struct
name|t4_regdump
modifier|*
name|regs
init|=
operator|(
expr|struct
name|t4_regdump
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|reglen
init|=
name|T4_REGDUMP_SIZE
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|regs
operator|->
name|len
operator|<
name|reglen
condition|)
block|{
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
comment|/* hint to the caller */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|reglen
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|t4_get_regs
argument_list|(
name|sc
argument_list|,
name|regs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rc
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|regs
operator|->
name|data
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_T4_GET_FILTER_MODE
case|:
name|rc
operator|=
name|get_filter_mode
argument_list|(
name|sc
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_FILTER_MODE
case|:
name|rc
operator|=
name|set_filter_mode
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_FILTER
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|get_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_FILTER
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|set_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_DEL_FILTER
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|del_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_SGE_CONTEXT
case|:
name|rc
operator|=
name|get_sge_context
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_sge_context
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_LOAD_FW
case|:
block|{
name|struct
name|t4_data
modifier|*
name|fw
init|=
operator|(
expr|struct
name|t4_data
operator|*
operator|)
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|fw_data
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|fw_data
operator|=
name|malloc
argument_list|(
name|fw
operator|->
name|len
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
name|copyin
argument_list|(
name|fw
operator|->
name|data
argument_list|,
name|fw_data
argument_list|,
name|fw
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|rc
operator|=
operator|-
name|t4_load_fw
argument_list|(
name|sc
argument_list|,
name|fw_data
argument_list|,
name|fw
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fw_data
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_T4_GET_MEM
case|:
name|rc
operator|=
name|read_card_mem
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_mem_range
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"You must enable a cxgbe interface first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|t4_activate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EAGAIN
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"You must kldload t4_tom.ko before trying "
literal|"to enable TOE on a cxgbe interface.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|tom_softc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: TOM activated but softc NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
argument_list|,
operator|(
literal|"%s: TOM activated but flag not set"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
argument_list|,
operator|(
literal|"%s: TOM never initialized?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an upper layer driver to the global list.  */
end_comment

begin_function
name|int
name|t4_register_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|->
name|uld_id
operator|==
name|ui
operator|->
name|uld_id
condition|)
block|{
name|rc
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t4_uld_list
argument_list|,
name|ui
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ui
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_unregister_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|==
name|ui
condition|)
block|{
if|if
condition|(
name|ui
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|t4_uld_list
argument_list|,
name|ui
argument_list|,
name|uld_info
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_activate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
init|=
name|EAGAIN
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
name|rc
operator|=
name|ui
operator|->
name|activate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|ui
operator|->
name|refcount
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_deactivate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
name|rc
operator|=
name|ui
operator|->
name|deactivate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|ui
operator|->
name|refcount
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Come up with reasonable defaults for some of the tunables, provided they're  * not set by the user (in which case we'll use the values as is).  */
end_comment

begin_function
specifier|static
name|void
name|tweak_tunables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nc
init|=
name|mp_ncpus
decl_stmt|;
comment|/* our snapshot of the number of CPUs */
if|if
condition|(
name|t4_ntxq10g
operator|<
literal|1
condition|)
name|t4_ntxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NTXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_ntxq1g
operator|<
literal|1
condition|)
name|t4_ntxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NTXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nrxq10g
operator|<
literal|1
condition|)
name|t4_nrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NRXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nrxq1g
operator|<
literal|1
condition|)
name|t4_nrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NRXQ_1G
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|t4_nofldtxq10g
operator|<
literal|1
condition|)
name|t4_nofldtxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDTXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldtxq1g
operator|<
literal|1
condition|)
name|t4_nofldtxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDTXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldrxq10g
operator|<
literal|1
condition|)
name|t4_nofldrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDRXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldrxq1g
operator|<
literal|1
condition|)
name|t4_nofldrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDRXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_toecaps_allowed
operator|==
operator|-
literal|1
condition|)
name|t4_toecaps_allowed
operator|=
name|FW_CAPS_CONFIG_TOE
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|t4_toecaps_allowed
operator|==
operator|-
literal|1
condition|)
name|t4_toecaps_allowed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t4_tmr_idx_10g
operator|<
literal|0
operator|||
name|t4_tmr_idx_10g
operator|>=
name|SGE_NTIMERS
condition|)
name|t4_tmr_idx_10g
operator|=
name|TMR_IDX_10G
expr_stmt|;
if|if
condition|(
name|t4_pktc_idx_10g
operator|<
operator|-
literal|1
operator|||
name|t4_pktc_idx_10g
operator|>=
name|SGE_NCOUNTERS
condition|)
name|t4_pktc_idx_10g
operator|=
name|PKTC_IDX_10G
expr_stmt|;
if|if
condition|(
name|t4_tmr_idx_1g
operator|<
literal|0
operator|||
name|t4_tmr_idx_1g
operator|>=
name|SGE_NTIMERS
condition|)
name|t4_tmr_idx_1g
operator|=
name|TMR_IDX_1G
expr_stmt|;
if|if
condition|(
name|t4_pktc_idx_1g
operator|<
operator|-
literal|1
operator|||
name|t4_pktc_idx_1g
operator|>=
name|SGE_NCOUNTERS
condition|)
name|t4_pktc_idx_1g
operator|=
name|PKTC_IDX_1G
expr_stmt|;
if|if
condition|(
name|t4_qsize_txq
operator|<
literal|128
condition|)
name|t4_qsize_txq
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|t4_qsize_rxq
operator|<
literal|128
condition|)
name|t4_qsize_rxq
operator|=
literal|128
expr_stmt|;
while|while
condition|(
name|t4_qsize_rxq
operator|&
literal|7
condition|)
name|t4_qsize_rxq
operator|++
expr_stmt|;
name|t4_intr_types
operator|&=
name|INTR_MSIX
operator||
name|INTR_MSI
operator||
name|INTR_INTX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|t4_sge_modload
argument_list|()
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t4_list_lock
argument_list|,
literal|"T4 adapters"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t4_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|mtx_init
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|,
literal|"T4 ULDs"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t4_uld_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tweak_tunables
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|mtx_lock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t4_uld_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t4_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|t4_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgbe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|t4nex
argument_list|,
name|pci
argument_list|,
name|t4_driver
argument_list|,
name|t4_devclass
argument_list|,
name|t4_mod_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t4nex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgbe
argument_list|,
name|t4nex
argument_list|,
name|cxgbe_driver
argument_list|,
name|cxgbe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxgbe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

