begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"t4_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"t4_l2t.h"
end_include

begin_include
include|#
directive|include
file|"t4_mp_ring.h"
end_include

begin_comment
comment|/* T4 bus driver interface */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|t4_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|t4_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|t4_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|t4_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|t4_driver
init|=
block|{
literal|"t4nex"
block|,
name|t4_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T4 port (cxgbe) interface */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgbe_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgbe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgbe_driver
init|=
block|{
literal|"cxgbe"
block|,
name|cxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|port_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T4 VI (vcxgbe) interface */
end_comment

begin_function_decl
specifier|static
name|int
name|vcxgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vcxgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vcxgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|vcxgbe_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|vcxgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|vcxgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|vcxgbe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|vcxgbe_driver
init|=
block|{
literal|"vcxgbe"
block|,
name|vcxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|vi_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|t4_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|t4_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|t4_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|t4_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|t4_open
block|,
operator|.
name|d_close
operator|=
name|t4_close
block|,
operator|.
name|d_ioctl
operator|=
name|t4_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"t4nex"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T5 bus driver interface */
end_comment

begin_function_decl
specifier|static
name|int
name|t5_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|t5_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|t5_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|t4_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|t4_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|t5_driver
init|=
block|{
literal|"t5nex"
block|,
name|t5_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T5 port (cxl) interface */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|cxl_driver
init|=
block|{
literal|"cxl"
block|,
name|cxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|port_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T5 VI (vcxl) interface */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|vcxl_driver
init|=
block|{
literal|"vcxl"
block|,
name|vcxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|vi_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|t5_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|t4_open
block|,
operator|.
name|d_close
operator|=
name|t4_close
block|,
operator|.
name|d_ioctl
operator|=
name|t4_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"t5nex"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ifnet + media interface */
end_comment

begin_function_decl
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CXGBE
argument_list|,
literal|"cxgbe"
argument_list|,
literal|"Chelsio T4/T5 Ethernet driver and services"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Correct lock order when you need to acquire multiple locks is t4_list_lock,  * then ADAPTER_LOCK, then t4_uld_list_lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|t4_list_lock
decl_stmt|;
end_decl_stmt

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|adapter
argument_list|)
end_macro

begin_expr_stmt
name|t4_list
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sx
name|t4_uld_list_lock
decl_stmt|;
end_decl_stmt

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|uld_info
argument_list|)
end_macro

begin_expr_stmt
name|t4_uld_list
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Tunables.  See tweak_tunables() too.  *  * Each tunable is set to a default value here if it's known at compile-time.  * Otherwise it is set to -1 as an indication to tweak_tunables() that it should  * provide a reasonable default when the driver is loaded.  *  * Tunables applicable to both T4 and T5 are under hw.cxgbe.  Those specific to  * T5 are under hw.cxl.  */
end_comment

begin_comment
comment|/*  * Number of queues for tx and rx, 10G and 1G, NIC and offload.  */
end_comment

begin_define
define|#
directive|define
name|NTXQ_10G
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_ntxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.ntxq10g"
argument_list|,
operator|&
name|t4_ntxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NRXQ_10G
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nrxq10g"
argument_list|,
operator|&
name|t4_nrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NTXQ_1G
value|4
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_ntxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.ntxq1g"
argument_list|,
operator|&
name|t4_ntxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NRXQ_1G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nrxq1g"
argument_list|,
operator|&
name|t4_nrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_rsrv_noflowq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.rsrv_noflowq"
argument_list|,
operator|&
name|t4_rsrv_noflowq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_define
define|#
directive|define
name|NOFLDTXQ_10G
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldtxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldtxq10g"
argument_list|,
operator|&
name|t4_nofldtxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDRXQ_10G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldrxq10g"
argument_list|,
operator|&
name|t4_nofldrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDTXQ_1G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldtxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldtxq1g"
argument_list|,
operator|&
name|t4_nofldtxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOFLDRXQ_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nofldrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nofldrxq1g"
argument_list|,
operator|&
name|t4_nofldrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_define
define|#
directive|define
name|NNMTXQ_10G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmtxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmtxq10g"
argument_list|,
operator|&
name|t4_nnmtxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NNMRXQ_10G
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmrxq10g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmrxq10g"
argument_list|,
operator|&
name|t4_nnmrxq10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NNMTXQ_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmtxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmtxq1g"
argument_list|,
operator|&
name|t4_nnmtxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NNMRXQ_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_nnmrxq1g
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.nnmrxq1g"
argument_list|,
operator|&
name|t4_nnmrxq1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Holdoff parameters for 10G and 1G ports.  */
end_comment

begin_define
define|#
directive|define
name|TMR_IDX_10G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_tmr_idx_10g
init|=
name|TMR_IDX_10G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_10G"
argument_list|,
operator|&
name|t4_tmr_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PKTC_IDX_10G
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_pktc_idx_10g
init|=
name|PKTC_IDX_10G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_10G"
argument_list|,
operator|&
name|t4_pktc_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TMR_IDX_1G
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_tmr_idx_1g
init|=
name|TMR_IDX_1G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_1G"
argument_list|,
operator|&
name|t4_tmr_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PKTC_IDX_1G
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|int
name|t4_pktc_idx_1g
init|=
name|PKTC_IDX_1G
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_1G"
argument_list|,
operator|&
name|t4_pktc_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Size (# of entries) of each tx and rx queue.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_qsize_txq
init|=
name|TX_EQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_txq"
argument_list|,
operator|&
name|t4_qsize_txq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_qsize_rxq
init|=
name|RX_IQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_rxq"
argument_list|,
operator|&
name|t4_qsize_rxq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Interrupt types allowed (bits 0, 1, 2 = INTx, MSI, MSI-X respectively).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_intr_types
init|=
name|INTR_MSIX
operator||
name|INTR_MSI
operator||
name|INTR_INTX
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.interrupt_types"
argument_list|,
operator|&
name|t4_intr_types
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Configuration file.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_CF
value|"default"
end_define

begin_define
define|#
directive|define
name|FLASH_CF
value|"flash"
end_define

begin_define
define|#
directive|define
name|UWIRE_CF
value|"uwire"
end_define

begin_define
define|#
directive|define
name|FPGA_CF
value|"fpga"
end_define

begin_decl_stmt
specifier|static
name|char
name|t4_cfg_file
index|[
literal|32
index|]
init|=
name|DEFAULT_CF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
literal|"hw.cxgbe.config_file"
argument_list|,
name|t4_cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|t4_cfg_file
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PAUSE settings (bit 0, 1 = rx_pause, tx_pause respectively).  * rx_pause = 1 to heed incoming PAUSE frames, 0 to ignore them.  * tx_pause = 1 to emit PAUSE frames when the rx FIFO reaches its high water  *            mark or when signalled to do so, 0 to never emit PAUSE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_pause_settings
init|=
name|PAUSE_TX
operator||
name|PAUSE_RX
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.pause_settings"
argument_list|,
operator|&
name|t4_pause_settings
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Firmware auto-install by driver during attach (0, 1, 2 = prohibited, allowed,  * encouraged respectively).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|t4_fw_install
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fw_install"
argument_list|,
operator|&
name|t4_fw_install
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ASIC features that will be used.  Disable the ones you don't want so that the  * chip resources aren't wasted on features that will not be used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|t4_linkcaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* No DCBX, PPP, etc. by default */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.linkcaps_allowed"
argument_list|,
operator|&
name|t4_linkcaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_niccaps_allowed
init|=
name|FW_CAPS_CONFIG_NIC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.niccaps_allowed"
argument_list|,
operator|&
name|t4_niccaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_toecaps_allowed
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.toecaps_allowed"
argument_list|,
operator|&
name|t4_toecaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_rdmacaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.rdmacaps_allowed"
argument_list|,
operator|&
name|t4_rdmacaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_iscsicaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.iscsicaps_allowed"
argument_list|,
operator|&
name|t4_iscsicaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_fcoecaps_allowed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fcoecaps_allowed"
argument_list|,
operator|&
name|t4_fcoecaps_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t5_write_combine
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxl.write_combine"
argument_list|,
operator|&
name|t5_write_combine
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|t4_num_vis
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.num_vis"
argument_list|,
operator|&
name|t4_num_vis
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Functions used by extra VIs to obtain unique MAC addresses for each VI. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_mac_funcs
index|[]
init|=
block|{
name|FW_VI_FUNC_OFLD
block|,
name|FW_VI_FUNC_IWARP
block|,
name|FW_VI_FUNC_OPENISCSI
block|,
name|FW_VI_FUNC_OPENFCOE
block|,
name|FW_VI_FUNC_FOISCSI
block|,
name|FW_VI_FUNC_FOFCOE
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|intrs_and_queues
block|{
name|uint16_t
name|intr_type
decl_stmt|;
comment|/* INTx, MSI, or MSI-X */
name|uint16_t
name|nirq
decl_stmt|;
comment|/* Total # of vectors */
name|uint16_t
name|intr_flags_10g
decl_stmt|;
comment|/* Interrupt flags for each 10G port */
name|uint16_t
name|intr_flags_1g
decl_stmt|;
comment|/* Interrupt flags for each 1G port */
name|uint16_t
name|ntxq10g
decl_stmt|;
comment|/* # of NIC txq's for each 10G port */
name|uint16_t
name|nrxq10g
decl_stmt|;
comment|/* # of NIC rxq's for each 10G port */
name|uint16_t
name|ntxq1g
decl_stmt|;
comment|/* # of NIC txq's for each 1G port */
name|uint16_t
name|nrxq1g
decl_stmt|;
comment|/* # of NIC rxq's for each 1G port */
name|uint16_t
name|rsrv_noflowq
decl_stmt|;
comment|/* Flag whether to reserve queue 0 */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|uint16_t
name|nofldtxq10g
decl_stmt|;
comment|/* # of TOE txq's for each 10G port */
name|uint16_t
name|nofldrxq10g
decl_stmt|;
comment|/* # of TOE rxq's for each 10G port */
name|uint16_t
name|nofldtxq1g
decl_stmt|;
comment|/* # of TOE txq's for each 1G port */
name|uint16_t
name|nofldrxq1g
decl_stmt|;
comment|/* # of TOE rxq's for each 1G port */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|uint16_t
name|nnmtxq10g
decl_stmt|;
comment|/* # of netmap txq's for each 10G port */
name|uint16_t
name|nnmrxq10g
decl_stmt|;
comment|/* # of netmap rxq's for each 10G port */
name|uint16_t
name|nnmtxq1g
decl_stmt|;
comment|/* # of netmap txq's for each 1G port */
name|uint16_t
name|nnmrxq1g
decl_stmt|;
comment|/* # of netmap rxq's for each 1G port */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|filter_entry
block|{
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/* filter allocated and valid */
name|uint32_t
name|locked
range|:
literal|1
decl_stmt|;
comment|/* filter is administratively locked */
name|uint32_t
name|pending
range|:
literal|1
decl_stmt|;
comment|/* filter action is pending firmware reply */
name|uint32_t
name|smtidx
range|:
literal|8
decl_stmt|;
comment|/* Source MAC Table index for smac */
name|struct
name|l2t_entry
modifier|*
name|l2t
decl_stmt|;
comment|/* Layer Two Table entry for dmac */
name|struct
name|t4_filter_specification
name|fs
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|map_bars_0_and_4
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_bar_2
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|position_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rw_via_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|read_via_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|write_via_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint32_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_mem_range
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwmtype_to_hwmtype
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_mt_off_len
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fixup_devlog_params
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|partition_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_params__pre_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|ifmedia
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_intr_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_txq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_wrq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_wrq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_iq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_iq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quiesce_fl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_intr_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_regdump
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vi_refresh_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|vi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_refresh_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_vlan_config
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|an_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fw_msg_not_handled
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|__be64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_bitfield
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_btphy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_noflowq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_pause_settings
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_temperature
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SBUF_DRAIN
end_ifdef

begin_function_decl
specifier|static
name|int
name|sysctl_cctrl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_ibq_obq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_la_t6
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_ma_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_pif_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cim_qcfg
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_cpl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_ddp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_devlog
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_fcoe_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_sched
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_lb_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_linkdnrc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_meminfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_mps_tcam
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_mps_tcam_t6
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_path_mtus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_pm_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_rdma_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tcp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tids
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tp_err_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tp_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tx_rate
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_ulprx_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_wcwr_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|uint32_t
name|fconf_iconf_to_mode
parameter_list|(
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|mode_to_fconf
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|mode_to_iconf
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_fspec_against_fconf_iconf
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter_specification
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint64_t
name|get_filter_hits
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_filter
parameter_list|(
name|struct
name|filter_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_sge_context
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_sge_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_fw
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_card_mem
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|t4_mem_range
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_i2c
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_i2c_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_sched_class
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_sched_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_sched_queue
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_sched_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function_decl
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
block|{
name|uint16_t
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|t4_pciids
index|[]
init|=
block|{
block|{
literal|0xa000
block|,
literal|"Chelsio Terminator 4 FPGA"
block|}
block|,
block|{
literal|0x4400
block|,
literal|"Chelsio T440-dbg"
block|}
block|,
block|{
literal|0x4401
block|,
literal|"Chelsio T420-CR"
block|}
block|,
block|{
literal|0x4402
block|,
literal|"Chelsio T422-CR"
block|}
block|,
block|{
literal|0x4403
block|,
literal|"Chelsio T440-CR"
block|}
block|,
block|{
literal|0x4404
block|,
literal|"Chelsio T420-BCH"
block|}
block|,
block|{
literal|0x4405
block|,
literal|"Chelsio T440-BCH"
block|}
block|,
block|{
literal|0x4406
block|,
literal|"Chelsio T440-CH"
block|}
block|,
block|{
literal|0x4407
block|,
literal|"Chelsio T420-SO"
block|}
block|,
block|{
literal|0x4408
block|,
literal|"Chelsio T420-CX"
block|}
block|,
block|{
literal|0x4409
block|,
literal|"Chelsio T420-BT"
block|}
block|,
block|{
literal|0x440a
block|,
literal|"Chelsio T404-BT"
block|}
block|,
block|{
literal|0x440e
block|,
literal|"Chelsio T440-LP-CR"
block|}
block|, }
struct|,
name|t5_pciids
index|[]
init|=
block|{
block|{
literal|0xb000
block|,
literal|"Chelsio Terminator 5 FPGA"
block|}
block|,
block|{
literal|0x5400
block|,
literal|"Chelsio T580-dbg"
block|}
block|,
block|{
literal|0x5401
block|,
literal|"Chelsio T520-CR"
block|}
block|,
comment|/* 2 x 10G */
block|{
literal|0x5402
block|,
literal|"Chelsio T522-CR"
block|}
block|,
comment|/* 2 x 10G, 2 X 1G */
block|{
literal|0x5403
block|,
literal|"Chelsio T540-CR"
block|}
block|,
comment|/* 4 x 10G */
block|{
literal|0x5407
block|,
literal|"Chelsio T520-SO"
block|}
block|,
comment|/* 2 x 10G, nomem */
block|{
literal|0x5409
block|,
literal|"Chelsio T520-BT"
block|}
block|,
comment|/* 2 x 10GBaseT */
block|{
literal|0x540a
block|,
literal|"Chelsio T504-BT"
block|}
block|,
comment|/* 4 x 1G */
block|{
literal|0x540d
block|,
literal|"Chelsio T580-CR"
block|}
block|,
comment|/* 2 x 40G */
block|{
literal|0x540e
block|,
literal|"Chelsio T540-LP-CR"
block|}
block|,
comment|/* 4 x 10G */
block|{
literal|0x5410
block|,
literal|"Chelsio T580-LP-CR"
block|}
block|,
comment|/* 2 x 40G */
block|{
literal|0x5411
block|,
literal|"Chelsio T520-LL-CR"
block|}
block|,
comment|/* 2 x 10G */
block|{
literal|0x5412
block|,
literal|"Chelsio T560-CR"
block|}
block|,
comment|/* 1 x 40G, 2 x 10G */
block|{
literal|0x5414
block|,
literal|"Chelsio T580-LP-SO-CR"
block|}
block|,
comment|/* 2 x 40G, nomem */
block|{
literal|0x5415
block|,
literal|"Chelsio T502-BT"
block|}
block|,
comment|/* 2 x 1G */
ifdef|#
directive|ifdef
name|notyet
block|{
literal|0x5404
block|,
literal|"Chelsio T520-BCH"
block|}
block|,
block|{
literal|0x5405
block|,
literal|"Chelsio T540-BCH"
block|}
block|,
block|{
literal|0x5406
block|,
literal|"Chelsio T540-CH"
block|}
block|,
block|{
literal|0x5408
block|,
literal|"Chelsio T520-CX"
block|}
block|,
block|{
literal|0x540b
block|,
literal|"Chelsio B520-SR"
block|}
block|,
block|{
literal|0x540c
block|,
literal|"Chelsio B504-BT"
block|}
block|,
block|{
literal|0x540f
block|,
literal|"Chelsio Amsterdam"
block|}
block|,
block|{
literal|0x5413
block|,
literal|"Chelsio T580-CHR"
block|}
block|,
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_comment
comment|/*  * service_iq() has an iq and needs the fl.  Offset of fl from the iq should be  * exactly the same for both rxq and ofld_rxq.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|,
name|iq
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|sge_rxq
argument_list|,
name|iq
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|,
name|fl
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|sge_rxq
argument_list|,
name|fl
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No easy way to include t4_msg.h before adapter.h so we check this way */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|nitems
argument_list|(
operator|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
literal|0
operator|)
operator|->
name|cpl_handler
argument_list|)
operator|==
name|NUM_CPL_CMDS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|nitems
argument_list|(
operator|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
literal|0
operator|)
operator|->
name|fw_msg_handler
argument_list|)
operator|==
name|NUM_FW6_TYPES
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cluster_metadata
argument_list|)
operator|<=
name|CL_METADATA_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|v
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|d
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|f
init|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|PCI_VENDOR_ID_CHELSIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Attach only to PF0 of the FPGA */
if|if
condition|(
name|d
operator|==
literal|0xa000
operator|&&
name|f
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t4_pciids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|==
name|t4_pciids
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t4_pciids
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t5_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|v
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|d
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|f
init|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|PCI_VENDOR_ID_CHELSIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Attach only to PF0 of the FPGA */
if|if
condition|(
name|d
operator|==
literal|0xb000
operator|&&
name|f
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t5_pciids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|==
name|t5_pciids
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t5_pciids
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t5_attribute_workaround
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|root_port
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * The T5 chips do not properly echo the No Snoop and Relaxed 	 * Ordering attributes when replying to a TLP from a Root 	 * Port.  As a workaround, find the parent Root Port and 	 * disable No Snoop and Relaxed Ordering.  Note that this 	 * affects all devices under this root port. 	 */
name|root_port
operator|=
name|pci_find_pcie_root_port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|root_port
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to find parent root port\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
name|pcie_adjust_config
argument_list|(
name|root_port
argument_list|,
name|PCIER_DEVICE_CTL
argument_list|,
name|PCIEM_CTL_RELAXED_ORD_ENABLE
operator||
name|PCIEM_CTL_NOSNOOP_ENABLE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
operator|(
name|PCIEM_CTL_RELAXED_ORD_ENABLE
operator||
name|PCIEM_CTL_NOSNOOP_ENABLE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Disabled No Snoop/Relaxed Ordering on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|root_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n10g
decl_stmt|,
name|n1g
decl_stmt|,
name|rqidx
decl_stmt|,
name|tqidx
decl_stmt|;
name|struct
name|intrs_and_queues
name|iaq
decl_stmt|;
name|struct
name|sge
modifier|*
name|s
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|int
name|ofld_rqidx
decl_stmt|,
name|ofld_tqidx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|int
name|nm_rqidx
decl_stmt|,
name|nm_tqidx
decl_stmt|;
endif|#
directive|endif
name|int
name|num_vis
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.cxgbe.debug_flags"
argument_list|,
operator|&
name|sc
operator|->
name|debug_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|&
literal|0xff00
operator|)
operator|==
literal|0x5400
condition|)
name|t5_attribute_workaround
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|pci_set_max_read_req
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|i
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|v
operator||=
name|PCIEM_CTL_RELAXED_ORD_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|i
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|mps
operator|=
literal|128
operator|<<
operator|(
operator|(
name|v
operator|&
name|PCIEM_CTL_MAX_PAYLOAD
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|traceq
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|ifp_lock
argument_list|,
name|sc
operator|->
name|ifp_lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|ifp_lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ifp_lockname
argument_list|)
argument_list|,
literal|"%s tracer"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|sc
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t4_list
argument_list|,
name|sc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|,
literal|"starving freelists"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sfl
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|,
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|,
literal|"indirect register access"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_bars_0_and_4
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * This is the real PF# to which we're attaching.  Works from within PCI 	 * passthrough environments too, where pci_get_function() could return a 	 * different PF# depending on the passthrough configuration.  We need to 	 * use the real PF# in all our communication with the firmware. 	 */
name|sc
operator|->
name|pf
operator|=
name|G_SOURCEPF
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_WHOAMI
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbox
operator|=
name|sc
operator|->
name|pf
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_handler
operator|=
name|an_not_handled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|cpl_handler
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|cpl_handler
index|[
name|i
index|]
operator|=
name|cpl_not_handled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|fw_msg_handler
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|fw_msg_handler
index|[
name|i
index|]
operator|=
name|fw_msg_not_handled
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_SET_TCB_RPL
argument_list|,
name|t4_filter_rpl
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_TRACE_PKT
argument_list|,
name|t4_trace_pkt
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_T5_TRACE_PKT
argument_list|,
name|t5_trace_pkt
argument_list|)
expr_stmt|;
name|t4_init_sge_cpl_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare the adapter for operation. */
name|buf
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_prep_adapter
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to prepare adapter: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Do this really early, with the memory windows set up even before the 	 * character device.  The userland tool's register i/o and mem read 	 * will work even in "recovery mode". 	 */
name|setup_memwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_init_devlog_params
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fixup_devlog_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|make_dev
argument_list|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
operator|&
name|t4_cdevsw
else|:
operator|&
name|t5_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create nexus char device.\n"
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Go no further if recovery mode has been requested. */
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.cxgbe.sos"
argument_list|,
operator|&
name|i
argument_list|)
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"recovery mode.\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_CX8
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"64 bit atomics not available.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* Prepare the firmware for operation */
name|rc
operator|=
name|prep_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|get_params__post_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|set_params__post_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|map_bar_2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
name|t4_create_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * Number of VIs to create per-port.  The first VI is the 	 * "main" regular VI for the port.  The second VI is used for 	 * netmap if present, and any remaining VIs are used for 	 * additional virtual interfaces. 	 * 	 * Limit the number of VIs per port to the number of available 	 * MAC addresses per port. 	 */
if|if
condition|(
name|t4_num_vis
operator|>=
literal|1
condition|)
name|num_vis
operator|=
name|t4_num_vis
expr_stmt|;
else|else
name|num_vis
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|num_vis
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|num_vis
operator|>
name|nitems
argument_list|(
name|vi_mac_funcs
argument_list|)
condition|)
block|{
name|num_vis
operator|=
name|nitems
argument_list|(
name|vi_mac_funcs
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Number of VIs limited to %d\n"
argument_list|,
name|num_vis
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First pass over all the ports - allocate VIs and initialize some 	 * basic parameters like mac address, port type, etc.  We also figure 	 * out whether a port is 10G or 1G and use that information when 	 * calculating how many interrupts to attempt to allocate. 	 */
name|n10g
operator|=
name|n1g
operator|=
literal|0
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|pi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|pi
expr_stmt|;
comment|/* These must be set before t4_port_init */
name|pi
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|pi
operator|->
name|port_id
operator|=
name|i
expr_stmt|;
name|pi
operator|->
name|nvi
operator|=
name|num_vis
expr_stmt|;
name|pi
operator|->
name|vi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vi_info
argument_list|)
operator|*
name|num_vis
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate the "main" VI and initialize parameters 		 * like mac addr. 		 */
name|rc
operator|=
operator|-
name|t4_port_init
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize port %d: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
operator|->
name|vi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pi
operator|->
name|link_cfg
operator|.
name|requested_fc
operator|&=
operator|~
operator|(
name|PAUSE_TX
operator||
name|PAUSE_RX
operator|)
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|requested_fc
operator||=
name|t4_pause_settings
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|fc
operator|&=
operator|~
operator|(
name|PAUSE_TX
operator||
name|PAUSE_RX
operator|)
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|fc
operator||=
name|t4_pause_settings
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_link_l1cfg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
operator|&
name|pi
operator|->
name|link_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"port %d l1cfg failed: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
operator|->
name|vi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|snprintf
argument_list|(
name|pi
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%sp%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|,
name|pi
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chan_map
index|[
name|pi
operator|->
name|tx_chan
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|n10g
operator|++
expr_stmt|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|j
argument_list|,
argument|vi
argument_list|)
block|{
name|vi
operator|->
name|tmr_idx
operator|=
name|t4_tmr_idx_10g
expr_stmt|;
name|vi
operator|->
name|pktc_idx
operator|=
name|t4_pktc_idx_10g
expr_stmt|;
block|}
block|}
else|else
block|{
name|n1g
operator|++
expr_stmt|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|j
argument_list|,
argument|vi
argument_list|)
block|{
name|vi
operator|->
name|tmr_idx
operator|=
name|t4_tmr_idx_1g
expr_stmt|;
name|vi
operator|->
name|pktc_idx
operator|=
name|t4_pktc_idx_1g
expr_stmt|;
block|}
block|}
name|pi
operator|->
name|linkdnrc
operator|=
operator|-
literal|1
expr_stmt|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|j
argument_list|,
argument|vi
argument_list|)
block|{
name|vi
operator|->
name|qsize_rxq
operator|=
name|t4_qsize_rxq
expr_stmt|;
name|vi
operator|->
name|qsize_txq
operator|=
name|t4_qsize_txq
expr_stmt|;
name|vi
operator|->
name|pi
operator|=
name|pi
expr_stmt|;
block|}
name|pi
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
literal|"cxgbe"
else|:
literal|"cxl"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add device for port %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pi
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|dev
operator|=
name|pi
operator|->
name|dev
expr_stmt|;
name|device_set_softc
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Interrupt type, # of interrupts, # of rx/tx queues, etc. 	 */
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|num_vis
operator|--
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|cfg_itype_and_nqueues
argument_list|(
name|sc
argument_list|,
name|n10g
argument_list|,
name|n1g
argument_list|,
name|num_vis
argument_list|,
operator|&
name|iaq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|sc
operator|->
name|intr_type
operator|=
name|iaq
operator|.
name|intr_type
expr_stmt|;
name|sc
operator|->
name|intr_count
operator|=
name|iaq
operator|.
name|nirq
expr_stmt|;
name|s
operator|=
operator|&
name|sc
operator|->
name|sge
expr_stmt|;
name|s
operator|->
name|nrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nrxq1g
expr_stmt|;
name|s
operator|->
name|ntxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|ntxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|ntxq1g
expr_stmt|;
if|if
condition|(
name|num_vis
operator|>
literal|1
condition|)
block|{
name|s
operator|->
name|nrxq
operator|+=
operator|(
name|n10g
operator|+
name|n1g
operator|)
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
name|s
operator|->
name|ntxq
operator|+=
operator|(
name|n10g
operator|+
name|n1g
operator|)
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|s
operator|->
name|neq
operator|=
name|s
operator|->
name|ntxq
operator|+
name|s
operator|->
name|nrxq
expr_stmt|;
comment|/* the free list in an rxq is an eq */
name|s
operator|->
name|neq
operator|+=
name|sc
operator|->
name|params
operator|.
name|nports
operator|+
literal|1
expr_stmt|;
comment|/* ctrl queues: 1 per port + 1 mgmt */
name|s
operator|->
name|niq
operator|=
name|s
operator|->
name|nrxq
operator|+
literal|1
expr_stmt|;
comment|/* 1 extra for firmware event queue */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|s
operator|->
name|nofldrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nofldrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nofldrxq1g
expr_stmt|;
name|s
operator|->
name|nofldtxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nofldtxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nofldtxq1g
expr_stmt|;
if|if
condition|(
name|num_vis
operator|>
literal|1
condition|)
block|{
name|s
operator|->
name|nofldrxq
operator|+=
operator|(
name|n10g
operator|+
name|n1g
operator|)
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
name|s
operator|->
name|nofldtxq
operator|+=
operator|(
name|n10g
operator|+
name|n1g
operator|)
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|s
operator|->
name|neq
operator|+=
name|s
operator|->
name|nofldtxq
operator|+
name|s
operator|->
name|nofldrxq
expr_stmt|;
name|s
operator|->
name|niq
operator|+=
name|s
operator|->
name|nofldrxq
expr_stmt|;
name|s
operator|->
name|ofld_rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nofldrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_ofld_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|ofld_txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nofldtxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_wrq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|s
operator|->
name|nnmrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nnmrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nnmrxq1g
expr_stmt|;
name|s
operator|->
name|nnmtxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nnmtxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nnmtxq1g
expr_stmt|;
name|s
operator|->
name|neq
operator|+=
name|s
operator|->
name|nnmtxq
operator|+
name|s
operator|->
name|nnmrxq
expr_stmt|;
name|s
operator|->
name|niq
operator|+=
name|s
operator|->
name|nnmrxq
expr_stmt|;
name|s
operator|->
name|nm_rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nnmrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_nm_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|nm_txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nnmtxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_nm_txq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|ctrlq
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|params
operator|.
name|nports
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_wrq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|ntxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_txq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|iqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|niq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_iq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|eqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|neq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_eq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|intr_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|irq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_init_l2t
argument_list|(
name|sc
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Second pass over the ports.  This time we know the number of rx and 	 * tx queues that each port should get. 	 */
name|rqidx
operator|=
name|tqidx
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|ofld_rqidx
operator|=
name|ofld_tqidx
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|nm_rqidx
operator|=
name|nm_tqidx
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
continue|continue;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|j
argument_list|,
argument|vi
argument_list|)
block|{
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|j
operator|==
literal|1
condition|)
block|{
name|vi
operator|->
name|flags
operator||=
name|VI_NETMAP
operator||
name|INTR_RXQ
expr_stmt|;
name|vi
operator|->
name|first_rxq
operator|=
name|nm_rqidx
expr_stmt|;
name|vi
operator|->
name|first_txq
operator|=
name|nm_tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|vi
operator|->
name|nrxq
operator|=
name|iaq
operator|.
name|nnmrxq10g
expr_stmt|;
name|vi
operator|->
name|ntxq
operator|=
name|iaq
operator|.
name|nnmtxq10g
expr_stmt|;
block|}
else|else
block|{
name|vi
operator|->
name|nrxq
operator|=
name|iaq
operator|.
name|nnmrxq1g
expr_stmt|;
name|vi
operator|->
name|ntxq
operator|=
name|iaq
operator|.
name|nnmtxq1g
expr_stmt|;
block|}
name|nm_rqidx
operator|+=
name|vi
operator|->
name|nrxq
expr_stmt|;
name|nm_tqidx
operator|+=
name|vi
operator|->
name|ntxq
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|vi
operator|->
name|first_rxq
operator|=
name|rqidx
expr_stmt|;
name|vi
operator|->
name|first_txq
operator|=
name|tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|vi
operator|->
name|flags
operator||=
name|iaq
operator|.
name|intr_flags_10g
operator|&
name|INTR_RXQ
expr_stmt|;
name|vi
operator|->
name|nrxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|nrxq10g
else|:
literal|1
expr_stmt|;
name|vi
operator|->
name|ntxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|ntxq10g
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
name|vi
operator|->
name|flags
operator||=
name|iaq
operator|.
name|intr_flags_1g
operator|&
name|INTR_RXQ
expr_stmt|;
name|vi
operator|->
name|nrxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|nrxq1g
else|:
literal|1
expr_stmt|;
name|vi
operator|->
name|ntxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|ntxq1g
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vi
operator|->
name|ntxq
operator|>
literal|1
condition|)
name|vi
operator|->
name|rsrv_noflowq
operator|=
name|iaq
operator|.
name|rsrv_noflowq
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|vi
operator|->
name|rsrv_noflowq
operator|=
literal|0
expr_stmt|;
name|rqidx
operator|+=
name|vi
operator|->
name|nrxq
expr_stmt|;
name|tqidx
operator|+=
name|vi
operator|->
name|ntxq
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
continue|continue;
name|vi
operator|->
name|first_ofld_rxq
operator|=
name|ofld_rqidx
expr_stmt|;
name|vi
operator|->
name|first_ofld_txq
operator|=
name|ofld_tqidx
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
operator|||
name|is_40G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|vi
operator|->
name|flags
operator||=
name|iaq
operator|.
name|intr_flags_10g
operator|&
name|INTR_OFLD_RXQ
expr_stmt|;
name|vi
operator|->
name|nofldrxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|nofldrxq10g
else|:
literal|1
expr_stmt|;
name|vi
operator|->
name|nofldtxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|nofldtxq10g
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
name|vi
operator|->
name|flags
operator||=
name|iaq
operator|.
name|intr_flags_1g
operator|&
name|INTR_OFLD_RXQ
expr_stmt|;
name|vi
operator|->
name|nofldrxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|nofldrxq1g
else|:
literal|1
expr_stmt|;
name|vi
operator|->
name|nofldtxq
operator|=
name|j
operator|==
literal|0
condition|?
name|iaq
operator|.
name|nofldtxq1g
else|:
literal|1
expr_stmt|;
block|}
name|ofld_rqidx
operator|+=
name|vi
operator|->
name|nofldrxq
expr_stmt|;
name|ofld_tqidx
operator|+=
name|vi
operator|->
name|nofldtxq
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|rc
operator|=
name|setup_intr_handlers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to setup interrupt handlers: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach all child ports: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCIe gen%d x%d, %d ports, %d %s interrupt%s, %d eq, %d iq\n"
argument_list|,
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|speed
argument_list|,
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|width
argument_list|,
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
name|sc
operator|->
name|intr_count
argument_list|,
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSIX
condition|?
literal|"MSI-X"
else|:
operator|(
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSI
condition|?
literal|"MSI"
else|:
literal|"INTx"
operator|)
argument_list|,
name|sc
operator|->
name|intr_count
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|niq
argument_list|)
expr_stmt|;
name|t4_set_desc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|cdev
condition|)
block|{
comment|/* cdev was created and so cxgbetool works; recover that way. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error during attach, adapter is now in recovery mode.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|t4_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
name|t4_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
condition|)
block|{
name|destroy_dev
argument_list|(
name|sc
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|NULL
expr_stmt|;
block|}
name|rc
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to detach child devices: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
name|t4_free_irq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NPORTS
condition|;
name|i
operator|++
control|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
name|t4_free_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|viid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
operator|->
name|vi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
name|adapter_full_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FW_OK
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSI
operator|||
name|sc
operator|->
name|intr_type
operator|==
name|INTR_MSIX
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|regs_rid
argument_list|,
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|udbs_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|udbs_rid
argument_list|,
name|sc
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_rid
argument_list|,
name|sc
operator|->
name|msix_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|l2t
condition|)
name|t4_free_l2t
argument_list|(
name|sc
operator|->
name|l2t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ofld_rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ofld_txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|nm_rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|nm_txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sc
operator|->
name|irq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|ctrlq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|iqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|eqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|t4_destroy_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|t4_list
argument_list|,
name|sc
argument_list|,
name|adapter
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|ifp_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|ifp_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MEMWIN
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|memwin
modifier|*
name|mw
init|=
operator|&
name|sc
operator|->
name|memwin
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rw_initialized
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
condition|)
name|rw_destroy
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"port %d"
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | \     IFCAP_VLAN_HWCSUM | IFCAP_TSO | IFCAP_JUMBO_MTU | IFCAP_LRO | \     IFCAP_VLAN_HWTSO | IFCAP_LINKSTATE | IFCAP_HWCSUM_IPV6 | IFCAP_HWSTATS)
end_define

begin_define
define|#
directive|define
name|T4_CAP_ENABLE
value|(T4_CAP)
end_define

begin_function
specifier|static
name|int
name|cxgbe_vi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|vi
operator|->
name|xact_addr_filt
operator|=
operator|-
literal|1
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vi
operator|->
name|tick
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate an ifnet and set it up */
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|vi
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|vi
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgbe_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgbe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|cxgbe_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|cxgbe_qflush
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|cxgbe_get_counter
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|T4_CAP
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|vi
operator|->
name|nofldrxq
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TOE
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_capenable
operator|=
name|T4_CAP_ENABLE
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomax
operator|=
literal|65536
operator|-
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|TX_SGL_SEGS
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
literal|65536
expr_stmt|;
comment|/* Initialize ifmedia for this VI */
name|ifmedia_init
argument_list|(
operator|&
name|vi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgbe_media_change
argument_list|,
name|cxgbe_media_status
argument_list|)
expr_stmt|;
name|build_medialist
argument_list|(
name|vi
operator|->
name|pi
argument_list|,
operator|&
name|vi
operator|->
name|media
argument_list|)
expr_stmt|;
name|vi
operator|->
name|vlan_c
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|cxgbe_vlan_config
argument_list|,
name|ifp
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|vi
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%d txq, %d rxq (NIC)"
argument_list|,
name|vi
operator|->
name|ntxq
argument_list|,
name|vi
operator|->
name|nrxq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_TOE
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"; %d txq, %d rxq (TOE)"
argument_list|,
name|vi
operator|->
name|nofldtxq
argument_list|,
name|vi
operator|->
name|nofldrxq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|vi_sysctls
argument_list|(
name|vi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
operator|&
name|pi
operator|->
name|pi_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cxgbe_vi_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|pi
operator|->
name|vi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|vi
argument_list|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_NETMAP
condition|)
block|{
comment|/* 			 * media handled here to keep 			 * implementation private to this file 			 */
name|ifmedia_init
argument_list|(
operator|&
name|vi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgbe_media_change
argument_list|,
name|cxgbe_media_status
argument_list|)
expr_stmt|;
name|build_medialist
argument_list|(
name|pi
argument_list|,
operator|&
name|vi
operator|->
name|media
argument_list|)
expr_stmt|;
name|vi
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|is_t4
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|?
literal|"ncxgbe"
else|:
literal|"ncxl"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|vi
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|is_t4
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
condition|?
literal|"vcxgbe"
else|:
literal|"vcxl"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add VI %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|device_set_softc
argument_list|(
name|vi
operator|->
name|dev
argument_list|,
name|vi
argument_list|)
expr_stmt|;
block|}
name|cxgbe_sysctls
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_vi_detach
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vi
operator|->
name|ifp
decl_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|vlan_c
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vi
operator|->
name|vlan_c
argument_list|)
expr_stmt|;
comment|/* Let detach proceed even if these fail. */
name|cxgbe_uninit_synchronized
argument_list|(
name|vi
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|vi
operator|->
name|tick
argument_list|)
expr_stmt|;
name|vi_full_uninit
argument_list|(
name|vi
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|vi
operator|->
name|media
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|vi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|vi
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Detach the extra VIs first. */
name|rc
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|doom_vi
argument_list|(
name|sc
argument_list|,
operator|&
name|pi
operator|->
name|vi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|HAS_TRACEQ
condition|)
block|{
name|sc
operator|->
name|traceq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* cloner should not create ifnet */
name|t4_tracer_port_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|cxgbe_vi_detach
argument_list|(
operator|&
name|pi
operator|->
name|vi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4init"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|cxgbe_init_synchronized
argument_list|(
name|vi
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|mtu
decl_stmt|,
name|flags
decl_stmt|,
name|can_sleep
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4mtu"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
block|{
name|t4_update_fl_bufsize
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_MTU
argument_list|)
expr_stmt|;
block|}
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|can_sleep
operator|=
literal|0
expr_stmt|;
name|redo_sifflags
label|:
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|can_sleep
condition|?
operator|(
name|SLEEP_OK
operator||
name|INTR_OK
operator|)
else|:
name|HOLD_LOCK
argument_list|,
literal|"t4flg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|vi
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
if|if
condition|(
name|can_sleep
operator|==
literal|1
condition|)
block|{
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|can_sleep
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo_sifflags
goto|;
block|}
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_PROMISC
operator||
name|XGMAC_ALLMULTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|can_sleep
operator|==
literal|0
condition|)
block|{
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
name|can_sleep
operator|=
literal|1
expr_stmt|;
goto|goto
name|redo_sifflags
goto|;
block|}
name|rc
operator|=
name|cxgbe_init_synchronized
argument_list|(
name|vi
argument_list|)
expr_stmt|;
block|}
name|vi
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
name|can_sleep
operator|==
literal|0
condition|)
block|{
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
name|can_sleep
operator|=
literal|1
expr_stmt|;
goto|goto
name|redo_sifflags
goto|;
block|}
name|rc
operator|=
name|cxgbe_uninit_synchronized
argument_list|(
name|vi
argument_list|)
expr_stmt|;
block|}
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|can_sleep
condition|?
literal|0
else|:
name|LOCK_HELD
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* these two are called with a mutex held :-( */
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|HOLD_LOCK
argument_list|,
literal|"t4multi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_MCADDRS
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4cap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso4 disabled due to -txcsum.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso6 disabled due to -txcsum6.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
comment|/* 		 * Note that we leave CSUM_TSO alone (it is always set).  The 		 * kernel takes both IFCAP_TSOx and CSUM_TSO into account before 		 * sending a TSO request our way, so it's sufficient to toggle 		 * IFCAP_TSOx only. 		 */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum first.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum6 first.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
name|rxq
operator|->
name|iq
operator|.
name|flags
operator||=
name|IQ_LRO_ENABLED
expr_stmt|;
else|else
name|rxq
operator|->
name|iq
operator|.
name|flags
operator|&=
operator|~
name|IQ_LRO_ENABLED
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|mask
operator|&
name|IFCAP_TOE
condition|)
block|{
name|int
name|enable
init|=
operator|(
name|ifp
operator|->
name|if_capenable
operator|^
name|mask
operator|)
operator|&
name|IFCAP_TOE
decl_stmt|;
name|rc
operator|=
name|toe_capability
argument_list|(
name|vi
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|mask
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_VLANEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* Need to find out how to disable auto-mtu-inflation */
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
ifdef|#
directive|ifdef
name|VLAN_CAPABILITIES
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fail
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|vi
operator|->
name|media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGI2C
case|:
block|{
name|struct
name|ifi2creq
name|i2c
decl_stmt|;
name|rc
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|i2c
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA0
operator|&&
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA2
condition|)
block|{
name|rc
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i2c
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
name|i2c
operator|.
name|data
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4i2c"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
operator|-
name|t4_i2c_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|pi
operator|->
name|port_id
argument_list|,
name|i2c
operator|.
name|dev_addr
argument_list|,
name|i2c
operator|.
name|offset
argument_list|,
name|i2c
operator|.
name|len
argument_list|,
operator|&
name|i2c
operator|.
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|rc
operator|=
name|copyout
argument_list|(
operator|&
name|i2c
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|rc
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|void
modifier|*
name|items
index|[
literal|1
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|m
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* not quite ready for this yet */
if|if
condition|(
name|__predict_false
argument_list|(
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
operator|==
literal|0
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|rc
operator|=
name|parse_pkt
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|MPASS
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* was freed already */
name|atomic_add_int
argument_list|(
operator|&
name|pi
operator|->
name|tx_parse_error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* rare, atomic is ok */
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Select a txq. */
name|txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|txq
index|[
name|vi
operator|->
name|first_txq
index|]
expr_stmt|;
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
name|txq
operator|+=
operator|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
operator|(
name|vi
operator|->
name|ntxq
operator|-
name|vi
operator|->
name|rsrv_noflowq
operator|)
operator|)
operator|+
name|vi
operator|->
name|rsrv_noflowq
operator|)
expr_stmt|;
name|items
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
name|rc
operator|=
name|mp_ring_enqueue
argument_list|(
name|txq
operator|->
name|r
argument_list|,
name|items
argument_list|,
literal|1
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* queues do not exist if !VI_INIT_DONE. */
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
block|{
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|eq
operator|.
name|flags
operator|&=
operator|~
name|EQ_ENABLED
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mp_ring_is_idle
argument_list|(
name|txq
operator|->
name|r
argument_list|)
condition|)
block|{
name|mp_ring_check_drainage
argument_list|(
name|txq
operator|->
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"qflush"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vi_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|c
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|fw_vi_stats_vf
modifier|*
name|s
init|=
operator|&
name|vi
operator|->
name|stats
decl_stmt|;
name|vi_refresh_stats
argument_list|(
name|vi
operator|->
name|pi
operator|->
name|adapter
argument_list|,
name|vi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|s
operator|->
name|rx_bcast_frames
operator|+
name|s
operator|->
name|rx_mcast_frames
operator|+
name|s
operator|->
name|rx_ucast_frames
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|s
operator|->
name|rx_err_frames
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|s
operator|->
name|tx_bcast_frames
operator|+
name|s
operator|->
name|tx_mcast_frames
operator|+
name|s
operator|->
name|tx_ucast_frames
operator|+
name|s
operator|->
name|tx_offload_frames
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|s
operator|->
name|tx_drop_frames
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|s
operator|->
name|rx_bcast_bytes
operator|+
name|s
operator|->
name|rx_mcast_bytes
operator|+
name|s
operator|->
name|rx_ucast_bytes
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|s
operator|->
name|tx_bcast_bytes
operator|+
name|s
operator|->
name|tx_mcast_bytes
operator|+
name|s
operator|->
name|tx_ucast_bytes
operator|+
name|s
operator|->
name|tx_offload_bytes
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|s
operator|->
name|rx_mcast_frames
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|s
operator|->
name|tx_mcast_frames
operator|)
return|;
case|case
name|IFCOUNTER_OQDROPS
case|:
block|{
name|uint64_t
name|drops
decl_stmt|;
name|drops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|vi
operator|->
name|flags
operator|&
operator|(
name|VI_INIT_DONE
operator||
name|VI_NETMAP
operator|)
operator|)
operator|==
name|VI_INIT_DONE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
name|drops
operator|+=
name|counter_u64_fetch
argument_list|(
name|txq
operator|->
name|r
operator|->
name|drops
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|drops
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|uint64_t
name|cxgbe_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|c
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|port_stats
modifier|*
name|s
init|=
operator|&
name|pi
operator|->
name|stats
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|nvi
operator|>
literal|1
condition|)
return|return
operator|(
name|vi_get_counter
argument_list|(
name|ifp
argument_list|,
name|c
argument_list|)
operator|)
return|;
name|cxgbe_refresh_stats
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|s
operator|->
name|rx_frames
operator|-
name|s
operator|->
name|rx_pause
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|s
operator|->
name|rx_jabber
operator|+
name|s
operator|->
name|rx_runt
operator|+
name|s
operator|->
name|rx_too_long
operator|+
name|s
operator|->
name|rx_fcs_err
operator|+
name|s
operator|->
name|rx_len_err
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|s
operator|->
name|tx_frames
operator|-
name|s
operator|->
name|tx_pause
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|s
operator|->
name|tx_error_frames
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|s
operator|->
name|rx_octets
operator|-
name|s
operator|->
name|rx_pause
operator|*
literal|64
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|s
operator|->
name|tx_octets
operator|-
name|s
operator|->
name|tx_pause
operator|*
literal|64
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|s
operator|->
name|rx_mcast_frames
operator|-
name|s
operator|->
name|rx_pause
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|s
operator|->
name|tx_mcast_frames
operator|-
name|s
operator|->
name|tx_pause
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|s
operator|->
name|rx_ovflow0
operator|+
name|s
operator|->
name|rx_ovflow1
operator|+
name|s
operator|->
name|rx_ovflow2
operator|+
name|s
operator|->
name|rx_ovflow3
operator|+
name|s
operator|->
name|rx_trunc0
operator|+
name|s
operator|->
name|rx_trunc1
operator|+
name|s
operator|->
name|rx_trunc2
operator|+
name|s
operator|->
name|rx_trunc3
operator|+
name|pi
operator|->
name|tnl_cong_drops
operator|)
return|;
case|case
name|IFCOUNTER_OQDROPS
case|:
block|{
name|uint64_t
name|drops
decl_stmt|;
name|drops
operator|=
name|s
operator|->
name|tx_drop
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
name|drops
operator|+=
name|counter_u64_fetch
argument_list|(
name|txq
operator|->
name|r
operator|->
name|drops
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|drops
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|vi
operator|->
name|dev
argument_list|,
literal|"%s unimplemented.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|cur
decl_stmt|;
name|int
name|speed
init|=
name|pi
operator|->
name|link_cfg
operator|.
name|speed
decl_stmt|;
name|cur
operator|=
name|vi
operator|->
name|media
operator|.
name|ifm_cur
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* active and current will differ iff current media is autoselect. */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|cur
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
return|return;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
if|if
condition|(
name|speed
operator|==
literal|10000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|1000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|100
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|10
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
else|else
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: link up but speed unknown (%u)"
operator|,
name|__func__
operator|,
name|speed
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vcxgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"port %d vi %td"
argument_list|,
name|vi
operator|->
name|pi
operator|->
name|port_id
argument_list|,
name|vi
operator|-
name|vi
operator|->
name|pi
operator|->
name|vi
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vcxgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|func
decl_stmt|,
name|index
decl_stmt|,
name|rc
decl_stmt|;
name|u32
name|param
decl_stmt|,
name|val
decl_stmt|;
name|vi
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pi
operator|=
name|vi
operator|->
name|pi
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|index
operator|=
name|vi
operator|-
name|pi
operator|->
name|vi
expr_stmt|;
name|KASSERT
argument_list|(
name|index
operator|<
name|nitems
argument_list|(
name|vi_mac_funcs
argument_list|)
argument_list|,
operator|(
literal|"%s: VI %s doesn't have a MAC func"
operator|,
name|__func__
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|func
operator|=
name|vi_mac_funcs
index|[
name|index
index|]
expr_stmt|;
name|rc
operator|=
name|t4_alloc_vi_func
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vi
operator|->
name|hw_addr
argument_list|,
operator|&
name|vi
operator|->
name|rss_size
argument_list|,
name|func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate virtual interface "
literal|"for port %d: %d\n"
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
operator|-
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|rc
operator|)
return|;
block|}
name|vi
operator|->
name|viid
operator|=
name|rc
expr_stmt|;
name|param
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_RSSINFO
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|vi
operator|->
name|rss_base
operator|=
literal|0xffff
expr_stmt|;
else|else
block|{
comment|/* MPASS((val>> 16) == rss_size); */
name|vi
operator|->
name|rss_base
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
block|}
name|rc
operator|=
name|cxgbe_vi_attach
argument_list|(
name|dev
argument_list|,
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|t4_free_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|viid
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vcxgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|vi
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|vi
operator|->
name|pi
operator|->
name|adapter
expr_stmt|;
name|doom_vi
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|cxgbe_vi_detach
argument_list|(
name|vi
argument_list|)
expr_stmt|;
name|t4_free_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|viid
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_fatal_err
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"%s: encountered fatal error, adapter stopped.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bars_0_and_4
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|regs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map registers.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mmio_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_KDB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|msix_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map MSI-X BAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bar_2
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * T4: only iWARP driver uses the userspace doorbells.  There is no need 	 * to map it if RDMA is disabled. 	 */
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|sc
operator|->
name|rdmacaps
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|udbs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|udbs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|udbs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|udbs_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map doorbell BAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|udbs_base
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|t5_write_combine
condition|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* 			 * Enable write combining on BAR2.  This is the 			 * userspace doorbell BAR and is split into 128B 			 * (UDBS_SEG_SIZE) doorbell regions, each associated 			 * with an egress queue.  The first 64B has the doorbell 			 * and the second 64B can be used to submit a tx work 			 * request with an implicit doorbell. 			 */
name|rc
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sc
operator|->
name|udbs_base
argument_list|,
name|rman_get_size
argument_list|(
name|sc
operator|->
name|udbs_res
argument_list|)
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDBWC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't enable write combining: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_CFG
argument_list|,
name|V_STATSOURCE_T5
argument_list|(
literal|7
argument_list|)
operator||
name|V_STATMODE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|memwin_init
block|{
name|uint32_t
name|base
decl_stmt|;
name|uint32_t
name|aperture
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|memwin_init
name|t4_memwin
index|[
name|NUM_MEMWIN
index|]
init|=
block|{
block|{
name|MEMWIN0_BASE
block|,
name|MEMWIN0_APERTURE
block|}
block|,
block|{
name|MEMWIN1_BASE
block|,
name|MEMWIN1_APERTURE
block|}
block|,
block|{
name|MEMWIN2_BASE_T4
block|,
name|MEMWIN2_APERTURE_T4
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|memwin_init
name|t5_memwin
index|[
name|NUM_MEMWIN
index|]
init|=
block|{
block|{
name|MEMWIN0_BASE
block|,
name|MEMWIN0_APERTURE
block|}
block|,
block|{
name|MEMWIN1_BASE
block|,
name|MEMWIN1_APERTURE
block|}
block|,
block|{
name|MEMWIN2_BASE_T5
block|,
name|MEMWIN2_APERTURE_T5
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|memwin_init
modifier|*
name|mw_init
decl_stmt|;
name|struct
name|memwin
modifier|*
name|mw
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|bar0
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * Read low 32b of bar0 indirectly via the hardware backdoor 		 * mechanism.  Works from within PCI passthrough environments 		 * too, where rman_get_start() can return a different value.  We 		 * need to program the T4 memory window decoders with the actual 		 * addresses that will be coming across the PCIe link. 		 */
name|bar0
operator|=
name|t4_hw_pci_read_cfg4
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bar0
operator|&=
operator|(
name|uint32_t
operator|)
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|mw_init
operator|=
operator|&
name|t4_memwin
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* T5+ use the relative offset inside the PCIe BAR */
name|bar0
operator|=
literal|0
expr_stmt|;
name|mw_init
operator|=
operator|&
name|t5_memwin
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mw
operator|=
operator|&
name|sc
operator|->
name|memwin
index|[
literal|0
index|]
init|;
name|i
operator|<
name|NUM_MEMWIN
condition|;
name|i
operator|++
operator|,
name|mw_init
operator|++
operator|,
name|mw
operator|++
control|)
block|{
name|rw_init
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|,
literal|"memory window access"
argument_list|)
expr_stmt|;
name|mw
operator|->
name|mw_base
operator|=
name|mw_init
operator|->
name|base
expr_stmt|;
name|mw
operator|->
name|mw_aperture
operator|=
name|mw_init
operator|->
name|aperture
expr_stmt|;
name|mw
operator|->
name|mw_curpos
operator|=
literal|0
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|mw
operator|->
name|mw_base
operator|+
name|bar0
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|mw
operator|->
name|mw_aperture
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
name|position_memwin
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
block|}
comment|/* flush */
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Positions the memory window at the given address in the card's address space.  * There are some alignment requirements and the actual position may be at an  * address prior to the requested address.  mw->mw_curpos always has the actual  * position of the window.  */
end_comment

begin_function
specifier|static
name|void
name|position_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|struct
name|memwin
modifier|*
name|mw
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|MPASS
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|NUM_MEMWIN
argument_list|)
expr_stmt|;
name|mw
operator|=
operator|&
name|sc
operator|->
name|memwin
index|[
name|idx
index|]
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|pf
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|mw_curpos
operator|=
name|addr
operator|&
operator|~
literal|0xf
expr_stmt|;
comment|/* start must be 16B aligned */
block|}
else|else
block|{
name|pf
operator|=
name|V_PFNUM
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
expr_stmt|;
name|mw
operator|->
name|mw_curpos
operator|=
name|addr
operator|&
operator|~
literal|0x7f
expr_stmt|;
comment|/* start must be 128B aligned */
block|}
name|reg
operator|=
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_OFFSET
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|mw
operator|->
name|mw_curpos
operator||
name|pf
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_function
specifier|static
name|int
name|rw_via_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|struct
name|memwin
modifier|*
name|mw
decl_stmt|;
name|uint32_t
name|mw_end
decl_stmt|,
name|v
decl_stmt|;
name|MPASS
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|NUM_MEMWIN
argument_list|)
expr_stmt|;
comment|/* Memory can only be accessed in naturally aligned 4 byte units */
if|if
condition|(
name|addr
operator|&
literal|3
operator|||
name|len
operator|&
literal|3
operator|||
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mw
operator|=
operator|&
name|sc
operator|->
name|memwin
index|[
name|idx
index|]
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|rw_rlock
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
name|mw_end
operator|=
name|mw
operator|->
name|mw_curpos
operator|+
name|mw
operator|->
name|mw_aperture
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|mw_end
operator|||
name|addr
operator|<
name|mw
operator|->
name|mw_curpos
condition|)
block|{
comment|/* Will need to reposition the window */
if|if
condition|(
operator|!
name|rw_try_upgrade
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
block|}
name|rw_assert
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|position_memwin
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rw_downgrade
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
name|mw_end
operator|=
name|mw
operator|->
name|mw_curpos
operator|+
name|mw
operator|->
name|mw_aperture
expr_stmt|;
block|}
name|rw_assert
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|,
name|RA_RLOCKED
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|mw_end
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rw
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|mw
operator|->
name|mw_base
operator|+
name|addr
operator|-
name|mw
operator|->
name|mw_curpos
argument_list|)
expr_stmt|;
operator|*
name|val
operator|++
operator|=
name|le32toh
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
operator|*
name|val
operator|++
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|mw
operator|->
name|mw_base
operator|+
name|addr
operator|-
name|mw
operator|->
name|mw_curpos
argument_list|,
name|htole32
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
name|addr
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|mw
operator|->
name|mw_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_via_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|rw_via_memwin
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|addr
argument_list|,
name|val
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|write_via_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|rw_via_memwin
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|val
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_range_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|t4_range
operator|*
operator|)
name|a
operator|)
operator|->
name|start
operator|-
operator|(
operator|(
specifier|const
expr|struct
name|t4_range
operator|*
operator|)
name|b
operator|)
operator|->
name|start
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that the memory range specified by the addr/len pair is valid within  * the card's address space.  */
end_comment

begin_function
specifier|static
name|int
name|validate_mem_range
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|t4_range
name|mem_ranges
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|uint32_t
name|em
decl_stmt|,
name|addr_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|remaining
decl_stmt|;
comment|/* Memory can only be accessed in naturally aligned 4 byte units */
if|if
condition|(
name|addr
operator|&
literal|3
operator|||
name|len
operator|&
literal|3
operator|||
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Enabled memories */
name|em
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
name|r
operator|=
operator|&
name|mem_ranges
index|[
literal|0
index|]
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_ranges
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|em
operator|&
name|F_EDRAM0_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|r
operator|->
name|size
operator|=
name|G_EDRAM0_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|r
operator|->
name|start
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|r
operator|->
name|start
operator|&&
name|addr
operator|+
name|len
operator|<=
name|r
operator|->
name|start
operator|+
name|r
operator|->
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|em
operator|&
name|F_EDRAM1_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|r
operator|->
name|size
operator|=
name|G_EDRAM1_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|r
operator|->
name|start
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|r
operator|->
name|start
operator|&&
name|addr
operator|+
name|len
operator|<=
name|r
operator|->
name|start
operator|+
name|r
operator|->
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|em
operator|&
name|F_EXT_MEM_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|r
operator|->
name|size
operator|=
name|G_EXT_MEM_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|r
operator|->
name|start
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|r
operator|->
name|start
operator|&&
name|addr
operator|+
name|len
operator|<=
name|r
operator|->
name|start
operator|+
name|r
operator|->
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
operator|&&
name|em
operator|&
name|F_EXT_MEM1_ENABLE
condition|)
block|{
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY1_BAR
argument_list|)
expr_stmt|;
name|r
operator|->
name|size
operator|=
name|G_EXT_MEM1_SIZE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|r
operator|->
name|start
operator|=
name|G_EXT_MEM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|r
operator|->
name|start
operator|&&
name|addr
operator|+
name|len
operator|<=
name|r
operator|->
name|start
operator|+
name|r
operator|->
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|MPASS
argument_list|(
name|n
operator|<=
name|nitems
argument_list|(
name|mem_ranges
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
block|{
comment|/* Sort and merge the ranges. */
name|qsort
argument_list|(
name|mem_ranges
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|t4_range
argument_list|)
argument_list|,
name|t4_range_cmp
argument_list|)
expr_stmt|;
comment|/* Start from index 0 and examine the next n - 1 entries. */
name|r
operator|=
operator|&
name|mem_ranges
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|remaining
operator|=
name|n
operator|-
literal|1
init|;
name|remaining
operator|>
literal|0
condition|;
name|remaining
operator|--
operator|,
name|r
operator|++
control|)
block|{
name|MPASS
argument_list|(
name|r
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* r is a valid entry. */
name|next
operator|=
name|r
operator|+
literal|1
expr_stmt|;
name|MPASS
argument_list|(
name|next
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* and so is the next one. */
while|while
condition|(
name|r
operator|->
name|start
operator|+
name|r
operator|->
name|size
operator|>=
name|next
operator|->
name|start
condition|)
block|{
comment|/* Merge the next one into the current entry. */
name|r
operator|->
name|size
operator|=
name|max
argument_list|(
name|r
operator|->
name|start
operator|+
name|r
operator|->
name|size
argument_list|,
name|next
operator|->
name|start
operator|+
name|next
operator|->
name|size
argument_list|)
operator|-
name|r
operator|->
name|start
expr_stmt|;
name|n
operator|--
expr_stmt|;
comment|/* One fewer entry in total. */
if|if
condition|(
operator|--
name|remaining
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* short circuit */
name|next
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|r
operator|+
literal|1
condition|)
block|{
comment|/* 				 * Some entries were merged into r and next 				 * points to the first valid entry that couldn't 				 * be merged. 				 */
name|MPASS
argument_list|(
name|next
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* must be valid */
name|memcpy
argument_list|(
name|r
operator|+
literal|1
argument_list|,
name|next
argument_list|,
name|remaining
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 				 * This so that the foo->size assertion in the 				 * next iteration of the loop do the right 				 * thing for entries that were pulled up and are 				 * no longer valid. 				 */
name|MPASS
argument_list|(
name|n
operator|<
name|nitems
argument_list|(
name|mem_ranges
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mem_ranges
index|[
name|n
index|]
argument_list|,
operator|(
name|nitems
argument_list|(
name|mem_ranges
argument_list|)
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|t4_range
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|done
label|:
comment|/* Done merging the ranges. */
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
operator|&
name|mem_ranges
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|r
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|>=
name|r
operator|->
name|start
operator|&&
name|addr
operator|+
name|len
operator|<=
name|r
operator|->
name|start
operator|+
name|r
operator|->
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwmtype_to_hwmtype
parameter_list|(
name|int
name|mtype
parameter_list|)
block|{
switch|switch
condition|(
name|mtype
condition|)
block|{
case|case
name|FW_MEMTYPE_EDC0
case|:
return|return
operator|(
name|MEM_EDC0
operator|)
return|;
case|case
name|FW_MEMTYPE_EDC1
case|:
return|return
operator|(
name|MEM_EDC1
operator|)
return|;
case|case
name|FW_MEMTYPE_EXTMEM
case|:
return|return
operator|(
name|MEM_MC0
operator|)
return|;
case|case
name|FW_MEMTYPE_EXTMEM1
case|:
return|return
operator|(
name|MEM_MC1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: cannot translate fw mtype %d."
argument_list|,
name|__func__
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Verify that the memory range specified by the memtype/offset/len pair is  * valid and lies entirely within the memtype specified.  The global address of  * the start of the range is returned in addr.  */
end_comment

begin_function
specifier|static
name|int
name|validate_mt_off_len
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|mtype
parameter_list|,
name|uint32_t
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|em
decl_stmt|,
name|addr_len
decl_stmt|,
name|maddr
decl_stmt|;
comment|/* Memory can only be accessed in naturally aligned 4 byte units */
if|if
condition|(
name|off
operator|&
literal|3
operator|||
name|len
operator|&
literal|3
operator|||
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|em
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fwmtype_to_hwmtype
argument_list|(
name|mtype
argument_list|)
condition|)
block|{
case|case
name|MEM_EDC0
case|:
if|if
condition|(
operator|!
operator|(
name|em
operator|&
name|F_EDRAM0_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|MEM_EDC1
case|:
if|if
condition|(
operator|!
operator|(
name|em
operator|&
name|F_EDRAM1_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|MEM_MC
case|:
if|if
condition|(
operator|!
operator|(
name|em
operator|&
name|F_EXT_MEM_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
case|case
name|MEM_MC1
case|:
if|if
condition|(
operator|!
name|is_t5
argument_list|(
name|sc
argument_list|)
operator|||
operator|!
operator|(
name|em
operator|&
name|F_EXT_MEM1_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr_len
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY1_BAR
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|G_EXT_MEM1_BASE
argument_list|(
name|addr_len
argument_list|)
operator|<<
literal|20
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|addr
operator|=
name|maddr
operator|+
name|off
expr_stmt|;
comment|/* global address */
return|return
operator|(
name|validate_mem_range
argument_list|(
name|sc
argument_list|,
operator|*
name|addr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fixup_devlog_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|devlog_params
modifier|*
name|dparams
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|devlog
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|validate_mt_off_len
argument_list|(
name|sc
argument_list|,
name|dparams
operator|->
name|memtype
argument_list|,
name|dparams
operator|->
name|start
argument_list|,
name|dparams
operator|->
name|size
argument_list|,
operator|&
name|dparams
operator|->
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|n10g
parameter_list|,
name|int
name|n1g
parameter_list|,
name|int
name|num_vis
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
name|iaq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|itype
decl_stmt|,
name|navail
decl_stmt|,
name|nrxq10g
decl_stmt|,
name|nrxq1g
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nofldrxq10g
init|=
literal|0
decl_stmt|,
name|nofldrxq1g
init|=
literal|0
decl_stmt|;
name|int
name|nnmrxq10g
init|=
literal|0
decl_stmt|,
name|nnmrxq1g
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|iaq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iaq
argument_list|)
argument_list|)
expr_stmt|;
name|iaq
operator|->
name|ntxq10g
operator|=
name|t4_ntxq10g
expr_stmt|;
name|iaq
operator|->
name|ntxq1g
operator|=
name|t4_ntxq1g
expr_stmt|;
name|iaq
operator|->
name|nrxq10g
operator|=
name|nrxq10g
operator|=
name|t4_nrxq10g
expr_stmt|;
name|iaq
operator|->
name|nrxq1g
operator|=
name|nrxq1g
operator|=
name|t4_nrxq1g
expr_stmt|;
name|iaq
operator|->
name|rsrv_noflowq
operator|=
name|t4_rsrv_noflowq
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iaq
operator|->
name|nofldtxq10g
operator|=
name|t4_nofldtxq10g
expr_stmt|;
name|iaq
operator|->
name|nofldtxq1g
operator|=
name|t4_nofldtxq1g
expr_stmt|;
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|nofldrxq10g
operator|=
name|t4_nofldrxq10g
expr_stmt|;
name|iaq
operator|->
name|nofldrxq1g
operator|=
name|nofldrxq1g
operator|=
name|t4_nofldrxq1g
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmtxq10g
operator|=
name|t4_nnmtxq10g
expr_stmt|;
name|iaq
operator|->
name|nnmtxq1g
operator|=
name|t4_nnmtxq1g
expr_stmt|;
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|nnmrxq10g
operator|=
name|t4_nnmrxq10g
expr_stmt|;
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|nnmrxq1g
operator|=
name|t4_nnmrxq1g
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|itype
operator|=
name|INTR_MSIX
init|;
name|itype
condition|;
name|itype
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|itype
operator|&
name|t4_intr_types
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* not allowed */
if|if
condition|(
name|itype
operator|==
name|INTR_MSIX
condition|)
name|navail
operator|=
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
name|INTR_MSI
condition|)
name|navail
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
else|else
name|navail
operator|=
literal|1
expr_stmt|;
name|restart
label|:
if|if
condition|(
name|navail
operator|==
literal|0
condition|)
continue|continue;
name|iaq
operator|->
name|intr_type
operator|=
name|itype
expr_stmt|;
name|iaq
operator|->
name|intr_flags_10g
operator|=
literal|0
expr_stmt|;
name|iaq
operator|->
name|intr_flags_1g
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Best option: an interrupt vector for errors, one for the 		 * firmware event queue, and one for every rxq (NIC, TOE, and 		 * netmap). 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
operator|(
name|nrxq10g
operator|+
name|nofldrxq10g
operator|+
name|nnmrxq10g
operator|)
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
literal|2
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
operator|(
name|nrxq1g
operator|+
name|nofldrxq1g
operator|+
name|nnmrxq1g
operator|)
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
literal|2
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
operator|&&
operator|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
operator|)
condition|)
block|{
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|INTR_ALL
expr_stmt|;
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|INTR_ALL
expr_stmt|;
goto|goto
name|allocate
goto|;
block|}
comment|/* 		 * Second best option: a vector for errors, one for the firmware 		 * event queue, and vectors for either all the NIC rx queues or 		 * all the TOE rx queues.  The queues that don't get vectors 		 * will forward their interrupts to those that do. 		 * 		 * Note: netmap rx queues cannot be created early and so they 		 * can't be setup to receive forwarded interrupts for others. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
if|if
condition|(
name|nrxq10g
operator|>=
name|nofldrxq10g
condition|)
block|{
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|INTR_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
name|nrxq10g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|min
argument_list|(
name|nnmrxq10g
argument_list|,
name|nrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|INTR_OFLD_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
operator|*
name|nofldrxq10g
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|min
argument_list|(
name|nnmrxq10g
argument_list|,
name|nofldrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|nrxq1g
operator|>=
name|nofldrxq1g
condition|)
block|{
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|INTR_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
name|nrxq1g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
operator|(
name|num_vis
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|min
argument_list|(
name|nnmrxq1g
argument_list|,
name|nrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|INTR_OFLD_RXQ
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
operator|*
name|nofldrxq1g
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|min
argument_list|(
name|nnmrxq1g
argument_list|,
name|nofldrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
operator|&&
operator|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
operator|)
condition|)
goto|goto
name|allocate
goto|;
comment|/* 		 * Next best option: an interrupt vector for errors, one for the 		 * firmware event queue, and at least one per VI.  At this 		 * point we know we'll have to downsize nrxq and/or nofldrxq 		 * and/or nnmrxq to fit what's available to us. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|T4_EXTRA_INTR
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
operator|(
name|n10g
operator|+
name|n1g
operator|)
operator|*
name|num_vis
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
condition|)
block|{
name|int
name|leftover
init|=
name|navail
operator|-
name|iaq
operator|->
name|nirq
decl_stmt|;
if|if
condition|(
name|n10g
operator|>
literal|0
condition|)
block|{
name|int
name|target
init|=
name|max
argument_list|(
name|nrxq10g
argument_list|,
name|nofldrxq10g
argument_list|)
decl_stmt|;
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|nrxq10g
operator|>=
name|nofldrxq10g
condition|?
name|INTR_RXQ
else|:
name|INTR_OFLD_RXQ
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|target
operator|&&
name|leftover
operator|>=
name|n10g
condition|)
block|{
name|leftover
operator|-=
name|n10g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n10g
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|iaq
operator|->
name|nrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nrxq10g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nofldrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nnmrxq10g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|n1g
operator|>
literal|0
condition|)
block|{
name|int
name|target
init|=
name|max
argument_list|(
name|nrxq1g
argument_list|,
name|nofldrxq1g
argument_list|)
decl_stmt|;
name|iaq
operator|->
name|intr_flags_1g
operator|=
name|nrxq1g
operator|>=
name|nofldrxq1g
condition|?
name|INTR_RXQ
else|:
name|INTR_OFLD_RXQ
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|target
operator|&&
name|leftover
operator|>=
name|n1g
condition|)
block|{
name|leftover
operator|-=
name|n1g
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|+=
name|n1g
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|iaq
operator|->
name|nrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nrxq1g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|iaq
operator|->
name|nofldrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nofldrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq1g
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nnmrxq1g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|itype
operator|!=
name|INTR_MSI
operator|||
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
condition|)
goto|goto
name|allocate
goto|;
block|}
comment|/* 		 * Least desirable option: one interrupt vector for everything. 		 */
name|iaq
operator|->
name|nirq
operator|=
name|iaq
operator|->
name|nrxq10g
operator|=
name|iaq
operator|->
name|nrxq1g
operator|=
literal|1
expr_stmt|;
name|iaq
operator|->
name|intr_flags_10g
operator|=
name|iaq
operator|->
name|intr_flags_1g
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
name|iaq
operator|->
name|nofldrxq10g
operator|=
name|iaq
operator|->
name|nofldrxq1g
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|iaq
operator|->
name|nnmrxq10g
operator|=
name|iaq
operator|->
name|nnmrxq1g
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|allocate
label|:
name|navail
operator|=
name|iaq
operator|->
name|nirq
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|itype
operator|==
name|INTR_MSIX
condition|)
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
name|INTR_MSI
condition|)
name|rc
operator|=
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|navail
operator|==
name|iaq
operator|->
name|nirq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * Didn't get the number requested.  Use whatever number 			 * the kernel is willing to allocate (it's in navail). 			 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"fewer vectors than requested, "
literal|"type=%d, req=%d, rcvd=%d; will downshift req.\n"
argument_list|,
name|itype
argument_list|,
name|iaq
operator|->
name|nirq
argument_list|,
name|navail
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate vectors:%d, type=%d, req=%d, rcvd=%d\n"
argument_list|,
name|itype
argument_list|,
name|rc
argument_list|,
name|iaq
operator|->
name|nirq
argument_list|,
name|navail
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to find a usable interrupt type.  "
literal|"allowed=%d, msi-x=%d, msi=%d, intx=1"
argument_list|,
name|t4_intr_types
argument_list|,
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_VERSION
parameter_list|(
name|chip
parameter_list|)
value|( \     V_FW_HDR_FW_VER_MAJOR(chip##FW_VERSION_MAJOR) | \     V_FW_HDR_FW_VER_MINOR(chip##FW_VERSION_MINOR) | \     V_FW_HDR_FW_VER_MICRO(chip##FW_VERSION_MICRO) | \     V_FW_HDR_FW_VER_BUILD(chip##FW_VERSION_BUILD))
end_define

begin_define
define|#
directive|define
name|FW_INTFVER
parameter_list|(
name|chip
parameter_list|,
name|intf
parameter_list|)
value|(chip##FW_HDR_INTFVER_##intf)
end_define

begin_struct
struct|struct
name|fw_info
block|{
name|uint8_t
name|chip
decl_stmt|;
name|char
modifier|*
name|kld_name
decl_stmt|;
name|char
modifier|*
name|fw_mod_name
decl_stmt|;
name|struct
name|fw_hdr
name|fw_hdr
decl_stmt|;
comment|/* XXX: waste of space, need a sparse struct */
block|}
name|fw_info
index|[]
init|=
block|{
block|{
operator|.
name|chip
operator|=
name|CHELSIO_T4
block|,
operator|.
name|kld_name
operator|=
literal|"t4fw_cfg"
block|,
operator|.
name|fw_mod_name
operator|=
literal|"t4fw"
block|,
operator|.
name|fw_hdr
operator|=
block|{
operator|.
name|chip
operator|=
name|FW_HDR_CHIP_T4
block|,
operator|.
name|fw_ver
operator|=
name|htobe32_const
argument_list|(
name|FW_VERSION
argument_list|(
name|T4
argument_list|)
argument_list|)
block|,
operator|.
name|intfver_nic
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|NIC
argument_list|)
block|,
operator|.
name|intfver_vnic
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|VNIC
argument_list|)
block|,
operator|.
name|intfver_ofld
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|OFLD
argument_list|)
block|,
operator|.
name|intfver_ri
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|RI
argument_list|)
block|,
operator|.
name|intfver_iscsipdu
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|ISCSIPDU
argument_list|)
block|,
operator|.
name|intfver_iscsi
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|ISCSI
argument_list|)
block|,
operator|.
name|intfver_fcoepdu
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|FCOEPDU
argument_list|)
block|,
operator|.
name|intfver_fcoe
operator|=
name|FW_INTFVER
argument_list|(
name|T4
argument_list|,
name|FCOE
argument_list|)
block|, 		}
block|, 	}
block|,
block|{
operator|.
name|chip
operator|=
name|CHELSIO_T5
block|,
operator|.
name|kld_name
operator|=
literal|"t5fw_cfg"
block|,
operator|.
name|fw_mod_name
operator|=
literal|"t5fw"
block|,
operator|.
name|fw_hdr
operator|=
block|{
operator|.
name|chip
operator|=
name|FW_HDR_CHIP_T5
block|,
operator|.
name|fw_ver
operator|=
name|htobe32_const
argument_list|(
name|FW_VERSION
argument_list|(
name|T5
argument_list|)
argument_list|)
block|,
operator|.
name|intfver_nic
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|NIC
argument_list|)
block|,
operator|.
name|intfver_vnic
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|VNIC
argument_list|)
block|,
operator|.
name|intfver_ofld
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|OFLD
argument_list|)
block|,
operator|.
name|intfver_ri
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|RI
argument_list|)
block|,
operator|.
name|intfver_iscsipdu
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|ISCSIPDU
argument_list|)
block|,
operator|.
name|intfver_iscsi
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|ISCSI
argument_list|)
block|,
operator|.
name|intfver_fcoepdu
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|FCOEPDU
argument_list|)
block|,
operator|.
name|intfver_fcoe
operator|=
name|FW_INTFVER
argument_list|(
name|T5
argument_list|,
name|FCOE
argument_list|)
block|, 		}
block|, 	}
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|fw_info
modifier|*
name|find_fw_info
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|fw_info
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fw_info
index|[
name|i
index|]
operator|.
name|chip
operator|==
name|chip
condition|)
return|return
operator|(
operator|&
name|fw_info
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is the given firmware API compatible with the one the driver was compiled  * with?  */
end_comment

begin_function
specifier|static
name|int
name|fw_compatible
parameter_list|(
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr1
parameter_list|,
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr2
parameter_list|)
block|{
comment|/* short circuit if it's the exact same firmware version */
if|if
condition|(
name|hdr1
operator|->
name|chip
operator|==
name|hdr2
operator|->
name|chip
operator|&&
name|hdr1
operator|->
name|fw_ver
operator|==
name|hdr2
operator|->
name|fw_ver
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * XXX: Is this too conservative?  Perhaps I should limit this to the 	 * features that are supported in the driver. 	 */
define|#
directive|define
name|SAME_INTF
parameter_list|(
name|x
parameter_list|)
value|(hdr1->intfver_##x == hdr2->intfver_##x)
if|if
condition|(
name|hdr1
operator|->
name|chip
operator|==
name|hdr2
operator|->
name|chip
operator|&&
name|SAME_INTF
argument_list|(
name|nic
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|vnic
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|ofld
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|ri
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|iscsipdu
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|iscsi
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|fcoepdu
argument_list|)
operator|&&
name|SAME_INTF
argument_list|(
name|fcoe
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
undef|#
directive|undef
name|SAME_INTF
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware in the KLD is usable, but should it be installed?  This routine  * explains itself in detail if it indicates the KLD firmware should be  * installed.  */
end_comment

begin_function
specifier|static
name|int
name|should_install_kld_fw
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|card_fw_usable
parameter_list|,
name|int
name|k
parameter_list|,
name|int
name|c
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
if|if
condition|(
operator|!
name|card_fw_usable
condition|)
block|{
name|reason
operator|=
literal|"incompatible or unusable"
expr_stmt|;
goto|goto
name|install
goto|;
block|}
if|if
condition|(
name|k
operator|>
name|c
condition|)
block|{
name|reason
operator|=
literal|"older than the version bundled with this driver"
expr_stmt|;
goto|goto
name|install
goto|;
block|}
if|if
condition|(
name|t4_fw_install
operator|==
literal|2
operator|&&
name|k
operator|!=
name|c
condition|)
block|{
name|reason
operator|=
literal|"different than the version bundled with this driver"
expr_stmt|;
goto|goto
name|install
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|install
label|:
if|if
condition|(
name|t4_fw_install
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware on card (%u.%u.%u.%u) is %s, "
literal|"but the driver is prohibited from installing a different "
literal|"firmware on the card.\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|c
argument_list|)
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware on card (%u.%u.%u.%u) is %s, "
literal|"installing firmware %u.%u.%u.%u on card.\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|c
argument_list|)
argument_list|,
name|reason
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Establish contact with the firmware and determine if we are the master driver  * or not, and whether we are responsible for chip initialization.  */
end_comment

begin_function
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
init|=
name|NULL
decl_stmt|,
modifier|*
name|default_cfg
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|pf
decl_stmt|,
name|card_fw_usable
decl_stmt|,
name|kld_fw_usable
decl_stmt|,
name|need_fw_reset
init|=
literal|1
decl_stmt|;
name|enum
name|dev_state
name|state
decl_stmt|;
name|struct
name|fw_info
modifier|*
name|fw_info
decl_stmt|;
name|struct
name|fw_hdr
modifier|*
name|card_fw
decl_stmt|;
comment|/* fw on the card */
specifier|const
name|struct
name|fw_hdr
modifier|*
name|kld_fw
decl_stmt|;
comment|/* fw in the KLD */
specifier|const
name|struct
name|fw_hdr
modifier|*
name|drv_fw
decl_stmt|;
comment|/* fw header the driver was compiled 					   against */
comment|/* Contact firmware. */
name|rc
operator|=
name|t4_fw_hello
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|MASTER_MAY
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
operator|||
name|state
operator|==
name|DEV_STATE_ERR
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to connect to the firmware: %d, %d.\n"
argument_list|,
name|rc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|pf
operator|=
name|rc
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|sc
operator|->
name|mbox
condition|)
name|sc
operator|->
name|flags
operator||=
name|MASTER_PF
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|DEV_STATE_UNINIT
condition|)
block|{
comment|/* 		 * We didn't get to be the master so we definitely won't be 		 * configuring the chip.  It's a bug if someone else hasn't 		 * configured it already. 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't be master(%d), "
literal|"device not already initialized either(%d).\n"
argument_list|,
name|rc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
comment|/* This is the firmware whose headers the driver was compiled against */
name|fw_info
operator|=
name|find_fw_info
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_info
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to look up firmware information for chip %d.\n"
argument_list|,
name|chip_id
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|drv_fw
operator|=
operator|&
name|fw_info
operator|->
name|fw_hdr
expr_stmt|;
comment|/* 	 * The firmware KLD contains many modules.  The KLD name is also the 	 * name of the module that contains the default config file. 	 */
name|default_cfg
operator|=
name|firmware_get
argument_list|(
name|fw_info
operator|->
name|kld_name
argument_list|)
expr_stmt|;
comment|/* Read the header of the firmware on the card */
name|card_fw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|card_fw
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_read_flash
argument_list|(
name|sc
argument_list|,
name|FLASH_FW_START
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|card_fw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|card_fw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|card_fw_usable
operator|=
name|fw_compatible
argument_list|(
name|drv_fw
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|card_fw
argument_list|)
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to read card's firmware header: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|card_fw_usable
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This is the firmware in the KLD */
name|fw
operator|=
name|firmware_get
argument_list|(
name|fw_info
operator|->
name|fw_mod_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
block|{
name|kld_fw
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
name|kld_fw_usable
operator|=
name|fw_compatible
argument_list|(
name|drv_fw
argument_list|,
name|kld_fw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kld_fw
operator|=
name|NULL
expr_stmt|;
name|kld_fw_usable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|card_fw_usable
operator|&&
name|card_fw
operator|->
name|fw_ver
operator|==
name|drv_fw
operator|->
name|fw_ver
operator|&&
operator|(
operator|!
name|kld_fw_usable
operator|||
name|kld_fw
operator|->
name|fw_ver
operator|==
name|drv_fw
operator|->
name|fw_ver
operator|)
condition|)
block|{
comment|/* 		 * Common case: the firmware on the card is an exact match and 		 * the KLD is an exact match too, or the KLD is 		 * absent/incompatible.  Note that t4_fw_install = 2 is ignored 		 * here -- use cxgbetool loadfw if you want to reinstall the 		 * same firmware as the one on the card. 		 */
block|}
elseif|else
if|if
condition|(
name|kld_fw_usable
operator|&&
name|state
operator|==
name|DEV_STATE_UNINIT
operator|&&
name|should_install_kld_fw
argument_list|(
name|sc
argument_list|,
name|card_fw_usable
argument_list|,
name|be32toh
argument_list|(
name|kld_fw
operator|->
name|fw_ver
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|card_fw
operator|->
name|fw_ver
argument_list|)
argument_list|)
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_fw_upgrade
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to install firmware: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Installed successfully, update the cached header too. */
name|memcpy
argument_list|(
name|card_fw
argument_list|,
name|kld_fw
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|card_fw
argument_list|)
argument_list|)
expr_stmt|;
name|card_fw_usable
operator|=
literal|1
expr_stmt|;
name|need_fw_reset
operator|=
literal|0
expr_stmt|;
comment|/* already reset as part of load_fw */
block|}
if|if
condition|(
operator|!
name|card_fw_usable
condition|)
block|{
name|uint32_t
name|d
decl_stmt|,
name|c
decl_stmt|,
name|k
decl_stmt|;
name|d
operator|=
name|ntohl
argument_list|(
name|drv_fw
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
name|c
operator|=
name|ntohl
argument_list|(
name|card_fw
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
name|k
operator|=
name|kld_fw
condition|?
name|ntohl
argument_list|(
name|kld_fw
operator|->
name|fw_ver
argument_list|)
else|:
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find a usable firmware: "
literal|"fw_install %d, chip state %d, "
literal|"driver compiled with %d.%d.%d.%d, "
literal|"card has %d.%d.%d.%d, KLD has %d.%d.%d.%d\n"
argument_list|,
name|t4_fw_install
argument_list|,
name|state
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|d
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|c
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|k
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* We're using whatever's on the card and it's known to be good. */
name|sc
operator|->
name|params
operator|.
name|fw_vers
operator|=
name|ntohl
argument_list|(
name|card_fw
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|)
expr_stmt|;
name|t4_get_tp_version
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|tp_vers
argument_list|)
expr_stmt|;
comment|/* Reset device */
if|if
condition|(
name|need_fw_reset
operator|&&
operator|(
name|rc
operator|=
operator|-
name|t4_fw_reset
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|F_PIORSTMODE
operator||
name|F_PIORST
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware reset failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ETIMEDOUT
operator|&&
name|rc
operator|!=
name|EIO
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|flags
operator||=
name|FW_OK
expr_stmt|;
name|rc
operator|=
name|get_params__pre_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* Partition adapter resources as specified in the config file. */
if|if
condition|(
name|state
operator|==
name|DEV_STATE_UNINIT
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|MASTER_PF
argument_list|,
operator|(
literal|"%s: trying to change chip settings when not master."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|partition_resources
argument_list|(
name|sc
argument_list|,
name|default_cfg
argument_list|,
name|fw_info
operator|->
name|kld_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|t4_tweak_chip_settings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get basic stuff going */
name|rc
operator|=
operator|-
name|t4_fw_initialize
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"fw init failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"pf%d"
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cfcsum
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|card_fw
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_cfg
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|default_cfg
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_PARAM_DEV
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_##param))
end_define

begin_define
define|#
directive|define
name|FW_PARAM_PFVF
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_PFVF) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_PFVF_##param))
end_define

begin_comment
comment|/*  * Partition chip resources for use between various PFs, VFs, etc.  */
end_comment

begin_function
specifier|static
name|int
name|partition_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
name|default_cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|name_prefix
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|fw_caps_config_cmd
name|caps
decl_stmt|;
name|uint32_t
name|mtype
decl_stmt|,
name|moff
decl_stmt|,
name|finicsum
decl_stmt|,
name|cfcsum
decl_stmt|;
comment|/* 	 * Figure out what configuration file to use.  Pick the default config 	 * file for the card if the user hasn't specified one explicitly. 	 */
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|t4_cfg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|t4_cfg_file
argument_list|,
name|DEFAULT_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|t4_cfg_file
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Card specific overrides go here. */
if|if
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|==
literal|0x440a
condition|)
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
name|UWIRE_CF
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_fpga
argument_list|(
name|sc
argument_list|)
condition|)
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
name|FPGA_CF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to load another module if the profile is anything except 	 * "default" or "flash". 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|DEFAULT_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|FLASH_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|s
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%s_%s"
argument_list|,
name|name_prefix
argument_list|,
name|sc
operator|->
name|cfg_file
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|firmware_get
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|default_cfg
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to load module \"%s\" for "
literal|"configuration profile \"%s\", will use "
literal|"the default config file instead.\n"
argument_list|,
name|s
argument_list|,
name|sc
operator|->
name|cfg_file
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|DEFAULT_CF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to load module \"%s\" for "
literal|"configuration profile \"%s\", will use "
literal|"the config file on the card's flash "
literal|"instead.\n"
argument_list|,
name|s
argument_list|,
name|sc
operator|->
name|cfg_file
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|FLASH_CF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|DEFAULT_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|default_cfg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"default config file not available, will use the config "
literal|"file on the card's flash instead.\n"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|FLASH_CF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|,
name|FLASH_CF
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cfg_file
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|cflen
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|cfdata
decl_stmt|;
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|,
name|addr
decl_stmt|;
name|KASSERT
argument_list|(
name|cfg
operator|!=
name|NULL
operator|||
name|default_cfg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no config to upload"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Ask the firmware where it wants us to upload the config file. 		 */
name|param
operator|=
name|FW_PARAM_DEV
argument_list|(
name|CF
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* No support for config file?  Shouldn't happen. */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query config file location: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtype
operator|=
name|G_FW_PARAMS_PARAM_Y
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|moff
operator|=
name|G_FW_PARAMS_PARAM_Z
argument_list|(
name|val
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* 		 * XXX: sheer laziness.  We deliberately added 4 bytes of 		 * useless stuffing/comments at the end of the config file so 		 * it's ok to simply throw away the last remaining bytes when 		 * the config file is not an exact multiple of 4.  This also 		 * helps with the validate_mt_off_len check. 		 */
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
block|{
name|cflen
operator|=
name|cfg
operator|->
name|datasize
operator|&
operator|~
literal|3
expr_stmt|;
name|cfdata
operator|=
name|cfg
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|cflen
operator|=
name|default_cfg
operator|->
name|datasize
operator|&
operator|~
literal|3
expr_stmt|;
name|cfdata
operator|=
name|default_cfg
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
name|cflen
operator|>
name|FLASH_CFG_MAX_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"config file too long (%d, max allowed is %d).  "
literal|"Will try to use the config on the card, if any.\n"
argument_list|,
name|cflen
argument_list|,
name|FLASH_CFG_MAX_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|use_config_on_flash
goto|;
block|}
name|rc
operator|=
name|validate_mt_off_len
argument_list|(
name|sc
argument_list|,
name|mtype
argument_list|,
name|moff
argument_list|,
name|cflen
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: addr (%d/0x%x) or len %d is not valid: %d.  "
literal|"Will try to use the config on the card, if any.\n"
argument_list|,
name|__func__
argument_list|,
name|mtype
argument_list|,
name|moff
argument_list|,
name|cflen
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|use_config_on_flash
goto|;
block|}
name|write_via_memwin
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|,
name|cfdata
argument_list|,
name|cflen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|use_config_on_flash
label|:
name|mtype
operator|=
name|FW_MEMTYPE_FLASH
expr_stmt|;
name|moff
operator|=
name|t4_flash_cfg_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_CAPS_CONFIG_CMD_CFVALID
operator||
name|V_FW_CAPS_CONFIG_CMD_MEMTYPE_CF
argument_list|(
name|mtype
argument_list|)
operator||
name|V_FW_CAPS_CONFIG_CMD_MEMADDR64K_CF
argument_list|(
name|moff
operator|>>
literal|16
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to pre-process config file: %d "
literal|"(mtype %d, moff 0x%x).\n"
argument_list|,
name|rc
argument_list|,
name|mtype
argument_list|,
name|moff
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|finicsum
operator|=
name|be32toh
argument_list|(
name|caps
operator|.
name|finicsum
argument_list|)
expr_stmt|;
name|cfcsum
operator|=
name|be32toh
argument_list|(
name|caps
operator|.
name|cfcsum
argument_list|)
expr_stmt|;
if|if
condition|(
name|finicsum
operator|!=
name|cfcsum
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING: config file checksum mismatch: %08x %08x\n"
argument_list|,
name|finicsum
argument_list|,
name|cfcsum
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cfcsum
operator|=
name|cfcsum
expr_stmt|;
define|#
directive|define
name|LIMIT_CAPS
parameter_list|(
name|x
parameter_list|)
value|do { \ 	caps.x&= htobe16(t4_##x##_allowed); \ } while (0)
comment|/* 	 * Let the firmware know what features will (not) be used so it can tune 	 * things accordingly. 	 */
name|LIMIT_CAPS
argument_list|(
name|linkcaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|niccaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|toecaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|rdmacaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|iscsicaps
argument_list|)
expr_stmt|;
name|LIMIT_CAPS
argument_list|(
name|fcoecaps
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|LIMIT_CAPS
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to process config file: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|cfg
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve parameters that are needed (or nice to have) very early.  */
end_comment

begin_function
specifier|static
name|int
name|get_params__pre_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|param
index|[
literal|2
index|]
decl_stmt|,
name|val
index|[
literal|2
index|]
decl_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|PORTVEC
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|CCLK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query parameters (pre_init): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|params
operator|.
name|portvec
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|nports
operator|=
name|bitcount32
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
comment|/* Read device log parameters. */
name|rc
operator|=
operator|-
name|t4_init_devlog_params
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|fixup_devlog_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get devlog parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* devlog isn't critical for device operation */
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve various parameters that are of interest to the driver.  The device  * has been initialized by the firmware at this point.  */
end_comment

begin_function
specifier|static
name|int
name|get_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|param
index|[
literal|7
index|]
decl_stmt|,
name|val
index|[
literal|7
index|]
decl_stmt|;
name|struct
name|fw_caps_config_cmd
name|caps
decl_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|IQFLINT_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|EQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|L2T_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|L2T_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query parameters (post_init): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|sge
operator|.
name|iq_start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eq_start
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nftids
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ftid_min
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ftid_max
operator|=
name|val
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|size
operator|<=
name|L2T_SIZE
argument_list|,
operator|(
literal|"%s: L2 table size (%u) larger than expected (%u)"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|vres
operator|.
name|l2t
operator|.
name|size
operator|,
name|L2T_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* get capabilites */
name|bzero
argument_list|(
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|.
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|caps
operator|.
name|cfvalid_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
name|caps
argument_list|)
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get card capabilities: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
define|#
directive|define
name|READ_CAPS
parameter_list|(
name|x
parameter_list|)
value|do { \ 	sc->x = htobe16(caps.x); \ } while (0)
name|READ_CAPS
argument_list|(
name|linkcaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|niccaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|toecaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|rdmacaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|iscsicaps
argument_list|)
expr_stmt|;
name|READ_CAPS
argument_list|(
name|fcoecaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|niccaps
operator|&
name|FW_CAPS_CONFIG_NIC_ETHOFLD
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ETHOFLD_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ETHOFLD_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|FLOWC_BUFFIFO_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query NIC parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|tids
operator|.
name|etid_base
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|etid_min
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|netids
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|netids
operator|=
name|sc
operator|->
name|tids
operator|.
name|netids
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|eo_wr_cred
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ethoffload
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|toecaps
condition|)
block|{
comment|/* query offload-related parameters */
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|NTID
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|FLOWC_BUFFIFO_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query TOE parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|natids
operator|=
name|min
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|/
literal|2
argument_list|,
name|MAX_ATIDS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|stid_base
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nstids
operator|=
name|val
index|[
literal|2
index|]
operator|-
name|val
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|start
operator|=
name|val
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|size
operator|=
name|val
index|[
literal|4
index|]
operator|-
name|val
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ofldq_wr_cred
operator|=
name|val
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|offload
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rdmacaps
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query RDMA parameters(1): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|size
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SQRQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SQRQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CQ_END
argument_list|)
expr_stmt|;
name|param
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|OCQ_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|OCQ_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query RDMA parameters(2): %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|qp
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|qp
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|cq
operator|.
name|start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|cq
operator|.
name|size
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|iscsicaps
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_START
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|param
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query iSCSI parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * We've got the params we wanted to query via the firmware.  Now grab 	 * some others directly from the chip. 	 */
name|rc
operator|=
name|t4_read_chip_settings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_params__post_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|;
comment|/* ask for encapsulated CPLs */
name|param
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|CPLFW4MSG_ENCAP
argument_list|)
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|FW_PARAM_PFVF
end_undef

begin_undef
undef|#
directive|undef
name|FW_PARAM_DEV
end_undef

begin_function
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|adapter_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Chelsio %s %sNIC (rev %d), S/N:%s, "
literal|"P/N:%s, E/C:%s"
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|id
argument_list|,
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|?
literal|"R"
else|:
literal|""
argument_list|,
name|chip_rev
argument_list|(
name|sc
argument_list|)
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|sn
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|pn
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|ec
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|ifmedia
modifier|*
name|media
parameter_list|)
block|{
name|int
name|m
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
name|media
argument_list|)
expr_stmt|;
name|m
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|port_type
condition|)
block|{
case|case
name|FW_PORT_TYPE_BT_XFI
case|:
case|case
name|FW_PORT_TYPE_BT_XAUI
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|FW_PORT_TYPE_BT_SGMII
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_CX4
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_QSFP_10G
case|:
case|case
name|FW_PORT_TYPE_SFP
case|:
case|case
name|FW_PORT_TYPE_FIBER_XFI
case|:
case|case
name|FW_PORT_TYPE_FIBER_XAUI
case|:
switch|switch
condition|(
name|pi
operator|->
name|mod_type
condition|)
block|{
case|case
name|FW_PORT_MOD_TYPE_LR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_SR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_LRM
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_TWINAX_PASSIVE
case|:
case|case
name|FW_PORT_MOD_TYPE_TWINAX_ACTIVE
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NONE
case|:
name|m
operator|&=
operator|~
name|IFM_FDX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NA
case|:
case|case
name|FW_PORT_MOD_TYPE_ER
case|:
default|default:
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"unknown port_type (%d), mod_type (%d)\n"
argument_list|,
name|pi
operator|->
name|port_type
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FW_PORT_TYPE_QSFP
case|:
switch|switch
condition|(
name|pi
operator|->
name|mod_type
condition|)
block|{
case|case
name|FW_PORT_MOD_TYPE_LR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_LR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_LR4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_SR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_SR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_SR4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_TWINAX_PASSIVE
case|:
case|case
name|FW_PORT_MOD_TYPE_TWINAX_ACTIVE
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_CR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_40G_CR4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NONE
case|:
name|m
operator|&=
operator|~
name|IFM_FDX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"unknown port_type (%d), mod_type (%d)\n"
argument_list|,
name|pi
operator|->
name|port_type
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"unknown port_type (%d), mod_type (%d)\n"
argument_list|,
name|pi
operator|->
name|port_type
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_MAC_EXACT_CHUNK
value|7
end_define

begin_comment
comment|/*  * Program the port's XGMAC based on parameters in ifnet.  The caller also  * indicates which parameters should be programmed (the rest are left alone).  */
end_comment

begin_function
name|int
name|update_mac_settings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|mtu
init|=
operator|-
literal|1
decl_stmt|,
name|promisc
init|=
operator|-
literal|1
decl_stmt|,
name|allmulti
init|=
operator|-
literal|1
decl_stmt|,
name|vlanex
init|=
operator|-
literal|1
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|flags
argument_list|,
operator|(
literal|"%s: not told what to update."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_MTU
condition|)
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_PROMISC
condition|)
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_ALLMULTI
condition|)
name|allmulti
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_VLANEX
condition|)
name|vlanex
operator|=
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|XGMAC_MTU
operator||
name|XGMAC_PROMISC
operator||
name|XGMAC_ALLMULTI
operator||
name|XGMAC_VLANEX
operator|)
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_set_rxmode
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
name|mtu
argument_list|,
name|promisc
argument_list|,
name|allmulti
argument_list|,
literal|1
argument_list|,
name|vlanex
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"set_rxmode (%x) failed: %d\n"
argument_list|,
name|flags
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_UCADDR
condition|)
block|{
name|uint8_t
name|ucaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ucaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ucaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_change_mac
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
name|vi
operator|->
name|xact_addr_filt
argument_list|,
name|ucaddr
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"change_mac failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
else|else
block|{
name|vi
operator|->
name|xact_addr_filt
operator|=
name|rc
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_MCADDRS
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|mcaddr
index|[
name|FW_MAC_EXACT_CHUNK
index|]
decl_stmt|;
name|int
name|del
init|=
literal|1
decl_stmt|;
name|uint64_t
name|hash
init|=
literal|0
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcaddr
index|[
name|i
index|]
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ETHER_IS_MULTICAST
argument_list|(
name|mcaddr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FW_MAC_EXACT_CHUNK
condition|)
block|{
name|rc
operator|=
name|t4_alloc_mac_filt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
name|del
argument_list|,
name|i
argument_list|,
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to add mc address"
literal|" %02x:%02x:%02x:"
literal|"%02x:%02x:%02x rc=%d\n"
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|3
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|4
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|5
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mcfail
goto|;
block|}
name|del
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|t4_alloc_mac_filt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
name|del
argument_list|,
name|i
argument_list|,
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to add mc address"
literal|" %02x:%02x:%02x:"
literal|"%02x:%02x:%02x rc=%d\n"
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|3
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|4
index|]
argument_list|,
name|mcaddr
index|[
name|j
index|]
index|[
literal|5
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mcfail
goto|;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_set_addr_hash
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to set mc address hash: %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|mcfail
label|:
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * {begin|end}_synchronized_op must be called from the same thread.  */
end_comment

begin_function
name|int
name|begin_synchronized_op
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|pri
decl_stmt|;
ifdef|#
directive|ifdef
name|WITNESS
comment|/* the caller thinks it's ok to sleep, but is it really? */
if|if
condition|(
name|flags
operator|&
name|SLEEP_OK
condition|)
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"begin_synchronized_op"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|INTR_OK
condition|)
name|pri
operator|=
name|PCATCH
expr_stmt|;
else|else
name|pri
operator|=
literal|0
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|vi
operator|&&
name|IS_DOOMED
argument_list|(
name|vi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SLEEP_OK
operator|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|pri
argument_list|,
name|wmesg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sc
operator|->
name|last_op
operator|=
name|wmesg
expr_stmt|;
name|sc
operator|->
name|last_op_thr
operator|=
name|curthread
expr_stmt|;
name|sc
operator|->
name|last_op_flags
operator|=
name|flags
expr_stmt|;
endif|#
directive|endif
name|done
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HOLD_LOCK
operator|)
operator|||
name|rc
condition|)
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tell if_ioctl and if_init that the VI is going away.  This is  * special variant of begin_synchronized_op and must be paired with a  * call to end_synchronized_op.  */
end_comment

begin_function
name|void
name|doom_vi
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SET_DOOMED
argument_list|(
name|vi
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|0
argument_list|,
literal|"t4detach"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sc
operator|->
name|last_op
operator|=
literal|"t4detach"
expr_stmt|;
name|sc
operator|->
name|last_op_thr
operator|=
name|curthread
expr_stmt|;
name|sc
operator|->
name|last_op_flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * {begin|end}_synchronized_op must be called from the same thread.  */
end_comment

begin_function
name|void
name|end_synchronized_op
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOCK_HELD
condition|)
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already running */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|adapter_full_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
if|if
condition|(
operator|!
operator|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|vi_full_init
argument_list|(
name|vi
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|ifp
argument_list|,
name|XGMAC_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Can't fail from this point onwards.  Review cxgbe_uninit_synchronized 	 * if this changes. 	 */
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|eq
operator|.
name|flags
operator||=
name|EQ_ENABLED
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The first iq of the first port to come up is used for tracing. 	 */
if|if
condition|(
name|sc
operator|->
name|traceq
operator|<
literal|0
operator|&&
name|IS_MAIN_VI
argument_list|(
name|vi
argument_list|)
condition|)
block|{
name|sc
operator|->
name|traceq
operator|=
name|sc
operator|->
name|sge
operator|.
name|rxq
index|[
name|vi
operator|->
name|first_rxq
index|]
operator|.
name|iq
operator|.
name|abs_id
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
name|A_MPS_TRC_RSS_CONTROL
else|:
name|A_MPS_T5_TRC_RSS_CONTROL
argument_list|,
name|V_RSSCONTROL
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|V_QUEUENUMBER
argument_list|(
name|sc
operator|->
name|traceq
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|flags
operator||=
name|HAS_TRACEQ
expr_stmt|;
block|}
comment|/* all ok */
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|pi
operator|->
name|up_vis
operator|++
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|nvi
operator|>
literal|1
condition|)
name|callout_reset
argument_list|(
operator|&
name|vi
operator|->
name|tick
argument_list|,
name|hz
argument_list|,
name|vi_tick
argument_list|,
name|vi
argument_list|)
expr_stmt|;
else|else
name|callout_reset
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|,
name|cxgbe_tick
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|cxgbe_uninit_synchronized
argument_list|(
name|vi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|,
operator|(
literal|"uninited VI is running"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Disable the VI so that all its data in either direction is discarded 	 * by the MPS.  Leave everything else (the queues, interrupts, and 1Hz 	 * tick) intact as the TP can deliver negative advice or data that it's 	 * holding in its RAM (for an offloaded connection) even after the VI is 	 * disabled. 	 */
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"disable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|eq
operator|.
name|flags
operator|&=
operator|~
name|EQ_ENABLED
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|nvi
operator|==
literal|1
condition|)
name|callout_stop
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
else|else
name|callout_stop
argument_list|(
operator|&
name|vi
operator|->
name|tick
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|pi
operator|->
name|up_vis
operator|--
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|up_vis
operator|>
literal|0
condition|)
block|{
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|linkdnrc
operator|=
operator|-
literal|1
expr_stmt|;
name|t4_os_link_changed
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * It is ok for this function to fail midway and return right away.  t4_detach  * will walk the entire sc->irq list and clean up whatever is valid.  */
end_comment

begin_function
specifier|static
name|int
name|setup_intr_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|rid
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|,
name|v
decl_stmt|;
name|char
name|s
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|irq
modifier|*
name|irq
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RSS
name|int
name|nbuckets
init|=
name|rss_getnumbuckets
argument_list|()
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Setup interrupts. 	 */
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
index|[
literal|0
index|]
expr_stmt|;
name|rid
operator|=
name|sc
operator|->
name|intr_type
operator|==
name|INTR_INTX
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
condition|)
return|return
operator|(
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_all
argument_list|,
name|sc
argument_list|,
literal|"all"
argument_list|)
operator|)
return|;
comment|/* Multiple interrupts. */
name|KASSERT
argument_list|(
name|sc
operator|->
name|intr_count
operator|>=
name|T4_EXTRA_INTR
operator|+
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
literal|"%s: too few intr."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* The first one is always error intr */
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_err
argument_list|,
name|sc
argument_list|,
literal|"err"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
comment|/* The second one is always the firmware event queue */
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr_evt
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
argument_list|,
literal|"evt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|p
argument_list|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
name|vi
operator|->
name|first_intr
operator|=
name|rid
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_NETMAP
condition|)
block|{
name|for_each_nm_rxq
argument_list|(
argument|vi
argument_list|,
argument|q
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d-%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_nm_intr
argument_list|,
name|nm_rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
name|vi
operator|->
name|nintr
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_RXQ
condition|)
block|{
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|q
argument_list|,
argument|rxq
argument_list|)
block|{
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d.%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d(%d).%d"
argument_list|,
name|p
argument_list|,
name|v
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr
argument_list|,
name|rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
ifdef|#
directive|ifdef
name|RSS
name|bus_bind_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|rss_getcpu
argument_list|(
name|q
operator|%
name|nbuckets
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
name|vi
operator|->
name|nintr
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_OFLD_RXQ
condition|)
block|{
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|q
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d,%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_alloc_irq
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|t4_intr
argument_list|,
name|ofld_rxq
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|irq
operator|++
expr_stmt|;
name|rid
operator|++
expr_stmt|;
name|vi
operator|->
name|nintr
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
name|MPASS
argument_list|(
name|irq
operator|==
operator|&
name|sc
operator|->
name|irq
index|[
name|sc
operator|->
name|intr_count
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adapter_full_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: FULL_INIT_DONE already"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * queues that belong to the adapter (not any particular port). 	 */
name|rc
operator|=
name|t4_setup_adapter_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|=
name|taskqueue_create
argument_list|(
literal|"t4 taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate task queue %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s tq%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|t4_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FULL_INIT_DONE
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|adapter_full_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adapter_full_uninit
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_teardown_adapter_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
operator|&&
name|sc
operator|->
name|tq
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FULL_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_define
define|#
directive|define
name|SUPPORTED_RSS_HASHTYPES
value|(RSS_HASHTYPE_RSS_IPV4 | \     RSS_HASHTYPE_RSS_TCP_IPV4 | RSS_HASHTYPE_RSS_IPV6 | \     RSS_HASHTYPE_RSS_TCP_IPV6 | RSS_HASHTYPE_RSS_UDP_IPV4 | \     RSS_HASHTYPE_RSS_UDP_IPV6)
end_define

begin_comment
comment|/* Translates kernel hash types to hardware. */
end_comment

begin_function
specifier|static
name|int
name|hashconfig_to_hashen
parameter_list|(
name|int
name|hashconfig
parameter_list|)
block|{
name|int
name|hashen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hashconfig
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
name|hashen
operator||=
name|F_FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN
expr_stmt|;
if|if
condition|(
name|hashconfig
operator|&
name|RSS_HASHTYPE_RSS_IPV6
condition|)
name|hashen
operator||=
name|F_FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN
expr_stmt|;
if|if
condition|(
name|hashconfig
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
condition|)
block|{
name|hashen
operator||=
name|F_FW_RSS_VI_CONFIG_CMD_UDPEN
operator||
name|F_FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN
expr_stmt|;
block|}
if|if
condition|(
name|hashconfig
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6
condition|)
block|{
name|hashen
operator||=
name|F_FW_RSS_VI_CONFIG_CMD_UDPEN
operator||
name|F_FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN
expr_stmt|;
block|}
if|if
condition|(
name|hashconfig
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
condition|)
name|hashen
operator||=
name|F_FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN
expr_stmt|;
if|if
condition|(
name|hashconfig
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6
condition|)
name|hashen
operator||=
name|F_FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN
expr_stmt|;
return|return
operator|(
name|hashen
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Translates hardware hash types to kernel. */
end_comment

begin_function
specifier|static
name|int
name|hashen_to_hashconfig
parameter_list|(
name|int
name|hashen
parameter_list|)
block|{
name|int
name|hashconfig
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hashen
operator|&
name|F_FW_RSS_VI_CONFIG_CMD_UDPEN
condition|)
block|{
comment|/* 		 * If UDP hashing was enabled it must have been enabled for 		 * either IPv4 or IPv6 (inclusive or).  Enabling UDP without 		 * enabling any 4-tuple hash is nonsense configuration. 		 */
name|MPASS
argument_list|(
name|hashen
operator|&
operator|(
name|F_FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN
operator||
name|F_FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashen
operator|&
name|F_FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN
condition|)
name|hashconfig
operator||=
name|RSS_HASHTYPE_RSS_UDP_IPV4
expr_stmt|;
if|if
condition|(
name|hashen
operator|&
name|F_FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN
condition|)
name|hashconfig
operator||=
name|RSS_HASHTYPE_RSS_UDP_IPV6
expr_stmt|;
block|}
if|if
condition|(
name|hashen
operator|&
name|F_FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN
condition|)
name|hashconfig
operator||=
name|RSS_HASHTYPE_RSS_TCP_IPV4
expr_stmt|;
if|if
condition|(
name|hashen
operator|&
name|F_FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN
condition|)
name|hashconfig
operator||=
name|RSS_HASHTYPE_RSS_TCP_IPV6
expr_stmt|;
if|if
condition|(
name|hashen
operator|&
name|F_FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN
condition|)
name|hashconfig
operator||=
name|RSS_HASHTYPE_RSS_IPV4
expr_stmt|;
if|if
condition|(
name|hashen
operator|&
name|F_FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN
condition|)
name|hashconfig
operator||=
name|RSS_HASHTYPE_RSS_IPV6
expr_stmt|;
return|return
operator|(
name|hashconfig
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|vi_full_init
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vi
operator|->
name|ifp
decl_stmt|;
name|uint16_t
modifier|*
name|rss
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|hashen
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|int
name|nbuckets
init|=
name|rss_getnumbuckets
argument_list|()
decl_stmt|;
name|int
name|hashconfig
init|=
name|rss_gethashconfig
argument_list|()
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|uint32_t
name|raw_rss_key
index|[
name|RSS_KEYSIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|rss_key
index|[
name|RSS_KEYSIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
decl_stmt|;
endif|#
directive|endif
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: VI_INIT_DONE already"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|vi
operator|->
name|flags
operator||=
name|VI_SYSCTL_CTX
expr_stmt|;
comment|/* 	 * Allocate tx/rx/fl queues for this VI. 	 */
name|rc
operator|=
name|t4_setup_vi_queues
argument_list|(
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* Netmap VIs configure RSS when netmap is enabled. */
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_NETMAP
condition|)
block|{
name|vi
operator|->
name|flags
operator||=
name|VI_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Setup RSS for this VI.  Save a copy of the RSS table for later use. 	 */
if|if
condition|(
name|vi
operator|->
name|nrxq
operator|>
name|vi
operator|->
name|rss_size
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"nrxq (%d)> hw RSS table size (%d); "
literal|"some queues will never receive traffic.\n"
argument_list|,
name|vi
operator|->
name|nrxq
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vi
operator|->
name|rss_size
operator|%
name|vi
operator|->
name|nrxq
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"nrxq (%d), hw RSS table size (%d); "
literal|"expect uneven traffic distribution.\n"
argument_list|,
name|vi
operator|->
name|nrxq
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RSS
name|MPASS
argument_list|(
name|RSS_KEYSIZE
operator|==
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|nrxq
operator|!=
name|nbuckets
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"nrxq (%d) != kernel RSS buckets (%d);"
literal|"performance will be impacted.\n"
argument_list|,
name|vi
operator|->
name|nrxq
argument_list|,
name|nbuckets
argument_list|)
expr_stmt|;
block|}
name|rss_getkey
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|raw_rss_key
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|rss_key
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rss_key
index|[
name|i
index|]
operator|=
name|htobe32
argument_list|(
name|raw_rss_key
index|[
name|nitems
argument_list|(
name|rss_key
argument_list|)
operator|-
literal|1
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|t4_write_rss_key
argument_list|(
name|sc
argument_list|,
operator|&
name|rss_key
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rss
operator|=
name|malloc
argument_list|(
name|vi
operator|->
name|rss_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rss
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vi
operator|->
name|rss_size
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|j
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|j
operator|%=
name|vi
operator|->
name|nrxq
expr_stmt|;
name|rxq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|rxq
index|[
name|vi
operator|->
name|first_rxq
operator|+
name|j
index|]
expr_stmt|;
name|rss
index|[
name|i
operator|++
index|]
operator|=
name|rxq
operator|->
name|iq
operator|.
name|abs_id
expr_stmt|;
else|#
directive|else
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|j
argument_list|,
argument|rxq
argument_list|)
block|{
name|rss
index|[
name|i
operator|++
index|]
operator|=
name|rxq
operator|->
name|iq
operator|.
name|abs_id
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|vi
operator|->
name|rss_size
condition|)
break|break;
block|}
endif|#
directive|endif
block|}
name|rc
operator|=
operator|-
name|t4_config_rss_range
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|,
name|rss
argument_list|,
name|vi
operator|->
name|rss_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"rss_config failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|RSS
name|hashen
operator|=
name|hashconfig_to_hashen
argument_list|(
name|hashconfig
argument_list|)
expr_stmt|;
comment|/* 	 * We may have had to enable some hashes even though the global config 	 * wants them disabled.  This is a potential problem that must be 	 * reported to the user. 	 */
name|extra
operator|=
name|hashen_to_hashconfig
argument_list|(
name|hashen
argument_list|)
operator|^
name|hashconfig
expr_stmt|;
comment|/* 	 * If we consider only the supported hash types, then the enabled hashes 	 * are a superset of the requested hashes.  In other words, there cannot 	 * be any supported hash that was requested but not enabled, but there 	 * can be hashes that were not requested but had to be enabled. 	 */
name|extra
operator|&=
name|SUPPORTED_RSS_HASHTYPES
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|extra
operator|&
name|hashconfig
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"global RSS config (0x%x) cannot be accomodated.\n"
argument_list|,
name|hashconfig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"IPv4 2-tuple hashing forced on.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TCP/IPv4 4-tuple hashing forced on.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
name|RSS_HASHTYPE_RSS_IPV6
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"IPv6 2-tuple hashing forced on.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TCP/IPv6 4-tuple hashing forced on.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"UDP/IPv4 4-tuple hashing forced on.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"UDP/IPv6 4-tuple hashing forced on.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|hashen
operator|=
name|F_FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN
operator||
name|F_FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN
operator||
name|F_FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN
operator||
name|F_FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN
operator||
name|F_FW_RSS_VI_CONFIG_CMD_UDPEN
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
operator|-
name|t4_config_vi_rss
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
name|hashen
argument_list|,
name|rss
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"rss hash/defaultq config failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vi
operator|->
name|rss
operator|=
name|rss
expr_stmt|;
name|vi
operator|->
name|flags
operator||=
name|VI_INIT_DONE
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|vi_full_uninit
argument_list|(
name|vi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
name|int
name|vi_full_uninit
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
block|{
comment|/* Need to quiesce queues.  */
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_NETMAP
condition|)
goto|goto
name|skip
goto|;
endif|#
directive|endif
comment|/* XXX: Only for the first VI? */
if|if
condition|(
name|IS_MAIN_VI
argument_list|(
name|vi
argument_list|)
condition|)
name|quiesce_wrq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
argument_list|)
expr_stmt|;
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|quiesce_txq
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_txq
argument_list|)
block|{
name|quiesce_wrq
argument_list|(
name|sc
argument_list|,
name|ofld_txq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|quiesce_iq
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|iq
argument_list|)
expr_stmt|;
name|quiesce_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|quiesce_iq
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
argument_list|)
expr_stmt|;
name|quiesce_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|vi
operator|->
name|rss
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|skip
label|:
endif|#
directive|endif
name|t4_teardown_vi_queues
argument_list|(
name|vi
argument_list|)
expr_stmt|;
name|vi
operator|->
name|flags
operator|&=
operator|~
name|VI_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_txq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|sge_qstat
modifier|*
name|spg
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* unused */
ifdef|#
directive|ifdef
name|INVARIANTS
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_ENABLED
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Wait for the mp_ring to empty. */
while|while
condition|(
operator|!
name|mp_ring_is_idle
argument_list|(
name|txq
operator|->
name|r
argument_list|)
condition|)
block|{
name|mp_ring_check_drainage
argument_list|(
name|txq
operator|->
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"rquiesce"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Then wait for the hardware to finish. */
while|while
condition|(
name|spg
operator|->
name|cidx
operator|!=
name|htobe16
argument_list|(
name|eq
operator|->
name|pidx
argument_list|)
condition|)
name|pause
argument_list|(
literal|"equiesce"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Finally, wait for the driver to reclaim all descriptors. */
while|while
condition|(
name|eq
operator|->
name|cidx
operator|!=
name|eq
operator|->
name|pidx
condition|)
name|pause
argument_list|(
literal|"dquiesce"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_wrq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|)
block|{
comment|/* XXXTX */
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_iq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* unused */
comment|/* Synchronize with the interrupt handler */
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|,
name|IQS_DISABLED
argument_list|)
condition|)
name|pause
argument_list|(
literal|"iqfree"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quiesce_fl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|flags
operator||=
name|FL_DOOMED
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|FL_STARVING
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: still starving"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_intr_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|irq
operator|->
name|rid
operator|=
name|rid
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate IRQ for rid %d, name %s.\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|&
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup interrupt for rid %d, name %s: %d\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
condition|)
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|)
block|{
if|if
condition|(
name|irq
operator|->
name|tag
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|rid
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|irq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|irq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_regdump
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|regs
operator|->
name|version
operator|=
name|chip_id
argument_list|(
name|sc
argument_list|)
operator||
name|chip_rev
argument_list|(
name|sc
argument_list|)
operator|<<
literal|10
expr_stmt|;
name|t4_get_regs
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|regs
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|A_PL_INDIR_CMD
value|0x1f8
end_define

begin_define
define|#
directive|define
name|S_PL_AUTOINC
value|31
end_define

begin_define
define|#
directive|define
name|M_PL_AUTOINC
value|0x1U
end_define

begin_define
define|#
directive|define
name|V_PL_AUTOINC
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_PL_AUTOINC)
end_define

begin_define
define|#
directive|define
name|G_PL_AUTOINC
parameter_list|(
name|x
parameter_list|)
value|(((x)>> S_PL_AUTOINC)& M_PL_AUTOINC)
end_define

begin_define
define|#
directive|define
name|S_PL_VFID
value|20
end_define

begin_define
define|#
directive|define
name|M_PL_VFID
value|0xffU
end_define

begin_define
define|#
directive|define
name|V_PL_VFID
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_PL_VFID)
end_define

begin_define
define|#
directive|define
name|G_PL_VFID
parameter_list|(
name|x
parameter_list|)
value|(((x)>> S_PL_VFID)& M_PL_VFID)
end_define

begin_define
define|#
directive|define
name|S_PL_ADDR
value|0
end_define

begin_define
define|#
directive|define
name|M_PL_ADDR
value|0xfffffU
end_define

begin_define
define|#
directive|define
name|V_PL_ADDR
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_PL_ADDR)
end_define

begin_define
define|#
directive|define
name|G_PL_ADDR
parameter_list|(
name|x
parameter_list|)
value|(((x)>> S_PL_ADDR)& M_PL_ADDR)
end_define

begin_define
define|#
directive|define
name|A_PL_INDIR_DATA
value|0x1fc
end_define

begin_function
specifier|static
name|uint64_t
name|read_vf_stat
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|stats
index|[
literal|2
index|]
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INDIR_CMD
argument_list|,
name|V_PL_AUTOINC
argument_list|(
literal|1
argument_list|)
operator||
name|V_PL_VFID
argument_list|(
name|G_FW_VIID_VIN
argument_list|(
name|viid
argument_list|)
argument_list|)
operator||
name|V_PL_ADDR
argument_list|(
name|VF_MPS_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stats
index|[
literal|0
index|]
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INDIR_DATA
argument_list|)
expr_stmt|;
name|stats
index|[
literal|1
index|]
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INDIR_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|stats
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator||
name|stats
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_get_vi_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|struct
name|fw_vi_stats_vf
modifier|*
name|stats
parameter_list|)
block|{
define|#
directive|define
name|GET_STAT
parameter_list|(
name|name
parameter_list|)
define|\
value|read_vf_stat(sc, viid, A_MPS_VF_STAT_##name##_L)
name|stats
operator|->
name|tx_bcast_bytes
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_BCAST_BYTES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_BCAST_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_mcast_bytes
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_MCAST_BYTES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_MCAST_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_ucast_bytes
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_UCAST_BYTES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_UCAST_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_drop_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_DROP_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_offload_bytes
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_OFFLOAD_BYTES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_offload_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_VF_OFFLOAD_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_bcast_bytes
operator|=
name|GET_STAT
argument_list|(
name|RX_VF_BCAST_BYTES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_VF_BCAST_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_mcast_bytes
operator|=
name|GET_STAT
argument_list|(
name|RX_VF_MCAST_BYTES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_VF_MCAST_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_ucast_bytes
operator|=
name|GET_STAT
argument_list|(
name|RX_VF_UCAST_BYTES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_VF_UCAST_FRAMES
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_err_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_VF_ERR_FRAMES
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|GET_STAT
block|}
end_function

begin_function
specifier|static
name|void
name|t4_clr_vi_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INDIR_CMD
argument_list|,
name|V_PL_AUTOINC
argument_list|(
literal|1
argument_list|)
operator||
name|V_PL_VFID
argument_list|(
name|G_FW_VIID_VIN
argument_list|(
name|viid
argument_list|)
argument_list|)
operator||
name|V_PL_ADDR
argument_list|(
name|VF_MPS_REG
argument_list|(
name|A_MPS_VF_STAT_TX_VF_BCAST_BYTES_L
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|A_MPS_VF_STAT_TX_VF_BCAST_BYTES_L
init|;
name|reg
operator|<=
name|A_MPS_VF_STAT_RX_VF_ERR_FRAMES_H
condition|;
name|reg
operator|+=
literal|4
control|)
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INDIR_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vi_refresh_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
specifier|const
name|struct
name|timeval
name|interval
init|=
block|{
literal|0
block|,
literal|250000
block|}
decl_stmt|;
comment|/* 250ms */
if|if
condition|(
operator|!
operator|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|)
condition|)
return|return;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|vi
operator|->
name|last_refreshed
argument_list|,
operator|<
argument_list|)
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|t4_get_vi_stats
argument_list|(
name|sc
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
operator|&
name|vi
operator|->
name|stats
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|vi
operator|->
name|last_refreshed
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_refresh_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|v
decl_stmt|,
name|tnl_cong_drops
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
specifier|const
name|struct
name|timeval
name|interval
init|=
block|{
literal|0
block|,
literal|250000
block|}
decl_stmt|;
comment|/* 250ms */
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|pi
operator|->
name|last_refreshed
argument_list|,
operator|<
argument_list|)
condition|)
return|return;
name|tnl_cong_drops
operator|=
literal|0
expr_stmt|;
name|t4_get_port_stats
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
operator|&
name|pi
operator|->
name|stats
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|chip_params
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pi
operator|->
name|rx_chan_map
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|sc
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
operator|&
name|v
argument_list|,
literal|1
argument_list|,
name|A_TP_MIB_TNL_CNG_DROP_0
operator|+
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|tnl_cong_drops
operator|+=
name|v
expr_stmt|;
block|}
block|}
name|pi
operator|->
name|tnl_cong_drops
operator|=
name|tnl_cong_drops
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|pi
operator|->
name|last_refreshed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|cxgbe_refresh_stats
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vi_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|vi_refresh_stats
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|vi
operator|->
name|tick
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_vlan_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|vid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|vlan
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|ifp
operator|||
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_ETHER
condition|)
return|return;
name|vlan
operator|=
name|VLAN_DEVAT
argument_list|(
name|ifp
argument_list|,
name|vid
argument_list|)
expr_stmt|;
name|VLAN_SETCOOKIE
argument_list|(
name|vlan
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: opcode 0x%02x on iq %p with payload %p"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: opcode 0x%02x on iq %p with payload %p\n"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_cpl_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|opcode
parameter_list|,
name|cpl_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|opcode
operator|>=
name|nitems
argument_list|(
name|sc
operator|->
name|cpl_handler
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|cpl_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|cpl_handler
index|[
name|opcode
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
name|ctrl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: async notification on iq %p (ctrl %p)"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: async notification on iq %p (ctrl %p)\n"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_an_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|an_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|an_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_handler
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_msg_not_handled
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_fw6_msg
modifier|*
name|cpl
init|=
name|__containerof
argument_list|(
name|rpl
argument_list|,
expr|struct
name|cpl_fw6_msg
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: fw_msg type %d"
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: fw_msg type %d\n"
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_fw_msg_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|,
name|fw_msg_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|nitems
argument_list|(
name|sc
operator|->
name|fw_msg_handler
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * These are dispatched by the handler for FW{4|6}_CPL_MSG using the CPL 	 * handler dispatch table.  Reject any attempt to install a handler for 	 * this subtype. 	 */
if|if
condition|(
name|type
operator|==
name|FW_TYPE_RSSCPL
operator|||
name|type
operator|==
name|FW6_TYPE_RSSCPL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|fw_msg_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|fw_msg_handler
index|[
name|type
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|,
modifier|*
name|c0
decl_stmt|;
specifier|static
name|char
modifier|*
name|caps
index|[]
init|=
block|{
literal|"\20\1PPP\2QFC\3DCBX"
block|,
comment|/* caps[0] linkcaps */
literal|"\20\1NIC\2VM\3IDS\4UM\5UM_ISGL"
comment|/* caps[1] niccaps */
literal|"\6HASHFILTER\7ETHOFLD"
block|,
literal|"\20\1TOE"
block|,
comment|/* caps[2] toecaps */
literal|"\20\1RDDP\2RDMAC"
block|,
comment|/* caps[3] rdmacaps */
literal|"\20\1INITIATOR_PDU\2TARGET_PDU"
comment|/* caps[4] iscsicaps */
literal|"\3INITIATOR_CNXOFLD\4TARGET_CNXOFLD"
literal|"\5INITIATOR_SSNOFLD\6TARGET_SSNOFLD"
block|,
literal|"\20\1INITIATOR\2TARGET\3CTRL_OFLD"
comment|/* caps[5] fcoecaps */
literal|"\4PO_INITIAOR\5PO_TARGET"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|doorbells
init|=
block|{
literal|"\20\1UDB\2WCWR\3UDBWC\4KDB"
block|}
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.t4nex.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|c0
operator|=
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_do_rxcopy
operator|=
literal|1
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"do_rx_copy"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_do_rxcopy
argument_list|,
literal|1
argument_list|,
literal|"Do RX copy of small frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nports"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
literal|"# of ports"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_revision"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|chip_rev
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"chip hardware revision"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cf"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|cfg_file
argument_list|,
literal|0
argument_list|,
literal|"configuration file"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cfcsum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|cfcsum
argument_list|,
literal|"config file checksum"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"doorbells"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|doorbells
argument_list|,
name|sc
operator|->
name|doorbells
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available doorbells"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"linkcaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|linkcaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available link capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"niccaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|niccaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available NIC capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"toecaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|toecaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available TCP offload capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdmacaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|rdmacaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available RDMA capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"iscsicaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|iscsicaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available iSCSI capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fcoecaps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|caps
index|[
literal|5
index|]
argument_list|,
name|sc
operator|->
name|fcoecaps
argument_list|,
name|sysctl_bitfield
argument_list|,
literal|"A"
argument_list|,
literal|"available FCoE capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"core_clock"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
argument_list|,
literal|"core clock frequency (in KHz)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_timers"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|timer_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|timer_val
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff timer values (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pkt_counts"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|counter_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|counter_val
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff packet counter values"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nfilters"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|tids
operator|.
name|nftids
argument_list|,
literal|"number of filters"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"temperature"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_temperature
argument_list|,
literal|"I"
argument_list|,
literal|"chip temperature (in Celsius)"
argument_list|)
expr_stmt|;
name|t4_sge_sysctls
argument_list|(
name|sc
argument_list|,
name|ctx
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lro_timeout
operator|=
literal|100
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_timeout"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|lro_timeout
argument_list|,
literal|0
argument_list|,
literal|"lro inactive-flush timeout (in us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_flags"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|debug_flags
argument_list|,
literal|0
argument_list|,
literal|"flags to enable runtime debugging"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SBUF_DRAIN
comment|/* 	 * dev.t4nex.X.misc.  Marked CTLFLAG_SKIP to avoid information overload. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|c0
argument_list|,
name|OID_AUTO
argument_list|,
literal|"misc"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_SKIP
argument_list|,
name|NULL
argument_list|,
literal|"logs and miscellaneous information"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cctrl"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cctrl
argument_list|,
literal|"A"
argument_list|,
literal|"congestion control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_tp0"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 0 (TP0)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_tp1"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 1 (TP1)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_ulp"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|2
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 2 (ULP)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_sge0"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|3
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 3 (SGE0)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_sge1"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|4
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 4 (SGE1)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ibq_ncsi"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|5
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM IBQ 5 (NCSI)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|sysctl_cim_la
else|:
name|sysctl_cim_la_t6
argument_list|,
literal|"A"
argument_list|,
literal|"CIM logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_ma_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_ma_la
argument_list|,
literal|"A"
argument_list|,
literal|"CIM MA logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp0"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 0 (ULP0)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp1"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|1
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 1 (ULP1)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp2"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|2
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 2 (ULP2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ulp3"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|3
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 3 (ULP3)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_sge"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|4
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 4 (SGE)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_ncsi"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|5
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 5 (NCSI)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>
name|CHELSIO_T4
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_sge0_rx"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|6
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 6 (SGE0-RX)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_obq_sge1_rx"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|7
operator|+
name|CIM_NUM_IBQ
argument_list|,
name|sysctl_cim_ibq_obq
argument_list|,
literal|"A"
argument_list|,
literal|"CIM OBQ 7 (SGE1-RX)"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_pif_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_pif_la
argument_list|,
literal|"A"
argument_list|,
literal|"CIM PIF logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cim_qcfg"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cim_qcfg
argument_list|,
literal|"A"
argument_list|,
literal|"CIM queue configuration"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpl_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_cpl_stats
argument_list|,
literal|"A"
argument_list|,
literal|"CPL statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_ddp_stats
argument_list|,
literal|"A"
argument_list|,
literal|"non-TCP DDP statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"devlog"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_devlog
argument_list|,
literal|"A"
argument_list|,
literal|"firmware's device log"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fcoe_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_fcoe_stats
argument_list|,
literal|"A"
argument_list|,
literal|"FCoE statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_sched"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_sched
argument_list|,
literal|"A"
argument_list|,
literal|"hardware scheduler "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"l2t"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_l2t
argument_list|,
literal|"A"
argument_list|,
literal|"hardware L2 table"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lb_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_lb_stats
argument_list|,
literal|"A"
argument_list|,
literal|"loopback statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"meminfo"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_meminfo
argument_list|,
literal|"A"
argument_list|,
literal|"memory regions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mps_tcam"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|sysctl_mps_tcam
else|:
name|sysctl_mps_tcam_t6
argument_list|,
literal|"A"
argument_list|,
literal|"MPS TCAM entries"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"path_mtus"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_path_mtus
argument_list|,
literal|"A"
argument_list|,
literal|"path MTUs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pm_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_pm_stats
argument_list|,
literal|"A"
argument_list|,
literal|"PM statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdma_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_rdma_stats
argument_list|,
literal|"A"
argument_list|,
literal|"RDMA statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tcp_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tcp_stats
argument_list|,
literal|"A"
argument_list|,
literal|"TCP statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tids"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tids
argument_list|,
literal|"A"
argument_list|,
literal|"TID information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tp_err_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tp_err_stats
argument_list|,
literal|"A"
argument_list|,
literal|"TP error statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tp_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tp_la
argument_list|,
literal|"A"
argument_list|,
literal|"TP logic analyzer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_rate"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_tx_rate
argument_list|,
literal|"A"
argument_list|,
literal|"Tx rate"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ulprx_la"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_ulprx_la
argument_list|,
literal|"A"
argument_list|,
literal|"ULPRX logic analyzer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wcwr_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_wcwr_stats
argument_list|,
literal|"A"
argument_list|,
literal|"write combined work requests"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * dev.t4nex.X.toe. 		 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|c0
argument_list|,
name|OID_AUTO
argument_list|,
literal|"toe"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"TOE parameters"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|sndbuf
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sndbuf"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|sndbuf
argument_list|,
literal|0
argument_list|,
literal|"max hardware send buffer size"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|ddp
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|ddp
argument_list|,
literal|0
argument_list|,
literal|"DDP allowed"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|indsz
operator|=
name|G_INDICATESIZE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG5
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"indsz"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|indsz
argument_list|,
literal|0
argument_list|,
literal|"DDP max indicate size allowed"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|ddp_thres
operator|=
name|G_RXCOALESCESIZE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG2
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ddp_thres"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|ddp_thres
argument_list|,
literal|0
argument_list|,
literal|"DDP threshold"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|rx_coalesce
operator|=
literal|1
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_coalesce"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|rx_coalesce
argument_list|,
literal|0
argument_list|,
literal|"receive coalescing"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tt
operator|.
name|tx_align
operator|=
literal|1
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_align"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tt
operator|.
name|tx_align
argument_list|,
literal|0
argument_list|,
literal|"chop and align payload"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|vi_sysctls
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.[nv](cxgbe|cxl).X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"viid"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|vi
operator|->
name|viid
argument_list|,
literal|"VI identifer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|nrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ntxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|ntxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|first_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|first_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first tx queue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_NETMAP
condition|)
return|return;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rsrv_noflowq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|vi
argument_list|,
literal|0
argument_list|,
name|sysctl_noflowq
argument_list|,
literal|"IU"
argument_list|,
literal|"Reserve queue 0 for non-flowid packets"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|vi
operator|->
name|nofldrxq
operator|!=
literal|0
condition|)
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nofldrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|nofldrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nofldtxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|nofldtxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_ofld_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|first_ofld_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first TOE rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_ofld_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vi
operator|->
name|first_ofld_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first TOE tx queue"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_tmr_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|vi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_tmr_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff timer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pktc_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|vi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_pktc_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff packet counter index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_rxq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|vi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_rxq
argument_list|,
literal|"I"
argument_list|,
literal|"rx queue size"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_txq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|vi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_txq
argument_list|,
literal|"I"
argument_list|,
literal|"tx queue size"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"linkdnrc"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_linkdnrc
argument_list|,
literal|"A"
argument_list|,
literal|"reason why link is down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|port_type
operator|==
name|FW_PORT_TYPE_BT_XAUI
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"temperature"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_btphy
argument_list|,
literal|"I"
argument_list|,
literal|"PHY temperature (in Celsius)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pi
argument_list|,
literal|1
argument_list|,
name|sysctl_btphy
argument_list|,
literal|"I"
argument_list|,
literal|"PHY firmware version"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pause_settings"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
name|PAUSE_TX
argument_list|,
name|sysctl_pause_settings
argument_list|,
literal|"A"
argument_list|,
literal|"PAUSE settings (bit 0 = rx_pause, bit 1 = tx_pause)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_speed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|port_top_speed
argument_list|(
name|pi
argument_list|)
argument_list|,
literal|"max speed (in Gbps)"
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X.stats. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"port statistics"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_parse_error"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|tx_parse_error
argument_list|,
literal|0
argument_list|,
literal|"# of tx packets with invalid length or # of segments"
argument_list|)
expr_stmt|;
define|#
directive|define
name|SYSCTL_ADD_T4_REG64
parameter_list|(
name|pi
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|,
name|reg
parameter_list|)
define|\
value|SYSCTL_ADD_OID(ctx, children, OID_AUTO, name, \ 	    CTLTYPE_U64 | CTLFLAG_RD, sc, reg, \ 	    sysctl_handle_t4_reg64, "QU", desc)
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_error_frames"
argument_list|,
literal|"# of error frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_64"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1024_1518"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1519_max"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_drop"
argument_list|,
literal|"# of dropped tx frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_DROP_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_pause"
argument_list|,
literal|"# of pause frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_too_long"
argument_list|,
literal|"# of frames exceeding MTU"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_jabber"
argument_list|,
literal|"# of jabber frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_fcs_err"
argument_list|,
literal|"# of frames received with bad FCS"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_len_err"
argument_list|,
literal|"# of frames received with length error"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LEN_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_symbol_err"
argument_list|,
literal|"symbol errors"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_SYM_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_runt"
argument_list|,
literal|"# of short frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LESS_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_64"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1024_1518"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1519_max"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_pause"
argument_list|,
literal|"# of pause frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_REG64
define|#
directive|define
name|SYSCTL_ADD_T4_PORTSTAT
parameter_list|(
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|SYSCTL_ADD_UQUAD(ctx, children, OID_AUTO, #name, CTLFLAG_RD, \&pi->stats.name, desc)
comment|/* We get these from port_stats and they may be stale by upto 1s */
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow0
argument_list|,
literal|"# drops due to buffer-group 0 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow1
argument_list|,
literal|"# drops due to buffer-group 1 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow2
argument_list|,
literal|"# drops due to buffer-group 2 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow3
argument_list|,
literal|"# drops due to buffer-group 3 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc0
argument_list|,
literal|"# of buffer-group 0 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc1
argument_list|,
literal|"# of buffer-group 1 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc2
argument_list|,
literal|"# of buffer-group 2 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc3
argument_list|,
literal|"# of buffer-group 3 truncated packets"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_PORTSTAT
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
modifier|*
name|i
decl_stmt|,
name|space
init|=
literal|0
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg1
init|;
name|arg2
condition|;
name|arg2
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|space
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%d"
argument_list|,
operator|*
name|i
argument_list|)
expr_stmt|;
name|space
operator|=
literal|1
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_bitfield
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%b"
argument_list|,
operator|(
name|int
operator|)
name|arg2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_btphy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|int
name|op
init|=
name|arg2
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|u_int
name|v
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
operator|&
name|pi
operator|->
name|vi
index|[
literal|0
index|]
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4btt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* XXX: magic numbers */
name|rc
operator|=
operator|-
name|t4_mdio_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|mdio_addr
argument_list|,
literal|0x1e
argument_list|,
name|op
condition|?
literal|0x20
else|:
literal|0xc820
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
name|v
operator|/=
literal|256
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|v
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_noflowq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg1
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|vi
operator|->
name|rsrv_noflowq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|(
name|val
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|vi
operator|->
name|ntxq
operator|>
literal|1
operator|)
condition|)
name|vi
operator|->
name|rsrv_noflowq
operator|=
literal|1
expr_stmt|;
else|else
name|vi
operator|->
name|rsrv_noflowq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
endif|#
directive|endif
name|uint8_t
name|v
decl_stmt|;
name|idx
operator|=
name|vi
operator|->
name|tmr_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|SGE_NTIMERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4tmr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|v
operator|=
name|V_QINTR_TIMER_IDX
argument_list|(
name|idx
argument_list|)
operator||
name|V_QINTR_CNT_EN
argument_list|(
name|vi
operator|->
name|pktc_idx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
ifdef|#
directive|ifdef
name|atomic_store_rel_8
name|atomic_store_rel_8
argument_list|(
operator|&
name|rxq
operator|->
name|iq
operator|.
name|intr_params
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|#
directive|else
name|rxq
operator|->
name|iq
operator|.
name|intr_params
operator|=
name|v
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
ifdef|#
directive|ifdef
name|atomic_store_rel_8
name|atomic_store_rel_8
argument_list|(
operator|&
name|ofld_rxq
operator|->
name|iq
operator|.
name|intr_params
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|#
directive|else
name|ofld_rxq
operator|->
name|iq
operator|.
name|intr_params
operator|=
name|v
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|vi
operator|->
name|tmr_idx
operator|=
name|idx
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|;
name|idx
operator|=
name|vi
operator|->
name|pktc_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
operator|-
literal|1
operator|||
name|idx
operator|>=
name|SGE_NCOUNTERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4pktc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
else|else
name|vi
operator|->
name|pktc_idx
operator|=
name|idx
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|vi
operator|->
name|qsize_rxq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|qsize
operator|<
literal|128
operator|||
operator|(
name|qsize
operator|&
literal|7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4rxqs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
else|else
name|vi
operator|->
name|qsize_rxq
operator|=
name|qsize
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|vi
operator|->
name|qsize_txq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|qsize
operator|<
literal|128
operator|||
name|qsize
operator|>
literal|65536
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4txqs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* cannot be changed once the queues are created */
else|else
name|vi
operator|->
name|qsize_txq
operator|=
name|qsize
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_pause_settings
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|link_config
modifier|*
name|lc
init|=
operator|&
name|pi
operator|->
name|link_cfg
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
specifier|static
name|char
modifier|*
name|bits
init|=
literal|"\20\1PAUSE_RX\2PAUSE_TX"
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%b"
argument_list|,
name|lc
operator|->
name|fc
operator|&
operator|(
name|PAUSE_TX
operator||
name|PAUSE_RX
operator|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|s
index|[
literal|2
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|s
index|[
literal|0
index|]
operator|=
literal|'0'
operator|+
operator|(
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_TX
operator||
name|PAUSE_RX
operator|)
operator|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|s
index|[
literal|0
index|]
operator|>
literal|'9'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not a number */
name|n
operator|=
name|s
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|n
operator|&
operator|~
operator|(
name|PAUSE_TX
operator||
name|PAUSE_RX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* some other bit is set too */
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
operator|&
name|pi
operator|->
name|vi
index|[
literal|0
index|]
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4PAUSE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|(
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_TX
operator||
name|PAUSE_RX
operator|)
operator|)
operator|!=
name|n
condition|)
block|{
name|int
name|link_ok
init|=
name|lc
operator|->
name|link_ok
decl_stmt|;
name|lc
operator|->
name|requested_fc
operator|&=
operator|~
operator|(
name|PAUSE_TX
operator||
name|PAUSE_RX
operator|)
expr_stmt|;
name|lc
operator|->
name|requested_fc
operator||=
name|n
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_link_l1cfg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|lc
argument_list|)
expr_stmt|;
name|lc
operator|->
name|link_ok
operator|=
name|link_ok
expr_stmt|;
comment|/* restore */
block|}
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|reg
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_temperature
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|t
decl_stmt|;
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4temp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|param
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_DIAG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_Y
argument_list|(
name|FW_PARAM_DEV_DIAG_TMP
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* unknown is returned as 0 but we display -1 in that case */
name|t
operator|=
name|val
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
name|val
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|t
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SBUF_DRAIN
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_cctrl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|incr
index|[
name|NMTUS
index|]
index|[
name|NCCTRL_WIN
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|dec_fac
index|[]
init|=
block|{
literal|"0.5"
block|,
literal|"0.5625"
block|,
literal|"0.625"
block|,
literal|"0.6875"
block|,
literal|"0.75"
block|,
literal|"0.8125"
block|,
literal|"0.875"
block|,
literal|"0.9375"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_read_cong_tbl
argument_list|(
name|sc
argument_list|,
name|incr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|i
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%2d: %4u %4u %4u %4u %4u %4u %4u %4u\n"
argument_list|,
name|i
argument_list|,
name|incr
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|2
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|3
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|4
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|5
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|6
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|7
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%8u %4u %4u %4u %4u %4u %4u %4u %5u %s\n"
argument_list|,
name|incr
index|[
literal|8
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|9
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|10
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|11
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|12
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|13
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|14
index|]
index|[
name|i
index|]
argument_list|,
name|incr
index|[
literal|15
index|]
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|a_wnd
index|[
name|i
index|]
argument_list|,
name|dec_fac
index|[
name|sc
operator|->
name|params
operator|.
name|b_wnd
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|qname
index|[
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
index|]
init|=
block|{
literal|"TP0"
block|,
literal|"TP1"
block|,
literal|"ULP"
block|,
literal|"SGE0"
block|,
literal|"SGE1"
block|,
literal|"NC-SI"
block|,
comment|/* ibq's */
literal|"ULP0"
block|,
literal|"ULP1"
block|,
literal|"ULP2"
block|,
literal|"ULP3"
block|,
literal|"SGE"
block|,
literal|"NC-SI"
block|,
comment|/* obq's */
literal|"SGE0-RX"
block|,
literal|"SGE1-RX"
comment|/* additional obq's (T5 onwards) */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_cim_ibq_obq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|qid
init|=
name|arg2
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|qtype
decl_stmt|;
name|u_int
name|cim_num_obq
init|=
name|sc
operator|->
name|chip_params
operator|->
name|cim_num_obq
decl_stmt|;
name|KASSERT
argument_list|(
name|qid
operator|>=
literal|0
operator|&&
name|qid
operator|<
name|CIM_NUM_IBQ
operator|+
name|cim_num_obq
argument_list|,
operator|(
literal|"%s: bad qid %d\n"
operator|,
name|__func__
operator|,
name|qid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|<
name|CIM_NUM_IBQ
condition|)
block|{
comment|/* inbound queue */
name|qtype
operator|=
literal|"IBQ"
expr_stmt|;
name|n
operator|=
literal|4
operator|*
name|CIM_IBQ_SIZE
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_read_cim_ibq
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* outbound queue */
name|qtype
operator|=
literal|"OBQ"
expr_stmt|;
name|qid
operator|-=
name|CIM_NUM_IBQ
expr_stmt|;
name|n
operator|=
literal|4
operator|*
name|cim_num_obq
operator|*
name|CIM_OBQ_SIZE
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_read_cim_obq
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|n
operator|=
name|rc
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* rc has # of words actually read */
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s%d %s"
argument_list|,
name|qtype
argument_list|,
name|qid
argument_list|,
name|qname
index|[
name|arg2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buf
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|16
operator|,
name|p
operator|+=
literal|4
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%#06x: %08x %08x %08x %08x"
argument_list|,
name|i
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|cfg
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|MPASS
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read
argument_list|(
name|sc
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|params
operator|.
name|cim_la_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Status   Data      PC%s"
argument_list|,
name|cfg
operator|&
name|F_UPDBGLACAPTPCONLY
condition|?
literal|""
else|:
literal|"     LS0Stat  LS0Addr             LS0Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<=
operator|&
name|buf
index|[
name|sc
operator|->
name|params
operator|.
name|cim_la_size
operator|-
literal|8
index|]
condition|;
name|p
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|cfg
operator|&
name|F_UPDBGLACAPTPCONLY
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %08x %08x"
argument_list|,
name|p
index|[
literal|5
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %02x%06x %02x%06x"
argument_list|,
operator|(
name|p
index|[
literal|3
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|4
index|]
operator|>>
literal|8
argument_list|,
name|p
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|5
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %x%07x %x%07x"
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|0
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|1
index|]
operator|>>
literal|4
argument_list|,
name|p
index|[
literal|1
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|2
index|]
operator|>>
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %x%07x %x%07x %08x %08x "
literal|"%08x%08x%08x%08x"
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|0
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|1
index|]
operator|>>
literal|4
argument_list|,
name|p
index|[
literal|1
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|2
index|]
operator|>>
literal|4
argument_list|,
name|p
index|[
literal|2
index|]
operator|&
literal|0xf
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_la_t6
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|cfg
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|MPASS
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>
name|CHELSIO_T5
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read
argument_list|(
name|sc
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|params
operator|.
name|cim_la_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Status   Inst    Data      PC%s"
argument_list|,
name|cfg
operator|&
name|F_UPDBGLACAPTPCONLY
condition|?
literal|""
else|:
literal|"     LS0Stat  LS0Addr  LS0Data  LS1Stat  LS1Addr  LS1Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<=
operator|&
name|buf
index|[
name|sc
operator|->
name|params
operator|.
name|cim_la_size
operator|-
literal|10
index|]
condition|;
name|p
operator|+=
literal|10
control|)
block|{
if|if
condition|(
name|cfg
operator|&
name|F_UPDBGLACAPTPCONLY
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %08x %08x %08x"
argument_list|,
name|p
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %02x%06x %02x%06x %02x%06x"
argument_list|,
operator|(
name|p
index|[
literal|6
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|6
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|5
index|]
operator|>>
literal|8
argument_list|,
name|p
index|[
literal|5
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|4
index|]
operator|>>
literal|8
argument_list|,
name|p
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|3
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %04x%04x %04x%04x %04x%04x"
argument_list|,
operator|(
name|p
index|[
literal|9
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|9
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|8
index|]
operator|>>
literal|16
argument_list|,
name|p
index|[
literal|8
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|7
index|]
operator|>>
literal|16
argument_list|,
name|p
index|[
literal|7
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|6
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n  %02x   %04x%04x %04x%04x %04x%04x "
literal|"%08x %08x %08x %08x %08x %08x"
argument_list|,
operator|(
name|p
index|[
literal|9
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|9
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|8
index|]
operator|>>
literal|16
argument_list|,
name|p
index|[
literal|8
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|7
index|]
operator|>>
literal|16
argument_list|,
name|p
index|[
literal|7
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|6
index|]
operator|>>
literal|16
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_ma_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|CIM_MALA_SIZE
operator|*
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_cim_read_ma_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
literal|5
operator|*
name|CIM_MALA_SIZE
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|5
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%02x%08x%08x%08x%08x"
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n\nCnt ID Tag UE       Data       RDY VLD"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|5
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%3u %2u  %x   %u %08x%08x  %u   %u"
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|10
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|7
operator|)
operator|&
literal|7
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0xf
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|2
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|p
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|3
operator|)
operator|<<
literal|30
operator|)
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|3
operator|)
operator|<<
literal|30
operator|)
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|&
literal|1
argument_list|,
name|p
index|[
literal|0
index|]
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_pif_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|CIM_PIFLA_SIZE
operator|*
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_cim_read_pif_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
literal|6
operator|*
name|CIM_PIFLA_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Cntl ID DataBE   Addr                 Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_PIFLA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|6
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n %02x  %02x  %04x  %08x %08x%08x%08x%08x"
argument_list|,
operator|(
name|p
index|[
literal|5
index|]
operator|>>
literal|22
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|p
index|[
literal|5
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0x3f
argument_list|,
name|p
index|[
literal|5
index|]
operator|&
literal|0xffff
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n\nCntl ID               Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_PIFLA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|6
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n %02x  %02x %08x%08x%08x%08x"
argument_list|,
operator|(
name|p
index|[
literal|4
index|]
operator|>>
literal|6
operator|)
operator|&
literal|0xff
argument_list|,
name|p
index|[
literal|4
index|]
operator|&
literal|0x3f
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cim_qcfg
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|base
index|[
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
index|]
decl_stmt|;
name|uint16_t
name|size
index|[
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
index|]
decl_stmt|;
name|uint16_t
name|thres
index|[
name|CIM_NUM_IBQ
index|]
decl_stmt|;
name|uint32_t
name|obq_wr
index|[
literal|2
operator|*
name|CIM_NUM_OBQ_T5
index|]
decl_stmt|,
modifier|*
name|wr
init|=
name|obq_wr
decl_stmt|;
name|uint32_t
name|stat
index|[
literal|4
operator|*
operator|(
name|CIM_NUM_IBQ
operator|+
name|CIM_NUM_OBQ_T5
operator|)
index|]
decl_stmt|,
modifier|*
name|p
init|=
name|stat
decl_stmt|;
name|u_int
name|cim_num_obq
decl_stmt|,
name|ibq_rdaddr
decl_stmt|,
name|obq_rdaddr
decl_stmt|,
name|nq
decl_stmt|;
name|cim_num_obq
operator|=
name|sc
operator|->
name|chip_params
operator|->
name|cim_num_obq
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ibq_rdaddr
operator|=
name|A_UP_IBQ_0_RDADDR
expr_stmt|;
name|obq_rdaddr
operator|=
name|A_UP_OBQ_0_REALADDR
expr_stmt|;
block|}
else|else
block|{
name|ibq_rdaddr
operator|=
name|A_UP_IBQ_0_SHADOW_RDADDR
expr_stmt|;
name|obq_rdaddr
operator|=
name|A_UP_OBQ_0_SHADOW_REALADDR
expr_stmt|;
block|}
name|nq
operator|=
name|CIM_NUM_IBQ
operator|+
name|cim_num_obq
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_cim_read
argument_list|(
name|sc
argument_list|,
name|ibq_rdaddr
argument_list|,
literal|4
operator|*
name|nq
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|rc
operator|=
operator|-
name|t4_cim_read
argument_list|(
name|sc
argument_list|,
name|obq_rdaddr
argument_list|,
literal|2
operator|*
name|cim_num_obq
argument_list|,
name|obq_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|t4_read_cimq_cfg
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|thres
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Queue  Base  Size Thres RdPtr WrPtr  SOP  EOP Avail"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_NUM_IBQ
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|4
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%7s %5x %5u %5u %6x  %4x %4u %4u %5u"
argument_list|,
name|qname
index|[
name|i
index|]
argument_list|,
name|base
index|[
name|i
index|]
argument_list|,
name|size
index|[
name|i
index|]
argument_list|,
name|thres
index|[
name|i
index|]
argument_list|,
name|G_IBQRDADDR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|G_IBQWRADDR
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|G_QUESOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEEOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEREMFLITS
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nq
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|4
operator|,
name|wr
operator|+=
literal|2
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%7s %5x %5u %12x  %4x %4u %4u %5u"
argument_list|,
name|qname
index|[
name|i
index|]
argument_list|,
name|base
index|[
name|i
index|]
argument_list|,
name|size
index|[
name|i
index|]
argument_list|,
name|G_QUERDADDR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0x3fff
argument_list|,
name|wr
index|[
literal|0
index|]
operator|-
name|base
index|[
name|i
index|]
argument_list|,
name|G_QUESOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEEOPCNT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|G_QUEREMFLITS
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cpl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_cpl_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|t4_tp_get_cpl_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_params
operator|->
name|nchan
operator|>
literal|2
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1"
literal|"  channel 2  channel 3"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nCPL requests:   %10u %10u %10u %10u"
argument_list|,
name|stats
operator|.
name|req
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nCPL responses:   %10u %10u %10u %10u"
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nCPL requests:   %10u %10u"
argument_list|,
name|stats
operator|.
name|req
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|req
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nCPL responses:   %10u %10u"
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|rsp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_ddp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_usm_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_usm_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Frames: %u\n"
argument_list|,
name|stats
operator|.
name|frames
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Octets: %ju\n"
argument_list|,
name|stats
operator|.
name|octets
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Drops:  %u"
argument_list|,
name|stats
operator|.
name|drops
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|devlog_level_strings
index|[]
init|=
block|{
index|[
name|FW_DEVLOG_LEVEL_EMERG
index|]
operator|=
literal|"EMERG"
block|,
index|[
name|FW_DEVLOG_LEVEL_CRIT
index|]
operator|=
literal|"CRIT"
block|,
index|[
name|FW_DEVLOG_LEVEL_ERR
index|]
operator|=
literal|"ERR"
block|,
index|[
name|FW_DEVLOG_LEVEL_NOTICE
index|]
operator|=
literal|"NOTICE"
block|,
index|[
name|FW_DEVLOG_LEVEL_INFO
index|]
operator|=
literal|"INFO"
block|,
index|[
name|FW_DEVLOG_LEVEL_DEBUG
index|]
operator|=
literal|"DEBUG"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|devlog_facility_strings
index|[]
init|=
block|{
index|[
name|FW_DEVLOG_FACILITY_CORE
index|]
operator|=
literal|"CORE"
block|,
index|[
name|FW_DEVLOG_FACILITY_CF
index|]
operator|=
literal|"CF"
block|,
index|[
name|FW_DEVLOG_FACILITY_SCHED
index|]
operator|=
literal|"SCHED"
block|,
index|[
name|FW_DEVLOG_FACILITY_TIMER
index|]
operator|=
literal|"TIMER"
block|,
index|[
name|FW_DEVLOG_FACILITY_RES
index|]
operator|=
literal|"RES"
block|,
index|[
name|FW_DEVLOG_FACILITY_HW
index|]
operator|=
literal|"HW"
block|,
index|[
name|FW_DEVLOG_FACILITY_FLR
index|]
operator|=
literal|"FLR"
block|,
index|[
name|FW_DEVLOG_FACILITY_DMAQ
index|]
operator|=
literal|"DMAQ"
block|,
index|[
name|FW_DEVLOG_FACILITY_PHY
index|]
operator|=
literal|"PHY"
block|,
index|[
name|FW_DEVLOG_FACILITY_MAC
index|]
operator|=
literal|"MAC"
block|,
index|[
name|FW_DEVLOG_FACILITY_PORT
index|]
operator|=
literal|"PORT"
block|,
index|[
name|FW_DEVLOG_FACILITY_VI
index|]
operator|=
literal|"VI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FILTER
index|]
operator|=
literal|"FILTER"
block|,
index|[
name|FW_DEVLOG_FACILITY_ACL
index|]
operator|=
literal|"ACL"
block|,
index|[
name|FW_DEVLOG_FACILITY_TM
index|]
operator|=
literal|"TM"
block|,
index|[
name|FW_DEVLOG_FACILITY_QFC
index|]
operator|=
literal|"QFC"
block|,
index|[
name|FW_DEVLOG_FACILITY_DCB
index|]
operator|=
literal|"DCB"
block|,
index|[
name|FW_DEVLOG_FACILITY_ETH
index|]
operator|=
literal|"ETH"
block|,
index|[
name|FW_DEVLOG_FACILITY_OFLD
index|]
operator|=
literal|"OFLD"
block|,
index|[
name|FW_DEVLOG_FACILITY_RI
index|]
operator|=
literal|"RI"
block|,
index|[
name|FW_DEVLOG_FACILITY_ISCSI
index|]
operator|=
literal|"ISCSI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FCOE
index|]
operator|=
literal|"FCOE"
block|,
index|[
name|FW_DEVLOG_FACILITY_FOISCSI
index|]
operator|=
literal|"FOISCSI"
block|,
index|[
name|FW_DEVLOG_FACILITY_FOFCOE
index|]
operator|=
literal|"FOFCOE"
block|,
index|[
name|FW_DEVLOG_FACILITY_CHNET
index|]
operator|=
literal|"CHNET"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_devlog
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|devlog_params
modifier|*
name|dparams
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|devlog
decl_stmt|;
name|struct
name|fw_devlog_e
modifier|*
name|buf
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
decl_stmt|,
name|nentries
decl_stmt|,
name|first
init|=
literal|0
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint64_t
name|ftstamp
init|=
name|UINT64_MAX
decl_stmt|;
if|if
condition|(
name|dparams
operator|->
name|addr
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|dparams
operator|->
name|size
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
name|read_via_memwin
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|dparams
operator|->
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|dparams
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|nentries
operator|=
name|dparams
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|fw_devlog_e
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|==
literal|0
condition|)
break|break;
comment|/* end */
name|e
operator|->
name|timestamp
operator|=
name|be64toh
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|e
operator|->
name|seqno
operator|=
name|be32toh
argument_list|(
name|e
operator|->
name|seqno
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|e
operator|->
name|params
index|[
name|j
index|]
operator|=
name|be32toh
argument_list|(
name|e
operator|->
name|params
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|<
name|ftstamp
condition|)
block|{
name|ftstamp
operator|=
name|e
operator|->
name|timestamp
expr_stmt|;
name|first
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|first
index|]
operator|.
name|timestamp
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* nothing in the log */
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10s  %15s  %8s  %8s  %s\n"
argument_list|,
literal|"Seq#"
argument_list|,
literal|"Tstamp"
argument_list|,
literal|"Level"
argument_list|,
literal|"Facility"
argument_list|,
literal|"Message"
argument_list|)
expr_stmt|;
name|i
operator|=
name|first
expr_stmt|;
do|do
block|{
name|e
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timestamp
operator|==
literal|0
condition|)
break|break;
comment|/* end */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10d  %15ju  %8s  %8s  "
argument_list|,
name|e
operator|->
name|seqno
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
operator|(
name|e
operator|->
name|level
operator|<
name|nitems
argument_list|(
name|devlog_level_strings
argument_list|)
condition|?
name|devlog_level_strings
index|[
name|e
operator|->
name|level
index|]
else|:
literal|"UNKNOWN"
operator|)
argument_list|,
operator|(
name|e
operator|->
name|facility
operator|<
name|nitems
argument_list|(
name|devlog_facility_strings
argument_list|)
condition|?
name|devlog_facility_strings
index|[
name|e
operator|->
name|facility
index|]
else|:
literal|"UNKNOWN"
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
name|e
operator|->
name|fmt
argument_list|,
name|e
operator|->
name|params
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|1
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|2
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|3
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|4
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|5
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|6
index|]
argument_list|,
name|e
operator|->
name|params
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|nentries
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|first
condition|)
do|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_fcoe_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_fcoe_stats
name|stats
index|[
name|MAX_NCHAN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nchan
init|=
name|sc
operator|->
name|chip_params
operator|->
name|nchan
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
name|t4_get_fcoe_stats
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|stats
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchan
operator|>
literal|2
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                   channel 0        channel 1"
literal|"        channel 2        channel 3"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\noctetsDDP:  %16ju %16ju %16ju %16ju"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|octets_ddp
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|octets_ddp
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|octets_ddp
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|octets_ddp
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nframesDDP:  %16u %16u %16u %16u"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|frames_ddp
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|frames_ddp
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|frames_ddp
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|frames_ddp
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nframesDrop: %16u %16u %16u %16u"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|frames_drop
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|frames_drop
argument_list|,
name|stats
index|[
literal|2
index|]
operator|.
name|frames_drop
argument_list|,
name|stats
index|[
literal|3
index|]
operator|.
name|frames_drop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                   channel 0        channel 1"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\noctetsDDP:  %16ju %16ju"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|octets_ddp
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|octets_ddp
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nframesDDP:  %16u %16u"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|frames_ddp
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|frames_ddp
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nframesDrop: %16u %16u"
argument_list|,
name|stats
index|[
literal|0
index|]
operator|.
name|frames_drop
argument_list|,
name|stats
index|[
literal|1
index|]
operator|.
name|frames_drop
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_sched
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|map
decl_stmt|,
name|kbps
decl_stmt|,
name|ipg
decl_stmt|,
name|mode
decl_stmt|;
name|unsigned
name|int
name|pace_tab
index|[
name|NTX_SCHED
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|map
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|)
expr_stmt|;
name|mode
operator|=
name|G_TIMERMODE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_MOD_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|t4_read_pace_tbl
argument_list|(
name|sc
argument_list|,
name|pace_tab
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Scheduler  Mode   Channel  Rate (Kbps)   "
literal|"Class IPG (0.1 ns)   Flow IPG (us)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTX_SCHED
condition|;
operator|++
name|i
operator|,
name|map
operator|>>=
literal|2
control|)
block|{
name|t4_get_tx_sched
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|kbps
argument_list|,
operator|&
name|ipg
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n    %u      %-5s     %u     "
argument_list|,
name|i
argument_list|,
operator|(
name|mode
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"flow"
else|:
literal|"class"
argument_list|,
name|map
operator|&
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbps
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%9u     "
argument_list|,
name|kbps
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" disabled     "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipg
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%13u        "
argument_list|,
name|ipg
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"     disabled        "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pace_tab
index|[
name|i
index|]
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%10u"
argument_list|,
name|pace_tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"  disabled"
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_lb_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|struct
name|lb_port_stats
name|s
index|[
literal|2
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|stat_name
index|[]
init|=
block|{
literal|"OctetsOK:"
block|,
literal|"FramesOK:"
block|,
literal|"BcastFrames:"
block|,
literal|"McastFrames:"
block|,
literal|"UcastFrames:"
block|,
literal|"ErrorFrames:"
block|,
literal|"Frames64:"
block|,
literal|"Frames65To127:"
block|,
literal|"Frames128To255:"
block|,
literal|"Frames256To511:"
block|,
literal|"Frames512To1023:"
block|,
literal|"Frames1024To1518:"
block|,
literal|"Frames1519ToMax:"
block|,
literal|"FramesDropped:"
block|,
literal|"BG0FramesDropped:"
block|,
literal|"BG1FramesDropped:"
block|,
literal|"BG2FramesDropped:"
block|,
literal|"BG3FramesDropped:"
block|,
literal|"BG0FramesTrunc:"
block|,
literal|"BG1FramesTrunc:"
block|,
literal|"BG2FramesTrunc:"
block|,
literal|"BG3FramesTrunc:"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|chip_params
operator|->
name|nchan
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|t4_get_lb_stats
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t4_get_lb_stats
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p0
operator|=
operator|&
name|s
index|[
literal|0
index|]
operator|.
name|octets
expr_stmt|;
name|p1
operator|=
operator|&
name|s
index|[
literal|1
index|]
operator|.
name|octets
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s                       Loopback %u"
literal|"           Loopback %u"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nitems
argument_list|(
name|stat_name
argument_list|)
condition|;
name|j
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-17s %20ju %20ju"
argument_list|,
name|stat_name
index|[
name|j
index|]
argument_list|,
operator|*
name|p0
operator|++
argument_list|,
operator|*
name|p1
operator|++
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_linkdnrc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|pi
operator|->
name|linkdnrc
operator|<
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"n/a"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|t4_link_down_rc_str
argument_list|(
name|pi
operator|->
name|linkdnrc
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|mem_desc
block|{
name|unsigned
name|int
name|base
decl_stmt|;
name|unsigned
name|int
name|limit
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|mem_desc_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|mem_desc
operator|*
operator|)
name|a
operator|)
operator|->
name|base
operator|-
operator|(
operator|(
specifier|const
expr|struct
name|mem_desc
operator|*
operator|)
name|b
operator|)
operator|->
name|base
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_region_show
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|size
operator|=
name|to
operator|-
name|from
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
comment|/* XXX: need humanize_number(3) in libkern for a more readable 'size' */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%-15s %#x-%#x [%u]\n"
argument_list|,
name|name
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_meminfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint32_t
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|used
decl_stmt|,
name|alloc
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|memory
index|[]
init|=
block|{
literal|"EDC0:"
block|,
literal|"EDC1:"
block|,
literal|"MC:"
block|,
literal|"MC0:"
block|,
literal|"MC1:"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|region
index|[]
init|=
block|{
literal|"DBQ contexts:"
block|,
literal|"IMSG contexts:"
block|,
literal|"FLM cache:"
block|,
literal|"TCBs:"
block|,
literal|"Pstructs:"
block|,
literal|"Timers:"
block|,
literal|"Rx FL:"
block|,
literal|"Tx FL:"
block|,
literal|"Pstruct FL:"
block|,
literal|"Tx payload:"
block|,
literal|"Rx payload:"
block|,
literal|"LE hash:"
block|,
literal|"iSCSI region:"
block|,
literal|"TDDP region:"
block|,
literal|"TPT region:"
block|,
literal|"STAG region:"
block|,
literal|"RQ region:"
block|,
literal|"RQUDP region:"
block|,
literal|"PBL region:"
block|,
literal|"TXPBL region:"
block|,
literal|"DBVFIFO region:"
block|,
literal|"ULPRX state:"
block|,
literal|"ULPTX state:"
block|,
literal|"On-chip queues:"
block|}
decl_stmt|;
name|struct
name|mem_desc
name|avail
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|mem_desc
name|mem
index|[
name|nitems
argument_list|(
name|region
argument_list|)
operator|+
literal|3
index|]
decl_stmt|;
comment|/* up to 3 holes */
name|struct
name|mem_desc
modifier|*
name|md
init|=
name|mem
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mem
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|mem
index|[
name|i
index|]
operator|.
name|limit
operator|=
literal|0
expr_stmt|;
name|mem
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|i
expr_stmt|;
block|}
comment|/* Find and sort the populated memory ranges */
name|i
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_TARGET_MEM_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|&
name|F_EDRAM0_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM0_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EDRAM0_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EDRAM0_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EDRAM1_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EDRAM1_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EDRAM1_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EDRAM1_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|&
name|F_EXT_MEM_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EXT_MEM_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EXT_MEM_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
comment|/* Call it MC0 for T5 */
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
operator|&&
name|lo
operator|&
name|F_EXT_MEM1_ENABLE
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MA_EXT_MEMORY1_BAR
argument_list|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|G_EXT_MEM1_BASE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|avail
index|[
name|i
index|]
operator|.
name|base
operator|+
operator|(
name|G_EXT_MEM1_SIZE
argument_list|(
name|hi
argument_list|)
operator|<<
literal|20
operator|)
expr_stmt|;
name|avail
index|[
name|i
index|]
operator|.
name|idx
operator|=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
comment|/* no memory available */
return|return
literal|0
return|;
name|qsort
argument_list|(
name|avail
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_desc
argument_list|)
argument_list|,
name|mem_desc_cmp
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_DBQ_CTXT_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_IMSG_CTXT_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_FLM_CACHE_BADDR
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TCB_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TIMER_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_RX_FLST_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_TX_FLST_BASE
argument_list|)
expr_stmt|;
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_PS_FLST_BASE
argument_list|)
expr_stmt|;
comment|/* the next few have explicit upper bounds */
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|-
literal|1
operator|+
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|)
operator|*
name|G_PMTXMAXPAGE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|-
literal|1
operator|+
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|)
operator|*
name|G_PMRXMAXPAGE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_CONFIG
argument_list|)
operator|&
name|F_HASHEN
condition|)
block|{
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_HASH_TID_BASE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_HASH_TID_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_HASH_TBL_BASE_ADDR
argument_list|)
expr_stmt|;
block|}
name|md
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|idx
operator|=
name|nitems
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|/* hide it */
block|}
name|md
operator|++
expr_stmt|;
define|#
directive|define
name|ulp_region
parameter_list|(
name|reg
parameter_list|)
define|\
value|md->base = t4_read_reg(sc, A_ULP_ ## reg ## _LLIMIT);\ 	(md++)->limit = t4_read_reg(sc, A_ULP_ ## reg ## _ULIMIT)
name|ulp_region
argument_list|(
name|RX_ISCSI
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_TDDP
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|TX_TPT
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_STAG
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_RQ
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_RQUDP
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|RX_PBL
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|TX_PBL
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ulp_region
name|md
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|idx
operator|=
name|nitems
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint32_t
name|size
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sge_ctrl
init|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL2
argument_list|)
decl_stmt|;
name|uint32_t
name|fifo_size
init|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_DBVFIFO_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sge_ctrl
operator|&
name|F_VFIFO_ENABLE
condition|)
name|size
operator|=
name|G_DBVFIFO_SIZE
argument_list|(
name|fifo_size
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
name|G_T6_DBVFIFO_SIZE
argument_list|(
name|fifo_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|md
operator|->
name|base
operator|=
name|G_BASEADDR
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_DBVFIFO_BADDR
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
operator|(
name|size
operator|<<
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_CTX_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_TX_ERR_TABLE_BASE
argument_list|)
expr_stmt|;
name|md
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|md
operator|++
expr_stmt|;
name|md
operator|->
name|base
operator|=
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
condition|)
name|md
operator|->
name|limit
operator|=
name|md
operator|->
name|base
operator|+
name|sc
operator|->
name|vres
operator|.
name|ocq
operator|.
name|size
operator|-
literal|1
expr_stmt|;
else|else
name|md
operator|->
name|idx
operator|=
name|nitems
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|/* hide it */
name|md
operator|++
expr_stmt|;
comment|/* add any address-space holes, there can be up to 3 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|-
literal|1
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|avail
index|[
name|n
index|]
operator|.
name|limit
operator|<
name|avail
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|base
condition|)
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|avail
index|[
name|n
index|]
operator|.
name|limit
expr_stmt|;
if|if
condition|(
name|avail
index|[
name|n
index|]
operator|.
name|limit
condition|)
operator|(
name|md
operator|++
operator|)
operator|->
name|base
operator|=
name|avail
index|[
name|n
index|]
operator|.
name|limit
expr_stmt|;
name|n
operator|=
name|md
operator|-
name|mem
expr_stmt|;
name|qsort
argument_list|(
name|mem
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_desc
argument_list|)
argument_list|,
name|mem_desc_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|lo
operator|=
literal|0
init|;
name|lo
operator|<
name|i
condition|;
name|lo
operator|++
control|)
name|mem_region_show
argument_list|(
name|sb
argument_list|,
name|memory
index|[
name|avail
index|[
name|lo
index|]
operator|.
name|idx
index|]
argument_list|,
name|avail
index|[
name|lo
index|]
operator|.
name|base
argument_list|,
name|avail
index|[
name|lo
index|]
operator|.
name|limit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mem
index|[
name|i
index|]
operator|.
name|idx
operator|>=
name|nitems
argument_list|(
name|region
argument_list|)
condition|)
continue|continue;
comment|/* skip holes */
if|if
condition|(
operator|!
name|mem
index|[
name|i
index|]
operator|.
name|limit
condition|)
name|mem
index|[
name|i
index|]
operator|.
name|limit
operator|=
name|i
operator|<
name|n
operator|-
literal|1
condition|?
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|base
operator|-
literal|1
else|:
operator|~
literal|0
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
name|region
index|[
name|mem
index|[
name|i
index|]
operator|.
name|idx
index|]
argument_list|,
name|mem
index|[
name|i
index|]
operator|.
name|base
argument_list|,
name|mem
index|[
name|i
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_SDRAM_BASE_ADDR
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_SDRAM_ADDR_SIZE
argument_list|)
operator|+
name|lo
operator|-
literal|1
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
literal|"uP RAM:"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_EXTMEM2_BASE_ADDR
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_CIM_EXTMEM2_ADDR_SIZE
argument_list|)
operator|+
name|lo
operator|-
literal|1
expr_stmt|;
name|mem_region_show
argument_list|(
name|sb
argument_list|,
literal|"uP Extmem2:"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%u Rx pages of size %uKiB for %u channels\n"
argument_list|,
name|G_PMRXMAXPAGE
argument_list|(
name|lo
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|)
operator|>>
literal|10
argument_list|,
operator|(
name|lo
operator|&
name|F_PMRXNUMCHN
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|)
expr_stmt|;
name|hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u Tx pages of size %u%ciB for %u channels\n"
argument_list|,
name|G_PMTXMAXPAGE
argument_list|(
name|lo
argument_list|)
argument_list|,
name|hi
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|?
operator|(
name|hi
operator|>>
literal|20
operator|)
else|:
operator|(
name|hi
operator|>>
literal|10
operator|)
argument_list|,
name|hi
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|?
literal|'M'
else|:
literal|'K'
argument_list|,
literal|1
operator|<<
name|G_PMTXNUMCHN
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u p-structs\n"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_MM_MAX_PSTRUCT
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>
name|CHELSIO_T5
condition|)
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_MAC_BG_PG_CNT0
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
else|else
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_PG_RSV0
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|used
operator|=
name|G_T5_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_T5_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|used
operator|=
name|G_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
comment|/* For T6 these are MAC buffer groups */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nPort %d using %u pages out of %u allocated"
argument_list|,
name|i
argument_list|,
name|used
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|chip_params
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>
name|CHELSIO_T5
condition|)
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_LPBK_BG_PG_CNT0
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
else|else
name|lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_RX_PG_RSV4
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|used
operator|=
name|G_T5_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_T5_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|used
operator|=
name|G_USED
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|G_ALLOC
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
comment|/* For T6 these are MAC buffer groups */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\nLoopback %d using %u pages out of %u allocated"
argument_list|,
name|i
argument_list|,
name|used
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|tcamxy2valmask
parameter_list|(
name|uint64_t
name|x
parameter_list|,
name|uint64_t
name|y
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint64_t
modifier|*
name|mask
parameter_list|)
block|{
operator|*
name|mask
operator|=
name|x
operator||
name|y
expr_stmt|;
name|y
operator|=
name|htobe64
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
operator|+
literal|2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_mps_tcam
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Idx  Ethernet address     Mask     Vld Ports PF"
literal|"  VF              Replication             P0 P1 P2 P3  ML"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|chip_params
operator|->
name|mps_tcam_size
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|tcamx
decl_stmt|,
name|tcamy
decl_stmt|,
name|mask
decl_stmt|;
name|uint32_t
name|cls_lo
decl_stmt|,
name|cls_hi
decl_stmt|;
name|uint8_t
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|tcamy
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_TCAM_Y_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tcamx
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_TCAM_X_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcamx
operator|&
name|tcamy
condition|)
continue|continue;
name|tcamxy2valmask
argument_list|(
name|tcamx
argument_list|,
name|tcamy
argument_list|,
name|addr
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|cls_lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_SRAM_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|cls_hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_SRAM_H
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%3u %02x:%02x:%02x:%02x:%02x:%02x %012jx"
literal|"  %c   %#x%4u%4d"
argument_list|,
name|i
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|,
name|addr
index|[
literal|4
index|]
argument_list|,
name|addr
index|[
literal|5
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mask
argument_list|,
operator|(
name|cls_lo
operator|&
name|F_SRAM_VLD
operator|)
condition|?
literal|'Y'
else|:
literal|'N'
argument_list|,
name|G_PORTMAP
argument_list|(
name|cls_hi
argument_list|)
argument_list|,
name|G_PF
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
operator|(
name|cls_lo
operator|&
name|F_VF_VALID
operator|)
condition|?
name|G_VF
argument_list|(
name|cls_lo
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cls_lo
operator|&
name|F_REPLICATE
condition|)
block|{
name|struct
name|fw_ldst_cmd
name|ldst_cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ldst_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|op_to_addrspace
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_MPS
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|cycles_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|fid_idx
operator|=
name|htobe16
argument_list|(
name|V_FW_LDST_CMD_FID
argument_list|(
name|FW_LDST_MPS_RPLC
argument_list|)
operator||
name|V_FW_LDST_CMD_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4mps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
break|break;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|ldst_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|,
operator|&
name|ldst_cmd
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%36d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %08x %08x %08x %08x"
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc127_96
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc95_64
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc63_32
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc31_0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%36s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%4u%3u%3u%3u %#3x"
argument_list|,
name|G_SRAM_PRIO0
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_SRAM_PRIO1
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_SRAM_PRIO2
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_SRAM_PRIO3
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
operator|(
name|cls_lo
operator|>>
name|S_MULTILISTEN0
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
operator|(
name|void
operator|)
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_mps_tcam_t6
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>
name|CHELSIO_T5
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Idx  Ethernet address     Mask       VNI   Mask"
literal|"   IVLAN Vld DIP_Hit   Lookup  Port Vld Ports PF  VF"
literal|"                           Replication"
literal|"                                    P0 P1 P2 P3  ML\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|chip_params
operator|->
name|mps_tcam_size
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|dip_hit
decl_stmt|,
name|vlan_vld
decl_stmt|,
name|lookup_type
decl_stmt|,
name|port_num
decl_stmt|;
name|uint16_t
name|ivlan
decl_stmt|;
name|uint64_t
name|tcamx
decl_stmt|,
name|tcamy
decl_stmt|,
name|val
decl_stmt|,
name|mask
decl_stmt|;
name|uint32_t
name|cls_lo
decl_stmt|,
name|cls_hi
decl_stmt|,
name|ctl
decl_stmt|,
name|data2
decl_stmt|,
name|vnix
decl_stmt|,
name|vniy
decl_stmt|;
name|uint8_t
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|ctl
operator|=
name|V_CTLREQID
argument_list|(
literal|1
argument_list|)
operator||
name|V_CTLCMDTYPE
argument_list|(
literal|0
argument_list|)
operator||
name|V_CTLXYBITSEL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|256
condition|)
name|ctl
operator||=
name|V_CTLTCAMINDEX
argument_list|(
name|i
argument_list|)
operator||
name|V_CTLTCAMSEL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|ctl
operator||=
name|V_CTLTCAMINDEX
argument_list|(
name|i
operator|-
literal|256
argument_list|)
operator||
name|V_CTLTCAMSEL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_DATA2_CTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_RDATA1_REQ_ID1
argument_list|)
expr_stmt|;
name|tcamy
operator|=
name|G_DMACH
argument_list|(
name|val
argument_list|)
operator|<<
literal|32
expr_stmt|;
name|tcamy
operator||=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_RDATA0_REQ_ID1
argument_list|)
expr_stmt|;
name|data2
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_RDATA2_REQ_ID1
argument_list|)
expr_stmt|;
name|lookup_type
operator|=
name|G_DATALKPTYPE
argument_list|(
name|data2
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|G_DATAPORTNUM
argument_list|(
name|data2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_type
operator|&&
name|lookup_type
operator|!=
name|M_DATALKPTYPE
condition|)
block|{
comment|/* Inner header VNI */
name|vniy
operator|=
operator|(
operator|(
name|data2
operator|&
name|F_DATAVIDH2
operator|)
operator|<<
literal|23
operator|)
operator||
operator|(
name|G_DATAVIDH1
argument_list|(
name|data2
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|G_VIDL
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|dip_hit
operator|=
name|data2
operator|&
name|F_DATADIPHIT
expr_stmt|;
name|vlan_vld
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vniy
operator|=
literal|0
expr_stmt|;
name|dip_hit
operator|=
literal|0
expr_stmt|;
name|vlan_vld
operator|=
name|data2
operator|&
name|F_DATAVIDH2
expr_stmt|;
name|ivlan
operator|=
name|G_VIDL
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|ctl
operator||=
name|V_CTLXYBITSEL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_DATA2_CTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_RDATA1_REQ_ID1
argument_list|)
expr_stmt|;
name|tcamx
operator|=
name|G_DMACH
argument_list|(
name|val
argument_list|)
operator|<<
literal|32
expr_stmt|;
name|tcamx
operator||=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_RDATA0_REQ_ID1
argument_list|)
expr_stmt|;
name|data2
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_MPS_CLS_TCAM_RDATA2_REQ_ID1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_type
operator|&&
name|lookup_type
operator|!=
name|M_DATALKPTYPE
condition|)
block|{
comment|/* Inner header VNI mask */
name|vnix
operator|=
operator|(
operator|(
name|data2
operator|&
name|F_DATAVIDH2
operator|)
operator|<<
literal|23
operator|)
operator||
operator|(
name|G_DATAVIDH1
argument_list|(
name|data2
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|G_VIDL
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|vnix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcamx
operator|&
name|tcamy
condition|)
continue|continue;
name|tcamxy2valmask
argument_list|(
name|tcamx
argument_list|,
name|tcamy
argument_list|,
name|addr
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|cls_lo
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_SRAM_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|cls_hi
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|MPS_CLS_SRAM_H
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_type
operator|&&
name|lookup_type
operator|!=
name|M_DATALKPTYPE
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%3u %02x:%02x:%02x:%02x:%02x:%02x "
literal|"%012jx %06x %06x    -    -   %3c"
literal|"      'I'  %4x   %3c   %#x%4u%4d"
argument_list|,
name|i
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|,
name|addr
index|[
literal|4
index|]
argument_list|,
name|addr
index|[
literal|5
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mask
argument_list|,
name|vniy
argument_list|,
name|vnix
argument_list|,
name|dip_hit
condition|?
literal|'Y'
else|:
literal|'N'
argument_list|,
name|port_num
argument_list|,
name|cls_lo
operator|&
name|F_T6_SRAM_VLD
condition|?
literal|'Y'
else|:
literal|'N'
argument_list|,
name|G_PORTMAP
argument_list|(
name|cls_hi
argument_list|)
argument_list|,
name|G_T6_PF
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|cls_lo
operator|&
name|F_T6_VF_VALID
condition|?
name|G_T6_VF
argument_list|(
name|cls_lo
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%3u %02x:%02x:%02x:%02x:%02x:%02x "
literal|"%012jx    -       -   "
argument_list|,
name|i
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|,
name|addr
index|[
literal|4
index|]
argument_list|,
name|addr
index|[
literal|5
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan_vld
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%4u   Y     "
argument_list|,
name|ivlan
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"  -    N     "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"-      %3c  %4x   %3c   %#x%4u%4d"
argument_list|,
name|lookup_type
condition|?
literal|'I'
else|:
literal|'O'
argument_list|,
name|port_num
argument_list|,
name|cls_lo
operator|&
name|F_T6_SRAM_VLD
condition|?
literal|'Y'
else|:
literal|'N'
argument_list|,
name|G_PORTMAP
argument_list|(
name|cls_hi
argument_list|)
argument_list|,
name|G_T6_PF
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|cls_lo
operator|&
name|F_T6_VF_VALID
condition|?
name|G_T6_VF
argument_list|(
name|cls_lo
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cls_lo
operator|&
name|F_T6_REPLICATE
condition|)
block|{
name|struct
name|fw_ldst_cmd
name|ldst_cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ldst_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|op_to_addrspace
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_MPS
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|cycles_to_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|fid_idx
operator|=
name|htobe16
argument_list|(
name|V_FW_LDST_CMD_FID
argument_list|(
name|FW_LDST_MPS_RPLC
argument_list|)
operator||
name|V_FW_LDST_CMD_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t6mps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
break|break;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|ldst_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|,
operator|&
name|ldst_cmd
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%72d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %08x %08x %08x %08x"
literal|" %08x %08x %08x %08x"
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc255_224
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc223_192
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc191_160
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc159_128
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc127_96
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc95_64
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc63_32
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|mps
operator|.
name|rplc
operator|.
name|rplc31_0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%72s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%4u%3u%3u%3u %#x"
argument_list|,
name|G_T6_SRAM_PRIO0
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_T6_SRAM_PRIO1
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_T6_SRAM_PRIO2
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
name|G_T6_SRAM_PRIO3
argument_list|(
name|cls_lo
argument_list|)
argument_list|,
operator|(
name|cls_lo
operator|>>
name|S_T6_MULTILISTEN0
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
operator|(
name|void
operator|)
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_path_mtus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|uint16_t
name|mtus
index|[
name|NMTUS
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_read_mtu_tbl
argument_list|(
name|sc
argument_list|,
name|mtus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u"
argument_list|,
name|mtus
index|[
literal|0
index|]
argument_list|,
name|mtus
index|[
literal|1
index|]
argument_list|,
name|mtus
index|[
literal|2
index|]
argument_list|,
name|mtus
index|[
literal|3
index|]
argument_list|,
name|mtus
index|[
literal|4
index|]
argument_list|,
name|mtus
index|[
literal|5
index|]
argument_list|,
name|mtus
index|[
literal|6
index|]
argument_list|,
name|mtus
index|[
literal|7
index|]
argument_list|,
name|mtus
index|[
literal|8
index|]
argument_list|,
name|mtus
index|[
literal|9
index|]
argument_list|,
name|mtus
index|[
literal|10
index|]
argument_list|,
name|mtus
index|[
literal|11
index|]
argument_list|,
name|mtus
index|[
literal|12
index|]
argument_list|,
name|mtus
index|[
literal|13
index|]
argument_list|,
name|mtus
index|[
literal|14
index|]
argument_list|,
name|mtus
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_pm_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|tx_cnt
index|[
name|MAX_PM_NSTATS
index|]
decl_stmt|,
name|rx_cnt
index|[
name|MAX_PM_NSTATS
index|]
decl_stmt|;
name|uint64_t
name|tx_cyc
index|[
name|MAX_PM_NSTATS
index|]
decl_stmt|,
name|rx_cyc
index|[
name|MAX_PM_NSTATS
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|tx_stats
index|[
name|MAX_PM_NSTATS
index|]
init|=
block|{
literal|"Read:"
block|,
literal|"Write bypass:"
block|,
literal|"Write mem:"
block|,
literal|"Bypass + mem:"
block|,
literal|"Tx FIFO wait"
block|,
name|NULL
block|,
literal|"Tx latency"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|rx_stats
index|[
name|MAX_PM_NSTATS
index|]
init|=
block|{
literal|"Read:"
block|,
literal|"Write bypass:"
block|,
literal|"Write mem:"
block|,
literal|"Flush:"
block|,
literal|" Rx FIFO wait"
block|,
name|NULL
block|,
literal|"Rx latency"
block|}
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_pmtx_get_stats
argument_list|(
name|sc
argument_list|,
name|tx_cnt
argument_list|,
name|tx_cyc
argument_list|)
expr_stmt|;
name|t4_pmrx_get_stats
argument_list|(
name|sc
argument_list|,
name|rx_cnt
argument_list|,
name|rx_cyc
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                Tx pcmds             Tx bytes"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|tx_stats
index|[
name|i
index|]
argument_list|,
name|tx_cnt
index|[
name|i
index|]
argument_list|,
name|tx_cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n                Rx pcmds             Rx bytes"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|rx_stats
index|[
name|i
index|]
argument_list|,
name|rx_cnt
index|[
name|i
index|]
argument_list|,
name|rx_cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>
name|CHELSIO_T5
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n              Total wait      Total occupancy"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|tx_stats
index|[
name|i
index|]
argument_list|,
name|tx_cnt
index|[
name|i
index|]
argument_list|,
name|tx_cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|rx_stats
index|[
name|i
index|]
argument_list|,
name|rx_cnt
index|[
name|i
index|]
argument_list|,
name|rx_cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|MPASS
argument_list|(
name|i
operator|<
name|nitems
argument_list|(
name|tx_stats
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n                   Reads           Total wait"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|tx_stats
index|[
name|i
index|]
argument_list|,
name|tx_cnt
index|[
name|i
index|]
argument_list|,
name|tx_cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%-13s %10u %20ju"
argument_list|,
name|rx_stats
index|[
name|i
index|]
argument_list|,
name|rx_cnt
index|[
name|i
index|]
argument_list|,
name|rx_cyc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_rdma_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_rdma_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|t4_tp_get_rdma_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NoRQEModDefferals: %u\n"
argument_list|,
name|stats
operator|.
name|rqe_dfr_mod
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NoRQEPktDefferals: %u"
argument_list|,
name|stats
operator|.
name|rqe_dfr_pkt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tcp_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_tcp_stats
name|v4
decl_stmt|,
name|v6
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|t4_tp_get_tcp_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|v4
argument_list|,
operator|&
name|v6
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                                IP                 IPv6\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"OutRsts:      %20u %20u\n"
argument_list|,
name|v4
operator|.
name|tcp_out_rsts
argument_list|,
name|v6
operator|.
name|tcp_out_rsts
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"InSegs:       %20ju %20ju\n"
argument_list|,
name|v4
operator|.
name|tcp_in_segs
argument_list|,
name|v6
operator|.
name|tcp_in_segs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"OutSegs:      %20ju %20ju\n"
argument_list|,
name|v4
operator|.
name|tcp_out_segs
argument_list|,
name|v6
operator|.
name|tcp_out_segs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"RetransSegs:  %20ju %20ju"
argument_list|,
name|v4
operator|.
name|tcp_retrans_segs
argument_list|,
name|v6
operator|.
name|tcp_retrans_segs
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tids
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|sc
operator|->
name|tids
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|natids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ATID range: 0-%u, in use: %u\n"
argument_list|,
name|t
operator|->
name|natids
operator|-
literal|1
argument_list|,
name|t
operator|->
name|atids_in_use
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|ntids
condition|)
block|{
if|if
condition|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_CONFIG
argument_list|)
operator|&
name|F_HASHEN
condition|)
block|{
name|uint32_t
name|b
init|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_SERVER_INDEX
argument_list|)
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: 0-%u, %u-%u"
argument_list|,
name|b
operator|-
literal|1
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: %u-%u"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_TID_HASHBASE
argument_list|)
operator|/
literal|4
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TID range: 0-%u"
argument_list|,
name|t
operator|->
name|ntids
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|", in use: %u\n"
argument_list|,
name|atomic_load_acq_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|nstids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"STID range: %u-%u, in use: %u\n"
argument_list|,
name|t
operator|->
name|stid_base
argument_list|,
name|t
operator|->
name|stid_base
operator|+
name|t
operator|->
name|nstids
operator|-
literal|1
argument_list|,
name|t
operator|->
name|stids_in_use
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|nftids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"FTID range: %u-%u\n"
argument_list|,
name|t
operator|->
name|ftid_base
argument_list|,
name|t
operator|->
name|ftid_base
operator|+
name|t
operator|->
name|nftids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|netids
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ETID range: %u-%u\n"
argument_list|,
name|t
operator|->
name|etid_base
argument_list|,
name|t
operator|->
name|etid_base
operator|+
name|t
operator|->
name|netids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"HW TID usage: %u IP users, %u IPv6 users"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_ACT_CNT_IPV4
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_LE_DB_ACT_CNT_IPV6
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tp_err_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|tp_err_stats
name|stats
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|t4_tp_get_err_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_params
operator|->
name|nchan
operator|>
literal|2
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1"
literal|"  channel 2  channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"macInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|mac_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|mac_in_errs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|mac_in_errs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|mac_in_errs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"hdrInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|hdr_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|hdr_in_errs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|hdr_in_errs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|hdr_in_errs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcpInErrs:      %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcp_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcp_in_errs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tcp_in_errs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tcp_in_errs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcp6InErrs:     %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcp6_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcp6_in_errs
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tcp6_in_errs
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tcp6_in_errs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlCongDrops:   %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnl_cong_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnl_cong_drops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tnl_cong_drops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tnl_cong_drops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlTxDrops:     %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnl_tx_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnl_tx_drops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|tnl_tx_drops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|tnl_tx_drops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldVlanDrops:  %10u %10u %10u %10u\n"
argument_list|,
name|stats
operator|.
name|ofld_vlan_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofld_vlan_drops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|ofld_vlan_drops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|ofld_vlan_drops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldChanDrops:  %10u %10u %10u %10u\n\n"
argument_list|,
name|stats
operator|.
name|ofld_chan_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofld_chan_drops
index|[
literal|1
index|]
argument_list|,
name|stats
operator|.
name|ofld_chan_drops
index|[
literal|2
index|]
argument_list|,
name|stats
operator|.
name|ofld_chan_drops
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"                 channel 0  channel 1\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"macInErrs:      %10u %10u\n"
argument_list|,
name|stats
operator|.
name|mac_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|mac_in_errs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"hdrInErrs:      %10u %10u\n"
argument_list|,
name|stats
operator|.
name|hdr_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|hdr_in_errs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcpInErrs:      %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcp_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcp_in_errs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tcp6InErrs:     %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tcp6_in_errs
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tcp6_in_errs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlCongDrops:   %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnl_cong_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnl_cong_drops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"tnlTxDrops:     %10u %10u\n"
argument_list|,
name|stats
operator|.
name|tnl_tx_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|tnl_tx_drops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldVlanDrops:  %10u %10u\n"
argument_list|,
name|stats
operator|.
name|ofld_vlan_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofld_vlan_drops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldChanDrops:  %10u %10u\n\n"
argument_list|,
name|stats
operator|.
name|ofld_chan_drops
index|[
literal|0
index|]
argument_list|,
name|stats
operator|.
name|ofld_chan_drops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ofldNoNeigh:    %u\nofldCongDefer:  %u"
argument_list|,
name|stats
operator|.
name|ofld_no_neigh
argument_list|,
name|stats
operator|.
name|ofld_cong_defer
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|field_desc
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|start
decl_stmt|;
name|u_int
name|width
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|field_desc_show
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
name|v
parameter_list|,
specifier|const
name|struct
name|field_desc
modifier|*
name|f
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|line_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|name
condition|)
block|{
name|uint64_t
name|mask
init|=
operator|(
literal|1ULL
operator|<<
name|f
operator|->
name|width
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s: %ju"
argument_list|,
name|f
operator|->
name|name
argument_list|,
operator|(
operator|(
name|uintmax_t
operator|)
name|v
operator|>>
name|f
operator|->
name|start
operator|)
operator|&
name|mask
argument_list|)
decl_stmt|;
if|if
condition|(
name|line_size
operator|+
name|len
operator|>=
literal|79
condition|)
block|{
name|line_size
operator|=
literal|8
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n        "
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|line_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|field_desc
name|tp_la0
index|[]
init|=
block|{
block|{
literal|"RcfOpCodeOut"
block|,
literal|60
block|,
literal|4
block|}
block|,
block|{
literal|"State"
block|,
literal|56
block|,
literal|4
block|}
block|,
block|{
literal|"WcfState"
block|,
literal|52
block|,
literal|4
block|}
block|,
block|{
literal|"RcfOpcSrcOut"
block|,
literal|50
block|,
literal|2
block|}
block|,
block|{
literal|"CRxError"
block|,
literal|49
block|,
literal|1
block|}
block|,
block|{
literal|"ERxError"
block|,
literal|48
block|,
literal|1
block|}
block|,
block|{
literal|"SanityFailed"
block|,
literal|47
block|,
literal|1
block|}
block|,
block|{
literal|"SpuriousMsg"
block|,
literal|46
block|,
literal|1
block|}
block|,
block|{
literal|"FlushInputMsg"
block|,
literal|45
block|,
literal|1
block|}
block|,
block|{
literal|"FlushInputCpl"
block|,
literal|44
block|,
literal|1
block|}
block|,
block|{
literal|"RssUpBit"
block|,
literal|43
block|,
literal|1
block|}
block|,
block|{
literal|"RssFilterHit"
block|,
literal|42
block|,
literal|1
block|}
block|,
block|{
literal|"Tid"
block|,
literal|32
block|,
literal|10
block|}
block|,
block|{
literal|"InitTcb"
block|,
literal|31
block|,
literal|1
block|}
block|,
block|{
literal|"LineNumber"
block|,
literal|24
block|,
literal|7
block|}
block|,
block|{
literal|"Emsg"
block|,
literal|23
block|,
literal|1
block|}
block|,
block|{
literal|"EdataOut"
block|,
literal|22
block|,
literal|1
block|}
block|,
block|{
literal|"Cmsg"
block|,
literal|21
block|,
literal|1
block|}
block|,
block|{
literal|"CdataOut"
block|,
literal|20
block|,
literal|1
block|}
block|,
block|{
literal|"EreadPdu"
block|,
literal|19
block|,
literal|1
block|}
block|,
block|{
literal|"CreadPdu"
block|,
literal|18
block|,
literal|1
block|}
block|,
block|{
literal|"TunnelPkt"
block|,
literal|17
block|,
literal|1
block|}
block|,
block|{
literal|"RcfPeerFin"
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
literal|"RcfReasonOut"
block|,
literal|12
block|,
literal|4
block|}
block|,
block|{
literal|"TxCchannel"
block|,
literal|10
block|,
literal|2
block|}
block|,
block|{
literal|"RcfTxChannel"
block|,
literal|8
block|,
literal|2
block|}
block|,
block|{
literal|"RxEchannel"
block|,
literal|6
block|,
literal|2
block|}
block|,
block|{
literal|"RcfRxChannel"
block|,
literal|5
block|,
literal|1
block|}
block|,
block|{
literal|"RcfDataOutSrdy"
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
literal|"RxDvld"
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|"RxOoDvld"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"RxCongestion"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"TxCongestion"
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|field_desc
name|tp_la1
index|[]
init|=
block|{
block|{
literal|"CplCmdIn"
block|,
literal|56
block|,
literal|8
block|}
block|,
block|{
literal|"CplCmdOut"
block|,
literal|48
block|,
literal|8
block|}
block|,
block|{
literal|"ESynOut"
block|,
literal|47
block|,
literal|1
block|}
block|,
block|{
literal|"EAckOut"
block|,
literal|46
block|,
literal|1
block|}
block|,
block|{
literal|"EFinOut"
block|,
literal|45
block|,
literal|1
block|}
block|,
block|{
literal|"ERstOut"
block|,
literal|44
block|,
literal|1
block|}
block|,
block|{
literal|"SynIn"
block|,
literal|43
block|,
literal|1
block|}
block|,
block|{
literal|"AckIn"
block|,
literal|42
block|,
literal|1
block|}
block|,
block|{
literal|"FinIn"
block|,
literal|41
block|,
literal|1
block|}
block|,
block|{
literal|"RstIn"
block|,
literal|40
block|,
literal|1
block|}
block|,
block|{
literal|"DataIn"
block|,
literal|39
block|,
literal|1
block|}
block|,
block|{
literal|"DataInVld"
block|,
literal|38
block|,
literal|1
block|}
block|,
block|{
literal|"PadIn"
block|,
literal|37
block|,
literal|1
block|}
block|,
block|{
literal|"RxBufEmpty"
block|,
literal|36
block|,
literal|1
block|}
block|,
block|{
literal|"RxDdp"
block|,
literal|35
block|,
literal|1
block|}
block|,
block|{
literal|"RxFbCongestion"
block|,
literal|34
block|,
literal|1
block|}
block|,
block|{
literal|"TxFbCongestion"
block|,
literal|33
block|,
literal|1
block|}
block|,
block|{
literal|"TxPktSumSrdy"
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"RcfUlpType"
block|,
literal|28
block|,
literal|4
block|}
block|,
block|{
literal|"Eread"
block|,
literal|27
block|,
literal|1
block|}
block|,
block|{
literal|"Ebypass"
block|,
literal|26
block|,
literal|1
block|}
block|,
block|{
literal|"Esave"
block|,
literal|25
block|,
literal|1
block|}
block|,
block|{
literal|"Static0"
block|,
literal|24
block|,
literal|1
block|}
block|,
block|{
literal|"Cread"
block|,
literal|23
block|,
literal|1
block|}
block|,
block|{
literal|"Cbypass"
block|,
literal|22
block|,
literal|1
block|}
block|,
block|{
literal|"Csave"
block|,
literal|21
block|,
literal|1
block|}
block|,
block|{
literal|"CPktOut"
block|,
literal|20
block|,
literal|1
block|}
block|,
block|{
literal|"RxPagePoolFull"
block|,
literal|18
block|,
literal|2
block|}
block|,
block|{
literal|"RxLpbkPkt"
block|,
literal|17
block|,
literal|1
block|}
block|,
block|{
literal|"TxLpbkPkt"
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
literal|"RxVfValid"
block|,
literal|15
block|,
literal|1
block|}
block|,
block|{
literal|"SynLearned"
block|,
literal|14
block|,
literal|1
block|}
block|,
block|{
literal|"SetDelEntry"
block|,
literal|13
block|,
literal|1
block|}
block|,
block|{
literal|"SetInvEntry"
block|,
literal|12
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdDvld"
block|,
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdSave"
block|,
literal|10
block|,
literal|1
block|}
block|,
block|{
literal|"RxPstructsFull"
block|,
literal|8
block|,
literal|2
block|}
block|,
block|{
literal|"EpcmdDvld"
block|,
literal|7
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdFlush"
block|,
literal|6
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPrefix"
block|,
literal|5
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPostfix"
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp4Pkt"
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp6Pkt"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"ERssTcpUdpPkt"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"ERssFceFipPkt"
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|field_desc
name|tp_la2
index|[]
init|=
block|{
block|{
literal|"CplCmdIn"
block|,
literal|56
block|,
literal|8
block|}
block|,
block|{
literal|"MpsVfVld"
block|,
literal|55
block|,
literal|1
block|}
block|,
block|{
literal|"MpsPf"
block|,
literal|52
block|,
literal|3
block|}
block|,
block|{
literal|"MpsVf"
block|,
literal|44
block|,
literal|8
block|}
block|,
block|{
literal|"SynIn"
block|,
literal|43
block|,
literal|1
block|}
block|,
block|{
literal|"AckIn"
block|,
literal|42
block|,
literal|1
block|}
block|,
block|{
literal|"FinIn"
block|,
literal|41
block|,
literal|1
block|}
block|,
block|{
literal|"RstIn"
block|,
literal|40
block|,
literal|1
block|}
block|,
block|{
literal|"DataIn"
block|,
literal|39
block|,
literal|1
block|}
block|,
block|{
literal|"DataInVld"
block|,
literal|38
block|,
literal|1
block|}
block|,
block|{
literal|"PadIn"
block|,
literal|37
block|,
literal|1
block|}
block|,
block|{
literal|"RxBufEmpty"
block|,
literal|36
block|,
literal|1
block|}
block|,
block|{
literal|"RxDdp"
block|,
literal|35
block|,
literal|1
block|}
block|,
block|{
literal|"RxFbCongestion"
block|,
literal|34
block|,
literal|1
block|}
block|,
block|{
literal|"TxFbCongestion"
block|,
literal|33
block|,
literal|1
block|}
block|,
block|{
literal|"TxPktSumSrdy"
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"RcfUlpType"
block|,
literal|28
block|,
literal|4
block|}
block|,
block|{
literal|"Eread"
block|,
literal|27
block|,
literal|1
block|}
block|,
block|{
literal|"Ebypass"
block|,
literal|26
block|,
literal|1
block|}
block|,
block|{
literal|"Esave"
block|,
literal|25
block|,
literal|1
block|}
block|,
block|{
literal|"Static0"
block|,
literal|24
block|,
literal|1
block|}
block|,
block|{
literal|"Cread"
block|,
literal|23
block|,
literal|1
block|}
block|,
block|{
literal|"Cbypass"
block|,
literal|22
block|,
literal|1
block|}
block|,
block|{
literal|"Csave"
block|,
literal|21
block|,
literal|1
block|}
block|,
block|{
literal|"CPktOut"
block|,
literal|20
block|,
literal|1
block|}
block|,
block|{
literal|"RxPagePoolFull"
block|,
literal|18
block|,
literal|2
block|}
block|,
block|{
literal|"RxLpbkPkt"
block|,
literal|17
block|,
literal|1
block|}
block|,
block|{
literal|"TxLpbkPkt"
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
literal|"RxVfValid"
block|,
literal|15
block|,
literal|1
block|}
block|,
block|{
literal|"SynLearned"
block|,
literal|14
block|,
literal|1
block|}
block|,
block|{
literal|"SetDelEntry"
block|,
literal|13
block|,
literal|1
block|}
block|,
block|{
literal|"SetInvEntry"
block|,
literal|12
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdDvld"
block|,
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|"CpcmdSave"
block|,
literal|10
block|,
literal|1
block|}
block|,
block|{
literal|"RxPstructsFull"
block|,
literal|8
block|,
literal|2
block|}
block|,
block|{
literal|"EpcmdDvld"
block|,
literal|7
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdFlush"
block|,
literal|6
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPrefix"
block|,
literal|5
block|,
literal|1
block|}
block|,
block|{
literal|"EpcmdTrimPostfix"
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp4Pkt"
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|"ERssIp6Pkt"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"ERssTcpUdpPkt"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"ERssFceFipPkt"
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tp_la_show
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
modifier|*
name|p
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|field_desc_show
argument_list|(
name|sb
argument_list|,
operator|*
name|p
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tp_la_show2
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
modifier|*
name|p
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
operator|(
name|TPLA_SIZE
operator|/
literal|2
operator|-
literal|1
operator|)
operator|||
name|p
index|[
literal|1
index|]
operator|!=
operator|~
literal|0ULL
condition|)
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tp_la_show3
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
modifier|*
name|p
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|tp_la0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
operator|(
name|TPLA_SIZE
operator|/
literal|2
operator|-
literal|1
operator|)
operator|||
name|p
index|[
literal|1
index|]
operator|!=
operator|~
literal|0ULL
condition|)
name|field_desc_show
argument_list|(
name|sb
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|(
name|p
index|[
literal|0
index|]
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|)
condition|?
name|tp_la2
else|:
name|tp_la1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tp_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint64_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|inc
decl_stmt|;
name|void
function_decl|(
modifier|*
name|show_func
function_decl|)
parameter_list|(
name|struct
name|sbuf
modifier|*
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|TPLA_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_tp_read_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
switch|switch
condition|(
name|G_DBGLAMODE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|inc
operator|=
literal|2
expr_stmt|;
name|show_func
operator|=
name|tp_la_show2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|inc
operator|=
literal|2
expr_stmt|;
name|show_func
operator|=
name|tp_la_show3
expr_stmt|;
break|break;
default|default:
name|inc
operator|=
literal|1
expr_stmt|;
name|show_func
operator|=
name|tp_la_show
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TPLA_SIZE
operator|/
name|inc
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
name|inc
control|)
call|(
modifier|*
name|show_func
call|)
argument_list|(
name|sb
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tx_rate
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u64
name|nrate
index|[
name|MAX_NCHAN
index|]
decl_stmt|,
name|orate
index|[
name|MAX_NCHAN
index|]
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t4_get_chan_txrate
argument_list|(
name|sc
argument_list|,
name|nrate
argument_list|,
name|orate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_params
operator|->
name|nchan
operator|>
literal|2
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"              channel 0   channel 1"
literal|"   channel 2   channel 3\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NIC B/s:     %10ju  %10ju  %10ju  %10ju\n"
argument_list|,
name|nrate
index|[
literal|0
index|]
argument_list|,
name|nrate
index|[
literal|1
index|]
argument_list|,
name|nrate
index|[
literal|2
index|]
argument_list|,
name|nrate
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Offload B/s: %10ju  %10ju  %10ju  %10ju"
argument_list|,
name|orate
index|[
literal|0
index|]
argument_list|,
name|orate
index|[
literal|1
index|]
argument_list|,
name|orate
index|[
literal|2
index|]
argument_list|,
name|orate
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"              channel 0   channel 1\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NIC B/s:     %10ju  %10ju\n"
argument_list|,
name|nrate
index|[
literal|0
index|]
argument_list|,
name|nrate
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Offload B/s: %10ju  %10ju"
argument_list|,
name|orate
index|[
literal|0
index|]
argument_list|,
name|orate
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_ulprx_la
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|ULPRX_LA_SIZE
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_ulprx_read_la
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"      Pcmd        Type   Message"
literal|"                Data"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ULPRX_LA_SIZE
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|8
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n%08x%08x  %4x  %08x  %08x%08x%08x%08x"
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_wcwr_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|v
decl_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_STATSOURCE_T5
argument_list|(
name|v
argument_list|)
operator|==
literal|7
condition|)
block|{
if|if
condition|(
name|G_STATMODE
argument_list|(
name|v
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"total %d, incomplete %d"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_TOTAL
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_MATCH
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|G_STATMODE
argument_list|(
name|v
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"total %d, data overflow %d"
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_TOTAL
argument_list|)
argument_list|,
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_STAT_MATCH
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint32_t
name|fconf_iconf_to_mode
parameter_list|(
name|uint32_t
name|fconf
parameter_list|,
name|uint32_t
name|iconf
parameter_list|)
block|{
name|uint32_t
name|mode
decl_stmt|;
name|mode
operator|=
name|T4_FILTER_IPv4
operator||
name|T4_FILTER_IPv6
operator||
name|T4_FILTER_IP_SADDR
operator||
name|T4_FILTER_IP_DADDR
operator||
name|T4_FILTER_IP_SPORT
operator||
name|T4_FILTER_IP_DPORT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_FRAGMENTATION
condition|)
name|mode
operator||=
name|T4_FILTER_IP_FRAGMENT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_MPSHITTYPE
condition|)
name|mode
operator||=
name|T4_FILTER_MPS_HIT_TYPE
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_MACMATCH
condition|)
name|mode
operator||=
name|T4_FILTER_MAC_IDX
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_ETHERTYPE
condition|)
name|mode
operator||=
name|T4_FILTER_ETH_TYPE
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_PROTOCOL
condition|)
name|mode
operator||=
name|T4_FILTER_IP_PROTO
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_TOS
condition|)
name|mode
operator||=
name|T4_FILTER_IP_TOS
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_VLAN
condition|)
name|mode
operator||=
name|T4_FILTER_VLAN
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_VNIC_ID
condition|)
block|{
name|mode
operator||=
name|T4_FILTER_VNIC
expr_stmt|;
if|if
condition|(
name|iconf
operator|&
name|F_VNIC
condition|)
name|mode
operator||=
name|T4_FILTER_IC_VNIC
expr_stmt|;
block|}
if|if
condition|(
name|fconf
operator|&
name|F_PORT
condition|)
name|mode
operator||=
name|T4_FILTER_PORT
expr_stmt|;
if|if
condition|(
name|fconf
operator|&
name|F_FCOE
condition|)
name|mode
operator||=
name|T4_FILTER_FCoE
expr_stmt|;
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|mode_to_fconf
parameter_list|(
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|fconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_FRAGMENT
condition|)
name|fconf
operator||=
name|F_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MPS_HIT_TYPE
condition|)
name|fconf
operator||=
name|F_MPSHITTYPE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MAC_IDX
condition|)
name|fconf
operator||=
name|F_MACMATCH
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_ETH_TYPE
condition|)
name|fconf
operator||=
name|F_ETHERTYPE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_PROTO
condition|)
name|fconf
operator||=
name|F_PROTOCOL
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_TOS
condition|)
name|fconf
operator||=
name|F_TOS
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VLAN
condition|)
name|fconf
operator||=
name|F_VLAN
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VNIC
condition|)
name|fconf
operator||=
name|F_VNIC_ID
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_PORT
condition|)
name|fconf
operator||=
name|F_PORT
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_FCoE
condition|)
name|fconf
operator||=
name|F_FCOE
expr_stmt|;
return|return
operator|(
name|fconf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|mode_to_iconf
parameter_list|(
name|uint32_t
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IC_VNIC
condition|)
return|return
operator|(
name|F_VNIC
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_fspec_against_fconf_iconf
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter_specification
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|tp_params
modifier|*
name|tpp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|uint32_t
name|fconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|frag
operator|||
name|fs
operator|->
name|mask
operator|.
name|frag
condition|)
name|fconf
operator||=
name|F_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|matchtype
operator|||
name|fs
operator|->
name|mask
operator|.
name|matchtype
condition|)
name|fconf
operator||=
name|F_MPSHITTYPE
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|macidx
operator|||
name|fs
operator|->
name|mask
operator|.
name|macidx
condition|)
name|fconf
operator||=
name|F_MACMATCH
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|ethtype
operator|||
name|fs
operator|->
name|mask
operator|.
name|ethtype
condition|)
name|fconf
operator||=
name|F_ETHERTYPE
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|proto
operator|||
name|fs
operator|->
name|mask
operator|.
name|proto
condition|)
name|fconf
operator||=
name|F_PROTOCOL
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|tos
operator|||
name|fs
operator|->
name|mask
operator|.
name|tos
condition|)
name|fconf
operator||=
name|F_TOS
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|vlan_vld
operator|||
name|fs
operator|->
name|mask
operator|.
name|vlan_vld
condition|)
name|fconf
operator||=
name|F_VLAN
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|ovlan_vld
operator|||
name|fs
operator|->
name|mask
operator|.
name|ovlan_vld
condition|)
block|{
name|fconf
operator||=
name|F_VNIC_ID
expr_stmt|;
if|if
condition|(
name|tpp
operator|->
name|ingress_config
operator|&
name|F_VNIC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|pfvf_vld
operator|||
name|fs
operator|->
name|mask
operator|.
name|pfvf_vld
condition|)
block|{
name|fconf
operator||=
name|F_VNIC_ID
expr_stmt|;
if|if
condition|(
operator|(
name|tpp
operator|->
name|ingress_config
operator|&
name|F_VNIC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|iport
operator|||
name|fs
operator|->
name|mask
operator|.
name|iport
condition|)
name|fconf
operator||=
name|F_PORT
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|val
operator|.
name|fcoe
operator|||
name|fs
operator|->
name|mask
operator|.
name|fcoe
condition|)
name|fconf
operator||=
name|F_FCOE
expr_stmt|;
if|if
condition|(
operator|(
name|tpp
operator|->
name|vlan_pri_map
operator||
name|fconf
operator|)
operator|!=
name|tpp
operator|->
name|vlan_pri_map
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|tp_params
modifier|*
name|tpp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
comment|/* 	 * We trust the cached values of the relevant TP registers.  This means 	 * things work reliably only if writes to those registers are always via 	 * t4_set_filter_mode. 	 */
operator|*
name|mode
operator|=
name|fconf_iconf_to_mode
argument_list|(
name|tpp
operator|->
name|vlan_pri_map
argument_list|,
name|tpp
operator|->
name|ingress_config
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|struct
name|tp_params
modifier|*
name|tpp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|uint32_t
name|fconf
decl_stmt|,
name|iconf
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|iconf
operator|=
name|mode_to_iconf
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iconf
operator|^
name|tpp
operator|->
name|ingress_config
operator|)
operator|&
name|F_VNIC
condition|)
block|{
comment|/* 		 * For now we just complain if A_TP_INGRESS_CONFIG is not 		 * already set to the correct value for the requested filter 		 * mode.  It's not clear if it's safe to write to this register 		 * on the fly.  (And we trust the cached value of the register). 		 */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|fconf
operator|=
name|mode_to_fconf
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setfm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
name|rc
operator|=
operator|-
name|t4_set_filter_mode
argument_list|(
name|sc
argument_list|,
name|fconf
argument_list|)
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|get_filter_hits
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|fid
parameter_list|)
block|{
name|uint32_t
name|tcb_addr
decl_stmt|;
name|tcb_addr
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_CMM_TCB_BASE
argument_list|)
operator|+
operator|(
name|fid
operator|+
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|)
operator|*
name|TCB_SIZE
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint64_t
name|hits
decl_stmt|;
name|read_via_memwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|tcb_addr
operator|+
literal|16
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|hits
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|be64toh
argument_list|(
name|hits
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|uint32_t
name|hits
decl_stmt|;
name|read_via_memwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|tcb_addr
operator|+
literal|24
argument_list|,
operator|&
name|hits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|be32toh
argument_list|(
name|hits
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|nfilters
init|=
name|sc
operator|->
name|tids
operator|.
name|nftids
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|HOLD_LOCK
operator||
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4getf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
operator|||
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
operator|||
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
block|{
name|t
operator|->
name|idx
operator|=
literal|0xffffffff
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|t
operator|->
name|idx
init|;
name|i
operator|<
name|nfilters
condition|;
name|i
operator|++
operator|,
name|f
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|valid
condition|)
block|{
name|t
operator|->
name|idx
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|l2tidx
operator|=
name|f
operator|->
name|l2t
condition|?
name|f
operator|->
name|l2t
operator|->
name|idx
else|:
literal|0
expr_stmt|;
name|t
operator|->
name|smtidx
operator|=
name|f
operator|->
name|smtidx
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|hitcnts
condition|)
name|t
operator|->
name|hits
operator|=
name|get_filter_hits
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|hits
operator|=
name|UINT64_MAX
expr_stmt|;
name|t
operator|->
name|fs
operator|=
name|f
operator|->
name|fs
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|t
operator|->
name|idx
operator|=
literal|0xffffffff
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
name|LOCK_HELD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|nfilters
decl_stmt|,
name|nports
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|nfilters
operator|=
name|sc
operator|->
name|tids
operator|.
name|nftids
expr_stmt|;
name|nports
operator|=
name|sc
operator|->
name|params
operator|.
name|nports
expr_stmt|;
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Validate against the global filter mode and ingress config */
name|rc
operator|=
name|check_fspec_against_fconf_iconf
argument_list|(
name|sc
argument_list|,
operator|&
name|t
operator|->
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
operator|&&
name|t
operator|->
name|fs
operator|.
name|eport
operator|>=
name|nports
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
operator|>=
name|nports
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Can't specify an iq if not steering to it */
if|if
condition|(
operator|!
name|t
operator|->
name|fs
operator|.
name|dirsteer
operator|&&
name|t
operator|->
name|fs
operator|.
name|iq
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* IPv6 filter idx must be 4 aligned */
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|type
operator|==
literal|1
operator|&&
operator|(
operator|(
name|t
operator|->
name|idx
operator|&
literal|0x3
operator|)
operator|||
name|t
operator|->
name|idx
operator|+
literal|4
operator|>=
name|nfilters
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: no memory allocated but filters_in_use> 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filter_entry
argument_list|)
operator|*
name|nfilters
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|,
literal|"T4 filters"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|pending
operator|||
name|f
operator|->
name|valid
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|locked
condition|)
block|{
name|rc
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|type
operator|==
literal|0
condition|)
break|break;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
name|f
operator|->
name|fs
operator|=
name|t
operator|->
name|fs
expr_stmt|;
name|rc
operator|=
name|set_filter_wr
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|f
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|f
operator|->
name|valid
condition|?
literal|0
else|:
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|,
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4setfw"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINPROGRESS
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|nfilters
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4delf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|nfilters
operator|=
name|sc
operator|->
name|tids
operator|.
name|nftids
expr_stmt|;
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
operator|==
name|NULL
operator|||
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|==
literal|0
operator|||
name|t
operator|->
name|idx
operator|>=
name|nfilters
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|t
operator|->
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|pending
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|locked
condition|)
block|{
name|rc
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|valid
condition|)
block|{
name|t
operator|->
name|fs
operator|=
name|f
operator|->
name|fs
expr_stmt|;
comment|/* extra info for the caller */
name|rc
operator|=
name|del_filter_wr
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|f
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|f
operator|->
name|valid
condition|?
name|EIO
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|,
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4delfw"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINPROGRESS
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_filter
parameter_list|(
name|struct
name|filter_entry
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|l2t
condition|)
name|t4_l2t_release
argument_list|(
name|f
operator|->
name|l2t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|f
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|fidx
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|f
init|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|fidx
index|]
decl_stmt|;
name|struct
name|fw_filter_wr
modifier|*
name|fwr
decl_stmt|;
name|unsigned
name|int
name|ftid
decl_stmt|,
name|vnic_vld
decl_stmt|,
name|vnic_vld_mask
decl_stmt|;
name|struct
name|wrq_cookie
name|cookie
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|newdmac
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
condition|)
block|{
comment|/* This filter needs an L2T entry; allocate one. */
name|f
operator|->
name|l2t
operator|=
name|t4_l2t_alloc_switching
argument_list|(
name|sc
operator|->
name|l2t
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|l2t
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|t4_l2t_set_switching
argument_list|(
name|sc
argument_list|,
name|f
operator|->
name|l2t
argument_list|,
name|f
operator|->
name|fs
operator|.
name|vlan
argument_list|,
name|f
operator|->
name|fs
operator|.
name|eport
argument_list|,
name|f
operator|->
name|fs
operator|.
name|dmac
argument_list|)
condition|)
block|{
name|t4_l2t_release
argument_list|(
name|f
operator|->
name|l2t
argument_list|)
expr_stmt|;
name|f
operator|->
name|l2t
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
comment|/* Already validated against fconf, iconf */
name|MPASS
argument_list|(
operator|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|pfvf_vld
operator|&
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|ovlan_vld
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|pfvf_vld
operator|&
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|ovlan_vld
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|pfvf_vld
operator|||
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|ovlan_vld
condition|)
name|vnic_vld
operator|=
literal|1
expr_stmt|;
else|else
name|vnic_vld
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|pfvf_vld
operator|||
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|ovlan_vld
condition|)
name|vnic_vld_mask
operator|=
literal|1
expr_stmt|;
else|else
name|vnic_vld_mask
operator|=
literal|0
expr_stmt|;
name|ftid
operator|=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|+
name|fidx
expr_stmt|;
name|fwr
operator|=
name|start_wrq_wr
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|,
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|fwr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|op_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FILTER_WR
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|len16_pkd
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|tid_to_iq
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_TID
argument_list|(
name|ftid
argument_list|)
operator||
name|V_FW_FILTER_WR_RQTYPE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|type
argument_list|)
operator||
name|V_FW_FILTER_WR_NOREPLY
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_FILTER_WR_IQ
argument_list|(
name|f
operator|->
name|fs
operator|.
name|iq
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|del_filter_to_l2tix
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_RPTTID
argument_list|(
name|f
operator|->
name|fs
operator|.
name|rpttid
argument_list|)
operator||
name|V_FW_FILTER_WR_DROP
argument_list|(
name|f
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_DROP
argument_list|)
operator||
name|V_FW_FILTER_WR_DIRSTEER
argument_list|(
name|f
operator|->
name|fs
operator|.
name|dirsteer
argument_list|)
operator||
name|V_FW_FILTER_WR_MASKHASH
argument_list|(
name|f
operator|->
name|fs
operator|.
name|maskhash
argument_list|)
operator||
name|V_FW_FILTER_WR_DIRSTEERHASH
argument_list|(
name|f
operator|->
name|fs
operator|.
name|dirsteerhash
argument_list|)
operator||
name|V_FW_FILTER_WR_LPBK
argument_list|(
name|f
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
argument_list|)
operator||
name|V_FW_FILTER_WR_DMAC
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newdmac
argument_list|)
operator||
name|V_FW_FILTER_WR_SMAC
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newsmac
argument_list|)
operator||
name|V_FW_FILTER_WR_INSVLAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_INSERT
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
argument_list|)
operator||
name|V_FW_FILTER_WR_RMVLAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REMOVE
operator|||
name|f
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
argument_list|)
operator||
name|V_FW_FILTER_WR_HITCNTS
argument_list|(
name|f
operator|->
name|fs
operator|.
name|hitcnts
argument_list|)
operator||
name|V_FW_FILTER_WR_TXCHAN
argument_list|(
name|f
operator|->
name|fs
operator|.
name|eport
argument_list|)
operator||
name|V_FW_FILTER_WR_PRIO
argument_list|(
name|f
operator|->
name|fs
operator|.
name|prio
argument_list|)
operator||
name|V_FW_FILTER_WR_L2TIX
argument_list|(
name|f
operator|->
name|l2t
condition|?
name|f
operator|->
name|l2t
operator|->
name|idx
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ethtype
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|ethtype
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ethtypem
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|ethtype
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|frag_to_ovlan_vldm
operator|=
operator|(
name|V_FW_FILTER_WR_FRAG
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|frag
argument_list|)
operator||
name|V_FW_FILTER_WR_FRAGM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|frag
argument_list|)
operator||
name|V_FW_FILTER_WR_IVLAN_VLD
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_OVLAN_VLD
argument_list|(
name|vnic_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_IVLAN_VLDM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan_vld
argument_list|)
operator||
name|V_FW_FILTER_WR_OVLAN_VLDM
argument_list|(
name|vnic_vld_mask
argument_list|)
operator|)
expr_stmt|;
name|fwr
operator|->
name|smac_sel
operator|=
literal|0
expr_stmt|;
name|fwr
operator|->
name|rx_chan_rx_rpl_iq
operator|=
name|htobe16
argument_list|(
name|V_FW_FILTER_WR_RX_CHAN
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_FILTER_WR_RX_RPL_IQ
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|maci_to_matchtypem
operator|=
name|htobe32
argument_list|(
name|V_FW_FILTER_WR_MACI
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|macidx
argument_list|)
operator||
name|V_FW_FILTER_WR_MACIM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|macidx
argument_list|)
operator||
name|V_FW_FILTER_WR_FCOE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|fcoe
argument_list|)
operator||
name|V_FW_FILTER_WR_FCOEM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|fcoe
argument_list|)
operator||
name|V_FW_FILTER_WR_PORT
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
argument_list|)
operator||
name|V_FW_FILTER_WR_PORTM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|iport
argument_list|)
operator||
name|V_FW_FILTER_WR_MATCHTYPE
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|matchtype
argument_list|)
operator||
name|V_FW_FILTER_WR_MATCHTYPEM
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|matchtype
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ptcl
operator|=
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|proto
expr_stmt|;
name|fwr
operator|->
name|ptclm
operator|=
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|proto
expr_stmt|;
name|fwr
operator|->
name|ttyp
operator|=
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|tos
expr_stmt|;
name|fwr
operator|->
name|ttypm
operator|=
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|tos
expr_stmt|;
name|fwr
operator|->
name|ivlan
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ivlanm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ovlan
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|ovlanm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|dip
argument_list|,
name|fwr
operator|->
name|lip
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|lip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|dip
argument_list|,
name|fwr
operator|->
name|lipm
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|lipm
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|sip
argument_list|,
name|fwr
operator|->
name|fip
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|fip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|sip
argument_list|,
name|fwr
operator|->
name|fipm
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|fipm
argument_list|)
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|lp
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|dport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|lpm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|dport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|fp
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|val
operator|.
name|sport
argument_list|)
expr_stmt|;
name|fwr
operator|->
name|fpm
operator|=
name|htobe16
argument_list|(
name|f
operator|->
name|fs
operator|.
name|mask
operator|.
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fs
operator|.
name|newsmac
condition|)
name|bcopy
argument_list|(
name|f
operator|->
name|fs
operator|.
name|smac
argument_list|,
name|fwr
operator|->
name|sma
argument_list|,
sizeof|sizeof
argument_list|(
name|fwr
operator|->
name|sma
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|++
expr_stmt|;
name|commit_wrq_wr
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|,
name|fwr
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|fidx
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|f
init|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|fidx
index|]
decl_stmt|;
name|struct
name|fw_filter_wr
modifier|*
name|fwr
decl_stmt|;
name|unsigned
name|int
name|ftid
decl_stmt|;
name|struct
name|wrq_cookie
name|cookie
decl_stmt|;
name|ftid
operator|=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|+
name|fidx
expr_stmt|;
name|fwr
operator|=
name|start_wrq_wr
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|,
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|fwr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwr
argument_list|)
argument_list|)
expr_stmt|;
name|t4_mk_filtdelwr
argument_list|(
name|ftid
argument_list|,
name|fwr
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|commit_wrq_wr
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|,
name|fwr
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_filter_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|rpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|idx
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rc
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|f
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: payload with opcode %02x"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ftid
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|idx
operator|-=
name|sc
operator|->
name|tids
operator|.
name|ftid_base
expr_stmt|;
name|f
operator|=
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
index|[
name|idx
index|]
expr_stmt|;
name|rc
operator|=
name|G_COOKIE
argument_list|(
name|rpl
operator|->
name|cookie
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|FW_FILTER_WR_FLT_ADDED
condition|)
block|{
name|KASSERT
argument_list|(
name|f
operator|->
name|pending
argument_list|,
operator|(
literal|"%s: filter[%u] isn't pending."
operator|,
name|__func__
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|smtidx
operator|=
operator|(
name|be64toh
argument_list|(
name|rpl
operator|->
name|oldval
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|f
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
comment|/* asynchronous setup completed */
name|f
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rc
operator|!=
name|FW_FILTER_WR_FLT_DELETED
condition|)
block|{
comment|/* Add or delete failed, display an error */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filter %u setup failed with error %u\n"
argument_list|,
name|idx
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|clear_filter
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftids_in_use
operator|--
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_tab
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tids
operator|.
name|ftid_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_sge_context
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_sge_context
modifier|*
name|cntxt
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|cntxt
operator|->
name|cid
operator|>
name|M_CTXTQID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_EGRESS
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_INGRESS
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_FLM
operator|&&
name|cntxt
operator|->
name|mem_id
operator|!=
name|CTXT_CNM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4ctxt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FW_OK
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_sge_ctxt_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|cntxt
operator|->
name|cid
argument_list|,
name|cntxt
operator|->
name|mem_id
argument_list|,
operator|&
name|cntxt
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Read via firmware failed or wasn't even attempted.  Read directly via 	 * the backdoor. 	 */
name|rc
operator|=
operator|-
name|t4_sge_ctxt_rd_bd
argument_list|(
name|sc
argument_list|,
name|cntxt
operator|->
name|cid
argument_list|,
name|cntxt
operator|->
name|mem_id
argument_list|,
operator|&
name|cntxt
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_fw
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_data
modifier|*
name|fw
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint8_t
modifier|*
name|fw_data
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4ldfw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fw_data
operator|=
name|malloc
argument_list|(
name|fw
operator|->
name|len
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_data
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|copyin
argument_list|(
name|fw
operator|->
name|data
argument_list|,
name|fw_data
argument_list|,
name|fw
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|rc
operator|=
operator|-
name|t4_load_fw
argument_list|(
name|sc
argument_list|,
name|fw_data
argument_list|,
name|fw
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fw_data
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_READ_BUF_SIZE
value|(128 * 1024)
end_define

begin_function
specifier|static
name|int
name|read_card_mem
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|win
parameter_list|,
name|struct
name|t4_mem_range
modifier|*
name|mr
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|,
name|remaining
decl_stmt|,
name|n
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|uint8_t
modifier|*
name|dst
decl_stmt|;
name|rc
operator|=
name|validate_mem_range
argument_list|(
name|sc
argument_list|,
name|mr
operator|->
name|addr
argument_list|,
name|mr
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|min
argument_list|(
name|mr
operator|->
name|len
argument_list|,
name|MAX_READ_BUF_SIZE
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mr
operator|->
name|addr
expr_stmt|;
name|remaining
operator|=
name|mr
operator|->
name|len
expr_stmt|;
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
name|mr
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|remaining
condition|)
block|{
name|n
operator|=
name|min
argument_list|(
name|remaining
argument_list|,
name|MAX_READ_BUF_SIZE
argument_list|)
expr_stmt|;
name|read_via_memwin
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|rc
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|dst
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
name|dst
operator|+=
name|n
expr_stmt|;
name|remaining
operator|-=
name|n
expr_stmt|;
name|addr
operator|+=
name|n
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MAX_READ_BUF_SIZE
end_undef

begin_function
specifier|static
name|int
name|read_i2c
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_i2c_data
modifier|*
name|i2cd
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|i2cd
operator|->
name|len
operator|==
literal|0
operator|||
name|i2cd
operator|->
name|port_id
operator|>=
name|sc
operator|->
name|params
operator|.
name|nports
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|i2cd
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|i2cd
operator|->
name|data
argument_list|)
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4i2crd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
operator|-
name|t4_i2c_rd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|i2cd
operator|->
name|port_id
argument_list|,
name|i2cd
operator|->
name|dev_addr
argument_list|,
name|i2cd
operator|->
name|offset
argument_list|,
name|i2cd
operator|->
name|len
argument_list|,
operator|&
name|i2cd
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|in_range
parameter_list|(
name|int
name|val
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
return|return
operator|(
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|<=
name|hi
operator|&&
name|val
operator|>=
name|lo
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_sched_class
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_sched_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|fw_subcmd
decl_stmt|,
name|fw_type
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setsc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Translate the cxgbetool parameters into T4 firmware parameters.  (The 	 * sub-command and type are in common locations.) 	 */
if|if
condition|(
name|p
operator|->
name|subcmd
operator|==
name|SCHED_CLASS_SUBCMD_CONFIG
condition|)
name|fw_subcmd
operator|=
name|FW_SCHED_SC_CONFIG
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|subcmd
operator|==
name|SCHED_CLASS_SUBCMD_PARAMS
condition|)
name|fw_subcmd
operator|=
name|FW_SCHED_SC_PARAMS
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|SCHED_CLASS_TYPE_PACKET
condition|)
name|fw_type
operator|=
name|FW_SCHED_TYPE_PKTSCHED
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|fw_subcmd
operator|==
name|FW_SCHED_SC_CONFIG
condition|)
block|{
comment|/* Vet our parameters ..*/
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|config
operator|.
name|minmax
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* And pass the request to the firmware ...*/
name|rc
operator|=
operator|-
name|t4_sched_config
argument_list|(
name|sc
argument_list|,
name|fw_type
argument_list|,
name|p
operator|->
name|u
operator|.
name|config
operator|.
name|minmax
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|fw_subcmd
operator|==
name|FW_SCHED_SC_PARAMS
condition|)
block|{
name|int
name|fw_level
decl_stmt|;
name|int
name|fw_mode
decl_stmt|;
name|int
name|fw_rateunit
decl_stmt|;
name|int
name|fw_ratemode
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_RL
condition|)
name|fw_level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CL_RL
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_WRR
condition|)
name|fw_level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CL_WRR
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CH_RL
condition|)
name|fw_level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CH_RL
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|mode
operator|==
name|SCHED_CLASS_MODE_CLASS
condition|)
name|fw_mode
operator|=
name|FW_SCHED_PARAMS_MODE_CLASS
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|mode
operator|==
name|SCHED_CLASS_MODE_FLOW
condition|)
name|fw_mode
operator|=
name|FW_SCHED_PARAMS_MODE_FLOW
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|rateunit
operator|==
name|SCHED_CLASS_RATEUNIT_BITS
condition|)
name|fw_rateunit
operator|=
name|FW_SCHED_PARAMS_UNIT_BITRATE
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|rateunit
operator|==
name|SCHED_CLASS_RATEUNIT_PKTS
condition|)
name|fw_rateunit
operator|=
name|FW_SCHED_PARAMS_UNIT_PKTRATE
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|ratemode
operator|==
name|SCHED_CLASS_RATEMODE_REL
condition|)
name|fw_ratemode
operator|=
name|FW_SCHED_PARAMS_RATE_REL
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|ratemode
operator|==
name|SCHED_CLASS_RATEMODE_ABS
condition|)
name|fw_ratemode
operator|=
name|FW_SCHED_PARAMS_RATE_ABS
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Vet our parameters ... */
if|if
condition|(
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|channel
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|cl
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|chip_params
operator|->
name|nsched_cls
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Translate any unset parameters into the firmware's 		 * nomenclature and/or fail the call if the parameters 		 * are required ... 		 */
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|rateunit
operator|<
literal|0
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|ratemode
operator|<
literal|0
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|channel
operator|<
literal|0
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|cl
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
operator|<
literal|0
condition|)
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_RL
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CH_RL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_WRR
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|pktsize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CL_RL
operator|||
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|level
operator|==
name|SCHED_CLASS_LEVEL_CH_RL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|pktsize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See what the firmware thinks of the request ... */
name|rc
operator|=
operator|-
name|t4_sched_params
argument_list|(
name|sc
argument_list|,
name|fw_type
argument_list|,
name|fw_level
argument_list|,
name|fw_mode
argument_list|,
name|fw_rateunit
argument_list|,
name|fw_ratemode
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|channel
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|cl
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|minrate
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|maxrate
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|weight
argument_list|,
name|p
operator|->
name|u
operator|.
name|params
operator|.
name|pktsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_sched_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_sched_queue
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|NULL
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|uint32_t
name|fw_mnem
decl_stmt|,
name|fw_queue
decl_stmt|,
name|fw_class
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4setsq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|port
operator|>=
name|sc
operator|->
name|params
operator|.
name|nports
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* XXX: Only supported for the main VI. */
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|p
operator|->
name|port
index|]
expr_stmt|;
name|vi
operator|=
operator|&
name|pi
operator|->
name|vi
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|queue
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|ntxq
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|p
operator|->
name|cl
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Create a template for the FW_PARAMS_CMD mnemonic and value (TX 	 * Scheduling Class in this case). 	 */
name|fw_mnem
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DMAQ
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DMAQ_EQ_SCHEDCLASS_ETH
argument_list|)
operator|)
expr_stmt|;
name|fw_class
operator|=
name|p
operator|->
name|cl
operator|<
literal|0
condition|?
literal|0xffffffff
else|:
name|p
operator|->
name|cl
expr_stmt|;
comment|/* 	 * If op.queue is non-negative, then we're only changing the scheduling 	 * on a single specified TX queue. 	 */
if|if
condition|(
name|p
operator|->
name|queue
operator|>=
literal|0
condition|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|txq
index|[
name|vi
operator|->
name|first_txq
operator|+
name|p
operator|->
name|queue
index|]
expr_stmt|;
name|fw_queue
operator|=
operator|(
name|fw_mnem
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|txq
operator|->
name|eq
operator|.
name|cntxt_id
argument_list|)
operator|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|fw_queue
argument_list|,
operator|&
name|fw_class
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Change the scheduling on all the TX queues for the 	 * interface. 	 */
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|fw_queue
operator|=
operator|(
name|fw_mnem
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|txq
operator|->
name|eq
operator|.
name|cntxt_id
argument_list|)
operator|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|fw_queue
argument_list|,
operator|&
name|fw_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_find_pci_capability
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
return|return
operator|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|cap
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|?
name|i
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_os_portmod_changed
parameter_list|(
specifier|const
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|v
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|mod_str
index|[]
init|=
block|{
name|NULL
block|,
literal|"LR"
block|,
literal|"SR"
block|,
literal|"ER"
block|,
literal|"TWINAX"
block|,
literal|"active TWINAX"
block|,
literal|"LRM"
block|}
decl_stmt|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
name|build_medialist
argument_list|(
name|pi
argument_list|,
operator|&
name|vi
operator|->
name|media
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|=
name|pi
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|ifp
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_NONE
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"transceiver unplugged.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_UNKNOWN
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unknown transceiver inserted.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_NOTSUPPORTED
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unsupported transceiver inserted.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|>
literal|0
operator|&&
name|pi
operator|->
name|mod_type
operator|<
name|nitems
argument_list|(
name|mod_str
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s transceiver inserted.\n"
argument_list|,
name|mod_str
index|[
name|pi
operator|->
name|mod_type
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"transceiver (type %d) inserted.\n"
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_os_link_changed
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|link_stat
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|v
decl_stmt|;
if|if
condition|(
name|link_stat
condition|)
name|pi
operator|->
name|linkdnrc
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reason
operator|>=
literal|0
condition|)
name|pi
operator|->
name|linkdnrc
operator|=
name|reason
expr_stmt|;
block|}
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
name|ifp
operator|=
name|vi
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|link_stat
condition|)
block|{
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|pi
operator|->
name|link_cfg
operator|.
name|speed
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|t4_iterate
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&t4_list
argument_list|,
argument|link
argument_list|)
block|{
comment|/* 		 * func should not make any assumptions about what state sc is 		 * in - the only guarantee is that sc->sc_lock is a valid lock. 		 */
name|func
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|rc
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHELSIO_T4_GETREG
case|:
block|{
name|struct
name|t4_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|4
condition|)
name|edata
operator|->
name|val
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|8
condition|)
name|edata
operator|->
name|val
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|CHELSIO_T4_SETREG
case|:
block|{
name|struct
name|t4_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|edata
operator|->
name|val
operator|&
literal|0xffffffff00000000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
operator|(
name|uint32_t
operator|)
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edata
operator|->
name|size
operator|==
literal|8
condition|)
name|t4_write_reg64
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|CHELSIO_T4_REGDUMP
case|:
block|{
name|struct
name|t4_regdump
modifier|*
name|regs
init|=
operator|(
expr|struct
name|t4_regdump
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|reglen
init|=
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|?
name|T4_REGDUMP_SIZE
else|:
name|T5_REGDUMP_SIZE
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|regs
operator|->
name|len
operator|<
name|reglen
condition|)
block|{
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
comment|/* hint to the caller */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|reglen
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|get_regs
argument_list|(
name|sc
argument_list|,
name|regs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rc
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|regs
operator|->
name|data
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_T4_GET_FILTER_MODE
case|:
name|rc
operator|=
name|get_filter_mode
argument_list|(
name|sc
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_FILTER_MODE
case|:
name|rc
operator|=
name|set_filter_mode
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_FILTER
case|:
name|rc
operator|=
name|get_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_FILTER
case|:
name|rc
operator|=
name|set_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_DEL_FILTER
case|:
name|rc
operator|=
name|del_filter
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_filter
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_SGE_CONTEXT
case|:
name|rc
operator|=
name|get_sge_context
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_sge_context
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_LOAD_FW
case|:
name|rc
operator|=
name|load_fw
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_data
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_MEM
case|:
name|rc
operator|=
name|read_card_mem
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
operator|(
expr|struct
name|t4_mem_range
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_I2C
case|:
name|rc
operator|=
name|read_i2c
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_i2c_data
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_CLEAR_STATS
case|:
block|{
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|u_int
name|port_id
init|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
decl_stmt|;
if|if
condition|(
name|port_id
operator|>=
name|sc
operator|->
name|params
operator|.
name|nports
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|port_id
index|]
expr_stmt|;
comment|/* MAC stats */
name|t4_clr_port_stats
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|pi
operator|->
name|tx_parse_error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
name|t4_clr_vi_stats
argument_list|(
name|sc
argument_list|,
name|vi
operator|->
name|viid
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Since this command accepts a port, clear stats for 		 * all VIs on this port. 		 */
name|for_each_vi
argument_list|(
argument|pi
argument_list|,
argument|v
argument_list|,
argument|vi
argument_list|)
block|{
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
condition|)
block|{
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|wrq
decl_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_NETMAP
condition|)
continue|continue;
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|rxq
operator|->
name|lro
operator|.
name|lro_queued
operator|=
literal|0
expr_stmt|;
name|rxq
operator|->
name|lro
operator|.
name|lro_flushed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|rxq
operator|->
name|rxcsum
operator|=
literal|0
expr_stmt|;
name|rxq
operator|->
name|vlan_extraction
operator|=
literal|0
expr_stmt|;
block|}
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|txq
operator|->
name|txcsum
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|tso_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|vlan_insertion
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|imm_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|sgl_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkt_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkts0_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkts1_wrs
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkts0_pkts
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|txpkts1_pkts
operator|=
literal|0
expr_stmt|;
name|mp_ring_reset_stats
argument_list|(
name|txq
operator|->
name|r
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
comment|/* nothing to clear for each ofld_rxq */
name|for_each_ofld_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|wrq
argument_list|)
block|{
name|wrq
operator|->
name|tx_wrs_direct
operator|=
literal|0
expr_stmt|;
name|wrq
operator|->
name|tx_wrs_copied
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|IS_MAIN_VI
argument_list|(
name|vi
argument_list|)
condition|)
block|{
name|wrq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
expr_stmt|;
name|wrq
operator|->
name|tx_wrs_direct
operator|=
literal|0
expr_stmt|;
name|wrq
operator|->
name|tx_wrs_copied
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|CHELSIO_T4_SCHED_CLASS
case|:
name|rc
operator|=
name|set_sched_class
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_sched_params
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SCHED_QUEUE
case|:
name|rc
operator|=
name|set_sched_queue
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_sched_queue
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_GET_TRACER
case|:
name|rc
operator|=
name|t4_get_tracer
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_tracer
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T4_SET_TRACER
case|:
name|rc
operator|=
name|t4_set_tracer
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|t4_tracer
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_db_full
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|CXGBE_UNIMPLEMENTED
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_db_dropped
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|CXGBE_UNIMPLEMENTED
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function
name|void
name|t4_iscsi_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|u_int
name|tag_mask
parameter_list|,
specifier|const
name|u_int
modifier|*
name|pgsz_order
parameter_list|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_ISCSI_TAGMASK
argument_list|,
name|tag_mask
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_ISCSI_PSZ
argument_list|,
name|V_HPZ0
argument_list|(
name|pgsz_order
index|[
literal|0
index|]
argument_list|)
operator||
name|V_HPZ1
argument_list|(
name|pgsz_order
index|[
literal|1
index|]
argument_list|)
operator||
name|V_HPZ2
argument_list|(
name|pgsz_order
index|[
literal|2
index|]
argument_list|)
operator||
name|V_HPZ3
argument_list|(
name|pgsz_order
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
operator|(
name|vi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* TOE is already enabled. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * We need the port's queues around so that we're able to send 		 * and receive CPLs to/from the TOE even if the ifnet for this 		 * port has never been UP'd administratively. 		 */
if|if
condition|(
operator|!
operator|(
name|vi
operator|->
name|flags
operator|&
name|VI_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|cxgbe_init_synchronized
argument_list|(
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|pi
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|VI_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|cxgbe_init_synchronized
argument_list|(
operator|&
name|pi
operator|->
name|vi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
block|{
comment|/* TOE is enabled on another VI of this port. */
name|pi
operator|->
name|uld_vis
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
condition|)
block|{
name|rc
operator|=
name|t4_activate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EAGAIN
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"You must kldload t4_tom.ko before trying "
literal|"to enable TOE on a cxgbe interface.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|tom_softc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: TOM activated but softc NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
argument_list|,
operator|(
literal|"%s: TOM activated but flag not set"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Activate iWARP and iSCSI too, if the modules are loaded. */
if|if
condition|(
operator|!
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_IWARP
argument_list|)
condition|)
operator|(
name|void
operator|)
name|t4_activate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_IWARP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_ISCSI
argument_list|)
condition|)
operator|(
name|void
operator|)
name|t4_activate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_ISCSI
argument_list|)
expr_stmt|;
name|pi
operator|->
name|uld_vis
operator|++
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|uld_vis
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
operator|||
name|pi
operator|->
name|uld_vis
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|uld_active
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
argument_list|,
operator|(
literal|"%s: TOM never initialized?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an upper layer driver to the global list.  */
end_comment

begin_function
name|int
name|t4_register_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|->
name|uld_id
operator|==
name|ui
operator|->
name|uld_id
condition|)
block|{
name|rc
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t4_uld_list
argument_list|,
name|ui
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ui
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_unregister_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|==
name|ui
condition|)
block|{
if|if
condition|(
name|ui
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|t4_uld_list
argument_list|,
name|ui
argument_list|,
name|uld_info
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_activate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|id
operator|>
name|ULD_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
comment|/* kldoad the module with this ULD and try again. */
name|sx_slock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|adapter_full_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
block|}
name|rc
operator|=
name|ui
operator|->
name|activate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|active_ulds
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ui
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_deactivate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|ASSERT_SYNCHRONIZED_OP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|id
operator|>
name|ULD_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t4_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
name|rc
operator|=
name|ui
operator|->
name|deactivate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|active_ulds
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ui
operator|->
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
block|}
block|}
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uld_active
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|uld_id
parameter_list|)
block|{
name|MPASS
argument_list|(
name|uld_id
operator|>=
literal|0
operator|&&
name|uld_id
operator|<=
name|ULD_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|active_ulds
argument_list|,
name|uld_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Come up with reasonable defaults for some of the tunables, provided they're  * not set by the user (in which case we'll use the values as is).  */
end_comment

begin_function
specifier|static
name|void
name|tweak_tunables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nc
init|=
name|mp_ncpus
decl_stmt|;
comment|/* our snapshot of the number of CPUs */
if|if
condition|(
name|t4_ntxq10g
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|t4_ntxq10g
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
else|#
directive|else
name|t4_ntxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NTXQ_10G
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|t4_ntxq1g
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
comment|/* XXX: way too many for 1GbE? */
name|t4_ntxq1g
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
else|#
directive|else
name|t4_ntxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NTXQ_1G
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|t4_nrxq10g
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|t4_nrxq10g
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
else|#
directive|else
name|t4_nrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NRXQ_10G
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|t4_nrxq1g
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
comment|/* XXX: way too many for 1GbE? */
name|t4_nrxq1g
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
else|#
directive|else
name|t4_nrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NRXQ_1G
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|t4_nofldtxq10g
operator|<
literal|1
condition|)
name|t4_nofldtxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDTXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldtxq1g
operator|<
literal|1
condition|)
name|t4_nofldtxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDTXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldrxq10g
operator|<
literal|1
condition|)
name|t4_nofldrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDRXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nofldrxq1g
operator|<
literal|1
condition|)
name|t4_nofldrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NOFLDRXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_toecaps_allowed
operator|==
operator|-
literal|1
condition|)
name|t4_toecaps_allowed
operator|=
name|FW_CAPS_CONFIG_TOE
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|t4_toecaps_allowed
operator|==
operator|-
literal|1
condition|)
name|t4_toecaps_allowed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|t4_nnmtxq10g
operator|<
literal|1
condition|)
name|t4_nnmtxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMTXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nnmtxq1g
operator|<
literal|1
condition|)
name|t4_nnmtxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMTXQ_1G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nnmrxq10g
operator|<
literal|1
condition|)
name|t4_nnmrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMRXQ_10G
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_nnmrxq1g
operator|<
literal|1
condition|)
name|t4_nnmrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|NNMRXQ_1G
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t4_tmr_idx_10g
operator|<
literal|0
operator|||
name|t4_tmr_idx_10g
operator|>=
name|SGE_NTIMERS
condition|)
name|t4_tmr_idx_10g
operator|=
name|TMR_IDX_10G
expr_stmt|;
if|if
condition|(
name|t4_pktc_idx_10g
operator|<
operator|-
literal|1
operator|||
name|t4_pktc_idx_10g
operator|>=
name|SGE_NCOUNTERS
condition|)
name|t4_pktc_idx_10g
operator|=
name|PKTC_IDX_10G
expr_stmt|;
if|if
condition|(
name|t4_tmr_idx_1g
operator|<
literal|0
operator|||
name|t4_tmr_idx_1g
operator|>=
name|SGE_NTIMERS
condition|)
name|t4_tmr_idx_1g
operator|=
name|TMR_IDX_1G
expr_stmt|;
if|if
condition|(
name|t4_pktc_idx_1g
operator|<
operator|-
literal|1
operator|||
name|t4_pktc_idx_1g
operator|>=
name|SGE_NCOUNTERS
condition|)
name|t4_pktc_idx_1g
operator|=
name|PKTC_IDX_1G
expr_stmt|;
if|if
condition|(
name|t4_qsize_txq
operator|<
literal|128
condition|)
name|t4_qsize_txq
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|t4_qsize_rxq
operator|<
literal|128
condition|)
name|t4_qsize_rxq
operator|=
literal|128
expr_stmt|;
while|while
condition|(
name|t4_qsize_rxq
operator|&
literal|7
condition|)
name|t4_qsize_rxq
operator|++
expr_stmt|;
name|t4_intr_types
operator|&=
name|INTR_MSIX
operator||
name|INTR_MSI
operator||
name|INTR_INTX
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sx
name|mlu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mod load unload */
end_comment

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|cxgbe_mlu
argument_list|,
operator|&
name|mlu
argument_list|,
literal|"cxgbe mod load/unload"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|loaded
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|sx_xlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
if|if
condition|(
name|loaded
operator|++
operator|==
literal|0
condition|)
block|{
name|t4_sge_modload
argument_list|()
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|t4_list_lock
argument_list|,
literal|"T4/T5 adapters"
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t4_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_init
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|,
literal|"T4/T5 ULDs"
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t4_uld_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t4_tracer_modload
argument_list|()
expr_stmt|;
name|tweak_tunables
argument_list|()
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|sx_xlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loaded
operator|==
literal|0
condition|)
block|{
name|int
name|tries
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t4_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
goto|goto
name|done_unload
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_slock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t4_uld_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
goto|goto
name|done_unload
goto|;
block|}
endif|#
directive|endif
name|tries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|5
operator|&&
name|t4_sge_extfree_refs
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"%ju clusters with custom free routine "
literal|"still is use.\n"
argument_list|,
name|t4_sge_extfree_refs
argument_list|()
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"t4unload"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_sunlock
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sx_sunlock
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_sge_extfree_refs
argument_list|()
operator|==
literal|0
condition|)
block|{
name|t4_tracer_modunload
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|sx_destroy
argument_list|(
operator|&
name|t4_uld_list_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sx_destroy
argument_list|(
operator|&
name|t4_list_lock
argument_list|)
expr_stmt|;
name|t4_sge_modunload
argument_list|()
expr_stmt|;
name|loaded
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|loaded
operator|++
expr_stmt|;
comment|/* undo earlier decrement */
block|}
block|}
name|done_unload
label|:
name|sx_xunlock
argument_list|(
operator|&
name|mlu
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|t4_devclass
decl_stmt|,
name|t5_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgbe_devclass
decl_stmt|,
name|cxl_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|vcxgbe_devclass
decl_stmt|,
name|vcxl_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|t4nex
argument_list|,
name|pci
argument_list|,
name|t4_driver
argument_list|,
name|t4_devclass
argument_list|,
name|mod_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t4nex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t4nex
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t4nex
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|t5nex
argument_list|,
name|pci
argument_list|,
name|t5_driver
argument_list|,
name|t5_devclass
argument_list|,
name|mod_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t5nex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t5nex
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t5nex
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgbe
argument_list|,
name|t4nex
argument_list|,
name|cxgbe_driver
argument_list|,
name|cxgbe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxgbe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxl
argument_list|,
name|t5nex
argument_list|,
name|cxl_driver
argument_list|,
name|cxl_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vcxgbe
argument_list|,
name|cxgbe
argument_list|,
name|vcxgbe_driver
argument_list|,
name|vcxgbe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|vcxgbe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vcxl
argument_list|,
name|cxl
argument_list|,
name|vcxl_driver
argument_list|,
name|vcxl_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|vcxl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

