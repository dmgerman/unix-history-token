begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|"common/t4_hw.h"
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"common/t4fw_interface.h"
end_include

begin_include
include|#
directive|include
file|"t4_ioctl.h"
end_include

begin_comment
comment|/* T4 bus driver interface */
end_comment

begin_function_decl
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|t4_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|t4_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|t4_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|t4_detach
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|t4_driver
init|=
block|{
literal|"t4nex"
block|,
name|t4_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T4 port (cxgbe) interface */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgbe_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgbe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgbe_driver
init|=
block|{
literal|"cxgbe"
block|,
name|cxgbe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|port_info
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|t4_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|t4_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|t4_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|t4_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|t4_open
block|,
operator|.
name|d_close
operator|=
name|t4_close
block|,
operator|.
name|d_ioctl
operator|=
name|t4_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"t4nex"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ifnet + media interface */
end_comment

begin_function_decl
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CXGBE
argument_list|,
literal|"cxgbe"
argument_list|,
literal|"Chelsio T4 Ethernet driver and services"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tunables.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|cxgbe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"cxgbe driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|force_firmware_install
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.force_firmware_install"
argument_list|,
operator|&
name|force_firmware_install
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|force_firmware_install
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|force_firmware_install
argument_list|,
literal|0
argument_list|,
literal|"install firmware on every attach."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Holdoff timer and packet counter values.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|intr_timer
index|[
name|SGE_NTIMERS
index|]
init|=
block|{
literal|1
block|,
literal|5
block|,
literal|10
block|,
literal|50
block|,
literal|100
block|,
literal|200
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|intr_pktcount
index|[
name|SGE_NCOUNTERS
index|]
init|=
block|{
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 63 max */
end_comment

begin_comment
comment|/*  * Max # of tx and rx queues to use for each 10G and 1G port.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_ntxq_10g
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.max_ntxq_10G_port"
argument_list|,
operator|&
name|max_ntxq_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|max_ntxq_10G_port
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_ntxq_10g
argument_list|,
literal|0
argument_list|,
literal|"maximum number of tx queues per 10G port."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_nrxq_10g
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.max_nrxq_10G_port"
argument_list|,
operator|&
name|max_nrxq_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|max_nrxq_10G_port
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_nrxq_10g
argument_list|,
literal|0
argument_list|,
literal|"maximum number of rxq's (per 10G port)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_ntxq_1g
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.max_ntxq_1G_port"
argument_list|,
operator|&
name|max_ntxq_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|max_ntxq_1G_port
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_ntxq_1g
argument_list|,
literal|0
argument_list|,
literal|"maximum number of tx queues per 1G port."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_nrxq_1g
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.max_nrxq_1G_port"
argument_list|,
operator|&
name|max_nrxq_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|max_nrxq_1G_port
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_nrxq_1g
argument_list|,
literal|0
argument_list|,
literal|"maximum number of rxq's (per 1G port)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Holdoff parameters for 10G and 1G ports.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tmr_idx_10g
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_10G"
argument_list|,
operator|&
name|tmr_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|holdoff_timer_idx_10G
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|tmr_idx_10g
argument_list|,
literal|0
argument_list|,
literal|"default timer index for interrupt holdoff (10G ports)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pktc_idx_10g
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_10G"
argument_list|,
operator|&
name|pktc_idx_10g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|holdoff_pktc_idx_10G
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pktc_idx_10g
argument_list|,
literal|0
argument_list|,
literal|"default pkt counter index for interrupt holdoff (10G ports)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tmr_idx_1g
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_timer_idx_1G"
argument_list|,
operator|&
name|tmr_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|holdoff_timer_idx_1G
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|tmr_idx_1g
argument_list|,
literal|0
argument_list|,
literal|"default timer index for interrupt holdoff (1G ports)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pktc_idx_1g
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.holdoff_pktc_idx_1G"
argument_list|,
operator|&
name|pktc_idx_1g
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|holdoff_pktc_idx_1G
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pktc_idx_1g
argument_list|,
literal|0
argument_list|,
literal|"default pkt counter index for interrupt holdoff (1G ports)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Size (# of entries) of each tx and rx queue.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|qsize_txq
init|=
name|TX_EQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_txq"
argument_list|,
operator|&
name|qsize_txq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|qsize_txq
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|qsize_txq
argument_list|,
literal|0
argument_list|,
literal|"default queue size of NIC tx queues."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|qsize_rxq
init|=
name|RX_IQ_QSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.qsize_rxq"
argument_list|,
operator|&
name|qsize_rxq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|qsize_rxq
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|qsize_rxq
argument_list|,
literal|0
argument_list|,
literal|"default queue size of NIC rx queues."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Interrupt types allowed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intr_types
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.interrupt_types"
argument_list|,
operator|&
name|intr_types
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|interrupt_types
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|intr_types
argument_list|,
literal|0
argument_list|,
literal|"interrupt types allowed (bits 0, 1, 2 = INTx, MSI, MSI-X respectively)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Force the driver to use interrupt forwarding.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intr_fwd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.interrupt_forwarding"
argument_list|,
operator|&
name|intr_fwd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgbe
argument_list|,
name|OID_AUTO
argument_list|,
name|interrupt_forwarding
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|intr_fwd
argument_list|,
literal|0
argument_list|,
literal|"always use forwarded interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|intrs_and_queues
block|{
name|int
name|intr_type
decl_stmt|;
comment|/* 1, 2, or 4 for INTx, MSI, or MSI-X */
name|int
name|nirq
decl_stmt|;
comment|/* Number of vectors */
name|int
name|intr_fwd
decl_stmt|;
comment|/* Interrupts forwarded */
name|int
name|ntxq10g
decl_stmt|;
comment|/* # of NIC txq's for each 10G port */
name|int
name|nrxq10g
decl_stmt|;
comment|/* # of NIC rxq's for each 10G port */
name|int
name|ntxq1g
decl_stmt|;
comment|/* # of NIC txq's for each 1G port */
name|int
name|nrxq1g
decl_stmt|;
comment|/* # of NIC rxq's for each 1G port */
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|MEMWIN0_APERTURE
init|=
literal|2048
block|,
name|MEMWIN0_BASE
init|=
literal|0x1b800
block|,
name|MEMWIN1_APERTURE
init|=
literal|32768
block|,
name|MEMWIN1_BASE
init|=
literal|0x28000
block|,
name|MEMWIN2_APERTURE
init|=
literal|65536
block|,
name|MEMWIN2_BASE
init|=
literal|0x30000
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|XGMAC_MTU
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|XGMAC_PROMISC
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|XGMAC_ALLMULTI
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|XGMAC_VLANEX
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|XGMAC_UCADDR
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|XGMAC_MCADDRS
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|XGMAC_ALL
init|=
literal|0xffff
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|map_bars
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_capabilities
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|fw_caps_config_cmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_params
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|fw_caps_config_cmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_mac_settings
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_uninit_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|first_port_up
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|last_port_down
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|,
name|int
name|rid
parameter_list|,
name|iq_intr_handler_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|irq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t4_get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_regdump
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|txq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|t4_pciids
block|{
name|uint16_t
name|device
decl_stmt|;
name|uint8_t
name|mpf
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|t4_pciids
index|[]
init|=
block|{
block|{
literal|0xa000
block|,
literal|0
block|,
literal|"Chelsio Terminator 4 FPGA"
block|}
block|,
block|{
literal|0x4400
block|,
literal|4
block|,
literal|"Chelsio T440-dbg"
block|}
block|,
block|{
literal|0x4401
block|,
literal|4
block|,
literal|"Chelsio T420-CR"
block|}
block|,
block|{
literal|0x4402
block|,
literal|4
block|,
literal|"Chelsio T422-CR"
block|}
block|,
block|{
literal|0x4403
block|,
literal|4
block|,
literal|"Chelsio T440-CR"
block|}
block|,
block|{
literal|0x4404
block|,
literal|4
block|,
literal|"Chelsio T420-BCH"
block|}
block|,
block|{
literal|0x4405
block|,
literal|4
block|,
literal|"Chelsio T440-BCH"
block|}
block|,
block|{
literal|0x4406
block|,
literal|4
block|,
literal|"Chelsio T440-CH"
block|}
block|,
block|{
literal|0x4407
block|,
literal|4
block|,
literal|"Chelsio T420-SO"
block|}
block|,
block|{
literal|0x4408
block|,
literal|4
block|,
literal|"Chelsio T420-CX"
block|}
block|,
block|{
literal|0x4409
block|,
literal|4
block|,
literal|"Chelsio T420-BT"
block|}
block|,
block|{
literal|0x440a
block|,
literal|4
block|,
literal|"Chelsio T404-BT"
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|t4_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|v
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|d
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|PCI_VENDOR_ID_CHELSIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|t4_pciids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|==
name|t4_pciids
index|[
name|i
index|]
operator|.
name|device
operator|&&
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|==
name|t4_pciids
index|[
name|i
index|]
operator|.
name|mpf
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t4_pciids
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|n10g
decl_stmt|,
name|n1g
decl_stmt|,
name|rqidx
decl_stmt|,
name|tqidx
decl_stmt|;
name|struct
name|fw_caps_config_cmd
name|caps
decl_stmt|;
name|uint32_t
name|p
decl_stmt|,
name|v
decl_stmt|;
name|struct
name|intrs_and_queues
name|iaq
decl_stmt|;
name|struct
name|sge
modifier|*
name|s
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|pf
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbox
operator|=
name|sc
operator|->
name|pf
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_set_max_read_req
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|sc
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|memset
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|chan_map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare the adapter for operation */
name|rc
operator|=
operator|-
name|t4_prep_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to prepare adapter: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Do this really early */
name|sc
operator|->
name|cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|t4_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Prepare the firmware for operation */
name|rc
operator|=
name|prep_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* Get device capabilities and select which ones we'll use */
name|rc
operator|=
name|get_capabilities
argument_list|(
name|sc
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize adapter capabilities: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Choose the global RSS mode. */
name|rc
operator|=
operator|-
name|t4_config_glbl_rss
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL
argument_list|,
name|F_FW_RSS_GLB_CONFIG_CMD_TNLMAPEN
operator||
name|F_FW_RSS_GLB_CONFIG_CMD_TNLALLLKP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to select global RSS mode: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* These are total (sum of all ports) limits for a bus driver */
name|rc
operator|=
operator|-
name|t4_cfg_pfvf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|64
argument_list|,
comment|/* max # of egress queues */
literal|64
argument_list|,
comment|/* max # of egress Ethernet or control queues */
literal|64
argument_list|,
comment|/* max # of ingress queues with fl/interrupt */
literal|0
argument_list|,
comment|/* max # of ingress queues without interrupt */
literal|0
argument_list|,
comment|/* PCIe traffic class */
literal|4
argument_list|,
comment|/* max # of virtual interfaces */
name|M_FW_PFVF_CMD_CMASK
argument_list|,
name|M_FW_PFVF_CMD_PMASK
argument_list|,
literal|16
argument_list|,
name|FW_CMD_CAP_PF
argument_list|,
name|FW_CMD_CAP_PF
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to configure pf/vf resources: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Need this before sge_init */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_NTIMERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sge
operator|.
name|timer_val
index|[
name|i
index|]
operator|=
name|min
argument_list|(
name|intr_timer
index|[
name|i
index|]
argument_list|,
literal|200U
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_NCOUNTERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sge
operator|.
name|counter_val
index|[
name|i
index|]
operator|=
name|min
argument_list|(
name|intr_pktcount
index|[
name|i
index|]
argument_list|,
name|M_THRESHOLD_0
argument_list|)
expr_stmt|;
comment|/* Also need the cooked value of cclk before sge_init */
name|p
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_CCLK
argument_list|)
operator|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to obtain core clock value: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|=
name|v
expr_stmt|;
name|t4_sge_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: This is the place to call t4_set_filter_mode() 	 */
comment|/* get basic stuff going */
name|rc
operator|=
operator|-
name|t4_early_init
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"early init failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|get_params
argument_list|(
name|sc
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* These are finalized by FW initialization, load their values now */
name|v
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_TIMER_RESOLUTION
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|tre
operator|=
name|G_TIMERRESOLUTION
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|dack_re
operator|=
name|G_DELAYEDACKRESOLUTION
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|t4_read_mtu_tbl
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* tweak some settings */
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_SHIFT_CNT
argument_list|,
name|V_SYNSHIFTMAX
argument_list|(
literal|6
argument_list|)
operator||
name|V_RXTSHIFTMAXR1
argument_list|(
literal|4
argument_list|)
operator||
name|V_RXTSHIFTMAXR2
argument_list|(
literal|15
argument_list|)
operator||
name|V_PERSHIFTBACKOFFMAX
argument_list|(
literal|8
argument_list|)
operator||
name|V_PERSHIFTMAX
argument_list|(
literal|8
argument_list|)
operator||
name|V_KEEPALIVEMAXR1
argument_list|(
literal|4
argument_list|)
operator||
name|V_KEEPALIVEMAXR2
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_TDDP_PSZ
argument_list|,
name|V_HPZ0
argument_list|(
name|PAGE_SHIFT
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|setup_memwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_create_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * First pass over all the ports - allocate VIs and initialize some 	 * basic parameters like mac address, port type, etc.  We also figure 	 * out whether a port is 10G or 1G and use that information when 	 * calculating how many interrupts to attempt to allocate. 	 */
name|n10g
operator|=
name|n1g
operator|=
literal|0
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|pi
expr_stmt|;
comment|/* These must be set before t4_port_init */
name|pi
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|pi
operator|->
name|port_id
operator|=
name|i
expr_stmt|;
comment|/* Allocate the vi and initialize parameters like mac addr */
name|rc
operator|=
operator|-
name|t4_port_init
argument_list|(
name|pi
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize port %d: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* indicates init failed */
continue|continue;
block|}
name|snprintf
argument_list|(
name|pi
operator|->
name|lockname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|lockname
argument_list|)
argument_list|,
literal|"%sp%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|,
name|pi
operator|->
name|lockname
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_10G_port
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|n10g
operator|++
expr_stmt|;
name|pi
operator|->
name|tmr_idx
operator|=
name|tmr_idx_10g
expr_stmt|;
name|pi
operator|->
name|pktc_idx
operator|=
name|pktc_idx_10g
expr_stmt|;
block|}
else|else
block|{
name|n1g
operator|++
expr_stmt|;
name|pi
operator|->
name|tmr_idx
operator|=
name|tmr_idx_1g
expr_stmt|;
name|pi
operator|->
name|pktc_idx
operator|=
name|pktc_idx_1g
expr_stmt|;
block|}
name|pi
operator|->
name|xact_addr_filt
operator|=
operator|-
literal|1
expr_stmt|;
name|pi
operator|->
name|qsize_rxq
operator|=
name|max
argument_list|(
name|qsize_rxq
argument_list|,
literal|128
argument_list|)
expr_stmt|;
while|while
condition|(
name|pi
operator|->
name|qsize_rxq
operator|&
literal|7
condition|)
name|pi
operator|->
name|qsize_rxq
operator|++
expr_stmt|;
name|pi
operator|->
name|qsize_txq
operator|=
name|max
argument_list|(
name|qsize_txq
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|qsize_rxq
operator|!=
name|qsize_rxq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %d instead of %d as the rx queue size.\n"
argument_list|,
name|pi
operator|->
name|qsize_rxq
argument_list|,
name|qsize_rxq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|->
name|qsize_txq
operator|!=
name|qsize_txq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %d instead of %d as the tx queue size.\n"
argument_list|,
name|pi
operator|->
name|qsize_txq
argument_list|,
name|qsize_txq
argument_list|)
expr_stmt|;
block|}
name|pi
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"cxgbe"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add device for port %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|device_set_softc
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|registered_device_map
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|registered_device_map
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no usable ports\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Interrupt type, # of interrupts, # of rx/tx queues, etc. 	 */
name|rc
operator|=
name|cfg_itype_and_nqueues
argument_list|(
name|sc
argument_list|,
name|n10g
argument_list|,
name|n1g
argument_list|,
operator|&
name|iaq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|sc
operator|->
name|intr_type
operator|=
name|iaq
operator|.
name|intr_type
expr_stmt|;
name|sc
operator|->
name|intr_count
operator|=
name|iaq
operator|.
name|nirq
expr_stmt|;
name|s
operator|=
operator|&
name|sc
operator|->
name|sge
expr_stmt|;
name|s
operator|->
name|nrxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|nrxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|nrxq1g
expr_stmt|;
name|s
operator|->
name|ntxq
operator|=
name|n10g
operator|*
name|iaq
operator|.
name|ntxq10g
operator|+
name|n1g
operator|*
name|iaq
operator|.
name|ntxq1g
expr_stmt|;
name|s
operator|->
name|neq
operator|=
name|s
operator|->
name|ntxq
operator|+
name|s
operator|->
name|nrxq
expr_stmt|;
comment|/* the fl in an rxq is an eq */
name|s
operator|->
name|niq
operator|=
name|s
operator|->
name|nrxq
operator|+
literal|1
expr_stmt|;
comment|/* 1 extra for firmware event queue */
if|if
condition|(
name|iaq
operator|.
name|intr_fwd
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|INTR_FWD
expr_stmt|;
name|s
operator|->
name|niq
operator|+=
name|NFIQ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* forwarded interrupt queues */
name|s
operator|->
name|fiq
operator|=
name|malloc
argument_list|(
name|NFIQ
argument_list|(
name|sc
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_iq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|rxq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|nrxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_rxq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|txq
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|ntxq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_txq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|iqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|niq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_iq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
operator|->
name|eqmap
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|neq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sge_eq
operator|*
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|intr_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|irq
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|t4_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Second pass over the ports.  This time we know the number of rx and 	 * tx queues that each port should get. 	 */
name|rqidx
operator|=
name|tqidx
operator|=
literal|0
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
continue|continue;
name|pi
operator|->
name|first_rxq
operator|=
name|rqidx
expr_stmt|;
name|pi
operator|->
name|nrxq
operator|=
name|is_10G_port
argument_list|(
name|pi
argument_list|)
condition|?
name|iaq
operator|.
name|nrxq10g
else|:
name|iaq
operator|.
name|nrxq1g
expr_stmt|;
name|pi
operator|->
name|first_txq
operator|=
name|tqidx
expr_stmt|;
name|pi
operator|->
name|ntxq
operator|=
name|is_10G_port
argument_list|(
name|pi
argument_list|)
condition|?
name|iaq
operator|.
name|ntxq10g
else|:
name|iaq
operator|.
name|ntxq1g
expr_stmt|;
name|rqidx
operator|+=
name|pi
operator|->
name|nrxq
expr_stmt|;
name|tqidx
operator|+=
name|pi
operator|->
name|ntxq
expr_stmt|;
block|}
name|rc
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach all child ports: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%p, %d ports (0x%x), %d intr_type, %d intr_count\n"
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
name|sc
operator|->
name|params
operator|.
name|portvec
argument_list|,
name|sc
operator|->
name|intr_type
argument_list|,
name|sc
operator|->
name|intr_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t4_set_desc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|t4_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
specifier|static
name|int
name|t4_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NPORTS
condition|;
name|i
operator|++
control|)
block|{
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
name|t4_free_vi
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|viid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|dev
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pi
operator|->
name|pi_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FW_OK
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_type
operator|==
literal|2
operator|||
name|sc
operator|->
name|intr_type
operator|==
literal|4
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|regs_rid
argument_list|,
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_rid
argument_list|,
name|sc
operator|->
name|msix_res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|irq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|rxq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|txq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|fiq
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|iqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|eqmap
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|t4_destroy_dma_tag
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Port %d"
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | \     IFCAP_VLAN_HWCSUM | IFCAP_TSO | IFCAP_JUMBO_MTU | IFCAP_LRO | \     IFCAP_VLAN_HWTSO)
end_define

begin_define
define|#
directive|define
name|T4_CAP_ENABLE
value|(T4_CAP& ~IFCAP_TSO6)
end_define

begin_function
specifier|static
name|int
name|cxgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* Allocate an ifnet and set it up */
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pi
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|pi
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|pi
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"cxgbe_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|pi
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate port task queue\n"
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|pi
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgbe_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgbe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|cxgbe_start
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|cxgbe_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|cxgbe_qflush
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
literal|1024
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|T4_CAP
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|T4_CAP_ENABLE
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
expr_stmt|;
comment|/* Initialize ifmedia for this port */
name|ifmedia_init
argument_list|(
operator|&
name|pi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgbe_media_change
argument_list|,
name|cxgbe_media_status
argument_list|)
expr_stmt|;
name|build_medialist
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|pi
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%p, %d txq, %d rxq\n"
argument_list|,
name|pi
argument_list|,
name|pi
operator|->
name|ntxq
argument_list|,
name|pi
operator|->
name|nrxq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cxgbe_sysctls
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Tell if_ioctl and if_init that the port is going away */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SET_DOOMED
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|0
argument_list|,
literal|"t4detach"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"port uninit failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|pi
operator|->
name|tq
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|pi
operator|->
name|media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cxgbe_init_locked
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* releases adapter lock */
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|mtu
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fail
label|:
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|t4_update_fl_bufsize
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_MTU
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|pi
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_PROMISC
operator||
name|XGMAC_ALLMULTI
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|rc
operator|=
name|cxgbe_init_locked
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|cxgbe_uninit_locked
argument_list|(
name|pi
argument_list|)
expr_stmt|;
else|else
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* these two can be called with a mutex held :-( */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_MCADDRS
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|fail
goto|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso disabled due to -txcsum.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum first.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
block|}
block|}
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
name|rxq
operator|->
name|flags
operator||=
name|RXQ_LRO_ENABLED
expr_stmt|;
else|else
name|rxq
operator|->
name|flags
operator|&=
operator|~
name|RXQ_LRO_ENABLED
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|TCP_OFFLOAD_DISABLE
if|if
condition|(
name|mask
operator|&
name|IFCAP_TOE4
condition|)
block|{
name|rc
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_VLANEX
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* Need to find out how to disable auto-mtu-inflation */
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
ifdef|#
directive|ifdef
name|VLAN_CAPABILITIES
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|pi
operator|->
name|media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
condition|)
block|{
name|txq_start
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|txq
index|[
name|pi
operator|->
name|first_txq
index|]
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
name|txq
operator|+=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|pi
operator|->
name|ntxq
operator|)
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|eq
operator|.
name|br
expr_stmt|;
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX: make sure that this packet really is sent out.  There is 		 * a small race where t4_eth_tx may stop draining the drbr and 		 * goes away, just before we enqueued this mbuf. 		 */
return|return
operator|(
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * txq->m is the mbuf that is held up due to a temporary shortage of 	 * resources and it should be put on the wire first.  Then what's in 	 * drbr and finally the mbuf that was just passed in to us. 	 * 	 * Return code should indicate the fate of the mbuf that was passed in 	 * this time. 	 */
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|drbr_needs_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
operator|||
name|txq
operator|->
name|m
condition|)
block|{
comment|/* Queued for transmission. */
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|txq
operator|->
name|m
condition|?
name|txq
operator|->
name|m
else|:
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Direct transmission. */
name|rc
operator|=
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|&&
name|txq
operator|->
name|m
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* held, will be transmitted soon (hopefully) */
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"%s unimplemented.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"%s unimplemented.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|cur
init|=
name|pi
operator|->
name|media
operator|.
name|ifm_cur
decl_stmt|;
name|int
name|speed
init|=
name|pi
operator|->
name|link_cfg
operator|.
name|speed
decl_stmt|;
name|int
name|data
init|=
operator|(
name|pi
operator|->
name|port_type
operator|<<
literal|8
operator|)
operator||
name|pi
operator|->
name|mod_type
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|ifm_data
operator|!=
name|data
condition|)
block|{
name|build_medialist
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|cur
operator|=
name|pi
operator|->
name|media
operator|.
name|ifm_cur
expr_stmt|;
block|}
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* active and current will differ iff current media is autoselect. */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|cur
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
return|return;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_10000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_100
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_10
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
else|else
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: link up but speed unknown (%u)"
operator|,
name|__func__
operator|,
name|speed
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_fatal_err
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"%s: encountered fatal error, adapter stopped.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bars
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|regs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map registers.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mmio_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|msix_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot map MSI-X BAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_memwin
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|u_long
name|bar0
decl_stmt|;
name|bar0
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bar0
operator|+
name|MEMWIN0_BASE
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|MEMWIN0_APERTURE
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|bar0
operator|+
name|MEMWIN1_BASE
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|MEMWIN1_APERTURE
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|PCIE_MEM_ACCESS_REG
argument_list|(
name|A_PCIE_MEM_ACCESS_BASE_WIN
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|(
name|bar0
operator|+
name|MEMWIN2_BASE
operator|)
operator||
name|V_BIR
argument_list|(
literal|0
argument_list|)
operator||
name|V_WINDOW
argument_list|(
name|ilog2
argument_list|(
name|MEMWIN2_APERTURE
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfg_itype_and_nqueues
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|n10g
parameter_list|,
name|int
name|n1g
parameter_list|,
name|struct
name|intrs_and_queues
modifier|*
name|iaq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|itype
decl_stmt|,
name|navail
decl_stmt|,
name|nc
decl_stmt|,
name|nrxq10g
decl_stmt|,
name|nrxq1g
decl_stmt|;
name|bzero
argument_list|(
name|iaq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iaq
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* our snapshot of the number of CPUs */
for|for
control|(
name|itype
operator|=
literal|4
init|;
name|itype
condition|;
name|itype
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|itype
operator|&
name|intr_types
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* not allowed */
if|if
condition|(
name|itype
operator|==
literal|4
condition|)
name|navail
operator|=
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
literal|2
condition|)
name|navail
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
else|else
name|navail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|navail
operator|==
literal|0
condition|)
continue|continue;
name|iaq
operator|->
name|intr_type
operator|=
name|itype
expr_stmt|;
name|iaq
operator|->
name|ntxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|max_ntxq_10g
argument_list|)
expr_stmt|;
name|iaq
operator|->
name|ntxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|max_ntxq_1g
argument_list|)
expr_stmt|;
name|nrxq10g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|max_nrxq_10g
argument_list|)
expr_stmt|;
name|nrxq1g
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|max_nrxq_1g
argument_list|)
expr_stmt|;
comment|/* Extra 2 is for a) error interrupt b) firmware event */
name|iaq
operator|->
name|nirq
operator|=
name|n10g
operator|*
name|nrxq10g
operator|+
name|n1g
operator|*
name|nrxq1g
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
operator|&&
name|intr_fwd
operator|==
literal|0
condition|)
block|{
comment|/* One for err, one for fwq, and one for each rxq */
name|iaq
operator|->
name|intr_fwd
operator|=
literal|0
expr_stmt|;
name|iaq
operator|->
name|nrxq10g
operator|=
name|nrxq10g
expr_stmt|;
name|iaq
operator|->
name|nrxq1g
operator|=
name|nrxq1g
expr_stmt|;
if|if
condition|(
name|itype
operator|==
literal|2
condition|)
block|{
comment|/* # of vectors requested must be power of 2 */
while|while
condition|(
operator|!
name|powerof2
argument_list|(
name|iaq
operator|->
name|nirq
argument_list|)
condition|)
name|iaq
operator|->
name|nirq
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|iaq
operator|->
name|nirq
operator|<=
name|navail
argument_list|,
operator|(
literal|"%s: bad MSI calculation"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fwd
label|:
name|iaq
operator|->
name|intr_fwd
operator|=
literal|1
expr_stmt|;
name|iaq
operator|->
name|nirq
operator|=
name|navail
expr_stmt|;
comment|/* 			 * If we have multiple vectors available reserve one 			 * exclusively for errors.  The rest will be shared by 			 * the fwq and data. 			 */
if|if
condition|(
name|navail
operator|>
literal|1
condition|)
block|{
name|navail
operator|--
expr_stmt|;
if|if
condition|(
name|navail
operator|>
name|nc
operator|&&
name|itype
operator|==
literal|4
condition|)
name|iaq
operator|->
name|nirq
operator|=
name|nc
operator|+
literal|1
expr_stmt|;
block|}
name|iaq
operator|->
name|nrxq10g
operator|=
name|min
argument_list|(
name|nrxq10g
argument_list|,
name|navail
argument_list|)
expr_stmt|;
name|iaq
operator|->
name|nrxq1g
operator|=
name|min
argument_list|(
name|nrxq1g
argument_list|,
name|navail
argument_list|)
expr_stmt|;
block|}
name|navail
operator|=
name|iaq
operator|->
name|nirq
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|itype
operator|==
literal|4
condition|)
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|itype
operator|==
literal|2
condition|)
name|rc
operator|=
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|navail
operator|==
name|iaq
operator|->
name|nirq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * Didn't get the number requested.  Use whatever number 			 * the kernel is willing to allocate (it's in navail). 			 */
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|fwd
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate vectors:%d, type=%d, req=%d, rcvd=%d\n"
argument_list|,
name|itype
argument_list|,
name|rc
argument_list|,
name|iaq
operator|->
name|nirq
argument_list|,
name|navail
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to find a usable interrupt type.  "
literal|"allowed=%d, msi-x=%d, msi=%d, intx=1"
argument_list|,
name|intr_types
argument_list|,
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Install a compatible firmware (if required), establish contact with it,  * become the master, and reset the device.  */
end_comment

begin_function
specifier|static
name|int
name|prep_firmware
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|enum
name|dev_state
name|state
decl_stmt|;
comment|/* Check firmware version and install a different one if necessary */
name|rc
operator|=
name|t4_check_fw_version
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|force_firmware_install
condition|)
block|{
name|uint32_t
name|v
init|=
literal|0
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|T4_FWNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|fw
operator|->
name|data
decl_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|fw_ver
argument_list|)
expr_stmt|;
comment|/* 			 * The firmware module will not be used if it isn't the 			 * same major version as what the driver was compiled 			 * with.  This check trumps force_firmware_install. 			 */
if|if
condition|(
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|v
argument_list|)
operator|!=
name|FW_VERSION_MAJOR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Found firmware image but version %d "
literal|"can not be used with this driver (%d)\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|v
argument_list|)
argument_list|,
name|FW_VERSION_MAJOR
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|fw
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fw
operator|==
name|NULL
operator|&&
operator|(
name|rc
operator|<
literal|0
operator|||
name|force_firmware_install
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"No usable firmware. "
literal|"card has %d.%d.%d, driver compiled with %d.%d.%d, "
literal|"force_firmware_install%s set"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|,
name|FW_VERSION_MICRO
argument_list|,
name|force_firmware_install
condition|?
literal|""
else|:
literal|" not"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* 		 * Always upgrade, even for minor/micro/build mismatches. 		 * Downgrade only for a major version mismatch or if 		 * force_firmware_install was specified. 		 */
if|if
condition|(
name|fw
operator|!=
name|NULL
operator|&&
operator|(
name|rc
operator|<
literal|0
operator|||
name|force_firmware_install
operator|||
name|v
operator|>
name|sc
operator|->
name|params
operator|.
name|fw_vers
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"installing firmware %d.%d.%d.%d on card.\n"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_load_fw
argument_list|(
name|sc
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to install firmware: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
else|else
block|{
comment|/* refresh */
operator|(
name|void
operator|)
name|t4_check_fw_version
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fw
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
block|}
comment|/* Contact firmware, request master */
name|rc
operator|=
name|t4_fw_hello
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|MASTER_MUST
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to connect to the firmware: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Reset device */
name|rc
operator|=
operator|-
name|t4_fw_reset
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|F_PIORSTMODE
operator||
name|F_PIORST
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware reset failed: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ETIMEDOUT
operator|&&
name|rc
operator|!=
name|EIO
condition|)
name|t4_fw_bye
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|,
name|G_FW_HDR_FW_VER_BUILD
argument_list|(
name|sc
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FW_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_capabilities
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|fw_caps_config_cmd
modifier|*
name|caps
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|bzero
argument_list|(
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|caps
operator|->
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|caps
operator|->
name|retval_len16
operator|=
name|htobe32
argument_list|(
name|FW_LEN16
argument_list|(
operator|*
name|caps
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|caps
argument_list|)
argument_list|,
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|caps
operator|->
name|niccaps
operator|&
name|htobe16
argument_list|(
name|FW_CAPS_CONFIG_NIC_VM
argument_list|)
condition|)
name|caps
operator|->
name|niccaps
operator|^=
name|htobe16
argument_list|(
name|FW_CAPS_CONFIG_NIC_VM
argument_list|)
expr_stmt|;
name|caps
operator|->
name|op_to_write
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_CAPS_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|caps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|caps
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|fw_caps_config_cmd
modifier|*
name|caps
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|params
index|[
literal|7
index|]
decl_stmt|,
name|val
index|[
literal|7
index|]
decl_stmt|;
define|#
directive|define
name|FW_PARAM_DEV
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_##param))
define|#
directive|define
name|FW_PARAM_PFVF
parameter_list|(
name|param
parameter_list|)
define|\
value|(V_FW_PARAMS_MNEM(FW_PARAMS_MNEM_PFVF) | \ 	 V_FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_PFVF_##param))
name|params
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|PORTVEC
argument_list|)
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|IQFLINT_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|EQ_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|FILTER_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
name|params
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|params
operator|.
name|portvec
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|nports
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|val
index|[
literal|0
index|]
condition|)
block|{
name|sc
operator|->
name|params
operator|.
name|nports
operator|++
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|&=
name|val
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sge
operator|.
name|iq_start
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eq_start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|ftid_base
operator|=
name|val
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nftids
operator|=
name|val
index|[
literal|4
index|]
operator|-
name|val
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|caps
operator|->
name|toecaps
condition|)
block|{
comment|/* query offload-related parameters */
name|params
index|[
literal|0
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|NTID
argument_list|)
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|SERVER_END
argument_list|)
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|TDDP_END
argument_list|)
expr_stmt|;
name|params
index|[
literal|5
index|]
operator|=
name|FW_PARAM_DEV
argument_list|(
name|FLOWC_BUFFIFO_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|params
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query TOE parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|natids
operator|=
name|min
argument_list|(
name|sc
operator|->
name|tids
operator|.
name|ntids
operator|/
literal|2
argument_list|,
name|MAX_ATIDS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|stid_base
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|tids
operator|.
name|nstids
operator|=
name|val
index|[
literal|2
index|]
operator|-
name|val
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|start
operator|=
name|val
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|ddp
operator|.
name|size
operator|=
name|val
index|[
literal|4
index|]
operator|-
name|val
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|ofldq_wr_cred
operator|=
name|val
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|params
operator|.
name|offload
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|caps
operator|->
name|rdmacaps
condition|)
block|{
name|params
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|STAG_END
argument_list|)
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|RQ_END
argument_list|)
expr_stmt|;
name|params
index|[
literal|4
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|5
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|PBL_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|params
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query RDMA parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|stag
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|start
operator|=
name|val
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|rq
operator|.
name|size
operator|=
name|val
index|[
literal|3
index|]
operator|-
name|val
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|start
operator|=
name|val
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|pbl
operator|.
name|size
operator|=
name|val
index|[
literal|5
index|]
operator|-
name|val
index|[
literal|4
index|]
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|caps
operator|->
name|iscsicaps
condition|)
block|{
name|params
index|[
literal|0
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_START
argument_list|)
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|FW_PARAM_PFVF
argument_list|(
name|ISCSI_END
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_query_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|params
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to query iSCSI parameters: %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|start
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|vres
operator|.
name|iscsi
operator|.
name|size
operator|=
name|val
index|[
literal|1
index|]
operator|-
name|val
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
undef|#
directive|undef
name|FW_PARAM_PFVF
undef|#
directive|undef
name|FW_PARAM_DEV
name|done
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_set_desc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|adapter_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Chelsio %s (rev %d) %d port %sNIC PCIe-x%d %s, S/N:%s, E/C:%s"
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|id
argument_list|,
name|p
operator|->
name|rev
argument_list|,
name|p
operator|->
name|nports
argument_list|,
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|?
literal|"R"
else|:
literal|""
argument_list|,
name|p
operator|->
name|pci
operator|.
name|width
argument_list|,
operator|(
name|sc
operator|->
name|intr_type
operator|==
literal|4
operator|)
condition|?
literal|"MSI-X"
else|:
operator|(
name|sc
operator|->
name|intr_type
operator|==
literal|2
operator|)
condition|?
literal|"MSI"
else|:
literal|"INTx"
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|sn
argument_list|,
name|p
operator|->
name|vpd
operator|.
name|ec
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|ifmedia
modifier|*
name|media
init|=
operator|&
name|pi
operator|->
name|media
decl_stmt|;
name|int
name|data
decl_stmt|,
name|m
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
name|media
argument_list|)
expr_stmt|;
name|m
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
name|data
operator|=
operator|(
name|pi
operator|->
name|port_type
operator|<<
literal|8
operator|)
operator||
name|pi
operator|->
name|mod_type
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|port_type
condition|)
block|{
case|case
name|FW_PORT_TYPE_BT_XFI
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_BT_XAUI
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|FW_PORT_TYPE_BT_SGMII
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_1000_T
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_100_TX
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_CX4
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_TYPE_SFP
case|:
case|case
name|FW_PORT_TYPE_FIBER_XFI
case|:
case|case
name|FW_PORT_TYPE_FIBER_XAUI
case|:
switch|switch
condition|(
name|pi
operator|->
name|mod_type
condition|)
block|{
case|case
name|FW_PORT_MOD_TYPE_LR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_SR
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_SR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_LRM
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_LRM
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_TWINAX_PASSIVE
case|:
case|case
name|FW_PORT_MOD_TYPE_TWINAX_ACTIVE
case|:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_TWINAX
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NONE
case|:
name|m
operator|&=
operator|~
name|IFM_FDX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_PORT_MOD_TYPE_NA
case|:
case|case
name|FW_PORT_MOD_TYPE_ER
case|:
default|default:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FW_PORT_TYPE_KX4
case|:
case|case
name|FW_PORT_TYPE_KX
case|:
case|case
name|FW_PORT_TYPE_KR
case|:
default|default:
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Program the port's XGMAC based on parameters in ifnet.  The caller also  * indicates which parameters should be programmed (the rest are left alone).  */
end_comment

begin_function
specifier|static
name|int
name|update_mac_settings
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|mtu
init|=
operator|-
literal|1
decl_stmt|,
name|promisc
init|=
operator|-
literal|1
decl_stmt|,
name|allmulti
init|=
operator|-
literal|1
decl_stmt|,
name|vlanex
init|=
operator|-
literal|1
decl_stmt|;
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|flags
argument_list|,
operator|(
literal|"%s: not told what to update."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_MTU
condition|)
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_PROMISC
condition|)
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_ALLMULTI
condition|)
name|allmulti
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XGMAC_VLANEX
condition|)
name|vlanex
operator|=
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_set_rxmode
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|mtu
argument_list|,
name|promisc
argument_list|,
name|allmulti
argument_list|,
literal|1
argument_list|,
name|vlanex
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"set_rxmode (%x) failed: %d\n"
argument_list|,
name|flags
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_UCADDR
condition|)
block|{
name|uint8_t
name|ucaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ucaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ucaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_change_mac
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|pi
operator|->
name|xact_addr_filt
argument_list|,
name|ucaddr
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"change_mac failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
else|else
block|{
name|pi
operator|->
name|xact_addr_filt
operator|=
name|rc
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|XGMAC_MCADDRS
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|mcaddr
decl_stmt|;
name|int
name|del
init|=
literal|1
decl_stmt|;
name|uint64_t
name|hash
init|=
literal|0
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcaddr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|t4_alloc_mac_filt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|del
argument_list|,
literal|1
argument_list|,
operator|&
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to add mc address"
literal|" %02x:%02x:%02x:%02x:%02x:%02x rc=%d\n"
argument_list|,
name|mcaddr
index|[
literal|0
index|]
argument_list|,
name|mcaddr
index|[
literal|1
index|]
argument_list|,
name|mcaddr
index|[
literal|2
index|]
argument_list|,
name|mcaddr
index|[
literal|3
index|]
argument_list|,
name|mcaddr
index|[
literal|4
index|]
argument_list|,
name|mcaddr
index|[
literal|5
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|mcfail
goto|;
block|}
name|del
operator|=
literal|0
expr_stmt|;
block|}
name|rc
operator|=
operator|-
name|t4_set_addr_hash
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to set mc address hash: %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|mcfail
label|:
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
operator|&&
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4init"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Give up the adapter lock, port init code can sleep. */
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cxgbe_init_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|done
label|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_init_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
modifier|*
name|rss
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
argument_list|,
operator|(
literal|"mismatch between open_device_map and if_drv_flags"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already running */
block|}
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
operator|&&
operator|(
operator|(
name|rc
operator|=
name|first_port_up
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* error message displayed already */
comment|/* 	 * Allocate tx/rx/fl queues for this port. 	 */
name|rc
operator|=
name|t4_setup_eth_queues
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
comment|/* 	 * Setup RSS for this port. 	 */
name|rss
operator|=
name|malloc
argument_list|(
name|pi
operator|->
name|nrxq
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rss
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|rss
index|[
name|i
index|]
operator|=
name|rxq
operator|->
name|iq
operator|.
name|abs_id
expr_stmt|;
block|}
name|rc
operator|=
operator|-
name|t4_config_rss_range
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|rss_size
argument_list|,
name|rss
argument_list|,
name|pi
operator|->
name|nrxq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rss
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"rss_config failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|rc
operator|=
name|update_mac_settings
argument_list|(
name|pi
argument_list|,
name|XGMAC_ALL
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
comment|/* error message displayed already */
name|rc
operator|=
operator|-
name|t4_link_start
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
operator|&
name|pi
operator|->
name|link_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"start_link failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pi
operator|->
name|flags
operator||=
name|VI_ENABLED
expr_stmt|;
comment|/* all ok */
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|,
name|cxgbe_tick
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_uninit_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
operator|&&
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"t4uninit"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cxgbe_uninit_synchronized
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|done
label|:
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
specifier|static
name|int
name|cxgbe_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * taskqueue_drain may cause a deadlock if the adapter lock is held. 	 */
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Clear this port's bit from the open device map, and then drain 	 * tasks and callouts. 	 */
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* 	 * Stop and then free the queues' resources, including the queues 	 * themselves. 	 * 	 * XXX: we could just stop the queues here (on ifconfig down) and free 	 * them later (on port detach), but having up/down go through the entire 	 * allocate/activate/deactivate/free sequence is a good way to find 	 * leaks and bugs. 	 */
name|rc
operator|=
name|t4_teardown_eth_queues
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"teardown failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|flags
operator|&
name|VI_ENABLED
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_enable_vi
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|pi
operator|->
name|viid
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"disable_vi failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
else|else
name|pi
operator|->
name|flags
operator|&=
operator|~
name|VI_ENABLED
expr_stmt|;
block|}
name|pi
operator|->
name|link_cfg
operator|.
name|link_ok
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|link_cfg
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|t4_os_link_changed
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
condition|)
name|last_port_down
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_ALLOC_IRQ
parameter_list|(
name|sc
parameter_list|,
name|irqid
parameter_list|,
name|rid
parameter_list|,
name|handler
parameter_list|,
name|arg
parameter_list|,
name|name
parameter_list|)
value|do { \ 	rc = t4_alloc_irq(sc,&sc->irq[irqid], rid, handler, arg, name); \ 	if (rc != 0) \ 		goto done; \ } while (0)
end_define

begin_function
specifier|static
name|int
name|first_port_up
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The firmware event queue and the optional forwarded interrupt queues. 	 */
name|rc
operator|=
name|t4_setup_adapter_iqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Setup interrupts. 	 */
if|if
condition|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|INTR_FWD
argument_list|,
operator|(
literal|"%s: single interrupt but not forwarded?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|t4_intr_all
argument_list|,
name|sc
argument_list|,
literal|"all"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Multiple interrupts.  The first one is always error intr */
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|t4_intr_err
argument_list|,
name|sc
argument_list|,
literal|"err"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|INTR_FWD
condition|)
block|{
comment|/* The rest are shared by the fwq and all data intr */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"mux%d"
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|t4_intr_fwd
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|fiq
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|int
name|p
decl_stmt|,
name|q
decl_stmt|;
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|t4_intr_evt
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
argument_list|,
literal|"evt"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|=
literal|0
expr_stmt|;
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"p%dq%d"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|>=
name|pi
operator|->
name|nrxq
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
name|pi
operator|=
name|sc
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
block|}
name|T4_ALLOC_IRQ
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|t4_intr_data
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|rxq
index|[
name|i
operator|-
literal|2
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|t4_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FULL_INIT_DONE
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|last_port_down
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|T4_ALLOC_IRQ
end_undef

begin_comment
comment|/*  * Idempotent.  */
end_comment

begin_function
specifier|static
name|int
name|last_port_down
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_teardown_adapter_iqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
name|t4_free_irq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FULL_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_alloc_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|,
name|int
name|rid
parameter_list|,
name|iq_intr_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|irq
operator|->
name|rid
operator|=
name|rid
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate IRQ for rid %d, name %s.\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|&
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup interrupt for rid %d, name %s: %d\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
condition|)
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_free_irq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|irq
modifier|*
name|irq
parameter_list|)
block|{
if|if
condition|(
name|irq
operator|->
name|tag
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|rid
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|irq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|irq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|start
operator|)
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
operator|*
name|p
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t4_get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|t4_regdump
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|reg_ranges
index|[]
init|=
block|{
literal|0x1008
block|,
literal|0x1108
block|,
literal|0x1180
block|,
literal|0x11b4
block|,
literal|0x11fc
block|,
literal|0x123c
block|,
literal|0x1300
block|,
literal|0x173c
block|,
literal|0x1800
block|,
literal|0x18fc
block|,
literal|0x3000
block|,
literal|0x30d8
block|,
literal|0x30e0
block|,
literal|0x5924
block|,
literal|0x5960
block|,
literal|0x59d4
block|,
literal|0x5a00
block|,
literal|0x5af8
block|,
literal|0x6000
block|,
literal|0x6098
block|,
literal|0x6100
block|,
literal|0x6150
block|,
literal|0x6200
block|,
literal|0x6208
block|,
literal|0x6240
block|,
literal|0x6248
block|,
literal|0x6280
block|,
literal|0x6338
block|,
literal|0x6370
block|,
literal|0x638c
block|,
literal|0x6400
block|,
literal|0x643c
block|,
literal|0x6500
block|,
literal|0x6524
block|,
literal|0x6a00
block|,
literal|0x6a38
block|,
literal|0x6a60
block|,
literal|0x6a78
block|,
literal|0x6b00
block|,
literal|0x6b84
block|,
literal|0x6bf0
block|,
literal|0x6c84
block|,
literal|0x6cf0
block|,
literal|0x6d84
block|,
literal|0x6df0
block|,
literal|0x6e84
block|,
literal|0x6ef0
block|,
literal|0x6f84
block|,
literal|0x6ff0
block|,
literal|0x7084
block|,
literal|0x70f0
block|,
literal|0x7184
block|,
literal|0x71f0
block|,
literal|0x7284
block|,
literal|0x72f0
block|,
literal|0x7384
block|,
literal|0x73f0
block|,
literal|0x7450
block|,
literal|0x7500
block|,
literal|0x7530
block|,
literal|0x7600
block|,
literal|0x761c
block|,
literal|0x7680
block|,
literal|0x76cc
block|,
literal|0x7700
block|,
literal|0x7798
block|,
literal|0x77c0
block|,
literal|0x77fc
block|,
literal|0x7900
block|,
literal|0x79fc
block|,
literal|0x7b00
block|,
literal|0x7c38
block|,
literal|0x7d00
block|,
literal|0x7efc
block|,
literal|0x8dc0
block|,
literal|0x8e1c
block|,
literal|0x8e30
block|,
literal|0x8e78
block|,
literal|0x8ea0
block|,
literal|0x8f6c
block|,
literal|0x8fc0
block|,
literal|0x9074
block|,
literal|0x90fc
block|,
literal|0x90fc
block|,
literal|0x9400
block|,
literal|0x9458
block|,
literal|0x9600
block|,
literal|0x96bc
block|,
literal|0x9800
block|,
literal|0x9808
block|,
literal|0x9820
block|,
literal|0x983c
block|,
literal|0x9850
block|,
literal|0x9864
block|,
literal|0x9c00
block|,
literal|0x9c6c
block|,
literal|0x9c80
block|,
literal|0x9cec
block|,
literal|0x9d00
block|,
literal|0x9d6c
block|,
literal|0x9d80
block|,
literal|0x9dec
block|,
literal|0x9e00
block|,
literal|0x9e6c
block|,
literal|0x9e80
block|,
literal|0x9eec
block|,
literal|0x9f00
block|,
literal|0x9f6c
block|,
literal|0x9f80
block|,
literal|0x9fec
block|,
literal|0xd004
block|,
literal|0xd03c
block|,
literal|0xdfc0
block|,
literal|0xdfe0
block|,
literal|0xe000
block|,
literal|0xea7c
block|,
literal|0xf000
block|,
literal|0x11190
block|,
literal|0x19040
block|,
literal|0x19124
block|,
literal|0x19150
block|,
literal|0x191b0
block|,
literal|0x191d0
block|,
literal|0x191e8
block|,
literal|0x19238
block|,
literal|0x1924c
block|,
literal|0x193f8
block|,
literal|0x19474
block|,
literal|0x19490
block|,
literal|0x194f8
block|,
literal|0x19800
block|,
literal|0x19f30
block|,
literal|0x1a000
block|,
literal|0x1a06c
block|,
literal|0x1a0b0
block|,
literal|0x1a120
block|,
literal|0x1a128
block|,
literal|0x1a138
block|,
literal|0x1a190
block|,
literal|0x1a1c4
block|,
literal|0x1a1fc
block|,
literal|0x1a1fc
block|,
literal|0x1e040
block|,
literal|0x1e04c
block|,
literal|0x1e240
block|,
literal|0x1e28c
block|,
literal|0x1e2c0
block|,
literal|0x1e2c0
block|,
literal|0x1e2e0
block|,
literal|0x1e2e0
block|,
literal|0x1e300
block|,
literal|0x1e384
block|,
literal|0x1e3c0
block|,
literal|0x1e3c8
block|,
literal|0x1e440
block|,
literal|0x1e44c
block|,
literal|0x1e640
block|,
literal|0x1e68c
block|,
literal|0x1e6c0
block|,
literal|0x1e6c0
block|,
literal|0x1e6e0
block|,
literal|0x1e6e0
block|,
literal|0x1e700
block|,
literal|0x1e784
block|,
literal|0x1e7c0
block|,
literal|0x1e7c8
block|,
literal|0x1e840
block|,
literal|0x1e84c
block|,
literal|0x1ea40
block|,
literal|0x1ea8c
block|,
literal|0x1eac0
block|,
literal|0x1eac0
block|,
literal|0x1eae0
block|,
literal|0x1eae0
block|,
literal|0x1eb00
block|,
literal|0x1eb84
block|,
literal|0x1ebc0
block|,
literal|0x1ebc8
block|,
literal|0x1ec40
block|,
literal|0x1ec4c
block|,
literal|0x1ee40
block|,
literal|0x1ee8c
block|,
literal|0x1eec0
block|,
literal|0x1eec0
block|,
literal|0x1eee0
block|,
literal|0x1eee0
block|,
literal|0x1ef00
block|,
literal|0x1ef84
block|,
literal|0x1efc0
block|,
literal|0x1efc8
block|,
literal|0x1f040
block|,
literal|0x1f04c
block|,
literal|0x1f240
block|,
literal|0x1f28c
block|,
literal|0x1f2c0
block|,
literal|0x1f2c0
block|,
literal|0x1f2e0
block|,
literal|0x1f2e0
block|,
literal|0x1f300
block|,
literal|0x1f384
block|,
literal|0x1f3c0
block|,
literal|0x1f3c8
block|,
literal|0x1f440
block|,
literal|0x1f44c
block|,
literal|0x1f640
block|,
literal|0x1f68c
block|,
literal|0x1f6c0
block|,
literal|0x1f6c0
block|,
literal|0x1f6e0
block|,
literal|0x1f6e0
block|,
literal|0x1f700
block|,
literal|0x1f784
block|,
literal|0x1f7c0
block|,
literal|0x1f7c8
block|,
literal|0x1f840
block|,
literal|0x1f84c
block|,
literal|0x1fa40
block|,
literal|0x1fa8c
block|,
literal|0x1fac0
block|,
literal|0x1fac0
block|,
literal|0x1fae0
block|,
literal|0x1fae0
block|,
literal|0x1fb00
block|,
literal|0x1fb84
block|,
literal|0x1fbc0
block|,
literal|0x1fbc8
block|,
literal|0x1fc40
block|,
literal|0x1fc4c
block|,
literal|0x1fe40
block|,
literal|0x1fe8c
block|,
literal|0x1fec0
block|,
literal|0x1fec0
block|,
literal|0x1fee0
block|,
literal|0x1fee0
block|,
literal|0x1ff00
block|,
literal|0x1ff84
block|,
literal|0x1ffc0
block|,
literal|0x1ffc8
block|,
literal|0x20000
block|,
literal|0x2002c
block|,
literal|0x20100
block|,
literal|0x2013c
block|,
literal|0x20190
block|,
literal|0x201c8
block|,
literal|0x20200
block|,
literal|0x20318
block|,
literal|0x20400
block|,
literal|0x20528
block|,
literal|0x20540
block|,
literal|0x20614
block|,
literal|0x21000
block|,
literal|0x21040
block|,
literal|0x2104c
block|,
literal|0x21060
block|,
literal|0x210c0
block|,
literal|0x210ec
block|,
literal|0x21200
block|,
literal|0x21268
block|,
literal|0x21270
block|,
literal|0x21284
block|,
literal|0x212fc
block|,
literal|0x21388
block|,
literal|0x21400
block|,
literal|0x21404
block|,
literal|0x21500
block|,
literal|0x21518
block|,
literal|0x2152c
block|,
literal|0x2153c
block|,
literal|0x21550
block|,
literal|0x21554
block|,
literal|0x21600
block|,
literal|0x21600
block|,
literal|0x21608
block|,
literal|0x21628
block|,
literal|0x21630
block|,
literal|0x2163c
block|,
literal|0x21700
block|,
literal|0x2171c
block|,
literal|0x21780
block|,
literal|0x2178c
block|,
literal|0x21800
block|,
literal|0x21c38
block|,
literal|0x21c80
block|,
literal|0x21d7c
block|,
literal|0x21e00
block|,
literal|0x21e04
block|,
literal|0x22000
block|,
literal|0x2202c
block|,
literal|0x22100
block|,
literal|0x2213c
block|,
literal|0x22190
block|,
literal|0x221c8
block|,
literal|0x22200
block|,
literal|0x22318
block|,
literal|0x22400
block|,
literal|0x22528
block|,
literal|0x22540
block|,
literal|0x22614
block|,
literal|0x23000
block|,
literal|0x23040
block|,
literal|0x2304c
block|,
literal|0x23060
block|,
literal|0x230c0
block|,
literal|0x230ec
block|,
literal|0x23200
block|,
literal|0x23268
block|,
literal|0x23270
block|,
literal|0x23284
block|,
literal|0x232fc
block|,
literal|0x23388
block|,
literal|0x23400
block|,
literal|0x23404
block|,
literal|0x23500
block|,
literal|0x23518
block|,
literal|0x2352c
block|,
literal|0x2353c
block|,
literal|0x23550
block|,
literal|0x23554
block|,
literal|0x23600
block|,
literal|0x23600
block|,
literal|0x23608
block|,
literal|0x23628
block|,
literal|0x23630
block|,
literal|0x2363c
block|,
literal|0x23700
block|,
literal|0x2371c
block|,
literal|0x23780
block|,
literal|0x2378c
block|,
literal|0x23800
block|,
literal|0x23c38
block|,
literal|0x23c80
block|,
literal|0x23d7c
block|,
literal|0x23e00
block|,
literal|0x23e04
block|,
literal|0x24000
block|,
literal|0x2402c
block|,
literal|0x24100
block|,
literal|0x2413c
block|,
literal|0x24190
block|,
literal|0x241c8
block|,
literal|0x24200
block|,
literal|0x24318
block|,
literal|0x24400
block|,
literal|0x24528
block|,
literal|0x24540
block|,
literal|0x24614
block|,
literal|0x25000
block|,
literal|0x25040
block|,
literal|0x2504c
block|,
literal|0x25060
block|,
literal|0x250c0
block|,
literal|0x250ec
block|,
literal|0x25200
block|,
literal|0x25268
block|,
literal|0x25270
block|,
literal|0x25284
block|,
literal|0x252fc
block|,
literal|0x25388
block|,
literal|0x25400
block|,
literal|0x25404
block|,
literal|0x25500
block|,
literal|0x25518
block|,
literal|0x2552c
block|,
literal|0x2553c
block|,
literal|0x25550
block|,
literal|0x25554
block|,
literal|0x25600
block|,
literal|0x25600
block|,
literal|0x25608
block|,
literal|0x25628
block|,
literal|0x25630
block|,
literal|0x2563c
block|,
literal|0x25700
block|,
literal|0x2571c
block|,
literal|0x25780
block|,
literal|0x2578c
block|,
literal|0x25800
block|,
literal|0x25c38
block|,
literal|0x25c80
block|,
literal|0x25d7c
block|,
literal|0x25e00
block|,
literal|0x25e04
block|,
literal|0x26000
block|,
literal|0x2602c
block|,
literal|0x26100
block|,
literal|0x2613c
block|,
literal|0x26190
block|,
literal|0x261c8
block|,
literal|0x26200
block|,
literal|0x26318
block|,
literal|0x26400
block|,
literal|0x26528
block|,
literal|0x26540
block|,
literal|0x26614
block|,
literal|0x27000
block|,
literal|0x27040
block|,
literal|0x2704c
block|,
literal|0x27060
block|,
literal|0x270c0
block|,
literal|0x270ec
block|,
literal|0x27200
block|,
literal|0x27268
block|,
literal|0x27270
block|,
literal|0x27284
block|,
literal|0x272fc
block|,
literal|0x27388
block|,
literal|0x27400
block|,
literal|0x27404
block|,
literal|0x27500
block|,
literal|0x27518
block|,
literal|0x2752c
block|,
literal|0x2753c
block|,
literal|0x27550
block|,
literal|0x27554
block|,
literal|0x27600
block|,
literal|0x27600
block|,
literal|0x27608
block|,
literal|0x27628
block|,
literal|0x27630
block|,
literal|0x2763c
block|,
literal|0x27700
block|,
literal|0x2771c
block|,
literal|0x27780
block|,
literal|0x2778c
block|,
literal|0x27800
block|,
literal|0x27c38
block|,
literal|0x27c80
block|,
literal|0x27d7c
block|,
literal|0x27e00
block|,
literal|0x27e04
block|}
decl_stmt|;
name|regs
operator|->
name|version
operator|=
literal|4
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_ranges
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|reg_ranges
index|[
name|i
index|]
argument_list|,
name|reg_ranges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgbe_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|drops
decl_stmt|;
name|struct
name|port_stats
modifier|*
name|s
init|=
operator|&
name|pi
operator|->
name|stats
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return;
comment|/* without scheduling another callout */
block|}
name|t4_get_port_stats
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|s
operator|->
name|tx_frames
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|=
name|s
operator|->
name|rx_frames
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|s
operator|->
name|tx_octets
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|s
operator|->
name|rx_octets
expr_stmt|;
name|ifp
operator|->
name|if_omcasts
operator|=
name|s
operator|->
name|tx_mcast_frames
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|s
operator|->
name|rx_mcast_frames
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|=
name|s
operator|->
name|rx_ovflow0
operator|+
name|s
operator|->
name|rx_ovflow1
operator|+
name|s
operator|->
name|rx_ovflow2
operator|+
name|s
operator|->
name|rx_ovflow3
expr_stmt|;
name|drops
operator|=
name|s
operator|->
name|tx_drop
expr_stmt|;
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
name|drops
operator|+=
name|txq
operator|->
name|eq
operator|.
name|br
operator|->
name|br_drops
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drops
operator|=
name|drops
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|=
name|s
operator|->
name|tx_error_frames
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|=
name|s
operator|->
name|rx_jabber
operator|+
name|s
operator|->
name|rx_runt
operator|+
name|s
operator|->
name|rx_too_long
operator|+
name|s
operator|->
name|rx_fcs_err
operator|+
name|s
operator|->
name|rx_len_err
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|pi
operator|->
name|tick
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nports"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
literal|0
argument_list|,
literal|"# of ports"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_revision"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|rev
argument_list|,
literal|0
argument_list|,
literal|"chip hardware revision"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"TOE"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|offload
argument_list|,
literal|0
argument_list|,
literal|"hardware is capable of TCP offload"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"core_clock"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
argument_list|,
literal|0
argument_list|,
literal|"core clock frequency (in KHz)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_timers"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|intr_timer
argument_list|,
sizeof|sizeof
argument_list|(
name|intr_timer
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff timer values (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pkt_counts"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|intr_pktcount
argument_list|,
sizeof|sizeof
argument_list|(
name|intr_pktcount
argument_list|)
argument_list|,
name|sysctl_int_array
argument_list|,
literal|"A"
argument_list|,
literal|"interrupt holdoff packet counter values"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgbe_sysctls
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nrxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nrxq
argument_list|,
literal|0
argument_list|,
literal|"# of rx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ntxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|ntxq
argument_list|,
literal|0
argument_list|,
literal|"# of tx queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_rxq
argument_list|,
literal|0
argument_list|,
literal|"index of first rx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"first_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|first_txq
argument_list|,
literal|0
argument_list|,
literal|"index of first tx queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_tmr_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_tmr_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff timer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"holdoff_pktc_idx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_holdoff_pktc_idx
argument_list|,
literal|"I"
argument_list|,
literal|"holdoff packet counter index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_rxq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_rxq
argument_list|,
literal|"I"
argument_list|,
literal|"rx queue size"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qsize_txq"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
name|sysctl_qsize_txq
argument_list|,
literal|"I"
argument_list|,
literal|"tx queue size"
argument_list|)
expr_stmt|;
comment|/* 	 * dev.cxgbe.X.stats. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"port statistics"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
define|#
directive|define
name|SYSCTL_ADD_T4_REG64
parameter_list|(
name|pi
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|,
name|reg
parameter_list|)
define|\
value|SYSCTL_ADD_OID(ctx, children, OID_AUTO, name, \ 	    CTLTYPE_QUAD | CTLFLAG_RD, pi->adapter, reg, \ 	    sysctl_handle_t4_reg64, "QU", desc)
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_error_frames"
argument_list|,
literal|"# of error frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_64"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1024_1518"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_frames_1519_max"
argument_list|,
literal|"# of tx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_drop"
argument_list|,
literal|"# of dropped tx frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_DROP_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_pause"
argument_list|,
literal|"# of pause frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"tx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames transmitted"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_TX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_octets"
argument_list|,
literal|"# of octets in good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BYTES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames"
argument_list|,
literal|"total # of good frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_FRAMES_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_bcast_frames"
argument_list|,
literal|"# of broadcast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_BCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_mcast_frames"
argument_list|,
literal|"# of multicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ucast_frames"
argument_list|,
literal|"# of unicast frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_UCAST_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_too_long"
argument_list|,
literal|"# of frames exceeding MTU"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_jabber"
argument_list|,
literal|"# of jabber frames"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_MTU_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_fcs_err"
argument_list|,
literal|"# of frames received with bad FCS"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_CRC_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_len_err"
argument_list|,
literal|"# of frames received with length error"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LEN_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_symbol_err"
argument_list|,
literal|"symbol errors"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_SYM_ERROR_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_runt"
argument_list|,
literal|"# of short frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_LESS_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_64"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_64B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_65B_127B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_128B_255B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_256B_511B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_512B_1023B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1024_1518"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1024B_1518B_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_frames_1519_max"
argument_list|,
literal|"# of rx frames in this range"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_1519B_MAX_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_pause"
argument_list|,
literal|"# of pause frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PAUSE_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp0"
argument_list|,
literal|"# of PPP prio 0 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP0_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp1"
argument_list|,
literal|"# of PPP prio 1 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP1_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp2"
argument_list|,
literal|"# of PPP prio 2 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP2_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp3"
argument_list|,
literal|"# of PPP prio 3 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP3_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp4"
argument_list|,
literal|"# of PPP prio 4 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP4_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp5"
argument_list|,
literal|"# of PPP prio 5 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP5_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp6"
argument_list|,
literal|"# of PPP prio 6 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP6_L
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_REG64
argument_list|(
name|pi
argument_list|,
literal|"rx_ppp7"
argument_list|,
literal|"# of PPP prio 7 frames received"
argument_list|,
name|PORT_REG
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|,
name|A_MPS_PORT_STAT_RX_PORT_PPP7_L
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_REG64
define|#
directive|define
name|SYSCTL_ADD_T4_PORTSTAT
parameter_list|(
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|SYSCTL_ADD_QUAD(ctx, children, OID_AUTO, #name, CTLFLAG_RD, \&pi->stats.name, desc)
comment|/* We get these from port_stats and they may be stale by upto 1s */
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow0
argument_list|,
literal|"# drops due to buffer-group 0 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow1
argument_list|,
literal|"# drops due to buffer-group 1 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow2
argument_list|,
literal|"# drops due to buffer-group 2 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_ovflow3
argument_list|,
literal|"# drops due to buffer-group 3 overflows"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc0
argument_list|,
literal|"# of buffer-group 0 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc1
argument_list|,
literal|"# of buffer-group 1 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc2
argument_list|,
literal|"# of buffer-group 2 truncated packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_T4_PORTSTAT
argument_list|(
name|rx_trunc3
argument_list|,
literal|"# of buffer-group 3 truncated packets"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SYSCTL_ADD_T4_PORTSTAT
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_array
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|32
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg1
init|;
name|arg2
condition|;
name|arg2
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%d "
argument_list|,
operator|*
name|i
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_tmr_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|idx
operator|=
name|pi
operator|->
name|tmr_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|SGE_NTIMERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|rxq
operator|->
name|iq
operator|.
name|intr_params
operator|=
name|V_QINTR_TIMER_IDX
argument_list|(
name|idx
argument_list|)
operator||
name|V_QINTR_CNT_EN
argument_list|(
name|pi
operator|->
name|pktc_idx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|pi
operator|->
name|tmr_idx
operator|=
name|idx
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_holdoff_pktc_idx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|;
name|idx
operator|=
name|pi
operator|->
name|pktc_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|<
operator|-
literal|1
operator|||
name|idx
operator|>=
name|SGE_NCOUNTERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|pi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* can be changed only when port is down */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|pi
operator|->
name|pktc_idx
operator|=
name|idx
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_rxq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|pi
operator|->
name|qsize_rxq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|qsize
operator|<
literal|128
operator|||
operator|(
name|qsize
operator|&
literal|7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|pi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* can be changed only when port is down */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|pi
operator|->
name|qsize_rxq
operator|=
name|qsize
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_qsize_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg1
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|rc
decl_stmt|;
name|qsize
operator|=
name|pi
operator|->
name|qsize_txq
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qsize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|qsize
operator|<
literal|128
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IS_DOOMED
argument_list|(
name|pi
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|pi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|rc
operator|=
name|EBUSY
expr_stmt|;
comment|/* can be changed only when port is down */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|pi
operator|->
name|qsize_txq
operator|=
name|qsize
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_t4_reg64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|reg
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|t4_read_reg64
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_quad
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|txq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|eq
operator|.
name|br
expr_stmt|;
name|m
operator|=
name|txq
operator|->
name|m
condition|?
name|txq
operator|->
name|m
else|:
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|t4_eth_tx
argument_list|(
name|ifp
argument_list|,
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgbe_txq_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|arg
decl_stmt|;
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq_start
argument_list|(
name|txq
operator|->
name|ifp
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t4_os_find_pci_capability
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint8_t
name|ptr
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|cap
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_os_portmod_changed
parameter_list|(
specifier|const
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|mod_str
index|[]
init|=
block|{
name|NULL
block|,
literal|"LR"
block|,
literal|"SR"
block|,
literal|"ER"
block|,
literal|"TWINAX"
block|,
literal|"active TWINAX"
block|}
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|==
name|FW_PORT_MOD_TYPE_NONE
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"transceiver unplugged.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|mod_type
operator|>
literal|0
operator|&&
name|pi
operator|->
name|mod_type
operator|<
name|ARRAY_SIZE
argument_list|(
name|mod_str
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"%s transceiver inserted.\n"
argument_list|,
name|mod_str
index|[
name|pi
operator|->
name|mod_type
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"transceiver (type %d) inserted.\n"
argument_list|,
name|pi
operator|->
name|mod_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_os_link_changed
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|link_stat
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|sc
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|link_stat
condition|)
block|{
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|pi
operator|->
name|link_cfg
operator|.
name|speed
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|rc
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHELSIO_T4_GETREG32
case|:
block|{
name|struct
name|t4_reg32
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg32
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|edata
operator|->
name|val
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_T4_SETREG32
case|:
block|{
name|struct
name|t4_reg32
modifier|*
name|edata
init|=
operator|(
expr|struct
name|t4_reg32
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_T4_REGDUMP
case|:
block|{
name|struct
name|t4_regdump
modifier|*
name|regs
init|=
operator|(
expr|struct
name|t4_regdump
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|reglen
init|=
name|T4_REGDUMP_SIZE
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|regs
operator|->
name|len
operator|<
name|reglen
condition|)
block|{
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
comment|/* hint to the caller */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|reglen
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|t4_get_regs
argument_list|(
name|sc
argument_list|,
name|regs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rc
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|regs
operator|->
name|data
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|==
name|MOD_LOAD
condition|)
name|t4_sge_modload
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|t4_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgbe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|t4nex
argument_list|,
name|pci
argument_list|,
name|t4_driver
argument_list|,
name|t4_devclass
argument_list|,
name|t4_mod_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t4nex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgbe
argument_list|,
name|t4nex
argument_list|,
name|cxgbe_driver
argument_list|,
name|cxgbe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxgbe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

