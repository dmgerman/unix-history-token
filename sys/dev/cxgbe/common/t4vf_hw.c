begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Chelsio Communications, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"t4_regs.h"
end_include

begin_undef
undef|#
directive|undef
name|msleep
end_undef

begin_define
define|#
directive|define
name|msleep
parameter_list|(
name|x
parameter_list|)
value|do { \ 	if (cold) \ 		DELAY((x) * 1000); \ 	else \ 		pause("t4hw", (x) * hz / 1000); \ } while (0)
end_define

begin_comment
comment|/*  * Wait for the device to become ready (signified by our "who am I" register  * returning a value other than all 1's).  Return an error if it doesn't  * become ready ...  */
end_comment

begin_function
name|int
name|t4vf_wait_dev_ready
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|const
name|u32
name|whoami
init|=
name|VF_PL_REG
argument_list|(
name|A_PL_VF_WHOAMI
argument_list|)
decl_stmt|;
specifier|const
name|u32
name|notready1
init|=
literal|0xffffffff
decl_stmt|;
specifier|const
name|u32
name|notready2
init|=
literal|0xeeeeeeee
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|notready1
operator|&&
name|val
operator|!=
name|notready2
condition|)
return|return
literal|0
return|;
name|msleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|notready1
operator|&&
name|val
operator|!=
name|notready2
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_comment
comment|/**  *      t4vf_fw_reset - issue a reset to FW  *      @adapter: the adapter  *  *	Issues a reset command to FW.  For a Physical Function this would  *	result in the Firmware reseting all of its state.  For a Virtual  *	Function this just resets the state associated with the VF.  */
end_comment

begin_function
name|int
name|t4vf_fw_reset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|fw_reset_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RESET_CMD
argument_list|)
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_LEN16
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4vf_wr_mbox
argument_list|(
name|adapter
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4vf_get_sge_params - retrieve adapter Scatter gather Engine parameters  *	@adapter: the adapter  *  *	Retrieves various core SGE parameters in the form of hardware SGE  *	register values.  The caller is responsible for decoding these as  *	needed.  The SGE parameters are stored in @adapter->params.sge.  */
end_comment

begin_function
name|int
name|t4vf_get_sge_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|sge_params
modifier|*
name|sp
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|sge
decl_stmt|;
name|u32
name|params
index|[
literal|7
index|]
decl_stmt|,
name|vals
index|[
literal|7
index|]
decl_stmt|;
name|u32
name|whoami
decl_stmt|;
name|unsigned
name|int
name|pf
decl_stmt|,
name|s_hps
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_CONTROL
argument_list|)
operator|)
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_HOST_PAGE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_TIMER_VALUE_0_AND_1
argument_list|)
operator|)
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_TIMER_VALUE_2_AND_3
argument_list|)
operator|)
expr_stmt|;
name|params
index|[
literal|4
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_TIMER_VALUE_4_AND_5
argument_list|)
operator|)
expr_stmt|;
name|params
index|[
literal|5
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_CONM_CTRL
argument_list|)
operator|)
expr_stmt|;
name|params
index|[
literal|6
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_INGRESS_RX_THRESHOLD
argument_list|)
operator|)
expr_stmt|;
name|v
operator|=
name|t4vf_query_params
argument_list|(
name|adapter
argument_list|,
literal|7
argument_list|,
name|params
argument_list|,
name|vals
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|FW_SUCCESS
condition|)
return|return
name|v
return|;
name|sp
operator|->
name|sge_control
operator|=
name|vals
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|0
index|]
operator|=
name|G_THRESHOLD_0
argument_list|(
name|vals
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|1
index|]
operator|=
name|G_THRESHOLD_1
argument_list|(
name|vals
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|2
index|]
operator|=
name|G_THRESHOLD_2
argument_list|(
name|vals
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|3
index|]
operator|=
name|G_THRESHOLD_3
argument_list|(
name|vals
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|0
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE0
argument_list|(
name|vals
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|1
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE1
argument_list|(
name|vals
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|2
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE2
argument_list|(
name|vals
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|3
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE3
argument_list|(
name|vals
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|4
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE4
argument_list|(
name|vals
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|5
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE5
argument_list|(
name|vals
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fl_starve_threshold
operator|=
name|G_EGRTHRESHOLD
argument_list|(
name|vals
index|[
literal|5
index|]
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
name|sp
operator|->
name|fl_starve_threshold2
operator|=
name|sp
operator|->
name|fl_starve_threshold
expr_stmt|;
else|else
name|sp
operator|->
name|fl_starve_threshold2
operator|=
name|G_EGRTHRESHOLDPACKING
argument_list|(
name|vals
index|[
literal|5
index|]
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
comment|/* 	 * We need the Queues/Page and Host Page Size for our VF. 	 * This is based on the PF from which we're instantiated. 	 */
name|whoami
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|VF_PL_REG
argument_list|(
name|A_PL_VF_WHOAMI
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|=
name|G_SOURCEPF
argument_list|(
name|whoami
argument_list|)
expr_stmt|;
name|s_hps
operator|=
operator|(
name|S_HOSTPAGESIZEPF0
operator|+
operator|(
name|S_HOSTPAGESIZEPF1
operator|-
name|S_HOSTPAGESIZEPF0
operator|)
operator|*
name|pf
operator|)
expr_stmt|;
name|sp
operator|->
name|page_shift
operator|=
operator|(
operator|(
name|vals
index|[
literal|1
index|]
operator|>>
name|s_hps
operator|)
operator|&
name|M_HOSTPAGESIZEPF0
operator|)
operator|+
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_FLBUF_SIZES
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
literal|0
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_FL_BUFFER_SIZE0
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|)
operator|)
expr_stmt|;
name|v
operator|=
name|t4vf_query_params
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
name|params
argument_list|,
name|vals
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|FW_SUCCESS
condition|)
return|return
name|v
return|;
name|sp
operator|->
name|sge_fl_buffer_size
index|[
name|i
index|]
operator|=
name|vals
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * T4 uses a single control field to specify both the PCIe Padding and 	 * Packing Boundary.  T5 introduced the ability to specify these 	 * separately with the Padding Boundary in SGE_CONTROL and and Packing 	 * Boundary in SGE_CONTROL2.  So for T5 and later we need to grab 	 * SGE_CONTROL in order to determine how ingress packet data will be 	 * laid out in Packed Buffer Mode.  Unfortunately, older versions of 	 * the firmware won't let us retrieve SGE_CONTROL2 so if we get a 	 * failure grabbing it we throw an error since we can't figure out the 	 * right value. 	 */
name|sp
operator|->
name|spg_len
operator|=
name|sp
operator|->
name|sge_control
operator|&
name|F_EGRSTATUSPAGESIZE
condition|?
literal|128
else|:
literal|64
expr_stmt|;
name|sp
operator|->
name|fl_pktshift
operator|=
name|G_PKTSHIFT
argument_list|(
name|sp
operator|->
name|sge_control
argument_list|)
expr_stmt|;
name|sp
operator|->
name|pad_boundary
operator|=
literal|1
operator|<<
operator|(
name|G_INGPADBOUNDARY
argument_list|(
name|sp
operator|->
name|sge_control
argument_list|)
operator|+
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
name|sp
operator|->
name|pack_boundary
operator|=
name|sp
operator|->
name|pad_boundary
expr_stmt|;
else|else
block|{
name|params
index|[
literal|0
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_CONTROL2
argument_list|)
operator|)
expr_stmt|;
name|v
operator|=
name|t4vf_query_params
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
name|params
argument_list|,
name|vals
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|FW_SUCCESS
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"Unable to get SGE Control2; "
literal|"probably old firmware.\n"
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
name|G_INGPACKBOUNDARY
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|->
name|pack_boundary
operator|=
literal|16
expr_stmt|;
else|else
name|sp
operator|->
name|pack_boundary
operator|=
literal|1
operator|<<
operator|(
name|G_INGPACKBOUNDARY
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|+
literal|5
operator|)
expr_stmt|;
block|}
comment|/* 	 * For T5 and later we want to use the new BAR2 Doorbells. 	 * Unfortunately, older firmware didn't allow the this register to be 	 * read. 	 */
if|if
condition|(
operator|!
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|s_qpp
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_EGRESS_QUEUES_PER_PAGE_VF
argument_list|)
operator|)
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_REG
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_XYZ
argument_list|(
name|A_SGE_INGRESS_QUEUES_PER_PAGE_VF
argument_list|)
operator|)
expr_stmt|;
name|v
operator|=
name|t4vf_query_params
argument_list|(
name|adapter
argument_list|,
literal|2
argument_list|,
name|params
argument_list|,
name|vals
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|FW_SUCCESS
condition|)
block|{
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"Unable to get VF SGE Queues/Page; "
literal|"probably old firmware.\n"
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
name|s_qpp
operator|=
operator|(
name|S_QUEUESPERPAGEPF0
operator|+
operator|(
name|S_QUEUESPERPAGEPF1
operator|-
name|S_QUEUESPERPAGEPF0
operator|)
operator|*
name|pf
operator|)
expr_stmt|;
name|sp
operator|->
name|eq_s_qpp
operator|=
operator|(
operator|(
name|vals
index|[
literal|0
index|]
operator|>>
name|s_qpp
operator|)
operator|&
name|M_QUEUESPERPAGEPF0
operator|)
expr_stmt|;
name|sp
operator|->
name|iq_s_qpp
operator|=
operator|(
operator|(
name|vals
index|[
literal|1
index|]
operator|>>
name|s_qpp
operator|)
operator|&
name|M_QUEUESPERPAGEPF0
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4vf_get_rss_glb_config - retrieve adapter RSS Global Configuration  *	@adapter: the adapter  *  *	Retrieves global RSS mode and parameters with which we have to live  *	and stores them in the @adapter's RSS parameters.  */
end_comment

begin_function
name|int
name|t4vf_get_rss_glb_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rss_params
modifier|*
name|rss
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|rss
decl_stmt|;
name|struct
name|fw_rss_glb_config_cmd
name|cmd
decl_stmt|,
name|rpl
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* 	 * Execute an RSS Global Configuration read command to retrieve 	 * our RSS configuration. 	 */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RSS_GLB_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4vf_wr_mbox
argument_list|(
name|adapter
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|&
name|rpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|FW_SUCCESS
condition|)
return|return
name|v
return|;
comment|/* 	 * Transate the big-endian RSS Global Configuration into our 	 * cpu-endian format based on the RSS mode.  We also do first level 	 * filtering at this point to weed out modes which don't support 	 * VF Drivers ... 	 */
name|rss
operator|->
name|mode
operator|=
name|G_FW_RSS_GLB_CONFIG_CMD_MODE
argument_list|(
name|be32_to_cpu
argument_list|(
name|rpl
operator|.
name|u
operator|.
name|manual
operator|.
name|mode_pkd
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rss
operator|->
name|mode
condition|)
block|{
case|case
name|FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL
case|:
block|{
name|u32
name|word
init|=
name|be32_to_cpu
argument_list|(
name|rpl
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|synmapen_to_hashtoeplitz
argument_list|)
decl_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|synmapen
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_SYNMAPEN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|syn4tupenipv6
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV6
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|syn2tupenipv6
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV6
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|syn4tupenipv4
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV4
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|syn2tupenipv4
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV4
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|ofdmapen
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_OFDMAPEN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|tnlmapen
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_TNLMAPEN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|tnlalllookup
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_TNLALLLKP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|hashtoeplitz
operator|=
operator|(
operator|(
name|word
operator|&
name|F_FW_RSS_GLB_CONFIG_CMD_HASHTOEPLITZ
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* we need at least Tunnel Map Enable to be set */
if|if
condition|(
operator|!
name|rss
operator|->
name|u
operator|.
name|basicvirtual
operator|.
name|tnlmapen
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
block|}
default|default:
comment|/* all unknown/unsupported RSS modes result in an error */
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4vf_get_vfres - retrieve VF resource limits  *	@adapter: the adapter  *  *	Retrieves configured resource limits and capabilities for a virtual  *	function.  The results are stored in @adapter->vfres.  */
end_comment

begin_function
name|int
name|t4vf_get_vfres
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|vf_resources
modifier|*
name|vfres
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|vfres
decl_stmt|;
name|struct
name|fw_pfvf_cmd
name|cmd
decl_stmt|,
name|rpl
decl_stmt|;
name|int
name|v
decl_stmt|;
name|u32
name|word
decl_stmt|;
comment|/* 	 * Execute PFVF Read command to get VF resource limits; bail out early 	 * with error on command failure. 	 */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PFVF_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4vf_wr_mbox
argument_list|(
name|adapter
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|&
name|rpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|FW_SUCCESS
condition|)
return|return
name|v
return|;
comment|/* 	 * Extract VF resource limits and return success. 	 */
name|word
operator|=
name|be32_to_cpu
argument_list|(
name|rpl
operator|.
name|niqflint_niq
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|niqflint
operator|=
name|G_FW_PFVF_CMD_NIQFLINT
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|niq
operator|=
name|G_FW_PFVF_CMD_NIQ
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|be32_to_cpu
argument_list|(
name|rpl
operator|.
name|type_to_neq
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|neq
operator|=
name|G_FW_PFVF_CMD_NEQ
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|pmask
operator|=
name|G_FW_PFVF_CMD_PMASK
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|be32_to_cpu
argument_list|(
name|rpl
operator|.
name|tc_to_nexactf
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|tc
operator|=
name|G_FW_PFVF_CMD_TC
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|nvi
operator|=
name|G_FW_PFVF_CMD_NVI
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|nexactf
operator|=
name|G_FW_PFVF_CMD_NEXACTF
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|be32_to_cpu
argument_list|(
name|rpl
operator|.
name|r_caps_to_nethctrl
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|r_caps
operator|=
name|G_FW_PFVF_CMD_R_CAPS
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|wx_caps
operator|=
name|G_FW_PFVF_CMD_WX_CAPS
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|vfres
operator|->
name|nethctrl
operator|=
name|G_FW_PFVF_CMD_NETHCTRL
argument_list|(
name|word
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  */
end_comment

begin_function
name|int
name|t4vf_prep_adapter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Wait for the device to become ready before proceeding ... 	 */
name|err
operator|=
name|t4vf_wait_dev_ready
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|=
name|pci_get_device
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
operator|>>
literal|12
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|>=
literal|0xa
condition|)
block|{
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|-=
operator|(
literal|0xa
operator|-
literal|0x4
operator|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|fpga
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Default port and clock for debugging in case we can't reach 	 * firmware. 	 */
name|adapter
operator|->
name|params
operator|.
name|nports
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|vfres
operator|.
name|pmask
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|=
literal|50000
expr_stmt|;
name|adapter
operator|->
name|chip_params
operator|=
name|t4_get_chip_params
argument_list|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|chip_params
operator|==
name|NULL
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

