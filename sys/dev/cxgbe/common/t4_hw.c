begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012, 2016 Chelsio Communications, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"firmware/t4fw_interface.h"
end_include

begin_undef
undef|#
directive|undef
name|msleep
end_undef

begin_define
define|#
directive|define
name|msleep
parameter_list|(
name|x
parameter_list|)
value|do { \ 	if (cold) \ 		DELAY((x) * 1000); \ 	else \ 		pause("t4hw", (x) * hz / 1000); \ } while (0)
end_define

begin_comment
comment|/**  *	t4_wait_op_done_val - wait until an operation is completed  *	@adapter: the adapter performing the operation  *	@reg: the register to check for completion  *	@mask: a single-bit field within @reg that indicates completion  *	@polarity: the value of the field when the operation is completed  *	@attempts: number of check iterations  *	@delay: delay in usecs between iterations  *	@valp: where to store the value of the register at completion time  *  *	Wait until an operation is completed by checking a bit in a register  *	up to @attempts times.  If @valp is not NULL the value of the register  *	at the time it indicated completion is stored there.  Returns 0 if the  *	operation completes and	-EAGAIN	otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|t4_wait_op_done_val
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|mask
parameter_list|,
name|int
name|polarity
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|u32
name|val
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|!
operator|(
name|val
operator|&
name|mask
operator|)
operator|==
name|polarity
condition|)
block|{
if|if
condition|(
name|valp
condition|)
operator|*
name|valp
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|udelay
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|t4_wait_op_done
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|mask
parameter_list|,
name|int
name|polarity
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
return|return
name|t4_wait_op_done_val
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|,
name|mask
argument_list|,
name|polarity
argument_list|,
name|attempts
argument_list|,
name|delay
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_reg_field - set a register field to a value  *	@adapter: the adapter to program  *	@addr: the register address  *	@mask: specifies the portion of the register to modify  *	@val: the new value for the register field  *  *	Sets a register field specified by the supplied mask to the  *	given value.  */
end_comment

begin_function
name|void
name|t4_set_reg_field
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|mask
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|u32
name|v
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
operator|~
name|mask
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|v
operator||
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	t4_read_indirect - read indirectly addressed registers  *	@adap: the adapter  *	@addr_reg: register holding the indirect address  *	@data_reg: register holding the value of the indirect register  *	@vals: where the read register values are stored  *	@nregs: how many indirect registers to read  *	@start_idx: index of first indirect register to read  *  *	Reads registers that are accessed indirectly through an address/data  *	register pair.  */
end_comment

begin_function
name|void
name|t4_read_indirect
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr_reg
parameter_list|,
name|unsigned
name|int
name|data_reg
parameter_list|,
name|u32
modifier|*
name|vals
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|unsigned
name|int
name|start_idx
parameter_list|)
block|{
while|while
condition|(
name|nregs
operator|--
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|addr_reg
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
operator|*
name|vals
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|start_idx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_write_indirect - write indirectly addressed registers  *	@adap: the adapter  *	@addr_reg: register holding the indirect addresses  *	@data_reg: register holding the value for the indirect registers  *	@vals: values to write  *	@nregs: how many indirect registers to write  *	@start_idx: address of first indirect register to write  *  *	Writes a sequential block of registers that are accessed indirectly  *	through an address/data register pair.  */
end_comment

begin_function
name|void
name|t4_write_indirect
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr_reg
parameter_list|,
name|unsigned
name|int
name|data_reg
parameter_list|,
specifier|const
name|u32
modifier|*
name|vals
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|unsigned
name|int
name|start_idx
parameter_list|)
block|{
while|while
condition|(
name|nregs
operator|--
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|addr_reg
argument_list|,
name|start_idx
operator|++
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|,
operator|*
name|vals
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read a 32-bit PCI Configuration Space register via the PCI-E backdoor  * mechanism.  This guarantees that we get the real value even if we're  * operating within a Virtual Machine and the Hypervisor is trapping our  * Configuration Space accesses.  *  * N.B. This routine should only be used as a last resort: the firmware uses  *      the backdoor registers on a regular basis and we can end up  *      conflicting with it's uses!  */
end_comment

begin_function
name|u32
name|t4_hw_pci_read_cfg4
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|req
init|=
name|V_FUNCTION
argument_list|(
name|adap
operator|->
name|pf
argument_list|)
operator||
name|V_REGISTER
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adap
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
name|req
operator||=
name|F_ENABLE
expr_stmt|;
else|else
name|req
operator||=
name|F_T6_ENABLE
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|req
operator||=
name|F_LOCALCFG
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_CFG_SPACE_REQ
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_CFG_SPACE_DATA
argument_list|)
expr_stmt|;
comment|/* 	 * Reset F_ENABLE to 0 so reads of PCIE_CFG_SPACE_DATA won't cause a 	 * Configuration Space read.  (None of the other fields matter when 	 * F_ENABLE is 0 so a simple register write is easier than a 	 * read-modify-write via t4_set_reg_field().) 	 */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_CFG_SPACE_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * t4_report_fw_error - report firmware error  * @adap: the adapter  *  * The adapter firmware can indicate error conditions to the host.  * If the firmware has indicated an error, print out the reason for  * the firmware error.  */
end_comment

begin_function
specifier|static
name|void
name|t4_report_fw_error
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reason
index|[]
init|=
block|{
literal|"Crash"
block|,
comment|/* PCIE_FW_EVAL_CRASH */
literal|"During Device Preparation"
block|,
comment|/* PCIE_FW_EVAL_PREP */
literal|"During Device Configuration"
block|,
comment|/* PCIE_FW_EVAL_CONF */
literal|"During Device Initialization"
block|,
comment|/* PCIE_FW_EVAL_INIT */
literal|"Unexpected Event"
block|,
comment|/* PCIE_FW_EVAL_UNEXPECTEDEVENT */
literal|"Insufficient Airflow"
block|,
comment|/* PCIE_FW_EVAL_OVERHEAT */
literal|"Device Shutdown"
block|,
comment|/* PCIE_FW_EVAL_DEVICESHUTDOWN */
literal|"Reserved"
block|,
comment|/* reserved */
block|}
decl_stmt|;
name|u32
name|pcie_fw
decl_stmt|;
name|pcie_fw
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_fw
operator|&
name|F_PCIE_FW_ERR
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Firmware reports adapter error: %s\n"
argument_list|,
name|reason
index|[
name|G_PCIE_FW_EVAL
argument_list|(
name|pcie_fw
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the reply to a mailbox command and store it in @rpl in big-endian order.  */
end_comment

begin_function
specifier|static
name|void
name|get_mbox_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|__be64
modifier|*
name|rpl
parameter_list|,
name|int
name|nflit
parameter_list|,
name|u32
name|mbox_addr
parameter_list|)
block|{
for|for
control|(
init|;
name|nflit
condition|;
name|nflit
operator|--
operator|,
name|mbox_addr
operator|+=
literal|8
control|)
operator|*
name|rpl
operator|++
operator|=
name|cpu_to_be64
argument_list|(
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|mbox_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a FW assertion reported in a mailbox.  */
end_comment

begin_function
specifier|static
name|void
name|fw_asrt
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|fw_debug_cmd
modifier|*
name|asrt
parameter_list|)
block|{
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"FW assertion at %.16s:%u, val0 %#x, val1 %#x\n"
argument_list|,
name|asrt
operator|->
name|u
operator|.
name|assert
operator|.
name|filename_0_7
argument_list|,
name|be32_to_cpu
argument_list|(
name|asrt
operator|->
name|u
operator|.
name|assert
operator|.
name|line
argument_list|)
argument_list|,
name|be32_to_cpu
argument_list|(
name|asrt
operator|->
name|u
operator|.
name|assert
operator|.
name|x
argument_list|)
argument_list|,
name|be32_to_cpu
argument_list|(
name|asrt
operator|->
name|u
operator|.
name|assert
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|X_CIM_PF_NOACCESS
value|0xeeeeeeee
end_define

begin_comment
comment|/**  *	t4_wr_mbox_meat_timeout - send a command to FW through the given mailbox  *	@adap: the adapter  *	@mbox: index of the mailbox to use  *	@cmd: the command to write  *	@size: command length in bytes  *	@rpl: where to optionally store the reply  *	@sleep_ok: if true we may sleep while awaiting command completion  *	@timeout: time to wait for command to finish before timing out  *		(negative implies @sleep_ok=false)  *  *	Sends the given command to FW through the selected mailbox and waits  *	for the FW to execute the command.  If @rpl is not %NULL it is used to  *	store the FW's reply to the command.  The command and its optional  *	reply are of the same length.  Some FW commands like RESET and  *	INITIALIZE can take a considerable amount of time to execute.  *	@sleep_ok determines whether we may sleep while awaiting the response.  *	If sleeping is allowed we use progressive backoff otherwise we spin.  *	Note that passing in a negative @timeout is an alternate mechanism  *	for specifying @sleep_ok=false.  This is useful when a higher level  *	interface allows for specification of @timeout but not @sleep_ok ...  *  *	The return value is 0 on success or a negative errno on failure.  A  *	failure can happen either because we are not able to execute the  *	command or FW executes it but signals an error.  In the latter case  *	the return value is the error code indicated by FW (negated).  */
end_comment

begin_function
name|int
name|t4_wr_mbox_meat_timeout
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|mbox
parameter_list|,
specifier|const
name|void
modifier|*
name|cmd
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|rpl
parameter_list|,
name|bool
name|sleep_ok
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
comment|/* 	 * We delay in small increments at first in an effort to maintain 	 * responsiveness for simple, fast executing commands but then back 	 * off to larger delays to a maximum retry delay. 	 */
specifier|static
specifier|const
name|int
name|delay
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|10
block|,
literal|10
block|,
literal|20
block|,
literal|50
block|,
literal|100
block|}
decl_stmt|;
name|u32
name|v
decl_stmt|;
name|u64
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ms
decl_stmt|,
name|delay_idx
decl_stmt|,
name|ret
decl_stmt|;
specifier|const
name|__be64
modifier|*
name|p
init|=
name|cmd
decl_stmt|;
name|u32
name|data_reg
init|=
name|PF_REG
argument_list|(
name|mbox
argument_list|,
name|A_CIM_PF_MAILBOX_DATA
argument_list|)
decl_stmt|;
name|u32
name|ctl_reg
init|=
name|PF_REG
argument_list|(
name|mbox
argument_list|,
name|A_CIM_PF_MAILBOX_CTRL
argument_list|)
decl_stmt|;
name|u32
name|ctl
decl_stmt|;
name|__be64
name|cmd_rpl
index|[
name|MBOX_LEN
operator|/
literal|8
index|]
decl_stmt|;
name|u32
name|pcie_fw
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
literal|15
operator|)
operator|||
name|size
operator|>
name|MBOX_LEN
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|adap
operator|->
name|flags
operator|&
name|IS_VF
condition|)
block|{
if|if
condition|(
name|is_t6
argument_list|(
name|adap
argument_list|)
condition|)
name|data_reg
operator|=
name|FW_T6VF_MBDATA_BASE_ADDR
expr_stmt|;
else|else
name|data_reg
operator|=
name|FW_T4VF_MBDATA_BASE_ADDR
expr_stmt|;
name|ctl_reg
operator|=
name|VF_CIM_REG
argument_list|(
name|A_CIM_VF_EXT_MAILBOX_CTRL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have a negative timeout, that implies that we can't sleep. 	 */
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
block|{
name|sleep_ok
operator|=
name|false
expr_stmt|;
name|timeout
operator|=
operator|-
name|timeout
expr_stmt|;
block|}
comment|/* 	 * Attempt to gain access to the mailbox. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|ctl
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|)
expr_stmt|;
name|v
operator|=
name|G_MBOWNER
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|X_MBOWNER_NONE
condition|)
break|break;
block|}
comment|/* 	 * If we were unable to gain access, dequeue ourselves from the 	 * mailbox atomic access list and report the error to our caller. 	 */
if|if
condition|(
name|v
operator|!=
name|X_MBOWNER_PL
condition|)
block|{
name|t4_report_fw_error
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|v
operator|==
name|X_MBOWNER_FW
operator|)
condition|?
operator|-
name|EBUSY
else|:
operator|-
name|ETIMEDOUT
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* 	 * If we gain ownership of the mailbox and there's a "valid" message 	 * in it, this is likely an asynchronous error message from the 	 * firmware.  So we'll report that and then proceed on with attempting 	 * to issue our own command ... which may well fail if the error 	 * presaged the firmware crashing ... 	 */
if|if
condition|(
name|ctl
operator|&
name|F_MBMSGVALID
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"found VALID command in mbox %u: "
literal|"%llx %llx %llx %llx %llx %llx %llx %llx\n"
argument_list|,
name|mbox
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
literal|8
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
literal|16
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
literal|24
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
literal|32
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
literal|40
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
literal|48
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
literal|56
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy in the new mailbox command and send it on its way ... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|8
operator|,
name|p
operator|++
control|)
name|t4_write_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
name|i
argument_list|,
name|be64_to_cpu
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|flags
operator|&
name|IS_VF
condition|)
block|{
comment|/* 		 * For the VFs, the Mailbox Data "registers" are 		 * actually backed by T4's "MA" interface rather than 		 * PL Registers (as is the case for the PFs).  Because 		 * these are in different coherency domains, the write 		 * to the VF's PL-register-backed Mailbox Control can 		 * race in front of the writes to the MA-backed VF 		 * Mailbox Data "registers".  So we need to do a 		 * read-back on at least one byte of the VF Mailbox 		 * Data registers before doing the write to the VF 		 * Mailbox Control register. 		 */
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
block|}
name|CH_DUMP_MBOX
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|,
name|F_MBMSGVALID
operator||
name|V_MBOWNER
argument_list|(
name|X_MBOWNER_FW
argument_list|)
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|)
expr_stmt|;
comment|/* flush write */
name|delay_idx
operator|=
literal|0
expr_stmt|;
name|ms
operator|=
name|delay
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Loop waiting for the reply; bail out if we time out or the firmware 	 * reports an error. 	 */
name|pcie_fw
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|+=
name|ms
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|adap
operator|->
name|flags
operator|&
name|IS_VF
operator|)
condition|)
block|{
name|pcie_fw
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_fw
operator|&
name|F_PCIE_FW_ERR
condition|)
break|break;
block|}
if|if
condition|(
name|sleep_ok
condition|)
block|{
name|ms
operator|=
name|delay
index|[
name|delay_idx
index|]
expr_stmt|;
comment|/* last element may repeat */
if|if
condition|(
name|delay_idx
operator|<
name|ARRAY_SIZE
argument_list|(
name|delay
argument_list|)
operator|-
literal|1
condition|)
name|delay_idx
operator|++
expr_stmt|;
name|msleep
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mdelay
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|X_CIM_PF_NOACCESS
condition|)
continue|continue;
if|if
condition|(
name|G_MBOWNER
argument_list|(
name|v
argument_list|)
operator|==
name|X_MBOWNER_PL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|&
name|F_MBMSGVALID
operator|)
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|,
name|V_MBOWNER
argument_list|(
name|X_MBOWNER_NONE
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Retrieve the command reply and release the mailbox. 			 */
name|get_mbox_rpl
argument_list|(
name|adap
argument_list|,
name|cmd_rpl
argument_list|,
name|MBOX_LEN
operator|/
literal|8
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|,
name|V_MBOWNER
argument_list|(
name|X_MBOWNER_NONE
argument_list|)
argument_list|)
expr_stmt|;
name|CH_DUMP_MBOX
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|res
operator|=
name|be64_to_cpu
argument_list|(
name|cmd_rpl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_FW_CMD_OP
argument_list|(
name|res
operator|>>
literal|32
argument_list|)
operator|==
name|FW_DEBUG_CMD
condition|)
block|{
name|fw_asrt
argument_list|(
name|adap
argument_list|,
operator|(
expr|struct
name|fw_debug_cmd
operator|*
operator|)
name|cmd_rpl
argument_list|)
expr_stmt|;
name|res
operator|=
name|V_FW_CMD_RETVAL
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rpl
condition|)
name|memcpy
argument_list|(
name|rpl
argument_list|,
name|cmd_rpl
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|-
name|G_FW_CMD_RETVAL
argument_list|(
operator|(
name|int
operator|)
name|res
argument_list|)
return|;
block|}
block|}
comment|/* 	 * We timed out waiting for a reply to our mailbox command.  Report 	 * the error and also check to see if the firmware reported any 	 * errors ... 	 */
name|ret
operator|=
operator|(
name|pcie_fw
operator|&
name|F_PCIE_FW_ERR
operator|)
condition|?
operator|-
name|ENXIO
else|:
operator|-
name|ETIMEDOUT
expr_stmt|;
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"command %#x in mailbox %d timed out\n"
argument_list|,
operator|*
operator|(
specifier|const
name|u8
operator|*
operator|)
name|cmd
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
comment|/* If DUMP_MBOX is set the mbox has already been dumped */
if|if
condition|(
operator|(
name|adap
operator|->
name|debug_flags
operator|&
name|DF_DUMP_MBOX
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|cmd
expr_stmt|;
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"mbox: %016llx %016llx %016llx %016llx "
literal|"%016llx %016llx %016llx %016llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|5
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|6
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t4_report_fw_error
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|t4_wr_mbox_meat
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|mbox
parameter_list|,
specifier|const
name|void
modifier|*
name|cmd
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|rpl
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
return|return
name|t4_wr_mbox_meat_timeout
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|cmd
argument_list|,
name|size
argument_list|,
name|rpl
argument_list|,
name|sleep_ok
argument_list|,
name|FW_CMD_MAX_TIMEOUT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_edc_err_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|u32
name|edc_ecc_err_addr_reg
decl_stmt|;
name|u32
name|edc_bist_status_rdata_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|CH_WARN
argument_list|(
name|adap
argument_list|,
literal|"%s: T4 NOT supported.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|idx
operator|!=
name|MEM_EDC0
operator|&&
name|idx
operator|!=
name|MEM_EDC1
condition|)
block|{
name|CH_WARN
argument_list|(
name|adap
argument_list|,
literal|"%s: idx %d NOT supported.\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|edc_ecc_err_addr_reg
operator|=
name|EDC_T5_REG
argument_list|(
name|A_EDC_H_ECC_ERR_ADDR
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_status_rdata_reg
operator|=
name|EDC_T5_REG
argument_list|(
name|A_EDC_H_BIST_STATUS_RDATA
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|CH_WARN
argument_list|(
name|adap
argument_list|,
literal|"edc%d err addr 0x%x: 0x%x.\n"
argument_list|,
name|idx
argument_list|,
name|edc_ecc_err_addr_reg
argument_list|,
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|edc_ecc_err_addr_reg
argument_list|)
argument_list|)
expr_stmt|;
name|CH_WARN
argument_list|(
name|adap
argument_list|,
literal|"bist: 0x%x, status %llx %llx %llx %llx %llx %llx %llx %llx %llx.\n"
argument_list|,
name|edc_bist_status_rdata_reg
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|8
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|16
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|24
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|32
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|40
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|48
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|56
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|edc_bist_status_rdata_reg
operator|+
literal|64
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mc_read - read from MC through backdoor accesses  *	@adap: the adapter  *	@idx: which MC to access  *	@addr: address of first byte requested  *	@data: 64 bytes of data containing the requested address  *	@ecc: where to store the corresponding 64-bit ECC word  *  *	Read 64 bytes of data from MC starting at a 64-byte-aligned address  *	that covers the requested address @addr.  If @parity is not %NULL it  *	is assigned the 64-bit ECC word for the read data.  */
end_comment

begin_function
name|int
name|t4_mc_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|u32
name|addr
parameter_list|,
name|__be32
modifier|*
name|data
parameter_list|,
name|u64
modifier|*
name|ecc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|mc_bist_cmd_reg
decl_stmt|,
name|mc_bist_cmd_addr_reg
decl_stmt|,
name|mc_bist_cmd_len_reg
decl_stmt|;
name|u32
name|mc_bist_status_rdata_reg
decl_stmt|,
name|mc_bist_data_pattern_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|mc_bist_cmd_reg
operator|=
name|A_MC_BIST_CMD
expr_stmt|;
name|mc_bist_cmd_addr_reg
operator|=
name|A_MC_BIST_CMD_ADDR
expr_stmt|;
name|mc_bist_cmd_len_reg
operator|=
name|A_MC_BIST_CMD_LEN
expr_stmt|;
name|mc_bist_status_rdata_reg
operator|=
name|A_MC_BIST_STATUS_RDATA
expr_stmt|;
name|mc_bist_data_pattern_reg
operator|=
name|A_MC_BIST_DATA_PATTERN
expr_stmt|;
block|}
else|else
block|{
name|mc_bist_cmd_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_CMD
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_cmd_addr_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_CMD_ADDR
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_cmd_len_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_CMD_LEN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_status_rdata_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_STATUS_RDATA
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_data_pattern_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_DATA_PATTERN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_reg
argument_list|)
operator|&
name|F_START_BIST
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_addr_reg
argument_list|,
name|addr
operator|&
operator|~
literal|0x3fU
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_len_reg
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_data_pattern_reg
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_reg
argument_list|,
name|V_BIST_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_START_BIST
operator||
name|V_BIST_CMD_GAP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_reg
argument_list|,
name|F_START_BIST
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
define|#
directive|define
name|MC_DATA
parameter_list|(
name|i
parameter_list|)
value|MC_BIST_STATUS_REG(mc_bist_status_rdata_reg, i)
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|data
operator|++
operator|=
name|ntohl
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|MC_DATA
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecc
condition|)
operator|*
name|ecc
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|MC_DATA
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MC_DATA
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_edc_read - read from EDC through backdoor accesses  *	@adap: the adapter  *	@idx: which EDC to access  *	@addr: address of first byte requested  *	@data: 64 bytes of data containing the requested address  *	@ecc: where to store the corresponding 64-bit ECC word  *  *	Read 64 bytes of data from EDC starting at a 64-byte-aligned address  *	that covers the requested address @addr.  If @parity is not %NULL it  *	is assigned the 64-bit ECC word for the read data.  */
end_comment

begin_function
name|int
name|t4_edc_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|u32
name|addr
parameter_list|,
name|__be32
modifier|*
name|data
parameter_list|,
name|u64
modifier|*
name|ecc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|edc_bist_cmd_reg
decl_stmt|,
name|edc_bist_cmd_addr_reg
decl_stmt|,
name|edc_bist_cmd_len_reg
decl_stmt|;
name|u32
name|edc_bist_cmd_data_pattern
decl_stmt|,
name|edc_bist_status_rdata_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|edc_bist_cmd_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_CMD
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_addr_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_CMD_ADDR
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_len_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_CMD_LEN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_data_pattern
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_DATA_PATTERN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_status_rdata_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_STATUS_RDATA
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  * These macro are missing in t4_regs.h file.  * Added temporarily for testing.  */
define|#
directive|define
name|EDC_STRIDE_T5
value|(EDC_T51_BASE_ADDR - EDC_T50_BASE_ADDR)
define|#
directive|define
name|EDC_REG_T5
parameter_list|(
name|reg
parameter_list|,
name|idx
parameter_list|)
value|(reg + EDC_STRIDE_T5 * idx)
name|edc_bist_cmd_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_CMD
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_addr_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_CMD_ADDR
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_len_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_CMD_LEN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_data_pattern
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_DATA_PATTERN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_status_rdata_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_STATUS_RDATA
argument_list|,
name|idx
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|EDC_REG_T5
undef|#
directive|undef
name|EDC_STRIDE_T5
block|}
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_reg
argument_list|)
operator|&
name|F_START_BIST
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_addr_reg
argument_list|,
name|addr
operator|&
operator|~
literal|0x3fU
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_len_reg
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_data_pattern
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_reg
argument_list|,
name|V_BIST_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_BIST_CMD_GAP
argument_list|(
literal|1
argument_list|)
operator||
name|F_START_BIST
argument_list|)
expr_stmt|;
name|i
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_reg
argument_list|,
name|F_START_BIST
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
define|#
directive|define
name|EDC_DATA
parameter_list|(
name|i
parameter_list|)
value|EDC_BIST_STATUS_REG(edc_bist_status_rdata_reg, i)
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|data
operator|++
operator|=
name|ntohl
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EDC_DATA
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecc
condition|)
operator|*
name|ecc
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|EDC_DATA
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|EDC_DATA
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mem_read - read EDC 0, EDC 1 or MC into buffer  *	@adap: the adapter  *	@mtype: memory type: MEM_EDC0, MEM_EDC1 or MEM_MC  *	@addr: address within indicated memory type  *	@len: amount of memory to read  *	@buf: host memory buffer  *  *	Reads an [almost] arbitrary memory region in the firmware: the  *	firmware memory address, length and host buffer must be aligned on  *	32-bit boudaries.  The memory is returned as a raw byte sequence from  *	the firmware's memory.  If this memory contains data structures which  *	contain multi-byte integers, it's the callers responsibility to  *	perform appropriate byte order conversions.  */
end_comment

begin_function
name|int
name|t4_mem_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|mtype
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|len
parameter_list|,
name|__be32
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|pos
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Argument sanity checks ... 	 */
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|len
operator|&
literal|0x3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 	 * The underlaying EDC/MC read routines read 64 bytes at a time so we 	 * need to round down the start and round up the end.  We'll start 	 * copying out of the first line at (addr - start) a word at a time. 	 */
name|start
operator|=
name|rounddown2
argument_list|(
name|addr
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|end
operator|=
name|roundup2
argument_list|(
name|addr
operator|+
name|len
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|addr
operator|-
name|start
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|__be32
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|start
init|;
name|pos
operator|<
name|end
condition|;
name|pos
operator|+=
literal|64
operator|,
name|offset
operator|=
literal|0
control|)
block|{
name|__be32
name|data
index|[
literal|16
index|]
decl_stmt|;
comment|/* 		 * Read the chip's memory block and bail if there's an error. 		 */
if|if
condition|(
operator|(
name|mtype
operator|==
name|MEM_MC
operator|)
operator|||
operator|(
name|mtype
operator|==
name|MEM_MC1
operator|)
condition|)
name|ret
operator|=
name|t4_mc_read
argument_list|(
name|adap
argument_list|,
name|mtype
operator|-
name|MEM_MC
argument_list|,
name|pos
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|t4_edc_read
argument_list|(
name|adap
argument_list|,
name|mtype
argument_list|,
name|pos
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* 		 * Copy the data into the caller's memory buffer. 		 */
while|while
condition|(
name|offset
operator|<
literal|16
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|__be32
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return the specified PCI-E Configuration Space register from our Physical  * Function.  We try first via a Firmware LDST Command (if fw_attach != 0)  * since we prefer to let the firmware own all of these registers, but if that  * fails we go for it directly ourselves.  */
end_comment

begin_function
name|u32
name|t4_read_pcie_cfg4
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|drv_fw_attach
parameter_list|)
block|{
comment|/* 	 * If fw_attach != 0, construct and send the Firmware LDST Command to 	 * retrieve the specified PCI-E Configuration Space register. 	 */
if|if
condition|(
name|drv_fw_attach
operator|!=
literal|0
condition|)
block|{
name|struct
name|fw_ldst_cmd
name|ldst_cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ldst_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_FUNC_PCIE
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|u
operator|.
name|pcie
operator|.
name|select_naccess
operator|=
name|V_FW_LDST_CMD_NACCESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ldst_cmd
operator|.
name|u
operator|.
name|pcie
operator|.
name|ctrl_to_fn
operator|=
operator|(
name|F_FW_LDST_CMD_LC
operator||
name|V_FW_LDST_CMD_FN
argument_list|(
name|adap
operator|->
name|pf
argument_list|)
operator|)
expr_stmt|;
name|ldst_cmd
operator|.
name|u
operator|.
name|pcie
operator|.
name|r
operator|=
name|reg
expr_stmt|;
comment|/* 		 * If the LDST Command succeeds, return the result, otherwise 		 * fall through to reading it directly ourselves ... 		 */
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|mbox
argument_list|,
operator|&
name|ldst_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ldst_cmd
argument_list|)
argument_list|,
operator|&
name|ldst_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
name|be32_to_cpu
argument_list|(
name|ldst_cmd
operator|.
name|u
operator|.
name|pcie
operator|.
name|data
index|[
literal|0
index|]
argument_list|)
return|;
name|CH_WARN
argument_list|(
name|adap
argument_list|,
literal|"Firmware failed to return "
literal|"Configuration Space register %d, err = %d\n"
argument_list|,
name|reg
argument_list|,
operator|-
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read the desired Configuration Space register via the PCI-E 	 * Backdoor mechanism. 	 */
return|return
name|t4_hw_pci_read_cfg4
argument_list|(
name|adap
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_regs_len - return the size of the chips register set  *	@adapter: the adapter  *  *	Returns the size of the chip's BAR0 register space.  */
end_comment

begin_function
name|unsigned
name|int
name|t4_get_regs_len
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|unsigned
name|int
name|chip_version
init|=
name|chip_id
argument_list|(
name|adapter
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|chip_version
condition|)
block|{
case|case
name|CHELSIO_T4
case|:
if|if
condition|(
name|adapter
operator|->
name|flags
operator|&
name|IS_VF
condition|)
return|return
name|FW_T4VF_REGMAP_SIZE
return|;
return|return
name|T4_REGMAP_SIZE
return|;
case|case
name|CHELSIO_T5
case|:
case|case
name|CHELSIO_T6
case|:
if|if
condition|(
name|adapter
operator|->
name|flags
operator|&
name|IS_VF
condition|)
return|return
name|FW_T4VF_REGMAP_SIZE
return|;
return|return
name|T5_REGMAP_SIZE
return|;
block|}
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"Unsupported chip version %d\n"
argument_list|,
name|chip_version
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_regs - read chip registers into provided buffer  *	@adap: the adapter  *	@buf: register buffer  *	@buf_size: size (in bytes) of register buffer  *  *	If the provided register buffer isn't large enough for the chip's  *	full register range, the register dump will be truncated to the  *	register buffer's size.  */
end_comment

begin_function
name|void
name|t4_get_regs
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|buf_size
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|t4_reg_ranges
index|[]
init|=
block|{
literal|0x1008
block|,
literal|0x1108
block|,
literal|0x1180
block|,
literal|0x1184
block|,
literal|0x1190
block|,
literal|0x1194
block|,
literal|0x11a0
block|,
literal|0x11a4
block|,
literal|0x11b0
block|,
literal|0x11b4
block|,
literal|0x11fc
block|,
literal|0x123c
block|,
literal|0x1300
block|,
literal|0x173c
block|,
literal|0x1800
block|,
literal|0x18fc
block|,
literal|0x3000
block|,
literal|0x30d8
block|,
literal|0x30e0
block|,
literal|0x30e4
block|,
literal|0x30ec
block|,
literal|0x5910
block|,
literal|0x5920
block|,
literal|0x5924
block|,
literal|0x5960
block|,
literal|0x5960
block|,
literal|0x5968
block|,
literal|0x5968
block|,
literal|0x5970
block|,
literal|0x5970
block|,
literal|0x5978
block|,
literal|0x5978
block|,
literal|0x5980
block|,
literal|0x5980
block|,
literal|0x5988
block|,
literal|0x5988
block|,
literal|0x5990
block|,
literal|0x5990
block|,
literal|0x5998
block|,
literal|0x5998
block|,
literal|0x59a0
block|,
literal|0x59d4
block|,
literal|0x5a00
block|,
literal|0x5ae0
block|,
literal|0x5ae8
block|,
literal|0x5ae8
block|,
literal|0x5af0
block|,
literal|0x5af0
block|,
literal|0x5af8
block|,
literal|0x5af8
block|,
literal|0x6000
block|,
literal|0x6098
block|,
literal|0x6100
block|,
literal|0x6150
block|,
literal|0x6200
block|,
literal|0x6208
block|,
literal|0x6240
block|,
literal|0x6248
block|,
literal|0x6280
block|,
literal|0x62b0
block|,
literal|0x62c0
block|,
literal|0x6338
block|,
literal|0x6370
block|,
literal|0x638c
block|,
literal|0x6400
block|,
literal|0x643c
block|,
literal|0x6500
block|,
literal|0x6524
block|,
literal|0x6a00
block|,
literal|0x6a04
block|,
literal|0x6a14
block|,
literal|0x6a38
block|,
literal|0x6a60
block|,
literal|0x6a70
block|,
literal|0x6a78
block|,
literal|0x6a78
block|,
literal|0x6b00
block|,
literal|0x6b0c
block|,
literal|0x6b1c
block|,
literal|0x6b84
block|,
literal|0x6bf0
block|,
literal|0x6bf8
block|,
literal|0x6c00
block|,
literal|0x6c0c
block|,
literal|0x6c1c
block|,
literal|0x6c84
block|,
literal|0x6cf0
block|,
literal|0x6cf8
block|,
literal|0x6d00
block|,
literal|0x6d0c
block|,
literal|0x6d1c
block|,
literal|0x6d84
block|,
literal|0x6df0
block|,
literal|0x6df8
block|,
literal|0x6e00
block|,
literal|0x6e0c
block|,
literal|0x6e1c
block|,
literal|0x6e84
block|,
literal|0x6ef0
block|,
literal|0x6ef8
block|,
literal|0x6f00
block|,
literal|0x6f0c
block|,
literal|0x6f1c
block|,
literal|0x6f84
block|,
literal|0x6ff0
block|,
literal|0x6ff8
block|,
literal|0x7000
block|,
literal|0x700c
block|,
literal|0x701c
block|,
literal|0x7084
block|,
literal|0x70f0
block|,
literal|0x70f8
block|,
literal|0x7100
block|,
literal|0x710c
block|,
literal|0x711c
block|,
literal|0x7184
block|,
literal|0x71f0
block|,
literal|0x71f8
block|,
literal|0x7200
block|,
literal|0x720c
block|,
literal|0x721c
block|,
literal|0x7284
block|,
literal|0x72f0
block|,
literal|0x72f8
block|,
literal|0x7300
block|,
literal|0x730c
block|,
literal|0x731c
block|,
literal|0x7384
block|,
literal|0x73f0
block|,
literal|0x73f8
block|,
literal|0x7400
block|,
literal|0x7450
block|,
literal|0x7500
block|,
literal|0x7530
block|,
literal|0x7600
block|,
literal|0x760c
block|,
literal|0x7614
block|,
literal|0x761c
block|,
literal|0x7680
block|,
literal|0x76cc
block|,
literal|0x7700
block|,
literal|0x7798
block|,
literal|0x77c0
block|,
literal|0x77fc
block|,
literal|0x7900
block|,
literal|0x79fc
block|,
literal|0x7b00
block|,
literal|0x7b58
block|,
literal|0x7b60
block|,
literal|0x7b84
block|,
literal|0x7b8c
block|,
literal|0x7c38
block|,
literal|0x7d00
block|,
literal|0x7d38
block|,
literal|0x7d40
block|,
literal|0x7d80
block|,
literal|0x7d8c
block|,
literal|0x7ddc
block|,
literal|0x7de4
block|,
literal|0x7e04
block|,
literal|0x7e10
block|,
literal|0x7e1c
block|,
literal|0x7e24
block|,
literal|0x7e38
block|,
literal|0x7e40
block|,
literal|0x7e44
block|,
literal|0x7e4c
block|,
literal|0x7e78
block|,
literal|0x7e80
block|,
literal|0x7ea4
block|,
literal|0x7eac
block|,
literal|0x7edc
block|,
literal|0x7ee8
block|,
literal|0x7efc
block|,
literal|0x8dc0
block|,
literal|0x8e04
block|,
literal|0x8e10
block|,
literal|0x8e1c
block|,
literal|0x8e30
block|,
literal|0x8e78
block|,
literal|0x8ea0
block|,
literal|0x8eb8
block|,
literal|0x8ec0
block|,
literal|0x8f6c
block|,
literal|0x8fc0
block|,
literal|0x9008
block|,
literal|0x9010
block|,
literal|0x9058
block|,
literal|0x9060
block|,
literal|0x9060
block|,
literal|0x9068
block|,
literal|0x9074
block|,
literal|0x90fc
block|,
literal|0x90fc
block|,
literal|0x9400
block|,
literal|0x9408
block|,
literal|0x9410
block|,
literal|0x9458
block|,
literal|0x9600
block|,
literal|0x9600
block|,
literal|0x9608
block|,
literal|0x9638
block|,
literal|0x9640
block|,
literal|0x96bc
block|,
literal|0x9800
block|,
literal|0x9808
block|,
literal|0x9820
block|,
literal|0x983c
block|,
literal|0x9850
block|,
literal|0x9864
block|,
literal|0x9c00
block|,
literal|0x9c6c
block|,
literal|0x9c80
block|,
literal|0x9cec
block|,
literal|0x9d00
block|,
literal|0x9d6c
block|,
literal|0x9d80
block|,
literal|0x9dec
block|,
literal|0x9e00
block|,
literal|0x9e6c
block|,
literal|0x9e80
block|,
literal|0x9eec
block|,
literal|0x9f00
block|,
literal|0x9f6c
block|,
literal|0x9f80
block|,
literal|0x9fec
block|,
literal|0xd004
block|,
literal|0xd004
block|,
literal|0xd010
block|,
literal|0xd03c
block|,
literal|0xdfc0
block|,
literal|0xdfe0
block|,
literal|0xe000
block|,
literal|0xea7c
block|,
literal|0xf000
block|,
literal|0x11110
block|,
literal|0x11118
block|,
literal|0x11190
block|,
literal|0x19040
block|,
literal|0x1906c
block|,
literal|0x19078
block|,
literal|0x19080
block|,
literal|0x1908c
block|,
literal|0x190e4
block|,
literal|0x190f0
block|,
literal|0x190f8
block|,
literal|0x19100
block|,
literal|0x19110
block|,
literal|0x19120
block|,
literal|0x19124
block|,
literal|0x19150
block|,
literal|0x19194
block|,
literal|0x1919c
block|,
literal|0x191b0
block|,
literal|0x191d0
block|,
literal|0x191e8
block|,
literal|0x19238
block|,
literal|0x1924c
block|,
literal|0x193f8
block|,
literal|0x1943c
block|,
literal|0x1944c
block|,
literal|0x19474
block|,
literal|0x19490
block|,
literal|0x194e0
block|,
literal|0x194f0
block|,
literal|0x194f8
block|,
literal|0x19800
block|,
literal|0x19c08
block|,
literal|0x19c10
block|,
literal|0x19c90
block|,
literal|0x19ca0
block|,
literal|0x19ce4
block|,
literal|0x19cf0
block|,
literal|0x19d40
block|,
literal|0x19d50
block|,
literal|0x19d94
block|,
literal|0x19da0
block|,
literal|0x19de8
block|,
literal|0x19df0
block|,
literal|0x19e40
block|,
literal|0x19e50
block|,
literal|0x19e90
block|,
literal|0x19ea0
block|,
literal|0x19f4c
block|,
literal|0x1a000
block|,
literal|0x1a004
block|,
literal|0x1a010
block|,
literal|0x1a06c
block|,
literal|0x1a0b0
block|,
literal|0x1a0e4
block|,
literal|0x1a0ec
block|,
literal|0x1a0f4
block|,
literal|0x1a100
block|,
literal|0x1a108
block|,
literal|0x1a114
block|,
literal|0x1a120
block|,
literal|0x1a128
block|,
literal|0x1a130
block|,
literal|0x1a138
block|,
literal|0x1a138
block|,
literal|0x1a190
block|,
literal|0x1a1c4
block|,
literal|0x1a1fc
block|,
literal|0x1a1fc
block|,
literal|0x1e040
block|,
literal|0x1e04c
block|,
literal|0x1e284
block|,
literal|0x1e28c
block|,
literal|0x1e2c0
block|,
literal|0x1e2c0
block|,
literal|0x1e2e0
block|,
literal|0x1e2e0
block|,
literal|0x1e300
block|,
literal|0x1e384
block|,
literal|0x1e3c0
block|,
literal|0x1e3c8
block|,
literal|0x1e440
block|,
literal|0x1e44c
block|,
literal|0x1e684
block|,
literal|0x1e68c
block|,
literal|0x1e6c0
block|,
literal|0x1e6c0
block|,
literal|0x1e6e0
block|,
literal|0x1e6e0
block|,
literal|0x1e700
block|,
literal|0x1e784
block|,
literal|0x1e7c0
block|,
literal|0x1e7c8
block|,
literal|0x1e840
block|,
literal|0x1e84c
block|,
literal|0x1ea84
block|,
literal|0x1ea8c
block|,
literal|0x1eac0
block|,
literal|0x1eac0
block|,
literal|0x1eae0
block|,
literal|0x1eae0
block|,
literal|0x1eb00
block|,
literal|0x1eb84
block|,
literal|0x1ebc0
block|,
literal|0x1ebc8
block|,
literal|0x1ec40
block|,
literal|0x1ec4c
block|,
literal|0x1ee84
block|,
literal|0x1ee8c
block|,
literal|0x1eec0
block|,
literal|0x1eec0
block|,
literal|0x1eee0
block|,
literal|0x1eee0
block|,
literal|0x1ef00
block|,
literal|0x1ef84
block|,
literal|0x1efc0
block|,
literal|0x1efc8
block|,
literal|0x1f040
block|,
literal|0x1f04c
block|,
literal|0x1f284
block|,
literal|0x1f28c
block|,
literal|0x1f2c0
block|,
literal|0x1f2c0
block|,
literal|0x1f2e0
block|,
literal|0x1f2e0
block|,
literal|0x1f300
block|,
literal|0x1f384
block|,
literal|0x1f3c0
block|,
literal|0x1f3c8
block|,
literal|0x1f440
block|,
literal|0x1f44c
block|,
literal|0x1f684
block|,
literal|0x1f68c
block|,
literal|0x1f6c0
block|,
literal|0x1f6c0
block|,
literal|0x1f6e0
block|,
literal|0x1f6e0
block|,
literal|0x1f700
block|,
literal|0x1f784
block|,
literal|0x1f7c0
block|,
literal|0x1f7c8
block|,
literal|0x1f840
block|,
literal|0x1f84c
block|,
literal|0x1fa84
block|,
literal|0x1fa8c
block|,
literal|0x1fac0
block|,
literal|0x1fac0
block|,
literal|0x1fae0
block|,
literal|0x1fae0
block|,
literal|0x1fb00
block|,
literal|0x1fb84
block|,
literal|0x1fbc0
block|,
literal|0x1fbc8
block|,
literal|0x1fc40
block|,
literal|0x1fc4c
block|,
literal|0x1fe84
block|,
literal|0x1fe8c
block|,
literal|0x1fec0
block|,
literal|0x1fec0
block|,
literal|0x1fee0
block|,
literal|0x1fee0
block|,
literal|0x1ff00
block|,
literal|0x1ff84
block|,
literal|0x1ffc0
block|,
literal|0x1ffc8
block|,
literal|0x20000
block|,
literal|0x2002c
block|,
literal|0x20100
block|,
literal|0x2013c
block|,
literal|0x20190
block|,
literal|0x201a0
block|,
literal|0x201a8
block|,
literal|0x201b8
block|,
literal|0x201c4
block|,
literal|0x201c8
block|,
literal|0x20200
block|,
literal|0x20318
block|,
literal|0x20400
block|,
literal|0x204b4
block|,
literal|0x204c0
block|,
literal|0x20528
block|,
literal|0x20540
block|,
literal|0x20614
block|,
literal|0x21000
block|,
literal|0x21040
block|,
literal|0x2104c
block|,
literal|0x21060
block|,
literal|0x210c0
block|,
literal|0x210ec
block|,
literal|0x21200
block|,
literal|0x21268
block|,
literal|0x21270
block|,
literal|0x21284
block|,
literal|0x212fc
block|,
literal|0x21388
block|,
literal|0x21400
block|,
literal|0x21404
block|,
literal|0x21500
block|,
literal|0x21500
block|,
literal|0x21510
block|,
literal|0x21518
block|,
literal|0x2152c
block|,
literal|0x21530
block|,
literal|0x2153c
block|,
literal|0x2153c
block|,
literal|0x21550
block|,
literal|0x21554
block|,
literal|0x21600
block|,
literal|0x21600
block|,
literal|0x21608
block|,
literal|0x2161c
block|,
literal|0x21624
block|,
literal|0x21628
block|,
literal|0x21630
block|,
literal|0x21634
block|,
literal|0x2163c
block|,
literal|0x2163c
block|,
literal|0x21700
block|,
literal|0x2171c
block|,
literal|0x21780
block|,
literal|0x2178c
block|,
literal|0x21800
block|,
literal|0x21818
block|,
literal|0x21820
block|,
literal|0x21828
block|,
literal|0x21830
block|,
literal|0x21848
block|,
literal|0x21850
block|,
literal|0x21854
block|,
literal|0x21860
block|,
literal|0x21868
block|,
literal|0x21870
block|,
literal|0x21870
block|,
literal|0x21878
block|,
literal|0x21898
block|,
literal|0x218a0
block|,
literal|0x218a8
block|,
literal|0x218b0
block|,
literal|0x218c8
block|,
literal|0x218d0
block|,
literal|0x218d4
block|,
literal|0x218e0
block|,
literal|0x218e8
block|,
literal|0x218f0
block|,
literal|0x218f0
block|,
literal|0x218f8
block|,
literal|0x21a18
block|,
literal|0x21a20
block|,
literal|0x21a28
block|,
literal|0x21a30
block|,
literal|0x21a48
block|,
literal|0x21a50
block|,
literal|0x21a54
block|,
literal|0x21a60
block|,
literal|0x21a68
block|,
literal|0x21a70
block|,
literal|0x21a70
block|,
literal|0x21a78
block|,
literal|0x21a98
block|,
literal|0x21aa0
block|,
literal|0x21aa8
block|,
literal|0x21ab0
block|,
literal|0x21ac8
block|,
literal|0x21ad0
block|,
literal|0x21ad4
block|,
literal|0x21ae0
block|,
literal|0x21ae8
block|,
literal|0x21af0
block|,
literal|0x21af0
block|,
literal|0x21af8
block|,
literal|0x21c18
block|,
literal|0x21c20
block|,
literal|0x21c20
block|,
literal|0x21c28
block|,
literal|0x21c30
block|,
literal|0x21c38
block|,
literal|0x21c38
block|,
literal|0x21c80
block|,
literal|0x21c98
block|,
literal|0x21ca0
block|,
literal|0x21ca8
block|,
literal|0x21cb0
block|,
literal|0x21cc8
block|,
literal|0x21cd0
block|,
literal|0x21cd4
block|,
literal|0x21ce0
block|,
literal|0x21ce8
block|,
literal|0x21cf0
block|,
literal|0x21cf0
block|,
literal|0x21cf8
block|,
literal|0x21d7c
block|,
literal|0x21e00
block|,
literal|0x21e04
block|,
literal|0x22000
block|,
literal|0x2202c
block|,
literal|0x22100
block|,
literal|0x2213c
block|,
literal|0x22190
block|,
literal|0x221a0
block|,
literal|0x221a8
block|,
literal|0x221b8
block|,
literal|0x221c4
block|,
literal|0x221c8
block|,
literal|0x22200
block|,
literal|0x22318
block|,
literal|0x22400
block|,
literal|0x224b4
block|,
literal|0x224c0
block|,
literal|0x22528
block|,
literal|0x22540
block|,
literal|0x22614
block|,
literal|0x23000
block|,
literal|0x23040
block|,
literal|0x2304c
block|,
literal|0x23060
block|,
literal|0x230c0
block|,
literal|0x230ec
block|,
literal|0x23200
block|,
literal|0x23268
block|,
literal|0x23270
block|,
literal|0x23284
block|,
literal|0x232fc
block|,
literal|0x23388
block|,
literal|0x23400
block|,
literal|0x23404
block|,
literal|0x23500
block|,
literal|0x23500
block|,
literal|0x23510
block|,
literal|0x23518
block|,
literal|0x2352c
block|,
literal|0x23530
block|,
literal|0x2353c
block|,
literal|0x2353c
block|,
literal|0x23550
block|,
literal|0x23554
block|,
literal|0x23600
block|,
literal|0x23600
block|,
literal|0x23608
block|,
literal|0x2361c
block|,
literal|0x23624
block|,
literal|0x23628
block|,
literal|0x23630
block|,
literal|0x23634
block|,
literal|0x2363c
block|,
literal|0x2363c
block|,
literal|0x23700
block|,
literal|0x2371c
block|,
literal|0x23780
block|,
literal|0x2378c
block|,
literal|0x23800
block|,
literal|0x23818
block|,
literal|0x23820
block|,
literal|0x23828
block|,
literal|0x23830
block|,
literal|0x23848
block|,
literal|0x23850
block|,
literal|0x23854
block|,
literal|0x23860
block|,
literal|0x23868
block|,
literal|0x23870
block|,
literal|0x23870
block|,
literal|0x23878
block|,
literal|0x23898
block|,
literal|0x238a0
block|,
literal|0x238a8
block|,
literal|0x238b0
block|,
literal|0x238c8
block|,
literal|0x238d0
block|,
literal|0x238d4
block|,
literal|0x238e0
block|,
literal|0x238e8
block|,
literal|0x238f0
block|,
literal|0x238f0
block|,
literal|0x238f8
block|,
literal|0x23a18
block|,
literal|0x23a20
block|,
literal|0x23a28
block|,
literal|0x23a30
block|,
literal|0x23a48
block|,
literal|0x23a50
block|,
literal|0x23a54
block|,
literal|0x23a60
block|,
literal|0x23a68
block|,
literal|0x23a70
block|,
literal|0x23a70
block|,
literal|0x23a78
block|,
literal|0x23a98
block|,
literal|0x23aa0
block|,
literal|0x23aa8
block|,
literal|0x23ab0
block|,
literal|0x23ac8
block|,
literal|0x23ad0
block|,
literal|0x23ad4
block|,
literal|0x23ae0
block|,
literal|0x23ae8
block|,
literal|0x23af0
block|,
literal|0x23af0
block|,
literal|0x23af8
block|,
literal|0x23c18
block|,
literal|0x23c20
block|,
literal|0x23c20
block|,
literal|0x23c28
block|,
literal|0x23c30
block|,
literal|0x23c38
block|,
literal|0x23c38
block|,
literal|0x23c80
block|,
literal|0x23c98
block|,
literal|0x23ca0
block|,
literal|0x23ca8
block|,
literal|0x23cb0
block|,
literal|0x23cc8
block|,
literal|0x23cd0
block|,
literal|0x23cd4
block|,
literal|0x23ce0
block|,
literal|0x23ce8
block|,
literal|0x23cf0
block|,
literal|0x23cf0
block|,
literal|0x23cf8
block|,
literal|0x23d7c
block|,
literal|0x23e00
block|,
literal|0x23e04
block|,
literal|0x24000
block|,
literal|0x2402c
block|,
literal|0x24100
block|,
literal|0x2413c
block|,
literal|0x24190
block|,
literal|0x241a0
block|,
literal|0x241a8
block|,
literal|0x241b8
block|,
literal|0x241c4
block|,
literal|0x241c8
block|,
literal|0x24200
block|,
literal|0x24318
block|,
literal|0x24400
block|,
literal|0x244b4
block|,
literal|0x244c0
block|,
literal|0x24528
block|,
literal|0x24540
block|,
literal|0x24614
block|,
literal|0x25000
block|,
literal|0x25040
block|,
literal|0x2504c
block|,
literal|0x25060
block|,
literal|0x250c0
block|,
literal|0x250ec
block|,
literal|0x25200
block|,
literal|0x25268
block|,
literal|0x25270
block|,
literal|0x25284
block|,
literal|0x252fc
block|,
literal|0x25388
block|,
literal|0x25400
block|,
literal|0x25404
block|,
literal|0x25500
block|,
literal|0x25500
block|,
literal|0x25510
block|,
literal|0x25518
block|,
literal|0x2552c
block|,
literal|0x25530
block|,
literal|0x2553c
block|,
literal|0x2553c
block|,
literal|0x25550
block|,
literal|0x25554
block|,
literal|0x25600
block|,
literal|0x25600
block|,
literal|0x25608
block|,
literal|0x2561c
block|,
literal|0x25624
block|,
literal|0x25628
block|,
literal|0x25630
block|,
literal|0x25634
block|,
literal|0x2563c
block|,
literal|0x2563c
block|,
literal|0x25700
block|,
literal|0x2571c
block|,
literal|0x25780
block|,
literal|0x2578c
block|,
literal|0x25800
block|,
literal|0x25818
block|,
literal|0x25820
block|,
literal|0x25828
block|,
literal|0x25830
block|,
literal|0x25848
block|,
literal|0x25850
block|,
literal|0x25854
block|,
literal|0x25860
block|,
literal|0x25868
block|,
literal|0x25870
block|,
literal|0x25870
block|,
literal|0x25878
block|,
literal|0x25898
block|,
literal|0x258a0
block|,
literal|0x258a8
block|,
literal|0x258b0
block|,
literal|0x258c8
block|,
literal|0x258d0
block|,
literal|0x258d4
block|,
literal|0x258e0
block|,
literal|0x258e8
block|,
literal|0x258f0
block|,
literal|0x258f0
block|,
literal|0x258f8
block|,
literal|0x25a18
block|,
literal|0x25a20
block|,
literal|0x25a28
block|,
literal|0x25a30
block|,
literal|0x25a48
block|,
literal|0x25a50
block|,
literal|0x25a54
block|,
literal|0x25a60
block|,
literal|0x25a68
block|,
literal|0x25a70
block|,
literal|0x25a70
block|,
literal|0x25a78
block|,
literal|0x25a98
block|,
literal|0x25aa0
block|,
literal|0x25aa8
block|,
literal|0x25ab0
block|,
literal|0x25ac8
block|,
literal|0x25ad0
block|,
literal|0x25ad4
block|,
literal|0x25ae0
block|,
literal|0x25ae8
block|,
literal|0x25af0
block|,
literal|0x25af0
block|,
literal|0x25af8
block|,
literal|0x25c18
block|,
literal|0x25c20
block|,
literal|0x25c20
block|,
literal|0x25c28
block|,
literal|0x25c30
block|,
literal|0x25c38
block|,
literal|0x25c38
block|,
literal|0x25c80
block|,
literal|0x25c98
block|,
literal|0x25ca0
block|,
literal|0x25ca8
block|,
literal|0x25cb0
block|,
literal|0x25cc8
block|,
literal|0x25cd0
block|,
literal|0x25cd4
block|,
literal|0x25ce0
block|,
literal|0x25ce8
block|,
literal|0x25cf0
block|,
literal|0x25cf0
block|,
literal|0x25cf8
block|,
literal|0x25d7c
block|,
literal|0x25e00
block|,
literal|0x25e04
block|,
literal|0x26000
block|,
literal|0x2602c
block|,
literal|0x26100
block|,
literal|0x2613c
block|,
literal|0x26190
block|,
literal|0x261a0
block|,
literal|0x261a8
block|,
literal|0x261b8
block|,
literal|0x261c4
block|,
literal|0x261c8
block|,
literal|0x26200
block|,
literal|0x26318
block|,
literal|0x26400
block|,
literal|0x264b4
block|,
literal|0x264c0
block|,
literal|0x26528
block|,
literal|0x26540
block|,
literal|0x26614
block|,
literal|0x27000
block|,
literal|0x27040
block|,
literal|0x2704c
block|,
literal|0x27060
block|,
literal|0x270c0
block|,
literal|0x270ec
block|,
literal|0x27200
block|,
literal|0x27268
block|,
literal|0x27270
block|,
literal|0x27284
block|,
literal|0x272fc
block|,
literal|0x27388
block|,
literal|0x27400
block|,
literal|0x27404
block|,
literal|0x27500
block|,
literal|0x27500
block|,
literal|0x27510
block|,
literal|0x27518
block|,
literal|0x2752c
block|,
literal|0x27530
block|,
literal|0x2753c
block|,
literal|0x2753c
block|,
literal|0x27550
block|,
literal|0x27554
block|,
literal|0x27600
block|,
literal|0x27600
block|,
literal|0x27608
block|,
literal|0x2761c
block|,
literal|0x27624
block|,
literal|0x27628
block|,
literal|0x27630
block|,
literal|0x27634
block|,
literal|0x2763c
block|,
literal|0x2763c
block|,
literal|0x27700
block|,
literal|0x2771c
block|,
literal|0x27780
block|,
literal|0x2778c
block|,
literal|0x27800
block|,
literal|0x27818
block|,
literal|0x27820
block|,
literal|0x27828
block|,
literal|0x27830
block|,
literal|0x27848
block|,
literal|0x27850
block|,
literal|0x27854
block|,
literal|0x27860
block|,
literal|0x27868
block|,
literal|0x27870
block|,
literal|0x27870
block|,
literal|0x27878
block|,
literal|0x27898
block|,
literal|0x278a0
block|,
literal|0x278a8
block|,
literal|0x278b0
block|,
literal|0x278c8
block|,
literal|0x278d0
block|,
literal|0x278d4
block|,
literal|0x278e0
block|,
literal|0x278e8
block|,
literal|0x278f0
block|,
literal|0x278f0
block|,
literal|0x278f8
block|,
literal|0x27a18
block|,
literal|0x27a20
block|,
literal|0x27a28
block|,
literal|0x27a30
block|,
literal|0x27a48
block|,
literal|0x27a50
block|,
literal|0x27a54
block|,
literal|0x27a60
block|,
literal|0x27a68
block|,
literal|0x27a70
block|,
literal|0x27a70
block|,
literal|0x27a78
block|,
literal|0x27a98
block|,
literal|0x27aa0
block|,
literal|0x27aa8
block|,
literal|0x27ab0
block|,
literal|0x27ac8
block|,
literal|0x27ad0
block|,
literal|0x27ad4
block|,
literal|0x27ae0
block|,
literal|0x27ae8
block|,
literal|0x27af0
block|,
literal|0x27af0
block|,
literal|0x27af8
block|,
literal|0x27c18
block|,
literal|0x27c20
block|,
literal|0x27c20
block|,
literal|0x27c28
block|,
literal|0x27c30
block|,
literal|0x27c38
block|,
literal|0x27c38
block|,
literal|0x27c80
block|,
literal|0x27c98
block|,
literal|0x27ca0
block|,
literal|0x27ca8
block|,
literal|0x27cb0
block|,
literal|0x27cc8
block|,
literal|0x27cd0
block|,
literal|0x27cd4
block|,
literal|0x27ce0
block|,
literal|0x27ce8
block|,
literal|0x27cf0
block|,
literal|0x27cf0
block|,
literal|0x27cf8
block|,
literal|0x27d7c
block|,
literal|0x27e00
block|,
literal|0x27e04
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|t4vf_reg_ranges
index|[]
init|=
block|{
name|VF_SGE_REG
argument_list|(
name|A_SGE_VF_KDOORBELL
argument_list|)
block|,
name|VF_SGE_REG
argument_list|(
name|A_SGE_VF_GTS
argument_list|)
block|,
name|VF_MPS_REG
argument_list|(
name|A_MPS_VF_CTL
argument_list|)
block|,
name|VF_MPS_REG
argument_list|(
name|A_MPS_VF_STAT_RX_VF_ERR_FRAMES_H
argument_list|)
block|,
name|VF_PL_REG
argument_list|(
name|A_PL_VF_WHOAMI
argument_list|)
block|,
name|VF_PL_REG
argument_list|(
name|A_PL_VF_WHOAMI
argument_list|)
block|,
name|VF_CIM_REG
argument_list|(
name|A_CIM_VF_EXT_MAILBOX_CTRL
argument_list|)
block|,
name|VF_CIM_REG
argument_list|(
name|A_CIM_VF_EXT_MAILBOX_STATUS
argument_list|)
block|,
name|FW_T4VF_MBDATA_BASE_ADDR
block|,
name|FW_T4VF_MBDATA_BASE_ADDR
operator|+
operator|(
operator|(
name|NUM_CIM_PF_MAILBOX_DATA_INSTANCES
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|t5_reg_ranges
index|[]
init|=
block|{
literal|0x1008
block|,
literal|0x10c0
block|,
literal|0x10cc
block|,
literal|0x10f8
block|,
literal|0x1100
block|,
literal|0x1100
block|,
literal|0x110c
block|,
literal|0x1148
block|,
literal|0x1180
block|,
literal|0x1184
block|,
literal|0x1190
block|,
literal|0x1194
block|,
literal|0x11a0
block|,
literal|0x11a4
block|,
literal|0x11b0
block|,
literal|0x11b4
block|,
literal|0x11fc
block|,
literal|0x123c
block|,
literal|0x1280
block|,
literal|0x173c
block|,
literal|0x1800
block|,
literal|0x18fc
block|,
literal|0x3000
block|,
literal|0x3028
block|,
literal|0x3060
block|,
literal|0x30b0
block|,
literal|0x30b8
block|,
literal|0x30d8
block|,
literal|0x30e0
block|,
literal|0x30fc
block|,
literal|0x3140
block|,
literal|0x357c
block|,
literal|0x35a8
block|,
literal|0x35cc
block|,
literal|0x35ec
block|,
literal|0x35ec
block|,
literal|0x3600
block|,
literal|0x5624
block|,
literal|0x56cc
block|,
literal|0x56ec
block|,
literal|0x56f4
block|,
literal|0x5720
block|,
literal|0x5728
block|,
literal|0x575c
block|,
literal|0x580c
block|,
literal|0x5814
block|,
literal|0x5890
block|,
literal|0x589c
block|,
literal|0x58a4
block|,
literal|0x58ac
block|,
literal|0x58b8
block|,
literal|0x58bc
block|,
literal|0x5940
block|,
literal|0x59c8
block|,
literal|0x59d0
block|,
literal|0x59dc
block|,
literal|0x59fc
block|,
literal|0x5a18
block|,
literal|0x5a60
block|,
literal|0x5a70
block|,
literal|0x5a80
block|,
literal|0x5a9c
block|,
literal|0x5b94
block|,
literal|0x5bfc
block|,
literal|0x6000
block|,
literal|0x6020
block|,
literal|0x6028
block|,
literal|0x6040
block|,
literal|0x6058
block|,
literal|0x609c
block|,
literal|0x60a8
block|,
literal|0x614c
block|,
literal|0x7700
block|,
literal|0x7798
block|,
literal|0x77c0
block|,
literal|0x78fc
block|,
literal|0x7b00
block|,
literal|0x7b58
block|,
literal|0x7b60
block|,
literal|0x7b84
block|,
literal|0x7b8c
block|,
literal|0x7c54
block|,
literal|0x7d00
block|,
literal|0x7d38
block|,
literal|0x7d40
block|,
literal|0x7d80
block|,
literal|0x7d8c
block|,
literal|0x7ddc
block|,
literal|0x7de4
block|,
literal|0x7e04
block|,
literal|0x7e10
block|,
literal|0x7e1c
block|,
literal|0x7e24
block|,
literal|0x7e38
block|,
literal|0x7e40
block|,
literal|0x7e44
block|,
literal|0x7e4c
block|,
literal|0x7e78
block|,
literal|0x7e80
block|,
literal|0x7edc
block|,
literal|0x7ee8
block|,
literal|0x7efc
block|,
literal|0x8dc0
block|,
literal|0x8de0
block|,
literal|0x8df8
block|,
literal|0x8e04
block|,
literal|0x8e10
block|,
literal|0x8e84
block|,
literal|0x8ea0
block|,
literal|0x8f84
block|,
literal|0x8fc0
block|,
literal|0x9058
block|,
literal|0x9060
block|,
literal|0x9060
block|,
literal|0x9068
block|,
literal|0x90f8
block|,
literal|0x9400
block|,
literal|0x9408
block|,
literal|0x9410
block|,
literal|0x9470
block|,
literal|0x9600
block|,
literal|0x9600
block|,
literal|0x9608
block|,
literal|0x9638
block|,
literal|0x9640
block|,
literal|0x96f4
block|,
literal|0x9800
block|,
literal|0x9808
block|,
literal|0x9820
block|,
literal|0x983c
block|,
literal|0x9850
block|,
literal|0x9864
block|,
literal|0x9c00
block|,
literal|0x9c6c
block|,
literal|0x9c80
block|,
literal|0x9cec
block|,
literal|0x9d00
block|,
literal|0x9d6c
block|,
literal|0x9d80
block|,
literal|0x9dec
block|,
literal|0x9e00
block|,
literal|0x9e6c
block|,
literal|0x9e80
block|,
literal|0x9eec
block|,
literal|0x9f00
block|,
literal|0x9f6c
block|,
literal|0x9f80
block|,
literal|0xa020
block|,
literal|0xd004
block|,
literal|0xd004
block|,
literal|0xd010
block|,
literal|0xd03c
block|,
literal|0xdfc0
block|,
literal|0xdfe0
block|,
literal|0xe000
block|,
literal|0x1106c
block|,
literal|0x11074
block|,
literal|0x11088
block|,
literal|0x1109c
block|,
literal|0x1117c
block|,
literal|0x11190
block|,
literal|0x11204
block|,
literal|0x19040
block|,
literal|0x1906c
block|,
literal|0x19078
block|,
literal|0x19080
block|,
literal|0x1908c
block|,
literal|0x190e8
block|,
literal|0x190f0
block|,
literal|0x190f8
block|,
literal|0x19100
block|,
literal|0x19110
block|,
literal|0x19120
block|,
literal|0x19124
block|,
literal|0x19150
block|,
literal|0x19194
block|,
literal|0x1919c
block|,
literal|0x191b0
block|,
literal|0x191d0
block|,
literal|0x191e8
block|,
literal|0x19238
block|,
literal|0x19290
block|,
literal|0x193f8
block|,
literal|0x19428
block|,
literal|0x19430
block|,
literal|0x19444
block|,
literal|0x1944c
block|,
literal|0x1946c
block|,
literal|0x19474
block|,
literal|0x19474
block|,
literal|0x19490
block|,
literal|0x194cc
block|,
literal|0x194f0
block|,
literal|0x194f8
block|,
literal|0x19c00
block|,
literal|0x19c08
block|,
literal|0x19c10
block|,
literal|0x19c60
block|,
literal|0x19c94
block|,
literal|0x19ce4
block|,
literal|0x19cf0
block|,
literal|0x19d40
block|,
literal|0x19d50
block|,
literal|0x19d94
block|,
literal|0x19da0
block|,
literal|0x19de8
block|,
literal|0x19df0
block|,
literal|0x19e10
block|,
literal|0x19e50
block|,
literal|0x19e90
block|,
literal|0x19ea0
block|,
literal|0x19f24
block|,
literal|0x19f34
block|,
literal|0x19f34
block|,
literal|0x19f40
block|,
literal|0x19f50
block|,
literal|0x19f90
block|,
literal|0x19fb4
block|,
literal|0x19fc4
block|,
literal|0x19fe4
block|,
literal|0x1a000
block|,
literal|0x1a004
block|,
literal|0x1a010
block|,
literal|0x1a06c
block|,
literal|0x1a0b0
block|,
literal|0x1a0e4
block|,
literal|0x1a0ec
block|,
literal|0x1a0f8
block|,
literal|0x1a100
block|,
literal|0x1a108
block|,
literal|0x1a114
block|,
literal|0x1a120
block|,
literal|0x1a128
block|,
literal|0x1a130
block|,
literal|0x1a138
block|,
literal|0x1a138
block|,
literal|0x1a190
block|,
literal|0x1a1c4
block|,
literal|0x1a1fc
block|,
literal|0x1a1fc
block|,
literal|0x1e008
block|,
literal|0x1e00c
block|,
literal|0x1e040
block|,
literal|0x1e044
block|,
literal|0x1e04c
block|,
literal|0x1e04c
block|,
literal|0x1e284
block|,
literal|0x1e290
block|,
literal|0x1e2c0
block|,
literal|0x1e2c0
block|,
literal|0x1e2e0
block|,
literal|0x1e2e0
block|,
literal|0x1e300
block|,
literal|0x1e384
block|,
literal|0x1e3c0
block|,
literal|0x1e3c8
block|,
literal|0x1e408
block|,
literal|0x1e40c
block|,
literal|0x1e440
block|,
literal|0x1e444
block|,
literal|0x1e44c
block|,
literal|0x1e44c
block|,
literal|0x1e684
block|,
literal|0x1e690
block|,
literal|0x1e6c0
block|,
literal|0x1e6c0
block|,
literal|0x1e6e0
block|,
literal|0x1e6e0
block|,
literal|0x1e700
block|,
literal|0x1e784
block|,
literal|0x1e7c0
block|,
literal|0x1e7c8
block|,
literal|0x1e808
block|,
literal|0x1e80c
block|,
literal|0x1e840
block|,
literal|0x1e844
block|,
literal|0x1e84c
block|,
literal|0x1e84c
block|,
literal|0x1ea84
block|,
literal|0x1ea90
block|,
literal|0x1eac0
block|,
literal|0x1eac0
block|,
literal|0x1eae0
block|,
literal|0x1eae0
block|,
literal|0x1eb00
block|,
literal|0x1eb84
block|,
literal|0x1ebc0
block|,
literal|0x1ebc8
block|,
literal|0x1ec08
block|,
literal|0x1ec0c
block|,
literal|0x1ec40
block|,
literal|0x1ec44
block|,
literal|0x1ec4c
block|,
literal|0x1ec4c
block|,
literal|0x1ee84
block|,
literal|0x1ee90
block|,
literal|0x1eec0
block|,
literal|0x1eec0
block|,
literal|0x1eee0
block|,
literal|0x1eee0
block|,
literal|0x1ef00
block|,
literal|0x1ef84
block|,
literal|0x1efc0
block|,
literal|0x1efc8
block|,
literal|0x1f008
block|,
literal|0x1f00c
block|,
literal|0x1f040
block|,
literal|0x1f044
block|,
literal|0x1f04c
block|,
literal|0x1f04c
block|,
literal|0x1f284
block|,
literal|0x1f290
block|,
literal|0x1f2c0
block|,
literal|0x1f2c0
block|,
literal|0x1f2e0
block|,
literal|0x1f2e0
block|,
literal|0x1f300
block|,
literal|0x1f384
block|,
literal|0x1f3c0
block|,
literal|0x1f3c8
block|,
literal|0x1f408
block|,
literal|0x1f40c
block|,
literal|0x1f440
block|,
literal|0x1f444
block|,
literal|0x1f44c
block|,
literal|0x1f44c
block|,
literal|0x1f684
block|,
literal|0x1f690
block|,
literal|0x1f6c0
block|,
literal|0x1f6c0
block|,
literal|0x1f6e0
block|,
literal|0x1f6e0
block|,
literal|0x1f700
block|,
literal|0x1f784
block|,
literal|0x1f7c0
block|,
literal|0x1f7c8
block|,
literal|0x1f808
block|,
literal|0x1f80c
block|,
literal|0x1f840
block|,
literal|0x1f844
block|,
literal|0x1f84c
block|,
literal|0x1f84c
block|,
literal|0x1fa84
block|,
literal|0x1fa90
block|,
literal|0x1fac0
block|,
literal|0x1fac0
block|,
literal|0x1fae0
block|,
literal|0x1fae0
block|,
literal|0x1fb00
block|,
literal|0x1fb84
block|,
literal|0x1fbc0
block|,
literal|0x1fbc8
block|,
literal|0x1fc08
block|,
literal|0x1fc0c
block|,
literal|0x1fc40
block|,
literal|0x1fc44
block|,
literal|0x1fc4c
block|,
literal|0x1fc4c
block|,
literal|0x1fe84
block|,
literal|0x1fe90
block|,
literal|0x1fec0
block|,
literal|0x1fec0
block|,
literal|0x1fee0
block|,
literal|0x1fee0
block|,
literal|0x1ff00
block|,
literal|0x1ff84
block|,
literal|0x1ffc0
block|,
literal|0x1ffc8
block|,
literal|0x30000
block|,
literal|0x30030
block|,
literal|0x30100
block|,
literal|0x30144
block|,
literal|0x30190
block|,
literal|0x301a0
block|,
literal|0x301a8
block|,
literal|0x301b8
block|,
literal|0x301c4
block|,
literal|0x301c8
block|,
literal|0x301d0
block|,
literal|0x301d0
block|,
literal|0x30200
block|,
literal|0x30318
block|,
literal|0x30400
block|,
literal|0x304b4
block|,
literal|0x304c0
block|,
literal|0x3052c
block|,
literal|0x30540
block|,
literal|0x3061c
block|,
literal|0x30800
block|,
literal|0x30828
block|,
literal|0x30834
block|,
literal|0x30834
block|,
literal|0x308c0
block|,
literal|0x30908
block|,
literal|0x30910
block|,
literal|0x309ac
block|,
literal|0x30a00
block|,
literal|0x30a14
block|,
literal|0x30a1c
block|,
literal|0x30a2c
block|,
literal|0x30a44
block|,
literal|0x30a50
block|,
literal|0x30a74
block|,
literal|0x30a74
block|,
literal|0x30a7c
block|,
literal|0x30afc
block|,
literal|0x30b08
block|,
literal|0x30c24
block|,
literal|0x30d00
block|,
literal|0x30d00
block|,
literal|0x30d08
block|,
literal|0x30d14
block|,
literal|0x30d1c
block|,
literal|0x30d20
block|,
literal|0x30d3c
block|,
literal|0x30d3c
block|,
literal|0x30d48
block|,
literal|0x30d50
block|,
literal|0x31200
block|,
literal|0x3120c
block|,
literal|0x31220
block|,
literal|0x31220
block|,
literal|0x31240
block|,
literal|0x31240
block|,
literal|0x31600
block|,
literal|0x3160c
block|,
literal|0x31a00
block|,
literal|0x31a1c
block|,
literal|0x31e00
block|,
literal|0x31e20
block|,
literal|0x31e38
block|,
literal|0x31e3c
block|,
literal|0x31e80
block|,
literal|0x31e80
block|,
literal|0x31e88
block|,
literal|0x31ea8
block|,
literal|0x31eb0
block|,
literal|0x31eb4
block|,
literal|0x31ec8
block|,
literal|0x31ed4
block|,
literal|0x31fb8
block|,
literal|0x32004
block|,
literal|0x32200
block|,
literal|0x32200
block|,
literal|0x32208
block|,
literal|0x32240
block|,
literal|0x32248
block|,
literal|0x32280
block|,
literal|0x32288
block|,
literal|0x322c0
block|,
literal|0x322c8
block|,
literal|0x322fc
block|,
literal|0x32600
block|,
literal|0x32630
block|,
literal|0x32a00
block|,
literal|0x32abc
block|,
literal|0x32b00
block|,
literal|0x32b10
block|,
literal|0x32b20
block|,
literal|0x32b30
block|,
literal|0x32b40
block|,
literal|0x32b50
block|,
literal|0x32b60
block|,
literal|0x32b70
block|,
literal|0x33000
block|,
literal|0x33028
block|,
literal|0x33030
block|,
literal|0x33048
block|,
literal|0x33060
block|,
literal|0x33068
block|,
literal|0x33070
block|,
literal|0x3309c
block|,
literal|0x330f0
block|,
literal|0x33128
block|,
literal|0x33130
block|,
literal|0x33148
block|,
literal|0x33160
block|,
literal|0x33168
block|,
literal|0x33170
block|,
literal|0x3319c
block|,
literal|0x331f0
block|,
literal|0x33238
block|,
literal|0x33240
block|,
literal|0x33240
block|,
literal|0x33248
block|,
literal|0x33250
block|,
literal|0x3325c
block|,
literal|0x33264
block|,
literal|0x33270
block|,
literal|0x332b8
block|,
literal|0x332c0
block|,
literal|0x332e4
block|,
literal|0x332f8
block|,
literal|0x33338
block|,
literal|0x33340
block|,
literal|0x33340
block|,
literal|0x33348
block|,
literal|0x33350
block|,
literal|0x3335c
block|,
literal|0x33364
block|,
literal|0x33370
block|,
literal|0x333b8
block|,
literal|0x333c0
block|,
literal|0x333e4
block|,
literal|0x333f8
block|,
literal|0x33428
block|,
literal|0x33430
block|,
literal|0x33448
block|,
literal|0x33460
block|,
literal|0x33468
block|,
literal|0x33470
block|,
literal|0x3349c
block|,
literal|0x334f0
block|,
literal|0x33528
block|,
literal|0x33530
block|,
literal|0x33548
block|,
literal|0x33560
block|,
literal|0x33568
block|,
literal|0x33570
block|,
literal|0x3359c
block|,
literal|0x335f0
block|,
literal|0x33638
block|,
literal|0x33640
block|,
literal|0x33640
block|,
literal|0x33648
block|,
literal|0x33650
block|,
literal|0x3365c
block|,
literal|0x33664
block|,
literal|0x33670
block|,
literal|0x336b8
block|,
literal|0x336c0
block|,
literal|0x336e4
block|,
literal|0x336f8
block|,
literal|0x33738
block|,
literal|0x33740
block|,
literal|0x33740
block|,
literal|0x33748
block|,
literal|0x33750
block|,
literal|0x3375c
block|,
literal|0x33764
block|,
literal|0x33770
block|,
literal|0x337b8
block|,
literal|0x337c0
block|,
literal|0x337e4
block|,
literal|0x337f8
block|,
literal|0x337fc
block|,
literal|0x33814
block|,
literal|0x33814
block|,
literal|0x3382c
block|,
literal|0x3382c
block|,
literal|0x33880
block|,
literal|0x3388c
block|,
literal|0x338e8
block|,
literal|0x338ec
block|,
literal|0x33900
block|,
literal|0x33928
block|,
literal|0x33930
block|,
literal|0x33948
block|,
literal|0x33960
block|,
literal|0x33968
block|,
literal|0x33970
block|,
literal|0x3399c
block|,
literal|0x339f0
block|,
literal|0x33a38
block|,
literal|0x33a40
block|,
literal|0x33a40
block|,
literal|0x33a48
block|,
literal|0x33a50
block|,
literal|0x33a5c
block|,
literal|0x33a64
block|,
literal|0x33a70
block|,
literal|0x33ab8
block|,
literal|0x33ac0
block|,
literal|0x33ae4
block|,
literal|0x33af8
block|,
literal|0x33b10
block|,
literal|0x33b28
block|,
literal|0x33b28
block|,
literal|0x33b3c
block|,
literal|0x33b50
block|,
literal|0x33bf0
block|,
literal|0x33c10
block|,
literal|0x33c28
block|,
literal|0x33c28
block|,
literal|0x33c3c
block|,
literal|0x33c50
block|,
literal|0x33cf0
block|,
literal|0x33cfc
block|,
literal|0x34000
block|,
literal|0x34030
block|,
literal|0x34100
block|,
literal|0x34144
block|,
literal|0x34190
block|,
literal|0x341a0
block|,
literal|0x341a8
block|,
literal|0x341b8
block|,
literal|0x341c4
block|,
literal|0x341c8
block|,
literal|0x341d0
block|,
literal|0x341d0
block|,
literal|0x34200
block|,
literal|0x34318
block|,
literal|0x34400
block|,
literal|0x344b4
block|,
literal|0x344c0
block|,
literal|0x3452c
block|,
literal|0x34540
block|,
literal|0x3461c
block|,
literal|0x34800
block|,
literal|0x34828
block|,
literal|0x34834
block|,
literal|0x34834
block|,
literal|0x348c0
block|,
literal|0x34908
block|,
literal|0x34910
block|,
literal|0x349ac
block|,
literal|0x34a00
block|,
literal|0x34a14
block|,
literal|0x34a1c
block|,
literal|0x34a2c
block|,
literal|0x34a44
block|,
literal|0x34a50
block|,
literal|0x34a74
block|,
literal|0x34a74
block|,
literal|0x34a7c
block|,
literal|0x34afc
block|,
literal|0x34b08
block|,
literal|0x34c24
block|,
literal|0x34d00
block|,
literal|0x34d00
block|,
literal|0x34d08
block|,
literal|0x34d14
block|,
literal|0x34d1c
block|,
literal|0x34d20
block|,
literal|0x34d3c
block|,
literal|0x34d3c
block|,
literal|0x34d48
block|,
literal|0x34d50
block|,
literal|0x35200
block|,
literal|0x3520c
block|,
literal|0x35220
block|,
literal|0x35220
block|,
literal|0x35240
block|,
literal|0x35240
block|,
literal|0x35600
block|,
literal|0x3560c
block|,
literal|0x35a00
block|,
literal|0x35a1c
block|,
literal|0x35e00
block|,
literal|0x35e20
block|,
literal|0x35e38
block|,
literal|0x35e3c
block|,
literal|0x35e80
block|,
literal|0x35e80
block|,
literal|0x35e88
block|,
literal|0x35ea8
block|,
literal|0x35eb0
block|,
literal|0x35eb4
block|,
literal|0x35ec8
block|,
literal|0x35ed4
block|,
literal|0x35fb8
block|,
literal|0x36004
block|,
literal|0x36200
block|,
literal|0x36200
block|,
literal|0x36208
block|,
literal|0x36240
block|,
literal|0x36248
block|,
literal|0x36280
block|,
literal|0x36288
block|,
literal|0x362c0
block|,
literal|0x362c8
block|,
literal|0x362fc
block|,
literal|0x36600
block|,
literal|0x36630
block|,
literal|0x36a00
block|,
literal|0x36abc
block|,
literal|0x36b00
block|,
literal|0x36b10
block|,
literal|0x36b20
block|,
literal|0x36b30
block|,
literal|0x36b40
block|,
literal|0x36b50
block|,
literal|0x36b60
block|,
literal|0x36b70
block|,
literal|0x37000
block|,
literal|0x37028
block|,
literal|0x37030
block|,
literal|0x37048
block|,
literal|0x37060
block|,
literal|0x37068
block|,
literal|0x37070
block|,
literal|0x3709c
block|,
literal|0x370f0
block|,
literal|0x37128
block|,
literal|0x37130
block|,
literal|0x37148
block|,
literal|0x37160
block|,
literal|0x37168
block|,
literal|0x37170
block|,
literal|0x3719c
block|,
literal|0x371f0
block|,
literal|0x37238
block|,
literal|0x37240
block|,
literal|0x37240
block|,
literal|0x37248
block|,
literal|0x37250
block|,
literal|0x3725c
block|,
literal|0x37264
block|,
literal|0x37270
block|,
literal|0x372b8
block|,
literal|0x372c0
block|,
literal|0x372e4
block|,
literal|0x372f8
block|,
literal|0x37338
block|,
literal|0x37340
block|,
literal|0x37340
block|,
literal|0x37348
block|,
literal|0x37350
block|,
literal|0x3735c
block|,
literal|0x37364
block|,
literal|0x37370
block|,
literal|0x373b8
block|,
literal|0x373c0
block|,
literal|0x373e4
block|,
literal|0x373f8
block|,
literal|0x37428
block|,
literal|0x37430
block|,
literal|0x37448
block|,
literal|0x37460
block|,
literal|0x37468
block|,
literal|0x37470
block|,
literal|0x3749c
block|,
literal|0x374f0
block|,
literal|0x37528
block|,
literal|0x37530
block|,
literal|0x37548
block|,
literal|0x37560
block|,
literal|0x37568
block|,
literal|0x37570
block|,
literal|0x3759c
block|,
literal|0x375f0
block|,
literal|0x37638
block|,
literal|0x37640
block|,
literal|0x37640
block|,
literal|0x37648
block|,
literal|0x37650
block|,
literal|0x3765c
block|,
literal|0x37664
block|,
literal|0x37670
block|,
literal|0x376b8
block|,
literal|0x376c0
block|,
literal|0x376e4
block|,
literal|0x376f8
block|,
literal|0x37738
block|,
literal|0x37740
block|,
literal|0x37740
block|,
literal|0x37748
block|,
literal|0x37750
block|,
literal|0x3775c
block|,
literal|0x37764
block|,
literal|0x37770
block|,
literal|0x377b8
block|,
literal|0x377c0
block|,
literal|0x377e4
block|,
literal|0x377f8
block|,
literal|0x377fc
block|,
literal|0x37814
block|,
literal|0x37814
block|,
literal|0x3782c
block|,
literal|0x3782c
block|,
literal|0x37880
block|,
literal|0x3788c
block|,
literal|0x378e8
block|,
literal|0x378ec
block|,
literal|0x37900
block|,
literal|0x37928
block|,
literal|0x37930
block|,
literal|0x37948
block|,
literal|0x37960
block|,
literal|0x37968
block|,
literal|0x37970
block|,
literal|0x3799c
block|,
literal|0x379f0
block|,
literal|0x37a38
block|,
literal|0x37a40
block|,
literal|0x37a40
block|,
literal|0x37a48
block|,
literal|0x37a50
block|,
literal|0x37a5c
block|,
literal|0x37a64
block|,
literal|0x37a70
block|,
literal|0x37ab8
block|,
literal|0x37ac0
block|,
literal|0x37ae4
block|,
literal|0x37af8
block|,
literal|0x37b10
block|,
literal|0x37b28
block|,
literal|0x37b28
block|,
literal|0x37b3c
block|,
literal|0x37b50
block|,
literal|0x37bf0
block|,
literal|0x37c10
block|,
literal|0x37c28
block|,
literal|0x37c28
block|,
literal|0x37c3c
block|,
literal|0x37c50
block|,
literal|0x37cf0
block|,
literal|0x37cfc
block|,
literal|0x38000
block|,
literal|0x38030
block|,
literal|0x38100
block|,
literal|0x38144
block|,
literal|0x38190
block|,
literal|0x381a0
block|,
literal|0x381a8
block|,
literal|0x381b8
block|,
literal|0x381c4
block|,
literal|0x381c8
block|,
literal|0x381d0
block|,
literal|0x381d0
block|,
literal|0x38200
block|,
literal|0x38318
block|,
literal|0x38400
block|,
literal|0x384b4
block|,
literal|0x384c0
block|,
literal|0x3852c
block|,
literal|0x38540
block|,
literal|0x3861c
block|,
literal|0x38800
block|,
literal|0x38828
block|,
literal|0x38834
block|,
literal|0x38834
block|,
literal|0x388c0
block|,
literal|0x38908
block|,
literal|0x38910
block|,
literal|0x389ac
block|,
literal|0x38a00
block|,
literal|0x38a14
block|,
literal|0x38a1c
block|,
literal|0x38a2c
block|,
literal|0x38a44
block|,
literal|0x38a50
block|,
literal|0x38a74
block|,
literal|0x38a74
block|,
literal|0x38a7c
block|,
literal|0x38afc
block|,
literal|0x38b08
block|,
literal|0x38c24
block|,
literal|0x38d00
block|,
literal|0x38d00
block|,
literal|0x38d08
block|,
literal|0x38d14
block|,
literal|0x38d1c
block|,
literal|0x38d20
block|,
literal|0x38d3c
block|,
literal|0x38d3c
block|,
literal|0x38d48
block|,
literal|0x38d50
block|,
literal|0x39200
block|,
literal|0x3920c
block|,
literal|0x39220
block|,
literal|0x39220
block|,
literal|0x39240
block|,
literal|0x39240
block|,
literal|0x39600
block|,
literal|0x3960c
block|,
literal|0x39a00
block|,
literal|0x39a1c
block|,
literal|0x39e00
block|,
literal|0x39e20
block|,
literal|0x39e38
block|,
literal|0x39e3c
block|,
literal|0x39e80
block|,
literal|0x39e80
block|,
literal|0x39e88
block|,
literal|0x39ea8
block|,
literal|0x39eb0
block|,
literal|0x39eb4
block|,
literal|0x39ec8
block|,
literal|0x39ed4
block|,
literal|0x39fb8
block|,
literal|0x3a004
block|,
literal|0x3a200
block|,
literal|0x3a200
block|,
literal|0x3a208
block|,
literal|0x3a240
block|,
literal|0x3a248
block|,
literal|0x3a280
block|,
literal|0x3a288
block|,
literal|0x3a2c0
block|,
literal|0x3a2c8
block|,
literal|0x3a2fc
block|,
literal|0x3a600
block|,
literal|0x3a630
block|,
literal|0x3aa00
block|,
literal|0x3aabc
block|,
literal|0x3ab00
block|,
literal|0x3ab10
block|,
literal|0x3ab20
block|,
literal|0x3ab30
block|,
literal|0x3ab40
block|,
literal|0x3ab50
block|,
literal|0x3ab60
block|,
literal|0x3ab70
block|,
literal|0x3b000
block|,
literal|0x3b028
block|,
literal|0x3b030
block|,
literal|0x3b048
block|,
literal|0x3b060
block|,
literal|0x3b068
block|,
literal|0x3b070
block|,
literal|0x3b09c
block|,
literal|0x3b0f0
block|,
literal|0x3b128
block|,
literal|0x3b130
block|,
literal|0x3b148
block|,
literal|0x3b160
block|,
literal|0x3b168
block|,
literal|0x3b170
block|,
literal|0x3b19c
block|,
literal|0x3b1f0
block|,
literal|0x3b238
block|,
literal|0x3b240
block|,
literal|0x3b240
block|,
literal|0x3b248
block|,
literal|0x3b250
block|,
literal|0x3b25c
block|,
literal|0x3b264
block|,
literal|0x3b270
block|,
literal|0x3b2b8
block|,
literal|0x3b2c0
block|,
literal|0x3b2e4
block|,
literal|0x3b2f8
block|,
literal|0x3b338
block|,
literal|0x3b340
block|,
literal|0x3b340
block|,
literal|0x3b348
block|,
literal|0x3b350
block|,
literal|0x3b35c
block|,
literal|0x3b364
block|,
literal|0x3b370
block|,
literal|0x3b3b8
block|,
literal|0x3b3c0
block|,
literal|0x3b3e4
block|,
literal|0x3b3f8
block|,
literal|0x3b428
block|,
literal|0x3b430
block|,
literal|0x3b448
block|,
literal|0x3b460
block|,
literal|0x3b468
block|,
literal|0x3b470
block|,
literal|0x3b49c
block|,
literal|0x3b4f0
block|,
literal|0x3b528
block|,
literal|0x3b530
block|,
literal|0x3b548
block|,
literal|0x3b560
block|,
literal|0x3b568
block|,
literal|0x3b570
block|,
literal|0x3b59c
block|,
literal|0x3b5f0
block|,
literal|0x3b638
block|,
literal|0x3b640
block|,
literal|0x3b640
block|,
literal|0x3b648
block|,
literal|0x3b650
block|,
literal|0x3b65c
block|,
literal|0x3b664
block|,
literal|0x3b670
block|,
literal|0x3b6b8
block|,
literal|0x3b6c0
block|,
literal|0x3b6e4
block|,
literal|0x3b6f8
block|,
literal|0x3b738
block|,
literal|0x3b740
block|,
literal|0x3b740
block|,
literal|0x3b748
block|,
literal|0x3b750
block|,
literal|0x3b75c
block|,
literal|0x3b764
block|,
literal|0x3b770
block|,
literal|0x3b7b8
block|,
literal|0x3b7c0
block|,
literal|0x3b7e4
block|,
literal|0x3b7f8
block|,
literal|0x3b7fc
block|,
literal|0x3b814
block|,
literal|0x3b814
block|,
literal|0x3b82c
block|,
literal|0x3b82c
block|,
literal|0x3b880
block|,
literal|0x3b88c
block|,
literal|0x3b8e8
block|,
literal|0x3b8ec
block|,
literal|0x3b900
block|,
literal|0x3b928
block|,
literal|0x3b930
block|,
literal|0x3b948
block|,
literal|0x3b960
block|,
literal|0x3b968
block|,
literal|0x3b970
block|,
literal|0x3b99c
block|,
literal|0x3b9f0
block|,
literal|0x3ba38
block|,
literal|0x3ba40
block|,
literal|0x3ba40
block|,
literal|0x3ba48
block|,
literal|0x3ba50
block|,
literal|0x3ba5c
block|,
literal|0x3ba64
block|,
literal|0x3ba70
block|,
literal|0x3bab8
block|,
literal|0x3bac0
block|,
literal|0x3bae4
block|,
literal|0x3baf8
block|,
literal|0x3bb10
block|,
literal|0x3bb28
block|,
literal|0x3bb28
block|,
literal|0x3bb3c
block|,
literal|0x3bb50
block|,
literal|0x3bbf0
block|,
literal|0x3bc10
block|,
literal|0x3bc28
block|,
literal|0x3bc28
block|,
literal|0x3bc3c
block|,
literal|0x3bc50
block|,
literal|0x3bcf0
block|,
literal|0x3bcfc
block|,
literal|0x3c000
block|,
literal|0x3c030
block|,
literal|0x3c100
block|,
literal|0x3c144
block|,
literal|0x3c190
block|,
literal|0x3c1a0
block|,
literal|0x3c1a8
block|,
literal|0x3c1b8
block|,
literal|0x3c1c4
block|,
literal|0x3c1c8
block|,
literal|0x3c1d0
block|,
literal|0x3c1d0
block|,
literal|0x3c200
block|,
literal|0x3c318
block|,
literal|0x3c400
block|,
literal|0x3c4b4
block|,
literal|0x3c4c0
block|,
literal|0x3c52c
block|,
literal|0x3c540
block|,
literal|0x3c61c
block|,
literal|0x3c800
block|,
literal|0x3c828
block|,
literal|0x3c834
block|,
literal|0x3c834
block|,
literal|0x3c8c0
block|,
literal|0x3c908
block|,
literal|0x3c910
block|,
literal|0x3c9ac
block|,
literal|0x3ca00
block|,
literal|0x3ca14
block|,
literal|0x3ca1c
block|,
literal|0x3ca2c
block|,
literal|0x3ca44
block|,
literal|0x3ca50
block|,
literal|0x3ca74
block|,
literal|0x3ca74
block|,
literal|0x3ca7c
block|,
literal|0x3cafc
block|,
literal|0x3cb08
block|,
literal|0x3cc24
block|,
literal|0x3cd00
block|,
literal|0x3cd00
block|,
literal|0x3cd08
block|,
literal|0x3cd14
block|,
literal|0x3cd1c
block|,
literal|0x3cd20
block|,
literal|0x3cd3c
block|,
literal|0x3cd3c
block|,
literal|0x3cd48
block|,
literal|0x3cd50
block|,
literal|0x3d200
block|,
literal|0x3d20c
block|,
literal|0x3d220
block|,
literal|0x3d220
block|,
literal|0x3d240
block|,
literal|0x3d240
block|,
literal|0x3d600
block|,
literal|0x3d60c
block|,
literal|0x3da00
block|,
literal|0x3da1c
block|,
literal|0x3de00
block|,
literal|0x3de20
block|,
literal|0x3de38
block|,
literal|0x3de3c
block|,
literal|0x3de80
block|,
literal|0x3de80
block|,
literal|0x3de88
block|,
literal|0x3dea8
block|,
literal|0x3deb0
block|,
literal|0x3deb4
block|,
literal|0x3dec8
block|,
literal|0x3ded4
block|,
literal|0x3dfb8
block|,
literal|0x3e004
block|,
literal|0x3e200
block|,
literal|0x3e200
block|,
literal|0x3e208
block|,
literal|0x3e240
block|,
literal|0x3e248
block|,
literal|0x3e280
block|,
literal|0x3e288
block|,
literal|0x3e2c0
block|,
literal|0x3e2c8
block|,
literal|0x3e2fc
block|,
literal|0x3e600
block|,
literal|0x3e630
block|,
literal|0x3ea00
block|,
literal|0x3eabc
block|,
literal|0x3eb00
block|,
literal|0x3eb10
block|,
literal|0x3eb20
block|,
literal|0x3eb30
block|,
literal|0x3eb40
block|,
literal|0x3eb50
block|,
literal|0x3eb60
block|,
literal|0x3eb70
block|,
literal|0x3f000
block|,
literal|0x3f028
block|,
literal|0x3f030
block|,
literal|0x3f048
block|,
literal|0x3f060
block|,
literal|0x3f068
block|,
literal|0x3f070
block|,
literal|0x3f09c
block|,
literal|0x3f0f0
block|,
literal|0x3f128
block|,
literal|0x3f130
block|,
literal|0x3f148
block|,
literal|0x3f160
block|,
literal|0x3f168
block|,
literal|0x3f170
block|,
literal|0x3f19c
block|,
literal|0x3f1f0
block|,
literal|0x3f238
block|,
literal|0x3f240
block|,
literal|0x3f240
block|,
literal|0x3f248
block|,
literal|0x3f250
block|,
literal|0x3f25c
block|,
literal|0x3f264
block|,
literal|0x3f270
block|,
literal|0x3f2b8
block|,
literal|0x3f2c0
block|,
literal|0x3f2e4
block|,
literal|0x3f2f8
block|,
literal|0x3f338
block|,
literal|0x3f340
block|,
literal|0x3f340
block|,
literal|0x3f348
block|,
literal|0x3f350
block|,
literal|0x3f35c
block|,
literal|0x3f364
block|,
literal|0x3f370
block|,
literal|0x3f3b8
block|,
literal|0x3f3c0
block|,
literal|0x3f3e4
block|,
literal|0x3f3f8
block|,
literal|0x3f428
block|,
literal|0x3f430
block|,
literal|0x3f448
block|,
literal|0x3f460
block|,
literal|0x3f468
block|,
literal|0x3f470
block|,
literal|0x3f49c
block|,
literal|0x3f4f0
block|,
literal|0x3f528
block|,
literal|0x3f530
block|,
literal|0x3f548
block|,
literal|0x3f560
block|,
literal|0x3f568
block|,
literal|0x3f570
block|,
literal|0x3f59c
block|,
literal|0x3f5f0
block|,
literal|0x3f638
block|,
literal|0x3f640
block|,
literal|0x3f640
block|,
literal|0x3f648
block|,
literal|0x3f650
block|,
literal|0x3f65c
block|,
literal|0x3f664
block|,
literal|0x3f670
block|,
literal|0x3f6b8
block|,
literal|0x3f6c0
block|,
literal|0x3f6e4
block|,
literal|0x3f6f8
block|,
literal|0x3f738
block|,
literal|0x3f740
block|,
literal|0x3f740
block|,
literal|0x3f748
block|,
literal|0x3f750
block|,
literal|0x3f75c
block|,
literal|0x3f764
block|,
literal|0x3f770
block|,
literal|0x3f7b8
block|,
literal|0x3f7c0
block|,
literal|0x3f7e4
block|,
literal|0x3f7f8
block|,
literal|0x3f7fc
block|,
literal|0x3f814
block|,
literal|0x3f814
block|,
literal|0x3f82c
block|,
literal|0x3f82c
block|,
literal|0x3f880
block|,
literal|0x3f88c
block|,
literal|0x3f8e8
block|,
literal|0x3f8ec
block|,
literal|0x3f900
block|,
literal|0x3f928
block|,
literal|0x3f930
block|,
literal|0x3f948
block|,
literal|0x3f960
block|,
literal|0x3f968
block|,
literal|0x3f970
block|,
literal|0x3f99c
block|,
literal|0x3f9f0
block|,
literal|0x3fa38
block|,
literal|0x3fa40
block|,
literal|0x3fa40
block|,
literal|0x3fa48
block|,
literal|0x3fa50
block|,
literal|0x3fa5c
block|,
literal|0x3fa64
block|,
literal|0x3fa70
block|,
literal|0x3fab8
block|,
literal|0x3fac0
block|,
literal|0x3fae4
block|,
literal|0x3faf8
block|,
literal|0x3fb10
block|,
literal|0x3fb28
block|,
literal|0x3fb28
block|,
literal|0x3fb3c
block|,
literal|0x3fb50
block|,
literal|0x3fbf0
block|,
literal|0x3fc10
block|,
literal|0x3fc28
block|,
literal|0x3fc28
block|,
literal|0x3fc3c
block|,
literal|0x3fc50
block|,
literal|0x3fcf0
block|,
literal|0x3fcfc
block|,
literal|0x40000
block|,
literal|0x4000c
block|,
literal|0x40040
block|,
literal|0x40050
block|,
literal|0x40060
block|,
literal|0x40068
block|,
literal|0x4007c
block|,
literal|0x4008c
block|,
literal|0x40094
block|,
literal|0x400b0
block|,
literal|0x400c0
block|,
literal|0x40144
block|,
literal|0x40180
block|,
literal|0x4018c
block|,
literal|0x40200
block|,
literal|0x40254
block|,
literal|0x40260
block|,
literal|0x40264
block|,
literal|0x40270
block|,
literal|0x40288
block|,
literal|0x40290
block|,
literal|0x40298
block|,
literal|0x402ac
block|,
literal|0x402c8
block|,
literal|0x402d0
block|,
literal|0x402e0
block|,
literal|0x402f0
block|,
literal|0x402f0
block|,
literal|0x40300
block|,
literal|0x4033c
block|,
literal|0x403f8
block|,
literal|0x403fc
block|,
literal|0x41304
block|,
literal|0x413c4
block|,
literal|0x41400
block|,
literal|0x4140c
block|,
literal|0x41414
block|,
literal|0x4141c
block|,
literal|0x41480
block|,
literal|0x414d0
block|,
literal|0x44000
block|,
literal|0x44054
block|,
literal|0x4405c
block|,
literal|0x44078
block|,
literal|0x440c0
block|,
literal|0x44174
block|,
literal|0x44180
block|,
literal|0x441ac
block|,
literal|0x441b4
block|,
literal|0x441b8
block|,
literal|0x441c0
block|,
literal|0x44254
block|,
literal|0x4425c
block|,
literal|0x44278
block|,
literal|0x442c0
block|,
literal|0x44374
block|,
literal|0x44380
block|,
literal|0x443ac
block|,
literal|0x443b4
block|,
literal|0x443b8
block|,
literal|0x443c0
block|,
literal|0x44454
block|,
literal|0x4445c
block|,
literal|0x44478
block|,
literal|0x444c0
block|,
literal|0x44574
block|,
literal|0x44580
block|,
literal|0x445ac
block|,
literal|0x445b4
block|,
literal|0x445b8
block|,
literal|0x445c0
block|,
literal|0x44654
block|,
literal|0x4465c
block|,
literal|0x44678
block|,
literal|0x446c0
block|,
literal|0x44774
block|,
literal|0x44780
block|,
literal|0x447ac
block|,
literal|0x447b4
block|,
literal|0x447b8
block|,
literal|0x447c0
block|,
literal|0x44854
block|,
literal|0x4485c
block|,
literal|0x44878
block|,
literal|0x448c0
block|,
literal|0x44974
block|,
literal|0x44980
block|,
literal|0x449ac
block|,
literal|0x449b4
block|,
literal|0x449b8
block|,
literal|0x449c0
block|,
literal|0x449fc
block|,
literal|0x45000
block|,
literal|0x45004
block|,
literal|0x45010
block|,
literal|0x45030
block|,
literal|0x45040
block|,
literal|0x45060
block|,
literal|0x45068
block|,
literal|0x45068
block|,
literal|0x45080
block|,
literal|0x45084
block|,
literal|0x450a0
block|,
literal|0x450b0
block|,
literal|0x45200
block|,
literal|0x45204
block|,
literal|0x45210
block|,
literal|0x45230
block|,
literal|0x45240
block|,
literal|0x45260
block|,
literal|0x45268
block|,
literal|0x45268
block|,
literal|0x45280
block|,
literal|0x45284
block|,
literal|0x452a0
block|,
literal|0x452b0
block|,
literal|0x460c0
block|,
literal|0x460e4
block|,
literal|0x47000
block|,
literal|0x4703c
block|,
literal|0x47044
block|,
literal|0x4708c
block|,
literal|0x47200
block|,
literal|0x47250
block|,
literal|0x47400
block|,
literal|0x47408
block|,
literal|0x47414
block|,
literal|0x47420
block|,
literal|0x47600
block|,
literal|0x47618
block|,
literal|0x47800
block|,
literal|0x47814
block|,
literal|0x48000
block|,
literal|0x4800c
block|,
literal|0x48040
block|,
literal|0x48050
block|,
literal|0x48060
block|,
literal|0x48068
block|,
literal|0x4807c
block|,
literal|0x4808c
block|,
literal|0x48094
block|,
literal|0x480b0
block|,
literal|0x480c0
block|,
literal|0x48144
block|,
literal|0x48180
block|,
literal|0x4818c
block|,
literal|0x48200
block|,
literal|0x48254
block|,
literal|0x48260
block|,
literal|0x48264
block|,
literal|0x48270
block|,
literal|0x48288
block|,
literal|0x48290
block|,
literal|0x48298
block|,
literal|0x482ac
block|,
literal|0x482c8
block|,
literal|0x482d0
block|,
literal|0x482e0
block|,
literal|0x482f0
block|,
literal|0x482f0
block|,
literal|0x48300
block|,
literal|0x4833c
block|,
literal|0x483f8
block|,
literal|0x483fc
block|,
literal|0x49304
block|,
literal|0x493c4
block|,
literal|0x49400
block|,
literal|0x4940c
block|,
literal|0x49414
block|,
literal|0x4941c
block|,
literal|0x49480
block|,
literal|0x494d0
block|,
literal|0x4c000
block|,
literal|0x4c054
block|,
literal|0x4c05c
block|,
literal|0x4c078
block|,
literal|0x4c0c0
block|,
literal|0x4c174
block|,
literal|0x4c180
block|,
literal|0x4c1ac
block|,
literal|0x4c1b4
block|,
literal|0x4c1b8
block|,
literal|0x4c1c0
block|,
literal|0x4c254
block|,
literal|0x4c25c
block|,
literal|0x4c278
block|,
literal|0x4c2c0
block|,
literal|0x4c374
block|,
literal|0x4c380
block|,
literal|0x4c3ac
block|,
literal|0x4c3b4
block|,
literal|0x4c3b8
block|,
literal|0x4c3c0
block|,
literal|0x4c454
block|,
literal|0x4c45c
block|,
literal|0x4c478
block|,
literal|0x4c4c0
block|,
literal|0x4c574
block|,
literal|0x4c580
block|,
literal|0x4c5ac
block|,
literal|0x4c5b4
block|,
literal|0x4c5b8
block|,
literal|0x4c5c0
block|,
literal|0x4c654
block|,
literal|0x4c65c
block|,
literal|0x4c678
block|,
literal|0x4c6c0
block|,
literal|0x4c774
block|,
literal|0x4c780
block|,
literal|0x4c7ac
block|,
literal|0x4c7b4
block|,
literal|0x4c7b8
block|,
literal|0x4c7c0
block|,
literal|0x4c854
block|,
literal|0x4c85c
block|,
literal|0x4c878
block|,
literal|0x4c8c0
block|,
literal|0x4c974
block|,
literal|0x4c980
block|,
literal|0x4c9ac
block|,
literal|0x4c9b4
block|,
literal|0x4c9b8
block|,
literal|0x4c9c0
block|,
literal|0x4c9fc
block|,
literal|0x4d000
block|,
literal|0x4d004
block|,
literal|0x4d010
block|,
literal|0x4d030
block|,
literal|0x4d040
block|,
literal|0x4d060
block|,
literal|0x4d068
block|,
literal|0x4d068
block|,
literal|0x4d080
block|,
literal|0x4d084
block|,
literal|0x4d0a0
block|,
literal|0x4d0b0
block|,
literal|0x4d200
block|,
literal|0x4d204
block|,
literal|0x4d210
block|,
literal|0x4d230
block|,
literal|0x4d240
block|,
literal|0x4d260
block|,
literal|0x4d268
block|,
literal|0x4d268
block|,
literal|0x4d280
block|,
literal|0x4d284
block|,
literal|0x4d2a0
block|,
literal|0x4d2b0
block|,
literal|0x4e0c0
block|,
literal|0x4e0e4
block|,
literal|0x4f000
block|,
literal|0x4f03c
block|,
literal|0x4f044
block|,
literal|0x4f08c
block|,
literal|0x4f200
block|,
literal|0x4f250
block|,
literal|0x4f400
block|,
literal|0x4f408
block|,
literal|0x4f414
block|,
literal|0x4f420
block|,
literal|0x4f600
block|,
literal|0x4f618
block|,
literal|0x4f800
block|,
literal|0x4f814
block|,
literal|0x50000
block|,
literal|0x50084
block|,
literal|0x50090
block|,
literal|0x500cc
block|,
literal|0x50400
block|,
literal|0x50400
block|,
literal|0x50800
block|,
literal|0x50884
block|,
literal|0x50890
block|,
literal|0x508cc
block|,
literal|0x50c00
block|,
literal|0x50c00
block|,
literal|0x51000
block|,
literal|0x5101c
block|,
literal|0x51300
block|,
literal|0x51308
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|t5vf_reg_ranges
index|[]
init|=
block|{
name|VF_SGE_REG
argument_list|(
name|A_SGE_VF_KDOORBELL
argument_list|)
block|,
name|VF_SGE_REG
argument_list|(
name|A_SGE_VF_GTS
argument_list|)
block|,
name|VF_MPS_REG
argument_list|(
name|A_MPS_VF_CTL
argument_list|)
block|,
name|VF_MPS_REG
argument_list|(
name|A_MPS_VF_STAT_RX_VF_ERR_FRAMES_H
argument_list|)
block|,
name|VF_PL_REG
argument_list|(
name|A_PL_VF_WHOAMI
argument_list|)
block|,
name|VF_PL_REG
argument_list|(
name|A_PL_VF_REVISION
argument_list|)
block|,
name|VF_CIM_REG
argument_list|(
name|A_CIM_VF_EXT_MAILBOX_CTRL
argument_list|)
block|,
name|VF_CIM_REG
argument_list|(
name|A_CIM_VF_EXT_MAILBOX_STATUS
argument_list|)
block|,
name|FW_T4VF_MBDATA_BASE_ADDR
block|,
name|FW_T4VF_MBDATA_BASE_ADDR
operator|+
operator|(
operator|(
name|NUM_CIM_PF_MAILBOX_DATA_INSTANCES
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|t6_reg_ranges
index|[]
init|=
block|{
literal|0x1008
block|,
literal|0x101c
block|,
literal|0x1024
block|,
literal|0x10a8
block|,
literal|0x10b4
block|,
literal|0x10f8
block|,
literal|0x1100
block|,
literal|0x1114
block|,
literal|0x111c
block|,
literal|0x112c
block|,
literal|0x1138
block|,
literal|0x113c
block|,
literal|0x1144
block|,
literal|0x114c
block|,
literal|0x1180
block|,
literal|0x1184
block|,
literal|0x1190
block|,
literal|0x1194
block|,
literal|0x11a0
block|,
literal|0x11a4
block|,
literal|0x11b0
block|,
literal|0x11b4
block|,
literal|0x11fc
block|,
literal|0x1274
block|,
literal|0x1280
block|,
literal|0x133c
block|,
literal|0x1800
block|,
literal|0x18fc
block|,
literal|0x3000
block|,
literal|0x302c
block|,
literal|0x3060
block|,
literal|0x30b0
block|,
literal|0x30b8
block|,
literal|0x30d8
block|,
literal|0x30e0
block|,
literal|0x30fc
block|,
literal|0x3140
block|,
literal|0x357c
block|,
literal|0x35a8
block|,
literal|0x35cc
block|,
literal|0x35ec
block|,
literal|0x35ec
block|,
literal|0x3600
block|,
literal|0x5624
block|,
literal|0x56cc
block|,
literal|0x56ec
block|,
literal|0x56f4
block|,
literal|0x5720
block|,
literal|0x5728
block|,
literal|0x575c
block|,
literal|0x580c
block|,
literal|0x5814
block|,
literal|0x5890
block|,
literal|0x589c
block|,
literal|0x58a4
block|,
literal|0x58ac
block|,
literal|0x58b8
block|,
literal|0x58bc
block|,
literal|0x5940
block|,
literal|0x595c
block|,
literal|0x5980
block|,
literal|0x598c
block|,
literal|0x59b0
block|,
literal|0x59c8
block|,
literal|0x59d0
block|,
literal|0x59dc
block|,
literal|0x59fc
block|,
literal|0x5a18
block|,
literal|0x5a60
block|,
literal|0x5a6c
block|,
literal|0x5a80
block|,
literal|0x5a8c
block|,
literal|0x5a94
block|,
literal|0x5a9c
block|,
literal|0x5b94
block|,
literal|0x5bfc
block|,
literal|0x5c10
block|,
literal|0x5e48
block|,
literal|0x5e50
block|,
literal|0x5e94
block|,
literal|0x5ea0
block|,
literal|0x5eb0
block|,
literal|0x5ec0
block|,
literal|0x5ec0
block|,
literal|0x5ec8
block|,
literal|0x5ed0
block|,
literal|0x5ee0
block|,
literal|0x5ee0
block|,
literal|0x5ef0
block|,
literal|0x5ef0
block|,
literal|0x5f00
block|,
literal|0x5f00
block|,
literal|0x6000
block|,
literal|0x6020
block|,
literal|0x6028
block|,
literal|0x6040
block|,
literal|0x6058
block|,
literal|0x609c
block|,
literal|0x60a8
block|,
literal|0x619c
block|,
literal|0x7700
block|,
literal|0x7798
block|,
literal|0x77c0
block|,
literal|0x7880
block|,
literal|0x78cc
block|,
literal|0x78fc
block|,
literal|0x7b00
block|,
literal|0x7b58
block|,
literal|0x7b60
block|,
literal|0x7b84
block|,
literal|0x7b8c
block|,
literal|0x7c54
block|,
literal|0x7d00
block|,
literal|0x7d38
block|,
literal|0x7d40
block|,
literal|0x7d84
block|,
literal|0x7d8c
block|,
literal|0x7ddc
block|,
literal|0x7de4
block|,
literal|0x7e04
block|,
literal|0x7e10
block|,
literal|0x7e1c
block|,
literal|0x7e24
block|,
literal|0x7e38
block|,
literal|0x7e40
block|,
literal|0x7e44
block|,
literal|0x7e4c
block|,
literal|0x7e78
block|,
literal|0x7e80
block|,
literal|0x7edc
block|,
literal|0x7ee8
block|,
literal|0x7efc
block|,
literal|0x8dc0
block|,
literal|0x8de4
block|,
literal|0x8df8
block|,
literal|0x8e04
block|,
literal|0x8e10
block|,
literal|0x8e84
block|,
literal|0x8ea0
block|,
literal|0x8f88
block|,
literal|0x8fb8
block|,
literal|0x9058
block|,
literal|0x9060
block|,
literal|0x9060
block|,
literal|0x9068
block|,
literal|0x90f8
block|,
literal|0x9100
block|,
literal|0x9124
block|,
literal|0x9400
block|,
literal|0x9470
block|,
literal|0x9600
block|,
literal|0x9600
block|,
literal|0x9608
block|,
literal|0x9638
block|,
literal|0x9640
block|,
literal|0x9704
block|,
literal|0x9710
block|,
literal|0x971c
block|,
literal|0x9800
block|,
literal|0x9808
block|,
literal|0x9820
block|,
literal|0x983c
block|,
literal|0x9850
block|,
literal|0x9864
block|,
literal|0x9c00
block|,
literal|0x9c6c
block|,
literal|0x9c80
block|,
literal|0x9cec
block|,
literal|0x9d00
block|,
literal|0x9d6c
block|,
literal|0x9d80
block|,
literal|0x9dec
block|,
literal|0x9e00
block|,
literal|0x9e6c
block|,
literal|0x9e80
block|,
literal|0x9eec
block|,
literal|0x9f00
block|,
literal|0x9f6c
block|,
literal|0x9f80
block|,
literal|0xa020
block|,
literal|0xd004
block|,
literal|0xd03c
block|,
literal|0xd100
block|,
literal|0xd118
block|,
literal|0xd200
block|,
literal|0xd214
block|,
literal|0xd220
block|,
literal|0xd234
block|,
literal|0xd240
block|,
literal|0xd254
block|,
literal|0xd260
block|,
literal|0xd274
block|,
literal|0xd280
block|,
literal|0xd294
block|,
literal|0xd2a0
block|,
literal|0xd2b4
block|,
literal|0xd2c0
block|,
literal|0xd2d4
block|,
literal|0xd2e0
block|,
literal|0xd2f4
block|,
literal|0xd300
block|,
literal|0xd31c
block|,
literal|0xdfc0
block|,
literal|0xdfe0
block|,
literal|0xe000
block|,
literal|0xf008
block|,
literal|0xf010
block|,
literal|0xf018
block|,
literal|0xf020
block|,
literal|0xf028
block|,
literal|0x11000
block|,
literal|0x11014
block|,
literal|0x11048
block|,
literal|0x1106c
block|,
literal|0x11074
block|,
literal|0x11088
block|,
literal|0x11098
block|,
literal|0x11120
block|,
literal|0x1112c
block|,
literal|0x1117c
block|,
literal|0x11190
block|,
literal|0x112e0
block|,
literal|0x11300
block|,
literal|0x1130c
block|,
literal|0x12000
block|,
literal|0x1206c
block|,
literal|0x19040
block|,
literal|0x1906c
block|,
literal|0x19078
block|,
literal|0x19080
block|,
literal|0x1908c
block|,
literal|0x190e8
block|,
literal|0x190f0
block|,
literal|0x190f8
block|,
literal|0x19100
block|,
literal|0x19110
block|,
literal|0x19120
block|,
literal|0x19124
block|,
literal|0x19150
block|,
literal|0x19194
block|,
literal|0x1919c
block|,
literal|0x191b0
block|,
literal|0x191d0
block|,
literal|0x191e8
block|,
literal|0x19238
block|,
literal|0x19290
block|,
literal|0x192a4
block|,
literal|0x192b0
block|,
literal|0x192bc
block|,
literal|0x192bc
block|,
literal|0x19348
block|,
literal|0x1934c
block|,
literal|0x193f8
block|,
literal|0x19418
block|,
literal|0x19420
block|,
literal|0x19428
block|,
literal|0x19430
block|,
literal|0x19444
block|,
literal|0x1944c
block|,
literal|0x1946c
block|,
literal|0x19474
block|,
literal|0x19474
block|,
literal|0x19490
block|,
literal|0x194cc
block|,
literal|0x194f0
block|,
literal|0x194f8
block|,
literal|0x19c00
block|,
literal|0x19c48
block|,
literal|0x19c50
block|,
literal|0x19c80
block|,
literal|0x19c94
block|,
literal|0x19c98
block|,
literal|0x19ca0
block|,
literal|0x19cbc
block|,
literal|0x19ce4
block|,
literal|0x19ce4
block|,
literal|0x19cf0
block|,
literal|0x19cf8
block|,
literal|0x19d00
block|,
literal|0x19d28
block|,
literal|0x19d50
block|,
literal|0x19d78
block|,
literal|0x19d94
block|,
literal|0x19d98
block|,
literal|0x19da0
block|,
literal|0x19dc8
block|,
literal|0x19df0
block|,
literal|0x19e10
block|,
literal|0x19e50
block|,
literal|0x19e6c
block|,
literal|0x19ea0
block|,
literal|0x19ebc
block|,
literal|0x19ec4
block|,
literal|0x19ef4
block|,
literal|0x19f04
block|,
literal|0x19f2c
block|,
literal|0x19f34
block|,
literal|0x19f34
block|,
literal|0x19f40
block|,
literal|0x19f50
block|,
literal|0x19f90
block|,
literal|0x19fac
block|,
literal|0x19fc4
block|,
literal|0x19fc8
block|,
literal|0x19fd0
block|,
literal|0x19fe4
block|,
literal|0x1a000
block|,
literal|0x1a004
block|,
literal|0x1a010
block|,
literal|0x1a06c
block|,
literal|0x1a0b0
block|,
literal|0x1a0e4
block|,
literal|0x1a0ec
block|,
literal|0x1a0f8
block|,
literal|0x1a100
block|,
literal|0x1a108
block|,
literal|0x1a114
block|,
literal|0x1a120
block|,
literal|0x1a128
block|,
literal|0x1a130
block|,
literal|0x1a138
block|,
literal|0x1a138
block|,
literal|0x1a190
block|,
literal|0x1a1c4
block|,
literal|0x1a1fc
block|,
literal|0x1a1fc
block|,
literal|0x1e008
block|,
literal|0x1e00c
block|,
literal|0x1e040
block|,
literal|0x1e044
block|,
literal|0x1e04c
block|,
literal|0x1e04c
block|,
literal|0x1e284
block|,
literal|0x1e290
block|,
literal|0x1e2c0
block|,
literal|0x1e2c0
block|,
literal|0x1e2e0
block|,
literal|0x1e2e0
block|,
literal|0x1e300
block|,
literal|0x1e384
block|,
literal|0x1e3c0
block|,
literal|0x1e3c8
block|,
literal|0x1e408
block|,
literal|0x1e40c
block|,
literal|0x1e440
block|,
literal|0x1e444
block|,
literal|0x1e44c
block|,
literal|0x1e44c
block|,
literal|0x1e684
block|,
literal|0x1e690
block|,
literal|0x1e6c0
block|,
literal|0x1e6c0
block|,
literal|0x1e6e0
block|,
literal|0x1e6e0
block|,
literal|0x1e700
block|,
literal|0x1e784
block|,
literal|0x1e7c0
block|,
literal|0x1e7c8
block|,
literal|0x1e808
block|,
literal|0x1e80c
block|,
literal|0x1e840
block|,
literal|0x1e844
block|,
literal|0x1e84c
block|,
literal|0x1e84c
block|,
literal|0x1ea84
block|,
literal|0x1ea90
block|,
literal|0x1eac0
block|,
literal|0x1eac0
block|,
literal|0x1eae0
block|,
literal|0x1eae0
block|,
literal|0x1eb00
block|,
literal|0x1eb84
block|,
literal|0x1ebc0
block|,
literal|0x1ebc8
block|,
literal|0x1ec08
block|,
literal|0x1ec0c
block|,
literal|0x1ec40
block|,
literal|0x1ec44
block|,
literal|0x1ec4c
block|,
literal|0x1ec4c
block|,
literal|0x1ee84
block|,
literal|0x1ee90
block|,
literal|0x1eec0
block|,
literal|0x1eec0
block|,
literal|0x1eee0
block|,
literal|0x1eee0
block|,
literal|0x1ef00
block|,
literal|0x1ef84
block|,
literal|0x1efc0
block|,
literal|0x1efc8
block|,
literal|0x1f008
block|,
literal|0x1f00c
block|,
literal|0x1f040
block|,
literal|0x1f044
block|,
literal|0x1f04c
block|,
literal|0x1f04c
block|,
literal|0x1f284
block|,
literal|0x1f290
block|,
literal|0x1f2c0
block|,
literal|0x1f2c0
block|,
literal|0x1f2e0
block|,
literal|0x1f2e0
block|,
literal|0x1f300
block|,
literal|0x1f384
block|,
literal|0x1f3c0
block|,
literal|0x1f3c8
block|,
literal|0x1f408
block|,
literal|0x1f40c
block|,
literal|0x1f440
block|,
literal|0x1f444
block|,
literal|0x1f44c
block|,
literal|0x1f44c
block|,
literal|0x1f684
block|,
literal|0x1f690
block|,
literal|0x1f6c0
block|,
literal|0x1f6c0
block|,
literal|0x1f6e0
block|,
literal|0x1f6e0
block|,
literal|0x1f700
block|,
literal|0x1f784
block|,
literal|0x1f7c0
block|,
literal|0x1f7c8
block|,
literal|0x1f808
block|,
literal|0x1f80c
block|,
literal|0x1f840
block|,
literal|0x1f844
block|,
literal|0x1f84c
block|,
literal|0x1f84c
block|,
literal|0x1fa84
block|,
literal|0x1fa90
block|,
literal|0x1fac0
block|,
literal|0x1fac0
block|,
literal|0x1fae0
block|,
literal|0x1fae0
block|,
literal|0x1fb00
block|,
literal|0x1fb84
block|,
literal|0x1fbc0
block|,
literal|0x1fbc8
block|,
literal|0x1fc08
block|,
literal|0x1fc0c
block|,
literal|0x1fc40
block|,
literal|0x1fc44
block|,
literal|0x1fc4c
block|,
literal|0x1fc4c
block|,
literal|0x1fe84
block|,
literal|0x1fe90
block|,
literal|0x1fec0
block|,
literal|0x1fec0
block|,
literal|0x1fee0
block|,
literal|0x1fee0
block|,
literal|0x1ff00
block|,
literal|0x1ff84
block|,
literal|0x1ffc0
block|,
literal|0x1ffc8
block|,
literal|0x30000
block|,
literal|0x30030
block|,
literal|0x30100
block|,
literal|0x30168
block|,
literal|0x30190
block|,
literal|0x301a0
block|,
literal|0x301a8
block|,
literal|0x301b8
block|,
literal|0x301c4
block|,
literal|0x301c8
block|,
literal|0x301d0
block|,
literal|0x301d0
block|,
literal|0x30200
block|,
literal|0x30320
block|,
literal|0x30400
block|,
literal|0x304b4
block|,
literal|0x304c0
block|,
literal|0x3052c
block|,
literal|0x30540
block|,
literal|0x3061c
block|,
literal|0x30800
block|,
literal|0x308a0
block|,
literal|0x308c0
block|,
literal|0x30908
block|,
literal|0x30910
block|,
literal|0x309b8
block|,
literal|0x30a00
block|,
literal|0x30a04
block|,
literal|0x30a0c
block|,
literal|0x30a14
block|,
literal|0x30a1c
block|,
literal|0x30a2c
block|,
literal|0x30a44
block|,
literal|0x30a50
block|,
literal|0x30a74
block|,
literal|0x30a74
block|,
literal|0x30a7c
block|,
literal|0x30afc
block|,
literal|0x30b08
block|,
literal|0x30c24
block|,
literal|0x30d00
block|,
literal|0x30d14
block|,
literal|0x30d1c
block|,
literal|0x30d3c
block|,
literal|0x30d44
block|,
literal|0x30d4c
block|,
literal|0x30d54
block|,
literal|0x30d74
block|,
literal|0x30d7c
block|,
literal|0x30d7c
block|,
literal|0x30de0
block|,
literal|0x30de0
block|,
literal|0x30e00
block|,
literal|0x30ed4
block|,
literal|0x30f00
block|,
literal|0x30fa4
block|,
literal|0x30fc0
block|,
literal|0x30fc4
block|,
literal|0x31000
block|,
literal|0x31004
block|,
literal|0x31080
block|,
literal|0x310fc
block|,
literal|0x31208
block|,
literal|0x31220
block|,
literal|0x3123c
block|,
literal|0x31254
block|,
literal|0x31300
block|,
literal|0x31300
block|,
literal|0x31308
block|,
literal|0x3131c
block|,
literal|0x31338
block|,
literal|0x3133c
block|,
literal|0x31380
block|,
literal|0x31380
block|,
literal|0x31388
block|,
literal|0x313a8
block|,
literal|0x313b4
block|,
literal|0x313b4
block|,
literal|0x31400
block|,
literal|0x31420
block|,
literal|0x31438
block|,
literal|0x3143c
block|,
literal|0x31480
block|,
literal|0x31480
block|,
literal|0x314a8
block|,
literal|0x314a8
block|,
literal|0x314b0
block|,
literal|0x314b4
block|,
literal|0x314c8
block|,
literal|0x314d4
block|,
literal|0x31a40
block|,
literal|0x31a4c
block|,
literal|0x31af0
block|,
literal|0x31b20
block|,
literal|0x31b38
block|,
literal|0x31b3c
block|,
literal|0x31b80
block|,
literal|0x31b80
block|,
literal|0x31ba8
block|,
literal|0x31ba8
block|,
literal|0x31bb0
block|,
literal|0x31bb4
block|,
literal|0x31bc8
block|,
literal|0x31bd4
block|,
literal|0x32140
block|,
literal|0x3218c
block|,
literal|0x321f0
block|,
literal|0x321f4
block|,
literal|0x32200
block|,
literal|0x32200
block|,
literal|0x32218
block|,
literal|0x32218
block|,
literal|0x32400
block|,
literal|0x32400
block|,
literal|0x32408
block|,
literal|0x3241c
block|,
literal|0x32618
block|,
literal|0x32620
block|,
literal|0x32664
block|,
literal|0x32664
block|,
literal|0x326a8
block|,
literal|0x326a8
block|,
literal|0x326ec
block|,
literal|0x326ec
block|,
literal|0x32a00
block|,
literal|0x32abc
block|,
literal|0x32b00
block|,
literal|0x32b18
block|,
literal|0x32b20
block|,
literal|0x32b38
block|,
literal|0x32b40
block|,
literal|0x32b58
block|,
literal|0x32b60
block|,
literal|0x32b78
block|,
literal|0x32c00
block|,
literal|0x32c00
block|,
literal|0x32c08
block|,
literal|0x32c3c
block|,
literal|0x33000
block|,
literal|0x3302c
block|,
literal|0x33034
block|,
literal|0x33050
block|,
literal|0x33058
block|,
literal|0x33058
block|,
literal|0x33060
block|,
literal|0x3308c
block|,
literal|0x3309c
block|,
literal|0x330ac
block|,
literal|0x330c0
block|,
literal|0x330c0
block|,
literal|0x330c8
block|,
literal|0x330d0
block|,
literal|0x330d8
block|,
literal|0x330e0
block|,
literal|0x330ec
block|,
literal|0x3312c
block|,
literal|0x33134
block|,
literal|0x33150
block|,
literal|0x33158
block|,
literal|0x33158
block|,
literal|0x33160
block|,
literal|0x3318c
block|,
literal|0x3319c
block|,
literal|0x331ac
block|,
literal|0x331c0
block|,
literal|0x331c0
block|,
literal|0x331c8
block|,
literal|0x331d0
block|,
literal|0x331d8
block|,
literal|0x331e0
block|,
literal|0x331ec
block|,
literal|0x33290
block|,
literal|0x33298
block|,
literal|0x332c4
block|,
literal|0x332e4
block|,
literal|0x33390
block|,
literal|0x33398
block|,
literal|0x333c4
block|,
literal|0x333e4
block|,
literal|0x3342c
block|,
literal|0x33434
block|,
literal|0x33450
block|,
literal|0x33458
block|,
literal|0x33458
block|,
literal|0x33460
block|,
literal|0x3348c
block|,
literal|0x3349c
block|,
literal|0x334ac
block|,
literal|0x334c0
block|,
literal|0x334c0
block|,
literal|0x334c8
block|,
literal|0x334d0
block|,
literal|0x334d8
block|,
literal|0x334e0
block|,
literal|0x334ec
block|,
literal|0x3352c
block|,
literal|0x33534
block|,
literal|0x33550
block|,
literal|0x33558
block|,
literal|0x33558
block|,
literal|0x33560
block|,
literal|0x3358c
block|,
literal|0x3359c
block|,
literal|0x335ac
block|,
literal|0x335c0
block|,
literal|0x335c0
block|,
literal|0x335c8
block|,
literal|0x335d0
block|,
literal|0x335d8
block|,
literal|0x335e0
block|,
literal|0x335ec
block|,
literal|0x33690
block|,
literal|0x33698
block|,
literal|0x336c4
block|,
literal|0x336e4
block|,
literal|0x33790
block|,
literal|0x33798
block|,
literal|0x337c4
block|,
literal|0x337e4
block|,
literal|0x337fc
block|,
literal|0x33814
block|,
literal|0x33814
block|,
literal|0x33854
block|,
literal|0x33868
block|,
literal|0x33880
block|,
literal|0x3388c
block|,
literal|0x338c0
block|,
literal|0x338d0
block|,
literal|0x338e8
block|,
literal|0x338ec
block|,
literal|0x33900
block|,
literal|0x3392c
block|,
literal|0x33934
block|,
literal|0x33950
block|,
literal|0x33958
block|,
literal|0x33958
block|,
literal|0x33960
block|,
literal|0x3398c
block|,
literal|0x3399c
block|,
literal|0x339ac
block|,
literal|0x339c0
block|,
literal|0x339c0
block|,
literal|0x339c8
block|,
literal|0x339d0
block|,
literal|0x339d8
block|,
literal|0x339e0
block|,
literal|0x339ec
block|,
literal|0x33a90
block|,
literal|0x33a98
block|,
literal|0x33ac4
block|,
literal|0x33ae4
block|,
literal|0x33b10
block|,
literal|0x33b24
block|,
literal|0x33b28
block|,
literal|0x33b38
block|,
literal|0x33b50
block|,
literal|0x33bf0
block|,
literal|0x33c10
block|,
literal|0x33c24
block|,
literal|0x33c28
block|,
literal|0x33c38
block|,
literal|0x33c50
block|,
literal|0x33cf0
block|,
literal|0x33cfc
block|,
literal|0x34000
block|,
literal|0x34030
block|,
literal|0x34100
block|,
literal|0x34168
block|,
literal|0x34190
block|,
literal|0x341a0
block|,
literal|0x341a8
block|,
literal|0x341b8
block|,
literal|0x341c4
block|,
literal|0x341c8
block|,
literal|0x341d0
block|,
literal|0x341d0
block|,
literal|0x34200
block|,
literal|0x34320
block|,
literal|0x34400
block|,
literal|0x344b4
block|,
literal|0x344c0
block|,
literal|0x3452c
block|,
literal|0x34540
block|,
literal|0x3461c
block|,
literal|0x34800
block|,
literal|0x348a0
block|,
literal|0x348c0
block|,
literal|0x34908
block|,
literal|0x34910
block|,
literal|0x349b8
block|,
literal|0x34a00
block|,
literal|0x34a04
block|,
literal|0x34a0c
block|,
literal|0x34a14
block|,
literal|0x34a1c
block|,
literal|0x34a2c
block|,
literal|0x34a44
block|,
literal|0x34a50
block|,
literal|0x34a74
block|,
literal|0x34a74
block|,
literal|0x34a7c
block|,
literal|0x34afc
block|,
literal|0x34b08
block|,
literal|0x34c24
block|,
literal|0x34d00
block|,
literal|0x34d14
block|,
literal|0x34d1c
block|,
literal|0x34d3c
block|,
literal|0x34d44
block|,
literal|0x34d4c
block|,
literal|0x34d54
block|,
literal|0x34d74
block|,
literal|0x34d7c
block|,
literal|0x34d7c
block|,
literal|0x34de0
block|,
literal|0x34de0
block|,
literal|0x34e00
block|,
literal|0x34ed4
block|,
literal|0x34f00
block|,
literal|0x34fa4
block|,
literal|0x34fc0
block|,
literal|0x34fc4
block|,
literal|0x35000
block|,
literal|0x35004
block|,
literal|0x35080
block|,
literal|0x350fc
block|,
literal|0x35208
block|,
literal|0x35220
block|,
literal|0x3523c
block|,
literal|0x35254
block|,
literal|0x35300
block|,
literal|0x35300
block|,
literal|0x35308
block|,
literal|0x3531c
block|,
literal|0x35338
block|,
literal|0x3533c
block|,
literal|0x35380
block|,
literal|0x35380
block|,
literal|0x35388
block|,
literal|0x353a8
block|,
literal|0x353b4
block|,
literal|0x353b4
block|,
literal|0x35400
block|,
literal|0x35420
block|,
literal|0x35438
block|,
literal|0x3543c
block|,
literal|0x35480
block|,
literal|0x35480
block|,
literal|0x354a8
block|,
literal|0x354a8
block|,
literal|0x354b0
block|,
literal|0x354b4
block|,
literal|0x354c8
block|,
literal|0x354d4
block|,
literal|0x35a40
block|,
literal|0x35a4c
block|,
literal|0x35af0
block|,
literal|0x35b20
block|,
literal|0x35b38
block|,
literal|0x35b3c
block|,
literal|0x35b80
block|,
literal|0x35b80
block|,
literal|0x35ba8
block|,
literal|0x35ba8
block|,
literal|0x35bb0
block|,
literal|0x35bb4
block|,
literal|0x35bc8
block|,
literal|0x35bd4
block|,
literal|0x36140
block|,
literal|0x3618c
block|,
literal|0x361f0
block|,
literal|0x361f4
block|,
literal|0x36200
block|,
literal|0x36200
block|,
literal|0x36218
block|,
literal|0x36218
block|,
literal|0x36400
block|,
literal|0x36400
block|,
literal|0x36408
block|,
literal|0x3641c
block|,
literal|0x36618
block|,
literal|0x36620
block|,
literal|0x36664
block|,
literal|0x36664
block|,
literal|0x366a8
block|,
literal|0x366a8
block|,
literal|0x366ec
block|,
literal|0x366ec
block|,
literal|0x36a00
block|,
literal|0x36abc
block|,
literal|0x36b00
block|,
literal|0x36b18
block|,
literal|0x36b20
block|,
literal|0x36b38
block|,
literal|0x36b40
block|,
literal|0x36b58
block|,
literal|0x36b60
block|,
literal|0x36b78
block|,
literal|0x36c00
block|,
literal|0x36c00
block|,
literal|0x36c08
block|,
literal|0x36c3c
block|,
literal|0x37000
block|,
literal|0x3702c
block|,
literal|0x37034
block|,
literal|0x37050
block|,
literal|0x37058
block|,
literal|0x37058
block|,
literal|0x37060
block|,
literal|0x3708c
block|,
literal|0x3709c
block|,
literal|0x370ac
block|,
literal|0x370c0
block|,
literal|0x370c0
block|,
literal|0x370c8
block|,
literal|0x370d0
block|,
literal|0x370d8
block|,
literal|0x370e0
block|,
literal|0x370ec
block|,
literal|0x3712c
block|,
literal|0x37134
block|,
literal|0x37150
block|,
literal|0x37158
block|,
literal|0x37158
block|,
literal|0x37160
block|,
literal|0x3718c
block|,
literal|0x3719c
block|,
literal|0x371ac
block|,
literal|0x371c0
block|,
literal|0x371c0
block|,
literal|0x371c8
block|,
literal|0x371d0
block|,
literal|0x371d8
block|,
literal|0x371e0
block|,
literal|0x371ec
block|,
literal|0x37290
block|,
literal|0x37298
block|,
literal|0x372c4
block|,
literal|0x372e4
block|,
literal|0x37390
block|,
literal|0x37398
block|,
literal|0x373c4
block|,
literal|0x373e4
block|,
literal|0x3742c
block|,
literal|0x37434
block|,
literal|0x37450
block|,
literal|0x37458
block|,
literal|0x37458
block|,
literal|0x37460
block|,
literal|0x3748c
block|,
literal|0x3749c
block|,
literal|0x374ac
block|,
literal|0x374c0
block|,
literal|0x374c0
block|,
literal|0x374c8
block|,
literal|0x374d0
block|,
literal|0x374d8
block|,
literal|0x374e0
block|,
literal|0x374ec
block|,
literal|0x3752c
block|,
literal|0x37534
block|,
literal|0x37550
block|,
literal|0x37558
block|,
literal|0x37558
block|,
literal|0x37560
block|,
literal|0x3758c
block|,
literal|0x3759c
block|,
literal|0x375ac
block|,
literal|0x375c0
block|,
literal|0x375c0
block|,
literal|0x375c8
block|,
literal|0x375d0
block|,
literal|0x375d8
block|,
literal|0x375e0
block|,
literal|0x375ec
block|,
literal|0x37690
block|,
literal|0x37698
block|,
literal|0x376c4
block|,
literal|0x376e4
block|,
literal|0x37790
block|,
literal|0x37798
block|,
literal|0x377c4
block|,
literal|0x377e4
block|,
literal|0x377fc
block|,
literal|0x37814
block|,
literal|0x37814
block|,
literal|0x37854
block|,
literal|0x37868
block|,
literal|0x37880
block|,
literal|0x3788c
block|,
literal|0x378c0
block|,
literal|0x378d0
block|,
literal|0x378e8
block|,
literal|0x378ec
block|,
literal|0x37900
block|,
literal|0x3792c
block|,
literal|0x37934
block|,
literal|0x37950
block|,
literal|0x37958
block|,
literal|0x37958
block|,
literal|0x37960
block|,
literal|0x3798c
block|,
literal|0x3799c
block|,
literal|0x379ac
block|,
literal|0x379c0
block|,
literal|0x379c0
block|,
literal|0x379c8
block|,
literal|0x379d0
block|,
literal|0x379d8
block|,
literal|0x379e0
block|,
literal|0x379ec
block|,
literal|0x37a90
block|,
literal|0x37a98
block|,
literal|0x37ac4
block|,
literal|0x37ae4
block|,
literal|0x37b10
block|,
literal|0x37b24
block|,
literal|0x37b28
block|,
literal|0x37b38
block|,
literal|0x37b50
block|,
literal|0x37bf0
block|,
literal|0x37c10
block|,
literal|0x37c24
block|,
literal|0x37c28
block|,
literal|0x37c38
block|,
literal|0x37c50
block|,
literal|0x37cf0
block|,
literal|0x37cfc
block|,
literal|0x40040
block|,
literal|0x40040
block|,
literal|0x40080
block|,
literal|0x40084
block|,
literal|0x40100
block|,
literal|0x40100
block|,
literal|0x40140
block|,
literal|0x401bc
block|,
literal|0x40200
block|,
literal|0x40214
block|,
literal|0x40228
block|,
literal|0x40228
block|,
literal|0x40240
block|,
literal|0x40258
block|,
literal|0x40280
block|,
literal|0x40280
block|,
literal|0x40304
block|,
literal|0x40304
block|,
literal|0x40330
block|,
literal|0x4033c
block|,
literal|0x41304
block|,
literal|0x413c8
block|,
literal|0x413d0
block|,
literal|0x413dc
block|,
literal|0x413f0
block|,
literal|0x413f0
block|,
literal|0x41400
block|,
literal|0x4140c
block|,
literal|0x41414
block|,
literal|0x4141c
block|,
literal|0x41480
block|,
literal|0x414d0
block|,
literal|0x44000
block|,
literal|0x4407c
block|,
literal|0x440c0
block|,
literal|0x441ac
block|,
literal|0x441b4
block|,
literal|0x4427c
block|,
literal|0x442c0
block|,
literal|0x443ac
block|,
literal|0x443b4
block|,
literal|0x4447c
block|,
literal|0x444c0
block|,
literal|0x445ac
block|,
literal|0x445b4
block|,
literal|0x4467c
block|,
literal|0x446c0
block|,
literal|0x447ac
block|,
literal|0x447b4
block|,
literal|0x4487c
block|,
literal|0x448c0
block|,
literal|0x449ac
block|,
literal|0x449b4
block|,
literal|0x44a7c
block|,
literal|0x44ac0
block|,
literal|0x44bac
block|,
literal|0x44bb4
block|,
literal|0x44c7c
block|,
literal|0x44cc0
block|,
literal|0x44dac
block|,
literal|0x44db4
block|,
literal|0x44e7c
block|,
literal|0x44ec0
block|,
literal|0x44fac
block|,
literal|0x44fb4
block|,
literal|0x4507c
block|,
literal|0x450c0
block|,
literal|0x451ac
block|,
literal|0x451b4
block|,
literal|0x451fc
block|,
literal|0x45800
block|,
literal|0x45804
block|,
literal|0x45810
block|,
literal|0x45830
block|,
literal|0x45840
block|,
literal|0x45860
block|,
literal|0x45868
block|,
literal|0x45868
block|,
literal|0x45880
block|,
literal|0x45884
block|,
literal|0x458a0
block|,
literal|0x458b0
block|,
literal|0x45a00
block|,
literal|0x45a04
block|,
literal|0x45a10
block|,
literal|0x45a30
block|,
literal|0x45a40
block|,
literal|0x45a60
block|,
literal|0x45a68
block|,
literal|0x45a68
block|,
literal|0x45a80
block|,
literal|0x45a84
block|,
literal|0x45aa0
block|,
literal|0x45ab0
block|,
literal|0x460c0
block|,
literal|0x460e4
block|,
literal|0x47000
block|,
literal|0x4703c
block|,
literal|0x47044
block|,
literal|0x4708c
block|,
literal|0x47200
block|,
literal|0x47250
block|,
literal|0x47400
block|,
literal|0x47408
block|,
literal|0x47414
block|,
literal|0x47420
block|,
literal|0x47600
block|,
literal|0x47618
block|,
literal|0x47800
block|,
literal|0x47814
block|,
literal|0x47820
block|,
literal|0x4782c
block|,
literal|0x50000
block|,
literal|0x50084
block|,
literal|0x50090
block|,
literal|0x500cc
block|,
literal|0x50300
block|,
literal|0x50384
block|,
literal|0x50400
block|,
literal|0x50400
block|,
literal|0x50800
block|,
literal|0x50884
block|,
literal|0x50890
block|,
literal|0x508cc
block|,
literal|0x50b00
block|,
literal|0x50b84
block|,
literal|0x50c00
block|,
literal|0x50c00
block|,
literal|0x51000
block|,
literal|0x51020
block|,
literal|0x51028
block|,
literal|0x510b0
block|,
literal|0x51300
block|,
literal|0x51324
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|t6vf_reg_ranges
index|[]
init|=
block|{
name|VF_SGE_REG
argument_list|(
name|A_SGE_VF_KDOORBELL
argument_list|)
block|,
name|VF_SGE_REG
argument_list|(
name|A_SGE_VF_GTS
argument_list|)
block|,
name|VF_MPS_REG
argument_list|(
name|A_MPS_VF_CTL
argument_list|)
block|,
name|VF_MPS_REG
argument_list|(
name|A_MPS_VF_STAT_RX_VF_ERR_FRAMES_H
argument_list|)
block|,
name|VF_PL_REG
argument_list|(
name|A_PL_VF_WHOAMI
argument_list|)
block|,
name|VF_PL_REG
argument_list|(
name|A_PL_VF_REVISION
argument_list|)
block|,
name|VF_CIM_REG
argument_list|(
name|A_CIM_VF_EXT_MAILBOX_CTRL
argument_list|)
block|,
name|VF_CIM_REG
argument_list|(
name|A_CIM_VF_EXT_MAILBOX_STATUS
argument_list|)
block|,
name|FW_T6VF_MBDATA_BASE_ADDR
block|,
name|FW_T6VF_MBDATA_BASE_ADDR
operator|+
operator|(
operator|(
name|NUM_CIM_PF_MAILBOX_DATA_INSTANCES
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
block|, 	}
decl_stmt|;
name|u32
modifier|*
name|buf_end
init|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|buf
operator|+
name|buf_size
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|int
modifier|*
name|reg_ranges
decl_stmt|;
name|int
name|reg_ranges_size
decl_stmt|,
name|range
decl_stmt|;
name|unsigned
name|int
name|chip_version
init|=
name|chip_id
argument_list|(
name|adap
argument_list|)
decl_stmt|;
comment|/* 	 * Select the right set of register ranges to dump depending on the 	 * adapter chip type. 	 */
switch|switch
condition|(
name|chip_version
condition|)
block|{
case|case
name|CHELSIO_T4
case|:
if|if
condition|(
name|adap
operator|->
name|flags
operator|&
name|IS_VF
condition|)
block|{
name|reg_ranges
operator|=
name|t4vf_reg_ranges
expr_stmt|;
name|reg_ranges_size
operator|=
name|ARRAY_SIZE
argument_list|(
name|t4vf_reg_ranges
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg_ranges
operator|=
name|t4_reg_ranges
expr_stmt|;
name|reg_ranges_size
operator|=
name|ARRAY_SIZE
argument_list|(
name|t4_reg_ranges
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHELSIO_T5
case|:
if|if
condition|(
name|adap
operator|->
name|flags
operator|&
name|IS_VF
condition|)
block|{
name|reg_ranges
operator|=
name|t5vf_reg_ranges
expr_stmt|;
name|reg_ranges_size
operator|=
name|ARRAY_SIZE
argument_list|(
name|t5vf_reg_ranges
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg_ranges
operator|=
name|t5_reg_ranges
expr_stmt|;
name|reg_ranges_size
operator|=
name|ARRAY_SIZE
argument_list|(
name|t5_reg_ranges
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHELSIO_T6
case|:
if|if
condition|(
name|adap
operator|->
name|flags
operator|&
name|IS_VF
condition|)
block|{
name|reg_ranges
operator|=
name|t6vf_reg_ranges
expr_stmt|;
name|reg_ranges_size
operator|=
name|ARRAY_SIZE
argument_list|(
name|t6vf_reg_ranges
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg_ranges
operator|=
name|t6_reg_ranges
expr_stmt|;
name|reg_ranges_size
operator|=
name|ARRAY_SIZE
argument_list|(
name|t6_reg_ranges
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Unsupported chip version %d\n"
argument_list|,
name|chip_version
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Clear the register buffer and insert the appropriate register 	 * values selected by the above register ranges. 	 */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
for|for
control|(
name|range
operator|=
literal|0
init|;
name|range
operator|<
name|reg_ranges_size
condition|;
name|range
operator|+=
literal|2
control|)
block|{
name|unsigned
name|int
name|reg
init|=
name|reg_ranges
index|[
name|range
index|]
decl_stmt|;
name|unsigned
name|int
name|last_reg
init|=
name|reg_ranges
index|[
name|range
operator|+
literal|1
index|]
decl_stmt|;
name|u32
modifier|*
name|bufp
init|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|buf
operator|+
name|reg
operator|)
decl_stmt|;
comment|/* 		 * Iterate across the register range filling in the register 		 * buffer but don't write past the end of the register buffer. 		 */
while|while
condition|(
name|reg
operator|<=
name|last_reg
operator|&&
name|bufp
operator|<
name|buf_end
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|+=
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Partial EEPROM Vital Product Data structure.  Includes only the ID and  * VPD-R sections.  */
end_comment

begin_struct
struct|struct
name|t4_vpd_hdr
block|{
name|u8
name|id_tag
decl_stmt|;
name|u8
name|id_len
index|[
literal|2
index|]
decl_stmt|;
name|u8
name|id_data
index|[
name|ID_LEN
index|]
decl_stmt|;
name|u8
name|vpdr_tag
decl_stmt|;
name|u8
name|vpdr_len
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * EEPROM reads take a few tens of us while writes can take a bit over 5 ms.  */
end_comment

begin_define
define|#
directive|define
name|EEPROM_DELAY
value|10
end_define

begin_comment
comment|/* 10us per poll spin */
end_comment

begin_define
define|#
directive|define
name|EEPROM_MAX_POLL
value|5000
end_define

begin_comment
comment|/* x 5000 == 50ms */
end_comment

begin_define
define|#
directive|define
name|EEPROM_STAT_ADDR
value|0x7bfc
end_define

begin_define
define|#
directive|define
name|VPD_SIZE
value|0x800
end_define

begin_define
define|#
directive|define
name|VPD_BASE
value|0x400
end_define

begin_define
define|#
directive|define
name|VPD_BASE_OLD
value|0
end_define

begin_define
define|#
directive|define
name|VPD_LEN
value|1024
end_define

begin_define
define|#
directive|define
name|VPD_INFO_FLD_HDR_SIZE
value|3
end_define

begin_define
define|#
directive|define
name|CHELSIO_VPD_UNIQUE_ID
value|0x82
end_define

begin_comment
comment|/*  * Small utility function to wait till any outstanding VPD Access is complete.  * We have a per-adapter state variable "VPD Busy" to indicate when we have a  * VPD Access in flight.  This allows us to handle the problem of having a  * previous VPD Access time out and prevent an attempt to inject a new VPD  * Request before any in-flight VPD reguest has completed.  */
end_comment

begin_function
specifier|static
name|int
name|t4_seeprom_wait
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
name|int
name|max_poll
decl_stmt|;
comment|/* 	 * If no VPD Access is in flight, we can just return success right 	 * away. 	 */
if|if
condition|(
operator|!
name|adapter
operator|->
name|vpd_busy
condition|)
return|return
literal|0
return|;
comment|/* 	 * Poll the VPD Capability Address/Flag register waiting for it 	 * to indicate that the operation is complete. 	 */
name|max_poll
operator|=
name|EEPROM_MAX_POLL
expr_stmt|;
do|do
block|{
name|u16
name|val
decl_stmt|;
name|udelay
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * If the operation is complete, mark the VPD as no longer 		 * busy and return success. 		 */
if|if
condition|(
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
operator|==
name|adapter
operator|->
name|vpd_flag
condition|)
block|{
name|adapter
operator|->
name|vpd_busy
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
do|while
condition|(
operator|--
name|max_poll
condition|)
do|;
comment|/* 	 * Failure!  Note that we leave the VPD Busy status set in order to 	 * avoid pushing a new VPD Access request into the VPD Capability till 	 * the current operation eventually succeeds.  It's a bug to issue a 	 * new request when an existing request is in flight and will result 	 * in corrupt hardware state. 	 */
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_seeprom_read - read a serial EEPROM location  *	@adapter: adapter to read  *	@addr: EEPROM virtual address  *	@data: where to store the read data  *  *	Read a 32-bit word from a location in serial EEPROM using the card's PCI  *	VPD capability.  Note that this function must be called with a virtual  *	address.  */
end_comment

begin_function
name|int
name|t4_seeprom_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * VPD Accesses must alway be 4-byte aligned! 	 */
if|if
condition|(
name|addr
operator|>=
name|EEPROMVSIZE
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 	 * Wait for any previous operation which may still be in flight to 	 * complete. 	 */
name|ret
operator|=
name|t4_seeprom_wait
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"VPD still busy from previous operation\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* 	 * Issue our new VPD Read request, mark the VPD as being busy and wait 	 * for our request to complete.  If it doesn't complete, note the 	 * error and return it to our caller.  Note that we do not reset the 	 * VPD Busy status! 	 */
name|t4_os_pci_write_cfg2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vpd_busy
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|vpd_flag
operator|=
name|PCI_VPD_ADDR_F
expr_stmt|;
name|ret
operator|=
name|t4_seeprom_wait
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"VPD read of address %#x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* 	 * Grab the returned data, swizzle it into our endianness and 	 * return success. 	 */
name|t4_os_pci_read_cfg4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_seeprom_write - write a serial EEPROM location  *	@adapter: adapter to write  *	@addr: virtual EEPROM address  *	@data: value to write  *  *	Write a 32-bit word to a location in serial EEPROM using the card's PCI  *	VPD capability.  Note that this function must be called with a virtual  *	address.  */
end_comment

begin_function
name|int
name|t4_seeprom_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u32
name|stats_reg
decl_stmt|;
name|int
name|max_poll
decl_stmt|;
comment|/* 	 * VPD Accesses must alway be 4-byte aligned! 	 */
if|if
condition|(
name|addr
operator|>=
name|EEPROMVSIZE
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 	 * Wait for any previous operation which may still be in flight to 	 * complete. 	 */
name|ret
operator|=
name|t4_seeprom_wait
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"VPD still busy from previous operation\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* 	 * Issue our new VPD Read request, mark the VPD as being busy and wait 	 * for our request to complete.  If it doesn't complete, note the 	 * error and return it to our caller.  Note that we do not reset the 	 * VPD Busy status! 	 */
name|t4_os_pci_write_cfg4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|cpu_to_le32
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|t4_os_pci_write_cfg2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
operator||
name|PCI_VPD_ADDR_F
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vpd_busy
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|vpd_flag
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|t4_seeprom_wait
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"VPD write of address %#x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* 	 * Reset PCI_VPD_DATA register after a transaction and wait for our 	 * request to complete. If it doesn't complete, return error. 	 */
name|t4_os_pci_write_cfg4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max_poll
operator|=
name|EEPROM_MAX_POLL
expr_stmt|;
do|do
block|{
name|udelay
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
name|t4_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|EEPROM_STAT_ADDR
argument_list|,
operator|&
name|stats_reg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|stats_reg
operator|&
literal|0x1
operator|)
operator|&&
operator|--
name|max_poll
condition|)
do|;
if|if
condition|(
operator|!
name|max_poll
condition|)
return|return
operator|-
name|ETIMEDOUT
return|;
comment|/* Return success! */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_eeprom_ptov - translate a physical EEPROM address to virtual  *	@phys_addr: the physical EEPROM address  *	@fn: the PCI function number  *	@sz: size of function-specific area  *  *	Translate a physical EEPROM address to virtual.  The first 1K is  *	accessed through virtual addresses starting at 31K, the rest is  *	accessed through virtual addresses starting at 0.  *  *	The mapping is as follows:  *	[0..1K) -> [31K..32K)  *	[1K..1K+A) -> [ES-A..ES)  *	[1K+A..ES) -> [0..ES-A-1K)  *  *	where A = @fn * @sz, and ES = EEPROM size.  */
end_comment

begin_function
name|int
name|t4_eeprom_ptov
parameter_list|(
name|unsigned
name|int
name|phys_addr
parameter_list|,
name|unsigned
name|int
name|fn
parameter_list|,
name|unsigned
name|int
name|sz
parameter_list|)
block|{
name|fn
operator|*=
name|sz
expr_stmt|;
if|if
condition|(
name|phys_addr
operator|<
literal|1024
condition|)
return|return
name|phys_addr
operator|+
operator|(
literal|31
operator|<<
literal|10
operator|)
return|;
if|if
condition|(
name|phys_addr
operator|<
literal|1024
operator|+
name|fn
condition|)
return|return
name|EEPROMSIZE
operator|-
name|fn
operator|+
name|phys_addr
operator|-
literal|1024
return|;
if|if
condition|(
name|phys_addr
operator|<
name|EEPROMSIZE
condition|)
return|return
name|phys_addr
operator|-
literal|1024
operator|-
name|fn
return|;
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_seeprom_wp - enable/disable EEPROM write protection  *	@adapter: the adapter  *	@enable: whether to enable or disable write protection  *  *	Enables or disables write protection on the serial EEPROM.  */
end_comment

begin_function
name|int
name|t4_seeprom_wp
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
return|return
name|t4_seeprom_write
argument_list|(
name|adapter
argument_list|,
name|EEPROM_STAT_ADDR
argument_list|,
name|enable
condition|?
literal|0xc
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	get_vpd_keyword_val - Locates an information field keyword in the VPD  *	@v: Pointer to buffered vpd data structure  *	@kw: The keyword to search for  *  *	Returns the value of the information field keyword or  *	-ENOENT otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_vpd_keyword_val
parameter_list|(
specifier|const
name|struct
name|t4_vpd_hdr
modifier|*
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|kw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|u8
modifier|*
name|buf
init|=
operator|(
specifier|const
name|u8
operator|*
operator|)
name|v
decl_stmt|;
specifier|const
name|u8
modifier|*
name|vpdr_len
init|=
operator|&
name|v
operator|->
name|vpdr_len
index|[
literal|0
index|]
decl_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|t4_vpd_hdr
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|u16
operator|)
name|vpdr_len
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|u16
operator|)
name|vpdr_len
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|t4_vpd_hdr
argument_list|)
operator|>
name|VPD_LEN
condition|)
block|{
return|return
operator|-
name|ENOENT
return|;
block|}
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|+
name|VPD_INFO_FLD_HDR_SIZE
operator|<=
name|offset
operator|+
name|len
condition|;
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|kw
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
name|VPD_INFO_FLD_HDR_SIZE
expr_stmt|;
return|return
name|i
return|;
block|}
name|i
operator|+=
name|VPD_INFO_FLD_HDR_SIZE
operator|+
name|buf
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
return|return
operator|-
name|ENOENT
return|;
block|}
end_function

begin_comment
comment|/**  *	get_vpd_params - read VPD parameters from VPD EEPROM  *	@adapter: adapter to read  *	@p: where to store the parameters  *	@vpd: caller provided temporary space to read the VPD into  *  *	Reads card parameters stored in VPD EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|get_vpd_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|vpd_params
modifier|*
name|p
parameter_list|,
name|u8
modifier|*
name|vpd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|ec
decl_stmt|,
name|sn
decl_stmt|,
name|pn
decl_stmt|,
name|na
decl_stmt|;
name|u8
name|csum
decl_stmt|;
specifier|const
name|struct
name|t4_vpd_hdr
modifier|*
name|v
decl_stmt|;
comment|/* 	 * Card information normally starts at VPD_BASE but early cards had 	 * it at 0. 	 */
name|ret
operator|=
name|t4_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|VPD_BASE
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|(
name|vpd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * The VPD shall have a unique identifier specified by the PCI SIG. 	 * For chelsio adapters, the identifier is 0x82. The first byte of a VPD 	 * shall be CHELSIO_VPD_UNIQUE_ID (0x82). The VPD programming software 	 * is expected to automatically put this entry at the 	 * beginning of the VPD. 	 */
name|addr
operator|=
operator|*
name|vpd
operator|==
name|CHELSIO_VPD_UNIQUE_ID
condition|?
name|VPD_BASE
else|:
name|VPD_BASE_OLD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VPD_LEN
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ret
operator|=
name|t4_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|addr
operator|+
name|i
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|(
name|vpd
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|v
operator|=
operator|(
specifier|const
expr|struct
name|t4_vpd_hdr
operator|*
operator|)
name|vpd
expr_stmt|;
define|#
directive|define
name|FIND_VPD_KW
parameter_list|(
name|var
parameter_list|,
name|name
parameter_list|)
value|do { \ 	var = get_vpd_keyword_val(v , name); \ 	if (var< 0) { \ 		CH_ERR(adapter, "missing VPD keyword " name "\n"); \ 		return -EINVAL; \ 	} \ } while (0)
name|FIND_VPD_KW
argument_list|(
name|i
argument_list|,
literal|"RV"
argument_list|)
expr_stmt|;
for|for
control|(
name|csum
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|csum
operator|+=
name|vpd
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|csum
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"corrupted VPD EEPROM, actual csum %u\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|FIND_VPD_KW
argument_list|(
name|ec
argument_list|,
literal|"EC"
argument_list|)
expr_stmt|;
name|FIND_VPD_KW
argument_list|(
name|sn
argument_list|,
literal|"SN"
argument_list|)
expr_stmt|;
name|FIND_VPD_KW
argument_list|(
name|pn
argument_list|,
literal|"PN"
argument_list|)
expr_stmt|;
name|FIND_VPD_KW
argument_list|(
name|na
argument_list|,
literal|"NA"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FIND_VPD_KW
name|memcpy
argument_list|(
name|p
operator|->
name|id
argument_list|,
name|v
operator|->
name|id_data
argument_list|,
name|ID_LEN
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
name|p
operator|->
name|id
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|ec
argument_list|,
name|vpd
operator|+
name|ec
argument_list|,
name|EC_LEN
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
name|p
operator|->
name|ec
argument_list|)
expr_stmt|;
name|i
operator|=
name|vpd
index|[
name|sn
operator|-
name|VPD_INFO_FLD_HDR_SIZE
operator|+
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|sn
argument_list|,
name|vpd
operator|+
name|sn
argument_list|,
name|min
argument_list|(
name|i
argument_list|,
name|SERNUM_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
name|p
operator|->
name|sn
argument_list|)
expr_stmt|;
name|i
operator|=
name|vpd
index|[
name|pn
operator|-
name|VPD_INFO_FLD_HDR_SIZE
operator|+
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|pn
argument_list|,
name|vpd
operator|+
name|pn
argument_list|,
name|min
argument_list|(
name|i
argument_list|,
name|PN_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|pn
argument_list|)
expr_stmt|;
name|i
operator|=
name|vpd
index|[
name|na
operator|-
name|VPD_INFO_FLD_HDR_SIZE
operator|+
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|na
argument_list|,
name|vpd
operator|+
name|na
argument_list|,
name|min
argument_list|(
name|i
argument_list|,
name|MACADDR_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|na
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* serial flash and firmware constants and flash config file constants */
end_comment

begin_enum
enum|enum
block|{
name|SF_ATTEMPTS
init|=
literal|10
block|,
comment|/* max retries for SF operations */
comment|/* flash command opcodes */
name|SF_PROG_PAGE
init|=
literal|2
block|,
comment|/* program 256B page */
name|SF_WR_DISABLE
init|=
literal|4
block|,
comment|/* disable writes */
name|SF_RD_STATUS
init|=
literal|5
block|,
comment|/* read status register */
name|SF_WR_ENABLE
init|=
literal|6
block|,
comment|/* enable writes */
name|SF_RD_DATA_FAST
init|=
literal|0xb
block|,
comment|/* read flash */
name|SF_RD_ID
init|=
literal|0x9f
block|,
comment|/* read ID */
name|SF_ERASE_SECTOR
init|=
literal|0xd8
block|,
comment|/* erase 64KB sector */
block|}
enum|;
end_enum

begin_comment
comment|/**  *	sf1_read - read data from the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to read  *	@cont: whether another operation will be chained  *	@lock: whether to lock SF for PL access only  *	@valp: where to store the read data  *  *	Reads up to 4 bytes of data from the serial flash.  The location of  *	the read needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|int
name|lock
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_SF_LOCK
argument_list|(
name|lock
argument_list|)
operator||
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	sf1_write - write data to the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to write  *	@cont: whether another operation will be chained  *	@lock: whether to lock SF for PL access only  *	@val: value to write  *  *	Writes up to 4 bytes of data to the serial flash.  The location of  *	the write needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|int
name|lock
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_SF_LOCK
argument_list|(
name|lock
argument_list|)
operator||
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
operator||
name|V_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|5
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	flash_wait_op - wait for a flash operation to complete  *	@adapter: the adapter  *	@attempts: max number of polls of the status register  *	@delay: delay between polls in ms  *  *	Wait for a flash operation to complete by polling the status register.  */
end_comment

begin_function
specifier|static
name|int
name|flash_wait_op
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|status
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|SF_RD_STATUS
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|msleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_flash - read words from serial flash  *	@adapter: the adapter  *	@addr: the start address for the read  *	@nwords: how many 32-bit words to read  *	@data: where to store the read data  *	@byte_oriented: whether to store data as bytes or as words  *  *	Read the specified number of 32-bit words from the serial flash.  *	If @byte_oriented is set the read data is stored as a byte array  *	(i.e., big-endian), otherwise as 32-bit words in the platform's  *	natural endianness.  */
end_comment

begin_function
name|int
name|t4_read_flash
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|nwords
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|int
name|byte_oriented
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|addr
operator|+
name|nwords
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|>
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|addr
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_RD_DATA_FAST
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
init|;
name|nwords
condition|;
name|nwords
operator|--
operator|,
name|data
operator|++
control|)
block|{
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
name|nwords
operator|>
literal|1
argument_list|,
name|nwords
operator|==
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwords
operator|==
literal|1
condition|)
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|byte_oriented
condition|)
operator|*
name|data
operator|=
call|(
name|__force
name|__u32
call|)
argument_list|(
name|cpu_to_be32
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_flash - write up to a page of data to the serial flash  *	@adapter: the adapter  *	@addr: the start address to write  *	@n: length of data to write in bytes  *	@data: the data to write  *	@byte_oriented: whether to store data as bytes or as words  *  *	Writes up to a page of data (256 bytes) to the serial flash starting  *	at the given address.  All the data must be written to the same page.  *	If @byte_oriented is set the write data is stored as byte stream  *	(i.e. matches what on disk), otherwise in big-endian.  */
end_comment

begin_function
name|int
name|t4_write_flash
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|int
name|byte_oriented
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|buf
index|[
name|SF_PAGE_SIZE
operator|/
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|left
decl_stmt|,
name|val
decl_stmt|,
name|offset
init|=
name|addr
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|||
name|offset
operator|+
name|n
operator|>
name|SF_PAGE_SIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|val
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_PROG_PAGE
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unlock
goto|;
for|for
control|(
name|left
operator|=
name|n
init|;
name|left
condition|;
name|left
operator|-=
name|c
control|)
block|{
name|c
operator|=
name|min
argument_list|(
name|left
argument_list|,
literal|4U
argument_list|)
expr_stmt|;
for|for
control|(
name|val
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|byte_oriented
condition|)
name|val
operator|=
name|cpu_to_be32
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
name|c
argument_list|,
name|c
operator|!=
name|left
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unlock
goto|;
block|}
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unlock
goto|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
comment|/* Read the page to verify the write succeeded */
name|ret
operator|=
name|t4_read_flash
argument_list|(
name|adapter
argument_list|,
name|addr
operator|&
operator|~
literal|0xff
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|,
name|byte_oriented
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|data
operator|-
name|n
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|buf
operator|+
name|offset
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"failed to correctly write the flash page at %#x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
return|return
literal|0
return|;
name|unlock
label|:
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_fw_version - read the firmware version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the FW version from flash.  */
end_comment

begin_function
name|int
name|t4_get_fw_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
return|return
name|t4_read_flash
argument_list|(
name|adapter
argument_list|,
name|FLASH_FW_START
operator|+
name|offsetof
argument_list|(
expr|struct
name|fw_hdr
argument_list|,
name|fw_ver
argument_list|)
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_bs_version - read the firmware bootstrap version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the FW Bootstrap version from flash.  */
end_comment

begin_function
name|int
name|t4_get_bs_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
return|return
name|t4_read_flash
argument_list|(
name|adapter
argument_list|,
name|FLASH_FWBOOTSTRAP_START
operator|+
name|offsetof
argument_list|(
expr|struct
name|fw_hdr
argument_list|,
name|fw_ver
argument_list|)
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_tp_version - read the TP microcode version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the TP microcode version from flash.  */
end_comment

begin_function
name|int
name|t4_get_tp_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
return|return
name|t4_read_flash
argument_list|(
name|adapter
argument_list|,
name|FLASH_FW_START
operator|+
name|offsetof
argument_list|(
expr|struct
name|fw_hdr
argument_list|,
name|tp_microcode_ver
argument_list|)
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_exprom_version - return the Expansion ROM version (if any)  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the Expansion ROM header from FLASH and returns the version  *	number (if present) through the @vers return value pointer.  We return  *	this in the Firmware Version Format since it's convenient.  Return  *	0 on success, -ENOENT if no Expansion ROM is present.  */
end_comment

begin_function
name|int
name|t4_get_exprom_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
struct|struct
name|exprom_header
block|{
name|unsigned
name|char
name|hdr_arr
index|[
literal|16
index|]
decl_stmt|;
comment|/* must start with 0x55aa */
name|unsigned
name|char
name|hdr_ver
index|[
literal|4
index|]
decl_stmt|;
comment|/* Expansion ROM version */
block|}
modifier|*
name|hdr
struct|;
name|u32
name|exprom_header_buf
index|[
name|DIV_ROUND_UP
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|exprom_header
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|t4_read_flash
argument_list|(
name|adap
argument_list|,
name|FLASH_EXP_ROM_START
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|exprom_header_buf
argument_list|)
argument_list|,
name|exprom_header_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|hdr
operator|=
operator|(
expr|struct
name|exprom_header
operator|*
operator|)
name|exprom_header_buf
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_arr
index|[
literal|0
index|]
operator|!=
literal|0x55
operator|||
name|hdr
operator|->
name|hdr_arr
index|[
literal|1
index|]
operator|!=
literal|0xaa
condition|)
return|return
operator|-
name|ENOENT
return|;
operator|*
name|vers
operator|=
operator|(
name|V_FW_HDR_FW_VER_MAJOR
argument_list|(
name|hdr
operator|->
name|hdr_ver
index|[
literal|0
index|]
argument_list|)
operator||
name|V_FW_HDR_FW_VER_MINOR
argument_list|(
name|hdr
operator|->
name|hdr_ver
index|[
literal|1
index|]
argument_list|)
operator||
name|V_FW_HDR_FW_VER_MICRO
argument_list|(
name|hdr
operator|->
name|hdr_ver
index|[
literal|2
index|]
argument_list|)
operator||
name|V_FW_HDR_FW_VER_BUILD
argument_list|(
name|hdr
operator|->
name|hdr_ver
index|[
literal|3
index|]
argument_list|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_scfg_version - return the Serial Configuration version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the Serial Configuration Version via the Firmware interface  *	(thus this can only be called once we're ready to issue Firmware  *	commands).  The format of the Serial Configuration version is  *	adapter specific.  Returns 0 on success, an error on failure.  *  *	Note that early versions of the Firmware didn't include the ability  *	to retrieve the Serial Configuration version, so we zero-out the  *	return-value parameter in that case to avoid leaving it with  *	garbage in it.  *  *	Also note that the Firmware will return its cached copy of the Serial  *	Initialization Revision ID, not the actual Revision ID as written in  *	the Serial EEPROM.  This is only an issue if a new VPD has been written  *	and the Firmware/Chip haven't yet gone through a RESET sequence.  So  *	it's best to defer calling this routine till after a FW_RESET_CMD has  *	been issued if the Host Driver will be performing a full adapter  *	initialization.  */
end_comment

begin_function
name|int
name|t4_get_scfg_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
name|u32
name|scfgrev_param
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|scfgrev_param
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_SCFGREV
argument_list|)
operator|)
expr_stmt|;
name|ret
operator|=
name|t4_query_params
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
name|adapter
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|scfgrev_param
argument_list|,
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
operator|*
name|vers
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_vpd_version - return the VPD version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the VPD via the Firmware interface (thus this can only be called  *	once we're ready to issue Firmware commands).  The format of the  *	VPD version is adapter specific.  Returns 0 on success, an error on  *	failure.  *  *	Note that early versions of the Firmware didn't include the ability  *	to retrieve the VPD version, so we zero-out the return-value parameter  *	in that case to avoid leaving it with garbage in it.  *  *	Also note that the Firmware will return its cached copy of the VPD  *	Revision ID, not the actual Revision ID as written in the Serial  *	EEPROM.  This is only an issue if a new VPD has been written and the  *	Firmware/Chip haven't yet gone through a RESET sequence.  So it's best  *	to defer calling this routine till after a FW_RESET_CMD has been issued  *	if the Host Driver will be performing a full adapter initialization.  */
end_comment

begin_function
name|int
name|t4_get_vpd_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
name|u32
name|vpdrev_param
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|vpdrev_param
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_VPDREV
argument_list|)
operator|)
expr_stmt|;
name|ret
operator|=
name|t4_query_params
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
name|adapter
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|vpdrev_param
argument_list|,
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
operator|*
name|vers
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_version_info - extract various chip/firmware version information  *	@adapter: the adapter  *  *	Reads various chip/firmware version numbers and stores them into the  *	adapter Adapter Parameters structure.  If any of the efforts fails  *	the first failure will be returned, but all of the version numbers  *	will be read.  */
end_comment

begin_function
name|int
name|t4_get_version_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|FIRST_RET
parameter_list|(
name|__getvinfo
parameter_list|)
define|\
value|do { \ 		int __ret = __getvinfo; \ 		if (__ret&& !ret) \ 			ret = __ret; \ 	} while (0)
name|FIRST_RET
argument_list|(
name|t4_get_fw_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
argument_list|)
expr_stmt|;
name|FIRST_RET
argument_list|(
name|t4_get_bs_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|bs_vers
argument_list|)
argument_list|)
expr_stmt|;
name|FIRST_RET
argument_list|(
name|t4_get_tp_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp_vers
argument_list|)
argument_list|)
expr_stmt|;
name|FIRST_RET
argument_list|(
name|t4_get_exprom_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|er_vers
argument_list|)
argument_list|)
expr_stmt|;
name|FIRST_RET
argument_list|(
name|t4_get_scfg_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|scfg_vers
argument_list|)
argument_list|)
expr_stmt|;
name|FIRST_RET
argument_list|(
name|t4_get_vpd_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|vpd_vers
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FIRST_RET
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_flash_erase_sectors - erase a range of flash sectors  *	@adapter: the adapter  *	@start: the first sector to erase  *	@end: the last sector to erase  *  *	Erases the sectors in the given inclusive range.  */
end_comment

begin_function
name|int
name|t4_flash_erase_sectors
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|end
operator|>=
name|adapter
operator|->
name|params
operator|.
name|sf_nsec
condition|)
return|return
operator|-
name|EINVAL
return|;
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SF_ERASE_SECTOR
operator||
operator|(
name|start
operator|<<
literal|8
operator|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|14
argument_list|,
literal|500
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"erase of flash sector %d failed, error %d\n"
argument_list|,
name|start
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
block|}
name|start
operator|++
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_flash_cfg_addr - return the address of the flash configuration file  *	@adapter: the adapter  *  *	Return the address within the flash where the Firmware Configuration  *	File is stored, or an error if the device FLASH is too small to contain  *	a Firmware Configuration File.  */
end_comment

begin_function
name|int
name|t4_flash_cfg_addr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* 	 * If the device FLASH isn't large enough to hold a Firmware 	 * Configuration File, return an error. 	 */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|<
name|FLASH_CFG_START
operator|+
name|FLASH_CFG_MAX_SIZE
condition|)
return|return
operator|-
name|ENOSPC
return|;
return|return
name|FLASH_CFG_START
return|;
block|}
end_function

begin_comment
comment|/*  * Return TRUE if the specified firmware matches the adapter.  I.e. T4  * firmware for T4 adapters, T5 firmware for T5 adapters, etc.  We go ahead  * and emit an error message for mismatched firmware to save our caller the  * effort ...  */
end_comment

begin_function
specifier|static
name|int
name|t4_fw_matches_chip
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr
parameter_list|)
block|{
comment|/* 	 * The expression below will return FALSE for any unsupported adapter 	 * which will keep us "honest" in the future ... 	 */
if|if
condition|(
operator|(
name|is_t4
argument_list|(
name|adap
argument_list|)
operator|&&
name|hdr
operator|->
name|chip
operator|==
name|FW_HDR_CHIP_T4
operator|)
operator|||
operator|(
name|is_t5
argument_list|(
name|adap
argument_list|)
operator|&&
name|hdr
operator|->
name|chip
operator|==
name|FW_HDR_CHIP_T5
operator|)
operator|||
operator|(
name|is_t6
argument_list|(
name|adap
argument_list|)
operator|&&
name|hdr
operator|->
name|chip
operator|==
name|FW_HDR_CHIP_T6
operator|)
condition|)
return|return
literal|1
return|;
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image (%d) is not suitable for this adapter (%d)\n"
argument_list|,
name|hdr
operator|->
name|chip
argument_list|,
name|chip_id
argument_list|(
name|adap
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_load_fw - download firmware  *	@adap: the adapter  *	@fw_data: the firmware image to write  *	@size: image size  *  *	Write the supplied firmware image to the card's serial flash.  */
end_comment

begin_function
name|int
name|t4_load_fw
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u8
modifier|*
name|fw_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|u32
name|csum
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|addr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|u8
name|first_page
index|[
name|SF_PAGE_SIZE
index|]
decl_stmt|;
specifier|const
name|u32
modifier|*
name|p
init|=
operator|(
specifier|const
name|u32
operator|*
operator|)
name|fw_data
decl_stmt|;
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
expr|struct
name|fw_hdr
operator|*
operator|)
name|fw_data
decl_stmt|;
name|unsigned
name|int
name|sf_sec_size
init|=
name|adap
operator|->
name|params
operator|.
name|sf_size
operator|/
name|adap
operator|->
name|params
operator|.
name|sf_nsec
decl_stmt|;
name|unsigned
name|int
name|fw_start_sec
decl_stmt|;
name|unsigned
name|int
name|fw_start
decl_stmt|;
name|unsigned
name|int
name|fw_size
decl_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|hdr
operator|->
name|magic
argument_list|)
operator|==
name|FW_HDR_MAGIC_BOOTSTRAP
condition|)
block|{
name|fw_start_sec
operator|=
name|FLASH_FWBOOTSTRAP_START_SEC
expr_stmt|;
name|fw_start
operator|=
name|FLASH_FWBOOTSTRAP_START
expr_stmt|;
name|fw_size
operator|=
name|FLASH_FWBOOTSTRAP_MAX_SIZE
expr_stmt|;
block|}
else|else
block|{
name|fw_start_sec
operator|=
name|FLASH_FW_START_SEC
expr_stmt|;
name|fw_start
operator|=
name|FLASH_FW_START
expr_stmt|;
name|fw_size
operator|=
name|FLASH_FW_MAX_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image has no data\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|size
operator|&
literal|511
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image size not multiple of 512 bytes\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|len512
argument_list|)
operator|*
literal|512
operator|!=
name|size
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image size differs from size in FW header\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|size
operator|>
name|fw_size
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image too large, max is %u bytes\n"
argument_list|,
name|fw_size
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
if|if
condition|(
operator|!
name|t4_fw_matches_chip
argument_list|(
name|adap
argument_list|,
name|hdr
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|csum
argument_list|)
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|be32_to_cpu
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
literal|0xffffffff
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"corrupted firmware image, checksum %#x\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|i
operator|=
name|DIV_ROUND_UP
argument_list|(
name|size
argument_list|,
name|sf_sec_size
argument_list|)
expr_stmt|;
comment|/* # of sectors spanned */
name|ret
operator|=
name|t4_flash_erase_sectors
argument_list|(
name|adap
argument_list|,
name|fw_start_sec
argument_list|,
name|fw_start_sec
operator|+
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * We write the correct version at the end so the driver can see a bad 	 * version if the FW write fails.  Start by writing a copy of the 	 * first page with a bad version. 	 */
name|memcpy
argument_list|(
name|first_page
argument_list|,
name|fw_data
argument_list|,
name|SF_PAGE_SIZE
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|fw_hdr
operator|*
operator|)
name|first_page
operator|)
operator|->
name|fw_ver
operator|=
name|cpu_to_be32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|fw_start
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
name|first_page
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|=
name|fw_start
expr_stmt|;
for|for
control|(
name|size
operator|-=
name|SF_PAGE_SIZE
init|;
name|size
condition|;
name|size
operator|-=
name|SF_PAGE_SIZE
control|)
block|{
name|addr
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|fw_data
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
name|fw_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|fw_start
operator|+
name|offsetof
argument_list|(
expr|struct
name|fw_hdr
argument_list|,
name|fw_ver
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|fw_ver
argument_list|)
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|&
name|hdr
operator|->
name|fw_ver
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"firmware download failed, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fwcache - firmware cache operation  *	@adap: the adapter  *	@op  : the operation (flush or flush and invalidate)  */
end_comment

begin_function
name|int
name|t4_fwcache
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|enum
name|fw_params_param_dev_fwcache
name|op
parameter_list|)
block|{
name|struct
name|fw_params_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PARAMS_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_PARAMS_CMD_PFN
argument_list|(
name|adap
operator|->
name|pf
argument_list|)
operator||
name|V_FW_PARAMS_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|mnem
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_FWCACHE
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|val
operator|=
operator|(
name|__force
name|__be32
operator|)
name|op
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|t4_cim_read_pif_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|pif_req
parameter_list|,
name|u32
modifier|*
name|pif_rsp
parameter_list|,
name|unsigned
name|int
modifier|*
name|pif_req_wrptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|pif_rsp_wrptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u32
name|cfg
decl_stmt|,
name|val
decl_stmt|,
name|req
decl_stmt|,
name|rsp
decl_stmt|;
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_LADBGEN
condition|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
operator|^
name|F_LADBGEN
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGSTS
argument_list|)
expr_stmt|;
name|req
operator|=
name|G_POLADBGWRPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|rsp
operator|=
name|G_PILADBGWRPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|pif_req_wrptr
condition|)
operator|*
name|pif_req_wrptr
operator|=
name|req
expr_stmt|;
if|if
condition|(
name|pif_rsp_wrptr
condition|)
operator|*
name|pif_rsp_wrptr
operator|=
name|rsp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_PIFLA_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|V_POLADBGRDPTR
argument_list|(
name|req
argument_list|)
operator||
name|V_PILADBGRDPTR
argument_list|(
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pif_req
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PO_LA_DEBUGDATA
argument_list|)
expr_stmt|;
operator|*
name|pif_rsp
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PI_LA_DEBUGDATA
argument_list|)
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|rsp
operator|++
expr_stmt|;
block|}
name|req
operator|=
operator|(
name|req
operator|+
literal|2
operator|)
operator|&
name|M_POLADBGRDPTR
expr_stmt|;
name|rsp
operator|=
operator|(
name|rsp
operator|+
literal|2
operator|)
operator|&
name|M_PILADBGRDPTR
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_cim_read_ma_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|ma_req
parameter_list|,
name|u32
modifier|*
name|ma_rsp
parameter_list|)
block|{
name|u32
name|cfg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|idx
decl_stmt|;
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_LADBGEN
condition|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
operator|^
name|F_LADBGEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
name|idx
operator|=
literal|8
operator|*
name|i
operator|+
name|j
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|V_POLADBGRDPTR
argument_list|(
name|idx
argument_list|)
operator||
name|V_PILADBGRDPTR
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ma_req
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PO_LA_MADEBUGDATA
argument_list|)
expr_stmt|;
operator|*
name|ma_rsp
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PI_LA_MADEBUGDATA
argument_list|)
expr_stmt|;
block|}
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_ulprx_read_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|la_buf
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|u32
modifier|*
name|p
init|=
name|la_buf
operator|+
name|i
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_CTL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_WRPTR
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_RDPTR
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ULPRX_LA_SIZE
condition|;
name|j
operator|++
operator|,
name|p
operator|+=
literal|8
control|)
operator|*
name|p
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_RDDATA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_link_l1cfg - apply link configuration to MAC/PHY  *	@phy: the PHY to setup  *	@mac: the MAC to setup  *	@lc: the requested link configuration  *  *	Set up a port's MAC and PHY according to a desired link configuration.  *	- If the PHY can auto-negotiate first decide what to advertise, then  *	  enable/disable auto-negotiation as desired, and reset.  *	- If the PHY does not auto-negotiate just reset it.  *	- If auto-negotiation is off set the MAC to the proper speed/duplex/FC,  *	  otherwise do it later based on the outcome of auto-negotiation.  */
end_comment

begin_function
name|int
name|t4_link_l1cfg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|struct
name|link_config
modifier|*
name|lc
parameter_list|)
block|{
name|struct
name|fw_port_cmd
name|c
decl_stmt|;
name|unsigned
name|int
name|mdi
init|=
name|V_FW_PORT_CAP_MDI
argument_list|(
name|FW_PORT_CAP_MDI_AUTO
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|aneg
decl_stmt|,
name|fc
decl_stmt|,
name|fec
decl_stmt|,
name|speed
decl_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|requested_fc
operator|&
name|PAUSE_RX
condition|)
name|fc
operator||=
name|FW_PORT_CAP_FC_RX
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|requested_fc
operator|&
name|PAUSE_TX
condition|)
name|fc
operator||=
name|FW_PORT_CAP_FC_TX
expr_stmt|;
name|fec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|requested_fec
operator|&
name|FEC_RS
condition|)
name|fec
operator|=
name|FW_PORT_CAP_FEC_RS
expr_stmt|;
elseif|else
if|if
condition|(
name|lc
operator|->
name|requested_fec
operator|&
name|FEC_BASER_RS
condition|)
name|fec
operator|=
name|FW_PORT_CAP_FEC_BASER_RS
expr_stmt|;
elseif|else
if|if
condition|(
name|lc
operator|->
name|requested_fec
operator|&
name|FEC_RESERVED
condition|)
name|fec
operator|=
name|FW_PORT_CAP_FEC_RESERVED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lc
operator|->
name|supported
operator|&
name|FW_PORT_CAP_ANEG
operator|)
operator|||
name|lc
operator|->
name|requested_aneg
operator|==
name|AUTONEG_DISABLE
condition|)
block|{
name|aneg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|lc
operator|->
name|requested_speed
condition|)
block|{
case|case
literal|100
case|:
name|speed
operator|=
name|FW_PORT_CAP_SPEED_100G
expr_stmt|;
break|break;
case|case
literal|40
case|:
name|speed
operator|=
name|FW_PORT_CAP_SPEED_40G
expr_stmt|;
break|break;
case|case
literal|25
case|:
name|speed
operator|=
name|FW_PORT_CAP_SPEED_25G
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|speed
operator|=
name|FW_PORT_CAP_SPEED_10G
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|speed
operator|=
name|FW_PORT_CAP_SPEED_1G
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
break|break;
block|}
block|}
else|else
block|{
name|aneg
operator|=
name|FW_PORT_CAP_ANEG
expr_stmt|;
name|speed
operator|=
name|lc
operator|->
name|supported
operator|&
name|V_FW_PORT_CAP_SPEED
argument_list|(
name|M_FW_PORT_CAP_SPEED
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_portid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PORT_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_PORT_CMD_PORTID
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|action_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PORT_CMD_ACTION
argument_list|(
name|FW_PORT_ACTION_L1_CFG
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|l1cfg
operator|.
name|rcap
operator|=
name|cpu_to_be32
argument_list|(
name|aneg
operator||
name|speed
operator||
name|fc
operator||
name|fec
operator||
name|mdi
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_ns
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_restart_aneg - restart autonegotiation  *	@adap: the adapter  *	@mbox: mbox to use for the FW command  *	@port: the port id  *  *	Restarts autonegotiation for the selected port.  */
end_comment

begin_function
name|int
name|t4_restart_aneg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|)
block|{
name|struct
name|fw_port_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_portid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PORT_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_PORT_CMD_PORTID
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|action_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PORT_CMD_ACTION
argument_list|(
name|FW_PORT_ACTION_L1_CFG
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|l1cfg
operator|.
name|rcap
operator|=
name|cpu_to_be32
argument_list|(
name|FW_PORT_CAP_ANEG
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|int_handler_t
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|intr_info
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/* bits to check in interrupt status */
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* message to print or NULL */
name|short
name|stat_idx
decl_stmt|;
comment|/* stat counter to increment or -1 */
name|unsigned
name|short
name|fatal
decl_stmt|;
comment|/* whether the condition reported is fatal */
name|int_handler_t
name|int_handler
decl_stmt|;
comment|/* platform-specific int handler */
block|}
struct|;
end_struct

begin_comment
comment|/**  *	t4_handle_intr_status - table driven interrupt handler  *	@adapter: the adapter that generated the interrupt  *	@reg: the interrupt status register to process  *	@acts: table of interrupt actions  *  *	A table driven interrupt handler that applies a set of masks to an  *	interrupt status word and performs the corresponding actions if the  *	interrupts described by the mask have occurred.  The actions include  *	optionally emitting a warning or alert message.  The table is terminated  *	by an entry specifying mask 0.  Returns the number of fatal interrupt  *	conditions.  */
end_comment

begin_function
specifier|static
name|int
name|t4_handle_intr_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
specifier|const
name|struct
name|intr_info
modifier|*
name|acts
parameter_list|)
block|{
name|int
name|fatal
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|acts
operator|->
name|mask
condition|;
operator|++
name|acts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|acts
operator|->
name|mask
operator|)
condition|)
continue|continue;
if|if
condition|(
name|acts
operator|->
name|fatal
condition|)
block|{
name|fatal
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acts
operator|->
name|msg
condition|)
name|CH_WARN_RATELIMIT
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|acts
operator|->
name|int_handler
condition|)
name|acts
operator|->
name|int_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|mask
operator||=
name|acts
operator|->
name|mask
expr_stmt|;
block|}
name|status
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|status
condition|)
comment|/* clear processed interrupts */
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|fatal
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for the PCIE module.  */
end_comment

begin_function
specifier|static
name|void
name|pcie_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|sysbus_intr_info
index|[]
init|=
block|{
block|{
name|F_RNPP
block|,
literal|"RXNP array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RPCP
block|,
literal|"RXPC array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCIP
block|,
literal|"RXCIF array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCCP
block|,
literal|"Rx completions control array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RFTP
block|,
literal|"RXFT array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|pcie_port_intr_info
index|[]
init|=
block|{
block|{
name|F_TPCP
block|,
literal|"TXPC array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TNPP
block|,
literal|"TXNP array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TFTP
block|,
literal|"TXFT array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TCAP
block|,
literal|"TXCA array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TCIP
block|,
literal|"TXCIF array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCAP
block|,
literal|"RXCA array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OTDD
block|,
literal|"outbound request TLP discarded"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RDPE
block|,
literal|"Rx data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TDUE
block|,
literal|"Tx uncorrectable data error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|pcie_intr_info
index|[]
init|=
block|{
block|{
name|F_MSIADDRLPERR
block|,
literal|"MSI AddrL parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIADDRHPERR
block|,
literal|"MSI AddrH parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIDATAPERR
block|,
literal|"MSI data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRLPERR
block|,
literal|"MSI-X AddrL parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRHPERR
block|,
literal|"MSI-X AddrH parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDATAPERR
block|,
literal|"MSI-X data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDIPERR
block|,
literal|"MSI-X DI parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOCPLPERR
block|,
literal|"PCI PIO completion FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOREQPERR
block|,
literal|"PCI PIO request FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TARTAGPERR
block|,
literal|"PCI PCI target tag FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CCNTPERR
block|,
literal|"PCI CMD channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CREQPERR
block|,
literal|"PCI CMD channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CRSPPERR
block|,
literal|"PCI CMD channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DCNTPERR
block|,
literal|"PCI DMA channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DREQPERR
block|,
literal|"PCI DMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DRSPPERR
block|,
literal|"PCI DMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HCNTPERR
block|,
literal|"PCI HMA channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HREQPERR
block|,
literal|"PCI HMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HRSPPERR
block|,
literal|"PCI HMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CFGSNPPERR
block|,
literal|"PCI config snoop FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FIDPERR
block|,
literal|"PCI FID parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_INTXCLRPERR
block|,
literal|"PCI INTx clear parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MATAGPERR
block|,
literal|"PCI MA tag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOTAGPERR
block|,
literal|"PCI PIO tag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RXCPLPERR
block|,
literal|"PCI Rx completion parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RXWRPERR
block|,
literal|"PCI Rx write parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RPLPERR
block|,
literal|"PCI replay buffer parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIESINT
block|,
literal|"PCI core secondary fault"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIEPINT
block|,
literal|"PCI core primary fault"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCPLERR
block|,
literal|"PCI unexpected split completion error"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|t5_pcie_intr_info
index|[]
init|=
block|{
block|{
name|F_MSTGRPPERR
block|,
literal|"Master Response Read Queue parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSTTIMEOUTPERR
block|,
literal|"Master Timeout FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXSTIPERR
block|,
literal|"MSI-X STI SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRLPERR
block|,
literal|"MSI-X AddrL parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRHPERR
block|,
literal|"MSI-X AddrH parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDATAPERR
block|,
literal|"MSI-X data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDIPERR
block|,
literal|"MSI-X DI parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOCPLGRPPERR
block|,
literal|"PCI PIO completion Group FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOREQGRPPERR
block|,
literal|"PCI PIO request Group FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TARTAGPERR
block|,
literal|"PCI PCI target tag FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSTTAGQPERR
block|,
literal|"PCI master tag queue parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CREQPERR
block|,
literal|"PCI CMD channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CRSPPERR
block|,
literal|"PCI CMD channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DREQWRPERR
block|,
literal|"PCI DMA channel write request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DREQPERR
block|,
literal|"PCI DMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DRSPPERR
block|,
literal|"PCI DMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HREQWRPERR
block|,
literal|"PCI HMA channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HREQPERR
block|,
literal|"PCI HMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HRSPPERR
block|,
literal|"PCI HMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CFGSNPPERR
block|,
literal|"PCI config snoop FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FIDPERR
block|,
literal|"PCI FID parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_VFIDPERR
block|,
literal|"PCI INTx clear parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MAGRPPERR
block|,
literal|"PCI MA group FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOTAGPERR
block|,
literal|"PCI PIO tag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IPRXHDRGRPPERR
block|,
literal|"PCI IP Rx header group parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IPRXDATAGRPPERR
block|,
literal|"PCI IP Rx data group parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RPLPERR
block|,
literal|"PCI IP replay buffer parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IPSOTPERR
block|,
literal|"PCI IP SOT buffer parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TRGT1GRPPERR
block|,
literal|"PCI TRGT1 group FIFOs parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_READRSPERR
block|,
literal|"Outbound read error"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|int
name|fat
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS
argument_list|,
name|sysbus_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS
argument_list|,
name|pcie_port_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_CAUSE
argument_list|,
name|pcie_intr_info
argument_list|)
expr_stmt|;
else|else
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_CAUSE
argument_list|,
name|t5_pcie_intr_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TP interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|tp_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|tp_intr_info
index|[]
init|=
block|{
block|{
literal|0x3fffffff
block|,
literal|"TP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FLMTXFLSTEMPTY
block|,
literal|"TP out of Tx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_TP_INT_CAUSE
argument_list|,
name|tp_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SGE interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|sge_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u64
name|v
decl_stmt|;
name|u32
name|err
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|sge_intr_info
index|[]
init|=
block|{
block|{
name|F_ERR_CPL_EXCEED_IQE_SIZE
block|,
literal|"SGE received CPL exceeding IQE size"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ERR_INVALID_CIDX_INC
block|,
literal|"SGE GTS CIDX increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_CPL_OPCODE_0
block|,
literal|"SGE received 0-length CPL"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_DBFIFO_LP_INT
block|,
name|NULL
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|t4_db_full
block|}
block|,
block|{
name|F_ERR_DATA_CPL_ON_HIGH_QID1
operator||
name|F_ERR_DATA_CPL_ON_HIGH_QID0
block|,
literal|"SGE IQID> 1023 received CPL for FL"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX3
block|,
literal|"SGE DBP 3 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX2
block|,
literal|"SGE DBP 2 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX1
block|,
literal|"SGE DBP 1 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX0
block|,
literal|"SGE DBP 0 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_ING_CTXT_PRIO
block|,
literal|"SGE too many priority ingress contexts"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_INGRESS_SIZE_ERR
block|,
literal|"SGE illegal ingress QID"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_EGRESS_SIZE_ERR
block|,
literal|"SGE illegal egress QID"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_PCIE_ERROR0
operator||
name|F_ERR_PCIE_ERROR1
operator||
name|F_ERR_PCIE_ERROR2
operator||
name|F_ERR_PCIE_ERROR3
block|,
literal|"SGE PCIe error for a DBP thread"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|t4t5_sge_intr_info
index|[]
init|=
block|{
block|{
name|F_ERR_DROPPED_DB
block|,
name|NULL
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|t4_db_dropped
block|}
block|,
block|{
name|F_DBFIFO_HP_INT
block|,
name|NULL
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|t4_db_full
block|}
block|,
block|{
name|F_ERR_EGR_CTXT_PRIO
block|,
literal|"SGE too many priority egress contexts"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/*  	* For now, treat below interrupts as fatal so that we disable SGE and  	* get better debug */
specifier|static
specifier|const
name|struct
name|intr_info
name|t6_sge_intr_info
index|[]
init|=
block|{
block|{
name|F_FATAL_WRE_LEN
block|,
literal|"SGE Actual WRE packet is less than advertized length"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|v
operator|=
operator|(
name|u64
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE1
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE2
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"SGE parity error (%#llx)\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|v
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE2
argument_list|,
name|v
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|v
operator||=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE3
argument_list|,
name|sge_intr_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
name|v
operator||=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE3
argument_list|,
name|t4t5_sge_intr_info
argument_list|)
expr_stmt|;
else|else
name|v
operator||=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE3
argument_list|,
name|t6_sge_intr_info
argument_list|)
expr_stmt|;
name|err
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_ERROR_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&
name|F_ERROR_QID_VALID
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"SGE error for queue %u\n"
argument_list|,
name|G_ERROR_QID
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&
name|F_UNCAPTURED_ERROR
condition|)
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"SGE UNCAPTURED_ERROR set (clearing)\n"
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_ERROR_STATS
argument_list|,
name|F_ERROR_QID_VALID
operator||
name|F_UNCAPTURED_ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CIM_OBQ_INTR
value|(F_OBQULP0PARERR | F_OBQULP1PARERR | F_OBQULP2PARERR |\ 		      F_OBQULP3PARERR | F_OBQSGEPARERR | F_OBQNCSIPARERR)
end_define

begin_define
define|#
directive|define
name|CIM_IBQ_INTR
value|(F_IBQTP0PARERR | F_IBQTP1PARERR | F_IBQULPPARERR |\ 		      F_IBQSGEHIPARERR | F_IBQSGELOPARERR | F_IBQNCSIPARERR)
end_define

begin_comment
comment|/*  * CIM interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cim_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|cim_intr_info
index|[]
init|=
block|{
block|{
name|F_PREFDROPINT
block|,
literal|"CIM control register prefetch drop"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|CIM_OBQ_INTR
block|,
literal|"CIM OBQ parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|CIM_IBQ_INTR
block|,
literal|"CIM IBQ parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MBUPPARERR
block|,
literal|"CIM mailbox uP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MBHOSTPARERR
block|,
literal|"CIM mailbox host parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIEQINPARERRINT
block|,
literal|"CIM TIEQ outgoing parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIEQOUTPARERRINT
block|,
literal|"CIM TIEQ incoming parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIMER0INT
block|,
literal|"CIM TIMER0 interrupt"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|cim_upintr_info
index|[]
init|=
block|{
block|{
name|F_RSVDSPACEINT
block|,
literal|"CIM reserved space access"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLTRANSINT
block|,
literal|"CIM illegal transaction"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLWRINT
block|,
literal|"CIM illegal write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLRDINT
block|,
literal|"CIM illegal read"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLRDBEINT
block|,
literal|"CIM illegal read BE"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLWRBEINT
block|,
literal|"CIM illegal write BE"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDBOOTINT
block|,
literal|"CIM single read from boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRBOOTINT
block|,
literal|"CIM single write to boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRBOOTINT
block|,
literal|"CIM block write to boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDFLASHINT
block|,
literal|"CIM single read from flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRFLASHINT
block|,
literal|"CIM single write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRFLASHINT
block|,
literal|"CIM block write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDEEPROMINT
block|,
literal|"CIM single EEPROM read"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWREEPROMINT
block|,
literal|"CIM single EEPROM write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDEEPROMINT
block|,
literal|"CIM block EEPROM read"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWREEPROMINT
block|,
literal|"CIM block EEPROM write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDCTLINT
block|,
literal|"CIM single read from CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRCTLINT
block|,
literal|"CIM single write to CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDCTLINT
block|,
literal|"CIM block read from CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRCTLINT
block|,
literal|"CIM block write to CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDPLINT
block|,
literal|"CIM single read from PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRPLINT
block|,
literal|"CIM single write to PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDPLINT
block|,
literal|"CIM block read from PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRPLINT
block|,
literal|"CIM block write to PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_REQOVRLOOKUPINT
block|,
literal|"CIM request FIFO overwrite"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RSPOVRLOOKUPINT
block|,
literal|"CIM response FIFO overwrite"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIMEOUTINT
block|,
literal|"CIM PIF timeout"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIMEOUTMAINT
block|,
literal|"CIM PIF MA timeout"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|u32
name|val
decl_stmt|,
name|fw_err
decl_stmt|;
name|int
name|fat
decl_stmt|;
name|fw_err
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_FW
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_err
operator|&
name|F_PCIE_FW_ERR
condition|)
name|t4_report_fw_error
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* When the Firmware detects an internal error which normally wouldn't 	 * raise a Host Interrupt, it forces a CIM Timer0 interrupt in order 	 * to make sure the Host sees the Firmware Crash.  So if we have a 	 * Timer0 interrupt and don't see a Firmware Crash, ignore the Timer0 	 * interrupt. 	 */
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_INT_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|F_TIMER0INT
condition|)
if|if
condition|(
operator|!
operator|(
name|fw_err
operator|&
name|F_PCIE_FW_ERR
operator|)
operator|||
operator|(
name|G_PCIE_FW_EVAL
argument_list|(
name|fw_err
argument_list|)
operator|!=
name|PCIE_FW_EVAL_CRASH
operator|)
condition|)
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_INT_CAUSE
argument_list|,
name|F_TIMER0INT
argument_list|)
expr_stmt|;
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_INT_CAUSE
argument_list|,
name|cim_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_UPACC_INT_CAUSE
argument_list|,
name|cim_upintr_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulprx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|ulprx_intr_info
index|[]
init|=
block|{
block|{
name|F_CAUSE_CTX_1
block|,
literal|"ULPRX channel 1 context error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CAUSE_CTX_0
block|,
literal|"ULPRX channel 0 context error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x7fffff
block|,
literal|"ULPRX parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULP_RX_INT_CAUSE
argument_list|,
name|ulprx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulptx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|ulptx_intr_info
index|[]
init|=
block|{
block|{
name|F_PBL_BOUND_ERR_CH3
block|,
literal|"ULPTX channel 3 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH2
block|,
literal|"ULPTX channel 2 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH1
block|,
literal|"ULPTX channel 1 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH0
block|,
literal|"ULPTX channel 0 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0xfffffff
block|,
literal|"ULPTX parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULP_TX_INT_CAUSE
argument_list|,
name|ulptx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PM TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmtx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|pmtx_intr_info
index|[]
init|=
block|{
block|{
name|F_PCMD_LEN_OVFL0
block|,
literal|"PMTX channel 0 pcmd too large"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCMD_LEN_OVFL1
block|,
literal|"PMTX channel 1 pcmd too large"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCMD_LEN_OVFL2
block|,
literal|"PMTX channel 2 pcmd too large"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ZERO_C_CMD_ERROR
block|,
literal|"PMTX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0xffffff0
block|,
literal|"PMTX framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OESPI_PAR_ERROR
block|,
literal|"PMTX oespi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DB_OPTIONS_PAR_ERROR
block|,
literal|"PMTX db_options parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ICSPI_PAR_ERROR
block|,
literal|"PMTX icspi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_C_PCMD_PAR_ERROR
block|,
literal|"PMTX c_pcmd parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM_TX_INT_CAUSE
argument_list|,
name|pmtx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PM RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmrx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|pmrx_intr_info
index|[]
init|=
block|{
block|{
name|F_ZERO_E_CMD_ERROR
block|,
literal|"PMRX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x3ffff0
block|,
literal|"PMRX framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OCSPI_PAR_ERROR
block|,
literal|"PMRX ocspi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DB_OPTIONS_PAR_ERROR
block|,
literal|"PMRX db_options parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IESPI_PAR_ERROR
block|,
literal|"PMRX iespi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_E_PCMD_PAR_ERROR
block|,
literal|"PMRX e_pcmd parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM_RX_INT_CAUSE
argument_list|,
name|pmrx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CPL switch interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cplsw_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|cplsw_intr_info
index|[]
init|=
block|{
block|{
name|F_CIM_OP_MAP_PERR
block|,
literal|"CPLSW CIM op_map parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CIM_OVFL_ERROR
block|,
literal|"CPLSW CIM overflow"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TP_FRAMING_ERROR
block|,
literal|"CPLSW TP framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGE_FRAMING_ERROR
block|,
literal|"CPLSW SGE framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CIM_FRAMING_ERROR
block|,
literal|"CPLSW CIM framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ZERO_SWITCH_ERROR
block|,
literal|"CPLSW no-switch error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_CAUSE
argument_list|,
name|cplsw_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LE interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|le_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
name|unsigned
name|int
name|chip_ver
init|=
name|chip_id
argument_list|(
name|adap
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|le_intr_info
index|[]
init|=
block|{
block|{
name|F_LIPMISS
block|,
literal|"LE LIP miss"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_LIP0
block|,
literal|"LE 0 LIP error"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PARITYERR
block|,
literal|"LE parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNKNOWNCMD
block|,
literal|"LE unknown command"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_REQQPARERR
block|,
literal|"LE request queue parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|t6_le_intr_info
index|[]
init|=
block|{
block|{
name|F_T6_LIPMISS
block|,
literal|"LE LIP miss"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_T6_LIP0
block|,
literal|"LE 0 LIP error"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_TCAMINTPERR
block|,
literal|"LE parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_T6_UNKNOWNCMD
block|,
literal|"LE unknown command"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SSRAMINTPERR
block|,
literal|"LE request queue parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_LE_DB_INT_CAUSE
argument_list|,
operator|(
name|chip_ver
operator|<=
name|CHELSIO_T5
operator|)
condition|?
name|le_intr_info
else|:
name|t6_le_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MPS interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mps_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|mps_rx_intr_info
index|[]
init|=
block|{
block|{
literal|0xffffff
block|,
literal|"MPS Rx parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|mps_tx_intr_info
index|[]
init|=
block|{
block|{
name|V_TPFIFO
argument_list|(
name|M_TPFIFO
argument_list|)
block|,
literal|"MPS Tx TP FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_NCSIFIFO
block|,
literal|"MPS Tx NC-SI FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_TXDATAFIFO
argument_list|(
name|M_TXDATAFIFO
argument_list|)
block|,
literal|"MPS Tx data FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_TXDESCFIFO
argument_list|(
name|M_TXDESCFIFO
argument_list|)
block|,
literal|"MPS Tx desc FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BUBBLE
block|,
literal|"MPS Tx underflow"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SECNTERR
block|,
literal|"MPS Tx SOP/EOP error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FRMERR
block|,
literal|"MPS Tx framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|mps_trc_intr_info
index|[]
init|=
block|{
block|{
name|V_FILTMEM
argument_list|(
name|M_FILTMEM
argument_list|)
block|,
literal|"MPS TRC filter parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_PKTFIFO
argument_list|(
name|M_PKTFIFO
argument_list|)
block|,
literal|"MPS TRC packet FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MISCPERR
block|,
literal|"MPS TRC misc parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|mps_stat_sram_intr_info
index|[]
init|=
block|{
block|{
literal|0x1fffff
block|,
literal|"MPS statistics SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|mps_stat_tx_intr_info
index|[]
init|=
block|{
block|{
literal|0xfffff
block|,
literal|"MPS statistics Tx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|mps_stat_rx_intr_info
index|[]
init|=
block|{
block|{
literal|0xffffff
block|,
literal|"MPS statistics Rx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|mps_cls_intr_info
index|[]
init|=
block|{
block|{
name|F_MATCHSRAM
block|,
literal|"MPS match SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MATCHTCAM
block|,
literal|"MPS match TCAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HASHSRAM
block|,
literal|"MPS hash SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|int
name|fat
decl_stmt|;
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_RX_PERR_INT_CAUSE
argument_list|,
name|mps_rx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_TX_INT_CAUSE
argument_list|,
name|mps_tx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_TRC_INT_CAUSE
argument_list|,
name|mps_trc_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_STAT_PERR_INT_CAUSE_SRAM
argument_list|,
name|mps_stat_sram_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_STAT_PERR_INT_CAUSE_TX_FIFO
argument_list|,
name|mps_stat_tx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_STAT_PERR_INT_CAUSE_RX_FIFO
argument_list|,
name|mps_stat_rx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CLS_INT_CAUSE
argument_list|,
name|mps_cls_intr_info
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
name|fat
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MEM_INT_MASK
value|(F_PERR_INT_CAUSE | F_ECC_CE_INT_CAUSE | \ 		      F_ECC_UE_INT_CAUSE)
end_define

begin_comment
comment|/*  * EDC/MC interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mem_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|name
index|[
literal|4
index|]
index|[
literal|7
index|]
init|=
block|{
literal|"EDC0"
block|,
literal|"EDC1"
block|,
literal|"MC/MC0"
block|,
literal|"MC1"
block|}
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|,
name|cnt_addr
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|idx
operator|<=
name|MEM_EDC1
condition|)
block|{
name|addr
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_INT_CAUSE
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|cnt_addr
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_ECC_STATUS
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idx
operator|==
name|MEM_MC
condition|)
block|{
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|addr
operator|=
name|A_MC_INT_CAUSE
expr_stmt|;
name|cnt_addr
operator|=
name|A_MC_ECC_STATUS
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|A_MC_P_INT_CAUSE
expr_stmt|;
name|cnt_addr
operator|=
name|A_MC_P_ECC_STATUS
expr_stmt|;
block|}
block|}
else|else
block|{
name|addr
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_INT_CAUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cnt_addr
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_ECC_STATUS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
name|MEM_INT_MASK
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|F_PERR_INT_CAUSE
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s FIFO parity error\n"
argument_list|,
name|name
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|F_ECC_CE_INT_CAUSE
condition|)
block|{
name|u32
name|cnt
init|=
name|G_ECC_CECNT
argument_list|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|cnt_addr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<=
name|MEM_EDC1
condition|)
name|t4_edc_err_read
argument_list|(
name|adapter
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|cnt_addr
argument_list|,
name|V_ECC_CECNT
argument_list|(
name|M_ECC_CECNT
argument_list|)
argument_list|)
expr_stmt|;
name|CH_WARN_RATELIMIT
argument_list|(
name|adapter
argument_list|,
literal|"%u %s correctable ECC data error%s\n"
argument_list|,
name|cnt
argument_list|,
name|name
index|[
name|idx
index|]
argument_list|,
name|cnt
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|F_ECC_UE_INT_CAUSE
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s uncorrectable ECC data error\n"
argument_list|,
name|name
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
operator|(
name|F_PERR_INT_CAUSE
operator||
name|F_ECC_UE_INT_CAUSE
operator|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MA interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ma_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|v
decl_stmt|,
name|status
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_INT_CAUSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|F_MEM_PERR_INT_CAUSE
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"MA parity error, parity status %#x\n"
argument_list|,
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_PARITY_ERROR_STATUS1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|adapter
argument_list|)
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"MA parity error, parity status %#x\n"
argument_list|,
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_PARITY_ERROR_STATUS2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|F_MEM_WRAP_INT_CAUSE
condition|)
block|{
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_INT_WRAP_STATUS
argument_list|)
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"MA address wrap-around error by "
literal|"client %u to address %#x\n"
argument_list|,
name|G_MEM_WRAP_CLIENT_NUM
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_MEM_WRAP_ADDRESS
argument_list|(
name|v
argument_list|)
operator|<<
literal|4
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_INT_CAUSE
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SMB interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|smb_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|smb_intr_info
index|[]
init|=
block|{
block|{
name|F_MSTTXFIFOPARINT
block|,
literal|"SMB master Tx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSTRXFIFOPARINT
block|,
literal|"SMB master Rx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SLVFIFOPARINT
block|,
literal|"SMB slave FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_SMB_INT_CAUSE
argument_list|,
name|smb_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NC-SI interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ncsi_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|ncsi_intr_info
index|[]
init|=
block|{
block|{
name|F_CIM_DM_PRTY_ERR
block|,
literal|"NC-SI CIM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MPS_DM_PRTY_ERR
block|,
literal|"NC-SI MPS parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TXFIFO_PRTY_ERR
block|,
literal|"NC-SI Tx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RXFIFO_PRTY_ERR
block|,
literal|"NC-SI Rx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_NCSI_INT_CAUSE
argument_list|,
name|ncsi_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XGMAC interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|xgmac_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|v
decl_stmt|,
name|int_cause_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|int_cause_reg
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_INT_CAUSE
argument_list|)
expr_stmt|;
else|else
name|int_cause_reg
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_INT_CAUSE
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|int_cause_reg
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|(
name|F_TXFIFO_PRTY_ERR
operator||
name|F_RXFIFO_PRTY_ERR
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
return|return;
if|if
condition|(
name|v
operator|&
name|F_TXFIFO_PRTY_ERR
condition|)
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"XGMAC %d Tx FIFO parity error\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|F_RXFIFO_PRTY_ERR
condition|)
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"XGMAC %d Rx FIFO parity error\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|int_cause_reg
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PL interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pl_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|intr_info
name|pl_intr_info
index|[]
init|=
block|{
block|{
name|F_FATALPERR
block|,
literal|"Fatal parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PERRVFID
block|,
literal|"PL VFID_MAP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|intr_info
name|t5_pl_intr_info
index|[]
init|=
block|{
block|{
name|F_FATALPERR
block|,
literal|"Fatal parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_PL_PL_INT_CAUSE
argument_list|,
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|pl_intr_info
else|:
name|t5_pl_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PF_INTR_MASK
value|(F_PFSW | F_PFCIM)
end_define

begin_comment
comment|/**  *	t4_slow_intr_handler - control path interrupt handler  *	@adapter: the adapter  *  *	T4 interrupt handler for non-data global interrupt events, e.g., errors.  *	The designation 'slow' is because it involves register reads, while  *	data interrupts typically don't involve any MMIOs.  */
end_comment

begin_function
name|int
name|t4_slow_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|cause
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cause
operator|&
name|GLBL_INTR_MASK
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cause
operator|&
name|F_CIM
condition|)
name|cim_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MPS
condition|)
name|mps_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_NCSI
condition|)
name|ncsi_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PL
condition|)
name|pl_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_SMB
condition|)
name|smb_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MAC0
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MAC1
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MAC2
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MAC3
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PCIE
condition|)
name|pcie_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC0
condition|)
name|mem_intr_handler
argument_list|(
name|adapter
argument_list|,
name|MEM_MC
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|adapter
argument_list|)
operator|&&
operator|(
name|cause
operator|&
name|F_MC1
operator|)
condition|)
name|mem_intr_handler
argument_list|(
name|adapter
argument_list|,
name|MEM_MC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_EDC0
condition|)
name|mem_intr_handler
argument_list|(
name|adapter
argument_list|,
name|MEM_EDC0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_EDC1
condition|)
name|mem_intr_handler
argument_list|(
name|adapter
argument_list|,
name|MEM_EDC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_LE
condition|)
name|le_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_TP
condition|)
name|tp_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MA
condition|)
name|ma_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM_TX
condition|)
name|pmtx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM_RX
condition|)
name|pmrx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP_RX
condition|)
name|ulprx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CPL_SWITCH
condition|)
name|cplsw_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_SGE
condition|)
name|sge_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP_TX
condition|)
name|ulptx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Clear the interrupts just processed for which we are the master. */
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|,
name|cause
operator|&
name|GLBL_INTR_MASK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|)
expr_stmt|;
comment|/* flush */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_intr_enable - enable interrupts  *	@adapter: the adapter whose interrupts should be enabled  *  *	Enable PF-specific interrupts for the calling function and the top-level  *	interrupt concentrator for global interrupts.  Interrupts are already  *	enabled at each module,	here we just enable the roots of the interrupt  *	hierarchies.  *  *	Note: this function should be called only when the driver manages  *	non PF-specific interrupts from the various HW modules.  Only one PCI  *	function at a time should be doing this.  */
end_comment

begin_function
name|void
name|t4_intr_enable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|val
init|=
literal|0
decl_stmt|;
name|u32
name|whoami
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_WHOAMI
argument_list|)
decl_stmt|;
name|u32
name|pf
init|=
operator|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|G_SOURCEPF
argument_list|(
name|whoami
argument_list|)
else|:
name|G_T6_SOURCEPF
argument_list|(
name|whoami
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
name|val
operator|=
name|F_ERR_DROPPED_DB
operator||
name|F_ERR_EGR_CTXT_PRIO
operator||
name|F_DBFIFO_HP_INT
expr_stmt|;
else|else
name|val
operator|=
name|F_ERR_PCIE_ERROR0
operator||
name|F_ERR_PCIE_ERROR1
operator||
name|F_FATAL_WRE_LEN
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_ENABLE3
argument_list|,
name|F_ERR_CPL_EXCEED_IQE_SIZE
operator||
name|F_ERR_INVALID_CIDX_INC
operator||
name|F_ERR_CPL_OPCODE_0
operator||
name|F_ERR_DATA_CPL_ON_HIGH_QID1
operator||
name|F_INGRESS_SIZE_ERR
operator||
name|F_ERR_DATA_CPL_ON_HIGH_QID0
operator||
name|F_ERR_BAD_DB_PIDX3
operator||
name|F_ERR_BAD_DB_PIDX2
operator||
name|F_ERR_BAD_DB_PIDX1
operator||
name|F_ERR_BAD_DB_PIDX0
operator||
name|F_ERR_ING_CTXT_PRIO
operator||
name|F_DBFIFO_LP_INT
operator||
name|F_EGRESS_SIZE_ERR
operator||
name|val
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|MYPF_REG
argument_list|(
name|A_PL_PF_INT_ENABLE
argument_list|)
argument_list|,
name|PF_INTR_MASK
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_MAP0
argument_list|,
literal|0
argument_list|,
literal|1
operator|<<
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_intr_disable - disable interrupts  *	@adapter: the adapter whose interrupts should be disabled  *  *	Disable interrupts.  We only disable the top-level interrupt  *	concentrators.  The caller must be a PCI function managing global  *	interrupts.  */
end_comment

begin_function
name|void
name|t4_intr_disable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|whoami
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_WHOAMI
argument_list|)
decl_stmt|;
name|u32
name|pf
init|=
operator|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|G_SOURCEPF
argument_list|(
name|whoami
argument_list|)
else|:
name|G_T6_SOURCEPF
argument_list|(
name|whoami
argument_list|)
operator|)
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|MYPF_REG
argument_list|(
name|A_PL_PF_INT_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_MAP0
argument_list|,
literal|1
operator|<<
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_intr_clear - clear all interrupts  *	@adapter: the adapter whose interrupts should be cleared  *  *	Clears all interrupts.  The caller must be a PCI function managing  *	global interrupts.  */
end_comment

begin_function
name|void
name|t4_intr_clear
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|cause_reg
index|[]
init|=
block|{
name|A_SGE_INT_CAUSE1
block|,
name|A_SGE_INT_CAUSE2
block|,
name|A_SGE_INT_CAUSE3
block|,
name|A_PCIE_NONFAT_ERR
block|,
name|A_PCIE_INT_CAUSE
block|,
name|A_MA_INT_WRAP_STATUS
block|,
name|A_MA_PARITY_ERROR_STATUS1
block|,
name|A_MA_INT_CAUSE
block|,
name|A_EDC_INT_CAUSE
block|,
name|EDC_REG
argument_list|(
name|A_EDC_INT_CAUSE
argument_list|,
literal|1
argument_list|)
block|,
name|A_CIM_HOST_INT_CAUSE
block|,
name|A_CIM_HOST_UPACC_INT_CAUSE
block|,
name|MYPF_REG
argument_list|(
name|A_CIM_PF_HOST_INT_CAUSE
argument_list|)
block|,
name|A_TP_INT_CAUSE
block|,
name|A_ULP_RX_INT_CAUSE
block|,
name|A_ULP_TX_INT_CAUSE
block|,
name|A_PM_RX_INT_CAUSE
block|,
name|A_PM_TX_INT_CAUSE
block|,
name|A_MPS_RX_PERR_INT_CAUSE
block|,
name|A_CPL_INTR_CAUSE
block|,
name|MYPF_REG
argument_list|(
name|A_PL_PF_INT_CAUSE
argument_list|)
block|,
name|A_PL_PL_INT_CAUSE
block|,
name|A_LE_DB_INT_CAUSE
block|, 	}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cause_reg
argument_list|)
condition|;
operator|++
name|i
control|)
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|cause_reg
index|[
name|i
index|]
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|?
name|A_MC_INT_CAUSE
else|:
name|A_MC_P_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_PARITY_ERROR_STATUS2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|,
name|GLBL_INTR_MASK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	hash_mac_addr - return the hash value of a MAC address  *	@addr: the 48-bit Ethernet MAC address  *  *	Hashes a MAC address according to the hash function used by HW inexact  *	(hash) address matching.  */
end_comment

begin_function
specifier|static
name|int
name|hash_mac_addr
parameter_list|(
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|u32
name|a
init|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|b
init|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
decl_stmt|;
name|a
operator|^=
name|b
expr_stmt|;
name|a
operator|^=
operator|(
name|a
operator|>>
literal|12
operator|)
expr_stmt|;
name|a
operator|^=
operator|(
name|a
operator|>>
literal|6
operator|)
expr_stmt|;
return|return
name|a
operator|&
literal|0x3f
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_config_rss_range - configure a portion of the RSS mapping table  *	@adapter: the adapter  *	@mbox: mbox to use for the FW command  *	@viid: virtual interface whose RSS subtable is to be written  *	@start: start entry in the table to write  *	@n: how many table entries to write  *	@rspq: values for the "response queue" (Ingress Queue) lookup table  *	@nrspq: number of values in @rspq  *  *	Programs the selected part of the VI's RSS mapping table with the  *	provided values.  If @nrspq< @n the supplied values are used repeatedly  *	until the full table range is populated.  *  *	The caller must ensure the values in @rspq are in the range allowed for  *	@viid.  */
end_comment

begin_function
name|int
name|t4_config_rss_range
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|u16
modifier|*
name|rspq
parameter_list|,
name|unsigned
name|int
name|nrspq
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|const
name|u16
modifier|*
name|rsp
init|=
name|rspq
decl_stmt|;
specifier|const
name|u16
modifier|*
name|rsp_end
init|=
name|rspq
operator|+
name|nrspq
decl_stmt|;
name|struct
name|fw_rss_ind_tbl_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RSS_IND_TBL_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_RSS_IND_TBL_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Each firmware RSS command can accommodate up to 32 RSS Ingress 	 * Queue Identifiers.  These Ingress Queue IDs are packed three to 	 * a 32-bit word as 10-bit values with the upper remaining 2 bits 	 * reserved. 	 */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|nq
init|=
name|min
argument_list|(
name|n
argument_list|,
literal|32
argument_list|)
decl_stmt|;
name|int
name|nq_packed
init|=
literal|0
decl_stmt|;
name|__be32
modifier|*
name|qp
init|=
operator|&
name|cmd
operator|.
name|iq0_to_iq2
decl_stmt|;
comment|/* 		 * Set up the firmware RSS command header to send the next 		 * "nq" Ingress Queue IDs to the firmware. 		 */
name|cmd
operator|.
name|niqid
operator|=
name|cpu_to_be16
argument_list|(
name|nq
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|startidx
operator|=
name|cpu_to_be16
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|/* 		 * "nq" more done for the start of the next loop. 		 */
name|start
operator|+=
name|nq
expr_stmt|;
name|n
operator|-=
name|nq
expr_stmt|;
comment|/* 		 * While there are still Ingress Queue IDs to stuff into the 		 * current firmware RSS command, retrieve them from the 		 * Ingress Queue ID array and insert them into the command. 		 */
while|while
condition|(
name|nq
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Grab up to the next 3 Ingress Queue IDs (wrapping 			 * around the Ingress Queue ID array if necessary) and 			 * insert them into the firmware RSS command at the 			 * current 3-tuple position within the commad. 			 */
name|u16
name|qbuf
index|[
literal|3
index|]
decl_stmt|;
name|u16
modifier|*
name|qbp
init|=
name|qbuf
decl_stmt|;
name|int
name|nqbuf
init|=
name|min
argument_list|(
literal|3
argument_list|,
name|nq
argument_list|)
decl_stmt|;
name|nq
operator|-=
name|nqbuf
expr_stmt|;
name|qbuf
index|[
literal|0
index|]
operator|=
name|qbuf
index|[
literal|1
index|]
operator|=
name|qbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nqbuf
operator|&&
name|nq_packed
operator|<
literal|32
condition|)
block|{
name|nqbuf
operator|--
expr_stmt|;
name|nq_packed
operator|++
expr_stmt|;
operator|*
name|qbp
operator|++
operator|=
operator|*
name|rsp
operator|++
expr_stmt|;
if|if
condition|(
name|rsp
operator|>=
name|rsp_end
condition|)
name|rsp
operator|=
name|rspq
expr_stmt|;
block|}
operator|*
name|qp
operator|++
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_RSS_IND_TBL_CMD_IQ0
argument_list|(
name|qbuf
index|[
literal|0
index|]
argument_list|)
operator||
name|V_FW_RSS_IND_TBL_CMD_IQ1
argument_list|(
name|qbuf
index|[
literal|1
index|]
argument_list|)
operator||
name|V_FW_RSS_IND_TBL_CMD_IQ2
argument_list|(
name|qbuf
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Send this portion of the RRS table update to the firmware; 		 * bail out on any errors. 		 */
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_config_glbl_rss - configure the global RSS mode  *	@adapter: the adapter  *	@mbox: mbox to use for the FW command  *	@mode: global RSS mode  *	@flags: mode-specific flags  *  *	Sets the global RSS mode.  */
end_comment

begin_function
name|int
name|t4_config_glbl_rss
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|struct
name|fw_rss_glb_config_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RSS_GLB_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|FW_RSS_GLB_CONFIG_CMD_MODE_MANUAL
condition|)
block|{
name|c
operator|.
name|u
operator|.
name|manual
operator|.
name|mode_pkd
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_RSS_GLB_CONFIG_CMD_MODE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL
condition|)
block|{
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|mode_keymode
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_RSS_GLB_CONFIG_CMD_MODE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|synmapen_to_hashtoeplitz
operator|=
name|cpu_to_be32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
name|EINVAL
return|;
return|return
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_config_vi_rss - configure per VI RSS settings  *	@adapter: the adapter  *	@mbox: mbox to use for the FW command  *	@viid: the VI id  *	@flags: RSS flags  *	@defq: id of the default RSS queue for the VI.  *	@skeyidx: RSS secret key table index for non-global mode  *	@skey: RSS vf_scramble key for VI.  *  *	Configures VI-specific RSS properties.  */
end_comment

begin_function
name|int
name|t4_config_vi_rss
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|defq
parameter_list|,
name|unsigned
name|int
name|skeyidx
parameter_list|,
name|unsigned
name|int
name|skey
parameter_list|)
block|{
name|struct
name|fw_rss_vi_config_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RSS_VI_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_RSS_VI_CONFIG_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|defaultq_to_udpen
operator|=
name|cpu_to_be32
argument_list|(
name|flags
operator||
name|V_FW_RSS_VI_CONFIG_CMD_DEFAULTQ
argument_list|(
name|defq
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|secretkeyidx_pkd
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_RSS_VI_CONFIG_CMD_SECRETKEYIDX
argument_list|(
name|skeyidx
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|secretkeyxor
operator|=
name|cpu_to_be32
argument_list|(
name|skey
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read an RSS table row */
end_comment

begin_function
specifier|static
name|int
name|rd_rss_row
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|row
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
literal|0xfff00000
operator||
name|row
argument_list|)
expr_stmt|;
return|return
name|t4_wait_op_done_val
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
name|F_LKPTBLROWVLD
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss - read the contents of the RSS mapping table  *	@adapter: the adapter  *	@map: holds the contents of the RSS mapping table  *  *	Reads the contents of the RSS hash->queue mapping table.  */
end_comment

begin_function
name|int
name|t4_read_rss
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u16
modifier|*
name|map
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_NENTRIES
operator|/
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
name|rd_rss_row
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
operator|*
name|map
operator|++
operator|=
name|G_LKPTBLQUEUE0
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|map
operator|++
operator|=
name|G_LKPTBLQUEUE1
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * t4_tp_fw_ldst_rw - Access TP indirect register through LDST  * @adap: the adapter  * @cmd: TP fw ldst address space type  * @vals: where the indirect register values are stored/written  * @nregs: how many indirect registers to read/write  * @start_idx: index of first indirect register to read/write  * @rw: Read (1) or Write (0)  * @sleep_ok: if true we may sleep while awaiting command completion  *  * Access TP indirect registers through LDST  **/
end_comment

begin_function
specifier|static
name|int
name|t4_tp_fw_ldst_rw
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u32
modifier|*
name|vals
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|unsigned
name|int
name|start_index
parameter_list|,
name|unsigned
name|int
name|rw
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
operator|(
name|rw
condition|?
name|F_FW_CMD_READ
else|:
name|F_FW_CMD_WRITE
operator|)
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|addrval
operator|.
name|addr
operator|=
name|cpu_to_be32
argument_list|(
name|start_index
operator|+
name|i
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|addrval
operator|.
name|val
operator|=
name|rw
condition|?
literal|0
else|:
name|cpu_to_be32
argument_list|(
name|vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox_meat
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|rw
condition|)
name|vals
index|[
name|i
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|addrval
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * t4_tp_indirect_rw - Read/Write TP indirect register through LDST or backdoor  * @adap: the adapter  * @reg_addr: Address Register  * @reg_data: Data register  * @buff: where the indirect register values are stored/written  * @nregs: how many indirect registers to read/write  * @start_index: index of first indirect register to read/write  * @rw: READ(1) or WRITE(0)  * @sleep_ok: if true we may sleep while awaiting command completion  *  * Read/Write TP indirect registers through LDST if possible.  * Else, use backdoor access  **/
end_comment

begin_function
specifier|static
name|void
name|t4_tp_indirect_rw
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|reg_data
parameter_list|,
name|u32
modifier|*
name|buff
parameter_list|,
name|u32
name|nregs
parameter_list|,
name|u32
name|start_index
parameter_list|,
name|int
name|rw
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|rc
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|cmd
decl_stmt|;
switch|switch
condition|(
name|reg_addr
condition|)
block|{
case|case
name|A_TP_PIO_ADDR
case|:
name|cmd
operator|=
name|FW_LDST_ADDRSPC_TP_PIO
expr_stmt|;
break|break;
case|case
name|A_TP_TM_PIO_ADDR
case|:
name|cmd
operator|=
name|FW_LDST_ADDRSPC_TP_TM_PIO
expr_stmt|;
break|break;
case|case
name|A_TP_MIB_INDEX
case|:
name|cmd
operator|=
name|FW_LDST_ADDRSPC_TP_MIB
expr_stmt|;
break|break;
default|default:
goto|goto
name|indirect_access
goto|;
block|}
if|if
condition|(
name|t4_use_ldst
argument_list|(
name|adap
argument_list|)
condition|)
name|rc
operator|=
name|t4_tp_fw_ldst_rw
argument_list|(
name|adap
argument_list|,
name|cmd
argument_list|,
name|buff
argument_list|,
name|nregs
argument_list|,
name|start_index
argument_list|,
name|rw
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|indirect_access
label|:
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|rw
condition|)
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|reg_addr
argument_list|,
name|reg_data
argument_list|,
name|buff
argument_list|,
name|nregs
argument_list|,
name|start_index
argument_list|)
expr_stmt|;
else|else
name|t4_write_indirect
argument_list|(
name|adap
argument_list|,
name|reg_addr
argument_list|,
name|reg_data
argument_list|,
name|buff
argument_list|,
name|nregs
argument_list|,
name|start_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * t4_tp_pio_read - Read TP PIO registers  * @adap: the adapter  * @buff: where the indirect register values are written  * @nregs: how many indirect registers to read  * @start_index: index of first indirect register to read  * @sleep_ok: if true we may sleep while awaiting command completion  *  * Read TP PIO Registers  **/
end_comment

begin_function
name|void
name|t4_tp_pio_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|buff
parameter_list|,
name|u32
name|nregs
parameter_list|,
name|u32
name|start_index
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_indirect_rw
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|buff
argument_list|,
name|nregs
argument_list|,
name|start_index
argument_list|,
literal|1
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * t4_tp_pio_write - Write TP PIO registers  * @adap: the adapter  * @buff: where the indirect register values are stored  * @nregs: how many indirect registers to write  * @start_index: index of first indirect register to write  * @sleep_ok: if true we may sleep while awaiting command completion  *  * Write TP PIO Registers  **/
end_comment

begin_function
name|void
name|t4_tp_pio_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u32
modifier|*
name|buff
parameter_list|,
name|u32
name|nregs
parameter_list|,
name|u32
name|start_index
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_indirect_rw
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|__DECONST
argument_list|(
name|u32
operator|*
argument_list|,
name|buff
argument_list|)
argument_list|,
name|nregs
argument_list|,
name|start_index
argument_list|,
literal|0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * t4_tp_tm_pio_read - Read TP TM PIO registers  * @adap: the adapter  * @buff: where the indirect register values are written  * @nregs: how many indirect registers to read  * @start_index: index of first indirect register to read  * @sleep_ok: if true we may sleep while awaiting command completion  *  * Read TP TM PIO Registers  **/
end_comment

begin_function
name|void
name|t4_tp_tm_pio_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|buff
parameter_list|,
name|u32
name|nregs
parameter_list|,
name|u32
name|start_index
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_indirect_rw
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|buff
argument_list|,
name|nregs
argument_list|,
name|start_index
argument_list|,
literal|1
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * t4_tp_mib_read - Read TP MIB registers  * @adap: the adapter  * @buff: where the indirect register values are written  * @nregs: how many indirect registers to read  * @start_index: index of first indirect register to read  * @sleep_ok: if true we may sleep while awaiting command completion  *  * Read TP MIB Registers  **/
end_comment

begin_function
name|void
name|t4_tp_mib_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|buff
parameter_list|,
name|u32
name|nregs
parameter_list|,
name|u32
name|start_index
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_indirect_rw
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|buff
argument_list|,
name|nregs
argument_list|,
name|start_index
argument_list|,
literal|1
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_key - read the global RSS key  *	@adap: the adapter  *	@key: 10-entry array holding the 320-bit RSS key  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Reads the global 320-bit RSS key.  */
end_comment

begin_function
name|void
name|t4_read_rss_key
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|key
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_pio_read
argument_list|(
name|adap
argument_list|,
name|key
argument_list|,
literal|10
argument_list|,
name|A_TP_RSS_SECRET_KEY0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_key - program one of the RSS keys  *	@adap: the adapter  *	@key: 10-entry array holding the 320-bit RSS key  *	@idx: which RSS key to write  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Writes one of the RSS keys with the given 320-bit value.  If @idx is  *	0..15 the corresponding entry in the RSS key table is written,  *	otherwise the global RSS key is written.  */
end_comment

begin_function
name|void
name|t4_write_rss_key
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u32
modifier|*
name|key
parameter_list|,
name|int
name|idx
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u8
name|rss_key_addr_cnt
init|=
literal|16
decl_stmt|;
name|u32
name|vrt
init|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|)
decl_stmt|;
comment|/* 	 * T6 and later: for KeyMode 3 (per-vf and per-vf scramble), 	 * allows access to key addresses 16-63 by using KeyWrAddrX 	 * as index[5:4](upper 2) into key table 	 */
if|if
condition|(
operator|(
name|chip_id
argument_list|(
name|adap
argument_list|)
operator|>
name|CHELSIO_T5
operator|)
operator|&&
operator|(
name|vrt
operator|&
name|F_KEYEXTEND
operator|)
operator|&&
operator|(
name|G_KEYMODE
argument_list|(
name|vrt
argument_list|)
operator|==
literal|3
operator|)
condition|)
name|rss_key_addr_cnt
operator|=
literal|32
expr_stmt|;
name|t4_tp_pio_write
argument_list|(
name|adap
argument_list|,
name|key
argument_list|,
literal|10
argument_list|,
name|A_TP_RSS_SECRET_KEY0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|rss_key_addr_cnt
condition|)
block|{
if|if
condition|(
name|rss_key_addr_cnt
operator|>
literal|16
condition|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|,
name|vrt
operator||
name|V_KEYWRADDRX
argument_list|(
name|idx
operator|>>
literal|4
argument_list|)
operator||
name|V_T6_VFWRADDR
argument_list|(
name|idx
argument_list|)
operator||
name|F_KEYWREN
argument_list|)
expr_stmt|;
else|else
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|,
name|vrt
operator||
name|V_KEYWRADDR
argument_list|(
name|idx
argument_list|)
operator||
name|F_KEYWREN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_pf_config - read PF RSS Configuration Table  *	@adapter: the adapter  *	@index: the entry in the PF RSS table to read  *	@valp: where to store the returned value  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Reads the PF RSS Configuration Table at the specified index and returns  *	the value found there.  */
end_comment

begin_function
name|void
name|t4_read_rss_pf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_pio_read
argument_list|(
name|adapter
argument_list|,
name|valp
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF0_CONFIG
operator|+
name|index
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_pf_config - write PF RSS Configuration Table  *	@adapter: the adapter  *	@index: the entry in the VF RSS table to read  *	@val: the value to store  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Writes the PF RSS Configuration Table at the specified index with the  *	specified value.  */
end_comment

begin_function
name|void
name|t4_write_rss_pf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|val
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_pio_write
argument_list|(
name|adapter
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF0_CONFIG
operator|+
name|index
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_vf_config - read VF RSS Configuration Table  *	@adapter: the adapter  *	@index: the entry in the VF RSS table to read  *	@vfl: where to store the returned VFL  *	@vfh: where to store the returned VFH  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Reads the VF RSS Configuration Table at the specified index and returns  *	the (VFL, VFH) values found there.  */
end_comment

begin_function
name|void
name|t4_read_rss_vf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
modifier|*
name|vfl
parameter_list|,
name|u32
modifier|*
name|vfh
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u32
name|vrt
decl_stmt|,
name|mask
decl_stmt|,
name|data
decl_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
block|{
name|mask
operator|=
name|V_VFWRADDR
argument_list|(
name|M_VFWRADDR
argument_list|)
expr_stmt|;
name|data
operator|=
name|V_VFWRADDR
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|V_T6_VFWRADDR
argument_list|(
name|M_T6_VFWRADDR
argument_list|)
expr_stmt|;
name|data
operator|=
name|V_T6_VFWRADDR
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Request that the index'th VF Table values be read into VFL/VFH. 	 */
name|vrt
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|)
expr_stmt|;
name|vrt
operator|&=
operator|~
operator|(
name|F_VFRDRG
operator||
name|F_VFWREN
operator||
name|F_KEYWREN
operator||
name|mask
operator|)
expr_stmt|;
name|vrt
operator||=
name|data
operator||
name|F_VFRDEN
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|,
name|vrt
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the VFL/VFH values ... 	 */
name|t4_tp_pio_read
argument_list|(
name|adapter
argument_list|,
name|vfl
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFL_CONFIG
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_pio_read
argument_list|(
name|adapter
argument_list|,
name|vfh
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFH_CONFIG
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_vf_config - write VF RSS Configuration Table  *  *	@adapter: the adapter  *	@index: the entry in the VF RSS table to write  *	@vfl: the VFL to store  *	@vfh: the VFH to store  *  *	Writes the VF RSS Configuration Table at the specified index with the  *	specified (VFL, VFH) values.  */
end_comment

begin_function
name|void
name|t4_write_rss_vf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|vfl
parameter_list|,
name|u32
name|vfh
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u32
name|vrt
decl_stmt|,
name|mask
decl_stmt|,
name|data
decl_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
block|{
name|mask
operator|=
name|V_VFWRADDR
argument_list|(
name|M_VFWRADDR
argument_list|)
expr_stmt|;
name|data
operator|=
name|V_VFWRADDR
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|V_T6_VFWRADDR
argument_list|(
name|M_T6_VFWRADDR
argument_list|)
expr_stmt|;
name|data
operator|=
name|V_T6_VFWRADDR
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Load up VFL/VFH with the values to be written ... 	 */
name|t4_tp_pio_write
argument_list|(
name|adapter
argument_list|,
operator|&
name|vfl
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFL_CONFIG
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_pio_write
argument_list|(
name|adapter
argument_list|,
operator|&
name|vfh
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFH_CONFIG
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
comment|/* 	 * Write the VFL/VFH into the VF Table at index'th location. 	 */
name|vrt
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|)
expr_stmt|;
name|vrt
operator|&=
operator|~
operator|(
name|F_VFRDRG
operator||
name|F_VFWREN
operator||
name|F_KEYWREN
operator||
name|mask
operator|)
expr_stmt|;
name|vrt
operator||=
name|data
operator||
name|F_VFRDEN
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|,
name|vrt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_pf_map - read PF RSS Map  *	@adapter: the adapter  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Reads the PF RSS Map register and returns its value.  */
end_comment

begin_function
name|u32
name|t4_read_rss_pf_map
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u32
name|pfmap
decl_stmt|;
name|t4_tp_pio_read
argument_list|(
name|adapter
argument_list|,
operator|&
name|pfmap
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MAP
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
return|return
name|pfmap
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_pf_map - write PF RSS Map  *	@adapter: the adapter  *	@pfmap: PF RSS Map value  *  *	Writes the specified value to the PF RSS Map register.  */
end_comment

begin_function
name|void
name|t4_write_rss_pf_map
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|pfmap
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_pio_write
argument_list|(
name|adapter
argument_list|,
operator|&
name|pfmap
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MAP
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_pf_mask - read PF RSS Mask  *	@adapter: the adapter  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Reads the PF RSS Mask register and returns its value.  */
end_comment

begin_function
name|u32
name|t4_read_rss_pf_mask
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u32
name|pfmask
decl_stmt|;
name|t4_tp_pio_read
argument_list|(
name|adapter
argument_list|,
operator|&
name|pfmask
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MSK
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
return|return
name|pfmask
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_pf_mask - write PF RSS Mask  *	@adapter: the adapter  *	@pfmask: PF RSS Mask value  *  *	Writes the specified value to the PF RSS Mask register.  */
end_comment

begin_function
name|void
name|t4_write_rss_pf_mask
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|pfmask
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_pio_write
argument_list|(
name|adapter
argument_list|,
operator|&
name|pfmask
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MSK
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_tcp_stats - read TP's TCP MIB counters  *	@adap: the adapter  *	@v4: holds the TCP/IP counter values  *	@v6: holds the TCP/IPv6 counter values  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Returns the values of TP's TCP/IP and TCP/IPv6 MIB counters.  *	Either @v4 or @v6 may be %NULL to skip the corresponding stats.  */
end_comment

begin_function
name|void
name|t4_tp_get_tcp_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_tcp_stats
modifier|*
name|v4
parameter_list|,
name|struct
name|tp_tcp_stats
modifier|*
name|v6
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u32
name|val
index|[
name|A_TP_MIB_TCP_RXT_SEG_LO
operator|-
name|A_TP_MIB_TCP_OUT_RST
operator|+
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|STAT_IDX
parameter_list|(
name|x
parameter_list|)
value|((A_TP_MIB_TCP_##x) - A_TP_MIB_TCP_OUT_RST)
define|#
directive|define
name|STAT
parameter_list|(
name|x
parameter_list|)
value|val[STAT_IDX(x)]
define|#
directive|define
name|STAT64
parameter_list|(
name|x
parameter_list|)
value|(((u64)STAT(x##_HI)<< 32) | STAT(x##_LO))
if|if
condition|(
name|v4
condition|)
block|{
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|val
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|val
argument_list|)
argument_list|,
name|A_TP_MIB_TCP_OUT_RST
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcp_out_rsts
operator|=
name|STAT
argument_list|(
name|OUT_RST
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcp_in_segs
operator|=
name|STAT64
argument_list|(
name|IN_SEG
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcp_out_segs
operator|=
name|STAT64
argument_list|(
name|OUT_SEG
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcp_retrans_segs
operator|=
name|STAT64
argument_list|(
name|RXT_SEG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v6
condition|)
block|{
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|val
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|val
argument_list|)
argument_list|,
name|A_TP_MIB_TCP_V6OUT_RST
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcp_out_rsts
operator|=
name|STAT
argument_list|(
name|OUT_RST
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcp_in_segs
operator|=
name|STAT64
argument_list|(
name|IN_SEG
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcp_out_segs
operator|=
name|STAT64
argument_list|(
name|OUT_SEG
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcp_retrans_segs
operator|=
name|STAT64
argument_list|(
name|RXT_SEG
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|STAT64
undef|#
directive|undef
name|STAT
undef|#
directive|undef
name|STAT_IDX
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_err_stats - read TP's error MIB counters  *	@adap: the adapter  *	@st: holds the counter values  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Returns the values of TP's error counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_err_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_err_stats
modifier|*
name|st
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|nchan
init|=
name|adap
operator|->
name|chip_params
operator|->
name|nchan
decl_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|mac_in_errs
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_MAC_IN_ERR_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|hdr_in_errs
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_HDR_IN_ERR_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|tcp_in_errs
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_TCP_IN_ERR_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|tnl_cong_drops
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_TNL_CNG_DROP_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|ofld_chan_drops
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_OFD_CHN_DROP_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|tnl_tx_drops
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_TNL_DROP_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|ofld_vlan_drops
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_OFD_VLN_DROP_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|tcp6_in_errs
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_TCP_V6IN_ERR_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
operator|&
name|st
operator|->
name|ofld_no_neigh
argument_list|,
literal|2
argument_list|,
name|A_TP_MIB_OFD_ARP_DROP
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_proxy_stats - read TP's proxy MIB counters  *	@adap: the adapter  *	@st: holds the counter values  *  *	Returns the values of TP's proxy counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_proxy_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_proxy_stats
modifier|*
name|st
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|nchan
init|=
name|adap
operator|->
name|chip_params
operator|->
name|nchan
decl_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|proxy
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_TNL_LPBK_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_cpl_stats - read TP's CPL MIB counters  *	@adap: the adapter  *	@st: holds the counter values  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Returns the values of TP's CPL counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_cpl_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_cpl_stats
modifier|*
name|st
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|nchan
init|=
name|adap
operator|->
name|chip_params
operator|->
name|nchan
decl_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|req
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_CPL_IN_REQ_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|st
operator|->
name|rsp
argument_list|,
name|nchan
argument_list|,
name|A_TP_MIB_CPL_OUT_RSP_0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_rdma_stats - read TP's RDMA MIB counters  *	@adap: the adapter  *	@st: holds the counter values  *  *	Returns the values of TP's RDMA counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_rdma_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_rdma_stats
modifier|*
name|st
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
operator|&
name|st
operator|->
name|rqe_dfr_pkt
argument_list|,
literal|2
argument_list|,
name|A_TP_MIB_RQE_DFR_PKT
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_fcoe_stats - read TP's FCoE MIB counters for a port  *	@adap: the adapter  *	@idx: the port index  *	@st: holds the counter values  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Returns the values of TP's FCoE counters for the selected port.  */
end_comment

begin_function
name|void
name|t4_get_fcoe_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|struct
name|tp_fcoe_stats
modifier|*
name|st
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u32
name|val
index|[
literal|2
index|]
decl_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
operator|&
name|st
operator|->
name|frames_ddp
argument_list|,
literal|1
argument_list|,
name|A_TP_MIB_FCOE_DDP_0
operator|+
name|idx
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
operator|&
name|st
operator|->
name|frames_drop
argument_list|,
literal|1
argument_list|,
name|A_TP_MIB_FCOE_DROP_0
operator|+
name|idx
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|val
argument_list|,
literal|2
argument_list|,
name|A_TP_MIB_FCOE_BYTE_0_HI
operator|+
literal|2
operator|*
name|idx
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|st
operator|->
name|octets_ddp
operator|=
operator|(
operator|(
name|u64
operator|)
name|val
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator||
name|val
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_usm_stats - read TP's non-TCP DDP MIB counters  *	@adap: the adapter  *	@st: holds the counter values  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Returns the values of TP's counters for non-TCP directly-placed packets.  */
end_comment

begin_function
name|void
name|t4_get_usm_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_usm_stats
modifier|*
name|st
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|u32
name|val
index|[
literal|4
index|]
decl_stmt|;
name|t4_tp_mib_read
argument_list|(
name|adap
argument_list|,
name|val
argument_list|,
literal|4
argument_list|,
name|A_TP_MIB_USM_PKTS
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|st
operator|->
name|frames
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|->
name|drops
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|st
operator|->
name|octets
operator|=
operator|(
operator|(
name|u64
operator|)
name|val
index|[
literal|2
index|]
operator|<<
literal|32
operator|)
operator||
name|val
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_mtu_tbl - returns the values in the HW path MTU table  *	@adap: the adapter  *	@mtus: where to store the MTU values  *	@mtu_log: where to store the MTU base-2 log (may be %NULL)  *  *	Reads the HW path MTU table.  */
end_comment

begin_function
name|void
name|t4_read_mtu_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u16
modifier|*
name|mtus
parameter_list|,
name|u8
modifier|*
name|mtu_log
parameter_list|)
block|{
name|u32
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
name|V_MTUINDEX
argument_list|(
literal|0xff
argument_list|)
operator||
name|V_MTUVALUE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|)
expr_stmt|;
name|mtus
index|[
name|i
index|]
operator|=
name|G_MTUVALUE
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu_log
condition|)
name|mtu_log
index|[
name|i
index|]
operator|=
name|G_MTUWIDTH
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_cong_tbl - reads the congestion control table  *	@adap: the adapter  *	@incr: where to store the alpha values  *  *	Reads the additive increments programmed into the HW congestion  *	control table.  */
end_comment

begin_function
name|void
name|t4_read_cong_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u16
name|incr
index|[
name|NMTUS
index|]
index|[
name|NCCTRL_WIN
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|mtu
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|mtu
operator|=
literal|0
init|;
name|mtu
operator|<
name|NMTUS
condition|;
operator|++
name|mtu
control|)
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
name|V_ROWINDEX
argument_list|(
literal|0xffff
argument_list|)
operator||
operator|(
name|mtu
operator|<<
literal|5
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
name|incr
index|[
name|mtu
index|]
index|[
name|w
index|]
operator|=
operator|(
name|u16
operator|)
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|)
operator|&
literal|0x1fff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_tp_wr_bits_indirect - set/clear bits in an indirect TP register  *	@adap: the adapter  *	@addr: the indirect TP register address  *	@mask: specifies the field within the register to modify  *	@val: new value for the field  *  *	Sets a field of an indirect TP register to the given value.  */
end_comment

begin_function
name|void
name|t4_tp_wr_bits_indirect
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator||=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	init_cong_ctrl - initialize congestion control parameters  *	@a: the alpha values for congestion control  *	@b: the beta values for congestion control  *  *	Initialize the congestion control parameters.  */
end_comment

begin_function
specifier|static
name|void
name|init_cong_ctrl
parameter_list|(
name|unsigned
name|short
modifier|*
name|a
parameter_list|,
name|unsigned
name|short
modifier|*
name|b
parameter_list|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|2
index|]
operator|=
name|a
index|[
literal|3
index|]
operator|=
name|a
index|[
literal|4
index|]
operator|=
name|a
index|[
literal|5
index|]
operator|=
name|a
index|[
literal|6
index|]
operator|=
name|a
index|[
literal|7
index|]
operator|=
name|a
index|[
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|a
index|[
literal|9
index|]
operator|=
literal|2
expr_stmt|;
name|a
index|[
literal|10
index|]
operator|=
literal|3
expr_stmt|;
name|a
index|[
literal|11
index|]
operator|=
literal|4
expr_stmt|;
name|a
index|[
literal|12
index|]
operator|=
literal|5
expr_stmt|;
name|a
index|[
literal|13
index|]
operator|=
literal|6
expr_stmt|;
name|a
index|[
literal|14
index|]
operator|=
literal|7
expr_stmt|;
name|a
index|[
literal|15
index|]
operator|=
literal|8
expr_stmt|;
name|a
index|[
literal|16
index|]
operator|=
literal|9
expr_stmt|;
name|a
index|[
literal|17
index|]
operator|=
literal|10
expr_stmt|;
name|a
index|[
literal|18
index|]
operator|=
literal|14
expr_stmt|;
name|a
index|[
literal|19
index|]
operator|=
literal|17
expr_stmt|;
name|a
index|[
literal|20
index|]
operator|=
literal|21
expr_stmt|;
name|a
index|[
literal|21
index|]
operator|=
literal|25
expr_stmt|;
name|a
index|[
literal|22
index|]
operator|=
literal|30
expr_stmt|;
name|a
index|[
literal|23
index|]
operator|=
literal|35
expr_stmt|;
name|a
index|[
literal|24
index|]
operator|=
literal|45
expr_stmt|;
name|a
index|[
literal|25
index|]
operator|=
literal|60
expr_stmt|;
name|a
index|[
literal|26
index|]
operator|=
literal|80
expr_stmt|;
name|a
index|[
literal|27
index|]
operator|=
literal|100
expr_stmt|;
name|a
index|[
literal|28
index|]
operator|=
literal|200
expr_stmt|;
name|a
index|[
literal|29
index|]
operator|=
literal|300
expr_stmt|;
name|a
index|[
literal|30
index|]
operator|=
literal|400
expr_stmt|;
name|a
index|[
literal|31
index|]
operator|=
literal|500
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|2
index|]
operator|=
name|b
index|[
literal|3
index|]
operator|=
name|b
index|[
literal|4
index|]
operator|=
name|b
index|[
literal|5
index|]
operator|=
name|b
index|[
literal|6
index|]
operator|=
name|b
index|[
literal|7
index|]
operator|=
name|b
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|b
index|[
literal|9
index|]
operator|=
name|b
index|[
literal|10
index|]
operator|=
literal|1
expr_stmt|;
name|b
index|[
literal|11
index|]
operator|=
name|b
index|[
literal|12
index|]
operator|=
literal|2
expr_stmt|;
name|b
index|[
literal|13
index|]
operator|=
name|b
index|[
literal|14
index|]
operator|=
name|b
index|[
literal|15
index|]
operator|=
name|b
index|[
literal|16
index|]
operator|=
literal|3
expr_stmt|;
name|b
index|[
literal|17
index|]
operator|=
name|b
index|[
literal|18
index|]
operator|=
name|b
index|[
literal|19
index|]
operator|=
name|b
index|[
literal|20
index|]
operator|=
name|b
index|[
literal|21
index|]
operator|=
literal|4
expr_stmt|;
name|b
index|[
literal|22
index|]
operator|=
name|b
index|[
literal|23
index|]
operator|=
name|b
index|[
literal|24
index|]
operator|=
name|b
index|[
literal|25
index|]
operator|=
name|b
index|[
literal|26
index|]
operator|=
name|b
index|[
literal|27
index|]
operator|=
literal|5
expr_stmt|;
name|b
index|[
literal|28
index|]
operator|=
name|b
index|[
literal|29
index|]
operator|=
literal|6
expr_stmt|;
name|b
index|[
literal|30
index|]
operator|=
name|b
index|[
literal|31
index|]
operator|=
literal|7
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The minimum additive increment value for the congestion control table */
end_comment

begin_define
define|#
directive|define
name|CC_MIN_INCR
value|2U
end_define

begin_comment
comment|/**  *	t4_load_mtus - write the MTU and congestion control HW tables  *	@adap: the adapter  *	@mtus: the values for the MTU table  *	@alpha: the values for the congestion control alpha parameter  *	@beta: the values for the congestion control beta parameter  *  *	Write the HW MTU table with the supplied MTUs and the high-speed  *	congestion control table with the supplied alpha, beta, and MTUs.  *	We write the two tables together because the additive increments  *	depend on the MTUs.  */
end_comment

begin_function
name|void
name|t4_load_mtus
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|mtus
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|alpha
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|beta
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|avg_pkts
index|[
name|NCCTRL_WIN
index|]
init|=
block|{
literal|2
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|20
block|,
literal|28
block|,
literal|40
block|,
literal|56
block|,
literal|80
block|,
literal|112
block|,
literal|160
block|,
literal|224
block|,
literal|320
block|,
literal|448
block|,
literal|640
block|,
literal|896
block|,
literal|1281
block|,
literal|1792
block|,
literal|2560
block|,
literal|3584
block|,
literal|5120
block|,
literal|7168
block|,
literal|10240
block|,
literal|14336
block|,
literal|20480
block|,
literal|28672
block|,
literal|40960
block|,
literal|57344
block|,
literal|81920
block|,
literal|114688
block|,
literal|163840
block|,
literal|229376
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|mtu
init|=
name|mtus
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|log2
init|=
name|fls
argument_list|(
name|mtu
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtu
operator|&
operator|(
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|>>
literal|2
operator|)
operator|)
condition|)
comment|/* round */
name|log2
operator|--
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
name|V_MTUINDEX
argument_list|(
name|i
argument_list|)
operator||
name|V_MTUWIDTH
argument_list|(
name|log2
argument_list|)
operator||
name|V_MTUVALUE
argument_list|(
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|unsigned
name|int
name|inc
decl_stmt|;
name|inc
operator|=
name|max
argument_list|(
operator|(
operator|(
name|mtu
operator|-
literal|40
operator|)
operator|*
name|alpha
index|[
name|w
index|]
operator|)
operator|/
name|avg_pkts
index|[
name|w
index|]
argument_list|,
name|CC_MIN_INCR
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|21
operator|)
operator||
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
operator|(
name|beta
index|[
name|w
index|]
operator|<<
literal|13
operator|)
operator||
name|inc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_set_pace_tbl - set the pace table  *	@adap: the adapter  *	@pace_vals: the pace values in microseconds  *	@start: index of the first entry in the HW pace table to set  *	@n: how many entries to set  *  *	Sets (a subset of the) HW pace table.  */
end_comment

begin_function
name|int
name|t4_set_pace_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|*
name|pace_vals
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|vals
index|[
name|NTX_SCHED
index|]
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|tick_ns
init|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|NTX_SCHED
condition|)
return|return
operator|-
name|ERANGE
return|;
comment|/* convert values from us to dack ticks, rounding to closest value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|pace_vals
operator|++
control|)
block|{
name|vals
index|[
name|i
index|]
operator|=
operator|(
literal|1000
operator|*
operator|*
name|pace_vals
operator|+
name|tick_ns
operator|/
literal|2
operator|)
operator|/
name|tick_ns
expr_stmt|;
if|if
condition|(
name|vals
index|[
name|i
index|]
operator|>
literal|0x7ff
condition|)
return|return
operator|-
name|ERANGE
return|;
if|if
condition|(
operator|*
name|pace_vals
operator|&&
name|vals
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|-
name|ERANGE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|start
operator|++
control|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
operator|(
name|start
operator|<<
literal|16
operator|)
operator||
name|vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_sched_bps - set the bit rate for a HW traffic scheduler  *	@adap: the adapter  *	@kbps: target rate in Kbps  *	@sched: the scheduler index  *  *	Configure a Tx HW scheduler for the target rate.  */
end_comment

begin_function
name|int
name|t4_set_sched_bps
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|unsigned
name|int
name|kbps
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|tps
decl_stmt|,
name|cpt
decl_stmt|,
name|bpt
decl_stmt|,
name|delta
decl_stmt|,
name|mindelta
init|=
operator|~
literal|0
decl_stmt|;
name|unsigned
name|int
name|clk
init|=
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
decl_stmt|;
name|unsigned
name|int
name|selected_cpt
init|=
literal|0
decl_stmt|,
name|selected_bpt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kbps
operator|>
literal|0
condition|)
block|{
name|kbps
operator|*=
literal|125
expr_stmt|;
comment|/* -> bytes */
for|for
control|(
name|cpt
operator|=
literal|1
init|;
name|cpt
operator|<=
literal|255
condition|;
name|cpt
operator|++
control|)
block|{
name|tps
operator|=
name|clk
operator|/
name|cpt
expr_stmt|;
name|bpt
operator|=
operator|(
name|kbps
operator|+
name|tps
operator|/
literal|2
operator|)
operator|/
name|tps
expr_stmt|;
if|if
condition|(
name|bpt
operator|>
literal|0
operator|&&
name|bpt
operator|<=
literal|255
condition|)
block|{
name|v
operator|=
name|bpt
operator|*
name|tps
expr_stmt|;
name|delta
operator|=
name|v
operator|>=
name|kbps
condition|?
name|v
operator|-
name|kbps
else|:
name|kbps
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|delta
operator|<
name|mindelta
condition|)
block|{
name|mindelta
operator|=
name|delta
expr_stmt|;
name|selected_cpt
operator|=
name|cpt
expr_stmt|;
name|selected_bpt
operator|=
name|bpt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|selected_cpt
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|selected_cpt
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|selected_cpt
operator|<<
literal|16
operator|)
operator||
operator|(
name|selected_bpt
operator|<<
literal|24
operator|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff0000
operator|)
operator||
name|selected_cpt
operator||
operator|(
name|selected_bpt
operator|<<
literal|8
operator|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_sched_ipg - set the IPG for a Tx HW packet rate scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Set the interpacket delay for a HW packet rate scheduler.  */
end_comment

begin_function
name|int
name|t4_set_sched_ipg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|unsigned
name|int
name|ipg
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
init|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
decl_stmt|;
comment|/* convert ipg to nearest number of core clocks */
name|ipg
operator|*=
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|ipg
operator|=
operator|(
name|ipg
operator|+
literal|5000
operator|)
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|ipg
operator|>
name|M_TXTIMERSEPQ0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
name|V_TXTIMERSEPQ0
argument_list|(
name|M_TXTIMERSEPQ0
argument_list|)
operator|)
operator||
name|V_TXTIMERSEPQ1
argument_list|(
name|ipg
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
name|V_TXTIMERSEPQ1
argument_list|(
name|M_TXTIMERSEPQ1
argument_list|)
operator|)
operator||
name|V_TXTIMERSEPQ0
argument_list|(
name|ipg
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Calculates a rate in bytes/s given the number of 256-byte units per 4K core  * clocks.  The formula is  *  * bytes/s = bytes256 * 256 * ClkFreq / 4096  *  * which is equivalent to  *  * bytes/s = 62.5 * bytes256 * ClkFreq_ms  */
end_comment

begin_function
specifier|static
name|u64
name|chan_rate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|bytes256
parameter_list|)
block|{
name|u64
name|v
init|=
name|bytes256
operator|*
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
decl_stmt|;
return|return
name|v
operator|*
literal|62
operator|+
name|v
operator|/
literal|2
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_chan_txrate - get the current per channel Tx rates  *	@adap: the adapter  *	@nic_rate: rates for NIC traffic  *	@ofld_rate: rates for offloaded traffic  *  *	Return the current Tx rates in bytes/s for NIC and offloaded traffic  *	for each channel.  */
end_comment

begin_function
name|void
name|t4_get_chan_txrate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u64
modifier|*
name|nic_rate
parameter_list|,
name|u64
modifier|*
name|ofld_rate
parameter_list|)
block|{
name|u32
name|v
decl_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_TRATE
argument_list|)
expr_stmt|;
name|nic_rate
index|[
literal|0
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE0
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|nic_rate
index|[
literal|1
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE1
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|chip_params
operator|->
name|nchan
operator|>
literal|2
condition|)
block|{
name|nic_rate
index|[
literal|2
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE2
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|nic_rate
index|[
literal|3
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE3
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_ORATE
argument_list|)
expr_stmt|;
name|ofld_rate
index|[
literal|0
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE0
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|ofld_rate
index|[
literal|1
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE1
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|chip_params
operator|->
name|nchan
operator|>
literal|2
condition|)
block|{
name|ofld_rate
index|[
literal|2
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE2
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|ofld_rate
index|[
literal|3
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE3
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_set_trace_filter - configure one of the tracing filters  *	@adap: the adapter  *	@tp: the desired trace filter parameters  *	@idx: which filter to configure  *	@enable: whether to enable or disable the filter  *  *	Configures one of the tracing filters available in HW.  If @tp is %NULL  *	it indicates that the filter is already written in the register and it  *	just needs to be enabled or disabled.  */
end_comment

begin_function
name|int
name|t4_set_trace_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|trace_params
modifier|*
name|tp
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ofst
init|=
name|idx
operator|*
literal|4
decl_stmt|;
name|u32
name|data_reg
decl_stmt|,
name|mask_reg
decl_stmt|,
name|cfg
decl_stmt|;
name|u32
name|multitrc
init|=
name|F_TRCMULTIFILTER
decl_stmt|;
name|u32
name|en
init|=
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|F_TFEN
else|:
name|F_T5_TFEN
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|NTRACE
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|tp
operator|==
name|NULL
operator|||
operator|!
name|enable
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|,
name|en
argument_list|,
name|enable
condition|?
name|en
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * TODO - After T4 data book is updated, specify the exact 	 * section below. 	 * 	 * See T4 data book - MPS section for a complete description 	 * of the below if..else handling of A_MPS_TRC_CFG register 	 * value. 	 */
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_TRCMULTIFILTER
condition|)
block|{
comment|/* 		 * If multiple tracers are enabled, then maximum 		 * capture size is 2.5KB (FIFO size of a single channel) 		 * minus 2 flits for CPL_TRACE_PKT header. 		 */
if|if
condition|(
name|tp
operator|->
name|snap_len
operator|>
operator|(
operator|(
literal|10
operator|*
literal|1024
operator|/
literal|4
operator|)
operator|-
operator|(
literal|2
operator|*
literal|8
operator|)
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
block|{
comment|/* 		 * If multiple tracers are disabled, to avoid deadlocks 		 * maximum packet capture size of 9600 bytes is recommended. 		 * Also in this mode, only trace0 can be enabled and running. 		 */
name|multitrc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snap_len
operator|>
literal|9600
operator|||
name|idx
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|port
operator|>
operator|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
literal|11
else|:
literal|19
operator|)
operator|||
name|tp
operator|->
name|invert
operator|>
literal|1
operator|||
name|tp
operator|->
name|skip_len
operator|>
name|M_TFLENGTH
operator|||
name|tp
operator|->
name|skip_ofst
operator|>
name|M_TFOFFSET
operator|||
name|tp
operator|->
name|min_len
operator|>
name|M_TFMINPKTSIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* stop the tracer we'll be changing */
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|,
name|en
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|idx
operator|*=
operator|(
name|A_MPS_TRC_FILTER1_MATCH
operator|-
name|A_MPS_TRC_FILTER0_MATCH
operator|)
expr_stmt|;
name|data_reg
operator|=
name|A_MPS_TRC_FILTER0_MATCH
operator|+
name|idx
expr_stmt|;
name|mask_reg
operator|=
name|A_MPS_TRC_FILTER0_DONT_CARE
operator|+
name|idx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRACE_LEN
operator|/
literal|4
condition|;
name|i
operator|++
operator|,
name|data_reg
operator|+=
literal|4
operator|,
name|mask_reg
operator|+=
literal|4
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|,
name|tp
operator|->
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mask_reg
argument_list|,
operator|~
name|tp
operator|->
name|mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_B
operator|+
name|ofst
argument_list|,
name|V_TFCAPTUREMAX
argument_list|(
name|tp
operator|->
name|snap_len
argument_list|)
operator||
name|V_TFMINPKTSIZE
argument_list|(
name|tp
operator|->
name|min_len
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|,
name|V_TFOFFSET
argument_list|(
name|tp
operator|->
name|skip_ofst
argument_list|)
operator||
name|V_TFLENGTH
argument_list|(
name|tp
operator|->
name|skip_len
argument_list|)
operator||
name|en
operator||
operator|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|V_TFPORT
argument_list|(
name|tp
operator|->
name|port
argument_list|)
operator||
name|V_TFINVERTMATCH
argument_list|(
name|tp
operator|->
name|invert
argument_list|)
else|:
name|V_T5_TFPORT
argument_list|(
name|tp
operator|->
name|port
argument_list|)
operator||
name|V_T5_TFINVERTMATCH
argument_list|(
name|tp
operator|->
name|invert
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_trace_filter - query one of the tracing filters  *	@adap: the adapter  *	@tp: the current trace filter parameters  *	@idx: which trace filter to query  *	@enabled: non-zero if the filter is enabled  *  *	Returns the current settings of one of the HW tracing filters.  */
end_comment

begin_function
name|void
name|t4_get_trace_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|trace_params
modifier|*
name|tp
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|enabled
parameter_list|)
block|{
name|u32
name|ctla
decl_stmt|,
name|ctlb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ofst
init|=
name|idx
operator|*
literal|4
decl_stmt|;
name|u32
name|data_reg
decl_stmt|,
name|mask_reg
decl_stmt|;
name|ctla
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|)
expr_stmt|;
name|ctlb
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_B
operator|+
name|ofst
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
operator|*
name|enabled
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_TFEN
operator|)
expr_stmt|;
name|tp
operator|->
name|port
operator|=
name|G_TFPORT
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|tp
operator|->
name|invert
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_TFINVERTMATCH
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|enabled
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_T5_TFEN
operator|)
expr_stmt|;
name|tp
operator|->
name|port
operator|=
name|G_T5_TFPORT
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|tp
operator|->
name|invert
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_T5_TFINVERTMATCH
operator|)
expr_stmt|;
block|}
name|tp
operator|->
name|snap_len
operator|=
name|G_TFCAPTUREMAX
argument_list|(
name|ctlb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|min_len
operator|=
name|G_TFMINPKTSIZE
argument_list|(
name|ctlb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|skip_ofst
operator|=
name|G_TFOFFSET
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|tp
operator|->
name|skip_len
operator|=
name|G_TFLENGTH
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|ofst
operator|=
operator|(
name|A_MPS_TRC_FILTER1_MATCH
operator|-
name|A_MPS_TRC_FILTER0_MATCH
operator|)
operator|*
name|idx
expr_stmt|;
name|data_reg
operator|=
name|A_MPS_TRC_FILTER0_MATCH
operator|+
name|ofst
expr_stmt|;
name|mask_reg
operator|=
name|A_MPS_TRC_FILTER0_DONT_CARE
operator|+
name|ofst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRACE_LEN
operator|/
literal|4
condition|;
name|i
operator|++
operator|,
name|data_reg
operator|+=
literal|4
operator|,
name|mask_reg
operator|+=
literal|4
control|)
block|{
name|tp
operator|->
name|mask
index|[
name|i
index|]
operator|=
operator|~
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|mask_reg
argument_list|)
expr_stmt|;
name|tp
operator|->
name|data
index|[
name|i
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
operator|&
name|tp
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_pmtx_get_stats - returns the HW stats from PMTX  *	@adap: the adapter  *	@cnt: where to store the count statistics  *	@cycles: where to store the cycle statistics  *  *	Returns performance statistics from PMTX.  */
end_comment

begin_function
name|void
name|t4_pmtx_get_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
name|cnt
index|[]
parameter_list|,
name|u64
name|cycles
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|data
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adap
operator|->
name|chip_params
operator|->
name|pm_stats_cnt
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_STAT_CONFIG
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cnt
index|[
name|i
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_STAT_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|cycles
index|[
name|i
index|]
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_STAT_LSB
argument_list|)
expr_stmt|;
else|else
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_DBG_CTRL
argument_list|,
name|A_PM_TX_DBG_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|,
name|A_PM_TX_DBG_STAT_MSB
argument_list|)
expr_stmt|;
name|cycles
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|u64
operator|)
name|data
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator||
name|data
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_pmrx_get_stats - returns the HW stats from PMRX  *	@adap: the adapter  *	@cnt: where to store the count statistics  *	@cycles: where to store the cycle statistics  *  *	Returns performance statistics from PMRX.  */
end_comment

begin_function
name|void
name|t4_pmrx_get_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
name|cnt
index|[]
parameter_list|,
name|u64
name|cycles
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|data
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adap
operator|->
name|chip_params
operator|->
name|pm_stats_cnt
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_STAT_CONFIG
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cnt
index|[
name|i
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_STAT_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|cycles
index|[
name|i
index|]
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_STAT_LSB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_DBG_CTRL
argument_list|,
name|A_PM_RX_DBG_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|,
name|A_PM_RX_DBG_STAT_MSB
argument_list|)
expr_stmt|;
name|cycles
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|u64
operator|)
name|data
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator||
name|data
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_get_mps_bg_map - return the buffer groups associated with a port  *	@adap: the adapter  *	@idx: the port index  *  *	Returns a bitmap indicating which MPS buffer groups are associated  *	with the given port.  Bit i is set if buffer group i is used by the  *	port.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|t4_get_mps_bg_map
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|u32
name|n
init|=
name|G_NUMPORTS
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_CMN_CTL
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|idx
operator|==
literal|0
condition|?
literal|0xf
else|:
literal|0
return|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|chip_id
argument_list|(
name|adap
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
return|return
name|idx
operator|<
literal|2
condition|?
operator|(
literal|3
operator|<<
operator|(
literal|2
operator|*
name|idx
operator|)
operator|)
else|:
literal|0
return|;
return|return
literal|1
operator|<<
name|idx
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_get_port_type_description - return Port Type string description  *      @port_type: firmware Port Type enumeration  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|t4_get_port_type_description
parameter_list|(
name|enum
name|fw_port_type
name|port_type
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|port_type_description
index|[]
init|=
block|{
literal|"Fiber_XFI"
block|,
literal|"Fiber_XAUI"
block|,
literal|"BT_SGMII"
block|,
literal|"BT_XFI"
block|,
literal|"BT_XAUI"
block|,
literal|"KX4"
block|,
literal|"CX4"
block|,
literal|"KX"
block|,
literal|"KR"
block|,
literal|"SFP"
block|,
literal|"BP_AP"
block|,
literal|"BP4_AP"
block|,
literal|"QSFP_10G"
block|,
literal|"QSA"
block|,
literal|"QSFP"
block|,
literal|"BP40_BA"
block|,
literal|"KR4_100G"
block|,
literal|"CR4_QSFP"
block|,
literal|"CR_QSFP"
block|,
literal|"CR2_QSFP"
block|,
literal|"SFP28"
block|,
literal|"KR_SFP28"
block|, 	}
decl_stmt|;
if|if
condition|(
name|port_type
operator|<
name|ARRAY_SIZE
argument_list|(
name|port_type_description
argument_list|)
condition|)
return|return
name|port_type_description
index|[
name|port_type
index|]
return|;
return|return
literal|"UNKNOWN"
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_get_port_stats_offset - collect port stats relative to a previous  *				   snapshot  *      @adap: The adapter  *      @idx: The port  *      @stats: Current stats to fill  *      @offset: Previous stats snapshot  */
end_comment

begin_function
name|void
name|t4_get_port_stats_offset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|port_stats
modifier|*
name|stats
parameter_list|,
name|struct
name|port_stats
modifier|*
name|offset
parameter_list|)
block|{
name|u64
modifier|*
name|s
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t4_get_port_stats
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|,
name|stats
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
operator|(
name|u64
operator|*
operator|)
name|stats
operator|,
name|o
operator|=
operator|(
name|u64
operator|*
operator|)
name|offset
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|port_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|s
operator|++
operator|,
name|o
operator|++
control|)
operator|*
name|s
operator|-=
operator|*
name|o
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_port_stats - collect port statistics  *	@adap: the adapter  *	@idx: the port index  *	@p: the stats structure to fill  *  *	Collect statistics related to the given port from HW.  */
end_comment

begin_function
name|void
name|t4_get_port_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|port_stats
modifier|*
name|p
parameter_list|)
block|{
name|u32
name|bgmap
init|=
name|t4_get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|u32
name|stat_ctl
init|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_STAT_CTL
argument_list|)
decl_stmt|;
define|#
directive|define
name|GET_STAT
parameter_list|(
name|name
parameter_list|)
define|\
value|t4_read_reg64(adap, \ 	(is_t4(adap) ? PORT_REG(idx, A_MPS_PORT_STAT_##name##_L) : \ 	T5_PORT_REG(idx, A_MPS_PORT_STAT_##name##_L)))
define|#
directive|define
name|GET_STAT_COM
parameter_list|(
name|name
parameter_list|)
value|t4_read_reg64(adap, A_MPS_STAT_##name##_L)
name|p
operator|->
name|tx_pause
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PAUSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_octets
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_BYTES
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_BCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_MCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_UCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_error_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_64
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_65_127
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_65B_127B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_128_255
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_128B_255B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_256_511
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_256B_511B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_512_1023
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_512B_1023B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_1024_1518
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_1024B_1518B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_1519_max
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_1519B_MAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_drop
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_DROP
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp0
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP0
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp1
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP1
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp2
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP2
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp3
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP3
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp4
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP4
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp5
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP5
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp6
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP6
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp7
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP7
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adap
argument_list|)
operator|>=
name|CHELSIO_T5
condition|)
block|{
if|if
condition|(
name|stat_ctl
operator|&
name|F_COUNTPAUSESTATTX
condition|)
block|{
name|p
operator|->
name|tx_frames
operator|-=
name|p
operator|->
name|tx_pause
expr_stmt|;
name|p
operator|->
name|tx_octets
operator|-=
name|p
operator|->
name|tx_pause
operator|*
literal|64
expr_stmt|;
block|}
if|if
condition|(
name|stat_ctl
operator|&
name|F_COUNTPAUSEMCTX
condition|)
name|p
operator|->
name|tx_mcast_frames
operator|-=
name|p
operator|->
name|tx_pause
expr_stmt|;
block|}
name|p
operator|->
name|rx_pause
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PAUSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_octets
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_BYTES
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_BCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_MCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_UCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_too_long
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_MTU_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_jabber
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_MTU_CRC_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_fcs_err
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_CRC_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_len_err
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_LEN_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_symbol_err
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_SYM_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_runt
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_LESS_64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_64
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_65_127
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_65B_127B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_128_255
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_128B_255B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_256_511
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_256B_511B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_512_1023
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_512B_1023B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_1024_1518
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_1024B_1518B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_1519_max
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_1519B_MAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp0
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP0
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp1
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP1
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp2
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP2
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp3
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP3
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp4
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP4
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp5
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP5
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp6
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP6
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp7
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP7
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adap
argument_list|)
operator|>=
name|CHELSIO_T5
condition|)
block|{
if|if
condition|(
name|stat_ctl
operator|&
name|F_COUNTPAUSESTATRX
condition|)
block|{
name|p
operator|->
name|rx_frames
operator|-=
name|p
operator|->
name|rx_pause
expr_stmt|;
name|p
operator|->
name|rx_octets
operator|-=
name|p
operator|->
name|rx_pause
operator|*
literal|64
expr_stmt|;
block|}
if|if
condition|(
name|stat_ctl
operator|&
name|F_COUNTPAUSEMCRX
condition|)
name|p
operator|->
name|rx_mcast_frames
operator|-=
name|p
operator|->
name|rx_pause
expr_stmt|;
block|}
name|p
operator|->
name|rx_ovflow0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_ovflow1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_ovflow2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_ovflow3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
undef|#
directive|undef
name|GET_STAT
undef|#
directive|undef
name|GET_STAT_COM
block|}
end_function

begin_comment
comment|/**  *	t4_get_lb_stats - collect loopback port statistics  *	@adap: the adapter  *	@idx: the loopback port index  *	@p: the stats structure to fill  *  *	Return HW statistics for the given loopback port.  */
end_comment

begin_function
name|void
name|t4_get_lb_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|lb_port_stats
modifier|*
name|p
parameter_list|)
block|{
name|u32
name|bgmap
init|=
name|t4_get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|)
decl_stmt|;
define|#
directive|define
name|GET_STAT
parameter_list|(
name|name
parameter_list|)
define|\
value|t4_read_reg64(adap, \ 	(is_t4(adap) ? \ 	PORT_REG(idx, A_MPS_PORT_STAT_LB_PORT_##name##_L) : \ 	T5_PORT_REG(idx, A_MPS_PORT_STAT_LB_PORT_##name##_L)))
define|#
directive|define
name|GET_STAT_COM
parameter_list|(
name|name
parameter_list|)
value|t4_read_reg64(adap, A_MPS_STAT_##name##_L)
name|p
operator|->
name|octets
operator|=
name|GET_STAT
argument_list|(
name|BYTES
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames
operator|=
name|GET_STAT
argument_list|(
name|FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|BCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|MCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|UCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|error_frames
operator|=
name|GET_STAT
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_64
operator|=
name|GET_STAT
argument_list|(
literal|64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_65_127
operator|=
name|GET_STAT
argument_list|(
literal|65B_127B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_128_255
operator|=
name|GET_STAT
argument_list|(
literal|128B_255B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_256_511
operator|=
name|GET_STAT
argument_list|(
literal|256B_511B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_512_1023
operator|=
name|GET_STAT
argument_list|(
literal|512B_1023B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_1024_1518
operator|=
name|GET_STAT
argument_list|(
literal|1024B_1518B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_1519_max
operator|=
name|GET_STAT
argument_list|(
literal|1519B_MAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|drop
operator|=
name|GET_STAT
argument_list|(
name|DROP_FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|ovflow0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|ovflow1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|ovflow2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|ovflow3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
undef|#
directive|undef
name|GET_STAT
undef|#
directive|undef
name|GET_STAT_COM
block|}
end_function

begin_comment
comment|/**  *	t4_wol_magic_enable - enable/disable magic packet WoL  *	@adap: the adapter  *	@port: the physical port index  *	@addr: MAC address expected in magic packets, %NULL to disable  *  *	Enables/disables magic packet wake-on-LAN for the selected port.  */
end_comment

begin_function
name|void
name|t4_wol_magic_enable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|u32
name|mag_id_reg_l
decl_stmt|,
name|mag_id_reg_h
decl_stmt|,
name|port_cfg_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|mag_id_reg_l
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_MAGIC_MACID_LO
argument_list|)
expr_stmt|;
name|mag_id_reg_h
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_MAGIC_MACID_HI
argument_list|)
expr_stmt|;
name|port_cfg_reg
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_CFG2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mag_id_reg_l
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_MAGIC_MACID_LO
argument_list|)
expr_stmt|;
name|mag_id_reg_h
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_MAGIC_MACID_HI
argument_list|)
expr_stmt|;
name|port_cfg_reg
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_CFG2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mag_id_reg_l
argument_list|,
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mag_id_reg_h
argument_list|,
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|port_cfg_reg
argument_list|,
name|F_MAGICEN
argument_list|,
name|V_MAGICEN
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_wol_pat_enable - enable/disable pattern-based WoL  *	@adap: the adapter  *	@port: the physical port index  *	@map: bitmap of which HW pattern filters to set  *	@mask0: byte mask for bytes 0-63 of a packet  *	@mask1: byte mask for bytes 64-127 of a packet  *	@crc: Ethernet CRC for selected bytes  *	@enable: enable/disable switch  *  *	Sets the pattern filters indicated in @map to mask out the bytes  *	specified in @mask0/@mask1 in received packets and compare the CRC of  *	the resulting packet against @crc.  If @enable is %true pattern-based  *	WoL is enabled, otherwise disabled.  */
end_comment

begin_function
name|int
name|t4_wol_pat_enable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|map
parameter_list|,
name|u64
name|mask0
parameter_list|,
name|u64
name|mask1
parameter_list|,
name|unsigned
name|int
name|crc
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|port_cfg_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|port_cfg_reg
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_CFG2
argument_list|)
expr_stmt|;
else|else
name|port_cfg_reg
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_CFG2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|port_cfg_reg
argument_list|,
name|F_PATEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|map
operator|>
literal|0xff
condition|)
return|return
operator|-
name|EINVAL
return|;
define|#
directive|define
name|EPIO_REG
parameter_list|(
name|name
parameter_list|)
define|\
value|(is_t4(adap) ? PORT_REG(port, A_XGMAC_PORT_EPIO_##name) : \ 	T5_PORT_REG(port, A_MAC_PORT_EPIO_##name))
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA1
argument_list|)
argument_list|,
name|mask0
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA2
argument_list|)
argument_list|,
name|mask1
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA3
argument_list|)
argument_list|,
name|mask1
operator|>>
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NWOL_PAT
condition|;
name|i
operator|++
operator|,
name|map
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|map
operator|&
literal|1
operator|)
condition|)
continue|continue;
comment|/* write byte masks */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA0
argument_list|)
argument_list|,
name|mask0
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|,
name|V_ADDRESS
argument_list|(
name|i
argument_list|)
operator||
name|F_EPIOWR
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|ETIMEDOUT
return|;
comment|/* write CRC */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA0
argument_list|)
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|,
name|V_ADDRESS
argument_list|(
name|i
operator|+
literal|32
argument_list|)
operator||
name|F_EPIOWR
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
undef|#
directive|undef
name|EPIO_REG
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|port_cfg_reg
argument_list|,
literal|0
argument_list|,
name|F_PATEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     t4_mk_filtdelwr - create a delete filter WR  *     @ftid: the filter ID  *     @wr: the filter work request to populate  *     @qid: ingress queue to receive the delete notification  *  *     Creates a filter work request to delete the supplied filter.  If @qid is  *     negative the delete notification is suppressed.  */
end_comment

begin_function
name|void
name|t4_mk_filtdelwr
parameter_list|(
name|unsigned
name|int
name|ftid
parameter_list|,
name|struct
name|fw_filter_wr
modifier|*
name|wr
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|memset
argument_list|(
name|wr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|op_pkd
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FILTER_WR
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|len16_pkd
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
operator|/
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|tid_to_iq
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_FILTER_WR_TID
argument_list|(
name|ftid
argument_list|)
operator||
name|V_FW_FILTER_WR_NOREPLY
argument_list|(
name|qid
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|del_filter_to_l2tix
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_FILTER_WR_DEL_FILTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|>=
literal|0
condition|)
name|wr
operator|->
name|rx_chan_rx_rpl_iq
operator|=
name|cpu_to_be16
argument_list|(
name|V_FW_FILTER_WR_RX_RPL_IQ
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|INIT_CMD
parameter_list|(
name|var
parameter_list|,
name|cmd
parameter_list|,
name|rd_wr
parameter_list|)
value|do { \ 	(var).op_to_write = cpu_to_be32(V_FW_CMD_OP(FW_##cmd##_CMD) | \ 					F_FW_CMD_REQUEST | \ 					F_FW_CMD_##rd_wr); \ 	(var).retval_len16 = cpu_to_be32(FW_LEN16(var)); \ } while (0)
end_define

begin_function
name|int
name|t4_fwaddrspace_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|u32
name|ldst_addrspace
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_addrspace
operator|=
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_FIRMWARE
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|ldst_addrspace
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|addrval
operator|.
name|addr
operator|=
name|cpu_to_be32
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|addrval
operator|.
name|val
operator|=
name|cpu_to_be32
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mdio_rd - read a PHY register through MDIO  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@phy_addr: the PHY address  *	@mmd: the PHY MMD to access (0 for clause 22 PHYs)  *	@reg: the register to read  *	@valp: where to store the value  *  *	Issues a FW command through the given mailbox to read a PHY register.  */
end_comment

begin_function
name|int
name|t4_mdio_rd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|phy_addr
parameter_list|,
name|unsigned
name|int
name|mmd
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|ldst_addrspace
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_addrspace
operator|=
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_MDIO
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|ldst_addrspace
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|paddr_mmd
operator|=
name|cpu_to_be16
argument_list|(
name|V_FW_LDST_CMD_PADDR
argument_list|(
name|phy_addr
argument_list|)
operator||
name|V_FW_LDST_CMD_MMD
argument_list|(
name|mmd
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|raddr
operator|=
name|cpu_to_be16
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|*
name|valp
operator|=
name|be16_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|rval
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mdio_wr - write a PHY register through MDIO  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@phy_addr: the PHY address  *	@mmd: the PHY MMD to access (0 for clause 22 PHYs)  *	@reg: the register to write  *	@valp: value to write  *  *	Issues a FW command through the given mailbox to write a PHY register.  */
end_comment

begin_function
name|int
name|t4_mdio_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|phy_addr
parameter_list|,
name|unsigned
name|int
name|mmd
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|u32
name|ldst_addrspace
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_addrspace
operator|=
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_MDIO
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|ldst_addrspace
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|paddr_mmd
operator|=
name|cpu_to_be16
argument_list|(
name|V_FW_LDST_CMD_PADDR
argument_list|(
name|phy_addr
argument_list|)
operator||
name|V_FW_LDST_CMD_MMD
argument_list|(
name|mmd
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|raddr
operator|=
name|cpu_to_be16
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|rval
operator|=
name|cpu_to_be16
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  *	t4_sge_decode_idma_state - decode the idma state  *	@adap: the adapter  *	@state: the state idma is stuck in  */
end_comment

begin_function
name|void
name|t4_sge_decode_idma_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|t4_decode
index|[]
init|=
block|{
literal|"IDMA_IDLE"
block|,
literal|"IDMA_PUSH_MORE_CPL_FIFO"
block|,
literal|"IDMA_PUSH_CPL_MSG_HEADER_TO_FIFO"
block|,
literal|"Not used"
block|,
literal|"IDMA_PHYSADDR_SEND_PCIEHDR"
block|,
literal|"IDMA_PHYSADDR_SEND_PAYLOAD_FIRST"
block|,
literal|"IDMA_PHYSADDR_SEND_PAYLOAD"
block|,
literal|"IDMA_SEND_FIFO_TO_IMSG"
block|,
literal|"IDMA_FL_REQ_DATA_FL_PREP"
block|,
literal|"IDMA_FL_REQ_DATA_FL"
block|,
literal|"IDMA_FL_DROP"
block|,
literal|"IDMA_FL_H_REQ_HEADER_FL"
block|,
literal|"IDMA_FL_H_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_H_PUSH_CPL_FIFO"
block|,
literal|"IDMA_FL_H_SEND_CPL"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR_FIRST"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR"
block|,
literal|"IDMA_FL_H_REQ_NEXT_HEADER_FL"
block|,
literal|"IDMA_FL_H_SEND_NEXT_PCIEHDR"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR_PADDING"
block|,
literal|"IDMA_FL_D_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_D_SEND_CPL_AND_IP_HDR"
block|,
literal|"IDMA_FL_D_REQ_NEXT_DATA_FL"
block|,
literal|"IDMA_FL_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_PUSH_CPL_FIFO"
block|,
literal|"IDMA_FL_SEND_CPL"
block|,
literal|"IDMA_FL_SEND_PAYLOAD_FIRST"
block|,
literal|"IDMA_FL_SEND_PAYLOAD"
block|,
literal|"IDMA_FL_REQ_NEXT_DATA_FL"
block|,
literal|"IDMA_FL_SEND_NEXT_PCIEHDR"
block|,
literal|"IDMA_FL_SEND_PADDING"
block|,
literal|"IDMA_FL_SEND_COMPLETION_TO_IMSG"
block|,
literal|"IDMA_FL_SEND_FIFO_TO_IMSG"
block|,
literal|"IDMA_FL_REQ_DATAFL_DONE"
block|,
literal|"IDMA_FL_REQ_HEADERFL_DONE"
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|t5_decode
index|[]
init|=
block|{
literal|"IDMA_IDLE"
block|,
literal|"IDMA_ALMOST_IDLE"
block|,
literal|"IDMA_PUSH_MORE_CPL_FIFO"
block|,
literal|"IDMA_PUSH_CPL_MSG_HEADER_TO_FIFO"
block|,
literal|"IDMA_SGEFLRFLUSH_SEND_PCIEHDR"
block|,
literal|"IDMA_PHYSADDR_SEND_PCIEHDR"
block|,
literal|"IDMA_PHYSADDR_SEND_PAYLOAD_FIRST"
block|,
literal|"IDMA_PHYSADDR_SEND_PAYLOAD"
block|,
literal|"IDMA_SEND_FIFO_TO_IMSG"
block|,
literal|"IDMA_FL_REQ_DATA_FL"
block|,
literal|"IDMA_FL_DROP"
block|,
literal|"IDMA_FL_DROP_SEND_INC"
block|,
literal|"IDMA_FL_H_REQ_HEADER_FL"
block|,
literal|"IDMA_FL_H_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_H_PUSH_CPL_FIFO"
block|,
literal|"IDMA_FL_H_SEND_CPL"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR_FIRST"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR"
block|,
literal|"IDMA_FL_H_REQ_NEXT_HEADER_FL"
block|,
literal|"IDMA_FL_H_SEND_NEXT_PCIEHDR"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR_PADDING"
block|,
literal|"IDMA_FL_D_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_D_SEND_CPL_AND_IP_HDR"
block|,
literal|"IDMA_FL_D_REQ_NEXT_DATA_FL"
block|,
literal|"IDMA_FL_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_PUSH_CPL_FIFO"
block|,
literal|"IDMA_FL_SEND_CPL"
block|,
literal|"IDMA_FL_SEND_PAYLOAD_FIRST"
block|,
literal|"IDMA_FL_SEND_PAYLOAD"
block|,
literal|"IDMA_FL_REQ_NEXT_DATA_FL"
block|,
literal|"IDMA_FL_SEND_NEXT_PCIEHDR"
block|,
literal|"IDMA_FL_SEND_PADDING"
block|,
literal|"IDMA_FL_SEND_COMPLETION_TO_IMSG"
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|t6_decode
index|[]
init|=
block|{
literal|"IDMA_IDLE"
block|,
literal|"IDMA_PUSH_MORE_CPL_FIFO"
block|,
literal|"IDMA_PUSH_CPL_MSG_HEADER_TO_FIFO"
block|,
literal|"IDMA_SGEFLRFLUSH_SEND_PCIEHDR"
block|,
literal|"IDMA_PHYSADDR_SEND_PCIEHDR"
block|,
literal|"IDMA_PHYSADDR_SEND_PAYLOAD_FIRST"
block|,
literal|"IDMA_PHYSADDR_SEND_PAYLOAD"
block|,
literal|"IDMA_FL_REQ_DATA_FL"
block|,
literal|"IDMA_FL_DROP"
block|,
literal|"IDMA_FL_DROP_SEND_INC"
block|,
literal|"IDMA_FL_H_REQ_HEADER_FL"
block|,
literal|"IDMA_FL_H_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_H_PUSH_CPL_FIFO"
block|,
literal|"IDMA_FL_H_SEND_CPL"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR_FIRST"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR"
block|,
literal|"IDMA_FL_H_REQ_NEXT_HEADER_FL"
block|,
literal|"IDMA_FL_H_SEND_NEXT_PCIEHDR"
block|,
literal|"IDMA_FL_H_SEND_IP_HDR_PADDING"
block|,
literal|"IDMA_FL_D_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_D_SEND_CPL_AND_IP_HDR"
block|,
literal|"IDMA_FL_D_REQ_NEXT_DATA_FL"
block|,
literal|"IDMA_FL_SEND_PCIEHDR"
block|,
literal|"IDMA_FL_PUSH_CPL_FIFO"
block|,
literal|"IDMA_FL_SEND_CPL"
block|,
literal|"IDMA_FL_SEND_PAYLOAD_FIRST"
block|,
literal|"IDMA_FL_SEND_PAYLOAD"
block|,
literal|"IDMA_FL_REQ_NEXT_DATA_FL"
block|,
literal|"IDMA_FL_SEND_NEXT_PCIEHDR"
block|,
literal|"IDMA_FL_SEND_PADDING"
block|,
literal|"IDMA_FL_SEND_COMPLETION_TO_IMSG"
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|u32
name|sge_regs
index|[]
init|=
block|{
name|A_SGE_DEBUG_DATA_LOW_INDEX_2
block|,
name|A_SGE_DEBUG_DATA_LOW_INDEX_3
block|,
name|A_SGE_DEBUG_DATA_HIGH_INDEX_10
block|, 	}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|sge_idma_decode
decl_stmt|;
name|int
name|sge_idma_decode_nstates
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|chip_version
init|=
name|chip_id
argument_list|(
name|adapter
argument_list|)
decl_stmt|;
comment|/* Select the right set of decode strings to dump depending on the 	 * adapter chip type. 	 */
switch|switch
condition|(
name|chip_version
condition|)
block|{
case|case
name|CHELSIO_T4
case|:
name|sge_idma_decode
operator|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|t4_decode
expr_stmt|;
name|sge_idma_decode_nstates
operator|=
name|ARRAY_SIZE
argument_list|(
name|t4_decode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T5
case|:
name|sge_idma_decode
operator|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|t5_decode
expr_stmt|;
name|sge_idma_decode_nstates
operator|=
name|ARRAY_SIZE
argument_list|(
name|t5_decode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHELSIO_T6
case|:
name|sge_idma_decode
operator|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|t6_decode
expr_stmt|;
name|sge_idma_decode_nstates
operator|=
name|ARRAY_SIZE
argument_list|(
name|t6_decode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"Unsupported chip version %d\n"
argument_list|,
name|chip_version
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|<
name|sge_idma_decode_nstates
condition|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"idma state %s\n"
argument_list|,
name|sge_idma_decode
index|[
name|state
index|]
argument_list|)
expr_stmt|;
else|else
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"idma state %d unknown\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|sge_regs
argument_list|)
condition|;
name|i
operator|++
control|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"SGE register %#x value %#x\n"
argument_list|,
name|sge_regs
index|[
name|i
index|]
argument_list|,
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|sge_regs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *      t4_sge_ctxt_flush - flush the SGE context cache  *      @adap: the adapter  *      @mbox: mailbox to use for the FW command  *  *      Issues a FW command through the given mailbox to flush the  *      SGE context cache.  */
end_comment

begin_function
name|int
name|t4_sge_ctxt_flush
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|ldst_addrspace
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ldst_addrspace
operator|=
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_SGE_EGRC
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|ldst_addrspace
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|msg_ctxtflush
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_LDST_CMD_CTXTFLUSH
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_fw_hello - establish communication with FW  *      @adap: the adapter  *      @mbox: mailbox to use for the FW command  *      @evt_mbox: mailbox to receive async FW events  *      @master: specifies the caller's willingness to be the device master  *	@state: returns the current device state (if non-NULL)  *  *	Issues a command to establish communication with FW.  Returns either  *	an error (negative integer) or the mailbox of the Master PF.  */
end_comment

begin_function
name|int
name|t4_fw_hello
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|evt_mbox
parameter_list|,
name|enum
name|dev_master
name|master
parameter_list|,
name|enum
name|dev_state
modifier|*
name|state
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_hello_cmd
name|c
decl_stmt|;
name|u32
name|v
decl_stmt|;
name|unsigned
name|int
name|master_mbox
decl_stmt|;
name|int
name|retries
init|=
name|FW_CMD_HELLO_RETRIES
decl_stmt|;
name|retry
label|:
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|HELLO
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|err_to_clearinit
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_HELLO_CMD_MASTERDIS
argument_list|(
name|master
operator|==
name|MASTER_CANT
argument_list|)
operator||
name|V_FW_HELLO_CMD_MASTERFORCE
argument_list|(
name|master
operator|==
name|MASTER_MUST
argument_list|)
operator||
name|V_FW_HELLO_CMD_MBMASTER
argument_list|(
name|master
operator|==
name|MASTER_MUST
condition|?
name|mbox
else|:
name|M_FW_HELLO_CMD_MBMASTER
argument_list|)
operator||
name|V_FW_HELLO_CMD_MBASYNCNOT
argument_list|(
name|evt_mbox
argument_list|)
operator||
name|V_FW_HELLO_CMD_STAGE
argument_list|(
name|FW_HELLO_CMD_STAGE_OS
argument_list|)
operator||
name|F_FW_HELLO_CMD_CLEARINIT
argument_list|)
expr_stmt|;
comment|/* 	 * Issue the HELLO command to the firmware.  If it's not successful 	 * but indicates that we got a "busy" or "timeout" condition, retry 	 * the HELLO until we exhaust our retry limit.  If we do exceed our 	 * retry limit, check to see if the firmware left us any error 	 * information and report that if so ... 	 */
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|FW_SUCCESS
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|==
operator|-
name|EBUSY
operator|||
name|ret
operator|==
operator|-
name|ETIMEDOUT
operator|)
operator|&&
name|retries
operator|--
operator|>
literal|0
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
operator|&
name|F_PCIE_FW_ERR
condition|)
name|t4_report_fw_error
argument_list|(
name|adap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|v
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|err_to_clearinit
argument_list|)
expr_stmt|;
name|master_mbox
operator|=
name|G_FW_HELLO_CMD_MBMASTER
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|v
operator|&
name|F_FW_HELLO_CMD_ERR
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_ERR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|&
name|F_FW_HELLO_CMD_INIT
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_INIT
expr_stmt|;
else|else
operator|*
name|state
operator|=
name|DEV_STATE_UNINIT
expr_stmt|;
block|}
comment|/* 	 * If we're not the Master PF then we need to wait around for the 	 * Master PF Driver to finish setting up the adapter. 	 * 	 * Note that we also do this wait if we're a non-Master-capable PF and 	 * there is no current Master PF; a Master PF may show up momentarily 	 * and we wouldn't want to fail pointlessly.  (This can happen when an 	 * OS loads lots of different drivers rapidly at the same time).  In 	 * this case, the Master PF returned by the firmware will be 	 * M_PCIE_FW_MASTER so the test below will work ... 	 */
if|if
condition|(
operator|(
name|v
operator|&
operator|(
name|F_FW_HELLO_CMD_ERR
operator||
name|F_FW_HELLO_CMD_INIT
operator|)
operator|)
operator|==
literal|0
operator|&&
name|master_mbox
operator|!=
name|mbox
condition|)
block|{
name|int
name|waiting
init|=
name|FW_CMD_HELLO_TIMEOUT
decl_stmt|;
comment|/* 		 * Wait for the firmware to either indicate an error or 		 * initialized state.  If we see either of these we bail out 		 * and report the issue to the caller.  If we exhaust the 		 * "hello timeout" and we haven't exhausted our retries, try 		 * again.  Otherwise bail with a timeout error. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|u32
name|pcie_fw
decl_stmt|;
name|msleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|waiting
operator|-=
literal|50
expr_stmt|;
comment|/* 			 * If neither Error nor Initialialized are indicated 			 * by the firmware keep waiting till we exhaust our 			 * timeout ... and then retry if we haven't exhausted 			 * our retries ... 			 */
name|pcie_fw
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pcie_fw
operator|&
operator|(
name|F_PCIE_FW_ERR
operator||
name|F_PCIE_FW_INIT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|waiting
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
goto|goto
name|retry
goto|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
continue|continue;
block|}
comment|/* 			 * We either have an Error or Initialized condition 			 * report errors preferentially. 			 */
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|pcie_fw
operator|&
name|F_PCIE_FW_ERR
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_ERR
expr_stmt|;
elseif|else
if|if
condition|(
name|pcie_fw
operator|&
name|F_PCIE_FW_INIT
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_INIT
expr_stmt|;
block|}
comment|/* 			 * If we arrived before a Master PF was selected and 			 * there's not a valid Master PF, grab its identity 			 * for our caller. 			 */
if|if
condition|(
name|master_mbox
operator|==
name|M_PCIE_FW_MASTER
operator|&&
operator|(
name|pcie_fw
operator|&
name|F_PCIE_FW_MASTER_VLD
operator|)
condition|)
name|master_mbox
operator|=
name|G_PCIE_FW_MASTER
argument_list|(
name|pcie_fw
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|master_mbox
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_bye - end communication with FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *  *	Issues a command to terminate communication with FW.  */
end_comment

begin_function
name|int
name|t4_fw_bye
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|)
block|{
name|struct
name|fw_bye_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|BYE
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_reset - issue a reset to FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@reset: specifies the type of reset to perform  *  *	Issues a reset command of the specified type to FW.  */
end_comment

begin_function
name|int
name|t4_fw_reset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|fw_reset_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|RESET
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|cpu_to_be32
argument_list|(
name|reset
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_halt - issue a reset/halt to FW and put uP into RESET  *	@adap: the adapter  *	@mbox: mailbox to use for the FW RESET command (if desired)  *	@force: force uP into RESET even if FW RESET command fails  *  *	Issues a RESET command to firmware (if desired) with a HALT indication  *	and then puts the microprocessor into RESET state.  The RESET command  *	will only be issued if a legitimate mailbox is provided (mbox<=  *	M_PCIE_FW_MASTER).  *  *	This is generally used in order for the host to safely manipulate the  *	adapter without fear of conflicting with whatever the firmware might  *	be doing.  The only way out of this state is to RESTART the firmware  *	...  */
end_comment

begin_function
name|int
name|t4_fw_halt
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * If a legitimate mailbox is provided, issue a RESET command 	 * with a HALT indication. 	 */
if|if
condition|(
name|mbox
operator|<=
name|M_PCIE_FW_MASTER
condition|)
block|{
name|struct
name|fw_reset_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|RESET
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|cpu_to_be32
argument_list|(
name|F_PIORST
operator||
name|F_PIORSTMODE
argument_list|)
expr_stmt|;
name|c
operator|.
name|halt_pkd
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_RESET_CMD_HALT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Normally we won't complete the operation if the firmware RESET 	 * command fails but if our caller insists we'll go ahead and put the 	 * uP into RESET.  This can be useful if the firmware is hung or even 	 * missing ...  We'll have to take the risk of putting the uP into 	 * RESET without the cooperation of firmware in that case. 	 * 	 * We also force the firmware's HALT flag to be on in case we bypassed 	 * the firmware RESET command above or we're dealing with old firmware 	 * which doesn't have the HALT capability.  This will serve as a flag 	 * for the incoming firmware to know that it's coming out of a HALT 	 * rather than a RESET ... if it's new enough to understand that ... 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|force
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|F_UPCRST
argument_list|,
name|F_UPCRST
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|,
name|F_PCIE_FW_HALT
argument_list|,
name|F_PCIE_FW_HALT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * And we always return the result of the firmware RESET command 	 * even when we force the uP into RESET ... 	 */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_restart - restart the firmware by taking the uP out of RESET  *	@adap: the adapter  *	@reset: if we want to do a RESET to restart things  *  *	Restart firmware previously halted by t4_fw_halt().  On successful  *	return the previous PF Master remains as the new PF Master and there  *	is no need to issue a new HELLO command, etc.  *  *	We do this in two ways:  *  *	 1. If we're dealing with newer firmware we'll simply want to take  *	    the chip's microprocessor out of RESET.  This will cause the  *	    firmware to start up from its start vector.  And then we'll loop  *	    until the firmware indicates it's started again (PCIE_FW.HALT  *	    reset to 0) or we timeout.  *  *	 2. If we're dealing with older firmware then we'll need to RESET  *	    the chip since older firmware won't recognize the PCIE_FW.HALT  *	    flag and automatically RESET itself on startup.  */
end_comment

begin_function
name|int
name|t4_fw_restart
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
if|if
condition|(
name|reset
condition|)
block|{
comment|/* 		 * Since we're directing the RESET instead of the firmware 		 * doing it automatically, we need to clear the PCIE_FW.HALT 		 * bit. 		 */
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|,
name|F_PCIE_FW_HALT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If we've been given a valid mailbox, first try to get the 		 * firmware to do the RESET.  If that works, great and we can 		 * return success.  Otherwise, if we haven't been given a 		 * valid mailbox or the RESET command failed, fall back to 		 * hitting the chip with a hammer. 		 */
if|if
condition|(
name|mbox
operator|<=
name|M_PCIE_FW_MASTER
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|F_UPCRST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_fw_reset
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|F_PIORST
operator||
name|F_PIORSTMODE
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PL_RST
argument_list|,
name|F_PIORST
operator||
name|F_PIORSTMODE
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ms
decl_stmt|;
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|F_UPCRST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ms
operator|=
literal|0
init|;
name|ms
operator|<
name|FW_CMD_MAX_TIMEOUT
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
operator|&
name|F_PCIE_FW_HALT
operator|)
condition|)
return|return
name|FW_SUCCESS
return|;
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ms
operator|+=
literal|100
expr_stmt|;
block|}
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_upgrade - perform all of the steps necessary to upgrade FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW RESET command (if desired)  *	@fw_data: the firmware image to write  *	@size: image size  *	@force: force upgrade even if firmware doesn't cooperate  *  *	Perform all of the steps necessary for upgrading an adapter's  *	firmware image.  Normally this requires the cooperation of the  *	existing firmware in order to halt all existing activities  *	but if an invalid mailbox token is passed in we skip that step  *	(though we'll still put the adapter microprocessor into RESET in  *	that case).  *  *	On successful return the new firmware will have been loaded and  *	the adapter will have been fully RESET losing all previous setup  *	state.  On unsuccessful return the adapter may be completely hosed ...  *	positive errno indicates that the adapter is ~probably~ intact, a  *	negative errno indicates that things are looking bad ...  */
end_comment

begin_function
name|int
name|t4_fw_upgrade
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
specifier|const
name|u8
modifier|*
name|fw_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|force
parameter_list|)
block|{
specifier|const
name|struct
name|fw_hdr
modifier|*
name|fw_hdr
init|=
operator|(
specifier|const
expr|struct
name|fw_hdr
operator|*
operator|)
name|fw_data
decl_stmt|;
name|unsigned
name|int
name|bootstrap
init|=
name|be32_to_cpu
argument_list|(
name|fw_hdr
operator|->
name|magic
argument_list|)
operator|==
name|FW_HDR_MAGIC_BOOTSTRAP
decl_stmt|;
name|int
name|reset
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|t4_fw_matches_chip
argument_list|(
name|adap
argument_list|,
name|fw_hdr
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|bootstrap
condition|)
block|{
name|ret
operator|=
name|t4_fw_halt
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|&&
operator|!
name|force
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|t4_load_fw
argument_list|(
name|adap
argument_list|,
name|fw_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|bootstrap
condition|)
return|return
name|ret
return|;
comment|/* 	 * Older versions of the firmware don't understand the new 	 * PCIE_FW.HALT flag and so won't know to perform a RESET when they 	 * restart.  So for newly loaded older firmware we'll have to do the 	 * RESET for it so it starts up on a clean slate.  We can tell if 	 * the newly loaded firmware will handle this right by checking 	 * its header flags to see if it advertises the capability. 	 */
name|reset
operator|=
operator|(
operator|(
name|be32_to_cpu
argument_list|(
name|fw_hdr
operator|->
name|flags
argument_list|)
operator|&
name|FW_HDR_FLAGS_RESET_HALT
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|t4_fw_restart
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|reset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Card doesn't have a firmware, install one.  */
end_comment

begin_function
name|int
name|t4_fw_forceinstall
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u8
modifier|*
name|fw_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
specifier|const
name|struct
name|fw_hdr
modifier|*
name|fw_hdr
init|=
operator|(
specifier|const
expr|struct
name|fw_hdr
operator|*
operator|)
name|fw_data
decl_stmt|;
name|unsigned
name|int
name|bootstrap
init|=
name|be32_to_cpu
argument_list|(
name|fw_hdr
operator|->
name|magic
argument_list|)
operator|==
name|FW_HDR_MAGIC_BOOTSTRAP
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|t4_fw_matches_chip
argument_list|(
name|adap
argument_list|,
name|fw_hdr
argument_list|)
operator|||
name|bootstrap
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|F_UPCRST
argument_list|,
name|F_UPCRST
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clobber internal state */
name|ret
operator|=
name|t4_load_fw
argument_list|(
name|adap
argument_list|,
name|fw_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PL_RST
argument_list|,
name|F_PIORST
operator||
name|F_PIORSTMODE
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_initialize - ask FW to initialize the device  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *  *	Issues a command to FW to partially initialize the device.  This  *	performs initialization that generally doesn't depend on user input.  */
end_comment

begin_function
name|int
name|t4_fw_initialize
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|)
block|{
name|struct
name|fw_initialize_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|INITIALIZE
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_query_params_rw - query FW or device parameters  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF  *	@vf: the VF  *	@nparams: the number of parameters  *	@params: the parameter names  *	@val: the parameter values  *	@rw: Write and read flag  *  *	Reads the value of FW or device parameters.  Up to 7 parameters can be  *	queried at once.  */
end_comment

begin_function
name|int
name|t4_query_params_rw
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nparams
parameter_list|,
specifier|const
name|u32
modifier|*
name|params
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|fw_params_cmd
name|c
decl_stmt|;
name|__be32
modifier|*
name|p
init|=
operator|&
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|mnem
decl_stmt|;
if|if
condition|(
name|nparams
operator|>
literal|7
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PARAMS_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_PARAMS_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_PARAMS_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|cpu_to_be32
argument_list|(
operator|*
name|params
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
condition|)
operator|*
name|p
operator|=
name|cpu_to_be32
argument_list|(
operator|*
operator|(
name|val
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|&
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|val
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|2
control|)
operator|*
name|val
operator|++
operator|=
name|be32_to_cpu
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|t4_query_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nparams
parameter_list|,
specifier|const
name|u32
modifier|*
name|params
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|)
block|{
return|return
name|t4_query_params_rw
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
name|nparams
argument_list|,
name|params
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_set_params_timeout - sets FW or device parameters  *      @adap: the adapter  *      @mbox: mailbox to use for the FW command  *      @pf: the PF  *      @vf: the VF  *      @nparams: the number of parameters  *      @params: the parameter names  *      @val: the parameter values  *      @timeout: the timeout time  *  *      Sets the value of FW or device parameters.  Up to 7 parameters can be  *      specified at once.  */
end_comment

begin_function
name|int
name|t4_set_params_timeout
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nparams
parameter_list|,
specifier|const
name|u32
modifier|*
name|params
parameter_list|,
specifier|const
name|u32
modifier|*
name|val
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|fw_params_cmd
name|c
decl_stmt|;
name|__be32
modifier|*
name|p
init|=
operator|&
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|mnem
decl_stmt|;
if|if
condition|(
name|nparams
operator|>
literal|7
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PARAMS_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_PARAMS_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_PARAMS_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nparams
operator|--
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|cpu_to_be32
argument_list|(
operator|*
name|params
operator|++
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|cpu_to_be32
argument_list|(
operator|*
name|val
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|t4_wr_mbox_timeout
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_params - sets FW or device parameters  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF  *	@vf: the VF  *	@nparams: the number of parameters  *	@params: the parameter names  *	@val: the parameter values  *  *	Sets the value of FW or device parameters.  Up to 7 parameters can be  *	specified at once.  */
end_comment

begin_function
name|int
name|t4_set_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nparams
parameter_list|,
specifier|const
name|u32
modifier|*
name|params
parameter_list|,
specifier|const
name|u32
modifier|*
name|val
parameter_list|)
block|{
return|return
name|t4_set_params_timeout
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
name|nparams
argument_list|,
name|params
argument_list|,
name|val
argument_list|,
name|FW_CMD_MAX_TIMEOUT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cfg_pfvf - configure PF/VF resource limits  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF being configured  *	@vf: the VF being configured  *	@txq: the max number of egress queues  *	@txq_eth_ctrl: the max number of egress Ethernet or control queues  *	@rxqi: the max number of interrupt-capable ingress queues  *	@rxq: the max number of interruptless ingress queues  *	@tc: the PCI traffic class  *	@vi: the max number of virtual interfaces  *	@cmask: the channel access rights mask for the PF/VF  *	@pmask: the port access rights mask for the PF/VF  *	@nexact: the maximum number of exact MPS filters  *	@rcaps: read capabilities  *	@wxcaps: write/execute capabilities  *  *	Configures resource limits and capabilities for a physical or virtual  *	function.  */
end_comment

begin_function
name|int
name|t4_cfg_pfvf
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|txq
parameter_list|,
name|unsigned
name|int
name|txq_eth_ctrl
parameter_list|,
name|unsigned
name|int
name|rxqi
parameter_list|,
name|unsigned
name|int
name|rxq
parameter_list|,
name|unsigned
name|int
name|tc
parameter_list|,
name|unsigned
name|int
name|vi
parameter_list|,
name|unsigned
name|int
name|cmask
parameter_list|,
name|unsigned
name|int
name|pmask
parameter_list|,
name|unsigned
name|int
name|nexact
parameter_list|,
name|unsigned
name|int
name|rcaps
parameter_list|,
name|unsigned
name|int
name|wxcaps
parameter_list|)
block|{
name|struct
name|fw_pfvf_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PFVF_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_PFVF_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_PFVF_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|niqflint_niq
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PFVF_CMD_NIQFLINT
argument_list|(
name|rxqi
argument_list|)
operator||
name|V_FW_PFVF_CMD_NIQ
argument_list|(
name|rxq
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_neq
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PFVF_CMD_CMASK
argument_list|(
name|cmask
argument_list|)
operator||
name|V_FW_PFVF_CMD_PMASK
argument_list|(
name|pmask
argument_list|)
operator||
name|V_FW_PFVF_CMD_NEQ
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|tc_to_nexactf
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PFVF_CMD_TC
argument_list|(
name|tc
argument_list|)
operator||
name|V_FW_PFVF_CMD_NVI
argument_list|(
name|vi
argument_list|)
operator||
name|V_FW_PFVF_CMD_NEXACTF
argument_list|(
name|nexact
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|r_caps_to_nethctrl
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PFVF_CMD_R_CAPS
argument_list|(
name|rcaps
argument_list|)
operator||
name|V_FW_PFVF_CMD_WX_CAPS
argument_list|(
name|wxcaps
argument_list|)
operator||
name|V_FW_PFVF_CMD_NETHCTRL
argument_list|(
name|txq_eth_ctrl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_alloc_vi_func - allocate a virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@port: physical port associated with the VI  *	@pf: the PF owning the VI  *	@vf: the VF owning the VI  *	@nmac: number of MAC addresses needed (1 to 5)  *	@mac: the MAC addresses of the VI  *	@rss_size: size of RSS table slice associated with this VI  *	@portfunc: which Port Application Function MAC Address is desired  *	@idstype: Intrusion Detection Type  *  *	Allocates a virtual interface for the given physical port.  If @mac is  *	not %NULL it contains the MAC addresses of the VI as assigned by FW.  *	If @rss_size is %NULL the VI is not assigned any RSS slice by FW.  *	@mac should be large enough to hold @nmac Ethernet addresses, they are  *	stored consecutively so the space needed is @nmac * 6 bytes.  *	Returns a negative error number or the non-negative VI id.  */
end_comment

begin_function
name|int
name|t4_alloc_vi_func
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nmac
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|,
name|u16
modifier|*
name|rss_size
parameter_list|,
name|unsigned
name|int
name|portfunc
parameter_list|,
name|unsigned
name|int
name|idstype
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_vi_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_VI_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_VI_CMD_ALLOC
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_viid
operator|=
name|cpu_to_be16
argument_list|(
name|V_FW_VI_CMD_TYPE
argument_list|(
name|idstype
argument_list|)
operator||
name|V_FW_VI_CMD_FUNC
argument_list|(
name|portfunc
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|portid_pkd
operator|=
name|V_FW_VI_CMD_PORTID
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|c
operator|.
name|nmac
operator|=
name|nmac
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|rss_size
condition|)
name|c
operator|.
name|norss_rsssize
operator|=
name|F_FW_VI_CMD_NORSS
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|mac
condition|)
block|{
name|memcpy
argument_list|(
name|mac
argument_list|,
name|c
operator|.
name|mac
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|mac
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nmac
condition|)
block|{
case|case
literal|5
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|24
argument_list|,
name|c
operator|.
name|nmac3
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac3
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|18
argument_list|,
name|c
operator|.
name|nmac2
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac2
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|12
argument_list|,
name|c
operator|.
name|nmac1
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac1
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|6
argument_list|,
name|c
operator|.
name|nmac0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rss_size
condition|)
operator|*
name|rss_size
operator|=
name|G_FW_VI_CMD_RSSSIZE
argument_list|(
name|be16_to_cpu
argument_list|(
name|c
operator|.
name|norss_rsssize
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|G_FW_VI_CMD_VIID
argument_list|(
name|be16_to_cpu
argument_list|(
name|c
operator|.
name|type_to_viid
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_alloc_vi - allocate an [Ethernet Function] virtual interface  *      @adap: the adapter  *      @mbox: mailbox to use for the FW command  *      @port: physical port associated with the VI  *      @pf: the PF owning the VI  *      @vf: the VF owning the VI  *      @nmac: number of MAC addresses needed (1 to 5)  *      @mac: the MAC addresses of the VI  *      @rss_size: size of RSS table slice associated with this VI  *  *	backwards compatible and convieniance routine to allocate a Virtual  *	Interface with a Ethernet Port Application Function and Intrustion  *	Detection System disabled.  */
end_comment

begin_function
name|int
name|t4_alloc_vi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nmac
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|,
name|u16
modifier|*
name|rss_size
parameter_list|)
block|{
return|return
name|t4_alloc_vi_func
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|port
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
name|nmac
argument_list|,
name|mac
argument_list|,
name|rss_size
argument_list|,
name|FW_VI_FUNC_ETH
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t4_free_vi - free a virtual interface  * 	@adap: the adapter  * 	@mbox: mailbox to use for the FW command  * 	@pf: the PF owning the VI  * 	@vf: the VF owning the VI  * 	@viid: virtual interface identifiler  *  * 	Free a previously allocated virtual interface.  */
end_comment

begin_function
name|int
name|t4_free_vi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|)
block|{
name|struct
name|fw_vi_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_VI_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_VI_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_viid
operator|=
name|cpu_to_be16
argument_list|(
name|V_FW_VI_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_rxmode - set Rx properties of a virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@mtu: the new MTU or -1  *	@promisc: 1 to enable promiscuous mode, 0 to disable it, -1 no change  *	@all_multi: 1 to enable all-multi mode, 0 to disable it, -1 no change  *	@bcast: 1 to enable broadcast Rx, 0 to disable it, -1 no change  *	@vlanex: 1 to enable HW VLAN extraction, 0 to disable it, -1 no change  *	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Sets Rx properties of a virtual interface.  */
end_comment

begin_function
name|int
name|t4_set_rxmode
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|int
name|mtu
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|all_multi
parameter_list|,
name|int
name|bcast
parameter_list|,
name|int
name|vlanex
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_vi_rxmode_cmd
name|c
decl_stmt|;
comment|/* convert to FW values */
if|if
condition|(
name|mtu
operator|<
literal|0
condition|)
name|mtu
operator|=
name|M_FW_VI_RXMODE_CMD_MTU
expr_stmt|;
if|if
condition|(
name|promisc
operator|<
literal|0
condition|)
name|promisc
operator|=
name|M_FW_VI_RXMODE_CMD_PROMISCEN
expr_stmt|;
if|if
condition|(
name|all_multi
operator|<
literal|0
condition|)
name|all_multi
operator|=
name|M_FW_VI_RXMODE_CMD_ALLMULTIEN
expr_stmt|;
if|if
condition|(
name|bcast
operator|<
literal|0
condition|)
name|bcast
operator|=
name|M_FW_VI_RXMODE_CMD_BROADCASTEN
expr_stmt|;
if|if
condition|(
name|vlanex
operator|<
literal|0
condition|)
name|vlanex
operator|=
name|M_FW_VI_RXMODE_CMD_VLANEXEN
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_RXMODE_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_VI_RXMODE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|mtu_to_vlanexen
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_VI_RXMODE_CMD_MTU
argument_list|(
name|mtu
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_PROMISCEN
argument_list|(
name|promisc
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_ALLMULTIEN
argument_list|(
name|all_multi
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_BROADCASTEN
argument_list|(
name|bcast
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_VLANEXEN
argument_list|(
name|vlanex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_alloc_mac_filt - allocates exact-match filters for MAC addresses  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@free: if true any existing filters for this VI id are first removed  *	@naddr: the number of MAC addresses to allocate filters for (up to 7)  *	@addr: the MAC address(es)  *	@idx: where to store the index of each allocated filter  *	@hash: pointer to hash address filter bitmap  *	@sleep_ok: call is allowed to sleep  *  *	Allocates an exact-match filter for each of the supplied addresses and  *	sets it to the corresponding address.  If @idx is not %NULL it should  *	have at least @naddr entries, each of which will be set to the index of  *	the filter allocated for the corresponding MAC address.  If a filter  *	could not be allocated for an address its index is set to 0xffff.  *	If @hash is not %NULL addresses that fail to allocate an exact filter  *	are hashed and update the hash filter bitmap pointed at by @hash.  *  *	Returns a negative error number or the number of filters allocated.  */
end_comment

begin_function
name|int
name|t4_alloc_mac_filt
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|bool
name|free
parameter_list|,
name|unsigned
name|int
name|naddr
parameter_list|,
specifier|const
name|u8
modifier|*
modifier|*
name|addr
parameter_list|,
name|u16
modifier|*
name|idx
parameter_list|,
name|u64
modifier|*
name|hash
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|offset
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|fw_vi_mac_cmd
name|c
decl_stmt|;
name|unsigned
name|int
name|nfilters
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|max_naddr
init|=
name|adap
operator|->
name|chip_params
operator|->
name|mps_tcam_size
decl_stmt|;
name|unsigned
name|int
name|rem
init|=
name|naddr
decl_stmt|;
if|if
condition|(
name|naddr
operator|>
name|max_naddr
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|naddr
condition|;
comment|/**/
control|)
block|{
name|unsigned
name|int
name|fw_naddr
init|=
operator|(
name|rem
operator|<
name|ARRAY_SIZE
argument_list|(
name|c
operator|.
name|u
operator|.
name|exact
argument_list|)
condition|?
name|rem
else|:
name|ARRAY_SIZE
argument_list|(
name|c
operator|.
name|u
operator|.
name|exact
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|len16
init|=
name|DIV_ROUND_UP
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|fw_vi_mac_cmd
argument_list|,
name|u
operator|.
name|exact
index|[
name|fw_naddr
index|]
argument_list|)
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|struct
name|fw_vi_mac_exact
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_MAC_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_CMD_EXEC
argument_list|(
name|free
argument_list|)
operator||
name|V_FW_VI_MAC_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|freemacs_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_VI_MAC_CMD_FREEMACS
argument_list|(
name|free
argument_list|)
operator||
name|V_FW_CMD_LEN16
argument_list|(
name|len16
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|c
operator|.
name|u
operator|.
name|exact
init|;
name|i
operator|<
name|fw_naddr
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|p
operator|->
name|valid_to_idx
operator|=
name|cpu_to_be16
argument_list|(
name|F_FW_VI_MAC_CMD_VALID
operator||
name|V_FW_VI_MAC_CMD_IDX
argument_list|(
name|FW_VI_MAC_ADD_MAC
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|macaddr
argument_list|,
name|addr
index|[
name|offset
operator|+
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * It's okay if we run out of space in our MAC address arena. 		 * Some of the addresses we submit may get stored so we need 		 * to run through the reply to see what the results were ... 		 */
name|ret
operator|=
name|t4_wr_mbox_meat
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|ret
operator|!=
operator|-
name|FW_ENOMEM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|c
operator|.
name|u
operator|.
name|exact
init|;
name|i
operator|<
name|fw_naddr
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|u16
name|index
init|=
name|G_FW_VI_MAC_CMD_IDX
argument_list|(
name|be16_to_cpu
argument_list|(
name|p
operator|->
name|valid_to_idx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
condition|)
name|idx
index|[
name|offset
operator|+
name|i
index|]
operator|=
operator|(
name|index
operator|>=
name|max_naddr
condition|?
literal|0xffff
else|:
name|index
operator|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|max_naddr
condition|)
name|nfilters
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|hash
condition|)
operator|*
name|hash
operator||=
operator|(
literal|1ULL
operator|<<
name|hash_mac_addr
argument_list|(
name|addr
index|[
name|offset
operator|+
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
name|free
operator|=
name|false
expr_stmt|;
name|offset
operator|+=
name|fw_naddr
expr_stmt|;
name|rem
operator|-=
name|fw_naddr
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
operator|-
name|FW_ENOMEM
condition|)
name|ret
operator|=
name|nfilters
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_change_mac - modifies the exact-match filter for a MAC address  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@idx: index of existing filter for old value of MAC address, or -1  *	@addr: the new MAC address value  *	@persist: whether a new MAC allocation should be persistent  *	@add_smt: if true also add the address to the HW SMT  *  *	Modifies an exact-match filter and sets it to the new MAC address if  *	@idx>= 0, or adds the MAC address to a new filter if @idx< 0.  In the  *	latter case the address is added persistently if @persist is %true.  *  *	Note that in general it is not possible to modify the value of a given  *	filter so the generic way to modify an address filter is to free the one  *	being used by the old address value and allocate a new filter for the  *	new address value.  *  *	Returns a negative error number or the index of the filter with the new  *	MAC value.  Note that this index may differ from @idx.  */
end_comment

begin_function
name|int
name|t4_change_mac
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
name|bool
name|persist
parameter_list|,
name|bool
name|add_smt
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|fw_vi_mac_cmd
name|c
decl_stmt|;
name|struct
name|fw_vi_mac_exact
modifier|*
name|p
init|=
name|c
operator|.
name|u
operator|.
name|exact
decl_stmt|;
name|unsigned
name|int
name|max_mac_addr
init|=
name|adap
operator|->
name|chip_params
operator|->
name|mps_tcam_size
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
comment|/* new allocation */
name|idx
operator|=
name|persist
condition|?
name|FW_VI_MAC_ADD_PERSIST_MAC
else|:
name|FW_VI_MAC_ADD_MAC
expr_stmt|;
name|mode
operator|=
name|add_smt
condition|?
name|FW_VI_MAC_SMT_AND_MPSTCAM
else|:
name|FW_VI_MAC_MPS_TCAM_ENTRY
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_MAC_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_VI_MAC_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|freemacs_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_LEN16
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|valid_to_idx
operator|=
name|cpu_to_be16
argument_list|(
name|F_FW_VI_MAC_CMD_VALID
operator||
name|V_FW_VI_MAC_CMD_SMAC_RESULT
argument_list|(
name|mode
argument_list|)
operator||
name|V_FW_VI_MAC_CMD_IDX
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|macaddr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|G_FW_VI_MAC_CMD_IDX
argument_list|(
name|be16_to_cpu
argument_list|(
name|p
operator|->
name|valid_to_idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|max_mac_addr
condition|)
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_addr_hash - program the MAC inexact-match hash filter  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@ucast: whether the hash filter should also match unicast addresses  *	@vec: the value to be written to the hash filter  *	@sleep_ok: call is allowed to sleep  *  *	Sets the 64-bit inexact-match hash filter for a virtual interface.  */
end_comment

begin_function
name|int
name|t4_set_addr_hash
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|bool
name|ucast
parameter_list|,
name|u64
name|vec
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_vi_mac_cmd
name|c
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_MAC_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_VI_ENABLE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|V_FW_VI_MAC_CMD_ENTRY_TYPE
argument_list|(
name|FW_VI_MAC_TYPE_HASHVEC
argument_list|)
operator||
name|V_FW_VI_MAC_CMD_HASHUNIEN
argument_list|(
name|ucast
argument_list|)
operator||
name|V_FW_CMD_LEN16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|.
name|freemacs_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|hash
operator|.
name|hashvec
operator|=
name|cpu_to_be64
argument_list|(
name|vec
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_enable_vi_params - enable/disable a virtual interface  *      @adap: the adapter  *      @mbox: mailbox to use for the FW command  *      @viid: the VI id  *      @rx_en: 1=enable Rx, 0=disable Rx  *      @tx_en: 1=enable Tx, 0=disable Tx  *      @dcb_en: 1=enable delivery of Data Center Bridging messages.  *  *      Enables/disables a virtual interface.  Note that setting DCB Enable  *      only makes sense when enabling a Virtual Interface ...  */
end_comment

begin_function
name|int
name|t4_enable_vi_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|bool
name|rx_en
parameter_list|,
name|bool
name|tx_en
parameter_list|,
name|bool
name|dcb_en
parameter_list|)
block|{
name|struct
name|fw_vi_enable_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_ENABLE_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_ENABLE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|ien_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_VI_ENABLE_CMD_IEN
argument_list|(
name|rx_en
argument_list|)
operator||
name|V_FW_VI_ENABLE_CMD_EEN
argument_list|(
name|tx_en
argument_list|)
operator||
name|V_FW_VI_ENABLE_CMD_DCB_INFO
argument_list|(
name|dcb_en
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_ns
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_enable_vi - enable/disable a virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@rx_en: 1=enable Rx, 0=disable Rx  *	@tx_en: 1=enable Tx, 0=disable Tx  *  *	Enables/disables a virtual interface.  Note that setting DCB Enable  *	only makes sense when enabling a Virtual Interface ...  */
end_comment

begin_function
name|int
name|t4_enable_vi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|bool
name|rx_en
parameter_list|,
name|bool
name|tx_en
parameter_list|)
block|{
return|return
name|t4_enable_vi_params
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|viid
argument_list|,
name|rx_en
argument_list|,
name|tx_en
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_identify_port - identify a VI's port by blinking its LED  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@nblinks: how many times to blink LED at 2.5 Hz  *  *	Identifies a VI's port by blinking its LED.  */
end_comment

begin_function
name|int
name|t4_identify_port
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|unsigned
name|int
name|nblinks
parameter_list|)
block|{
name|struct
name|fw_vi_enable_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_ENABLE_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_ENABLE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|ien_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_VI_ENABLE_CMD_LED
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|blinkdur
operator|=
name|cpu_to_be16
argument_list|(
name|nblinks
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_iq_stop - stop an ingress queue and its FLs  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queues  *	@vf: the VF owning the queues  *	@iqtype: the ingress queue type (FW_IQ_TYPE_FL_INT_CAP, etc.)  *	@iqid: ingress queue id  *	@fl0id: FL0 queue id or 0xffff if no attached FL0  *	@fl1id: FL1 queue id or 0xffff if no attached FL1  *  *	Stops an ingress queue and its associated FLs, if any.  This causes  *	any current or future data/messages destined for these queues to be  *	tossed.  */
end_comment

begin_function
name|int
name|t4_iq_stop
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|iqtype
parameter_list|,
name|unsigned
name|int
name|iqid
parameter_list|,
name|unsigned
name|int
name|fl0id
parameter_list|,
name|unsigned
name|int
name|fl1id
parameter_list|)
block|{
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_IQ_CMD_IQSTOP
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_iqandstindex
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_IQ_CMD_TYPE
argument_list|(
name|iqtype
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqid
operator|=
name|cpu_to_be16
argument_list|(
name|iqid
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0id
operator|=
name|cpu_to_be16
argument_list|(
name|fl0id
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl1id
operator|=
name|cpu_to_be16
argument_list|(
name|fl1id
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_iq_free - free an ingress queue and its FLs  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queues  *	@vf: the VF owning the queues  *	@iqtype: the ingress queue type (FW_IQ_TYPE_FL_INT_CAP, etc.)  *	@iqid: ingress queue id  *	@fl0id: FL0 queue id or 0xffff if no attached FL0  *	@fl1id: FL1 queue id or 0xffff if no attached FL1  *  *	Frees an ingress queue and its associated FLs, if any.  */
end_comment

begin_function
name|int
name|t4_iq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|iqtype
parameter_list|,
name|unsigned
name|int
name|iqid
parameter_list|,
name|unsigned
name|int
name|fl0id
parameter_list|,
name|unsigned
name|int
name|fl1id
parameter_list|)
block|{
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_IQ_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_iqandstindex
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_IQ_CMD_TYPE
argument_list|(
name|iqtype
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqid
operator|=
name|cpu_to_be16
argument_list|(
name|iqid
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0id
operator|=
name|cpu_to_be16
argument_list|(
name|fl0id
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl1id
operator|=
name|cpu_to_be16
argument_list|(
name|fl1id
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_eth_eq_free - free an Ethernet egress queue  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queue  *	@vf: the VF owning the queue  *	@eqid: egress queue id  *  *	Frees an Ethernet egress queue.  */
end_comment

begin_function
name|int
name|t4_eth_eq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|eqid
parameter_list|)
block|{
name|struct
name|fw_eq_eth_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_ETH_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_ETH_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_EQ_ETH_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqid_pkd
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_EQ_ETH_CMD_EQID
argument_list|(
name|eqid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_ctrl_eq_free - free a control egress queue  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queue  *	@vf: the VF owning the queue  *	@eqid: egress queue id  *  *	Frees a control egress queue.  */
end_comment

begin_function
name|int
name|t4_ctrl_eq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|eqid
parameter_list|)
block|{
name|struct
name|fw_eq_ctrl_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_CTRL_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_CTRL_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_EQ_CTRL_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_EQ_CTRL_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cmpliqid_eqid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_EQ_CTRL_CMD_EQID
argument_list|(
name|eqid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_ofld_eq_free - free an offload egress queue  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queue  *	@vf: the VF owning the queue  *	@eqid: egress queue id  *  *	Frees a control egress queue.  */
end_comment

begin_function
name|int
name|t4_ofld_eq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|eqid
parameter_list|)
block|{
name|struct
name|fw_eq_ofld_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_OFLD_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_OFLD_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_EQ_OFLD_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|F_FW_EQ_OFLD_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqid_pkd
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_EQ_OFLD_CMD_EQID
argument_list|(
name|eqid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_link_down_rc_str - return a string for a Link Down Reason Code  *	@link_down_rc: Link Down Reason Code  *  *	Returns a string representation of the Link Down Reason Code.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|t4_link_down_rc_str
parameter_list|(
name|unsigned
name|char
name|link_down_rc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|reason
index|[]
init|=
block|{
literal|"Link Down"
block|,
literal|"Remote Fault"
block|,
literal|"Auto-negotiation Failure"
block|,
literal|"Reserved3"
block|,
literal|"Insufficient Airflow"
block|,
literal|"Unable To Determine Reason"
block|,
literal|"No RX Signal Detected"
block|,
literal|"Reserved7"
block|, 	}
decl_stmt|;
if|if
condition|(
name|link_down_rc
operator|>=
name|ARRAY_SIZE
argument_list|(
name|reason
argument_list|)
condition|)
return|return
literal|"Bad Reason Code"
return|;
return|return
name|reason
index|[
name|link_down_rc
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Updates all fields owned by the common code in port_info and link_config  * based on information provided by the firmware.  Does not touch any  * requested_* field.  */
end_comment

begin_function
specifier|static
name|void
name|handle_port_info
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|struct
name|fw_port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|link_config
modifier|*
name|lc
init|=
operator|&
name|pi
operator|->
name|link_cfg
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|unsigned
name|char
name|fc
decl_stmt|,
name|fec
decl_stmt|;
name|u32
name|stat
init|=
name|be32_to_cpu
argument_list|(
name|p
operator|->
name|lstatus_to_modtype
argument_list|)
decl_stmt|;
name|pi
operator|->
name|port_type
operator|=
name|G_FW_PORT_CMD_PTYPE
argument_list|(
name|stat
argument_list|)
expr_stmt|;
name|pi
operator|->
name|mod_type
operator|=
name|G_FW_PORT_CMD_MODTYPE
argument_list|(
name|stat
argument_list|)
expr_stmt|;
name|pi
operator|->
name|mdio_addr
operator|=
name|stat
operator|&
name|F_FW_PORT_CMD_MDIOCAP
condition|?
name|G_FW_PORT_CMD_MDIOADDR
argument_list|(
name|stat
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
name|lc
operator|->
name|supported
operator|=
name|be16_to_cpu
argument_list|(
name|p
operator|->
name|pcap
argument_list|)
expr_stmt|;
name|lc
operator|->
name|advertising
operator|=
name|be16_to_cpu
argument_list|(
name|p
operator|->
name|acap
argument_list|)
expr_stmt|;
name|lc
operator|->
name|lp_advertising
operator|=
name|be16_to_cpu
argument_list|(
name|p
operator|->
name|lpacap
argument_list|)
expr_stmt|;
name|lc
operator|->
name|link_ok
operator|=
operator|(
name|stat
operator|&
name|F_FW_PORT_CMD_LSTATUS
operator|)
operator|!=
literal|0
expr_stmt|;
name|lc
operator|->
name|link_down_rc
operator|=
name|G_FW_PORT_CMD_LINKDNRC
argument_list|(
name|stat
argument_list|)
expr_stmt|;
name|speed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_100M
argument_list|)
condition|)
name|speed
operator|=
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_1G
argument_list|)
condition|)
name|speed
operator|=
literal|1000
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_10G
argument_list|)
condition|)
name|speed
operator|=
literal|10000
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_25G
argument_list|)
condition|)
name|speed
operator|=
literal|25000
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_40G
argument_list|)
condition|)
name|speed
operator|=
literal|40000
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_100G
argument_list|)
condition|)
name|speed
operator|=
literal|100000
expr_stmt|;
name|lc
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|F_FW_PORT_CMD_RXPAUSE
condition|)
name|fc
operator||=
name|PAUSE_RX
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|F_FW_PORT_CMD_TXPAUSE
condition|)
name|fc
operator||=
name|PAUSE_TX
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
name|fc
expr_stmt|;
name|fec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|advertising
operator|&
name|FW_PORT_CAP_FEC_RS
condition|)
name|fec
operator||=
name|FEC_RS
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|advertising
operator|&
name|FW_PORT_CAP_FEC_BASER_RS
condition|)
name|fec
operator||=
name|FEC_BASER_RS
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|advertising
operator|&
name|FW_PORT_CAP_FEC_RESERVED
condition|)
name|fec
operator||=
name|FEC_RESERVED
expr_stmt|;
name|lc
operator|->
name|fec
operator|=
name|fec
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_update_port_info - retrieve and update port information if changed  *	@pi: the port_info  *  *	We issue a Get Port Information Command to the Firmware and, if  *	successful, we check to see if anything is different from what we  *	last recorded and update things accordingly.  */
end_comment

begin_function
name|int
name|t4_update_port_info
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|fw_port_cmd
name|port_cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|port_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|port_cmd
argument_list|)
expr_stmt|;
name|port_cmd
operator|.
name|op_to_portid
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PORT_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_PORT_CMD_PORTID
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
argument_list|)
expr_stmt|;
name|port_cmd
operator|.
name|action_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_PORT_CMD_ACTION
argument_list|(
name|FW_PORT_ACTION_GET_PORT_INFO
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|port_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox_ns
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|pi
operator|->
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|port_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|port_cmd
argument_list|)
argument_list|,
operator|&
name|port_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|handle_port_info
argument_list|(
name|pi
argument_list|,
operator|&
name|port_cmd
operator|.
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_handle_fw_rpl - process a FW reply message  *	@adap: the adapter  *	@rpl: start of the FW message  *  *	Processes a FW message, such as link state change messages.  */
end_comment

begin_function
name|int
name|t4_handle_fw_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
name|u8
name|opcode
init|=
operator|*
operator|(
specifier|const
name|u8
operator|*
operator|)
name|rpl
decl_stmt|;
specifier|const
name|struct
name|fw_port_cmd
modifier|*
name|p
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|rpl
decl_stmt|;
name|unsigned
name|int
name|action
init|=
name|G_FW_PORT_CMD_ACTION
argument_list|(
name|be32_to_cpu
argument_list|(
name|p
operator|->
name|action_to_len16
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|FW_PORT_CMD
operator|&&
name|action
operator|==
name|FW_PORT_ACTION_GET_PORT_INFO
condition|)
block|{
comment|/* link/module state change message */
name|int
name|i
decl_stmt|,
name|old_ptype
decl_stmt|,
name|old_mtype
decl_stmt|;
name|int
name|chan
init|=
name|G_FW_PORT_CMD_PORTID
argument_list|(
name|be32_to_cpu
argument_list|(
name|p
operator|->
name|op_to_portid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|NULL
decl_stmt|;
name|struct
name|link_config
modifier|*
name|lc
decl_stmt|,
name|old_lc
decl_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
block|{
name|pi
operator|=
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|tx_chan
operator|==
name|chan
condition|)
break|break;
block|}
name|lc
operator|=
operator|&
name|pi
operator|->
name|link_cfg
expr_stmt|;
name|old_lc
operator|=
operator|*
name|lc
expr_stmt|;
name|old_ptype
operator|=
name|pi
operator|->
name|port_type
expr_stmt|;
name|old_mtype
operator|=
name|pi
operator|->
name|mod_type
expr_stmt|;
name|handle_port_info
argument_list|(
name|pi
argument_list|,
operator|&
name|p
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_ptype
operator|!=
name|pi
operator|->
name|port_type
operator|||
name|old_mtype
operator|!=
name|pi
operator|->
name|mod_type
condition|)
block|{
name|t4_os_portmod_changed
argument_list|(
name|pi
argument_list|,
name|old_ptype
argument_list|,
name|old_mtype
argument_list|,
operator|&
name|old_lc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_lc
operator|.
name|link_ok
operator|!=
name|lc
operator|->
name|link_ok
operator|||
name|old_lc
operator|.
name|speed
operator|!=
name|lc
operator|->
name|speed
operator|||
name|old_lc
operator|.
name|fc
operator|!=
name|lc
operator|->
name|fc
condition|)
block|{
name|t4_os_link_changed
argument_list|(
name|pi
argument_list|,
operator|&
name|old_lc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CH_WARN_RATELIMIT
argument_list|(
name|adap
argument_list|,
literal|"Unknown firmware reply %d\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	get_pci_mode - determine a card's PCI mode  *	@adapter: the adapter  *	@p: where to store the PCI settings  *  *	Determines a card's PCI mode and associated parameters, such as speed  *	and width.  */
end_comment

begin_function
specifier|static
name|void
name|get_pci_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|pci_params
modifier|*
name|p
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|u32
name|pcie_cap
decl_stmt|;
name|pcie_cap
operator|=
name|t4_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_cap
condition|)
block|{
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_LNKSTA
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|p
operator|->
name|speed
operator|=
name|val
operator|&
name|PCI_EXP_LNKSTA_CLS
expr_stmt|;
name|p
operator|->
name|width
operator|=
operator|(
name|val
operator|&
name|PCI_EXP_LNKSTA_NLW
operator|)
operator|>>
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|flash_desc
block|{
name|u32
name|vendor_and_model_id
decl_stmt|;
name|u32
name|size_mb
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|t4_get_flash_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* 	 * Table for non-standard supported Flash parts.  Note, all Flash 	 * parts must have 64KB sectors. 	 */
specifier|static
name|struct
name|flash_desc
name|supported_flash
index|[]
init|=
block|{
block|{
literal|0x00150201
block|,
literal|4
operator|<<
literal|20
block|}
block|,
comment|/* Spansion 4MB S25FL032P */
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u32
name|flashid
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|part
decl_stmt|,
name|manufacturer
decl_stmt|;
name|unsigned
name|int
name|density
decl_stmt|,
name|size
decl_stmt|;
comment|/* 	 * Issue a Read ID Command to the Flash part.  We decode supported 	 * Flash parts and their sizes from this.  There's a newer Query 	 * Command which can retrieve detailed geometry information but many 	 * Flash parts don't support it. 	 */
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|SF_RD_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|flashid
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* 	 * Check to see if it's one of our non-standard supported Flash parts. 	 */
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|ARRAY_SIZE
argument_list|(
name|supported_flash
argument_list|)
condition|;
name|part
operator|++
control|)
if|if
condition|(
name|supported_flash
index|[
name|part
index|]
operator|.
name|vendor_and_model_id
operator|==
name|flashid
condition|)
block|{
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|=
name|supported_flash
index|[
name|part
index|]
operator|.
name|size_mb
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|sf_nsec
operator|=
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|/
name|SF_SEC_SIZE
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* 	 * Decode Flash part size.  The code below looks repetative with 	 * common encodings, but that's not guaranteed in the JEDEC 	 * specification for the Read JADEC ID command.  The only thing that 	 * we're guaranteed by the JADEC specification is where the 	 * Manufacturer ID is in the returned result.  After that each 	 * Manufacturer ~could~ encode things completely differently. 	 * Note, all Flash parts must have 64KB sectors. 	 */
name|manufacturer
operator|=
name|flashid
operator|&
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|manufacturer
condition|)
block|{
case|case
literal|0x20
case|:
block|{
comment|/* Micron/Numonix */
comment|/* 		 * This Density -> Size decoding table is taken from Micron 		 * Data Sheets. 		 */
name|density
operator|=
operator|(
name|flashid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|density
condition|)
block|{
case|case
literal|0x14
case|:
name|size
operator|=
literal|1
operator|<<
literal|20
expr_stmt|;
break|break;
comment|/*   1MB */
case|case
literal|0x15
case|:
name|size
operator|=
literal|1
operator|<<
literal|21
expr_stmt|;
break|break;
comment|/*   2MB */
case|case
literal|0x16
case|:
name|size
operator|=
literal|1
operator|<<
literal|22
expr_stmt|;
break|break;
comment|/*   4MB */
case|case
literal|0x17
case|:
name|size
operator|=
literal|1
operator|<<
literal|23
expr_stmt|;
break|break;
comment|/*   8MB */
case|case
literal|0x18
case|:
name|size
operator|=
literal|1
operator|<<
literal|24
expr_stmt|;
break|break;
comment|/*  16MB */
case|case
literal|0x19
case|:
name|size
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
break|break;
comment|/*  32MB */
case|case
literal|0x20
case|:
name|size
operator|=
literal|1
operator|<<
literal|26
expr_stmt|;
break|break;
comment|/*  64MB */
case|case
literal|0x21
case|:
name|size
operator|=
literal|1
operator|<<
literal|27
expr_stmt|;
break|break;
comment|/* 128MB */
case|case
literal|0x22
case|:
name|size
operator|=
literal|1
operator|<<
literal|28
expr_stmt|;
break|break;
comment|/* 256MB */
default|default:
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"Micron Flash Part has bad size, "
literal|"ID = %#x, Density code = %#x\n"
argument_list|,
name|flashid
argument_list|,
name|density
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
block|}
case|case
literal|0xef
case|:
block|{
comment|/* Winbond */
comment|/* 		 * This Density -> Size decoding table is taken from Winbond 		 * Data Sheets. 		 */
name|density
operator|=
operator|(
name|flashid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|density
condition|)
block|{
case|case
literal|0x17
case|:
name|size
operator|=
literal|1
operator|<<
literal|23
expr_stmt|;
break|break;
comment|/*   8MB */
case|case
literal|0x18
case|:
name|size
operator|=
literal|1
operator|<<
literal|24
expr_stmt|;
break|break;
comment|/*  16MB */
default|default:
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"Winbond Flash Part has bad size, "
literal|"ID = %#x, Density code = %#x\n"
argument_list|,
name|flashid
argument_list|,
name|density
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
block|}
default|default:
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"Unsupported Flash Part, ID = %#x\n"
argument_list|,
name|flashid
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Store decoded Flash size and fall through into vetting code. 	 */
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|=
name|size
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|sf_nsec
operator|=
name|size
operator|/
name|SF_SEC_SIZE
expr_stmt|;
name|found
label|:
comment|/* 	 * We should ~probably~ reject adapters with FLASHes which are too 	 * small but we have some legacy FPGAs with small FLASHes that we'd 	 * still like to use.  So instead we emit a scary message ... 	 */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|<
name|FLASH_MIN_SIZE
condition|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"WARNING: Flash Part ID %#x, size %#x< %#x\n"
argument_list|,
name|flashid
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|sf_size
argument_list|,
name|FLASH_MIN_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_pcie_completion_timeout
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u8
name|range
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|u32
name|pcie_cap
decl_stmt|;
name|pcie_cap
operator|=
name|t4_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_cap
condition|)
block|{
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_DEVCTL2
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xfff0
expr_stmt|;
name|val
operator||=
name|range
expr_stmt|;
name|t4_os_pci_write_cfg2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_DEVCTL2
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|struct
name|chip_params
modifier|*
name|t4_get_chip_params
parameter_list|(
name|int
name|chipid
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|chip_params
name|chip_params
index|[]
init|=
block|{
block|{
comment|/* T4 */
operator|.
name|nchan
operator|=
name|NCHAN
block|,
operator|.
name|pm_stats_cnt
operator|=
name|PM_NSTATS
block|,
operator|.
name|cng_ch_bits_log
operator|=
literal|2
block|,
operator|.
name|nsched_cls
operator|=
literal|15
block|,
operator|.
name|cim_num_obq
operator|=
name|CIM_NUM_OBQ
block|,
operator|.
name|mps_rplc_size
operator|=
literal|128
block|,
operator|.
name|vfcount
operator|=
literal|128
block|,
operator|.
name|sge_fl_db
operator|=
name|F_DBPRIO
block|,
operator|.
name|mps_tcam_size
operator|=
name|NUM_MPS_CLS_SRAM_L_INSTANCES
block|, 		}
block|,
block|{
comment|/* T5 */
operator|.
name|nchan
operator|=
name|NCHAN
block|,
operator|.
name|pm_stats_cnt
operator|=
name|PM_NSTATS
block|,
operator|.
name|cng_ch_bits_log
operator|=
literal|2
block|,
operator|.
name|nsched_cls
operator|=
literal|16
block|,
operator|.
name|cim_num_obq
operator|=
name|CIM_NUM_OBQ_T5
block|,
operator|.
name|mps_rplc_size
operator|=
literal|128
block|,
operator|.
name|vfcount
operator|=
literal|128
block|,
operator|.
name|sge_fl_db
operator|=
name|F_DBPRIO
operator||
name|F_DBTYPE
block|,
operator|.
name|mps_tcam_size
operator|=
name|NUM_MPS_T5_CLS_SRAM_L_INSTANCES
block|, 		}
block|,
block|{
comment|/* T6 */
operator|.
name|nchan
operator|=
name|T6_NCHAN
block|,
operator|.
name|pm_stats_cnt
operator|=
name|T6_PM_NSTATS
block|,
operator|.
name|cng_ch_bits_log
operator|=
literal|3
block|,
operator|.
name|nsched_cls
operator|=
literal|16
block|,
operator|.
name|cim_num_obq
operator|=
name|CIM_NUM_OBQ_T5
block|,
operator|.
name|mps_rplc_size
operator|=
literal|256
block|,
operator|.
name|vfcount
operator|=
literal|256
block|,
operator|.
name|sge_fl_db
operator|=
literal|0
block|,
operator|.
name|mps_tcam_size
operator|=
name|NUM_MPS_T5_CLS_SRAM_L_INSTANCES
block|, 		}
block|, 	}
decl_stmt|;
name|chipid
operator|-=
name|CHELSIO_T4
expr_stmt|;
if|if
condition|(
name|chipid
operator|<
literal|0
operator|||
name|chipid
operator|>=
name|ARRAY_SIZE
argument_list|(
name|chip_params
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|chip_params
index|[
name|chipid
index|]
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_prep_adapter - prepare SW and HW for operation  *	@adapter: the adapter  *	@buf: temporary space of at least VPD_LEN size provided by the caller.  *  *	Initialize adapter SW state for the various HW modules, set initial  *	values for some adapter tunables, take PHYs out of reset, and  *	initialize the MDIO interface.  */
end_comment

begin_function
name|int
name|t4_prep_adapter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|uint32_t
name|pl_rev
decl_stmt|;
name|get_pci_mode
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|pci
argument_list|)
expr_stmt|;
name|pl_rev
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_REV
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|=
name|G_CHIPID
argument_list|(
name|pl_rev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|rev
operator|=
name|G_REV
argument_list|(
name|pl_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|==
literal|0
condition|)
block|{
comment|/* T4 did not have chipid in PL_REV (T5 onwards do) */
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|=
name|CHELSIO_T4
expr_stmt|;
comment|/* T4A1 chip is not supported */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|1
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"T4 rev 1 chip is not supported.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|adapter
operator|->
name|chip_params
operator|=
name|t4_get_chip_params
argument_list|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|chip_params
operator|==
name|NULL
condition|)
return|return
operator|-
name|EINVAL
return|;
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
operator|=
name|t4_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_VPD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_get_flash_params
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|get_vpd_params
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|vpd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* Cards with real ASICs have the chipid in the PCIe device id */
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|PCI_DEVICE_ID
argument_list|,
operator|&
name|device_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_id
operator|>>
literal|12
operator|==
name|chip_id
argument_list|(
name|adapter
argument_list|)
condition|)
name|adapter
operator|->
name|params
operator|.
name|cim_la_size
operator|=
name|CIMLA_SIZE
expr_stmt|;
else|else
block|{
comment|/* FPGA */
name|adapter
operator|->
name|params
operator|.
name|fpga
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|cim_la_size
operator|=
literal|2
operator|*
name|CIMLA_SIZE
expr_stmt|;
block|}
name|init_cong_ctrl
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|a_wnd
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|b_wnd
argument_list|)
expr_stmt|;
comment|/* 	 * Default port and clock for debugging in case we can't reach FW. 	 */
name|adapter
operator|->
name|params
operator|.
name|nports
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|portvec
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|=
literal|50000
expr_stmt|;
comment|/* Set pci completion timeout value to 4 seconds. */
name|set_pcie_completion_timeout
argument_list|(
name|adapter
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_shutdown_adapter - shut down adapter, host& wire  *	@adapter: the adapter  *  *	Perform an emergency shutdown of the adapter and stop it from  *	continuing any further communication on the ports or DMA to the  *	host.  This is typically used when the adapter and/or firmware  *	have crashed and we want to prevent any further accidental  *	communication with the rest of the world.  This will also force  *	the port Link Status to go down -- if register writes work --  *	which should help our peers figure out that we're down.  */
end_comment

begin_function
name|int
name|t4_shutdown_adapter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|t4_intr_disable
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_DBG_GPIO_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|port
argument_list|)
block|{
name|u32
name|a_port_cfg
init|=
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|?
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_CFG
argument_list|)
else|:
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_CFG
argument_list|)
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|a_port_cfg
argument_list|,
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|a_port_cfg
argument_list|)
operator|&
operator|~
name|V_SIGNAL_DET
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t4_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_init_devlog_params - initialize adapter->params.devlog  *	@adap: the adapter  *	@fw_attach: whether we can talk to the firmware  *  *	Initialize various fields of the adapter's Firmware Device Log  *	Parameters structure.  */
end_comment

begin_function
name|int
name|t4_init_devlog_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|fw_attach
parameter_list|)
block|{
name|struct
name|devlog_params
modifier|*
name|dparams
init|=
operator|&
name|adap
operator|->
name|params
operator|.
name|devlog
decl_stmt|;
name|u32
name|pf_dparams
decl_stmt|;
name|unsigned
name|int
name|devlog_meminfo
decl_stmt|;
name|struct
name|fw_devlog_cmd
name|devlog_cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* If we're dealing with newer firmware, the Device Log Paramerters 	 * are stored in a designated register which allows us to access the 	 * Device Log even if we can't talk to the firmware. 	 */
name|pf_dparams
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|PCIE_FW_REG
argument_list|(
name|A_PCIE_FW_PF
argument_list|,
name|PCIE_FW_PF_DEVLOG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_dparams
condition|)
block|{
name|unsigned
name|int
name|nentries
decl_stmt|,
name|nentries128
decl_stmt|;
name|dparams
operator|->
name|memtype
operator|=
name|G_PCIE_FW_PF_DEVLOG_MEMTYPE
argument_list|(
name|pf_dparams
argument_list|)
expr_stmt|;
name|dparams
operator|->
name|start
operator|=
name|G_PCIE_FW_PF_DEVLOG_ADDR16
argument_list|(
name|pf_dparams
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|nentries128
operator|=
name|G_PCIE_FW_PF_DEVLOG_NENTRIES128
argument_list|(
name|pf_dparams
argument_list|)
expr_stmt|;
name|nentries
operator|=
operator|(
name|nentries128
operator|+
literal|1
operator|)
operator|*
literal|128
expr_stmt|;
name|dparams
operator|->
name|size
operator|=
name|nentries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fw_devlog_e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * For any failing returns ... 	 */
name|memset
argument_list|(
name|dparams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|dparams
argument_list|)
expr_stmt|;
comment|/* 	 * If we can't talk to the firmware, there's really nothing we can do 	 * at this point. 	 */
if|if
condition|(
operator|!
name|fw_attach
condition|)
return|return
operator|-
name|ENXIO
return|;
comment|/* Otherwise, ask the firmware for it's Device Log Parameters. 	 */
name|memset
argument_list|(
operator|&
name|devlog_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|devlog_cmd
argument_list|)
expr_stmt|;
name|devlog_cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_DEVLOG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|devlog_cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|mbox
argument_list|,
operator|&
name|devlog_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|,
operator|&
name|devlog_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|devlog_meminfo
operator|=
name|be32_to_cpu
argument_list|(
name|devlog_cmd
operator|.
name|memtype_devlog_memaddr16_devlog
argument_list|)
expr_stmt|;
name|dparams
operator|->
name|memtype
operator|=
name|G_FW_DEVLOG_CMD_MEMTYPE_DEVLOG
argument_list|(
name|devlog_meminfo
argument_list|)
expr_stmt|;
name|dparams
operator|->
name|start
operator|=
name|G_FW_DEVLOG_CMD_MEMADDR16_DEVLOG
argument_list|(
name|devlog_meminfo
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|dparams
operator|->
name|size
operator|=
name|be32_to_cpu
argument_list|(
name|devlog_cmd
operator|.
name|memsize_devlog
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_init_sge_params - initialize adap->params.sge  *	@adapter: the adapter  *  *	Initialize various fields of the adapter's SGE Parameters structure.  */
end_comment

begin_function
name|int
name|t4_init_sge_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|r
decl_stmt|;
name|struct
name|sge_params
modifier|*
name|sp
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|sge
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|tscale
init|=
literal|1
decl_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INGRESS_RX_THRESHOLD
argument_list|)
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|0
index|]
operator|=
name|G_THRESHOLD_0
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|1
index|]
operator|=
name|G_THRESHOLD_1
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|2
index|]
operator|=
name|G_THRESHOLD_2
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|sp
operator|->
name|counter_val
index|[
literal|3
index|]
operator|=
name|G_THRESHOLD_3
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|>=
name|CHELSIO_T6
condition|)
block|{
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_ITP_CONTROL
argument_list|)
expr_stmt|;
name|tscale
operator|=
name|G_TSCALE
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tscale
operator|==
literal|0
condition|)
name|tscale
operator|=
literal|1
expr_stmt|;
else|else
name|tscale
operator|+=
literal|2
expr_stmt|;
block|}
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_TIMER_VALUE_0_AND_1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|0
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE0
argument_list|(
name|r
argument_list|)
argument_list|)
operator|*
name|tscale
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|1
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE1
argument_list|(
name|r
argument_list|)
argument_list|)
operator|*
name|tscale
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_TIMER_VALUE_2_AND_3
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|2
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE2
argument_list|(
name|r
argument_list|)
argument_list|)
operator|*
name|tscale
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|3
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE3
argument_list|(
name|r
argument_list|)
argument_list|)
operator|*
name|tscale
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_TIMER_VALUE_4_AND_5
argument_list|)
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|4
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE4
argument_list|(
name|r
argument_list|)
argument_list|)
operator|*
name|tscale
expr_stmt|;
name|sp
operator|->
name|timer_val
index|[
literal|5
index|]
operator|=
name|core_ticks_to_us
argument_list|(
name|adapter
argument_list|,
name|G_TIMERVALUE5
argument_list|(
name|r
argument_list|)
argument_list|)
operator|*
name|tscale
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_CONM_CTRL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fl_starve_threshold
operator|=
name|G_EGRTHRESHOLD
argument_list|(
name|r
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
name|sp
operator|->
name|fl_starve_threshold2
operator|=
name|sp
operator|->
name|fl_starve_threshold
expr_stmt|;
elseif|else
if|if
condition|(
name|is_t5
argument_list|(
name|adapter
argument_list|)
condition|)
name|sp
operator|->
name|fl_starve_threshold2
operator|=
name|G_EGRTHRESHOLDPACKING
argument_list|(
name|r
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
else|else
name|sp
operator|->
name|fl_starve_threshold2
operator|=
name|G_T6_EGRTHRESHOLDPACKING
argument_list|(
name|r
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
comment|/* egress queues: log2 of # of doorbells per BAR2 page */
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_EGRESS_QUEUES_PER_PAGE_PF
argument_list|)
expr_stmt|;
name|r
operator|>>=
name|S_QUEUESPERPAGEPF0
operator|+
operator|(
name|S_QUEUESPERPAGEPF1
operator|-
name|S_QUEUESPERPAGEPF0
operator|)
operator|*
name|adapter
operator|->
name|pf
expr_stmt|;
name|sp
operator|->
name|eq_s_qpp
operator|=
name|r
operator|&
name|M_QUEUESPERPAGEPF0
expr_stmt|;
comment|/* ingress queues: log2 of # of doorbells per BAR2 page */
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INGRESS_QUEUES_PER_PAGE_PF
argument_list|)
expr_stmt|;
name|r
operator|>>=
name|S_QUEUESPERPAGEPF0
operator|+
operator|(
name|S_QUEUESPERPAGEPF1
operator|-
name|S_QUEUESPERPAGEPF0
operator|)
operator|*
name|adapter
operator|->
name|pf
expr_stmt|;
name|sp
operator|->
name|iq_s_qpp
operator|=
name|r
operator|&
name|M_QUEUESPERPAGEPF0
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_HOST_PAGE_SIZE
argument_list|)
expr_stmt|;
name|r
operator|>>=
name|S_HOSTPAGESIZEPF0
operator|+
operator|(
name|S_HOSTPAGESIZEPF1
operator|-
name|S_HOSTPAGESIZEPF0
operator|)
operator|*
name|adapter
operator|->
name|pf
expr_stmt|;
name|sp
operator|->
name|page_shift
operator|=
operator|(
name|r
operator|&
name|M_HOSTPAGESIZEPF0
operator|)
operator|+
literal|10
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_CONTROL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sge_control
operator|=
name|r
expr_stmt|;
name|sp
operator|->
name|spg_len
operator|=
name|r
operator|&
name|F_EGRSTATUSPAGESIZE
condition|?
literal|128
else|:
literal|64
expr_stmt|;
name|sp
operator|->
name|fl_pktshift
operator|=
name|G_PKTSHIFT
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
block|{
name|sp
operator|->
name|pad_boundary
operator|=
literal|1
operator|<<
operator|(
name|G_INGPADBOUNDARY
argument_list|(
name|r
argument_list|)
operator|+
name|X_INGPADBOUNDARY_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|pad_boundary
operator|=
literal|1
operator|<<
operator|(
name|G_INGPADBOUNDARY
argument_list|(
name|r
argument_list|)
operator|+
name|X_T6_INGPADBOUNDARY_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
name|sp
operator|->
name|pack_boundary
operator|=
name|sp
operator|->
name|pad_boundary
expr_stmt|;
else|else
block|{
name|r
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_CONTROL2
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_INGPACKBOUNDARY
argument_list|(
name|r
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|->
name|pack_boundary
operator|=
literal|16
expr_stmt|;
else|else
name|sp
operator|->
name|pack_boundary
operator|=
literal|1
operator|<<
operator|(
name|G_INGPACKBOUNDARY
argument_list|(
name|r
argument_list|)
operator|+
literal|5
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_FLBUF_SIZES
condition|;
name|i
operator|++
control|)
name|sp
operator|->
name|sge_fl_buffer_size
index|[
name|i
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_FL_BUFFER_SIZE0
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read and cache the adapter's compressed filter mode and ingress config.  */
end_comment

begin_function
specifier|static
name|void
name|read_filter_mode_and_ingress_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|struct
name|tp_params
modifier|*
name|tpp
init|=
operator|&
name|adap
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|t4_tp_pio_read
argument_list|(
name|adap
argument_list|,
operator|&
name|tpp
operator|->
name|vlan_pri_map
argument_list|,
literal|1
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|t4_tp_pio_read
argument_list|(
name|adap
argument_list|,
operator|&
name|tpp
operator|->
name|ingress_config
argument_list|,
literal|1
argument_list|,
name|A_TP_INGRESS_CONFIG
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we have TP_VLAN_PRI_MAP cached, we can calculate the field 	 * shift positions of several elements of the Compressed Filter Tuple 	 * for this adapter which we need frequently ... 	 */
name|tpp
operator|->
name|fcoe_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_FCOE
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|port_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_PORT
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|vnic_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_VNIC_ID
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|vlan_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_VLAN
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|tos_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_TOS
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|protocol_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_PROTOCOL
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|ethertype_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_ETHERTYPE
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|macmatch_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_MACMATCH
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|matchtype_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_MPSHITTYPE
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|frag_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_FRAGMENTATION
argument_list|)
expr_stmt|;
comment|/* 	 * If TP_INGRESS_CONFIG.VNID == 0, then TP_VLAN_PRI_MAP.VNIC_ID 	 * represents the presence of an Outer VLAN instead of a VNIC ID. 	 */
if|if
condition|(
operator|(
name|tpp
operator|->
name|ingress_config
operator|&
name|F_VNIC
operator|)
operator|==
literal|0
condition|)
name|tpp
operator|->
name|vnic_shift
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *      t4_init_tp_params - initialize adap->params.tp  *      @adap: the adapter  *  *      Initialize various fields of the adapter's TP Parameters structure.  */
end_comment

begin_function
name|int
name|t4_init_tp_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|chan
decl_stmt|;
name|u32
name|v
decl_stmt|;
name|struct
name|tp_params
modifier|*
name|tpp
init|=
operator|&
name|adap
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TIMER_RESOLUTION
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|tre
operator|=
name|G_TIMERRESOLUTION
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|tpp
operator|->
name|dack_re
operator|=
name|G_DELAYEDACKRESOLUTION
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* MODQ_REQ_MAP defaults to setting queues 0-3 to chan 0-3 */
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|MAX_NCHAN
condition|;
name|chan
operator|++
control|)
name|tpp
operator|->
name|tx_modq
index|[
name|chan
index|]
operator|=
name|chan
expr_stmt|;
name|read_filter_mode_and_ingress_config
argument_list|(
name|adap
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
comment|/* 	 * Cache a mask of the bits that represent the error vector portion of 	 * rx_pkt.err_vec.  T6+ can use a compressed error vector to make room 	 * for information about outer encapsulation (GENEVE/VXLAN/NVGRE). 	 */
name|tpp
operator|->
name|err_vec_mask
operator|=
name|htobe16
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adap
argument_list|)
operator|>
name|CHELSIO_T5
condition|)
block|{
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_OUT_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|F_CRXPKTENC
condition|)
block|{
name|tpp
operator|->
name|err_vec_mask
operator|=
name|htobe16
argument_list|(
name|V_T6_COMPR_RXERR_VEC
argument_list|(
name|M_T6_COMPR_RXERR_VEC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_filter_field_shift - calculate filter field shift  *      @adap: the adapter  *      @filter_sel: the desired field (from TP_VLAN_PRI_MAP bits)  *  *      Return the shift position of a filter field within the Compressed  *      Filter Tuple.  The filter field is specified via its selection bit  *      within TP_VLAN_PRI_MAL (filter mode).  E.g. F_VLAN.  */
end_comment

begin_function
name|int
name|t4_filter_field_shift
parameter_list|(
specifier|const
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|filter_sel
parameter_list|)
block|{
name|unsigned
name|int
name|filter_mode
init|=
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
decl_stmt|;
name|unsigned
name|int
name|sel
decl_stmt|;
name|int
name|field_shift
decl_stmt|;
if|if
condition|(
operator|(
name|filter_mode
operator|&
name|filter_sel
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|sel
operator|=
literal|1
operator|,
name|field_shift
operator|=
literal|0
init|;
name|sel
operator|<
name|filter_sel
condition|;
name|sel
operator|<<=
literal|1
control|)
block|{
switch|switch
condition|(
name|filter_mode
operator|&
name|sel
condition|)
block|{
case|case
name|F_FCOE
case|:
name|field_shift
operator|+=
name|W_FT_FCOE
expr_stmt|;
break|break;
case|case
name|F_PORT
case|:
name|field_shift
operator|+=
name|W_FT_PORT
expr_stmt|;
break|break;
case|case
name|F_VNIC_ID
case|:
name|field_shift
operator|+=
name|W_FT_VNIC_ID
expr_stmt|;
break|break;
case|case
name|F_VLAN
case|:
name|field_shift
operator|+=
name|W_FT_VLAN
expr_stmt|;
break|break;
case|case
name|F_TOS
case|:
name|field_shift
operator|+=
name|W_FT_TOS
expr_stmt|;
break|break;
case|case
name|F_PROTOCOL
case|:
name|field_shift
operator|+=
name|W_FT_PROTOCOL
expr_stmt|;
break|break;
case|case
name|F_ETHERTYPE
case|:
name|field_shift
operator|+=
name|W_FT_ETHERTYPE
expr_stmt|;
break|break;
case|case
name|F_MACMATCH
case|:
name|field_shift
operator|+=
name|W_FT_MACMATCH
expr_stmt|;
break|break;
case|case
name|F_MPSHITTYPE
case|:
name|field_shift
operator|+=
name|W_FT_MPSHITTYPE
expr_stmt|;
break|break;
case|case
name|F_FRAGMENTATION
case|:
name|field_shift
operator|+=
name|W_FT_FRAGMENTATION
expr_stmt|;
break|break;
block|}
block|}
return|return
name|field_shift
return|;
block|}
end_function

begin_function
name|int
name|t4_port_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|mbox
parameter_list|,
name|int
name|pf
parameter_list|,
name|int
name|vf
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
name|u8
name|addr
index|[
literal|6
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|fw_port_cmd
name|c
decl_stmt|;
name|u16
name|rss_size
decl_stmt|;
name|struct
name|port_info
modifier|*
name|p
init|=
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|port_id
argument_list|)
decl_stmt|;
name|u32
name|param
decl_stmt|,
name|val
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|p
operator|->
name|port_id
condition|;
name|i
operator|++
control|)
block|{
do|do
block|{
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|adap
operator|->
name|params
operator|.
name|portvec
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
operator|!
operator|(
name|adap
operator|->
name|flags
operator|&
name|IS_VF
operator|)
operator|||
name|adap
operator|->
name|params
operator|.
name|vfres
operator|.
name|r_caps
operator|&
name|FW_CMD_CAP_PORT
condition|)
block|{
name|t4_update_port_info
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|t4_alloc_vi
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|j
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
operator|&
name|rss_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|p
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|viid
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|adap
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
name|p
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|smt_idx
operator|=
operator|(
name|ret
operator|&
literal|0x7f
operator|)
operator|<<
literal|1
expr_stmt|;
else|else
name|p
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|smt_idx
operator|=
operator|(
name|ret
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|p
operator|->
name|tx_chan
operator|=
name|j
expr_stmt|;
name|p
operator|->
name|rx_chan_map
operator|=
name|t4_get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p
operator|->
name|lport
operator|=
name|j
expr_stmt|;
name|p
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|rss_size
operator|=
name|rss_size
expr_stmt|;
name|t4_os_set_hw_addr
argument_list|(
name|p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|param
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_RSSINFO
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|p
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|viid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_query_params
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|p
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|rss_base
operator|=
literal|0xffff
expr_stmt|;
else|else
block|{
comment|/* MPASS((val>> 16) == rss_size); */
name|p
operator|->
name|vi
index|[
literal|0
index|]
operator|.
name|rss_base
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_cimq_cfg - read CIM queue configuration  *	@adap: the adapter  *	@base: holds the queue base addresses in bytes  *	@size: holds the queue sizes in bytes  *	@thres: holds the queue full thresholds in bytes  *  *	Returns the current configuration of the CIM queues, starting with  *	the IBQs, then the OBQs.  */
end_comment

begin_function
name|void
name|t4_read_cimq_cfg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u16
modifier|*
name|base
parameter_list|,
name|u16
modifier|*
name|size
parameter_list|,
name|u16
modifier|*
name|thres
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|int
name|cim_num_obq
init|=
name|adap
operator|->
name|chip_params
operator|->
name|cim_num_obq
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_NUM_IBQ
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_REF
argument_list|,
name|F_IBQSELECT
operator||
name|V_QUENUMSELECT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_CTRL
argument_list|)
expr_stmt|;
comment|/* value is in 256-byte units */
operator|*
name|base
operator|++
operator|=
name|G_CIMQBASE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
operator|*
name|size
operator|++
operator|=
name|G_CIMQSIZE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
operator|*
name|thres
operator|++
operator|=
name|G_QUEFULLTHRSH
argument_list|(
name|v
argument_list|)
operator|*
literal|8
expr_stmt|;
comment|/* 8-byte unit */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cim_num_obq
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_REF
argument_list|,
name|F_OBQSELECT
operator||
name|V_QUENUMSELECT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_CTRL
argument_list|)
expr_stmt|;
comment|/* value is in 256-byte units */
operator|*
name|base
operator|++
operator|=
name|G_CIMQBASE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
operator|*
name|size
operator|++
operator|=
name|G_CIMQSIZE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_cim_ibq - read the contents of a CIM inbound queue  *	@adap: the adapter  *	@qid: the queue index  *	@data: where to store the queue contents  *	@n: capacity of @data in 32-bit words  *  *	Reads the contents of the selected CIM queue starting at address 0 up  *	to the capacity of @data.  @n must be a multiple of 4.  Returns< 0 on  *	error and the number of 32-bit words actually read on success.  */
end_comment

begin_function
name|int
name|t4_read_cim_ibq
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|attempts
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
specifier|const
name|unsigned
name|int
name|nwords
init|=
name|CIM_IBQ_SIZE
operator|*
literal|4
decl_stmt|;
if|if
condition|(
name|qid
operator|>
literal|5
operator|||
operator|(
name|n
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|addr
operator|=
name|qid
operator|*
name|nwords
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nwords
condition|)
name|n
operator|=
name|nwords
expr_stmt|;
comment|/* It might take 3-10ms before the IBQ debug read access is allowed. 	 * Wait for 1 Sec with a delay of 1 usec. 	 */
name|attempts
operator|=
literal|1000000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|addr
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
name|V_IBQDBGADDR
argument_list|(
name|addr
argument_list|)
operator||
name|F_IBQDBGEN
argument_list|)
expr_stmt|;
name|err
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
name|F_IBQDBGBUSY
argument_list|,
literal|0
argument_list|,
name|attempts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|*
name|data
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_DATA
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_cim_obq - read the contents of a CIM outbound queue  *	@adap: the adapter  *	@qid: the queue index  *	@data: where to store the queue contents  *	@n: capacity of @data in 32-bit words  *  *	Reads the contents of the selected CIM queue starting at address 0 up  *	to the capacity of @data.  @n must be a multiple of 4.  Returns< 0 on  *	error and the number of 32-bit words actually read on success.  */
end_comment

begin_function
name|int
name|t4_read_cim_obq
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|,
name|v
decl_stmt|,
name|nwords
decl_stmt|;
name|int
name|cim_num_obq
init|=
name|adap
operator|->
name|chip_params
operator|->
name|cim_num_obq
decl_stmt|;
if|if
condition|(
operator|(
name|qid
operator|>
operator|(
name|cim_num_obq
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|n
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_REF
argument_list|,
name|F_OBQSELECT
operator||
name|V_QUENUMSELECT
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_CTRL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|G_CIMQBASE
argument_list|(
name|v
argument_list|)
operator|*
literal|64
expr_stmt|;
comment|/* muliple of 256 -> muliple of 4 */
name|nwords
operator|=
name|G_CIMQSIZE
argument_list|(
name|v
argument_list|)
operator|*
literal|64
expr_stmt|;
comment|/* same */
if|if
condition|(
name|n
operator|>
name|nwords
condition|)
name|n
operator|=
name|nwords
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|addr
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_CFG
argument_list|,
name|V_OBQDBGADDR
argument_list|(
name|addr
argument_list|)
operator||
name|F_OBQDBGEN
argument_list|)
expr_stmt|;
name|err
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_CFG
argument_list|,
name|F_OBQDBGBUSY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|*
name|data
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_DATA
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|CIM_QCTL_BASE
init|=
literal|0
block|,
name|CIM_CTL_BASE
init|=
literal|0x2000
block|,
name|CIM_PBT_ADDR_BASE
init|=
literal|0x2800
block|,
name|CIM_PBT_LRF_BASE
init|=
literal|0x3000
block|,
name|CIM_PBT_DATA_BASE
init|=
literal|0x3800
block|}
enum|;
end_enum

begin_comment
comment|/**  *	t4_cim_read - read a block from CIM internal address space  *	@adap: the adapter  *	@addr: the start address within the CIM address space  *	@n: number of words to read  *	@valp: where to store the result  *  *	Reads a block of 4-byte words from the CIM intenal address space.  */
end_comment

begin_function
name|int
name|t4_cim_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|)
operator|&
name|F_HOSTBUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
for|for
control|(
init|;
operator|!
name|ret
operator|&&
name|n
operator|--
condition|;
name|addr
operator|+=
literal|4
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cim_write - write a block into CIM internal address space  *	@adap: the adapter  *	@addr: the start address within the CIM address space  *	@n: number of words to write  *	@valp: set of values to write  *  *	Writes a block of 4-byte words into the CIM intenal address space.  */
end_comment

begin_function
name|int
name|t4_cim_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|)
operator|&
name|F_HOSTBUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
for|for
control|(
init|;
operator|!
name|ret
operator|&&
name|n
operator|--
condition|;
name|addr
operator|+=
literal|4
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|,
operator|*
name|valp
operator|++
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|addr
operator||
name|F_HOSTWRITE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_cim_write1
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
return|return
name|t4_cim_write
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cim_ctl_read - read a block from CIM control region  *	@adap: the adapter  *	@addr: the start address within the CIM control region  *	@n: number of words to read  *	@valp: where to store the result  *  *	Reads a block of 4-byte words from the CIM control region.  */
end_comment

begin_function
name|int
name|t4_cim_ctl_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
return|return
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|addr
operator|+
name|CIM_CTL_BASE
argument_list|,
name|n
argument_list|,
name|valp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cim_read_la - read CIM LA capture buffer  *	@adap: the adapter  *	@la_buf: where to store the LA data  *	@wrptr: the HW write pointer within the capture buffer  *  *	Reads the contents of the CIM LA buffer with the most recent entry at  *	the end	of the returned data and with the entry at @wrptr first.  *	We try to leave the LA in the running state we find it in.  */
end_comment

begin_function
name|int
name|t4_cim_read_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|la_buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|wrptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|cfg
decl_stmt|,
name|val
decl_stmt|,
name|idx
decl_stmt|;
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|cfg
operator|&
name|F_UPDBGLAEN
condition|)
block|{
comment|/* LA is running, freeze it */
name|ret
operator|=
name|t4_cim_write1
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|restart
goto|;
name|idx
operator|=
name|G_UPDBGLAWRPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrptr
condition|)
operator|*
name|wrptr
operator|=
name|idx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adap
operator|->
name|params
operator|.
name|cim_la_size
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|t4_cim_write1
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
name|V_UPDBGLARDPTR
argument_list|(
name|idx
argument_list|)
operator||
name|F_UPDBGLARDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
if|if
condition|(
name|val
operator|&
name|F_UPDBGLARDEN
condition|)
block|{
name|ret
operator|=
operator|-
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_DATA
argument_list|,
literal|1
argument_list|,
operator|&
name|la_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
comment|/* address can't exceed 0xfff (UpDbgLaRdPtr is of 12-bits) */
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
name|M_UPDBGLARDPTR
expr_stmt|;
comment|/* 		 * Bits 0-3 of UpDbgLaRdPtr can be between 0000 to 1001 to 		 * identify the 32-bit portion of the full 312-bit data 		 */
if|if
condition|(
name|is_t6
argument_list|(
name|adap
argument_list|)
condition|)
while|while
condition|(
operator|(
name|idx
operator|&
literal|0xf
operator|)
operator|>
literal|9
condition|)
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|%
name|M_UPDBGLARDPTR
expr_stmt|;
block|}
name|restart
label|:
if|if
condition|(
name|cfg
operator|&
name|F_UPDBGLAEN
condition|)
block|{
name|int
name|r
init|=
name|t4_cim_write1
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
name|cfg
operator|&
operator|~
name|F_UPDBGLARDEN
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_read_la - read TP LA capture buffer  *	@adap: the adapter  *	@la_buf: where to store the LA data  *	@wrptr: the HW write pointer within the capture buffer  *  *	Reads the contents of the TP LA buffer with the most recent entry at  *	the end	of the returned data and with the entry at @wrptr first.  *	We leave the LA in the running state we find it in.  */
end_comment

begin_function
name|void
name|t4_tp_read_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u64
modifier|*
name|la_buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|wrptr
parameter_list|)
block|{
name|bool
name|last_incomplete
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|cfg
decl_stmt|,
name|val
decl_stmt|,
name|idx
decl_stmt|;
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_DBGLAENABLE
condition|)
comment|/* freeze LA */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|,
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|la_mask
operator||
operator|(
name|cfg
operator|^
name|F_DBGLAENABLE
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|)
expr_stmt|;
name|idx
operator|=
name|G_DBGLAWPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|last_incomplete
operator|=
name|G_DBGLAMODE
argument_list|(
name|val
argument_list|)
operator|>=
literal|2
operator|&&
operator|(
name|val
operator|&
name|F_DBGLAWHLF
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|last_incomplete
condition|)
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
name|M_DBGLARPTR
expr_stmt|;
if|if
condition|(
name|wrptr
condition|)
operator|*
name|wrptr
operator|=
name|idx
expr_stmt|;
name|val
operator|&=
literal|0xffff
expr_stmt|;
name|val
operator|&=
operator|~
name|V_DBGLARPTR
argument_list|(
name|M_DBGLARPTR
argument_list|)
expr_stmt|;
name|val
operator||=
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|la_mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TPLA_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|,
name|V_DBGLARPTR
argument_list|(
name|idx
argument_list|)
operator||
name|val
argument_list|)
expr_stmt|;
name|la_buf
index|[
name|i
index|]
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_DATAL
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
name|M_DBGLARPTR
expr_stmt|;
block|}
comment|/* Wipe out last entry if it isn't valid */
if|if
condition|(
name|last_incomplete
condition|)
name|la_buf
index|[
name|TPLA_SIZE
operator|-
literal|1
index|]
operator|=
operator|~
literal|0ULL
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_DBGLAENABLE
condition|)
comment|/* restore running state */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|,
name|cfg
operator||
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|la_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SGE Hung Ingress DMA Warning Threshold time and Warning Repeat Rate (in  * seconds).  If we find one of the SGE Ingress DMA State Machines in the same  * state for more than the Warning Threshold then we'll issue a warning about  * a potential hang.  We'll repeat the warning as the SGE Ingress DMA Channel  * appears to be hung every Warning Repeat second till the situation clears.  * If the situation clears, we'll note that as well.  */
end_comment

begin_define
define|#
directive|define
name|SGE_IDMA_WARN_THRESH
value|1
end_define

begin_define
define|#
directive|define
name|SGE_IDMA_WARN_REPEAT
value|300
end_define

begin_comment
comment|/**  *	t4_idma_monitor_init - initialize SGE Ingress DMA Monitor  *	@adapter: the adapter  *	@idma: the adapter IDMA Monitor state  *  *	Initialize the state of an SGE Ingress DMA Monitor.  */
end_comment

begin_function
name|void
name|t4_idma_monitor_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|sge_idma_monitor_state
modifier|*
name|idma
parameter_list|)
block|{
comment|/* Initialize the state variables for detecting an SGE Ingress DMA 	 * hang.  The SGE has internal counters which count up on each clock 	 * tick whenever the SGE finds its Ingress DMA State Engines in the 	 * same state they were on the previous clock tick.  The clock used is 	 * the Core Clock so we have a limit on the maximum "time" they can 	 * record; typically a very small number of seconds.  For instance, 	 * with a 600MHz Core Clock, we can only count up to a bit more than 	 * 7s.  So we'll synthesize a larger counter in order to not run the 	 * risk of having the "timers" overflow and give us the flexibility to 	 * maintain a Hung SGE State Machine of our own which operates across 	 * a longer time frame. 	 */
name|idma
operator|->
name|idma_1s_thresh
operator|=
name|core_ticks_per_usec
argument_list|(
name|adapter
argument_list|)
operator|*
literal|1000000
expr_stmt|;
comment|/* 1s */
name|idma
operator|->
name|idma_stalled
index|[
literal|0
index|]
operator|=
name|idma
operator|->
name|idma_stalled
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_idma_monitor - monitor SGE Ingress DMA state  *	@adapter: the adapter  *	@idma: the adapter IDMA Monitor state  *	@hz: number of ticks/second  *	@ticks: number of ticks since the last IDMA Monitor call  */
end_comment

begin_function
name|void
name|t4_idma_monitor
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|sge_idma_monitor_state
modifier|*
name|idma
parameter_list|,
name|int
name|hz
parameter_list|,
name|int
name|ticks
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idma_same_state_cnt
index|[
literal|2
index|]
decl_stmt|;
comment|/* Read the SGE Debug Ingress DMA Same State Count registers.  These 	  * are counters inside the SGE which count up on each clock when the 	  * SGE finds its Ingress DMA State Engines in the same states they 	  * were in the previous clock.  The counters will peg out at 	  * 0xffffffff without wrapping around so once they pass the 1s 	  * threshold they'll stay above that till the IDMA state changes. 	  */
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_DEBUG_INDEX
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|idma_same_state_cnt
index|[
literal|0
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_DEBUG_DATA_HIGH
argument_list|)
expr_stmt|;
name|idma_same_state_cnt
index|[
literal|1
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_DEBUG_DATA_LOW
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|debug0
decl_stmt|,
name|debug11
decl_stmt|;
comment|/* If the Ingress DMA Same State Counter ("timer") is less 		 * than 1s, then we can reset our synthesized Stall Timer and 		 * continue.  If we have previously emitted warnings about a 		 * potential stalled Ingress Queue, issue a note indicating 		 * that the Ingress Queue has resumed forward progress. 		 */
if|if
condition|(
name|idma_same_state_cnt
index|[
name|i
index|]
operator|<
name|idma
operator|->
name|idma_1s_thresh
condition|)
block|{
if|if
condition|(
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|>=
name|SGE_IDMA_WARN_THRESH
operator|*
name|hz
condition|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"SGE idma%d, queue %u, "
literal|"resumed after %d seconds\n"
argument_list|,
name|i
argument_list|,
name|idma
operator|->
name|idma_qid
index|[
name|i
index|]
argument_list|,
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|/
name|hz
argument_list|)
expr_stmt|;
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Synthesize an SGE Ingress DMA Same State Timer in the Hz 		 * domain.  The first time we get here it'll be because we 		 * passed the 1s Threshold; each additional time it'll be 		 * because the RX Timer Callback is being fired on its regular 		 * schedule. 		 * 		 * If the stall is below our Potential Hung Ingress Queue 		 * Warning Threshold, continue. 		 */
if|if
condition|(
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|=
name|hz
expr_stmt|;
name|idma
operator|->
name|idma_warn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|+=
name|ticks
expr_stmt|;
name|idma
operator|->
name|idma_warn
index|[
name|i
index|]
operator|-=
name|ticks
expr_stmt|;
block|}
if|if
condition|(
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|<
name|SGE_IDMA_WARN_THRESH
operator|*
name|hz
condition|)
continue|continue;
comment|/* We'll issue a warning every SGE_IDMA_WARN_REPEAT seconds. 		 */
if|if
condition|(
name|idma
operator|->
name|idma_warn
index|[
name|i
index|]
operator|>
literal|0
condition|)
continue|continue;
name|idma
operator|->
name|idma_warn
index|[
name|i
index|]
operator|=
name|SGE_IDMA_WARN_REPEAT
operator|*
name|hz
expr_stmt|;
comment|/* Read and save the SGE IDMA State and Queue ID information. 		 * We do this every time in case it changes across time ... 		 * can't be too careful ... 		 */
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_DEBUG_INDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug0
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_DEBUG_DATA_LOW
argument_list|)
expr_stmt|;
name|idma
operator|->
name|idma_state
index|[
name|i
index|]
operator|=
operator|(
name|debug0
operator|>>
operator|(
name|i
operator|*
literal|9
operator|)
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_DEBUG_INDEX
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|debug11
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_DEBUG_DATA_LOW
argument_list|)
expr_stmt|;
name|idma
operator|->
name|idma_qid
index|[
name|i
index|]
operator|=
operator|(
name|debug11
operator|>>
operator|(
name|i
operator|*
literal|16
operator|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"SGE idma%u, queue %u, potentially stuck in "
literal|" state %u for %d seconds (debug0=%#x, debug11=%#x)\n"
argument_list|,
name|i
argument_list|,
name|idma
operator|->
name|idma_qid
index|[
name|i
index|]
argument_list|,
name|idma
operator|->
name|idma_state
index|[
name|i
index|]
argument_list|,
name|idma
operator|->
name|idma_stalled
index|[
name|i
index|]
operator|/
name|hz
argument_list|,
name|debug0
argument_list|,
name|debug11
argument_list|)
expr_stmt|;
name|t4_sge_decode_idma_state
argument_list|(
name|adapter
argument_list|,
name|idma
operator|->
name|idma_state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_pace_tbl - read the pace table  *	@adap: the adapter  *	@pace_vals: holds the returned values  *  *	Returns the values of TP's pace table in microseconds.  */
end_comment

begin_function
name|void
name|t4_read_pace_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|pace_vals
index|[
name|NTX_SCHED
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTX_SCHED
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
literal|0xffff0000
operator|+
name|i
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|)
expr_stmt|;
name|pace_vals
index|[
name|i
index|]
operator|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_get_tx_sched - get the configuration of a Tx HW traffic scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@kbps: the byte rate in Kbps  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Return the current configuration of a HW Tx scheduler.  */
end_comment

begin_function
name|void
name|t4_get_tx_sched
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|sched
parameter_list|,
name|unsigned
name|int
modifier|*
name|kbps
parameter_list|,
name|unsigned
name|int
modifier|*
name|ipg
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
decl_stmt|,
name|bpt
decl_stmt|,
name|cpt
decl_stmt|;
if|if
condition|(
name|kbps
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t4_tp_tm_pio_read
argument_list|(
name|adap
argument_list|,
operator|&
name|v
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|bpt
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cpt
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|cpt
condition|)
operator|*
name|kbps
operator|=
literal|0
expr_stmt|;
comment|/* scheduler disabled */
else|else
block|{
name|v
operator|=
operator|(
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
operator|)
operator|/
name|cpt
expr_stmt|;
comment|/* ticks/s */
operator|*
name|kbps
operator|=
operator|(
name|v
operator|*
name|bpt
operator|)
operator|/
literal|125
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ipg
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t4_tp_tm_pio_read
argument_list|(
name|adap
argument_list|,
operator|&
name|v
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|v
operator|&=
literal|0xffff
expr_stmt|;
operator|*
name|ipg
operator|=
operator|(
literal|10000
operator|*
name|v
operator|)
operator|/
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_load_cfg - download config file  *	@adap: the adapter  *	@cfg_data: the cfg text file to write  *	@size: text file size  *  *	Write the supplied config text file to the card's serial flash.  */
end_comment

begin_function
name|int
name|t4_load_cfg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u8
modifier|*
name|cfg_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|cfg_addr
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
name|unsigned
name|int
name|flash_cfg_start_sec
decl_stmt|;
name|unsigned
name|int
name|sf_sec_size
init|=
name|adap
operator|->
name|params
operator|.
name|sf_size
operator|/
name|adap
operator|->
name|params
operator|.
name|sf_nsec
decl_stmt|;
name|cfg_addr
operator|=
name|t4_flash_cfg_addr
argument_list|(
name|adap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_addr
operator|<
literal|0
condition|)
return|return
name|cfg_addr
return|;
name|addr
operator|=
name|cfg_addr
expr_stmt|;
name|flash_cfg_start_sec
operator|=
name|addr
operator|/
name|SF_SEC_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|FLASH_CFG_MAX_SIZE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"cfg file too large, max is %u bytes\n"
argument_list|,
name|FLASH_CFG_MAX_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
name|i
operator|=
name|DIV_ROUND_UP
argument_list|(
name|FLASH_CFG_MAX_SIZE
argument_list|,
comment|/* # of sectors spanned */
name|sf_sec_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_flash_erase_sectors
argument_list|(
name|adap
argument_list|,
name|flash_cfg_start_sec
argument_list|,
name|flash_cfg_start_sec
operator|+
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If size == 0 then we're simply erasing the FLASH sectors associated 	 * with the on-adapter Firmware Configuration File. 	 */
if|if
condition|(
name|ret
operator|||
name|size
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* this will write to the flash up to SF_PAGE_SIZE at a time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|SF_PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|size
operator|-
name|i
operator|)
operator|<
name|SF_PAGE_SIZE
condition|)
name|n
operator|=
name|size
operator|-
name|i
expr_stmt|;
else|else
name|n
operator|=
name|SF_PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
name|n
argument_list|,
name|cfg_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|cfg_data
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"config file %s failed %d\n"
argument_list|,
operator|(
name|size
operator|==
literal|0
condition|?
literal|"clear"
else|:
literal|"download"
operator|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t5_fw_init_extern_mem - initialize the external memory  *	@adap: the adapter  *  *	Initializes the external memory on T5.  */
end_comment

begin_function
name|int
name|t5_fw_init_extern_mem
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
name|u32
name|params
index|[
literal|1
index|]
decl_stmt|,
name|val
index|[
literal|1
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|is_t5
argument_list|(
name|adap
argument_list|)
condition|)
return|return
literal|0
return|;
name|val
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* Initialize all MCs */
name|params
index|[
literal|0
index|]
operator|=
operator|(
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DEV
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DEV_MCINIT
argument_list|)
operator|)
expr_stmt|;
name|ret
operator|=
name|t4_set_params_timeout
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|mbox
argument_list|,
name|adap
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|params
argument_list|,
name|val
argument_list|,
name|FW_CMD_MAX_TIMEOUT
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* BIOS boot headers */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pci_expansion_rom_header
block|{
name|u8
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|/* ROM Signature. Should be 0xaa55 */
name|u8
name|reserved
index|[
literal|22
index|]
decl_stmt|;
comment|/* Reserved per processor Architecture data */
name|u8
name|pcir_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to PCI Data Structure */
block|}
name|pci_exp_rom_header_t
typedef|;
end_typedef

begin_comment
comment|/* PCI_EXPANSION_ROM_HEADER */
end_comment

begin_comment
comment|/* Legacy PCI Expansion ROM Header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|legacy_pci_expansion_rom_header
block|{
name|u8
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|/* ROM Signature. Should be 0xaa55 */
name|u8
name|size512
decl_stmt|;
comment|/* Current Image Size in units of 512 bytes */
name|u8
name|initentry_point
index|[
literal|4
index|]
decl_stmt|;
name|u8
name|cksum
decl_stmt|;
comment|/* Checksum computed on the entire Image */
name|u8
name|reserved
index|[
literal|16
index|]
decl_stmt|;
comment|/* Reserved */
name|u8
name|pcir_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to PCI Data Struture */
block|}
name|legacy_pci_exp_rom_header_t
typedef|;
end_typedef

begin_comment
comment|/* LEGACY_PCI_EXPANSION_ROM_HEADER */
end_comment

begin_comment
comment|/* EFI PCI Expansion ROM Header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|efi_pci_expansion_rom_header
block|{
name|u8
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|// ROM signature. The value 0xaa55
name|u8
name|initialization_size
index|[
literal|2
index|]
decl_stmt|;
comment|/* Units 512. Includes this header */
name|u8
name|efi_signature
index|[
literal|4
index|]
decl_stmt|;
comment|/* Signature from EFI image header. 0x0EF1 */
name|u8
name|efi_subsystem
index|[
literal|2
index|]
decl_stmt|;
comment|/* Subsystem value for EFI image header */
name|u8
name|efi_machine_type
index|[
literal|2
index|]
decl_stmt|;
comment|/* Machine type from EFI image header */
name|u8
name|compression_type
index|[
literal|2
index|]
decl_stmt|;
comment|/* Compression type. */
comment|/* 		 * Compression type definition 		 * 0x0: uncompressed 		 * 0x1: Compressed 		 * 0x2-0xFFFF: Reserved 		 */
name|u8
name|reserved
index|[
literal|8
index|]
decl_stmt|;
comment|/* Reserved */
name|u8
name|efi_image_header_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to EFI Image */
name|u8
name|pcir_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to PCI Data Structure */
block|}
name|efi_pci_exp_rom_header_t
typedef|;
end_typedef

begin_comment
comment|/* EFI PCI Expansion ROM Header */
end_comment

begin_comment
comment|/* PCI Data Structure Format */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pcir_data_structure
block|{
comment|/* PCI Data Structure */
name|u8
name|signature
index|[
literal|4
index|]
decl_stmt|;
comment|/* Signature. The string "PCIR" */
name|u8
name|vendor_id
index|[
literal|2
index|]
decl_stmt|;
comment|/* Vendor Identification */
name|u8
name|device_id
index|[
literal|2
index|]
decl_stmt|;
comment|/* Device Identification */
name|u8
name|vital_product
index|[
literal|2
index|]
decl_stmt|;
comment|/* Pointer to Vital Product Data */
name|u8
name|length
index|[
literal|2
index|]
decl_stmt|;
comment|/* PCIR Data Structure Length */
name|u8
name|revision
decl_stmt|;
comment|/* PCIR Data Structure Revision */
name|u8
name|class_code
index|[
literal|3
index|]
decl_stmt|;
comment|/* Class Code */
name|u8
name|image_length
index|[
literal|2
index|]
decl_stmt|;
comment|/* Image Length. Multiple of 512B */
name|u8
name|code_revision
index|[
literal|2
index|]
decl_stmt|;
comment|/* Revision Level of Code/Data */
name|u8
name|code_type
decl_stmt|;
comment|/* Code Type. */
comment|/* 		 * PCI Expansion ROM Code Types 		 * 0x00: Intel IA-32, PC-AT compatible. Legacy 		 * 0x01: Open Firmware standard for PCI. FCODE 		 * 0x02: Hewlett-Packard PA RISC. HP reserved 		 * 0x03: EFI Image. EFI 		 * 0x04-0xFF: Reserved. 		 */
name|u8
name|indicator
decl_stmt|;
comment|/* Indicator. Identifies the last image in the ROM */
name|u8
name|reserved
index|[
literal|2
index|]
decl_stmt|;
comment|/* Reserved */
block|}
name|pcir_data_t
typedef|;
end_typedef

begin_comment
comment|/* PCI__DATA_STRUCTURE */
end_comment

begin_comment
comment|/* BOOT constants */
end_comment

begin_enum
enum|enum
block|{
name|BOOT_FLASH_BOOT_ADDR
init|=
literal|0x0
block|,
comment|/* start address of boot image in flash */
name|BOOT_SIGNATURE
init|=
literal|0xaa55
block|,
comment|/* signature of BIOS boot ROM */
name|BOOT_SIZE_INC
init|=
literal|512
block|,
comment|/* image size measured in 512B chunks */
name|BOOT_MIN_SIZE
init|=
sizeof|sizeof
argument_list|(
name|pci_exp_rom_header_t
argument_list|)
block|,
comment|/* basic header */
name|BOOT_MAX_SIZE
init|=
literal|1024
operator|*
name|BOOT_SIZE_INC
block|,
comment|/* 1 byte * length increment  */
name|VENDOR_ID
init|=
literal|0x1425
block|,
comment|/* Vendor ID */
name|PCIR_SIGNATURE
init|=
literal|0x52494350
comment|/* PCIR signature */
block|}
enum|;
end_enum

begin_comment
comment|/*  *	modify_device_id - Modifies the device ID of the Boot BIOS image  *	@adatper: the device ID to write.  *	@boot_data: the boot image to modify.  *  *	Write the supplied device ID to the boot BIOS image.  */
end_comment

begin_function
specifier|static
name|void
name|modify_device_id
parameter_list|(
name|int
name|device_id
parameter_list|,
name|u8
modifier|*
name|boot_data
parameter_list|)
block|{
name|legacy_pci_exp_rom_header_t
modifier|*
name|header
decl_stmt|;
name|pcir_data_t
modifier|*
name|pcir_header
decl_stmt|;
name|u32
name|cur_header
init|=
literal|0
decl_stmt|;
comment|/* 	 * Loop through all chained images and change the device ID's 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|header
operator|=
operator|(
name|legacy_pci_exp_rom_header_t
operator|*
operator|)
operator|&
name|boot_data
index|[
name|cur_header
index|]
expr_stmt|;
name|pcir_header
operator|=
operator|(
name|pcir_data_t
operator|*
operator|)
operator|&
name|boot_data
index|[
name|cur_header
operator|+
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|header
operator|->
name|pcir_offset
argument_list|)
index|]
expr_stmt|;
comment|/* 		 * Only modify the Device ID if code type is Legacy or HP. 		 * 0x00: Okay to modify 		 * 0x01: FCODE. Do not be modify 		 * 0x03: Okay to modify 		 * 0x04-0xFF: Do not modify 		 */
if|if
condition|(
name|pcir_header
operator|->
name|code_type
operator|==
literal|0x00
condition|)
block|{
name|u8
name|csum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 			 * Modify Device ID to match current adatper 			 */
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|device_id
operator|=
name|device_id
expr_stmt|;
comment|/* 			 * Set checksum temporarily to 0. 			 * We will recalculate it later. 			 */
name|header
operator|->
name|cksum
operator|=
literal|0x0
expr_stmt|;
comment|/* 			 * Calculate and update checksum 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|header
operator|->
name|size512
operator|*
literal|512
operator|)
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
operator|(
name|u8
operator|)
name|boot_data
index|[
name|cur_header
operator|+
name|i
index|]
expr_stmt|;
comment|/* 			 * Invert summed value to create the checksum 			 * Writing new checksum value directly to the boot data 			 */
name|boot_data
index|[
name|cur_header
operator|+
literal|7
index|]
operator|=
operator|-
name|csum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcir_header
operator|->
name|code_type
operator|==
literal|0x03
condition|)
block|{
comment|/* 			 * Modify Device ID to match current adatper 			 */
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|device_id
operator|=
name|device_id
expr_stmt|;
block|}
comment|/* 		 * Check indicator element to identify if this is the last 		 * image in the ROM. 		 */
if|if
condition|(
name|pcir_header
operator|->
name|indicator
operator|&
literal|0x80
condition|)
break|break;
comment|/* 		 * Move header pointer up to the next image in the ROM. 		 */
name|cur_header
operator|+=
name|header
operator|->
name|size512
operator|*
literal|512
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	t4_load_boot - download boot flash  *	@adapter: the adapter  *	@boot_data: the boot image to write  *	@boot_addr: offset in flash to write boot_data  *	@size: image size  *  *	Write the supplied boot image to the card's serial flash.  *	The boot image has the following sections: a 28-byte header and the  *	boot image.  */
end_comment

begin_function
name|int
name|t4_load_boot
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u8
modifier|*
name|boot_data
parameter_list|,
name|unsigned
name|int
name|boot_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|pci_exp_rom_header_t
modifier|*
name|header
decl_stmt|;
name|int
name|pcir_offset
decl_stmt|;
name|pcir_data_t
modifier|*
name|pcir_header
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|addr
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|boot_sector
init|=
operator|(
name|boot_addr
operator|*
literal|1024
operator|)
decl_stmt|;
name|unsigned
name|int
name|sf_sec_size
init|=
name|adap
operator|->
name|params
operator|.
name|sf_size
operator|/
name|adap
operator|->
name|params
operator|.
name|sf_nsec
decl_stmt|;
comment|/* 	 * Make sure the boot image does not encroach on the firmware region 	 */
if|if
condition|(
operator|(
name|boot_sector
operator|+
name|size
operator|)
operator|>>
literal|16
operator|>
name|FLASH_FW_START_SEC
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"boot image encroaching on firmware region\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
comment|/* 	 * The boot sector is comprised of the Expansion-ROM boot, iSCSI boot, 	 * and Boot configuration data sections. These 3 boot sections span 	 * sectors 0 to 7 in flash and live right before the FW image location. 	 */
name|i
operator|=
name|DIV_ROUND_UP
argument_list|(
name|size
condition|?
name|size
else|:
name|FLASH_FW_START
argument_list|,
name|sf_sec_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_flash_erase_sectors
argument_list|(
name|adap
argument_list|,
name|boot_sector
operator|>>
literal|16
argument_list|,
operator|(
name|boot_sector
operator|>>
literal|16
operator|)
operator|+
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If size == 0 then we're simply erasing the FLASH sectors associated 	 * with the on-adapter option ROM file 	 */
if|if
condition|(
name|ret
operator|||
operator|(
name|size
operator|==
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Get boot header */
name|header
operator|=
operator|(
name|pci_exp_rom_header_t
operator|*
operator|)
name|boot_data
expr_stmt|;
name|pcir_offset
operator|=
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|header
operator|->
name|pcir_offset
argument_list|)
expr_stmt|;
comment|/* PCIR Data Structure */
name|pcir_header
operator|=
operator|(
name|pcir_data_t
operator|*
operator|)
operator|&
name|boot_data
index|[
name|pcir_offset
index|]
expr_stmt|;
comment|/* 	 * Perform some primitive sanity testing to avoid accidentally 	 * writing garbage over the boot sectors.  We ought to check for 	 * more but it's not worth it for now ... 	 */
if|if
condition|(
name|size
operator|<
name|BOOT_MIN_SIZE
operator|||
name|size
operator|>
name|BOOT_MAX_SIZE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"boot image too small/large\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
ifndef|#
directive|ifndef
name|CHELSIO_T4_DIAGS
comment|/* 	 * Check BOOT ROM header signature 	 */
if|if
condition|(
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|header
operator|->
name|signature
argument_list|)
operator|!=
name|BOOT_SIGNATURE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Boot image missing signature\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Check PCI header signature 	 */
if|if
condition|(
name|le32_to_cpu
argument_list|(
operator|*
operator|(
name|u32
operator|*
operator|)
name|pcir_header
operator|->
name|signature
argument_list|)
operator|!=
name|PCIR_SIGNATURE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"PCI header missing signature\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Check Vendor ID matches Chelsio ID 	 */
if|if
condition|(
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|vendor_id
argument_list|)
operator|!=
name|VENDOR_ID
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Vendor ID missing signature\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Retrieve adapter's device ID 	 */
name|t4_os_pci_read_cfg2
argument_list|(
name|adap
argument_list|,
name|PCI_DEVICE_ID
argument_list|,
operator|&
name|device_id
argument_list|)
expr_stmt|;
comment|/* Want to deal with PF 0 so I strip off PF 4 indicator */
name|device_id
operator|=
name|device_id
operator|&
literal|0xf0ff
expr_stmt|;
comment|/* 	 * Check PCIE Device ID 	 */
if|if
condition|(
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|device_id
argument_list|)
operator|!=
name|device_id
condition|)
block|{
comment|/* 		 * Change the device ID in the Boot BIOS image to match 		 * the Device ID of the current adapter. 		 */
name|modify_device_id
argument_list|(
name|device_id
argument_list|,
name|boot_data
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Skip over the first SF_PAGE_SIZE worth of data and write it after 	 * we finish copying the rest of the boot image. This will ensure 	 * that the BIOS boot header will only be written if the boot image 	 * was written in full. 	 */
name|addr
operator|=
name|boot_sector
expr_stmt|;
for|for
control|(
name|size
operator|-=
name|SF_PAGE_SIZE
init|;
name|size
condition|;
name|size
operator|-=
name|SF_PAGE_SIZE
control|)
block|{
name|addr
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|boot_data
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
name|boot_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|boot_sector
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"boot image download failed, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *	t4_flash_bootcfg_addr - return the address of the flash optionrom configuration  *	@adapter: the adapter  *  *	Return the address within the flash where the OptionROM Configuration  *	is stored, or an error if the device FLASH is too small to contain  *	a OptionROM Configuration.  */
end_comment

begin_function
specifier|static
name|int
name|t4_flash_bootcfg_addr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* 	 * If the device FLASH isn't large enough to hold a Firmware 	 * Configuration File, return an error. 	 */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|<
name|FLASH_BOOTCFG_START
operator|+
name|FLASH_BOOTCFG_MAX_SIZE
condition|)
return|return
operator|-
name|ENOSPC
return|;
return|return
name|FLASH_BOOTCFG_START
return|;
block|}
end_function

begin_function
name|int
name|t4_load_bootcfg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u8
modifier|*
name|cfg_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|cfg_addr
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
name|unsigned
name|int
name|flash_cfg_start_sec
decl_stmt|;
name|unsigned
name|int
name|sf_sec_size
init|=
name|adap
operator|->
name|params
operator|.
name|sf_size
operator|/
name|adap
operator|->
name|params
operator|.
name|sf_nsec
decl_stmt|;
name|cfg_addr
operator|=
name|t4_flash_bootcfg_addr
argument_list|(
name|adap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_addr
operator|<
literal|0
condition|)
return|return
name|cfg_addr
return|;
name|addr
operator|=
name|cfg_addr
expr_stmt|;
name|flash_cfg_start_sec
operator|=
name|addr
operator|/
name|SF_SEC_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|FLASH_BOOTCFG_MAX_SIZE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"bootcfg file too large, max is %u bytes\n"
argument_list|,
name|FLASH_BOOTCFG_MAX_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
name|i
operator|=
name|DIV_ROUND_UP
argument_list|(
name|FLASH_BOOTCFG_MAX_SIZE
argument_list|,
comment|/* # of sectors spanned */
name|sf_sec_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_flash_erase_sectors
argument_list|(
name|adap
argument_list|,
name|flash_cfg_start_sec
argument_list|,
name|flash_cfg_start_sec
operator|+
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If size == 0 then we're simply erasing the FLASH sectors associated 	 * with the on-adapter OptionROM Configuration File. 	 */
if|if
condition|(
name|ret
operator|||
name|size
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* this will write to the flash up to SF_PAGE_SIZE at a time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|SF_PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|size
operator|-
name|i
operator|)
operator|<
name|SF_PAGE_SIZE
condition|)
name|n
operator|=
name|size
operator|-
name|i
expr_stmt|;
else|else
name|n
operator|=
name|SF_PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
name|n
argument_list|,
name|cfg_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|cfg_data
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"boot config data %s failed %d\n"
argument_list|,
operator|(
name|size
operator|==
literal|0
condition|?
literal|"clear"
else|:
literal|"download"
operator|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_filter_mode - configure the optional components of filter tuples  *	@adap: the adapter  *	@mode_map: a bitmap selcting which optional filter components to enable  * 	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Sets the filter mode by selecting the optional components to enable  *	in filter tuples.  Returns 0 on success and a negative error if the  *	requested mode needs more bits than are available for optional  *	components.  */
end_comment

begin_function
name|int
name|t4_set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mode_map
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
specifier|static
name|u8
name|width
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|17
block|,
literal|8
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nbits
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|S_FCOE
init|;
name|i
operator|<=
name|S_FRAGMENTATION
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mode_map
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|nbits
operator|+=
name|width
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nbits
operator|>
name|FILTER_OPT_LEN
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_tp_pio_write
argument_list|(
name|adap
argument_list|,
operator|&
name|mode_map
argument_list|,
literal|1
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
name|read_filter_mode_and_ingress_config
argument_list|(
name|adap
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_clr_port_stats - clear port statistics  *	@adap: the adapter  *	@idx: the port index  *  *	Clear HW statistics for the given port.  */
end_comment

begin_function
name|void
name|t4_clr_port_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|u32
name|bgmap
init|=
name|t4_get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|u32
name|port_base_addr
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|port_base_addr
operator|=
name|PORT_BASE
argument_list|(
name|idx
argument_list|)
expr_stmt|;
else|else
name|port_base_addr
operator|=
name|T5_PORT_BASE
argument_list|(
name|idx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|A_MPS_PORT_STAT_TX_PORT_BYTES_L
init|;
name|i
operator|<=
name|A_MPS_PORT_STAT_TX_PORT_PPP7_H
condition|;
name|i
operator|+=
literal|8
control|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|port_base_addr
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|A_MPS_PORT_STAT_RX_PORT_BYTES_L
init|;
name|i
operator|<=
name|A_MPS_PORT_STAT_RX_PORT_LESS_64B_H
condition|;
name|i
operator|+=
literal|8
control|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|port_base_addr
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bgmap
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_STAT_RX_BG_0_MAC_DROP_FRAME_L
operator|+
name|i
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_STAT_RX_BG_0_MAC_TRUNC_FRAME_L
operator|+
name|i
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_i2c_rd - read I2C data from adapter  *	@adap: the adapter  *	@port: Port number if per-port device;<0 if not  *	@devid: per-port device ID or absolute device ID  *	@offset: byte offset into device I2C space  *	@len: byte length of I2C space data  *	@buf: buffer in which to return I2C data  *  *	Reads the I2C data from the indicated device and location.  */
end_comment

begin_function
name|int
name|t4_i2c_rd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|devid
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|ldst_addrspace
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|ldst
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|4
operator|||
name|devid
operator|>=
literal|256
operator|||
name|offset
operator|>=
literal|256
operator|||
name|len
operator|>
sizeof|sizeof
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|ldst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ldst
argument_list|)
expr_stmt|;
name|ldst_addrspace
operator|=
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_I2C
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|ldst_addrspace
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst
argument_list|)
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|pid
operator|=
operator|(
name|port
operator|<
literal|0
condition|?
literal|0xff
else|:
name|port
operator|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|did
operator|=
name|devid
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|boffset
operator|=
name|offset
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|blen
operator|=
name|len
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|ldst
argument_list|,
sizeof|sizeof
name|ldst
argument_list|,
operator|&
name|ldst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|memcpy
argument_list|(
name|buf
argument_list|,
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_i2c_wr - write I2C data to adapter  *	@adap: the adapter  *	@port: Port number if per-port device;<0 if not  *	@devid: per-port device ID or absolute device ID  *	@offset: byte offset into device I2C space  *	@len: byte length of I2C space data  *	@buf: buffer containing new I2C data  *  *	Write the I2C data to the indicated device and location.  */
end_comment

begin_function
name|int
name|t4_i2c_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|devid
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|ldst_addrspace
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|ldst
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|4
operator|||
name|devid
operator|>=
literal|256
operator|||
name|offset
operator|>=
literal|256
operator|||
name|len
operator|>
sizeof|sizeof
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|ldst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ldst
argument_list|)
expr_stmt|;
name|ldst_addrspace
operator|=
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_I2C
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|ldst_addrspace
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst
argument_list|)
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|pid
operator|=
operator|(
name|port
operator|<
literal|0
condition|?
literal|0xff
else|:
name|port
operator|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|did
operator|=
name|devid
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|boffset
operator|=
name|offset
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|blen
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|ldst
argument_list|,
sizeof|sizeof
name|ldst
argument_list|,
operator|&
name|ldst
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t4_sge_ctxt_rd - read an SGE context through FW  * 	@adap: the adapter  * 	@mbox: mailbox to use for the FW command  * 	@cid: the context id  * 	@ctype: the context type  * 	@data: where to store the context data  *  * 	Issues a FW command through the given mailbox to read an SGE context.  */
end_comment

begin_function
name|int
name|t4_sge_ctxt_rd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|cid
parameter_list|,
name|enum
name|ctxt_type
name|ctype
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
if|if
condition|(
name|ctype
operator|==
name|CTXT_EGRESS
condition|)
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_EGRC
expr_stmt|;
elseif|else
if|if
condition|(
name|ctype
operator|==
name|CTXT_INGRESS
condition|)
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_INGC
expr_stmt|;
elseif|else
if|if
condition|(
name|ctype
operator|==
name|CTXT_FLM
condition|)
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_FLMC
expr_stmt|;
else|else
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_CONMC
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|physid
operator|=
name|cpu_to_be32
argument_list|(
name|cid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data0
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data1
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data2
argument_list|)
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data3
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data4
argument_list|)
expr_stmt|;
name|data
index|[
literal|5
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data5
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * 	t4_sge_ctxt_rd_bd - read an SGE context bypassing FW  * 	@adap: the adapter  * 	@cid: the context id  * 	@ctype: the context type  * 	@data: where to store the context data  *  * 	Reads an SGE context directly, bypassing FW.  This is only for  * 	debugging when FW is unavailable.  */
end_comment

begin_function
name|int
name|t4_sge_ctxt_rd_bd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|cid
parameter_list|,
name|enum
name|ctxt_type
name|ctype
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SGE_CTXT_CMD
argument_list|,
name|V_CTXTQID
argument_list|(
name|cid
argument_list|)
operator||
name|V_CTXTTYPE
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_SGE_CTXT_CMD
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
for|for
control|(
name|i
operator|=
name|A_SGE_CTXT_DATA0
init|;
name|i
operator|<=
name|A_SGE_CTXT_DATA5
condition|;
name|i
operator|+=
literal|4
control|)
operator|*
name|data
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|t4_sched_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|minmaxen
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_sched_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_SCHED_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|config
operator|.
name|sc
operator|=
name|FW_SCHED_SC_CONFIG
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|config
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|config
operator|.
name|minmaxen
operator|=
name|minmaxen
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t4_sched_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|rateunit
parameter_list|,
name|int
name|ratemode
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|cl
parameter_list|,
name|int
name|minrate
parameter_list|,
name|int
name|maxrate
parameter_list|,
name|int
name|weight
parameter_list|,
name|int
name|pktsize
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_sched_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_SCHED_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|sc
operator|=
name|FW_SCHED_SC_PARAMS
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|ch
operator|=
name|channel
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|cl
operator|=
name|cl
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|unit
operator|=
name|rateunit
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|rate
operator|=
name|ratemode
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|min
operator|=
name|cpu_to_be32
argument_list|(
name|minrate
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|max
operator|=
name|cpu_to_be32
argument_list|(
name|maxrate
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|weight
operator|=
name|cpu_to_be16
argument_list|(
name|weight
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|pktsize
operator|=
name|cpu_to_be16
argument_list|(
name|pktsize
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t4_sched_params_ch_rl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|ratemode
parameter_list|,
name|unsigned
name|int
name|maxrate
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_sched_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_SCHED_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|sc
operator|=
name|FW_SCHED_SC_PARAMS
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|type
operator|=
name|FW_SCHED_TYPE_PKTSCHED
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CH_RL
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|ch
operator|=
name|channel
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|rate
operator|=
name|ratemode
expr_stmt|;
comment|/* REL or ABS */
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|max
operator|=
name|cpu_to_be32
argument_list|(
name|maxrate
argument_list|)
expr_stmt|;
comment|/*  %  or kbps */
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t4_sched_params_cl_wrr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|cl
parameter_list|,
name|int
name|weight
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_sched_cmd
name|cmd
decl_stmt|;
if|if
condition|(
name|weight
operator|<
literal|0
operator|||
name|weight
operator|>
literal|100
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_SCHED_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|sc
operator|=
name|FW_SCHED_SC_PARAMS
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|type
operator|=
name|FW_SCHED_TYPE_PKTSCHED
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CL_WRR
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|ch
operator|=
name|channel
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|cl
operator|=
name|cl
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|weight
operator|=
name|cpu_to_be16
argument_list|(
name|weight
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t4_sched_params_cl_rl_kbps
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|cl
parameter_list|,
name|int
name|mode
parameter_list|,
name|unsigned
name|int
name|maxrate
parameter_list|,
name|int
name|pktsize
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_sched_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_SCHED_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|sc
operator|=
name|FW_SCHED_SC_PARAMS
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|type
operator|=
name|FW_SCHED_TYPE_PKTSCHED
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|level
operator|=
name|FW_SCHED_PARAMS_LEVEL_CL_RL
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|ch
operator|=
name|channel
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|cl
operator|=
name|cl
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|unit
operator|=
name|FW_SCHED_PARAMS_UNIT_BITRATE
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|rate
operator|=
name|FW_SCHED_PARAMS_RATE_ABS
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|max
operator|=
name|cpu_to_be32
argument_list|(
name|maxrate
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|pktsize
operator|=
name|cpu_to_be16
argument_list|(
name|pktsize
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	t4_config_watchdog - configure (enable/disable) a watchdog timer  *	@adapter: the adapter  * 	@mbox: mailbox to use for the FW command  * 	@pf: the PF owning the queue  * 	@vf: the VF owning the queue  *	@timeout: watchdog timeout in ms  *	@action: watchdog timer / action  *  *	There are separate watchdog timers for each possible watchdog  *	action.  Configure one of the watchdog timers by setting a non-zero  *	timeout.  Disable a watchdog timer by using a timeout of zero.  */
end_comment

begin_function
name|int
name|t4_config_watchdog
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|,
name|unsigned
name|int
name|action
parameter_list|)
block|{
name|struct
name|fw_watchdog_cmd
name|wdog
decl_stmt|;
name|unsigned
name|int
name|ticks
decl_stmt|;
comment|/* 	 * The watchdog command expects a timeout in units of 10ms so we need 	 * to convert it here (via rounding) and force a minimum of one 10ms 	 * "tick" if the timeout is non-zero but the conversion results in 0 	 * ticks. 	 */
name|ticks
operator|=
operator|(
name|timeout
operator|+
literal|5
operator|)
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|timeout
operator|&&
operator|!
name|ticks
condition|)
name|ticks
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|wdog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|wdog
argument_list|)
expr_stmt|;
name|wdog
operator|.
name|op_to_vfn
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_WATCHDOG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_PARAMS_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_PARAMS_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|wdog
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|wdog
argument_list|)
argument_list|)
expr_stmt|;
name|wdog
operator|.
name|timeout
operator|=
name|cpu_to_be32
argument_list|(
name|ticks
argument_list|)
expr_stmt|;
name|wdog
operator|.
name|action
operator|=
name|cpu_to_be32
argument_list|(
name|action
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|mbox
argument_list|,
operator|&
name|wdog
argument_list|,
sizeof|sizeof
name|wdog
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t4_get_devlog_level
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
modifier|*
name|level
parameter_list|)
block|{
name|struct
name|fw_devlog_cmd
name|devlog_cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|devlog_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|devlog_cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_DEVLOG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
argument_list|)
expr_stmt|;
name|devlog_cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|devlog_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|,
operator|&
name|devlog_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
operator|*
name|level
operator|=
name|devlog_cmd
operator|.
name|level
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|t4_set_devlog_level
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|level
parameter_list|)
block|{
name|struct
name|fw_devlog_cmd
name|devlog_cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|devlog_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|devlog_cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_DEVLOG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|devlog_cmd
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|devlog_cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|devlog_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|devlog_cmd
argument_list|)
argument_list|,
operator|&
name|devlog_cmd
argument_list|)
return|;
block|}
end_function

end_unit

