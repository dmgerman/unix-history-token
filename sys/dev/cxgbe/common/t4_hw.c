begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"firmware/t4fw_interface.h"
end_include

begin_undef
undef|#
directive|undef
name|msleep
end_undef

begin_define
define|#
directive|define
name|msleep
parameter_list|(
name|x
parameter_list|)
value|do { \ 	if (cold) \ 		DELAY((x) * 1000); \ 	else \ 		pause("t4hw", (x) * hz / 1000); \ } while (0)
end_define

begin_comment
comment|/**  *	t4_wait_op_done_val - wait until an operation is completed  *	@adapter: the adapter performing the operation  *	@reg: the register to check for completion  *	@mask: a single-bit field within @reg that indicates completion  *	@polarity: the value of the field when the operation is completed  *	@attempts: number of check iterations  *	@delay: delay in usecs between iterations  *	@valp: where to store the value of the register at completion time  *  *	Wait until an operation is completed by checking a bit in a register  *	up to @attempts times.  If @valp is not NULL the value of the register  *	at the time it indicated completion is stored there.  Returns 0 if the  *	operation completes and	-EAGAIN	otherwise.  */
end_comment

begin_function
name|int
name|t4_wait_op_done_val
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|mask
parameter_list|,
name|int
name|polarity
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|u32
name|val
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|!
operator|(
name|val
operator|&
name|mask
operator|)
operator|==
name|polarity
condition|)
block|{
if|if
condition|(
name|valp
condition|)
operator|*
name|valp
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|udelay
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_set_reg_field - set a register field to a value  *	@adapter: the adapter to program  *	@addr: the register address  *	@mask: specifies the portion of the register to modify  *	@val: the new value for the register field  *  *	Sets a register field specified by the supplied mask to the  *	given value.  */
end_comment

begin_function
name|void
name|t4_set_reg_field
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|mask
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|u32
name|v
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
operator|~
name|mask
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|v
operator||
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	t4_read_indirect - read indirectly addressed registers  *	@adap: the adapter  *	@addr_reg: register holding the indirect address  *	@data_reg: register holding the value of the indirect register  *	@vals: where the read register values are stored  *	@nregs: how many indirect registers to read  *	@start_idx: index of first indirect register to read  *  *	Reads registers that are accessed indirectly through an address/data  *	register pair.  */
end_comment

begin_function
name|void
name|t4_read_indirect
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr_reg
parameter_list|,
name|unsigned
name|int
name|data_reg
parameter_list|,
name|u32
modifier|*
name|vals
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|unsigned
name|int
name|start_idx
parameter_list|)
block|{
while|while
condition|(
name|nregs
operator|--
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|addr_reg
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
operator|*
name|vals
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|start_idx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_write_indirect - write indirectly addressed registers  *	@adap: the adapter  *	@addr_reg: register holding the indirect addresses  *	@data_reg: register holding the value for the indirect registers  *	@vals: values to write  *	@nregs: how many indirect registers to write  *	@start_idx: address of first indirect register to write  *  *	Writes a sequential block of registers that are accessed indirectly  *	through an address/data register pair.  */
end_comment

begin_function
name|void
name|t4_write_indirect
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr_reg
parameter_list|,
name|unsigned
name|int
name|data_reg
parameter_list|,
specifier|const
name|u32
modifier|*
name|vals
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|unsigned
name|int
name|start_idx
parameter_list|)
block|{
while|while
condition|(
name|nregs
operator|--
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|addr_reg
argument_list|,
name|start_idx
operator|++
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|,
operator|*
name|vals
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read a 32-bit PCI Configuration Space register via the PCI-E backdoor  * mechanism.  This guarantees that we get the real value even if we're  * operating within a Virtual Machine and the Hypervisor is trapping our  * Configuration Space accesses.  */
end_comment

begin_function
name|u32
name|t4_hw_pci_read_cfg4
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_CFG_SPACE_REQ
argument_list|,
name|F_ENABLE
operator||
name|F_LOCALCFG
operator||
name|V_FUNCTION
argument_list|(
name|adap
operator|->
name|pf
argument_list|)
operator||
name|V_REGISTER
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_CFG_SPACE_DATA
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	t4_report_fw_error - report firmware error  *	@adap: the adapter  *  *	The adapter firmware can indicate error conditions to the host.  *	This routine prints out the reason for the firmware error (as  *	reported by the firmware).  */
end_comment

begin_function
specifier|static
name|void
name|t4_report_fw_error
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|reason
index|[]
init|=
block|{
literal|"Crash"
block|,
comment|/* PCIE_FW_EVAL_CRASH */
literal|"During Device Preparation"
block|,
comment|/* PCIE_FW_EVAL_PREP */
literal|"During Device Configuration"
block|,
comment|/* PCIE_FW_EVAL_CONF */
literal|"During Device Initialization"
block|,
comment|/* PCIE_FW_EVAL_INIT */
literal|"Unexpected Event"
block|,
comment|/* PCIE_FW_EVAL_UNEXPECTEDEVENT */
literal|"Insufficient Airflow"
block|,
comment|/* PCIE_FW_EVAL_OVERHEAT */
literal|"Device Shutdown"
block|,
comment|/* PCIE_FW_EVAL_DEVICESHUTDOWN */
literal|"Reserved"
block|,
comment|/* reserved */
block|}
decl_stmt|;
name|u32
name|pcie_fw
decl_stmt|;
name|pcie_fw
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_fw
operator|&
name|F_PCIE_FW_ERR
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Firmware reports adapter error: %s\n"
argument_list|,
name|reason
index|[
name|G_PCIE_FW_EVAL
argument_list|(
name|pcie_fw
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the reply to a mailbox command and store it in @rpl in big-endian order.  */
end_comment

begin_function
specifier|static
name|void
name|get_mbox_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|__be64
modifier|*
name|rpl
parameter_list|,
name|int
name|nflit
parameter_list|,
name|u32
name|mbox_addr
parameter_list|)
block|{
for|for
control|(
init|;
name|nflit
condition|;
name|nflit
operator|--
operator|,
name|mbox_addr
operator|+=
literal|8
control|)
operator|*
name|rpl
operator|++
operator|=
name|cpu_to_be64
argument_list|(
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|mbox_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a FW assertion reported in a mailbox.  */
end_comment

begin_function
specifier|static
name|void
name|fw_asrt
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
name|mbox_addr
parameter_list|)
block|{
name|struct
name|fw_debug_cmd
name|asrt
decl_stmt|;
name|get_mbox_rpl
argument_list|(
name|adap
argument_list|,
operator|(
name|__be64
operator|*
operator|)
operator|&
name|asrt
argument_list|,
sizeof|sizeof
argument_list|(
name|asrt
argument_list|)
operator|/
literal|8
argument_list|,
name|mbox_addr
argument_list|)
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"FW assertion at %.16s:%u, val0 %#x, val1 %#x\n"
argument_list|,
name|asrt
operator|.
name|u
operator|.
name|assert
operator|.
name|filename_0_7
argument_list|,
name|ntohl
argument_list|(
name|asrt
operator|.
name|u
operator|.
name|assert
operator|.
name|line
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|asrt
operator|.
name|u
operator|.
name|assert
operator|.
name|x
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|asrt
operator|.
name|u
operator|.
name|assert
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|X_CIM_PF_NOACCESS
value|0xeeeeeeee
end_define

begin_comment
comment|/**  *	t4_wr_mbox_meat - send a command to FW through the given mailbox  *	@adap: the adapter  *	@mbox: index of the mailbox to use  *	@cmd: the command to write  *	@size: command length in bytes  *	@rpl: where to optionally store the reply  *	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Sends the given command to FW through the selected mailbox and waits  *	for the FW to execute the command.  If @rpl is not %NULL it is used to  *	store the FW's reply to the command.  The command and its optional  *	reply are of the same length.  Some FW commands like RESET and  *	INITIALIZE can take a considerable amount of time to execute.  *	@sleep_ok determines whether we may sleep while awaiting the response.  *	If sleeping is allowed we use progressive backoff otherwise we spin.  *  *	The return value is 0 on success or a negative errno on failure.  A  *	failure can happen either because we are not able to execute the  *	command or FW executes it but signals an error.  In the latter case  *	the return value is the error code indicated by FW (negated).  */
end_comment

begin_function
name|int
name|t4_wr_mbox_meat
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|mbox
parameter_list|,
specifier|const
name|void
modifier|*
name|cmd
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|rpl
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
comment|/* 	 * We delay in small increments at first in an effort to maintain 	 * responsiveness for simple, fast executing commands but then back 	 * off to larger delays to a maximum retry delay. 	 */
specifier|static
specifier|const
name|int
name|delay
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|10
block|,
literal|10
block|,
literal|20
block|,
literal|50
block|,
literal|100
block|}
decl_stmt|;
name|u32
name|v
decl_stmt|;
name|u64
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ms
decl_stmt|,
name|delay_idx
decl_stmt|;
specifier|const
name|__be64
modifier|*
name|p
init|=
name|cmd
decl_stmt|;
name|u32
name|data_reg
init|=
name|PF_REG
argument_list|(
name|mbox
argument_list|,
name|A_CIM_PF_MAILBOX_DATA
argument_list|)
decl_stmt|;
name|u32
name|ctl_reg
init|=
name|PF_REG
argument_list|(
name|mbox
argument_list|,
name|A_CIM_PF_MAILBOX_CTRL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
literal|15
operator|)
operator|||
name|size
operator|>
name|MBOX_LEN
condition|)
return|return
operator|-
name|EINVAL
return|;
name|v
operator|=
name|G_MBOWNER
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|v
operator|==
name|X_MBOWNER_NONE
operator|&&
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|v
operator|=
name|G_MBOWNER
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|X_MBOWNER_PL
condition|)
return|return
name|v
condition|?
operator|-
name|EBUSY
else|:
operator|-
name|ETIMEDOUT
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|8
operator|,
name|p
operator|++
control|)
name|t4_write_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
operator|+
name|i
argument_list|,
name|be64_to_cpu
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|,
name|F_MBMSGVALID
operator||
name|V_MBOWNER
argument_list|(
name|X_MBOWNER_FW
argument_list|)
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|)
expr_stmt|;
comment|/* flush write */
name|delay_idx
operator|=
literal|0
expr_stmt|;
name|ms
operator|=
name|delay
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FW_CMD_MAX_TIMEOUT
condition|;
name|i
operator|+=
name|ms
control|)
block|{
if|if
condition|(
name|sleep_ok
condition|)
block|{
name|ms
operator|=
name|delay
index|[
name|delay_idx
index|]
expr_stmt|;
comment|/* last element may repeat */
if|if
condition|(
name|delay_idx
operator|<
name|ARRAY_SIZE
argument_list|(
name|delay
argument_list|)
operator|-
literal|1
condition|)
name|delay_idx
operator|++
expr_stmt|;
name|msleep
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
else|else
name|mdelay
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|X_CIM_PF_NOACCESS
condition|)
continue|continue;
if|if
condition|(
name|G_MBOWNER
argument_list|(
name|v
argument_list|)
operator|==
name|X_MBOWNER_PL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|&
name|F_MBMSGVALID
operator|)
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|,
name|V_MBOWNER
argument_list|(
name|X_MBOWNER_NONE
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|res
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_FW_CMD_OP
argument_list|(
name|res
operator|>>
literal|32
argument_list|)
operator|==
name|FW_DEBUG_CMD
condition|)
block|{
name|fw_asrt
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|res
operator|=
name|V_FW_CMD_RETVAL
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rpl
condition|)
name|get_mbox_rpl
argument_list|(
name|adap
argument_list|,
name|rpl
argument_list|,
name|size
operator|/
literal|8
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|ctl_reg
argument_list|,
name|V_MBOWNER
argument_list|(
name|X_MBOWNER_NONE
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|G_FW_CMD_RETVAL
argument_list|(
operator|(
name|int
operator|)
name|res
argument_list|)
return|;
block|}
block|}
comment|/* 	 * We timed out waiting for a reply to our mailbox command.  Report 	 * the error and also check to see if the firmware reported any 	 * errors ... 	 */
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"command %#x in mailbox %d timed out\n"
argument_list|,
operator|*
operator|(
specifier|const
name|u8
operator|*
operator|)
name|cmd
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
operator|&
name|F_PCIE_FW_ERR
condition|)
name|t4_report_fw_error
argument_list|(
name|adap
argument_list|)
expr_stmt|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mc_read - read from MC through backdoor accesses  *	@adap: the adapter  *	@idx: which MC to access  *	@addr: address of first byte requested  *	@data: 64 bytes of data containing the requested address  *	@ecc: where to store the corresponding 64-bit ECC word  *  *	Read 64 bytes of data from MC starting at a 64-byte-aligned address  *	that covers the requested address @addr.  If @parity is not %NULL it  *	is assigned the 64-bit ECC word for the read data.  */
end_comment

begin_function
name|int
name|t4_mc_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|u32
name|addr
parameter_list|,
name|__be32
modifier|*
name|data
parameter_list|,
name|u64
modifier|*
name|ecc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|mc_bist_cmd_reg
decl_stmt|,
name|mc_bist_cmd_addr_reg
decl_stmt|,
name|mc_bist_cmd_len_reg
decl_stmt|;
name|u32
name|mc_bist_status_rdata_reg
decl_stmt|,
name|mc_bist_data_pattern_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|mc_bist_cmd_reg
operator|=
name|A_MC_BIST_CMD
expr_stmt|;
name|mc_bist_cmd_addr_reg
operator|=
name|A_MC_BIST_CMD_ADDR
expr_stmt|;
name|mc_bist_cmd_len_reg
operator|=
name|A_MC_BIST_CMD_LEN
expr_stmt|;
name|mc_bist_status_rdata_reg
operator|=
name|A_MC_BIST_STATUS_RDATA
expr_stmt|;
name|mc_bist_data_pattern_reg
operator|=
name|A_MC_BIST_DATA_PATTERN
expr_stmt|;
block|}
else|else
block|{
name|mc_bist_cmd_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_CMD
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_cmd_addr_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_CMD_ADDR
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_cmd_len_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_CMD_LEN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_status_rdata_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_STATUS_RDATA
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mc_bist_data_pattern_reg
operator|=
name|MC_REG
argument_list|(
name|A_MC_P_BIST_DATA_PATTERN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_reg
argument_list|)
operator|&
name|F_START_BIST
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_addr_reg
argument_list|,
name|addr
operator|&
operator|~
literal|0x3fU
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_len_reg
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_data_pattern_reg
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_reg
argument_list|,
name|V_BIST_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_START_BIST
operator||
name|V_BIST_CMD_GAP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|mc_bist_cmd_reg
argument_list|,
name|F_START_BIST
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
define|#
directive|define
name|MC_DATA
parameter_list|(
name|i
parameter_list|)
value|MC_BIST_STATUS_REG(mc_bist_status_rdata_reg, i)
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|data
operator|++
operator|=
name|ntohl
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|MC_DATA
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecc
condition|)
operator|*
name|ecc
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|MC_DATA
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MC_DATA
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_edc_read - read from EDC through backdoor accesses  *	@adap: the adapter  *	@idx: which EDC to access  *	@addr: address of first byte requested  *	@data: 64 bytes of data containing the requested address  *	@ecc: where to store the corresponding 64-bit ECC word  *  *	Read 64 bytes of data from EDC starting at a 64-byte-aligned address  *	that covers the requested address @addr.  If @parity is not %NULL it  *	is assigned the 64-bit ECC word for the read data.  */
end_comment

begin_function
name|int
name|t4_edc_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|u32
name|addr
parameter_list|,
name|__be32
modifier|*
name|data
parameter_list|,
name|u64
modifier|*
name|ecc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|edc_bist_cmd_reg
decl_stmt|,
name|edc_bist_cmd_addr_reg
decl_stmt|,
name|edc_bist_cmd_len_reg
decl_stmt|;
name|u32
name|edc_bist_cmd_data_pattern
decl_stmt|,
name|edc_bist_status_rdata_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|edc_bist_cmd_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_CMD
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_addr_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_CMD_ADDR
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_len_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_CMD_LEN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_data_pattern
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_DATA_PATTERN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_status_rdata_reg
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_BIST_STATUS_RDATA
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  * These macro are missing in t4_regs.h file.  * Added temporarily for testing.  */
define|#
directive|define
name|EDC_STRIDE_T5
value|(EDC_T51_BASE_ADDR - EDC_T50_BASE_ADDR)
define|#
directive|define
name|EDC_REG_T5
parameter_list|(
name|reg
parameter_list|,
name|idx
parameter_list|)
value|(reg + EDC_STRIDE_T5 * idx)
name|edc_bist_cmd_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_CMD
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_addr_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_CMD_ADDR
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_len_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_CMD_LEN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_cmd_data_pattern
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_DATA_PATTERN
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|edc_bist_status_rdata_reg
operator|=
name|EDC_REG_T5
argument_list|(
name|A_EDC_H_BIST_STATUS_RDATA
argument_list|,
name|idx
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|EDC_REG_T5
undef|#
directive|undef
name|EDC_STRIDE_T5
block|}
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_reg
argument_list|)
operator|&
name|F_START_BIST
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_addr_reg
argument_list|,
name|addr
operator|&
operator|~
literal|0x3fU
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_len_reg
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_data_pattern
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_reg
argument_list|,
name|V_BIST_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_BIST_CMD_GAP
argument_list|(
literal|1
argument_list|)
operator||
name|F_START_BIST
argument_list|)
expr_stmt|;
name|i
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|edc_bist_cmd_reg
argument_list|,
name|F_START_BIST
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
define|#
directive|define
name|EDC_DATA
parameter_list|(
name|i
parameter_list|)
value|EDC_BIST_STATUS_REG(edc_bist_status_rdata_reg, i)
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|data
operator|++
operator|=
name|ntohl
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EDC_DATA
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecc
condition|)
operator|*
name|ecc
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|EDC_DATA
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|EDC_DATA
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mem_read - read EDC 0, EDC 1 or MC into buffer  *	@adap: the adapter  *	@mtype: memory type: MEM_EDC0, MEM_EDC1 or MEM_MC  *	@addr: address within indicated memory type  *	@len: amount of memory to read  *	@buf: host memory buffer  *  *	Reads an [almost] arbitrary memory region in the firmware: the  *	firmware memory address, length and host buffer must be aligned on  *	32-bit boudaries.  The memory is returned as a raw byte sequence from  *	the firmware's memory.  If this memory contains data structures which  *	contain multi-byte integers, it's the callers responsibility to  *	perform appropriate byte order conversions.  */
end_comment

begin_function
name|int
name|t4_mem_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|mtype
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|len
parameter_list|,
name|__be32
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|pos
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Argument sanity checks ... 	 */
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|len
operator|&
literal|0x3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 	 * The underlaying EDC/MC read routines read 64 bytes at a time so we 	 * need to round down the start and round up the end.  We'll start 	 * copying out of the first line at (addr - start) a word at a time. 	 */
name|start
operator|=
name|addr
operator|&
operator|~
operator|(
literal|64
operator|-
literal|1
operator|)
expr_stmt|;
name|end
operator|=
operator|(
name|addr
operator|+
name|len
operator|+
literal|64
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
literal|64
operator|-
literal|1
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
name|addr
operator|-
name|start
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|__be32
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|start
init|;
name|pos
operator|<
name|end
condition|;
name|pos
operator|+=
literal|64
operator|,
name|offset
operator|=
literal|0
control|)
block|{
name|__be32
name|data
index|[
literal|16
index|]
decl_stmt|;
comment|/* 		 * Read the chip's memory block and bail if there's an error. 		 */
if|if
condition|(
operator|(
name|mtype
operator|==
name|MEM_MC
operator|)
operator|||
operator|(
name|mtype
operator|==
name|MEM_MC1
operator|)
condition|)
name|ret
operator|=
name|t4_mc_read
argument_list|(
name|adap
argument_list|,
name|mtype
operator|-
name|MEM_MC
argument_list|,
name|pos
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|t4_edc_read
argument_list|(
name|adap
argument_list|,
name|mtype
argument_list|,
name|pos
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* 		 * Copy the data into the caller's memory buffer. 		 */
while|while
condition|(
name|offset
operator|<
literal|16
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|__be32
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Partial EEPROM Vital Product Data structure.  Includes only the ID and  * VPD-R header.  */
end_comment

begin_struct
struct|struct
name|t4_vpd_hdr
block|{
name|u8
name|id_tag
decl_stmt|;
name|u8
name|id_len
index|[
literal|2
index|]
decl_stmt|;
name|u8
name|id_data
index|[
name|ID_LEN
index|]
decl_stmt|;
name|u8
name|vpdr_tag
decl_stmt|;
name|u8
name|vpdr_len
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * EEPROM reads take a few tens of us while writes can take a bit over 5 ms.  */
end_comment

begin_define
define|#
directive|define
name|EEPROM_MAX_RD_POLL
value|40
end_define

begin_define
define|#
directive|define
name|EEPROM_MAX_WR_POLL
value|6
end_define

begin_define
define|#
directive|define
name|EEPROM_STAT_ADDR
value|0x7bfc
end_define

begin_define
define|#
directive|define
name|VPD_BASE
value|0x400
end_define

begin_define
define|#
directive|define
name|VPD_BASE_OLD
value|0
end_define

begin_define
define|#
directive|define
name|VPD_LEN
value|1024
end_define

begin_define
define|#
directive|define
name|VPD_INFO_FLD_HDR_SIZE
value|3
end_define

begin_define
define|#
directive|define
name|CHELSIO_VPD_UNIQUE_ID
value|0x82
end_define

begin_comment
comment|/**  *	t4_seeprom_read - read a serial EEPROM location  *	@adapter: adapter to read  *	@addr: EEPROM virtual address  *	@data: where to store the read data  *  *	Read a 32-bit word from a location in serial EEPROM using the card's PCI  *	VPD capability.  Note that this function must be called with a virtual  *	address.  */
end_comment

begin_function
name|int
name|t4_seeprom_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|int
name|attempts
init|=
name|EEPROM_MAX_RD_POLL
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|EEPROMVSIZE
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_os_pci_write_cfg2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
argument_list|)
expr_stmt|;
do|do
block|{
name|udelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"reading EEPROM address 0x%x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
name|t4_os_pci_read_cfg4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_seeprom_write - write a serial EEPROM location  *	@adapter: adapter to write  *	@addr: virtual EEPROM address  *	@data: value to write  *  *	Write a 32-bit word to a location in serial EEPROM using the card's PCI  *	VPD capability.  Note that this function must be called with a virtual  *	address.  */
end_comment

begin_function
name|int
name|t4_seeprom_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|int
name|attempts
init|=
name|EEPROM_MAX_WR_POLL
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|EEPROMVSIZE
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_os_pci_write_cfg4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|cpu_to_le32
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|t4_os_pci_write_cfg2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
operator||
name|PCI_VPD_ADDR_F
argument_list|)
expr_stmt|;
do|do
block|{
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
name|val
operator|&
name|PCI_VPD_ADDR_F
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"write to EEPROM address 0x%x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_eeprom_ptov - translate a physical EEPROM address to virtual  *	@phys_addr: the physical EEPROM address  *	@fn: the PCI function number  *	@sz: size of function-specific area  *  *	Translate a physical EEPROM address to virtual.  The first 1K is  *	accessed through virtual addresses starting at 31K, the rest is  *	accessed through virtual addresses starting at 0.  *  *	The mapping is as follows:  *	[0..1K) -> [31K..32K)  *	[1K..1K+A) -> [ES-A..ES)  *	[1K+A..ES) -> [0..ES-A-1K)  *  *	where A = @fn * @sz, and ES = EEPROM size.  */
end_comment

begin_function
name|int
name|t4_eeprom_ptov
parameter_list|(
name|unsigned
name|int
name|phys_addr
parameter_list|,
name|unsigned
name|int
name|fn
parameter_list|,
name|unsigned
name|int
name|sz
parameter_list|)
block|{
name|fn
operator|*=
name|sz
expr_stmt|;
if|if
condition|(
name|phys_addr
operator|<
literal|1024
condition|)
return|return
name|phys_addr
operator|+
operator|(
literal|31
operator|<<
literal|10
operator|)
return|;
if|if
condition|(
name|phys_addr
operator|<
literal|1024
operator|+
name|fn
condition|)
return|return
name|EEPROMSIZE
operator|-
name|fn
operator|+
name|phys_addr
operator|-
literal|1024
return|;
if|if
condition|(
name|phys_addr
operator|<
name|EEPROMSIZE
condition|)
return|return
name|phys_addr
operator|-
literal|1024
operator|-
name|fn
return|;
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_seeprom_wp - enable/disable EEPROM write protection  *	@adapter: the adapter  *	@enable: whether to enable or disable write protection  *  *	Enables or disables write protection on the serial EEPROM.  */
end_comment

begin_function
name|int
name|t4_seeprom_wp
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
return|return
name|t4_seeprom_write
argument_list|(
name|adapter
argument_list|,
name|EEPROM_STAT_ADDR
argument_list|,
name|enable
condition|?
literal|0xc
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	get_vpd_keyword_val - Locates an information field keyword in the VPD  *	@v: Pointer to buffered vpd data structure  *	@kw: The keyword to search for  *	  *	Returns the value of the information field keyword or  *	-ENOENT otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_vpd_keyword_val
parameter_list|(
specifier|const
name|struct
name|t4_vpd_hdr
modifier|*
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|kw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|u8
modifier|*
name|buf
init|=
operator|&
name|v
operator|->
name|id_tag
decl_stmt|;
specifier|const
name|u8
modifier|*
name|vpdr_len
init|=
operator|&
name|v
operator|->
name|vpdr_tag
decl_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|t4_vpd_hdr
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|u16
operator|)
name|vpdr_len
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|u16
operator|)
name|vpdr_len
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|t4_vpd_hdr
argument_list|)
operator|>
name|VPD_LEN
condition|)
block|{
return|return
operator|-
name|ENOENT
return|;
block|}
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|+
name|VPD_INFO_FLD_HDR_SIZE
operator|<=
name|offset
operator|+
name|len
condition|;
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|kw
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
name|VPD_INFO_FLD_HDR_SIZE
expr_stmt|;
return|return
name|i
return|;
block|}
name|i
operator|+=
name|VPD_INFO_FLD_HDR_SIZE
operator|+
name|buf
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
return|return
operator|-
name|ENOENT
return|;
block|}
end_function

begin_comment
comment|/**  *	get_vpd_params - read VPD parameters from VPD EEPROM  *	@adapter: adapter to read  *	@p: where to store the parameters  *  *	Reads card parameters stored in VPD EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|get_vpd_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|vpd_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|ec
decl_stmt|,
name|sn
decl_stmt|,
name|pn
decl_stmt|,
name|na
decl_stmt|;
name|u8
name|vpd
index|[
name|VPD_LEN
index|]
decl_stmt|,
name|csum
decl_stmt|;
specifier|const
name|struct
name|t4_vpd_hdr
modifier|*
name|v
decl_stmt|;
comment|/* 	 * Card information normally starts at VPD_BASE but early cards had 	 * it at 0. 	 */
name|ret
operator|=
name|t4_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|VPD_BASE
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|(
name|vpd
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|*
name|vpd
operator|==
name|CHELSIO_VPD_UNIQUE_ID
condition|?
name|VPD_BASE
else|:
name|VPD_BASE_OLD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|vpd
argument_list|)
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ret
operator|=
name|t4_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|addr
operator|+
name|i
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|(
name|vpd
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|v
operator|=
operator|(
specifier|const
expr|struct
name|t4_vpd_hdr
operator|*
operator|)
name|vpd
expr_stmt|;
define|#
directive|define
name|FIND_VPD_KW
parameter_list|(
name|var
parameter_list|,
name|name
parameter_list|)
value|do { \ 	var = get_vpd_keyword_val(v , name); \ 	if (var< 0) { \ 		CH_ERR(adapter, "missing VPD keyword " name "\n"); \ 		return -EINVAL; \ 	} \ } while (0)
name|FIND_VPD_KW
argument_list|(
name|i
argument_list|,
literal|"RV"
argument_list|)
expr_stmt|;
for|for
control|(
name|csum
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|csum
operator|+=
name|vpd
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|csum
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"corrupted VPD EEPROM, actual csum %u\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|FIND_VPD_KW
argument_list|(
name|ec
argument_list|,
literal|"EC"
argument_list|)
expr_stmt|;
name|FIND_VPD_KW
argument_list|(
name|sn
argument_list|,
literal|"SN"
argument_list|)
expr_stmt|;
name|FIND_VPD_KW
argument_list|(
name|pn
argument_list|,
literal|"PN"
argument_list|)
expr_stmt|;
name|FIND_VPD_KW
argument_list|(
name|na
argument_list|,
literal|"NA"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FIND_VPD_KW
name|memcpy
argument_list|(
name|p
operator|->
name|id
argument_list|,
name|v
operator|->
name|id_data
argument_list|,
name|ID_LEN
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
name|p
operator|->
name|id
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|ec
argument_list|,
name|vpd
operator|+
name|ec
argument_list|,
name|EC_LEN
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
name|p
operator|->
name|ec
argument_list|)
expr_stmt|;
name|i
operator|=
name|vpd
index|[
name|sn
operator|-
name|VPD_INFO_FLD_HDR_SIZE
operator|+
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|sn
argument_list|,
name|vpd
operator|+
name|sn
argument_list|,
name|min
argument_list|(
name|i
argument_list|,
name|SERNUM_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
name|p
operator|->
name|sn
argument_list|)
expr_stmt|;
name|i
operator|=
name|vpd
index|[
name|pn
operator|-
name|VPD_INFO_FLD_HDR_SIZE
operator|+
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|pn
argument_list|,
name|vpd
operator|+
name|pn
argument_list|,
name|min
argument_list|(
name|i
argument_list|,
name|PN_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|pn
argument_list|)
expr_stmt|;
name|i
operator|=
name|vpd
index|[
name|na
operator|-
name|VPD_INFO_FLD_HDR_SIZE
operator|+
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|na
argument_list|,
name|vpd
operator|+
name|na
argument_list|,
name|min
argument_list|(
name|i
argument_list|,
name|MACADDR_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|strstrip
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|na
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* serial flash and firmware constants and flash config file constants */
end_comment

begin_enum
enum|enum
block|{
name|SF_ATTEMPTS
init|=
literal|10
block|,
comment|/* max retries for SF operations */
comment|/* flash command opcodes */
name|SF_PROG_PAGE
init|=
literal|2
block|,
comment|/* program page */
name|SF_WR_DISABLE
init|=
literal|4
block|,
comment|/* disable writes */
name|SF_RD_STATUS
init|=
literal|5
block|,
comment|/* read status register */
name|SF_WR_ENABLE
init|=
literal|6
block|,
comment|/* enable writes */
name|SF_RD_DATA_FAST
init|=
literal|0xb
block|,
comment|/* read flash */
name|SF_RD_ID
init|=
literal|0x9f
block|,
comment|/* read ID */
name|SF_ERASE_SECTOR
init|=
literal|0xd8
block|,
comment|/* erase sector */
block|}
enum|;
end_enum

begin_comment
comment|/**  *	sf1_read - read data from the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to read  *	@cont: whether another operation will be chained  *	@lock: whether to lock SF for PL access only  *	@valp: where to store the read data  *  *	Reads up to 4 bytes of data from the serial flash.  The location of  *	the read needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|int
name|lock
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_SF_LOCK
argument_list|(
name|lock
argument_list|)
operator||
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	sf1_write - write data to the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to write  *	@cont: whether another operation will be chained  *	@lock: whether to lock SF for PL access only  *	@val: value to write  *  *	Writes up to 4 bytes of data to the serial flash.  The location of  *	the write needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|int
name|lock
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_SF_LOCK
argument_list|(
name|lock
argument_list|)
operator||
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
operator||
name|V_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|5
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	flash_wait_op - wait for a flash operation to complete  *	@adapter: the adapter  *	@attempts: max number of polls of the status register  *	@delay: delay between polls in ms  *  *	Wait for a flash operation to complete by polling the status register.  */
end_comment

begin_function
specifier|static
name|int
name|flash_wait_op
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|status
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|SF_RD_STATUS
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|msleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_flash - read words from serial flash  *	@adapter: the adapter  *	@addr: the start address for the read  *	@nwords: how many 32-bit words to read  *	@data: where to store the read data  *	@byte_oriented: whether to store data as bytes or as words  *  *	Read the specified number of 32-bit words from the serial flash.  *	If @byte_oriented is set the read data is stored as a byte array  *	(i.e., big-endian), otherwise as 32-bit words in the platform's  *	natural endianess.  */
end_comment

begin_function
name|int
name|t4_read_flash
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|nwords
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|int
name|byte_oriented
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|addr
operator|+
name|nwords
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|>
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|addr
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_RD_DATA_FAST
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
init|;
name|nwords
condition|;
name|nwords
operator|--
operator|,
name|data
operator|++
control|)
block|{
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
name|nwords
operator|>
literal|1
argument_list|,
name|nwords
operator|==
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwords
operator|==
literal|1
condition|)
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|byte_oriented
condition|)
operator|*
name|data
operator|=
name|htonl
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_flash - write up to a page of data to the serial flash  *	@adapter: the adapter  *	@addr: the start address to write  *	@n: length of data to write in bytes  *	@data: the data to write  *	@byte_oriented: whether to store data as bytes or as words  *  *	Writes up to a page of data (256 bytes) to the serial flash starting  *	at the given address.  All the data must be written to the same page.  *	If @byte_oriented is set the write data is stored as byte stream   *	(i.e. matches what on disk), otherwise in big-endian.  */
end_comment

begin_function
specifier|static
name|int
name|t4_write_flash
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|int
name|byte_oriented
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|buf
index|[
name|SF_PAGE_SIZE
operator|/
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|left
decl_stmt|,
name|val
decl_stmt|,
name|offset
init|=
name|addr
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|||
name|offset
operator|+
name|n
operator|>
name|SF_PAGE_SIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|val
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_PROG_PAGE
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unlock
goto|;
for|for
control|(
name|left
operator|=
name|n
init|;
name|left
condition|;
name|left
operator|-=
name|c
control|)
block|{
name|c
operator|=
name|min
argument_list|(
name|left
argument_list|,
literal|4U
argument_list|)
expr_stmt|;
for|for
control|(
name|val
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|byte_oriented
condition|)
name|val
operator|=
name|htonl
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
name|c
argument_list|,
name|c
operator|!=
name|left
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unlock
goto|;
block|}
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unlock
goto|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
comment|/* Read the page to verify the write succeeded */
name|ret
operator|=
name|t4_read_flash
argument_list|(
name|adapter
argument_list|,
name|addr
operator|&
operator|~
literal|0xff
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|,
name|byte_oriented
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|data
operator|-
name|n
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|buf
operator|+
name|offset
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"failed to correctly write the flash page "
literal|"at %#x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
return|return
literal|0
return|;
name|unlock
label|:
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_fw_version - read the firmware version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the FW version from flash.  */
end_comment

begin_function
name|int
name|t4_get_fw_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
return|return
name|t4_read_flash
argument_list|(
name|adapter
argument_list|,
name|FLASH_FW_START
operator|+
name|offsetof
argument_list|(
expr|struct
name|fw_hdr
argument_list|,
name|fw_ver
argument_list|)
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_tp_version - read the TP microcode version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the TP microcode version from flash.  */
end_comment

begin_function
name|int
name|t4_get_tp_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
return|return
name|t4_read_flash
argument_list|(
name|adapter
argument_list|,
name|FLASH_FW_START
operator|+
name|offsetof
argument_list|(
expr|struct
name|fw_hdr
argument_list|,
name|tp_microcode_ver
argument_list|)
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_check_fw_version - check if the FW is compatible with this driver  *	@adapter: the adapter  *  *	Checks if an adapter's FW is compatible with the driver.  Returns 0  *	if there's exact match, a negative error if the version could not be  *	read or there's a major version mismatch, and a positive value if the  *	expected major version is found but there's a minor version mismatch.  */
end_comment

begin_function
name|int
name|t4_check_fw_version
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|micro
decl_stmt|;
name|int
name|exp_major
decl_stmt|,
name|exp_minor
decl_stmt|,
name|exp_micro
decl_stmt|;
name|ret
operator|=
name|t4_get_fw_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|t4_get_tp_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp_vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|major
operator|=
name|G_FW_HDR_FW_VER_MAJOR
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
expr_stmt|;
name|minor
operator|=
name|G_FW_HDR_FW_VER_MINOR
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
expr_stmt|;
name|micro
operator|=
name|G_FW_HDR_FW_VER_MICRO
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|fw_vers
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chip_id
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
case|case
name|CHELSIO_T4
case|:
name|exp_major
operator|=
name|T4FW_VERSION_MAJOR
expr_stmt|;
name|exp_minor
operator|=
name|T4FW_VERSION_MINOR
expr_stmt|;
name|exp_micro
operator|=
name|T4FW_VERSION_MICRO
expr_stmt|;
break|break;
case|case
name|CHELSIO_T5
case|:
name|exp_major
operator|=
name|T5FW_VERSION_MAJOR
expr_stmt|;
name|exp_minor
operator|=
name|T5FW_VERSION_MINOR
expr_stmt|;
name|exp_micro
operator|=
name|T5FW_VERSION_MICRO
expr_stmt|;
break|break;
default|default:
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"Unsupported chip type, %x\n"
argument_list|,
name|chip_id
argument_list|(
name|adapter
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|major
operator|!=
name|exp_major
condition|)
block|{
comment|/* major mismatch - fail */
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"card FW has major version %u, driver wants "
literal|"%u\n"
argument_list|,
name|major
argument_list|,
name|exp_major
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|minor
operator|==
name|exp_minor
operator|&&
name|micro
operator|==
name|exp_micro
condition|)
return|return
literal|0
return|;
comment|/* perfect match */
comment|/* Minor/micro version mismatch.  Report it but often it's OK. */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_flash_erase_sectors - erase a range of flash sectors  *	@adapter: the adapter  *	@start: the first sector to erase  *	@end: the last sector to erase  *  *	Erases the sectors in the given inclusive range.  */
end_comment

begin_function
specifier|static
name|int
name|t4_flash_erase_sectors
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SF_ERASE_SECTOR
operator||
operator|(
name|start
operator|<<
literal|8
operator|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|14
argument_list|,
literal|500
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"erase of flash sector %d failed, "
literal|"error %d\n"
argument_list|,
name|start
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
block|}
name|start
operator|++
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_flash_cfg_addr - return the address of the flash configuration file  *	@adapter: the adapter  *  *	Return the address within the flash where the Firmware Configuration  *	File is stored, or an error if the device FLASH is too small to contain  *	a Firmware Configuration File.  */
end_comment

begin_function
name|int
name|t4_flash_cfg_addr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* 	 * If the device FLASH isn't large enough to hold a Firmware 	 * Configuration File, return an error. 	 */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|<
name|FLASH_CFG_START
operator|+
name|FLASH_CFG_MAX_SIZE
condition|)
return|return
operator|-
name|ENOSPC
return|;
return|return
name|FLASH_CFG_START
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_load_cfg - download config file  *	@adap: the adapter  *	@cfg_data: the cfg text file to write  *	@size: text file size  *  *	Write the supplied config text file to the card's serial flash.  */
end_comment

begin_function
name|int
name|t4_load_cfg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u8
modifier|*
name|cfg_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|cfg_addr
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
name|unsigned
name|int
name|flash_cfg_start_sec
decl_stmt|;
name|unsigned
name|int
name|sf_sec_size
init|=
name|adap
operator|->
name|params
operator|.
name|sf_size
operator|/
name|adap
operator|->
name|params
operator|.
name|sf_nsec
decl_stmt|;
name|cfg_addr
operator|=
name|t4_flash_cfg_addr
argument_list|(
name|adap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_addr
operator|<
literal|0
condition|)
return|return
name|cfg_addr
return|;
name|addr
operator|=
name|cfg_addr
expr_stmt|;
name|flash_cfg_start_sec
operator|=
name|addr
operator|/
name|SF_SEC_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|FLASH_CFG_MAX_SIZE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"cfg file too large, max is %u bytes\n"
argument_list|,
name|FLASH_CFG_MAX_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
name|i
operator|=
name|DIV_ROUND_UP
argument_list|(
name|FLASH_CFG_MAX_SIZE
argument_list|,
comment|/* # of sectors spanned */
name|sf_sec_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_flash_erase_sectors
argument_list|(
name|adap
argument_list|,
name|flash_cfg_start_sec
argument_list|,
name|flash_cfg_start_sec
operator|+
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If size == 0 then we're simply erasing the FLASH sectors associated 	 * with the on-adapter Firmware Configuration File. 	 */
if|if
condition|(
name|ret
operator|||
name|size
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* this will write to the flash up to SF_PAGE_SIZE at a time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|SF_PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|size
operator|-
name|i
operator|)
operator|<
name|SF_PAGE_SIZE
condition|)
name|n
operator|=
name|size
operator|-
name|i
expr_stmt|;
else|else
name|n
operator|=
name|SF_PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
name|n
argument_list|,
name|cfg_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|cfg_data
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"config file %s failed %d\n"
argument_list|,
operator|(
name|size
operator|==
literal|0
condition|?
literal|"clear"
else|:
literal|"download"
operator|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_load_fw - download firmware  *	@adap: the adapter  *	@fw_data: the firmware image to write  *	@size: image size  *  *	Write the supplied firmware image to the card's serial flash.  */
end_comment

begin_function
name|int
name|t4_load_fw
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u8
modifier|*
name|fw_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|u32
name|csum
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|addr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|u8
name|first_page
index|[
name|SF_PAGE_SIZE
index|]
decl_stmt|;
specifier|const
name|u32
modifier|*
name|p
init|=
operator|(
specifier|const
name|u32
operator|*
operator|)
name|fw_data
decl_stmt|;
specifier|const
name|struct
name|fw_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
expr|struct
name|fw_hdr
operator|*
operator|)
name|fw_data
decl_stmt|;
name|unsigned
name|int
name|sf_sec_size
init|=
name|adap
operator|->
name|params
operator|.
name|sf_size
operator|/
name|adap
operator|->
name|params
operator|.
name|sf_nsec
decl_stmt|;
name|unsigned
name|int
name|fw_start_sec
decl_stmt|;
name|unsigned
name|int
name|fw_start
decl_stmt|;
name|unsigned
name|int
name|fw_size
decl_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|hdr
operator|->
name|magic
argument_list|)
operator|==
name|FW_HDR_MAGIC_BOOTSTRAP
condition|)
block|{
name|fw_start_sec
operator|=
name|FLASH_FWBOOTSTRAP_START_SEC
expr_stmt|;
name|fw_start
operator|=
name|FLASH_FWBOOTSTRAP_START
expr_stmt|;
name|fw_size
operator|=
name|FLASH_FWBOOTSTRAP_MAX_SIZE
expr_stmt|;
block|}
else|else
block|{
name|fw_start_sec
operator|=
name|FLASH_FW_START_SEC
expr_stmt|;
name|fw_start
operator|=
name|FLASH_FW_START
expr_stmt|;
name|fw_size
operator|=
name|FLASH_FW_MAX_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image has no data\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|size
operator|&
literal|511
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image size not multiple of 512 bytes\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|hdr
operator|->
name|len512
argument_list|)
operator|*
literal|512
operator|!=
name|size
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image size differs from size in FW header\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|size
operator|>
name|fw_size
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image too large, max is %u bytes\n"
argument_list|,
name|fw_size
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
if|if
condition|(
operator|(
name|is_t4
argument_list|(
name|adap
argument_list|)
operator|&&
name|hdr
operator|->
name|chip
operator|!=
name|FW_HDR_CHIP_T4
operator|)
operator|||
operator|(
name|is_t5
argument_list|(
name|adap
argument_list|)
operator|&&
name|hdr
operator|->
name|chip
operator|!=
name|FW_HDR_CHIP_T5
operator|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"FW image (%d) is not suitable for this adapter (%d)\n"
argument_list|,
name|hdr
operator|->
name|chip
argument_list|,
name|chip_id
argument_list|(
name|adap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|csum
argument_list|)
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|ntohl
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
literal|0xffffffff
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"corrupted firmware image, checksum %#x\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|i
operator|=
name|DIV_ROUND_UP
argument_list|(
name|size
argument_list|,
name|sf_sec_size
argument_list|)
expr_stmt|;
comment|/* # of sectors spanned */
name|ret
operator|=
name|t4_flash_erase_sectors
argument_list|(
name|adap
argument_list|,
name|fw_start_sec
argument_list|,
name|fw_start_sec
operator|+
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * We write the correct version at the end so the driver can see a bad 	 * version if the FW write fails.  Start by writing a copy of the 	 * first page with a bad version. 	 */
name|memcpy
argument_list|(
name|first_page
argument_list|,
name|fw_data
argument_list|,
name|SF_PAGE_SIZE
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|fw_hdr
operator|*
operator|)
name|first_page
operator|)
operator|->
name|fw_ver
operator|=
name|htonl
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|fw_start
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
name|first_page
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|=
name|fw_start
expr_stmt|;
for|for
control|(
name|size
operator|-=
name|SF_PAGE_SIZE
init|;
name|size
condition|;
name|size
operator|-=
name|SF_PAGE_SIZE
control|)
block|{
name|addr
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|fw_data
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
name|fw_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|fw_start
operator|+
name|offsetof
argument_list|(
expr|struct
name|fw_hdr
argument_list|,
name|fw_ver
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|fw_ver
argument_list|)
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|&
name|hdr
operator|->
name|fw_ver
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"firmware download failed, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* BIOS boot headers */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pci_expansion_rom_header
block|{
name|u8
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|/* ROM Signature. Should be 0xaa55 */
name|u8
name|reserved
index|[
literal|22
index|]
decl_stmt|;
comment|/* Reserved per processor Architecture data */
name|u8
name|pcir_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to PCI Data Structure */
block|}
name|pci_exp_rom_header_t
typedef|;
end_typedef

begin_comment
comment|/* PCI_EXPANSION_ROM_HEADER */
end_comment

begin_comment
comment|/* Legacy PCI Expansion ROM Header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|legacy_pci_expansion_rom_header
block|{
name|u8
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|/* ROM Signature. Should be 0xaa55 */
name|u8
name|size512
decl_stmt|;
comment|/* Current Image Size in units of 512 bytes */
name|u8
name|initentry_point
index|[
literal|4
index|]
decl_stmt|;
name|u8
name|cksum
decl_stmt|;
comment|/* Checksum computed on the entire Image */
name|u8
name|reserved
index|[
literal|16
index|]
decl_stmt|;
comment|/* Reserved */
name|u8
name|pcir_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to PCI Data Struture */
block|}
name|legacy_pci_exp_rom_header_t
typedef|;
end_typedef

begin_comment
comment|/* LEGACY_PCI_EXPANSION_ROM_HEADER */
end_comment

begin_comment
comment|/* EFI PCI Expansion ROM Header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|efi_pci_expansion_rom_header
block|{
name|u8
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|// ROM signature. The value 0xaa55
name|u8
name|initialization_size
index|[
literal|2
index|]
decl_stmt|;
comment|/* Units 512. Includes this header */
name|u8
name|efi_signature
index|[
literal|4
index|]
decl_stmt|;
comment|/* Signature from EFI image header. 0x0EF1 */
name|u8
name|efi_subsystem
index|[
literal|2
index|]
decl_stmt|;
comment|/* Subsystem value for EFI image header */
name|u8
name|efi_machine_type
index|[
literal|2
index|]
decl_stmt|;
comment|/* Machine type from EFI image header */
name|u8
name|compression_type
index|[
literal|2
index|]
decl_stmt|;
comment|/* Compression type. */
comment|/*  		 * Compression type definition 		 * 0x0: uncompressed 		 * 0x1: Compressed 		 * 0x2-0xFFFF: Reserved 		 */
name|u8
name|reserved
index|[
literal|8
index|]
decl_stmt|;
comment|/* Reserved */
name|u8
name|efi_image_header_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to EFI Image */
name|u8
name|pcir_offset
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset to PCI Data Structure */
block|}
name|efi_pci_exp_rom_header_t
typedef|;
end_typedef

begin_comment
comment|/* EFI PCI Expansion ROM Header */
end_comment

begin_comment
comment|/* PCI Data Structure Format */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pcir_data_structure
block|{
comment|/* PCI Data Structure */
name|u8
name|signature
index|[
literal|4
index|]
decl_stmt|;
comment|/* Signature. The string "PCIR" */
name|u8
name|vendor_id
index|[
literal|2
index|]
decl_stmt|;
comment|/* Vendor Identification */
name|u8
name|device_id
index|[
literal|2
index|]
decl_stmt|;
comment|/* Device Identification */
name|u8
name|vital_product
index|[
literal|2
index|]
decl_stmt|;
comment|/* Pointer to Vital Product Data */
name|u8
name|length
index|[
literal|2
index|]
decl_stmt|;
comment|/* PCIR Data Structure Length */
name|u8
name|revision
decl_stmt|;
comment|/* PCIR Data Structure Revision */
name|u8
name|class_code
index|[
literal|3
index|]
decl_stmt|;
comment|/* Class Code */
name|u8
name|image_length
index|[
literal|2
index|]
decl_stmt|;
comment|/* Image Length. Multiple of 512B */
name|u8
name|code_revision
index|[
literal|2
index|]
decl_stmt|;
comment|/* Revision Level of Code/Data */
name|u8
name|code_type
decl_stmt|;
comment|/* Code Type. */
comment|/* 		 * PCI Expansion ROM Code Types 		 * 0x00: Intel IA-32, PC-AT compatible. Legacy 		 * 0x01: Open Firmware standard for PCI. FCODE 		 * 0x02: Hewlett-Packard PA RISC. HP reserved 		 * 0x03: EFI Image. EFI 		 * 0x04-0xFF: Reserved. 		 */
name|u8
name|indicator
decl_stmt|;
comment|/* Indicator. Identifies the last image in the ROM */
name|u8
name|reserved
index|[
literal|2
index|]
decl_stmt|;
comment|/* Reserved */
block|}
name|pcir_data_t
typedef|;
end_typedef

begin_comment
comment|/* PCI__DATA_STRUCTURE */
end_comment

begin_comment
comment|/* BOOT constants */
end_comment

begin_enum
enum|enum
block|{
name|BOOT_FLASH_BOOT_ADDR
init|=
literal|0x0
block|,
comment|/* start address of boot image in flash */
name|BOOT_SIGNATURE
init|=
literal|0xaa55
block|,
comment|/* signature of BIOS boot ROM */
name|BOOT_SIZE_INC
init|=
literal|512
block|,
comment|/* image size measured in 512B chunks */
name|BOOT_MIN_SIZE
init|=
sizeof|sizeof
argument_list|(
name|pci_exp_rom_header_t
argument_list|)
block|,
comment|/* basic header */
name|BOOT_MAX_SIZE
init|=
literal|1024
operator|*
name|BOOT_SIZE_INC
block|,
comment|/* 1 byte * length increment  */
name|VENDOR_ID
init|=
literal|0x1425
block|,
comment|/* Vendor ID */
name|PCIR_SIGNATURE
init|=
literal|0x52494350
comment|/* PCIR signature */
block|}
enum|;
end_enum

begin_comment
comment|/*  *	modify_device_id - Modifies the device ID of the Boot BIOS image   *	@adatper: the device ID to write.  *	@boot_data: the boot image to modify.  *  *	Write the supplied device ID to the boot BIOS image.  */
end_comment

begin_function
specifier|static
name|void
name|modify_device_id
parameter_list|(
name|int
name|device_id
parameter_list|,
name|u8
modifier|*
name|boot_data
parameter_list|)
block|{
name|legacy_pci_exp_rom_header_t
modifier|*
name|header
decl_stmt|;
name|pcir_data_t
modifier|*
name|pcir_header
decl_stmt|;
name|u32
name|cur_header
init|=
literal|0
decl_stmt|;
comment|/* 	 * Loop through all chained images and change the device ID's 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|header
operator|=
operator|(
name|legacy_pci_exp_rom_header_t
operator|*
operator|)
operator|&
name|boot_data
index|[
name|cur_header
index|]
expr_stmt|;
name|pcir_header
operator|=
operator|(
name|pcir_data_t
operator|*
operator|)
operator|&
name|boot_data
index|[
name|cur_header
operator|+
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|header
operator|->
name|pcir_offset
argument_list|)
index|]
expr_stmt|;
comment|/* 		 * Only modify the Device ID if code type is Legacy or HP. 		 * 0x00: Okay to modify 		 * 0x01: FCODE. Do not be modify 		 * 0x03: Okay to modify 		 * 0x04-0xFF: Do not modify 		 */
if|if
condition|(
name|pcir_header
operator|->
name|code_type
operator|==
literal|0x00
condition|)
block|{
name|u8
name|csum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 			 * Modify Device ID to match current adatper 			 */
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|device_id
operator|=
name|device_id
expr_stmt|;
comment|/* 			 * Set checksum temporarily to 0. 			 * We will recalculate it later. 			 */
name|header
operator|->
name|cksum
operator|=
literal|0x0
expr_stmt|;
comment|/* 			 * Calculate and update checksum 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|header
operator|->
name|size512
operator|*
literal|512
operator|)
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
operator|(
name|u8
operator|)
name|boot_data
index|[
name|cur_header
operator|+
name|i
index|]
expr_stmt|;
comment|/* 			 * Invert summed value to create the checksum 			 * Writing new checksum value directly to the boot data 			 */
name|boot_data
index|[
name|cur_header
operator|+
literal|7
index|]
operator|=
operator|-
name|csum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcir_header
operator|->
name|code_type
operator|==
literal|0x03
condition|)
block|{
comment|/* 			 * Modify Device ID to match current adatper 			 */
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|device_id
operator|=
name|device_id
expr_stmt|;
block|}
comment|/* 		 * Check indicator element to identify if this is the last 		 * image in the ROM. 		 */
if|if
condition|(
name|pcir_header
operator|->
name|indicator
operator|&
literal|0x80
condition|)
break|break;
comment|/* 		 * Move header pointer up to the next image in the ROM. 		 */
name|cur_header
operator|+=
name|header
operator|->
name|size512
operator|*
literal|512
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	t4_load_boot - download boot flash  *	@adapter: the adapter  *	@boot_data: the boot image to write  *	@boot_addr: offset in flash to write boot_data  *	@size: image size  *  *	Write the supplied boot image to the card's serial flash.  *	The boot image has the following sections: a 28-byte header and the  *	boot image.  */
end_comment

begin_function
name|int
name|t4_load_boot
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u8
modifier|*
name|boot_data
parameter_list|,
name|unsigned
name|int
name|boot_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|pci_exp_rom_header_t
modifier|*
name|header
decl_stmt|;
name|int
name|pcir_offset
decl_stmt|;
name|pcir_data_t
modifier|*
name|pcir_header
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|addr
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|boot_sector
init|=
name|boot_addr
operator|*
literal|1024
decl_stmt|;
name|unsigned
name|int
name|sf_sec_size
init|=
name|adap
operator|->
name|params
operator|.
name|sf_size
operator|/
name|adap
operator|->
name|params
operator|.
name|sf_nsec
decl_stmt|;
comment|/* 	 * Make sure the boot image does not encroach on the firmware region 	 */
if|if
condition|(
operator|(
name|boot_sector
operator|+
name|size
operator|)
operator|>>
literal|16
operator|>
name|FLASH_FW_START_SEC
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"boot image encroaching on firmware region\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
comment|/* 	 * Number of sectors spanned 	 */
name|i
operator|=
name|DIV_ROUND_UP
argument_list|(
name|size
condition|?
name|size
else|:
name|FLASH_BOOTCFG_MAX_SIZE
argument_list|,
name|sf_sec_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_flash_erase_sectors
argument_list|(
name|adap
argument_list|,
name|boot_sector
operator|>>
literal|16
argument_list|,
operator|(
name|boot_sector
operator|>>
literal|16
operator|)
operator|+
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If size == 0 then we're simply erasing the FLASH sectors associated 	 * with the on-adapter option ROM file 	 */
if|if
condition|(
name|ret
operator|||
operator|(
name|size
operator|==
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Get boot header */
name|header
operator|=
operator|(
name|pci_exp_rom_header_t
operator|*
operator|)
name|boot_data
expr_stmt|;
name|pcir_offset
operator|=
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|header
operator|->
name|pcir_offset
argument_list|)
expr_stmt|;
comment|/* PCIR Data Structure */
name|pcir_header
operator|=
operator|(
name|pcir_data_t
operator|*
operator|)
operator|&
name|boot_data
index|[
name|pcir_offset
index|]
expr_stmt|;
comment|/* 	 * Perform some primitive sanity testing to avoid accidentally 	 * writing garbage over the boot sectors.  We ought to check for 	 * more but it's not worth it for now ... 	 */
if|if
condition|(
name|size
operator|<
name|BOOT_MIN_SIZE
operator|||
name|size
operator|>
name|BOOT_MAX_SIZE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"boot image too small/large\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
comment|/* 	 * Check BOOT ROM header signature 	 */
if|if
condition|(
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|header
operator|->
name|signature
argument_list|)
operator|!=
name|BOOT_SIGNATURE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Boot image missing signature\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Check PCI header signature 	 */
if|if
condition|(
name|le32_to_cpu
argument_list|(
operator|*
operator|(
name|u32
operator|*
operator|)
name|pcir_header
operator|->
name|signature
argument_list|)
operator|!=
name|PCIR_SIGNATURE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"PCI header missing signature\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Check Vendor ID matches Chelsio ID 	 */
if|if
condition|(
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|vendor_id
argument_list|)
operator|!=
name|VENDOR_ID
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Vendor ID missing signature\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Retrieve adapter's device ID 	 */
name|t4_os_pci_read_cfg2
argument_list|(
name|adap
argument_list|,
name|PCI_DEVICE_ID
argument_list|,
operator|&
name|device_id
argument_list|)
expr_stmt|;
comment|/* Want to deal with PF 0 so I strip off PF 4 indicator */
name|device_id
operator|=
operator|(
name|device_id
operator|&
literal|0xff
operator|)
operator||
literal|0x4000
expr_stmt|;
comment|/* 	 * Check PCIE Device ID 	 */
if|if
condition|(
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|pcir_header
operator|->
name|device_id
argument_list|)
operator|!=
name|device_id
condition|)
block|{
comment|/* 		 * Change the device ID in the Boot BIOS image to match 		 * the Device ID of the current adapter. 		 */
name|modify_device_id
argument_list|(
name|device_id
argument_list|,
name|boot_data
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Skip over the first SF_PAGE_SIZE worth of data and write it after 	 * we finish copying the rest of the boot image. This will ensure 	 * that the BIOS boot header will only be written if the boot image 	 * was written in full. 	 */
name|addr
operator|=
name|boot_sector
expr_stmt|;
for|for
control|(
name|size
operator|-=
name|SF_PAGE_SIZE
init|;
name|size
condition|;
name|size
operator|-=
name|SF_PAGE_SIZE
control|)
block|{
name|addr
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|boot_data
operator|+=
name|SF_PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
name|boot_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|t4_write_flash
argument_list|(
name|adap
argument_list|,
name|boot_sector
argument_list|,
name|SF_PAGE_SIZE
argument_list|,
name|boot_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"boot image download failed, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_cimq_cfg - read CIM queue configuration  *	@adap: the adapter  *	@base: holds the queue base addresses in bytes  *	@size: holds the queue sizes in bytes  *	@thres: holds the queue full thresholds in bytes  *  *	Returns the current configuration of the CIM queues, starting with  *	the IBQs, then the OBQs.  */
end_comment

begin_function
name|void
name|t4_read_cimq_cfg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u16
modifier|*
name|base
parameter_list|,
name|u16
modifier|*
name|size
parameter_list|,
name|u16
modifier|*
name|thres
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|int
name|cim_num_obq
init|=
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|CIM_NUM_OBQ
else|:
name|CIM_NUM_OBQ_T5
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_NUM_IBQ
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_REF
argument_list|,
name|F_IBQSELECT
operator||
name|V_QUENUMSELECT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_CTRL
argument_list|)
expr_stmt|;
operator|*
name|base
operator|++
operator|=
name|G_CIMQBASE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
comment|/* value is in 256-byte units */
operator|*
name|size
operator|++
operator|=
name|G_CIMQSIZE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
comment|/* value is in 256-byte units */
operator|*
name|thres
operator|++
operator|=
name|G_QUEFULLTHRSH
argument_list|(
name|v
argument_list|)
operator|*
literal|8
expr_stmt|;
comment|/* 8-byte unit */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cim_num_obq
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_REF
argument_list|,
name|F_OBQSELECT
operator||
name|V_QUENUMSELECT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_CTRL
argument_list|)
expr_stmt|;
operator|*
name|base
operator|++
operator|=
name|G_CIMQBASE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
comment|/* value is in 256-byte units */
operator|*
name|size
operator|++
operator|=
name|G_CIMQSIZE
argument_list|(
name|v
argument_list|)
operator|*
literal|256
expr_stmt|;
comment|/* value is in 256-byte units */
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_cim_ibq - read the contents of a CIM inbound queue  *	@adap: the adapter  *	@qid: the queue index  *	@data: where to store the queue contents  *	@n: capacity of @data in 32-bit words  *  *	Reads the contents of the selected CIM queue starting at address 0 up  *	to the capacity of @data.  @n must be a multiple of 4.  Returns< 0 on  *	error and the number of 32-bit words actually read on success.  */
end_comment

begin_function
name|int
name|t4_read_cim_ibq
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
specifier|const
name|unsigned
name|int
name|nwords
init|=
name|CIM_IBQ_SIZE
operator|*
literal|4
decl_stmt|;
if|if
condition|(
name|qid
operator|>
literal|5
operator|||
operator|(
name|n
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|addr
operator|=
name|qid
operator|*
name|nwords
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nwords
condition|)
name|n
operator|=
name|nwords
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|addr
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
name|V_IBQDBGADDR
argument_list|(
name|addr
argument_list|)
operator||
name|F_IBQDBGEN
argument_list|)
expr_stmt|;
comment|/* 		 * It might take 3-10ms before the IBQ debug read access is 		 * allowed.  Wait for 1 Sec with a delay of 1 usec. 		 */
name|err
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
name|F_IBQDBGBUSY
argument_list|,
literal|0
argument_list|,
literal|1000000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|*
name|data
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_DATA
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_cim_obq - read the contents of a CIM outbound queue  *	@adap: the adapter  *	@qid: the queue index  *	@data: where to store the queue contents  *	@n: capacity of @data in 32-bit words  *  *	Reads the contents of the selected CIM queue starting at address 0 up  *	to the capacity of @data.  @n must be a multiple of 4.  Returns< 0 on  *	error and the number of 32-bit words actually read on success.  */
end_comment

begin_function
name|int
name|t4_read_cim_obq
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|,
name|v
decl_stmt|,
name|nwords
decl_stmt|;
name|int
name|cim_num_obq
init|=
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|CIM_NUM_OBQ
else|:
name|CIM_NUM_OBQ_T5
decl_stmt|;
if|if
condition|(
name|qid
operator|>=
name|cim_num_obq
operator|||
operator|(
name|n
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_REF
argument_list|,
name|F_OBQSELECT
operator||
name|V_QUENUMSELECT
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_QUEUE_CONFIG_CTRL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|G_CIMQBASE
argument_list|(
name|v
argument_list|)
operator|*
literal|64
expr_stmt|;
comment|/* muliple of 256 -> muliple of 4 */
name|nwords
operator|=
name|G_CIMQSIZE
argument_list|(
name|v
argument_list|)
operator|*
literal|64
expr_stmt|;
comment|/* same */
if|if
condition|(
name|n
operator|>
name|nwords
condition|)
name|n
operator|=
name|nwords
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|addr
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_CFG
argument_list|,
name|V_OBQDBGADDR
argument_list|(
name|addr
argument_list|)
operator||
name|F_OBQDBGEN
argument_list|)
expr_stmt|;
name|err
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_CFG
argument_list|,
name|F_OBQDBGBUSY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|*
name|data
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_DATA
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_OBQ_DBG_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|CIM_QCTL_BASE
init|=
literal|0
block|,
name|CIM_CTL_BASE
init|=
literal|0x2000
block|,
name|CIM_PBT_ADDR_BASE
init|=
literal|0x2800
block|,
name|CIM_PBT_LRF_BASE
init|=
literal|0x3000
block|,
name|CIM_PBT_DATA_BASE
init|=
literal|0x3800
block|}
enum|;
end_enum

begin_comment
comment|/**  *	t4_cim_read - read a block from CIM internal address space  *	@adap: the adapter  *	@addr: the start address within the CIM address space  *	@n: number of words to read  *	@valp: where to store the result  *  *	Reads a block of 4-byte words from the CIM intenal address space.  */
end_comment

begin_function
name|int
name|t4_cim_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|)
operator|&
name|F_HOSTBUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
for|for
control|(
init|;
operator|!
name|ret
operator|&&
name|n
operator|--
condition|;
name|addr
operator|+=
literal|4
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cim_write - write a block into CIM internal address space  *	@adap: the adapter  *	@addr: the start address within the CIM address space  *	@n: number of words to write  *	@valp: set of values to write  *  *	Writes a block of 4-byte words into the CIM intenal address space.  */
end_comment

begin_function
name|int
name|t4_cim_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|)
operator|&
name|F_HOSTBUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
for|for
control|(
init|;
operator|!
name|ret
operator|&&
name|n
operator|--
condition|;
name|addr
operator|+=
literal|4
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|,
operator|*
name|valp
operator|++
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|addr
operator||
name|F_HOSTWRITE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_cim_write1
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
return|return
name|t4_cim_write
argument_list|(
name|adap
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cim_ctl_read - read a block from CIM control region  *	@adap: the adapter  *	@addr: the start address within the CIM control region  *	@n: number of words to read  *	@valp: where to store the result  *  *	Reads a block of 4-byte words from the CIM control region.  */
end_comment

begin_function
name|int
name|t4_cim_ctl_read
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
return|return
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|addr
operator|+
name|CIM_CTL_BASE
argument_list|,
name|n
argument_list|,
name|valp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cim_read_la - read CIM LA capture buffer  *	@adap: the adapter  *	@la_buf: where to store the LA data  *	@wrptr: the HW write pointer within the capture buffer  *  *	Reads the contents of the CIM LA buffer with the most recent entry at  *	the end	of the returned data and with the entry at @wrptr first.  *	We try to leave the LA in the running state we find it in.  */
end_comment

begin_function
name|int
name|t4_cim_read_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|la_buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|wrptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|cfg
decl_stmt|,
name|val
decl_stmt|,
name|idx
decl_stmt|;
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|cfg
operator|&
name|F_UPDBGLAEN
condition|)
block|{
comment|/* LA is running, freeze it */
name|ret
operator|=
name|t4_cim_write1
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|restart
goto|;
name|idx
operator|=
name|G_UPDBGLAWRPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrptr
condition|)
operator|*
name|wrptr
operator|=
name|idx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adap
operator|->
name|params
operator|.
name|cim_la_size
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|t4_cim_write1
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
name|V_UPDBGLARDPTR
argument_list|(
name|idx
argument_list|)
operator||
name|F_UPDBGLARDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
if|if
condition|(
name|val
operator|&
name|F_UPDBGLARDEN
condition|)
block|{
name|ret
operator|=
operator|-
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|t4_cim_read
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_DATA
argument_list|,
literal|1
argument_list|,
operator|&
name|la_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
name|M_UPDBGLARDPTR
expr_stmt|;
block|}
name|restart
label|:
if|if
condition|(
name|cfg
operator|&
name|F_UPDBGLAEN
condition|)
block|{
name|int
name|r
init|=
name|t4_cim_write1
argument_list|(
name|adap
argument_list|,
name|A_UP_UP_DBG_LA_CFG
argument_list|,
name|cfg
operator|&
operator|~
name|F_UPDBGLARDEN
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|t4_cim_read_pif_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|pif_req
parameter_list|,
name|u32
modifier|*
name|pif_rsp
parameter_list|,
name|unsigned
name|int
modifier|*
name|pif_req_wrptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|pif_rsp_wrptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u32
name|cfg
decl_stmt|,
name|val
decl_stmt|,
name|req
decl_stmt|,
name|rsp
decl_stmt|;
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_LADBGEN
condition|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
operator|^
name|F_LADBGEN
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGSTS
argument_list|)
expr_stmt|;
name|req
operator|=
name|G_POLADBGWRPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|rsp
operator|=
name|G_PILADBGWRPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|pif_req_wrptr
condition|)
operator|*
name|pif_req_wrptr
operator|=
name|req
expr_stmt|;
if|if
condition|(
name|pif_rsp_wrptr
condition|)
operator|*
name|pif_rsp_wrptr
operator|=
name|rsp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_PIFLA_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|V_POLADBGRDPTR
argument_list|(
name|req
argument_list|)
operator||
name|V_PILADBGRDPTR
argument_list|(
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pif_req
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PO_LA_DEBUGDATA
argument_list|)
expr_stmt|;
operator|*
name|pif_rsp
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PI_LA_DEBUGDATA
argument_list|)
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|rsp
operator|++
expr_stmt|;
block|}
name|req
operator|=
operator|(
name|req
operator|+
literal|2
operator|)
operator|&
name|M_POLADBGRDPTR
expr_stmt|;
name|rsp
operator|=
operator|(
name|rsp
operator|+
literal|2
operator|)
operator|&
name|M_PILADBGRDPTR
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_cim_read_ma_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|ma_req
parameter_list|,
name|u32
modifier|*
name|ma_rsp
parameter_list|)
block|{
name|u32
name|cfg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|idx
decl_stmt|;
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_LADBGEN
condition|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
operator|^
name|F_LADBGEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CIM_MALA_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
name|idx
operator|=
literal|8
operator|*
name|i
operator|+
name|j
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|V_POLADBGRDPTR
argument_list|(
name|idx
argument_list|)
operator||
name|V_PILADBGRDPTR
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ma_req
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PO_LA_MADEBUGDATA
argument_list|)
expr_stmt|;
operator|*
name|ma_rsp
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_PI_LA_MADEBUGDATA
argument_list|)
expr_stmt|;
block|}
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_DEBUGCFG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_read_la - read TP LA capture buffer  *	@adap: the adapter  *	@la_buf: where to store the LA data  *	@wrptr: the HW write pointer within the capture buffer  *  *	Reads the contents of the TP LA buffer with the most recent entry at  *	the end	of the returned data and with the entry at @wrptr first.  *	We leave the LA in the running state we find it in.  */
end_comment

begin_function
name|void
name|t4_tp_read_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u64
modifier|*
name|la_buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|wrptr
parameter_list|)
block|{
name|bool
name|last_incomplete
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|cfg
decl_stmt|,
name|val
decl_stmt|,
name|idx
decl_stmt|;
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_DBGLAENABLE
condition|)
comment|/* freeze LA */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|,
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|la_mask
operator||
operator|(
name|cfg
operator|^
name|F_DBGLAENABLE
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|)
expr_stmt|;
name|idx
operator|=
name|G_DBGLAWPTR
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|last_incomplete
operator|=
name|G_DBGLAMODE
argument_list|(
name|val
argument_list|)
operator|>=
literal|2
operator|&&
operator|(
name|val
operator|&
name|F_DBGLAWHLF
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|last_incomplete
condition|)
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
name|M_DBGLARPTR
expr_stmt|;
if|if
condition|(
name|wrptr
condition|)
operator|*
name|wrptr
operator|=
name|idx
expr_stmt|;
name|val
operator|&=
literal|0xffff
expr_stmt|;
name|val
operator|&=
operator|~
name|V_DBGLARPTR
argument_list|(
name|M_DBGLARPTR
argument_list|)
expr_stmt|;
name|val
operator||=
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|la_mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TPLA_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|,
name|V_DBGLARPTR
argument_list|(
name|idx
argument_list|)
operator||
name|val
argument_list|)
expr_stmt|;
name|la_buf
index|[
name|i
index|]
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_DATAL
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
name|M_DBGLARPTR
expr_stmt|;
block|}
comment|/* Wipe out last entry if it isn't valid */
if|if
condition|(
name|last_incomplete
condition|)
name|la_buf
index|[
name|TPLA_SIZE
operator|-
literal|1
index|]
operator|=
operator|~
literal|0ULL
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_DBGLAENABLE
condition|)
comment|/* restore running state */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DBG_LA_CONFIG
argument_list|,
name|cfg
operator||
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|la_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_ulprx_read_la
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|la_buf
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|u32
modifier|*
name|p
init|=
name|la_buf
operator|+
name|i
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_CTL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_WRPTR
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_RDPTR
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ULPRX_LA_SIZE
condition|;
name|j
operator|++
operator|,
name|p
operator|+=
literal|8
control|)
operator|*
name|p
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_ULP_RX_LA_RDDATA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ADVERT_MASK
value|(FW_PORT_CAP_SPEED_100M | FW_PORT_CAP_SPEED_1G |\ 		     FW_PORT_CAP_SPEED_10G | FW_PORT_CAP_SPEED_40G | \ 		     FW_PORT_CAP_SPEED_100G | FW_PORT_CAP_ANEG)
end_define

begin_comment
comment|/**  *	t4_link_start - apply link configuration to MAC/PHY  *	@phy: the PHY to setup  *	@mac: the MAC to setup  *	@lc: the requested link configuration  *  *	Set up a port's MAC and PHY according to a desired link configuration.  *	- If the PHY can auto-negotiate first decide what to advertise, then  *	  enable/disable auto-negotiation as desired, and reset.  *	- If the PHY does not auto-negotiate just reset it.  *	- If auto-negotiation is off set the MAC to the proper speed/duplex/FC,  *	  otherwise do it later based on the outcome of auto-negotiation.  */
end_comment

begin_function
name|int
name|t4_link_start
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|struct
name|link_config
modifier|*
name|lc
parameter_list|)
block|{
name|struct
name|fw_port_cmd
name|c
decl_stmt|;
name|unsigned
name|int
name|fc
init|=
literal|0
decl_stmt|,
name|mdi
init|=
name|V_FW_PORT_CAP_MDI
argument_list|(
name|FW_PORT_CAP_MDI_AUTO
argument_list|)
decl_stmt|;
name|lc
operator|->
name|link_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|requested_fc
operator|&
name|PAUSE_RX
condition|)
name|fc
operator||=
name|FW_PORT_CAP_FC_RX
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|requested_fc
operator|&
name|PAUSE_TX
condition|)
name|fc
operator||=
name|FW_PORT_CAP_FC_TX
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_portid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PORT_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_PORT_CMD_PORTID
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|action_to_len16
operator|=
name|htonl
argument_list|(
name|V_FW_PORT_CMD_ACTION
argument_list|(
name|FW_PORT_ACTION_L1_CFG
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lc
operator|->
name|supported
operator|&
name|FW_PORT_CAP_ANEG
operator|)
condition|)
block|{
name|c
operator|.
name|u
operator|.
name|l1cfg
operator|.
name|rcap
operator|=
name|htonl
argument_list|(
operator|(
name|lc
operator|->
name|supported
operator|&
name|ADVERT_MASK
operator|)
operator||
name|fc
argument_list|)
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_RX
operator||
name|PAUSE_TX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lc
operator|->
name|autoneg
operator|==
name|AUTONEG_DISABLE
condition|)
block|{
name|c
operator|.
name|u
operator|.
name|l1cfg
operator|.
name|rcap
operator|=
name|htonl
argument_list|(
name|lc
operator|->
name|requested_speed
operator||
name|fc
operator||
name|mdi
argument_list|)
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_RX
operator||
name|PAUSE_TX
operator|)
expr_stmt|;
block|}
else|else
name|c
operator|.
name|u
operator|.
name|l1cfg
operator|.
name|rcap
operator|=
name|htonl
argument_list|(
name|lc
operator|->
name|advertising
operator||
name|fc
operator||
name|mdi
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_restart_aneg - restart autonegotiation  *	@adap: the adapter  *	@mbox: mbox to use for the FW command  *	@port: the port id  *  *	Restarts autonegotiation for the selected port.  */
end_comment

begin_function
name|int
name|t4_restart_aneg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|)
block|{
name|struct
name|fw_port_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_portid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PORT_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_PORT_CMD_PORTID
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|action_to_len16
operator|=
name|htonl
argument_list|(
name|V_FW_PORT_CMD_ACTION
argument_list|(
name|FW_PORT_ACTION_L1_CFG
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|l1cfg
operator|.
name|rcap
operator|=
name|htonl
argument_list|(
name|FW_PORT_CAP_ANEG
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|intr_info
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/* bits to check in interrupt status */
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* message to print or NULL */
name|short
name|stat_idx
decl_stmt|;
comment|/* stat counter to increment or -1 */
name|unsigned
name|short
name|fatal
decl_stmt|;
comment|/* whether the condition reported is fatal */
block|}
struct|;
end_struct

begin_comment
comment|/**  *	t4_handle_intr_status - table driven interrupt handler  *	@adapter: the adapter that generated the interrupt  *	@reg: the interrupt status register to process  *	@acts: table of interrupt actions  *  *	A table driven interrupt handler that applies a set of masks to an  *	interrupt status word and performs the corresponding actions if the  *	interrupts described by the mask have occured.  The actions include  *	optionally emitting a warning or alert message.  The table is terminated  *	by an entry specifying mask 0.  Returns the number of fatal interrupt  *	conditions.  */
end_comment

begin_function
specifier|static
name|int
name|t4_handle_intr_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
specifier|const
name|struct
name|intr_info
modifier|*
name|acts
parameter_list|)
block|{
name|int
name|fatal
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|acts
operator|->
name|mask
condition|;
operator|++
name|acts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|acts
operator|->
name|mask
operator|)
condition|)
continue|continue;
if|if
condition|(
name|acts
operator|->
name|fatal
condition|)
block|{
name|fatal
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acts
operator|->
name|msg
condition|)
name|CH_WARN_RATELIMIT
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
name|mask
operator||=
name|acts
operator|->
name|mask
expr_stmt|;
block|}
name|status
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|status
condition|)
comment|/* clear processed interrupts */
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|fatal
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for the PCIE module.  */
end_comment

begin_function
specifier|static
name|void
name|pcie_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|sysbus_intr_info
index|[]
init|=
block|{
block|{
name|F_RNPP
block|,
literal|"RXNP array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RPCP
block|,
literal|"RXPC array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCIP
block|,
literal|"RXCIF array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCCP
block|,
literal|"Rx completions control array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RFTP
block|,
literal|"RXFT array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|pcie_port_intr_info
index|[]
init|=
block|{
block|{
name|F_TPCP
block|,
literal|"TXPC array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TNPP
block|,
literal|"TXNP array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TFTP
block|,
literal|"TXFT array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TCAP
block|,
literal|"TXCA array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TCIP
block|,
literal|"TXCIF array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCAP
block|,
literal|"RXCA array parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OTDD
block|,
literal|"outbound request TLP discarded"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RDPE
block|,
literal|"Rx data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TDUE
block|,
literal|"Tx uncorrectable data error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|pcie_intr_info
index|[]
init|=
block|{
block|{
name|F_MSIADDRLPERR
block|,
literal|"MSI AddrL parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIADDRHPERR
block|,
literal|"MSI AddrH parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIDATAPERR
block|,
literal|"MSI data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRLPERR
block|,
literal|"MSI-X AddrL parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRHPERR
block|,
literal|"MSI-X AddrH parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDATAPERR
block|,
literal|"MSI-X data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDIPERR
block|,
literal|"MSI-X DI parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOCPLPERR
block|,
literal|"PCI PIO completion FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOREQPERR
block|,
literal|"PCI PIO request FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TARTAGPERR
block|,
literal|"PCI PCI target tag FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CCNTPERR
block|,
literal|"PCI CMD channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CREQPERR
block|,
literal|"PCI CMD channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CRSPPERR
block|,
literal|"PCI CMD channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DCNTPERR
block|,
literal|"PCI DMA channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DREQPERR
block|,
literal|"PCI DMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DRSPPERR
block|,
literal|"PCI DMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HCNTPERR
block|,
literal|"PCI HMA channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HREQPERR
block|,
literal|"PCI HMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HRSPPERR
block|,
literal|"PCI HMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CFGSNPPERR
block|,
literal|"PCI config snoop FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FIDPERR
block|,
literal|"PCI FID parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_INTXCLRPERR
block|,
literal|"PCI INTx clear parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MATAGPERR
block|,
literal|"PCI MA tag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOTAGPERR
block|,
literal|"PCI PIO tag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RXCPLPERR
block|,
literal|"PCI Rx completion parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RXWRPERR
block|,
literal|"PCI Rx write parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RPLPERR
block|,
literal|"PCI replay buffer parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIESINT
block|,
literal|"PCI core secondary fault"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIEPINT
block|,
literal|"PCI core primary fault"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCPLERR
block|,
literal|"PCI unexpected split completion error"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|t5_pcie_intr_info
index|[]
init|=
block|{
block|{
name|F_MSTGRPPERR
block|,
literal|"Master Response Read Queue parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSTTIMEOUTPERR
block|,
literal|"Master Timeout FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXSTIPERR
block|,
literal|"MSI-X STI SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRLPERR
block|,
literal|"MSI-X AddrL parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXADDRHPERR
block|,
literal|"MSI-X AddrH parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDATAPERR
block|,
literal|"MSI-X data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSIXDIPERR
block|,
literal|"MSI-X DI parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOCPLGRPPERR
block|,
literal|"PCI PIO completion Group FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOREQGRPPERR
block|,
literal|"PCI PIO request Group FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TARTAGPERR
block|,
literal|"PCI PCI target tag FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSTTAGQPERR
block|,
literal|"PCI master tag queue parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CREQPERR
block|,
literal|"PCI CMD channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CRSPPERR
block|,
literal|"PCI CMD channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DREQWRPERR
block|,
literal|"PCI DMA channel write request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DREQPERR
block|,
literal|"PCI DMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DRSPPERR
block|,
literal|"PCI DMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HREQWRPERR
block|,
literal|"PCI HMA channel count parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HREQPERR
block|,
literal|"PCI HMA channel request parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HRSPPERR
block|,
literal|"PCI HMA channel response parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CFGSNPPERR
block|,
literal|"PCI config snoop FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FIDPERR
block|,
literal|"PCI FID parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_VFIDPERR
block|,
literal|"PCI INTx clear parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MAGRPPERR
block|,
literal|"PCI MA group FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOTAGPERR
block|,
literal|"PCI PIO tag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IPRXHDRGRPPERR
block|,
literal|"PCI IP Rx header group parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IPRXDATAGRPPERR
block|,
literal|"PCI IP Rx data group parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RPLPERR
block|,
literal|"PCI IP replay buffer parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IPSOTPERR
block|,
literal|"PCI IP SOT buffer parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TRGT1GRPPERR
block|,
literal|"PCI TRGT1 group FIFOs parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_READRSPERR
block|,
literal|"Outbound read error"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|int
name|fat
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS
argument_list|,
name|sysbus_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS
argument_list|,
name|pcie_port_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_CAUSE
argument_list|,
name|pcie_intr_info
argument_list|)
expr_stmt|;
else|else
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_CAUSE
argument_list|,
name|t5_pcie_intr_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TP interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|tp_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|tp_intr_info
index|[]
init|=
block|{
block|{
literal|0x3fffffff
block|,
literal|"TP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FLMTXFLSTEMPTY
block|,
literal|"TP out of Tx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_TP_INT_CAUSE
argument_list|,
name|tp_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SGE interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|sge_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u64
name|v
decl_stmt|;
name|u32
name|err
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|sge_intr_info
index|[]
init|=
block|{
block|{
name|F_ERR_CPL_EXCEED_IQE_SIZE
block|,
literal|"SGE received CPL exceeding IQE size"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ERR_INVALID_CIDX_INC
block|,
literal|"SGE GTS CIDX increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_CPL_OPCODE_0
block|,
literal|"SGE received 0-length CPL"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_DROPPED_DB
block|,
literal|"SGE doorbell dropped"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_DATA_CPL_ON_HIGH_QID1
operator||
name|F_ERR_DATA_CPL_ON_HIGH_QID0
block|,
literal|"SGE IQID> 1023 received CPL for FL"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX3
block|,
literal|"SGE DBP 3 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX2
block|,
literal|"SGE DBP 2 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX1
block|,
literal|"SGE DBP 1 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_BAD_DB_PIDX0
block|,
literal|"SGE DBP 0 pidx increment too large"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_ING_CTXT_PRIO
block|,
literal|"SGE too many priority ingress contexts"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_ERR_EGR_CTXT_PRIO
block|,
literal|"SGE too many priority egress contexts"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_INGRESS_SIZE_ERR
block|,
literal|"SGE illegal ingress QID"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_EGRESS_SIZE_ERR
block|,
literal|"SGE illegal egress QID"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|v
operator|=
operator|(
name|u64
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE1
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE2
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"SGE parity error (%#llx)\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|v
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE2
argument_list|,
name|v
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|v
operator||=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_CAUSE3
argument_list|,
name|sge_intr_info
argument_list|)
expr_stmt|;
name|err
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_ERROR_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&
name|F_ERROR_QID_VALID
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"SGE error for queue %u\n"
argument_list|,
name|G_ERROR_QID
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&
name|F_UNCAPTURED_ERROR
condition|)
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"SGE UNCAPTURED_ERROR set (clearing)\n"
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_ERROR_STATS
argument_list|,
name|F_ERROR_QID_VALID
operator||
name|F_UNCAPTURED_ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CIM_OBQ_INTR
value|(F_OBQULP0PARERR | F_OBQULP1PARERR | F_OBQULP2PARERR |\ 		      F_OBQULP3PARERR | F_OBQSGEPARERR | F_OBQNCSIPARERR)
end_define

begin_define
define|#
directive|define
name|CIM_IBQ_INTR
value|(F_IBQTP0PARERR | F_IBQTP1PARERR | F_IBQULPPARERR |\ 		      F_IBQSGEHIPARERR | F_IBQSGELOPARERR | F_IBQNCSIPARERR)
end_define

begin_comment
comment|/*  * CIM interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cim_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|cim_intr_info
index|[]
init|=
block|{
block|{
name|F_PREFDROPINT
block|,
literal|"CIM control register prefetch drop"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|CIM_OBQ_INTR
block|,
literal|"CIM OBQ parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|CIM_IBQ_INTR
block|,
literal|"CIM IBQ parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MBUPPARERR
block|,
literal|"CIM mailbox uP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MBHOSTPARERR
block|,
literal|"CIM mailbox host parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIEQINPARERRINT
block|,
literal|"CIM TIEQ outgoing parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIEQOUTPARERRINT
block|,
literal|"CIM TIEQ incoming parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|cim_upintr_info
index|[]
init|=
block|{
block|{
name|F_RSVDSPACEINT
block|,
literal|"CIM reserved space access"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLTRANSINT
block|,
literal|"CIM illegal transaction"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLWRINT
block|,
literal|"CIM illegal write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLRDINT
block|,
literal|"CIM illegal read"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLRDBEINT
block|,
literal|"CIM illegal read BE"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ILLWRBEINT
block|,
literal|"CIM illegal write BE"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDBOOTINT
block|,
literal|"CIM single read from boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRBOOTINT
block|,
literal|"CIM single write to boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRBOOTINT
block|,
literal|"CIM block write to boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDFLASHINT
block|,
literal|"CIM single read from flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRFLASHINT
block|,
literal|"CIM single write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRFLASHINT
block|,
literal|"CIM block write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDEEPROMINT
block|,
literal|"CIM single EEPROM read"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWREEPROMINT
block|,
literal|"CIM single EEPROM write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDEEPROMINT
block|,
literal|"CIM block EEPROM read"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWREEPROMINT
block|,
literal|"CIM block EEPROM write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDCTLINT
block|,
literal|"CIM single read from CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRCTLINT
block|,
literal|"CIM single write to CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDCTLINT
block|,
literal|"CIM block read from CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRCTLINT
block|,
literal|"CIM block write to CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLRDPLINT
block|,
literal|"CIM single read from PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRPLINT
block|,
literal|"CIM single write to PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDPLINT
block|,
literal|"CIM block read from PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRPLINT
block|,
literal|"CIM block write to PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_REQOVRLOOKUPINT
block|,
literal|"CIM request FIFO overwrite"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RSPOVRLOOKUPINT
block|,
literal|"CIM response FIFO overwrite"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIMEOUTINT
block|,
literal|"CIM PIF timeout"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TIMEOUTMAINT
block|,
literal|"CIM PIF MA timeout"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|int
name|fat
decl_stmt|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_FW
argument_list|)
operator|&
name|F_PCIE_FW_ERR
condition|)
name|t4_report_fw_error
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_INT_CAUSE
argument_list|,
name|cim_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_UPACC_INT_CAUSE
argument_list|,
name|cim_upintr_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulprx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|ulprx_intr_info
index|[]
init|=
block|{
block|{
name|F_CAUSE_CTX_1
block|,
literal|"ULPRX channel 1 context error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CAUSE_CTX_0
block|,
literal|"ULPRX channel 0 context error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x7fffff
block|,
literal|"ULPRX parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULP_RX_INT_CAUSE
argument_list|,
name|ulprx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulptx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|ulptx_intr_info
index|[]
init|=
block|{
block|{
name|F_PBL_BOUND_ERR_CH3
block|,
literal|"ULPTX channel 3 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH2
block|,
literal|"ULPTX channel 2 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH1
block|,
literal|"ULPTX channel 1 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH0
block|,
literal|"ULPTX channel 0 PBL out of bounds"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0xfffffff
block|,
literal|"ULPTX parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULP_TX_INT_CAUSE
argument_list|,
name|ulptx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PM TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmtx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pmtx_intr_info
index|[]
init|=
block|{
block|{
name|F_PCMD_LEN_OVFL0
block|,
literal|"PMTX channel 0 pcmd too large"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCMD_LEN_OVFL1
block|,
literal|"PMTX channel 1 pcmd too large"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCMD_LEN_OVFL2
block|,
literal|"PMTX channel 2 pcmd too large"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ZERO_C_CMD_ERROR
block|,
literal|"PMTX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0xffffff0
block|,
literal|"PMTX framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OESPI_PAR_ERROR
block|,
literal|"PMTX oespi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DB_OPTIONS_PAR_ERROR
block|,
literal|"PMTX db_options parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ICSPI_PAR_ERROR
block|,
literal|"PMTX icspi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_C_PCMD_PAR_ERROR
block|,
literal|"PMTX c_pcmd parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM_TX_INT_CAUSE
argument_list|,
name|pmtx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PM RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmrx_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pmrx_intr_info
index|[]
init|=
block|{
block|{
name|F_ZERO_E_CMD_ERROR
block|,
literal|"PMRX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x3ffff0
block|,
literal|"PMRX framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OCSPI_PAR_ERROR
block|,
literal|"PMRX ocspi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DB_OPTIONS_PAR_ERROR
block|,
literal|"PMRX db_options parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IESPI_PAR_ERROR
block|,
literal|"PMRX iespi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_E_PCMD_PAR_ERROR
block|,
literal|"PMRX e_pcmd parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM_RX_INT_CAUSE
argument_list|,
name|pmrx_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CPL switch interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cplsw_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|cplsw_intr_info
index|[]
init|=
block|{
block|{
name|F_CIM_OP_MAP_PERR
block|,
literal|"CPLSW CIM op_map parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CIM_OVFL_ERROR
block|,
literal|"CPLSW CIM overflow"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TP_FRAMING_ERROR
block|,
literal|"CPLSW TP framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGE_FRAMING_ERROR
block|,
literal|"CPLSW SGE framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CIM_FRAMING_ERROR
block|,
literal|"CPLSW CIM framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ZERO_SWITCH_ERROR
block|,
literal|"CPLSW no-switch error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_CAUSE
argument_list|,
name|cplsw_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LE interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|le_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|le_intr_info
index|[]
init|=
block|{
block|{
name|F_LIPMISS
block|,
literal|"LE LIP miss"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_LIP0
block|,
literal|"LE 0 LIP error"
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
name|F_PARITYERR
block|,
literal|"LE parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNKNOWNCMD
block|,
literal|"LE unknown command"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_REQQPARERR
block|,
literal|"LE request queue parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_LE_DB_INT_CAUSE
argument_list|,
name|le_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MPS interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mps_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|mps_rx_intr_info
index|[]
init|=
block|{
block|{
literal|0xffffff
block|,
literal|"MPS Rx parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|mps_tx_intr_info
index|[]
init|=
block|{
block|{
name|V_TPFIFO
argument_list|(
name|M_TPFIFO
argument_list|)
block|,
literal|"MPS Tx TP FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_NCSIFIFO
block|,
literal|"MPS Tx NC-SI FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_TXDATAFIFO
argument_list|(
name|M_TXDATAFIFO
argument_list|)
block|,
literal|"MPS Tx data FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_TXDESCFIFO
argument_list|(
name|M_TXDESCFIFO
argument_list|)
block|,
literal|"MPS Tx desc FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BUBBLE
block|,
literal|"MPS Tx underflow"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SECNTERR
block|,
literal|"MPS Tx SOP/EOP error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FRMERR
block|,
literal|"MPS Tx framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|mps_trc_intr_info
index|[]
init|=
block|{
block|{
name|V_FILTMEM
argument_list|(
name|M_FILTMEM
argument_list|)
block|,
literal|"MPS TRC filter parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_PKTFIFO
argument_list|(
name|M_PKTFIFO
argument_list|)
block|,
literal|"MPS TRC packet FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MISCPERR
block|,
literal|"MPS TRC misc parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|mps_stat_sram_intr_info
index|[]
init|=
block|{
block|{
literal|0x1fffff
block|,
literal|"MPS statistics SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|mps_stat_tx_intr_info
index|[]
init|=
block|{
block|{
literal|0xfffff
block|,
literal|"MPS statistics Tx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|mps_stat_rx_intr_info
index|[]
init|=
block|{
block|{
literal|0xffffff
block|,
literal|"MPS statistics Rx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|mps_cls_intr_info
index|[]
init|=
block|{
block|{
name|F_MATCHSRAM
block|,
literal|"MPS match SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MATCHTCAM
block|,
literal|"MPS match TCAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_HASHSRAM
block|,
literal|"MPS hash SRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|int
name|fat
decl_stmt|;
name|fat
operator|=
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_RX_PERR_INT_CAUSE
argument_list|,
name|mps_rx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_TX_INT_CAUSE
argument_list|,
name|mps_tx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_TRC_INT_CAUSE
argument_list|,
name|mps_trc_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_STAT_PERR_INT_CAUSE_SRAM
argument_list|,
name|mps_stat_sram_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_STAT_PERR_INT_CAUSE_TX_FIFO
argument_list|,
name|mps_stat_tx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_STAT_PERR_INT_CAUSE_RX_FIFO
argument_list|,
name|mps_stat_rx_intr_info
argument_list|)
operator|+
name|t4_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CLS_INT_CAUSE
argument_list|,
name|mps_cls_intr_info
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
name|fat
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MEM_INT_MASK
value|(F_PERR_INT_CAUSE | F_ECC_CE_INT_CAUSE | F_ECC_UE_INT_CAUSE)
end_define

begin_comment
comment|/*  * EDC/MC interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mem_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|name
index|[
literal|3
index|]
index|[
literal|5
index|]
init|=
block|{
literal|"EDC0"
block|,
literal|"EDC1"
block|,
literal|"MC"
block|}
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|,
name|cnt_addr
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|idx
operator|<=
name|MEM_EDC1
condition|)
block|{
name|addr
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_INT_CAUSE
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|cnt_addr
operator|=
name|EDC_REG
argument_list|(
name|A_EDC_ECC_STATUS
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|addr
operator|=
name|A_MC_INT_CAUSE
expr_stmt|;
name|cnt_addr
operator|=
name|A_MC_ECC_STATUS
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|A_MC_P_INT_CAUSE
expr_stmt|;
name|cnt_addr
operator|=
name|A_MC_P_ECC_STATUS
expr_stmt|;
block|}
block|}
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
name|MEM_INT_MASK
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|F_PERR_INT_CAUSE
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s FIFO parity error\n"
argument_list|,
name|name
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|F_ECC_CE_INT_CAUSE
condition|)
block|{
name|u32
name|cnt
init|=
name|G_ECC_CECNT
argument_list|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|cnt_addr
argument_list|)
argument_list|)
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|cnt_addr
argument_list|,
name|V_ECC_CECNT
argument_list|(
name|M_ECC_CECNT
argument_list|)
argument_list|)
expr_stmt|;
name|CH_WARN_RATELIMIT
argument_list|(
name|adapter
argument_list|,
literal|"%u %s correctable ECC data error%s\n"
argument_list|,
name|cnt
argument_list|,
name|name
index|[
name|idx
index|]
argument_list|,
name|cnt
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|F_ECC_UE_INT_CAUSE
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s uncorrectable ECC data error\n"
argument_list|,
name|name
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
operator|(
name|F_PERR_INT_CAUSE
operator||
name|F_ECC_UE_INT_CAUSE
operator|)
condition|)
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MA interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ma_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|v
decl_stmt|,
name|status
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_INT_CAUSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|F_MEM_PERR_INT_CAUSE
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"MA parity error, parity status %#x\n"
argument_list|,
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_PARITY_ERROR_STATUS1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t5
argument_list|(
name|adapter
argument_list|)
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"MA parity error, parity status %#x\n"
argument_list|,
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_PARITY_ERROR_STATUS2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|F_MEM_WRAP_INT_CAUSE
condition|)
block|{
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_INT_WRAP_STATUS
argument_list|)
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"MA address wrap-around error by client %u to"
literal|" address %#x\n"
argument_list|,
name|G_MEM_WRAP_CLIENT_NUM
argument_list|(
name|v
argument_list|)
argument_list|,
name|G_MEM_WRAP_ADDRESS
argument_list|(
name|v
argument_list|)
operator|<<
literal|4
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_INT_CAUSE
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|t4_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SMB interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|smb_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|smb_intr_info
index|[]
init|=
block|{
block|{
name|F_MSTTXFIFOPARINT
block|,
literal|"SMB master Tx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MSTRXFIFOPARINT
block|,
literal|"SMB master Rx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SLVFIFOPARINT
block|,
literal|"SMB slave FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_SMB_INT_CAUSE
argument_list|,
name|smb_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NC-SI interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ncsi_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|ncsi_intr_info
index|[]
init|=
block|{
block|{
name|F_CIM_DM_PRTY_ERR
block|,
literal|"NC-SI CIM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_MPS_DM_PRTY_ERR
block|,
literal|"NC-SI MPS parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TXFIFO_PRTY_ERR
block|,
literal|"NC-SI Tx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RXFIFO_PRTY_ERR
block|,
literal|"NC-SI Rx FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_NCSI_INT_CAUSE
argument_list|,
name|ncsi_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XGMAC interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|xgmac_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|v
decl_stmt|,
name|int_cause_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|int_cause_reg
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_INT_CAUSE
argument_list|)
expr_stmt|;
else|else
name|int_cause_reg
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_INT_CAUSE
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|int_cause_reg
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|(
name|F_TXFIFO_PRTY_ERR
operator||
name|F_RXFIFO_PRTY_ERR
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
return|return;
if|if
condition|(
name|v
operator|&
name|F_TXFIFO_PRTY_ERR
condition|)
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"XGMAC %d Tx FIFO parity error\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|F_RXFIFO_PRTY_ERR
condition|)
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"XGMAC %d Rx FIFO parity error\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|int_cause_reg
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PL interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pl_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pl_intr_info
index|[]
init|=
block|{
block|{
name|F_FATALPERR
block|,
literal|"Fatal parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PERRVFID
block|,
literal|"PL VFID_MAP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|t5_pl_intr_info
index|[]
init|=
block|{
block|{
name|F_PL_BUSPERR
block|,
literal|"PL bus parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FATALPERR
block|,
literal|"Fatal parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t4_handle_intr_status
argument_list|(
name|adap
argument_list|,
name|A_PL_PL_INT_CAUSE
argument_list|,
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|pl_intr_info
else|:
name|t5_pl_intr_info
argument_list|)
condition|)
name|t4_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PF_INTR_MASK
value|(F_PFSW | F_PFCIM)
end_define

begin_define
define|#
directive|define
name|GLBL_INTR_MASK
value|(F_CIM | F_MPS | F_PL | F_PCIE | F_MC | F_EDC0 | \ 		F_EDC1 | F_LE | F_TP | F_MA | F_PM_TX | F_PM_RX | F_ULP_RX | \ 		F_CPL_SWITCH | F_SGE | F_ULP_TX)
end_define

begin_comment
comment|/**  *	t4_slow_intr_handler - control path interrupt handler  *	@adapter: the adapter  *  *	T4 interrupt handler for non-data global interrupt events, e.g., errors.  *	The designation 'slow' is because it involves register reads, while  *	data interrupts typically don't involve any MMIOs.  */
end_comment

begin_function
name|int
name|t4_slow_intr_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|cause
init|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cause
operator|&
name|GLBL_INTR_MASK
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cause
operator|&
name|F_CIM
condition|)
name|cim_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MPS
condition|)
name|mps_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_NCSI
condition|)
name|ncsi_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PL
condition|)
name|pl_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_SMB
condition|)
name|smb_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC0
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC1
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC_KR0
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC_KR1
condition|)
name|xgmac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PCIE
condition|)
name|pcie_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC
condition|)
name|mem_intr_handler
argument_list|(
name|adapter
argument_list|,
name|MEM_MC
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_EDC0
condition|)
name|mem_intr_handler
argument_list|(
name|adapter
argument_list|,
name|MEM_EDC0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_EDC1
condition|)
name|mem_intr_handler
argument_list|(
name|adapter
argument_list|,
name|MEM_EDC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_LE
condition|)
name|le_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_TP
condition|)
name|tp_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MA
condition|)
name|ma_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM_TX
condition|)
name|pmtx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM_RX
condition|)
name|pmrx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP_RX
condition|)
name|ulprx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CPL_SWITCH
condition|)
name|cplsw_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_SGE
condition|)
name|sge_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP_TX
condition|)
name|ulptx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Clear the interrupts just processed for which we are the master. */
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|,
name|cause
operator|&
name|GLBL_INTR_MASK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|)
expr_stmt|;
comment|/* flush */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_intr_enable - enable interrupts  *	@adapter: the adapter whose interrupts should be enabled  *  *	Enable PF-specific interrupts for the calling function and the top-level  *	interrupt concentrator for global interrupts.  Interrupts are already  *	enabled at each module,	here we just enable the roots of the interrupt  *	hierarchies.  *  *	Note: this function should be called only when the driver manages  *	non PF-specific interrupts from the various HW modules.  Only one PCI  *	function at a time should be doing this.  */
end_comment

begin_function
name|void
name|t4_intr_enable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|pf
init|=
name|G_SOURCEPF
argument_list|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_WHOAMI
argument_list|)
argument_list|)
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SGE_INT_ENABLE3
argument_list|,
name|F_ERR_CPL_EXCEED_IQE_SIZE
operator||
name|F_ERR_INVALID_CIDX_INC
operator||
name|F_ERR_CPL_OPCODE_0
operator||
name|F_ERR_DROPPED_DB
operator||
name|F_ERR_DATA_CPL_ON_HIGH_QID1
operator||
name|F_ERR_DATA_CPL_ON_HIGH_QID0
operator||
name|F_ERR_BAD_DB_PIDX3
operator||
name|F_ERR_BAD_DB_PIDX2
operator||
name|F_ERR_BAD_DB_PIDX1
operator||
name|F_ERR_BAD_DB_PIDX0
operator||
name|F_ERR_ING_CTXT_PRIO
operator||
name|F_ERR_EGR_CTXT_PRIO
operator||
name|F_INGRESS_SIZE_ERR
operator||
name|F_EGRESS_SIZE_ERR
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|MYPF_REG
argument_list|(
name|A_PL_PF_INT_ENABLE
argument_list|)
argument_list|,
name|PF_INTR_MASK
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_MAP0
argument_list|,
literal|0
argument_list|,
literal|1
operator|<<
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_intr_disable - disable interrupts  *	@adapter: the adapter whose interrupts should be disabled  *  *	Disable interrupts.  We only disable the top-level interrupt  *	concentrators.  The caller must be a PCI function managing global  *	interrupts.  */
end_comment

begin_function
name|void
name|t4_intr_disable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|pf
init|=
name|G_SOURCEPF
argument_list|(
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_WHOAMI
argument_list|)
argument_list|)
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|MYPF_REG
argument_list|(
name|A_PL_PF_INT_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_MAP0
argument_list|,
literal|1
operator|<<
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_intr_clear - clear all interrupts  *	@adapter: the adapter whose interrupts should be cleared  *  *	Clears all interrupts.  The caller must be a PCI function managing  *	global interrupts.  */
end_comment

begin_function
name|void
name|t4_intr_clear
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|cause_reg
index|[]
init|=
block|{
name|A_SGE_INT_CAUSE1
block|,
name|A_SGE_INT_CAUSE2
block|,
name|A_SGE_INT_CAUSE3
block|,
name|A_PCIE_NONFAT_ERR
block|,
name|A_PCIE_INT_CAUSE
block|,
name|A_MA_INT_WRAP_STATUS
block|,
name|A_MA_PARITY_ERROR_STATUS1
block|,
name|A_MA_INT_CAUSE
block|,
name|A_EDC_INT_CAUSE
block|,
name|EDC_REG
argument_list|(
name|A_EDC_INT_CAUSE
argument_list|,
literal|1
argument_list|)
block|,
name|A_CIM_HOST_INT_CAUSE
block|,
name|A_CIM_HOST_UPACC_INT_CAUSE
block|,
name|MYPF_REG
argument_list|(
name|A_CIM_PF_HOST_INT_CAUSE
argument_list|)
block|,
name|A_TP_INT_CAUSE
block|,
name|A_ULP_RX_INT_CAUSE
block|,
name|A_ULP_TX_INT_CAUSE
block|,
name|A_PM_RX_INT_CAUSE
block|,
name|A_PM_TX_INT_CAUSE
block|,
name|A_MPS_RX_PERR_INT_CAUSE
block|,
name|A_CPL_INTR_CAUSE
block|,
name|MYPF_REG
argument_list|(
name|A_PL_PF_INT_CAUSE
argument_list|)
block|,
name|A_PL_PL_INT_CAUSE
block|,
name|A_LE_DB_INT_CAUSE
block|, 	}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cause_reg
argument_list|)
condition|;
operator|++
name|i
control|)
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|cause_reg
index|[
name|i
index|]
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|?
name|A_MC_INT_CAUSE
else|:
name|A_MC_P_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MA_PARITY_ERROR_STATUS2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|,
name|GLBL_INTR_MASK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	hash_mac_addr - return the hash value of a MAC address  *	@addr: the 48-bit Ethernet MAC address  *  *	Hashes a MAC address according to the hash function used by HW inexact  *	(hash) address matching.  */
end_comment

begin_function
specifier|static
name|int
name|hash_mac_addr
parameter_list|(
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|u32
name|a
init|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|b
init|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
decl_stmt|;
name|a
operator|^=
name|b
expr_stmt|;
name|a
operator|^=
operator|(
name|a
operator|>>
literal|12
operator|)
expr_stmt|;
name|a
operator|^=
operator|(
name|a
operator|>>
literal|6
operator|)
expr_stmt|;
return|return
name|a
operator|&
literal|0x3f
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_config_rss_range - configure a portion of the RSS mapping table  *	@adapter: the adapter  *	@mbox: mbox to use for the FW command  *	@viid: virtual interface whose RSS subtable is to be written  *	@start: start entry in the table to write  *	@n: how many table entries to write  *	@rspq: values for the "response queue" (Ingress Queue) lookup table  *	@nrspq: number of values in @rspq  *  *	Programs the selected part of the VI's RSS mapping table with the  *	provided values.  If @nrspq< @n the supplied values are used repeatedly  *	until the full table range is populated.  *  *	The caller must ensure the values in @rspq are in the range allowed for  *	@viid.  */
end_comment

begin_function
name|int
name|t4_config_rss_range
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|u16
modifier|*
name|rspq
parameter_list|,
name|unsigned
name|int
name|nrspq
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|const
name|u16
modifier|*
name|rsp
init|=
name|rspq
decl_stmt|;
specifier|const
name|u16
modifier|*
name|rsp_end
init|=
name|rspq
operator|+
name|nrspq
decl_stmt|;
name|struct
name|fw_rss_ind_tbl_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RSS_IND_TBL_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_RSS_IND_TBL_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Each firmware RSS command can accommodate up to 32 RSS Ingress 	 * Queue Identifiers.  These Ingress Queue IDs are packed three to 	 * a 32-bit word as 10-bit values with the upper remaining 2 bits 	 * reserved. 	 */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|nq
init|=
name|min
argument_list|(
name|n
argument_list|,
literal|32
argument_list|)
decl_stmt|;
name|int
name|nq_packed
init|=
literal|0
decl_stmt|;
name|__be32
modifier|*
name|qp
init|=
operator|&
name|cmd
operator|.
name|iq0_to_iq2
decl_stmt|;
comment|/* 		 * Set up the firmware RSS command header to send the next 		 * "nq" Ingress Queue IDs to the firmware. 		 */
name|cmd
operator|.
name|niqid
operator|=
name|htons
argument_list|(
name|nq
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|startidx
operator|=
name|htons
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|/* 		 * "nq" more done for the start of the next loop. 		 */
name|start
operator|+=
name|nq
expr_stmt|;
name|n
operator|-=
name|nq
expr_stmt|;
comment|/* 		 * While there are still Ingress Queue IDs to stuff into the 		 * current firmware RSS command, retrieve them from the 		 * Ingress Queue ID array and insert them into the command. 		 */
while|while
condition|(
name|nq
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Grab up to the next 3 Ingress Queue IDs (wrapping 			 * around the Ingress Queue ID array if necessary) and 			 * insert them into the firmware RSS command at the 			 * current 3-tuple position within the commad. 			 */
name|u16
name|qbuf
index|[
literal|3
index|]
decl_stmt|;
name|u16
modifier|*
name|qbp
init|=
name|qbuf
decl_stmt|;
name|int
name|nqbuf
init|=
name|min
argument_list|(
literal|3
argument_list|,
name|nq
argument_list|)
decl_stmt|;
name|nq
operator|-=
name|nqbuf
expr_stmt|;
name|qbuf
index|[
literal|0
index|]
operator|=
name|qbuf
index|[
literal|1
index|]
operator|=
name|qbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nqbuf
operator|&&
name|nq_packed
operator|<
literal|32
condition|)
block|{
name|nqbuf
operator|--
expr_stmt|;
name|nq_packed
operator|++
expr_stmt|;
operator|*
name|qbp
operator|++
operator|=
operator|*
name|rsp
operator|++
expr_stmt|;
if|if
condition|(
name|rsp
operator|>=
name|rsp_end
condition|)
name|rsp
operator|=
name|rspq
expr_stmt|;
block|}
operator|*
name|qp
operator|++
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_RSS_IND_TBL_CMD_IQ0
argument_list|(
name|qbuf
index|[
literal|0
index|]
argument_list|)
operator||
name|V_FW_RSS_IND_TBL_CMD_IQ1
argument_list|(
name|qbuf
index|[
literal|1
index|]
argument_list|)
operator||
name|V_FW_RSS_IND_TBL_CMD_IQ2
argument_list|(
name|qbuf
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Send this portion of the RRS table update to the firmware; 		 * bail out on any errors. 		 */
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_config_glbl_rss - configure the global RSS mode  *	@adapter: the adapter  *	@mbox: mbox to use for the FW command  *	@mode: global RSS mode  *	@flags: mode-specific flags  *  *	Sets the global RSS mode.  */
end_comment

begin_function
name|int
name|t4_config_glbl_rss
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|struct
name|fw_rss_glb_config_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_write
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RSS_GLB_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|FW_RSS_GLB_CONFIG_CMD_MODE_MANUAL
condition|)
block|{
name|c
operator|.
name|u
operator|.
name|manual
operator|.
name|mode_pkd
operator|=
name|htonl
argument_list|(
name|V_FW_RSS_GLB_CONFIG_CMD_MODE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL
condition|)
block|{
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|mode_pkd
operator|=
name|htonl
argument_list|(
name|V_FW_RSS_GLB_CONFIG_CMD_MODE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|synmapen_to_hashtoeplitz
operator|=
name|htonl
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
name|EINVAL
return|;
return|return
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_config_vi_rss - configure per VI RSS settings  *	@adapter: the adapter  *	@mbox: mbox to use for the FW command  *	@viid: the VI id  *	@flags: RSS flags  *	@defq: id of the default RSS queue for the VI.  *  *	Configures VI-specific RSS properties.  */
end_comment

begin_function
name|int
name|t4_config_vi_rss
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|defq
parameter_list|)
block|{
name|struct
name|fw_rss_vi_config_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_RSS_VI_CONFIG_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_RSS_VI_CONFIG_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|basicvirtual
operator|.
name|defaultq_to_udpen
operator|=
name|htonl
argument_list|(
name|flags
operator||
name|V_FW_RSS_VI_CONFIG_CMD_DEFAULTQ
argument_list|(
name|defq
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adapter
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read an RSS table row */
end_comment

begin_function
specifier|static
name|int
name|rd_rss_row
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|row
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
literal|0xfff00000
operator||
name|row
argument_list|)
expr_stmt|;
return|return
name|t4_wait_op_done_val
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
name|F_LKPTBLROWVLD
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss - read the contents of the RSS mapping table  *	@adapter: the adapter  *	@map: holds the contents of the RSS mapping table  *  *	Reads the contents of the RSS hash->queue mapping table.  */
end_comment

begin_function
name|int
name|t4_read_rss
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u16
modifier|*
name|map
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_NENTRIES
operator|/
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
name|rd_rss_row
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
operator|*
name|map
operator|++
operator|=
name|G_LKPTBLQUEUE0
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|map
operator|++
operator|=
name|G_LKPTBLQUEUE1
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_key - read the global RSS key  *	@adap: the adapter  *	@key: 10-entry array holding the 320-bit RSS key  *  *	Reads the global 320-bit RSS key.  */
end_comment

begin_function
name|void
name|t4_read_rss_key
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
modifier|*
name|key
parameter_list|)
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|key
argument_list|,
literal|10
argument_list|,
name|A_TP_RSS_SECRET_KEY0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_key - program one of the RSS keys  *	@adap: the adapter  *	@key: 10-entry array holding the 320-bit RSS key  *	@idx: which RSS key to write  *  *	Writes one of the RSS keys with the given 320-bit value.  If @idx is  *	0..15 the corresponding entry in the RSS key table is written,  *	otherwise the global RSS key is written.  */
end_comment

begin_function
name|void
name|t4_write_rss_key
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|u32
modifier|*
name|key
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|t4_write_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|key
argument_list|,
literal|10
argument_list|,
name|A_TP_RSS_SECRET_KEY0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
literal|16
condition|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|,
name|V_KEYWRADDR
argument_list|(
name|idx
argument_list|)
operator||
name|F_KEYWREN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_pf_config - read PF RSS Configuration Table  *	@adapter: the adapter  *	@index: the entry in the PF RSS table to read  *	@valp: where to store the returned value  *  *	Reads the PF RSS Configuration Table at the specified index and returns  *	the value found there.  */
end_comment

begin_function
name|void
name|t4_read_rss_pf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
name|t4_read_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|valp
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF0_CONFIG
operator|+
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_pf_config - write PF RSS Configuration Table  *	@adapter: the adapter  *	@index: the entry in the VF RSS table to read  *	@val: the value to store  *  *	Writes the PF RSS Configuration Table at the specified index with the  *	specified value.  */
end_comment

begin_function
name|void
name|t4_write_rss_pf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|t4_write_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF0_CONFIG
operator|+
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_vf_config - read VF RSS Configuration Table  *	@adapter: the adapter  *	@index: the entry in the VF RSS table to read  *	@vfl: where to store the returned VFL  *	@vfh: where to store the returned VFH  *  *	Reads the VF RSS Configuration Table at the specified index and returns  *	the (VFL, VFH) values found there.  */
end_comment

begin_function
name|void
name|t4_read_rss_vf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
modifier|*
name|vfl
parameter_list|,
name|u32
modifier|*
name|vfh
parameter_list|)
block|{
name|u32
name|vrt
decl_stmt|;
comment|/* 	 * Request that the index'th VF Table values be read into VFL/VFH. 	 */
name|vrt
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|)
expr_stmt|;
name|vrt
operator|&=
operator|~
operator|(
name|F_VFRDRG
operator||
name|V_VFWRADDR
argument_list|(
name|M_VFWRADDR
argument_list|)
operator||
name|F_VFWREN
operator||
name|F_KEYWREN
operator|)
expr_stmt|;
name|vrt
operator||=
name|V_VFWRADDR
argument_list|(
name|index
argument_list|)
operator||
name|F_VFRDEN
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|,
name|vrt
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the VFL/VFH values ... 	 */
name|t4_read_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|vfl
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFL_CONFIG
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|vfh
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFH_CONFIG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_vf_config - write VF RSS Configuration Table  *	  *	@adapter: the adapter  *	@index: the entry in the VF RSS table to write  *	@vfl: the VFL to store  *	@vfh: the VFH to store  *  *	Writes the VF RSS Configuration Table at the specified index with the  *	specified (VFL, VFH) values.  */
end_comment

begin_function
name|void
name|t4_write_rss_vf_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|vfl
parameter_list|,
name|u32
name|vfh
parameter_list|)
block|{
name|u32
name|vrt
decl_stmt|;
comment|/* 	 * Load up VFL/VFH with the values to be written ... 	 */
name|t4_write_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|vfl
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFL_CONFIG
argument_list|)
expr_stmt|;
name|t4_write_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|vfh
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_VFH_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Write the VFL/VFH into the VF Table at index'th location. 	 */
name|vrt
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|)
expr_stmt|;
name|vrt
operator|&=
operator|~
operator|(
name|F_VFRDRG
operator||
name|F_VFRDEN
operator||
name|V_VFWRADDR
argument_list|(
name|M_VFWRADDR
argument_list|)
operator||
name|F_KEYWREN
operator|)
expr_stmt|;
name|vrt
operator||=
name|V_VFWRADDR
argument_list|(
name|index
argument_list|)
operator||
name|F_VFWREN
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG_VRT
argument_list|,
name|vrt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_pf_map - read PF RSS Map  *	@adapter: the adapter  *  *	Reads the PF RSS Map register and returns its value.  */
end_comment

begin_function
name|u32
name|t4_read_rss_pf_map
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|pfmap
decl_stmt|;
name|t4_read_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|pfmap
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MAP
argument_list|)
expr_stmt|;
return|return
name|pfmap
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_pf_map - write PF RSS Map  *	@adapter: the adapter  *	@pfmap: PF RSS Map value  *  *	Writes the specified value to the PF RSS Map register.  */
end_comment

begin_function
name|void
name|t4_write_rss_pf_map
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|pfmap
parameter_list|)
block|{
name|t4_write_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|pfmap
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_rss_pf_mask - read PF RSS Mask  *	@adapter: the adapter  *  *	Reads the PF RSS Mask register and returns its value.  */
end_comment

begin_function
name|u32
name|t4_read_rss_pf_mask
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|pfmask
decl_stmt|;
name|t4_read_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|pfmask
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MSK
argument_list|)
expr_stmt|;
return|return
name|pfmask
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_write_rss_pf_mask - write PF RSS Mask  *	@adapter: the adapter  *	@pfmask: PF RSS Mask value  *  *	Writes the specified value to the PF RSS Mask register.  */
end_comment

begin_function
name|void
name|t4_write_rss_pf_mask
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|pfmask
parameter_list|)
block|{
name|t4_write_indirect
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|pfmask
argument_list|,
literal|1
argument_list|,
name|A_TP_RSS_PF_MSK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_filter_mode - configure the optional components of filter tuples  *	@adap: the adapter  *	@mode_map: a bitmap selcting which optional filter components to enable  *  *	Sets the filter mode by selecting the optional components to enable  *	in filter tuples.  Returns 0 on success and a negative error if the  *	requested mode needs more bits than are available for optional  *	components.  */
end_comment

begin_function
name|int
name|t4_set_filter_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mode_map
parameter_list|)
block|{
specifier|static
name|u8
name|width
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|17
block|,
literal|8
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nbits
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|S_FCOE
init|;
name|i
operator|<=
name|S_FRAGMENTATION
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mode_map
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|nbits
operator|+=
name|width
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nbits
operator|>
name|FILTER_OPT_LEN
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_write_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|mode_map
argument_list|,
literal|1
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_tcp_stats - read TP's TCP MIB counters  *	@adap: the adapter  *	@v4: holds the TCP/IP counter values  *	@v6: holds the TCP/IPv6 counter values  *  *	Returns the values of TP's TCP/IP and TCP/IPv6 MIB counters.  *	Either @v4 or @v6 may be %NULL to skip the corresponding stats.  */
end_comment

begin_function
name|void
name|t4_tp_get_tcp_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_tcp_stats
modifier|*
name|v4
parameter_list|,
name|struct
name|tp_tcp_stats
modifier|*
name|v6
parameter_list|)
block|{
name|u32
name|val
index|[
name|A_TP_MIB_TCP_RXT_SEG_LO
operator|-
name|A_TP_MIB_TCP_OUT_RST
operator|+
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|STAT_IDX
parameter_list|(
name|x
parameter_list|)
value|((A_TP_MIB_TCP_##x) - A_TP_MIB_TCP_OUT_RST)
define|#
directive|define
name|STAT
parameter_list|(
name|x
parameter_list|)
value|val[STAT_IDX(x)]
define|#
directive|define
name|STAT64
parameter_list|(
name|x
parameter_list|)
value|(((u64)STAT(x##_HI)<< 32) | STAT(x##_LO))
if|if
condition|(
name|v4
condition|)
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|val
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|val
argument_list|)
argument_list|,
name|A_TP_MIB_TCP_OUT_RST
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcpOutRsts
operator|=
name|STAT
argument_list|(
name|OUT_RST
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcpInSegs
operator|=
name|STAT64
argument_list|(
name|IN_SEG
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcpOutSegs
operator|=
name|STAT64
argument_list|(
name|OUT_SEG
argument_list|)
expr_stmt|;
name|v4
operator|->
name|tcpRetransSegs
operator|=
name|STAT64
argument_list|(
name|RXT_SEG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v6
condition|)
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|val
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|val
argument_list|)
argument_list|,
name|A_TP_MIB_TCP_V6OUT_RST
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcpOutRsts
operator|=
name|STAT
argument_list|(
name|OUT_RST
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcpInSegs
operator|=
name|STAT64
argument_list|(
name|IN_SEG
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcpOutSegs
operator|=
name|STAT64
argument_list|(
name|OUT_SEG
argument_list|)
expr_stmt|;
name|v6
operator|->
name|tcpRetransSegs
operator|=
name|STAT64
argument_list|(
name|RXT_SEG
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|STAT64
undef|#
directive|undef
name|STAT
undef|#
directive|undef
name|STAT_IDX
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_err_stats - read TP's error MIB counters  *	@adap: the adapter  *	@st: holds the counter values  *  *	Returns the values of TP's error counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_err_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_err_stats
modifier|*
name|st
parameter_list|)
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|st
operator|->
name|macInErrs
argument_list|,
literal|12
argument_list|,
name|A_TP_MIB_MAC_IN_ERR_0
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|st
operator|->
name|tnlCongDrops
argument_list|,
literal|8
argument_list|,
name|A_TP_MIB_TNL_CNG_DROP_0
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|st
operator|->
name|tnlTxDrops
argument_list|,
literal|4
argument_list|,
name|A_TP_MIB_TNL_DROP_0
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|st
operator|->
name|ofldVlanDrops
argument_list|,
literal|4
argument_list|,
name|A_TP_MIB_OFD_VLN_DROP_0
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|st
operator|->
name|tcp6InErrs
argument_list|,
literal|4
argument_list|,
name|A_TP_MIB_TCP_V6IN_ERR_0
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
operator|&
name|st
operator|->
name|ofldNoNeigh
argument_list|,
literal|2
argument_list|,
name|A_TP_MIB_OFD_ARP_DROP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_proxy_stats - read TP's proxy MIB counters  *	@adap: the adapter  *	@st: holds the counter values  *  *	Returns the values of TP's proxy counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_proxy_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_proxy_stats
modifier|*
name|st
parameter_list|)
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|st
operator|->
name|proxy
argument_list|,
literal|4
argument_list|,
name|A_TP_MIB_TNL_LPBK_0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_cpl_stats - read TP's CPL MIB counters  *	@adap: the adapter  *	@st: holds the counter values  *  *	Returns the values of TP's CPL counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_cpl_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_cpl_stats
modifier|*
name|st
parameter_list|)
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|st
operator|->
name|req
argument_list|,
literal|8
argument_list|,
name|A_TP_MIB_CPL_IN_REQ_0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_tp_get_rdma_stats - read TP's RDMA MIB counters  *	@adap: the adapter  *	@st: holds the counter values  *  *	Returns the values of TP's RDMA counters.  */
end_comment

begin_function
name|void
name|t4_tp_get_rdma_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_rdma_stats
modifier|*
name|st
parameter_list|)
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
operator|&
name|st
operator|->
name|rqe_dfr_mod
argument_list|,
literal|2
argument_list|,
name|A_TP_MIB_RQE_DFR_MOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_fcoe_stats - read TP's FCoE MIB counters for a port  *	@adap: the adapter  *	@idx: the port index  *	@st: holds the counter values  *  *	Returns the values of TP's FCoE counters for the selected port.  */
end_comment

begin_function
name|void
name|t4_get_fcoe_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|struct
name|tp_fcoe_stats
modifier|*
name|st
parameter_list|)
block|{
name|u32
name|val
index|[
literal|2
index|]
decl_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
operator|&
name|st
operator|->
name|framesDDP
argument_list|,
literal|1
argument_list|,
name|A_TP_MIB_FCOE_DDP_0
operator|+
name|idx
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
operator|&
name|st
operator|->
name|framesDrop
argument_list|,
literal|1
argument_list|,
name|A_TP_MIB_FCOE_DROP_0
operator|+
name|idx
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|val
argument_list|,
literal|2
argument_list|,
name|A_TP_MIB_FCOE_BYTE_0_HI
operator|+
literal|2
operator|*
name|idx
argument_list|)
expr_stmt|;
name|st
operator|->
name|octetsDDP
operator|=
operator|(
operator|(
name|u64
operator|)
name|val
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator||
name|val
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_usm_stats - read TP's non-TCP DDP MIB counters  *	@adap: the adapter  *	@st: holds the counter values  *  *	Returns the values of TP's counters for non-TCP directly-placed packets.  */
end_comment

begin_function
name|void
name|t4_get_usm_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_usm_stats
modifier|*
name|st
parameter_list|)
block|{
name|u32
name|val
index|[
literal|4
index|]
decl_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_DATA
argument_list|,
name|val
argument_list|,
literal|4
argument_list|,
name|A_TP_MIB_USM_PKTS
argument_list|)
expr_stmt|;
name|st
operator|->
name|frames
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|->
name|drops
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
name|st
operator|->
name|octets
operator|=
operator|(
operator|(
name|u64
operator|)
name|val
index|[
literal|2
index|]
operator|<<
literal|32
operator|)
operator||
name|val
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_read_mtu_tbl - returns the values in the HW path MTU table  *	@adap: the adapter  *	@mtus: where to store the MTU values  *	@mtu_log: where to store the MTU base-2 log (may be %NULL)  *  *	Reads the HW path MTU table.  */
end_comment

begin_function
name|void
name|t4_read_mtu_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u16
modifier|*
name|mtus
parameter_list|,
name|u8
modifier|*
name|mtu_log
parameter_list|)
block|{
name|u32
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
name|V_MTUINDEX
argument_list|(
literal|0xff
argument_list|)
operator||
name|V_MTUVALUE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|)
expr_stmt|;
name|mtus
index|[
name|i
index|]
operator|=
name|G_MTUVALUE
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu_log
condition|)
name|mtu_log
index|[
name|i
index|]
operator|=
name|G_MTUWIDTH
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_cong_tbl - reads the congestion control table  *	@adap: the adapter  *	@incr: where to store the alpha values  *  *	Reads the additive increments programmed into the HW congestion  *	control table.  */
end_comment

begin_function
name|void
name|t4_read_cong_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u16
name|incr
index|[
name|NMTUS
index|]
index|[
name|NCCTRL_WIN
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|mtu
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|mtu
operator|=
literal|0
init|;
name|mtu
operator|<
name|NMTUS
condition|;
operator|++
name|mtu
control|)
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
name|V_ROWINDEX
argument_list|(
literal|0xffff
argument_list|)
operator||
operator|(
name|mtu
operator|<<
literal|5
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
name|incr
index|[
name|mtu
index|]
index|[
name|w
index|]
operator|=
operator|(
name|u16
operator|)
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|)
operator|&
literal|0x1fff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_read_pace_tbl - read the pace table  *	@adap: the adapter  *	@pace_vals: holds the returned values  *  *	Returns the values of TP's pace table in microseconds.  */
end_comment

begin_function
name|void
name|t4_read_pace_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|pace_vals
index|[
name|NTX_SCHED
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTX_SCHED
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
literal|0xffff0000
operator|+
name|i
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|)
expr_stmt|;
name|pace_vals
index|[
name|i
index|]
operator|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_tp_wr_bits_indirect - set/clear bits in an indirect TP register  *	@adap: the adapter  *	@addr: the indirect TP register address  *	@mask: specifies the field within the register to modify  *	@val: new value for the field  *  *	Sets a field of an indirect TP register to the given value.  */
end_comment

begin_function
name|void
name|t4_tp_wr_bits_indirect
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator||=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	init_cong_ctrl - initialize congestion control parameters  *	@a: the alpha values for congestion control  *	@b: the beta values for congestion control  *  *	Initialize the congestion control parameters.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|init_cong_ctrl
parameter_list|(
name|unsigned
name|short
modifier|*
name|a
parameter_list|,
name|unsigned
name|short
modifier|*
name|b
parameter_list|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|2
index|]
operator|=
name|a
index|[
literal|3
index|]
operator|=
name|a
index|[
literal|4
index|]
operator|=
name|a
index|[
literal|5
index|]
operator|=
name|a
index|[
literal|6
index|]
operator|=
name|a
index|[
literal|7
index|]
operator|=
name|a
index|[
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|a
index|[
literal|9
index|]
operator|=
literal|2
expr_stmt|;
name|a
index|[
literal|10
index|]
operator|=
literal|3
expr_stmt|;
name|a
index|[
literal|11
index|]
operator|=
literal|4
expr_stmt|;
name|a
index|[
literal|12
index|]
operator|=
literal|5
expr_stmt|;
name|a
index|[
literal|13
index|]
operator|=
literal|6
expr_stmt|;
name|a
index|[
literal|14
index|]
operator|=
literal|7
expr_stmt|;
name|a
index|[
literal|15
index|]
operator|=
literal|8
expr_stmt|;
name|a
index|[
literal|16
index|]
operator|=
literal|9
expr_stmt|;
name|a
index|[
literal|17
index|]
operator|=
literal|10
expr_stmt|;
name|a
index|[
literal|18
index|]
operator|=
literal|14
expr_stmt|;
name|a
index|[
literal|19
index|]
operator|=
literal|17
expr_stmt|;
name|a
index|[
literal|20
index|]
operator|=
literal|21
expr_stmt|;
name|a
index|[
literal|21
index|]
operator|=
literal|25
expr_stmt|;
name|a
index|[
literal|22
index|]
operator|=
literal|30
expr_stmt|;
name|a
index|[
literal|23
index|]
operator|=
literal|35
expr_stmt|;
name|a
index|[
literal|24
index|]
operator|=
literal|45
expr_stmt|;
name|a
index|[
literal|25
index|]
operator|=
literal|60
expr_stmt|;
name|a
index|[
literal|26
index|]
operator|=
literal|80
expr_stmt|;
name|a
index|[
literal|27
index|]
operator|=
literal|100
expr_stmt|;
name|a
index|[
literal|28
index|]
operator|=
literal|200
expr_stmt|;
name|a
index|[
literal|29
index|]
operator|=
literal|300
expr_stmt|;
name|a
index|[
literal|30
index|]
operator|=
literal|400
expr_stmt|;
name|a
index|[
literal|31
index|]
operator|=
literal|500
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|2
index|]
operator|=
name|b
index|[
literal|3
index|]
operator|=
name|b
index|[
literal|4
index|]
operator|=
name|b
index|[
literal|5
index|]
operator|=
name|b
index|[
literal|6
index|]
operator|=
name|b
index|[
literal|7
index|]
operator|=
name|b
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|b
index|[
literal|9
index|]
operator|=
name|b
index|[
literal|10
index|]
operator|=
literal|1
expr_stmt|;
name|b
index|[
literal|11
index|]
operator|=
name|b
index|[
literal|12
index|]
operator|=
literal|2
expr_stmt|;
name|b
index|[
literal|13
index|]
operator|=
name|b
index|[
literal|14
index|]
operator|=
name|b
index|[
literal|15
index|]
operator|=
name|b
index|[
literal|16
index|]
operator|=
literal|3
expr_stmt|;
name|b
index|[
literal|17
index|]
operator|=
name|b
index|[
literal|18
index|]
operator|=
name|b
index|[
literal|19
index|]
operator|=
name|b
index|[
literal|20
index|]
operator|=
name|b
index|[
literal|21
index|]
operator|=
literal|4
expr_stmt|;
name|b
index|[
literal|22
index|]
operator|=
name|b
index|[
literal|23
index|]
operator|=
name|b
index|[
literal|24
index|]
operator|=
name|b
index|[
literal|25
index|]
operator|=
name|b
index|[
literal|26
index|]
operator|=
name|b
index|[
literal|27
index|]
operator|=
literal|5
expr_stmt|;
name|b
index|[
literal|28
index|]
operator|=
name|b
index|[
literal|29
index|]
operator|=
literal|6
expr_stmt|;
name|b
index|[
literal|30
index|]
operator|=
name|b
index|[
literal|31
index|]
operator|=
literal|7
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The minimum additive increment value for the congestion control table */
end_comment

begin_define
define|#
directive|define
name|CC_MIN_INCR
value|2U
end_define

begin_comment
comment|/**  *	t4_load_mtus - write the MTU and congestion control HW tables  *	@adap: the adapter  *	@mtus: the values for the MTU table  *	@alpha: the values for the congestion control alpha parameter  *	@beta: the values for the congestion control beta parameter  *  *	Write the HW MTU table with the supplied MTUs and the high-speed  *	congestion control table with the supplied alpha, beta, and MTUs.  *	We write the two tables together because the additive increments  *	depend on the MTUs.  */
end_comment

begin_function
name|void
name|t4_load_mtus
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|mtus
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|alpha
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|beta
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|avg_pkts
index|[
name|NCCTRL_WIN
index|]
init|=
block|{
literal|2
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|20
block|,
literal|28
block|,
literal|40
block|,
literal|56
block|,
literal|80
block|,
literal|112
block|,
literal|160
block|,
literal|224
block|,
literal|320
block|,
literal|448
block|,
literal|640
block|,
literal|896
block|,
literal|1281
block|,
literal|1792
block|,
literal|2560
block|,
literal|3584
block|,
literal|5120
block|,
literal|7168
block|,
literal|10240
block|,
literal|14336
block|,
literal|20480
block|,
literal|28672
block|,
literal|40960
block|,
literal|57344
block|,
literal|81920
block|,
literal|114688
block|,
literal|163840
block|,
literal|229376
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|mtu
init|=
name|mtus
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|log2
init|=
name|fls
argument_list|(
name|mtu
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtu
operator|&
operator|(
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|>>
literal|2
operator|)
operator|)
condition|)
comment|/* round */
name|log2
operator|--
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
name|V_MTUINDEX
argument_list|(
name|i
argument_list|)
operator||
name|V_MTUWIDTH
argument_list|(
name|log2
argument_list|)
operator||
name|V_MTUVALUE
argument_list|(
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|unsigned
name|int
name|inc
decl_stmt|;
name|inc
operator|=
name|max
argument_list|(
operator|(
operator|(
name|mtu
operator|-
literal|40
operator|)
operator|*
name|alpha
index|[
name|w
index|]
operator|)
operator|/
name|avg_pkts
index|[
name|w
index|]
argument_list|,
name|CC_MIN_INCR
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|21
operator|)
operator||
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
operator|(
name|beta
index|[
name|w
index|]
operator|<<
literal|13
operator|)
operator||
name|inc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_set_pace_tbl - set the pace table  *	@adap: the adapter  *	@pace_vals: the pace values in microseconds  *	@start: index of the first entry in the HW pace table to set  *	@n: how many entries to set  *  *	Sets (a subset of the) HW pace table.  */
end_comment

begin_function
name|int
name|t4_set_pace_tbl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|*
name|pace_vals
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|vals
index|[
name|NTX_SCHED
index|]
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|tick_ns
init|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|NTX_SCHED
condition|)
return|return
operator|-
name|ERANGE
return|;
comment|/* convert values from us to dack ticks, rounding to closest value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|pace_vals
operator|++
control|)
block|{
name|vals
index|[
name|i
index|]
operator|=
operator|(
literal|1000
operator|*
operator|*
name|pace_vals
operator|+
name|tick_ns
operator|/
literal|2
operator|)
operator|/
name|tick_ns
expr_stmt|;
if|if
condition|(
name|vals
index|[
name|i
index|]
operator|>
literal|0x7ff
condition|)
return|return
operator|-
name|ERANGE
return|;
if|if
condition|(
operator|*
name|pace_vals
operator|&&
name|vals
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|-
name|ERANGE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|start
operator|++
control|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
operator|(
name|start
operator|<<
literal|16
operator|)
operator||
name|vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_sched_bps - set the bit rate for a HW traffic scheduler  *	@adap: the adapter  *	@kbps: target rate in Kbps  *	@sched: the scheduler index  *  *	Configure a Tx HW scheduler for the target rate.  */
end_comment

begin_function
name|int
name|t4_set_sched_bps
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|unsigned
name|int
name|kbps
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|tps
decl_stmt|,
name|cpt
decl_stmt|,
name|bpt
decl_stmt|,
name|delta
decl_stmt|,
name|mindelta
init|=
operator|~
literal|0
decl_stmt|;
name|unsigned
name|int
name|clk
init|=
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
decl_stmt|;
name|unsigned
name|int
name|selected_cpt
init|=
literal|0
decl_stmt|,
name|selected_bpt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kbps
operator|>
literal|0
condition|)
block|{
name|kbps
operator|*=
literal|125
expr_stmt|;
comment|/* -> bytes */
for|for
control|(
name|cpt
operator|=
literal|1
init|;
name|cpt
operator|<=
literal|255
condition|;
name|cpt
operator|++
control|)
block|{
name|tps
operator|=
name|clk
operator|/
name|cpt
expr_stmt|;
name|bpt
operator|=
operator|(
name|kbps
operator|+
name|tps
operator|/
literal|2
operator|)
operator|/
name|tps
expr_stmt|;
if|if
condition|(
name|bpt
operator|>
literal|0
operator|&&
name|bpt
operator|<=
literal|255
condition|)
block|{
name|v
operator|=
name|bpt
operator|*
name|tps
expr_stmt|;
name|delta
operator|=
name|v
operator|>=
name|kbps
condition|?
name|v
operator|-
name|kbps
else|:
name|kbps
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|delta
operator|<
name|mindelta
condition|)
block|{
name|mindelta
operator|=
name|delta
expr_stmt|;
name|selected_cpt
operator|=
name|cpt
expr_stmt|;
name|selected_bpt
operator|=
name|bpt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|selected_cpt
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|selected_cpt
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|selected_cpt
operator|<<
literal|16
operator|)
operator||
operator|(
name|selected_bpt
operator|<<
literal|24
operator|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff0000
operator|)
operator||
name|selected_cpt
operator||
operator|(
name|selected_bpt
operator|<<
literal|8
operator|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_sched_ipg - set the IPG for a Tx HW packet rate scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Set the interpacket delay for a HW packet rate scheduler.  */
end_comment

begin_function
name|int
name|t4_set_sched_ipg
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|unsigned
name|int
name|ipg
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
init|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
decl_stmt|;
comment|/* convert ipg to nearest number of core clocks */
name|ipg
operator|*=
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|ipg
operator|=
operator|(
name|ipg
operator|+
literal|5000
operator|)
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|ipg
operator|>
name|M_TXTIMERSEPQ0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
name|V_TXTIMERSEPQ0
argument_list|(
name|M_TXTIMERSEPQ0
argument_list|)
operator|)
operator||
name|V_TXTIMERSEPQ1
argument_list|(
name|ipg
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
name|V_TXTIMERSEPQ1
argument_list|(
name|M_TXTIMERSEPQ1
argument_list|)
operator|)
operator||
name|V_TXTIMERSEPQ0
argument_list|(
name|ipg
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_tx_sched - get the configuration of a Tx HW traffic scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@kbps: the byte rate in Kbps  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Return the current configuration of a HW Tx scheduler.  */
end_comment

begin_function
name|void
name|t4_get_tx_sched
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|sched
parameter_list|,
name|unsigned
name|int
modifier|*
name|kbps
parameter_list|,
name|unsigned
name|int
modifier|*
name|ipg
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
decl_stmt|,
name|bpt
decl_stmt|,
name|cpt
decl_stmt|;
if|if
condition|(
name|kbps
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|bpt
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cpt
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|cpt
condition|)
operator|*
name|kbps
operator|=
literal|0
expr_stmt|;
comment|/* scheduler disabled */
else|else
block|{
name|v
operator|=
operator|(
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
operator|)
operator|/
name|cpt
expr_stmt|;
comment|/* ticks/s */
operator|*
name|kbps
operator|=
operator|(
name|v
operator|*
name|bpt
operator|)
operator|/
literal|125
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ipg
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|v
operator|&=
literal|0xffff
expr_stmt|;
operator|*
name|ipg
operator|=
operator|(
literal|10000
operator|*
name|v
operator|)
operator|/
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Calculates a rate in bytes/s given the number of 256-byte units per 4K core  * clocks.  The formula is  *  * bytes/s = bytes256 * 256 * ClkFreq / 4096  *  * which is equivalent to  *  * bytes/s = 62.5 * bytes256 * ClkFreq_ms  */
end_comment

begin_function
specifier|static
name|u64
name|chan_rate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|bytes256
parameter_list|)
block|{
name|u64
name|v
init|=
name|bytes256
operator|*
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
decl_stmt|;
return|return
name|v
operator|*
literal|62
operator|+
name|v
operator|/
literal|2
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_chan_txrate - get the current per channel Tx rates  *	@adap: the adapter  *	@nic_rate: rates for NIC traffic  *	@ofld_rate: rates for offloaded traffic  *  *	Return the current Tx rates in bytes/s for NIC and offloaded traffic  *	for each channel.  */
end_comment

begin_function
name|void
name|t4_get_chan_txrate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u64
modifier|*
name|nic_rate
parameter_list|,
name|u64
modifier|*
name|ofld_rate
parameter_list|)
block|{
name|u32
name|v
decl_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_TRATE
argument_list|)
expr_stmt|;
name|nic_rate
index|[
literal|0
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE0
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|nic_rate
index|[
literal|1
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE1
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|nic_rate
index|[
literal|2
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE2
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|nic_rate
index|[
literal|3
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_TNLRATE3
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_ORATE
argument_list|)
expr_stmt|;
name|ofld_rate
index|[
literal|0
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE0
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|ofld_rate
index|[
literal|1
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE1
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|ofld_rate
index|[
literal|2
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE2
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|ofld_rate
index|[
literal|3
index|]
operator|=
name|chan_rate
argument_list|(
name|adap
argument_list|,
name|G_OFDRATE3
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_trace_filter - configure one of the tracing filters  *	@adap: the adapter  *	@tp: the desired trace filter parameters  *	@idx: which filter to configure  *	@enable: whether to enable or disable the filter  *  *	Configures one of the tracing filters available in HW.  If @tp is %NULL  *	it indicates that the filter is already written in the register and it  *	just needs to be enabled or disabled.  */
end_comment

begin_function
name|int
name|t4_set_trace_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|trace_params
modifier|*
name|tp
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ofst
init|=
name|idx
operator|*
literal|4
decl_stmt|;
name|u32
name|data_reg
decl_stmt|,
name|mask_reg
decl_stmt|,
name|cfg
decl_stmt|;
name|u32
name|multitrc
init|=
name|F_TRCMULTIFILTER
decl_stmt|;
name|u32
name|en
init|=
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|F_TFEN
else|:
name|F_T5_TFEN
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|NTRACE
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|tp
operator|==
name|NULL
operator|||
operator|!
name|enable
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|,
name|en
argument_list|,
name|enable
condition|?
name|en
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * TODO - After T4 data book is updated, specify the exact 	 * section below. 	 * 	 * See T4 data book - MPS section for a complete description  	 * of the below if..else handling of A_MPS_TRC_CFG register  	 * value. 	 */
name|cfg
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_TRCMULTIFILTER
condition|)
block|{
comment|/* 		 * If multiple tracers are enabled, then maximum 		 * capture size is 2.5KB (FIFO size of a single channel) 		 * minus 2 flits for CPL_TRACE_PKT header. 		 */
if|if
condition|(
name|tp
operator|->
name|snap_len
operator|>
operator|(
operator|(
literal|10
operator|*
literal|1024
operator|/
literal|4
operator|)
operator|-
operator|(
literal|2
operator|*
literal|8
operator|)
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
block|{
comment|/* 		 * If multiple tracers are disabled, to avoid deadlocks  		 * maximum packet capture size of 9600 bytes is recommended. 		 * Also in this mode, only trace0 can be enabled and running. 		 */
name|multitrc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snap_len
operator|>
literal|9600
operator|||
name|idx
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|port
operator|>
operator|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
literal|11
else|:
literal|19
operator|)
operator|||
name|tp
operator|->
name|invert
operator|>
literal|1
operator|||
name|tp
operator|->
name|skip_len
operator|>
name|M_TFLENGTH
operator|||
name|tp
operator|->
name|skip_ofst
operator|>
name|M_TFOFFSET
operator|||
name|tp
operator|->
name|min_len
operator|>
name|M_TFMINPKTSIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* stop the tracer we'll be changing */
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|,
name|en
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|idx
operator|*=
operator|(
name|A_MPS_TRC_FILTER1_MATCH
operator|-
name|A_MPS_TRC_FILTER0_MATCH
operator|)
expr_stmt|;
name|data_reg
operator|=
name|A_MPS_TRC_FILTER0_MATCH
operator|+
name|idx
expr_stmt|;
name|mask_reg
operator|=
name|A_MPS_TRC_FILTER0_DONT_CARE
operator|+
name|idx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRACE_LEN
operator|/
literal|4
condition|;
name|i
operator|++
operator|,
name|data_reg
operator|+=
literal|4
operator|,
name|mask_reg
operator|+=
literal|4
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|,
name|tp
operator|->
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mask_reg
argument_list|,
operator|~
name|tp
operator|->
name|mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_B
operator|+
name|ofst
argument_list|,
name|V_TFCAPTUREMAX
argument_list|(
name|tp
operator|->
name|snap_len
argument_list|)
operator||
name|V_TFMINPKTSIZE
argument_list|(
name|tp
operator|->
name|min_len
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|,
name|V_TFOFFSET
argument_list|(
name|tp
operator|->
name|skip_ofst
argument_list|)
operator||
name|V_TFLENGTH
argument_list|(
name|tp
operator|->
name|skip_len
argument_list|)
operator||
name|en
operator||
operator|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|V_TFPORT
argument_list|(
name|tp
operator|->
name|port
argument_list|)
operator||
name|V_TFINVERTMATCH
argument_list|(
name|tp
operator|->
name|invert
argument_list|)
else|:
name|V_T5_TFPORT
argument_list|(
name|tp
operator|->
name|port
argument_list|)
operator||
name|V_T5_TFINVERTMATCH
argument_list|(
name|tp
operator|->
name|invert
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_trace_filter - query one of the tracing filters  *	@adap: the adapter  *	@tp: the current trace filter parameters  *	@idx: which trace filter to query  *	@enabled: non-zero if the filter is enabled  *  *	Returns the current settings of one of the HW tracing filters.  */
end_comment

begin_function
name|void
name|t4_get_trace_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|trace_params
modifier|*
name|tp
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|enabled
parameter_list|)
block|{
name|u32
name|ctla
decl_stmt|,
name|ctlb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ofst
init|=
name|idx
operator|*
literal|4
decl_stmt|;
name|u32
name|data_reg
decl_stmt|,
name|mask_reg
decl_stmt|;
name|ctla
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_A
operator|+
name|ofst
argument_list|)
expr_stmt|;
name|ctlb
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_TRC_FILTER_MATCH_CTL_B
operator|+
name|ofst
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
operator|*
name|enabled
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_TFEN
operator|)
expr_stmt|;
name|tp
operator|->
name|port
operator|=
name|G_TFPORT
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|tp
operator|->
name|invert
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_TFINVERTMATCH
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|enabled
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_T5_TFEN
operator|)
expr_stmt|;
name|tp
operator|->
name|port
operator|=
name|G_T5_TFPORT
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|tp
operator|->
name|invert
operator|=
operator|!
operator|!
operator|(
name|ctla
operator|&
name|F_T5_TFINVERTMATCH
operator|)
expr_stmt|;
block|}
name|tp
operator|->
name|snap_len
operator|=
name|G_TFCAPTUREMAX
argument_list|(
name|ctlb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|min_len
operator|=
name|G_TFMINPKTSIZE
argument_list|(
name|ctlb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|skip_ofst
operator|=
name|G_TFOFFSET
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|tp
operator|->
name|skip_len
operator|=
name|G_TFLENGTH
argument_list|(
name|ctla
argument_list|)
expr_stmt|;
name|ofst
operator|=
operator|(
name|A_MPS_TRC_FILTER1_MATCH
operator|-
name|A_MPS_TRC_FILTER0_MATCH
operator|)
operator|*
name|idx
expr_stmt|;
name|data_reg
operator|=
name|A_MPS_TRC_FILTER0_MATCH
operator|+
name|ofst
expr_stmt|;
name|mask_reg
operator|=
name|A_MPS_TRC_FILTER0_DONT_CARE
operator|+
name|ofst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRACE_LEN
operator|/
literal|4
condition|;
name|i
operator|++
operator|,
name|data_reg
operator|+=
literal|4
operator|,
name|mask_reg
operator|+=
literal|4
control|)
block|{
name|tp
operator|->
name|mask
index|[
name|i
index|]
operator|=
operator|~
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|mask_reg
argument_list|)
expr_stmt|;
name|tp
operator|->
name|data
index|[
name|i
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
operator|&
name|tp
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_pmtx_get_stats - returns the HW stats from PMTX  *	@adap: the adapter  *	@cnt: where to store the count statistics  *	@cycles: where to store the cycle statistics  *  *	Returns performance statistics from PMTX.  */
end_comment

begin_function
name|void
name|t4_pmtx_get_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
name|cnt
index|[]
parameter_list|,
name|u64
name|cycles
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|data
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PM_NSTATS
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_STAT_CONFIG
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cnt
index|[
name|i
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_STAT_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|cycles
index|[
name|i
index|]
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_STAT_LSB
argument_list|)
expr_stmt|;
else|else
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_PM_TX_DBG_CTRL
argument_list|,
name|A_PM_TX_DBG_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|,
name|A_PM_TX_DBG_STAT_MSB
argument_list|)
expr_stmt|;
name|cycles
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|u64
operator|)
name|data
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator||
name|data
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_pmrx_get_stats - returns the HW stats from PMRX  *	@adap: the adapter  *	@cnt: where to store the count statistics  *	@cycles: where to store the cycle statistics  *  *	Returns performance statistics from PMRX.  */
end_comment

begin_function
name|void
name|t4_pmrx_get_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|u32
name|cnt
index|[]
parameter_list|,
name|u64
name|cycles
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|data
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PM_NSTATS
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_STAT_CONFIG
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cnt
index|[
name|i
index|]
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_STAT_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|cycles
index|[
name|i
index|]
operator|=
name|t4_read_reg64
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_STAT_LSB
argument_list|)
expr_stmt|;
else|else
block|{
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_PM_RX_DBG_CTRL
argument_list|,
name|A_PM_RX_DBG_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|,
name|A_PM_RX_DBG_STAT_MSB
argument_list|)
expr_stmt|;
name|cycles
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|u64
operator|)
name|data
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator||
name|data
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	get_mps_bg_map - return the buffer groups associated with a port  *	@adap: the adapter  *	@idx: the port index  *  *	Returns a bitmap indicating which MPS buffer groups are associated  *	with the given port.  Bit i is set if buffer group i is used by the  *	port.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_mps_bg_map
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|u32
name|n
init|=
name|G_NUMPORTS
argument_list|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_CMN_CTL
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|idx
operator|==
literal|0
condition|?
literal|0xf
else|:
literal|0
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|idx
operator|<
literal|2
condition|?
operator|(
literal|3
operator|<<
operator|(
literal|2
operator|*
name|idx
operator|)
operator|)
else|:
literal|0
return|;
return|return
literal|1
operator|<<
name|idx
return|;
block|}
end_function

begin_comment
comment|/**  *      t4_get_port_stats_offset - collect port stats relative to a previous  *                                 snapshot  *      @adap: The adapter  *      @idx: The port  *      @stats: Current stats to fill  *      @offset: Previous stats snapshot  */
end_comment

begin_function
name|void
name|t4_get_port_stats_offset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|port_stats
modifier|*
name|stats
parameter_list|,
name|struct
name|port_stats
modifier|*
name|offset
parameter_list|)
block|{
name|u64
modifier|*
name|s
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t4_get_port_stats
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|,
name|stats
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
operator|(
name|u64
operator|*
operator|)
name|stats
operator|,
name|o
operator|=
operator|(
name|u64
operator|*
operator|)
name|offset
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|port_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|s
operator|++
operator|,
name|o
operator|++
control|)
operator|*
name|s
operator|-=
operator|*
name|o
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_get_port_stats - collect port statistics  *	@adap: the adapter  *	@idx: the port index  *	@p: the stats structure to fill  *  *	Collect statistics related to the given port from HW.  */
end_comment

begin_function
name|void
name|t4_get_port_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|port_stats
modifier|*
name|p
parameter_list|)
block|{
name|u32
name|bgmap
init|=
name|get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|)
decl_stmt|;
define|#
directive|define
name|GET_STAT
parameter_list|(
name|name
parameter_list|)
define|\
value|t4_read_reg64(adap, \ 	(is_t4(adap) ? PORT_REG(idx, A_MPS_PORT_STAT_##name##_L) : \ 	T5_PORT_REG(idx, A_MPS_PORT_STAT_##name##_L)))
define|#
directive|define
name|GET_STAT_COM
parameter_list|(
name|name
parameter_list|)
value|t4_read_reg64(adap, A_MPS_STAT_##name##_L)
name|p
operator|->
name|tx_pause
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PAUSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_octets
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_BYTES
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_BCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_MCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_UCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_error_frames
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_64
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_65_127
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_65B_127B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_128_255
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_128B_255B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_256_511
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_256B_511B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_512_1023
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_512B_1023B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_1024_1518
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_1024B_1518B
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_frames_1519_max
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_1519B_MAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_drop
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_DROP
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp0
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP0
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp1
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP1
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp2
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP2
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp3
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP3
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp4
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP4
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp5
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP5
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp6
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP6
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_ppp7
operator|=
name|GET_STAT
argument_list|(
name|TX_PORT_PPP7
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_pause
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PAUSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_octets
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_BYTES
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_BCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_MCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_UCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_too_long
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_MTU_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_jabber
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_MTU_CRC_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_fcs_err
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_CRC_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_len_err
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_LEN_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_symbol_err
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_SYM_ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_runt
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_LESS_64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_64
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_65_127
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_65B_127B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_128_255
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_128B_255B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_256_511
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_256B_511B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_512_1023
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_512B_1023B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_1024_1518
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_1024B_1518B
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_frames_1519_max
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_1519B_MAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp0
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP0
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp1
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP1
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp2
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP2
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp3
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP3
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp4
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP4
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp5
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP5
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp6
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP6
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ppp7
operator|=
name|GET_STAT
argument_list|(
name|RX_PORT_PPP7
argument_list|)
expr_stmt|;
name|p
operator|->
name|rx_ovflow0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_ovflow1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_ovflow2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_ovflow3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_MAC_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rx_trunc3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_MAC_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
undef|#
directive|undef
name|GET_STAT
undef|#
directive|undef
name|GET_STAT_COM
block|}
end_function

begin_comment
comment|/**  *	t4_clr_port_stats - clear port statistics  *	@adap: the adapter  *	@idx: the port index  *  *	Clear HW statistics for the given port.  */
end_comment

begin_function
name|void
name|t4_clr_port_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|u32
name|bgmap
init|=
name|get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|u32
name|port_base_addr
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|port_base_addr
operator|=
name|PORT_BASE
argument_list|(
name|idx
argument_list|)
expr_stmt|;
else|else
name|port_base_addr
operator|=
name|T5_PORT_BASE
argument_list|(
name|idx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|A_MPS_PORT_STAT_TX_PORT_BYTES_L
init|;
name|i
operator|<=
name|A_MPS_PORT_STAT_TX_PORT_PPP7_H
condition|;
name|i
operator|+=
literal|8
control|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|port_base_addr
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|A_MPS_PORT_STAT_RX_PORT_BYTES_L
init|;
name|i
operator|<=
name|A_MPS_PORT_STAT_RX_PORT_LESS_64B_H
condition|;
name|i
operator|+=
literal|8
control|)
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|port_base_addr
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bgmap
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_STAT_RX_BG_0_MAC_DROP_FRAME_L
operator|+
name|i
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_STAT_RX_BG_0_MAC_TRUNC_FRAME_L
operator|+
name|i
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_get_lb_stats - collect loopback port statistics  *	@adap: the adapter  *	@idx: the loopback port index  *	@p: the stats structure to fill  *  *	Return HW statistics for the given loopback port.  */
end_comment

begin_function
name|void
name|t4_get_lb_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|lb_port_stats
modifier|*
name|p
parameter_list|)
block|{
name|u32
name|bgmap
init|=
name|get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|)
decl_stmt|;
define|#
directive|define
name|GET_STAT
parameter_list|(
name|name
parameter_list|)
define|\
value|t4_read_reg64(adap, \ 	(is_t4(adap) ? \ 	PORT_REG(idx, A_MPS_PORT_STAT_LB_PORT_##name##_L) : \ 	T5_PORT_REG(idx, A_MPS_PORT_STAT_LB_PORT_##name##_L)))
define|#
directive|define
name|GET_STAT_COM
parameter_list|(
name|name
parameter_list|)
value|t4_read_reg64(adap, A_MPS_STAT_##name##_L)
name|p
operator|->
name|octets
operator|=
name|GET_STAT
argument_list|(
name|BYTES
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames
operator|=
name|GET_STAT
argument_list|(
name|FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|bcast_frames
operator|=
name|GET_STAT
argument_list|(
name|BCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|mcast_frames
operator|=
name|GET_STAT
argument_list|(
name|MCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|ucast_frames
operator|=
name|GET_STAT
argument_list|(
name|UCAST
argument_list|)
expr_stmt|;
name|p
operator|->
name|error_frames
operator|=
name|GET_STAT
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_64
operator|=
name|GET_STAT
argument_list|(
literal|64B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_65_127
operator|=
name|GET_STAT
argument_list|(
literal|65B_127B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_128_255
operator|=
name|GET_STAT
argument_list|(
literal|128B_255B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_256_511
operator|=
name|GET_STAT
argument_list|(
literal|256B_511B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_512_1023
operator|=
name|GET_STAT
argument_list|(
literal|512B_1023B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_1024_1518
operator|=
name|GET_STAT
argument_list|(
literal|1024B_1518B
argument_list|)
expr_stmt|;
name|p
operator|->
name|frames_1519_max
operator|=
name|GET_STAT
argument_list|(
literal|1519B_MAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|drop
operator|=
name|GET_STAT
argument_list|(
name|DROP_FRAMES
argument_list|)
expr_stmt|;
name|p
operator|->
name|ovflow0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|ovflow1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|ovflow2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|ovflow3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_LB_DROP_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc0
operator|=
operator|(
name|bgmap
operator|&
literal|1
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_0_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc1
operator|=
operator|(
name|bgmap
operator|&
literal|2
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_1_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc2
operator|=
operator|(
name|bgmap
operator|&
literal|4
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_2_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trunc3
operator|=
operator|(
name|bgmap
operator|&
literal|8
operator|)
condition|?
name|GET_STAT_COM
argument_list|(
name|RX_BG_3_LB_TRUNC_FRAME
argument_list|)
else|:
literal|0
expr_stmt|;
undef|#
directive|undef
name|GET_STAT
undef|#
directive|undef
name|GET_STAT_COM
block|}
end_function

begin_comment
comment|/**  *	t4_wol_magic_enable - enable/disable magic packet WoL  *	@adap: the adapter  *	@port: the physical port index  *	@addr: MAC address expected in magic packets, %NULL to disable  *  *	Enables/disables magic packet wake-on-LAN for the selected port.  */
end_comment

begin_function
name|void
name|t4_wol_magic_enable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|u32
name|mag_id_reg_l
decl_stmt|,
name|mag_id_reg_h
decl_stmt|,
name|port_cfg_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|mag_id_reg_l
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_MAGIC_MACID_LO
argument_list|)
expr_stmt|;
name|mag_id_reg_h
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_MAGIC_MACID_HI
argument_list|)
expr_stmt|;
name|port_cfg_reg
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_CFG2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mag_id_reg_l
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_MAGIC_MACID_LO
argument_list|)
expr_stmt|;
name|mag_id_reg_h
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_MAGIC_MACID_HI
argument_list|)
expr_stmt|;
name|port_cfg_reg
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_CFG2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
condition|)
block|{
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mag_id_reg_l
argument_list|,
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|mag_id_reg_h
argument_list|,
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|port_cfg_reg
argument_list|,
name|F_MAGICEN
argument_list|,
name|V_MAGICEN
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t4_wol_pat_enable - enable/disable pattern-based WoL  *	@adap: the adapter  *	@port: the physical port index  *	@map: bitmap of which HW pattern filters to set  *	@mask0: byte mask for bytes 0-63 of a packet  *	@mask1: byte mask for bytes 64-127 of a packet  *	@crc: Ethernet CRC for selected bytes  *	@enable: enable/disable switch  *  *	Sets the pattern filters indicated in @map to mask out the bytes  *	specified in @mask0/@mask1 in received packets and compare the CRC of  *	the resulting packet against @crc.  If @enable is %true pattern-based  *	WoL is enabled, otherwise disabled.  */
end_comment

begin_function
name|int
name|t4_wol_pat_enable
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|map
parameter_list|,
name|u64
name|mask0
parameter_list|,
name|u64
name|mask1
parameter_list|,
name|unsigned
name|int
name|crc
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|port_cfg_reg
decl_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|)
name|port_cfg_reg
operator|=
name|PORT_REG
argument_list|(
name|port
argument_list|,
name|A_XGMAC_PORT_CFG2
argument_list|)
expr_stmt|;
else|else
name|port_cfg_reg
operator|=
name|T5_PORT_REG
argument_list|(
name|port
argument_list|,
name|A_MAC_PORT_CFG2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|port_cfg_reg
argument_list|,
name|F_PATEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|map
operator|>
literal|0xff
condition|)
return|return
operator|-
name|EINVAL
return|;
define|#
directive|define
name|EPIO_REG
parameter_list|(
name|name
parameter_list|)
define|\
value|(is_t4(adap) ? PORT_REG(port, A_XGMAC_PORT_EPIO_##name) : \ 	T5_PORT_REG(port, A_MAC_PORT_EPIO_##name))
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA1
argument_list|)
argument_list|,
name|mask0
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA2
argument_list|)
argument_list|,
name|mask1
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA3
argument_list|)
argument_list|,
name|mask1
operator|>>
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NWOL_PAT
condition|;
name|i
operator|++
operator|,
name|map
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|map
operator|&
literal|1
operator|)
condition|)
continue|continue;
comment|/* write byte masks */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA0
argument_list|)
argument_list|,
name|mask0
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|,
name|V_ADDRESS
argument_list|(
name|i
argument_list|)
operator||
name|F_EPIOWR
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|ETIMEDOUT
return|;
comment|/* write CRC */
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|DATA0
argument_list|)
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|,
name|V_ADDRESS
argument_list|(
name|i
operator|+
literal|32
argument_list|)
operator||
name|F_EPIOWR
argument_list|)
expr_stmt|;
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|EPIO_REG
argument_list|(
name|OP
argument_list|)
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
undef|#
directive|undef
name|EPIO_REG
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|port_cfg_reg
argument_list|,
literal|0
argument_list|,
name|F_PATEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mk_filtdelwr - create a delete filter WR  *	@ftid: the filter ID  *	@wr: the filter work request to populate  *	@qid: ingress queue to receive the delete notification  *  *	Creates a filter work request to delete the supplied filter.  If @qid is  *	negative the delete notification is suppressed.  */
end_comment

begin_function
name|void
name|t4_mk_filtdelwr
parameter_list|(
name|unsigned
name|int
name|ftid
parameter_list|,
name|struct
name|fw_filter_wr
modifier|*
name|wr
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|memset
argument_list|(
name|wr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|op_pkd
operator|=
name|htonl
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_FILTER_WR
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|len16_pkd
operator|=
name|htonl
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
operator|/
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|tid_to_iq
operator|=
name|htonl
argument_list|(
name|V_FW_FILTER_WR_TID
argument_list|(
name|ftid
argument_list|)
operator||
name|V_FW_FILTER_WR_NOREPLY
argument_list|(
name|qid
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|del_filter_to_l2tix
operator|=
name|htonl
argument_list|(
name|F_FW_FILTER_WR_DEL_FILTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|>=
literal|0
condition|)
name|wr
operator|->
name|rx_chan_rx_rpl_iq
operator|=
name|htons
argument_list|(
name|V_FW_FILTER_WR_RX_RPL_IQ
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|INIT_CMD
parameter_list|(
name|var
parameter_list|,
name|cmd
parameter_list|,
name|rd_wr
parameter_list|)
value|do { \ 	(var).op_to_write = htonl(V_FW_CMD_OP(FW_##cmd##_CMD) | \ 				  F_FW_CMD_REQUEST | F_FW_CMD_##rd_wr); \ 	(var).retval_len16 = htonl(FW_LEN16(var)); \ } while (0)
end_define

begin_function
name|int
name|t4_fwaddrspace_write
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_FIRMWARE
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|addrval
operator|.
name|addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|addrval
operator|.
name|val
operator|=
name|htonl
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mdio_rd - read a PHY register through MDIO  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@phy_addr: the PHY address  *	@mmd: the PHY MMD to access (0 for clause 22 PHYs)  *	@reg: the register to read  *	@valp: where to store the value  *  *	Issues a FW command through the given mailbox to read a PHY register.  */
end_comment

begin_function
name|int
name|t4_mdio_rd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|phy_addr
parameter_list|,
name|unsigned
name|int
name|mmd
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_MDIO
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|paddr_mmd
operator|=
name|htons
argument_list|(
name|V_FW_LDST_CMD_PADDR
argument_list|(
name|phy_addr
argument_list|)
operator||
name|V_FW_LDST_CMD_MMD
argument_list|(
name|mmd
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|raddr
operator|=
name|htons
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|*
name|valp
operator|=
name|ntohs
argument_list|(
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|rval
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_mdio_wr - write a PHY register through MDIO  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@phy_addr: the PHY address  *	@mmd: the PHY MMD to access (0 for clause 22 PHYs)  *	@reg: the register to write  *	@valp: value to write  *  *	Issues a FW command through the given mailbox to write a PHY register.  */
end_comment

begin_function
name|int
name|t4_mdio_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|phy_addr
parameter_list|,
name|unsigned
name|int
name|mmd
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_MDIO
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|paddr_mmd
operator|=
name|htons
argument_list|(
name|V_FW_LDST_CMD_PADDR
argument_list|(
name|phy_addr
argument_list|)
operator||
name|V_FW_LDST_CMD_MMD
argument_list|(
name|mmd
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|raddr
operator|=
name|htons
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|mdio
operator|.
name|rval
operator|=
name|htons
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_i2c_rd - read I2C data from adapter  *	@adap: the adapter  *	@port: Port number if per-port device;<0 if not  *	@devid: per-port device ID or absolute device ID  *	@offset: byte offset into device I2C space  *	@len: byte length of I2C space data  *	@buf: buffer in which to return I2C data  *  *	Reads the I2C data from the indicated device and location.  */
end_comment

begin_function
name|int
name|t4_i2c_rd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|devid
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|fw_ldst_cmd
name|ldst
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|4
operator|||
name|devid
operator|>=
literal|256
operator|||
name|offset
operator|>=
literal|256
operator|||
name|len
operator|>
sizeof|sizeof
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|ldst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ldst
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_I2C
argument_list|)
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst
argument_list|)
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|pid
operator|=
operator|(
name|port
operator|<
literal|0
condition|?
literal|0xff
else|:
name|port
operator|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|did
operator|=
name|devid
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|boffset
operator|=
name|offset
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|blen
operator|=
name|len
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|ldst
argument_list|,
sizeof|sizeof
name|ldst
argument_list|,
operator|&
name|ldst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|memcpy
argument_list|(
name|buf
argument_list|,
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_i2c_wr - write I2C data to adapter  *	@adap: the adapter  *	@port: Port number if per-port device;<0 if not  *	@devid: per-port device ID or absolute device ID  *	@offset: byte offset into device I2C space  *	@len: byte length of I2C space data  *	@buf: buffer containing new I2C data  *  *	Write the I2C data to the indicated device and location.  */
end_comment

begin_function
name|int
name|t4_i2c_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|devid
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|fw_ldst_cmd
name|ldst
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|4
operator|||
name|devid
operator|>=
literal|256
operator|||
name|offset
operator|>=
literal|256
operator|||
name|len
operator|>
sizeof|sizeof
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|ldst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ldst
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|op_to_addrspace
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_I2C
argument_list|)
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|cycles_to_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|ldst
argument_list|)
argument_list|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|pid
operator|=
operator|(
name|port
operator|<
literal|0
condition|?
literal|0xff
else|:
name|port
operator|)
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|did
operator|=
name|devid
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|boffset
operator|=
name|offset
expr_stmt|;
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|blen
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ldst
operator|.
name|u
operator|.
name|i2c
operator|.
name|data
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|ldst
argument_list|,
sizeof|sizeof
name|ldst
argument_list|,
operator|&
name|ldst
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_sge_ctxt_flush - flush the SGE context cache  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *  *	Issues a FW command through the given mailbox to flush the  *	SGE context cache.  */
end_comment

begin_function
name|int
name|t4_sge_ctxt_flush
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|FW_LDST_ADDRSPC_SGE_EGRC
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|msg_ctxtflush
operator|=
name|htonl
argument_list|(
name|F_FW_LDST_CMD_CTXTFLUSH
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_sge_ctxt_rd - read an SGE context through FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@cid: the context id  *	@ctype: the context type  *	@data: where to store the context data  *  *	Issues a FW command through the given mailbox to read an SGE context.  */
end_comment

begin_function
name|int
name|t4_sge_ctxt_rd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|cid
parameter_list|,
name|enum
name|ctxt_type
name|ctype
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_ldst_cmd
name|c
decl_stmt|;
if|if
condition|(
name|ctype
operator|==
name|CTXT_EGRESS
condition|)
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_EGRC
expr_stmt|;
elseif|else
if|if
condition|(
name|ctype
operator|==
name|CTXT_INGRESS
condition|)
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_INGC
expr_stmt|;
elseif|else
if|if
condition|(
name|ctype
operator|==
name|CTXT_FLM
condition|)
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_FLMC
expr_stmt|;
else|else
name|ret
operator|=
name|FW_LDST_ADDRSPC_SGE_CONMC
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_addrspace
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_LDST_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_LDST_CMD_ADDRSPACE
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cycles_to_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|physid
operator|=
name|htonl
argument_list|(
name|cid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data0
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data1
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data2
argument_list|)
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data3
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data4
argument_list|)
expr_stmt|;
name|data
index|[
literal|5
index|]
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|u
operator|.
name|idctxt
operator|.
name|ctxt_data5
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_sge_ctxt_rd_bd - read an SGE context bypassing FW  *	@adap: the adapter  *	@cid: the context id  *	@ctype: the context type  *	@data: where to store the context data  *  *	Reads an SGE context directly, bypassing FW.  This is only for  *	debugging when FW is unavailable.  */
end_comment

begin_function
name|int
name|t4_sge_ctxt_rd_bd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|cid
parameter_list|,
name|enum
name|ctxt_type
name|ctype
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SGE_CTXT_CMD
argument_list|,
name|V_CTXTQID
argument_list|(
name|cid
argument_list|)
operator||
name|V_CTXTTYPE
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_SGE_CTXT_CMD
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
for|for
control|(
name|i
operator|=
name|A_SGE_CTXT_DATA0
init|;
name|i
operator|<=
name|A_SGE_CTXT_DATA5
condition|;
name|i
operator|+=
literal|4
control|)
operator|*
name|data
operator|++
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_hello - establish communication with FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@evt_mbox: mailbox to receive async FW events  *	@master: specifies the caller's willingness to be the device master  *	@state: returns the current device state (if non-NULL)  *  *	Issues a command to establish communication with FW.  Returns either  *	an error (negative integer) or the mailbox of the Master PF.  */
end_comment

begin_function
name|int
name|t4_fw_hello
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|evt_mbox
parameter_list|,
name|enum
name|dev_master
name|master
parameter_list|,
name|enum
name|dev_state
modifier|*
name|state
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_hello_cmd
name|c
decl_stmt|;
name|u32
name|v
decl_stmt|;
name|unsigned
name|int
name|master_mbox
decl_stmt|;
name|int
name|retries
init|=
name|FW_CMD_HELLO_RETRIES
decl_stmt|;
name|retry
label|:
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|HELLO
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|err_to_clearinit
operator|=
name|htonl
argument_list|(
name|V_FW_HELLO_CMD_MASTERDIS
argument_list|(
name|master
operator|==
name|MASTER_CANT
argument_list|)
operator||
name|V_FW_HELLO_CMD_MASTERFORCE
argument_list|(
name|master
operator|==
name|MASTER_MUST
argument_list|)
operator||
name|V_FW_HELLO_CMD_MBMASTER
argument_list|(
name|master
operator|==
name|MASTER_MUST
condition|?
name|mbox
else|:
name|M_FW_HELLO_CMD_MBMASTER
argument_list|)
operator||
name|V_FW_HELLO_CMD_MBASYNCNOT
argument_list|(
name|evt_mbox
argument_list|)
operator||
name|V_FW_HELLO_CMD_STAGE
argument_list|(
name|FW_HELLO_CMD_STAGE_OS
argument_list|)
operator||
name|F_FW_HELLO_CMD_CLEARINIT
argument_list|)
expr_stmt|;
comment|/* 	 * Issue the HELLO command to the firmware.  If it's not successful 	 * but indicates that we got a "busy" or "timeout" condition, retry 	 * the HELLO until we exhaust our retry limit.  If we do exceed our 	 * retry limit, check to see if the firmware left us any error 	 * information and report that if so ... 	 */
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|FW_SUCCESS
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|==
operator|-
name|EBUSY
operator|||
name|ret
operator|==
operator|-
name|ETIMEDOUT
operator|)
operator|&&
name|retries
operator|--
operator|>
literal|0
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
operator|&
name|F_PCIE_FW_ERR
condition|)
name|t4_report_fw_error
argument_list|(
name|adap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|v
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|err_to_clearinit
argument_list|)
expr_stmt|;
name|master_mbox
operator|=
name|G_FW_HELLO_CMD_MBMASTER
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|v
operator|&
name|F_FW_HELLO_CMD_ERR
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_ERR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|&
name|F_FW_HELLO_CMD_INIT
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_INIT
expr_stmt|;
else|else
operator|*
name|state
operator|=
name|DEV_STATE_UNINIT
expr_stmt|;
block|}
comment|/* 	 * If we're not the Master PF then we need to wait around for the 	 * Master PF Driver to finish setting up the adapter. 	 * 	 * Note that we also do this wait if we're a non-Master-capable PF and 	 * there is no current Master PF; a Master PF may show up momentarily 	 * and we wouldn't want to fail pointlessly.  (This can happen when an 	 * OS loads lots of different drivers rapidly at the same time).  In 	 * this case, the Master PF returned by the firmware will be 	 * M_PCIE_FW_MASTER so the test below will work ... 	 */
if|if
condition|(
operator|(
name|v
operator|&
operator|(
name|F_FW_HELLO_CMD_ERR
operator||
name|F_FW_HELLO_CMD_INIT
operator|)
operator|)
operator|==
literal|0
operator|&&
name|master_mbox
operator|!=
name|mbox
condition|)
block|{
name|int
name|waiting
init|=
name|FW_CMD_HELLO_TIMEOUT
decl_stmt|;
comment|/* 		 * Wait for the firmware to either indicate an error or 		 * initialized state.  If we see either of these we bail out 		 * and report the issue to the caller.  If we exhaust the 		 * "hello timeout" and we haven't exhausted our retries, try 		 * again.  Otherwise bail with a timeout error. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|u32
name|pcie_fw
decl_stmt|;
name|msleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|waiting
operator|-=
literal|50
expr_stmt|;
comment|/* 			 * If neither Error nor Initialialized are indicated 			 * by the firmware keep waiting till we exhaust our 			 * timeout ... and then retry if we haven't exhausted 			 * our retries ... 			 */
name|pcie_fw
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pcie_fw
operator|&
operator|(
name|F_PCIE_FW_ERR
operator||
name|F_PCIE_FW_INIT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|waiting
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
goto|goto
name|retry
goto|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
continue|continue;
block|}
comment|/* 			 * We either have an Error or Initialized condition 			 * report errors preferentially. 			 */
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|pcie_fw
operator|&
name|F_PCIE_FW_ERR
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_ERR
expr_stmt|;
elseif|else
if|if
condition|(
name|pcie_fw
operator|&
name|F_PCIE_FW_INIT
condition|)
operator|*
name|state
operator|=
name|DEV_STATE_INIT
expr_stmt|;
block|}
comment|/* 			 * If we arrived before a Master PF was selected and 			 * there's not a valid Master PF, grab its identity 			 * for our caller. 			 */
if|if
condition|(
name|master_mbox
operator|==
name|M_PCIE_FW_MASTER
operator|&&
operator|(
name|pcie_fw
operator|&
name|F_PCIE_FW_MASTER_VLD
operator|)
condition|)
name|master_mbox
operator|=
name|G_PCIE_FW_MASTER
argument_list|(
name|pcie_fw
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|master_mbox
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_bye - end communication with FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *  *	Issues a command to terminate communication with FW.  */
end_comment

begin_function
name|int
name|t4_fw_bye
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|)
block|{
name|struct
name|fw_bye_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|BYE
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_reset - issue a reset to FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@reset: specifies the type of reset to perform  *  *	Issues a reset command of the specified type to FW.  */
end_comment

begin_function
name|int
name|t4_fw_reset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|fw_reset_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|RESET
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|htonl
argument_list|(
name|reset
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_halt - issue a reset/halt to FW and put uP into RESET  *	@adap: the adapter  *	@mbox: mailbox to use for the FW RESET command (if desired)  *	@force: force uP into RESET even if FW RESET command fails  *  *	Issues a RESET command to firmware (if desired) with a HALT indication  *	and then puts the microprocessor into RESET state.  The RESET command  *	will only be issued if a legitimate mailbox is provided (mbox<=  *	M_PCIE_FW_MASTER).  *  *	This is generally used in order for the host to safely manipulate the  *	adapter without fear of conflicting with whatever the firmware might  *	be doing.  The only way out of this state is to RESTART the firmware  *	...  */
end_comment

begin_function
name|int
name|t4_fw_halt
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * If a legitimate mailbox is provided, issue a RESET command 	 * with a HALT indication. 	 */
if|if
condition|(
name|mbox
operator|<=
name|M_PCIE_FW_MASTER
condition|)
block|{
name|struct
name|fw_reset_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|RESET
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|htonl
argument_list|(
name|F_PIORST
operator||
name|F_PIORSTMODE
argument_list|)
expr_stmt|;
name|c
operator|.
name|halt_pkd
operator|=
name|htonl
argument_list|(
name|F_FW_RESET_CMD_HALT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Normally we won't complete the operation if the firmware RESET 	 * command fails but if our caller insists we'll go ahead and put the 	 * uP into RESET.  This can be useful if the firmware is hung or even 	 * missing ...  We'll have to take the risk of putting the uP into 	 * RESET without the cooperation of firmware in that case. 	 * 	 * We also force the firmware's HALT flag to be on in case we bypassed 	 * the firmware RESET command above or we're dealing with old firmware 	 * which doesn't have the HALT capability.  This will serve as a flag 	 * for the incoming firmware to know that it's coming out of a HALT 	 * rather than a RESET ... if it's new enough to understand that ... 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|force
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|F_UPCRST
argument_list|,
name|F_UPCRST
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|,
name|F_PCIE_FW_HALT
argument_list|,
name|F_PCIE_FW_HALT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * And we always return the result of the firmware RESET command 	 * even when we force the uP into RESET ... 	 */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_restart - restart the firmware by taking the uP out of RESET  *	@adap: the adapter  *	@reset: if we want to do a RESET to restart things  *  *	Restart firmware previously halted by t4_fw_halt().  On successful  *	return the previous PF Master remains as the new PF Master and there  *	is no need to issue a new HELLO command, etc.  *  *	We do this in two ways:  *  *	 1. If we're dealing with newer firmware we'll simply want to take  *	    the chip's microprocessor out of RESET.  This will cause the  *	    firmware to start up from its start vector.  And then we'll loop  *	    until the firmware indicates it's started again (PCIE_FW.HALT  *	    reset to 0) or we timeout.  *  *	 2. If we're dealing with older firmware then we'll need to RESET  *	    the chip since older firmware won't recognize the PCIE_FW.HALT  *	    flag and automatically RESET itself on startup.  */
end_comment

begin_function
name|int
name|t4_fw_restart
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
if|if
condition|(
name|reset
condition|)
block|{
comment|/* 		 * Since we're directing the RESET instead of the firmware 		 * doing it automatically, we need to clear the PCIE_FW.HALT 		 * bit. 		 */
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|,
name|F_PCIE_FW_HALT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If we've been given a valid mailbox, first try to get the 		 * firmware to do the RESET.  If that works, great and we can 		 * return success.  Otherwise, if we haven't been given a 		 * valid mailbox or the RESET command failed, fall back to 		 * hitting the chip with a hammer. 		 */
if|if
condition|(
name|mbox
operator|<=
name|M_PCIE_FW_MASTER
condition|)
block|{
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|F_UPCRST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_fw_reset
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|F_PIORST
operator||
name|F_PIORSTMODE
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|t4_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PL_RST
argument_list|,
name|F_PIORST
operator||
name|F_PIORSTMODE
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ms
decl_stmt|;
name|t4_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|F_UPCRST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ms
operator|=
literal|0
init|;
name|ms
operator|<
name|FW_CMD_MAX_TIMEOUT
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_FW
argument_list|)
operator|&
name|F_PCIE_FW_HALT
operator|)
condition|)
return|return
name|FW_SUCCESS
return|;
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ms
operator|+=
literal|100
expr_stmt|;
block|}
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_upgrade - perform all of the steps necessary to upgrade FW  *	@adap: the adapter  *	@mbox: mailbox to use for the FW RESET command (if desired)  *	@fw_data: the firmware image to write  *	@size: image size  *	@force: force upgrade even if firmware doesn't cooperate  *  *	Perform all of the steps necessary for upgrading an adapter's  *	firmware image.  Normally this requires the cooperation of the  *	existing firmware in order to halt all existing activities  *	but if an invalid mailbox token is passed in we skip that step  *	(though we'll still put the adapter microprocessor into RESET in  *	that case).  *  *	On successful return the new firmware will have been loaded and  *	the adapter will have been fully RESET losing all previous setup  *	state.  On unsuccessful return the adapter may be completely hosed ...  *	positive errno indicates that the adapter is ~probably~ intact, a  *	negative errno indicates that things are looking bad ...  */
end_comment

begin_function
name|int
name|t4_fw_upgrade
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
specifier|const
name|u8
modifier|*
name|fw_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|force
parameter_list|)
block|{
specifier|const
name|struct
name|fw_hdr
modifier|*
name|fw_hdr
init|=
operator|(
specifier|const
expr|struct
name|fw_hdr
operator|*
operator|)
name|fw_data
decl_stmt|;
name|unsigned
name|int
name|bootstrap
init|=
name|ntohl
argument_list|(
name|fw_hdr
operator|->
name|magic
argument_list|)
operator|==
name|FW_HDR_MAGIC_BOOTSTRAP
decl_stmt|;
name|int
name|reset
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bootstrap
condition|)
block|{
name|ret
operator|=
name|t4_fw_halt
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|&&
operator|!
name|force
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|t4_load_fw
argument_list|(
name|adap
argument_list|,
name|fw_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|bootstrap
condition|)
return|return
name|ret
return|;
comment|/* 	 * Older versions of the firmware don't understand the new 	 * PCIE_FW.HALT flag and so won't know to perform a RESET when they 	 * restart.  So for newly loaded older firmware we'll have to do the 	 * RESET for it so it starts up on a clean slate.  We can tell if 	 * the newly loaded firmware will handle this right by checking 	 * its header flags to see if it advertises the capability. 	 */
name|reset
operator|=
operator|(
operator|(
name|ntohl
argument_list|(
name|fw_hdr
operator|->
name|flags
argument_list|)
operator|&
name|FW_HDR_FLAGS_RESET_HALT
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|t4_fw_restart
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|reset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_fw_initialize - ask FW to initialize the device  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *  *	Issues a command to FW to partially initialize the device.  This  *	performs initialization that generally doesn't depend on user input.  */
end_comment

begin_function
name|int
name|t4_fw_initialize
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|)
block|{
name|struct
name|fw_initialize_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CMD
argument_list|(
name|c
argument_list|,
name|INITIALIZE
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_query_params - query FW or device parameters  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF  *	@vf: the VF  *	@nparams: the number of parameters  *	@params: the parameter names  *	@val: the parameter values  *  *	Reads the value of FW or device parameters.  Up to 7 parameters can be  *	queried at once.  */
end_comment

begin_function
name|int
name|t4_query_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nparams
parameter_list|,
specifier|const
name|u32
modifier|*
name|params
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|fw_params_cmd
name|c
decl_stmt|;
name|__be32
modifier|*
name|p
init|=
operator|&
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|mnem
decl_stmt|;
if|if
condition|(
name|nparams
operator|>
literal|7
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PARAMS_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_PARAMS_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_PARAMS_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|2
operator|,
name|params
operator|++
control|)
operator|*
name|p
operator|=
name|htonl
argument_list|(
operator|*
name|params
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|&
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|val
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|2
control|)
operator|*
name|val
operator|++
operator|=
name|ntohl
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_params - sets FW or device parameters  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF  *	@vf: the VF  *	@nparams: the number of parameters  *	@params: the parameter names  *	@val: the parameter values  *  *	Sets the value of FW or device parameters.  Up to 7 parameters can be  *	specified at once.  */
end_comment

begin_function
name|int
name|t4_set_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nparams
parameter_list|,
specifier|const
name|u32
modifier|*
name|params
parameter_list|,
specifier|const
name|u32
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|fw_params_cmd
name|c
decl_stmt|;
name|__be32
modifier|*
name|p
init|=
operator|&
name|c
operator|.
name|param
index|[
literal|0
index|]
operator|.
name|mnem
decl_stmt|;
if|if
condition|(
name|nparams
operator|>
literal|7
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PARAMS_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_PARAMS_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_PARAMS_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nparams
operator|--
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|htonl
argument_list|(
operator|*
name|params
argument_list|)
expr_stmt|;
name|params
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|htonl
argument_list|(
operator|*
name|val
argument_list|)
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_cfg_pfvf - configure PF/VF resource limits  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF being configured  *	@vf: the VF being configured  *	@txq: the max number of egress queues  *	@txq_eth_ctrl: the max number of egress Ethernet or control queues  *	@rxqi: the max number of interrupt-capable ingress queues  *	@rxq: the max number of interruptless ingress queues  *	@tc: the PCI traffic class  *	@vi: the max number of virtual interfaces  *	@cmask: the channel access rights mask for the PF/VF  *	@pmask: the port access rights mask for the PF/VF  *	@nexact: the maximum number of exact MPS filters  *	@rcaps: read capabilities  *	@wxcaps: write/execute capabilities  *  *	Configures resource limits and capabilities for a physical or virtual  *	function.  */
end_comment

begin_function
name|int
name|t4_cfg_pfvf
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|txq
parameter_list|,
name|unsigned
name|int
name|txq_eth_ctrl
parameter_list|,
name|unsigned
name|int
name|rxqi
parameter_list|,
name|unsigned
name|int
name|rxq
parameter_list|,
name|unsigned
name|int
name|tc
parameter_list|,
name|unsigned
name|int
name|vi
parameter_list|,
name|unsigned
name|int
name|cmask
parameter_list|,
name|unsigned
name|int
name|pmask
parameter_list|,
name|unsigned
name|int
name|nexact
parameter_list|,
name|unsigned
name|int
name|rcaps
parameter_list|,
name|unsigned
name|int
name|wxcaps
parameter_list|)
block|{
name|struct
name|fw_pfvf_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PFVF_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_PFVF_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_PFVF_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|niqflint_niq
operator|=
name|htonl
argument_list|(
name|V_FW_PFVF_CMD_NIQFLINT
argument_list|(
name|rxqi
argument_list|)
operator||
name|V_FW_PFVF_CMD_NIQ
argument_list|(
name|rxq
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_neq
operator|=
name|htonl
argument_list|(
name|V_FW_PFVF_CMD_CMASK
argument_list|(
name|cmask
argument_list|)
operator||
name|V_FW_PFVF_CMD_PMASK
argument_list|(
name|pmask
argument_list|)
operator||
name|V_FW_PFVF_CMD_NEQ
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|tc_to_nexactf
operator|=
name|htonl
argument_list|(
name|V_FW_PFVF_CMD_TC
argument_list|(
name|tc
argument_list|)
operator||
name|V_FW_PFVF_CMD_NVI
argument_list|(
name|vi
argument_list|)
operator||
name|V_FW_PFVF_CMD_NEXACTF
argument_list|(
name|nexact
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|r_caps_to_nethctrl
operator|=
name|htonl
argument_list|(
name|V_FW_PFVF_CMD_R_CAPS
argument_list|(
name|rcaps
argument_list|)
operator||
name|V_FW_PFVF_CMD_WX_CAPS
argument_list|(
name|wxcaps
argument_list|)
operator||
name|V_FW_PFVF_CMD_NETHCTRL
argument_list|(
name|txq_eth_ctrl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_alloc_vi_func - allocate a virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@port: physical port associated with the VI  *	@pf: the PF owning the VI  *	@vf: the VF owning the VI  *	@nmac: number of MAC addresses needed (1 to 5)  *	@mac: the MAC addresses of the VI  *	@rss_size: size of RSS table slice associated with this VI  *	@portfunc: which Port Application Function MAC Address is desired  *	@idstype: Intrusion Detection Type  *  *	Allocates a virtual interface for the given physical port.  If @mac is  *	not %NULL it contains the MAC addresses of the VI as assigned by FW.  *	@mac should be large enough to hold @nmac Ethernet addresses, they are  *	stored consecutively so the space needed is @nmac * 6 bytes.  *	Returns a negative error number or the non-negative VI id.  */
end_comment

begin_function
name|int
name|t4_alloc_vi_func
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nmac
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|,
name|u16
modifier|*
name|rss_size
parameter_list|,
name|unsigned
name|int
name|portfunc
parameter_list|,
name|unsigned
name|int
name|idstype
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|fw_vi_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_VI_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_VI_CMD_ALLOC
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_viid
operator|=
name|htons
argument_list|(
name|V_FW_VI_CMD_TYPE
argument_list|(
name|idstype
argument_list|)
operator||
name|V_FW_VI_CMD_FUNC
argument_list|(
name|portfunc
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|portid_pkd
operator|=
name|V_FW_VI_CMD_PORTID
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|c
operator|.
name|nmac
operator|=
name|nmac
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|mac
condition|)
block|{
name|memcpy
argument_list|(
name|mac
argument_list|,
name|c
operator|.
name|mac
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|mac
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nmac
condition|)
block|{
case|case
literal|5
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|24
argument_list|,
name|c
operator|.
name|nmac3
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac3
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|18
argument_list|,
name|c
operator|.
name|nmac2
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac2
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|12
argument_list|,
name|c
operator|.
name|nmac1
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac1
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|memcpy
argument_list|(
name|mac
operator|+
literal|6
argument_list|,
name|c
operator|.
name|nmac0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|.
name|nmac0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rss_size
condition|)
operator|*
name|rss_size
operator|=
name|G_FW_VI_CMD_RSSSIZE
argument_list|(
name|ntohs
argument_list|(
name|c
operator|.
name|norss_rsssize
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|G_FW_VI_CMD_VIID
argument_list|(
name|htons
argument_list|(
name|c
operator|.
name|type_to_viid
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_alloc_vi - allocate an [Ethernet Function] virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@port: physical port associated with the VI  *	@pf: the PF owning the VI  *	@vf: the VF owning the VI  *	@nmac: number of MAC addresses needed (1 to 5)  *	@mac: the MAC addresses of the VI  *	@rss_size: size of RSS table slice associated with this VI  *  *	backwards compatible and convieniance routine to allocate a Virtual  *	Interface with a Ethernet Port Application Function and Intrustion  *	Detection System disabled.  */
end_comment

begin_function
name|int
name|t4_alloc_vi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|nmac
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|,
name|u16
modifier|*
name|rss_size
parameter_list|)
block|{
return|return
name|t4_alloc_vi_func
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|port
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
name|nmac
argument_list|,
name|mac
argument_list|,
name|rss_size
argument_list|,
name|FW_VI_FUNC_ETH
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_free_vi - free a virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the VI  *	@vf: the VF owning the VI  *	@viid: virtual interface identifiler  *  *	Free a previously allocated virtual interface.  */
end_comment

begin_function
name|int
name|t4_free_vi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|)
block|{
name|struct
name|fw_vi_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_VI_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_VI_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_viid
operator|=
name|htons
argument_list|(
name|V_FW_VI_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_rxmode - set Rx properties of a virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@mtu: the new MTU or -1  *	@promisc: 1 to enable promiscuous mode, 0 to disable it, -1 no change  *	@all_multi: 1 to enable all-multi mode, 0 to disable it, -1 no change  *	@bcast: 1 to enable broadcast Rx, 0 to disable it, -1 no change  *	@vlanex: 1 to enable HVLAN extraction, 0 to disable it, -1 no change  *	@sleep_ok: if true we may sleep while awaiting command completion  *  *	Sets Rx properties of a virtual interface.  */
end_comment

begin_function
name|int
name|t4_set_rxmode
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|int
name|mtu
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|all_multi
parameter_list|,
name|int
name|bcast
parameter_list|,
name|int
name|vlanex
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_vi_rxmode_cmd
name|c
decl_stmt|;
comment|/* convert to FW values */
if|if
condition|(
name|mtu
operator|<
literal|0
condition|)
name|mtu
operator|=
name|M_FW_VI_RXMODE_CMD_MTU
expr_stmt|;
if|if
condition|(
name|promisc
operator|<
literal|0
condition|)
name|promisc
operator|=
name|M_FW_VI_RXMODE_CMD_PROMISCEN
expr_stmt|;
if|if
condition|(
name|all_multi
operator|<
literal|0
condition|)
name|all_multi
operator|=
name|M_FW_VI_RXMODE_CMD_ALLMULTIEN
expr_stmt|;
if|if
condition|(
name|bcast
operator|<
literal|0
condition|)
name|bcast
operator|=
name|M_FW_VI_RXMODE_CMD_BROADCASTEN
expr_stmt|;
if|if
condition|(
name|vlanex
operator|<
literal|0
condition|)
name|vlanex
operator|=
name|M_FW_VI_RXMODE_CMD_VLANEXEN
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_RXMODE_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_VI_RXMODE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|retval_len16
operator|=
name|htonl
argument_list|(
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|mtu_to_vlanexen
operator|=
name|htonl
argument_list|(
name|V_FW_VI_RXMODE_CMD_MTU
argument_list|(
name|mtu
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_PROMISCEN
argument_list|(
name|promisc
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_ALLMULTIEN
argument_list|(
name|all_multi
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_BROADCASTEN
argument_list|(
name|bcast
argument_list|)
operator||
name|V_FW_VI_RXMODE_CMD_VLANEXEN
argument_list|(
name|vlanex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_alloc_mac_filt - allocates exact-match filters for MAC addresses  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@free: if true any existing filters for this VI id are first removed  *	@naddr: the number of MAC addresses to allocate filters for (up to 7)  *	@addr: the MAC address(es)  *	@idx: where to store the index of each allocated filter  *	@hash: pointer to hash address filter bitmap  *	@sleep_ok: call is allowed to sleep  *  *	Allocates an exact-match filter for each of the supplied addresses and  *	sets it to the corresponding address.  If @idx is not %NULL it should  *	have at least @naddr entries, each of which will be set to the index of  *	the filter allocated for the corresponding MAC address.  If a filter  *	could not be allocated for an address its index is set to 0xffff.  *	If @hash is not %NULL addresses that fail to allocate an exact filter  *	are hashed and update the hash filter bitmap pointed at by @hash.  *  *	Returns a negative error number or the number of filters allocated.  */
end_comment

begin_function
name|int
name|t4_alloc_mac_filt
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|bool
name|free
parameter_list|,
name|unsigned
name|int
name|naddr
parameter_list|,
specifier|const
name|u8
modifier|*
modifier|*
name|addr
parameter_list|,
name|u16
modifier|*
name|idx
parameter_list|,
name|u64
modifier|*
name|hash
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|int
name|offset
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|fw_vi_mac_cmd
name|c
decl_stmt|;
name|unsigned
name|int
name|nfilters
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|max_naddr
init|=
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|NUM_MPS_CLS_SRAM_L_INSTANCES
else|:
name|NUM_MPS_T5_CLS_SRAM_L_INSTANCES
decl_stmt|;
name|unsigned
name|int
name|rem
init|=
name|naddr
decl_stmt|;
if|if
condition|(
name|naddr
operator|>
name|max_naddr
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|naddr
condition|;
comment|/**/
control|)
block|{
name|unsigned
name|int
name|fw_naddr
init|=
operator|(
name|rem
operator|<
name|ARRAY_SIZE
argument_list|(
name|c
operator|.
name|u
operator|.
name|exact
argument_list|)
condition|?
name|rem
else|:
name|ARRAY_SIZE
argument_list|(
name|c
operator|.
name|u
operator|.
name|exact
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|len16
init|=
name|DIV_ROUND_UP
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|fw_vi_mac_cmd
argument_list|,
name|u
operator|.
name|exact
index|[
name|fw_naddr
index|]
argument_list|)
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|struct
name|fw_vi_mac_exact
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_MAC_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_CMD_EXEC
argument_list|(
name|free
argument_list|)
operator||
name|V_FW_VI_MAC_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|freemacs_to_len16
operator|=
name|htonl
argument_list|(
name|V_FW_VI_MAC_CMD_FREEMACS
argument_list|(
name|free
argument_list|)
operator||
name|V_FW_CMD_LEN16
argument_list|(
name|len16
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|c
operator|.
name|u
operator|.
name|exact
init|;
name|i
operator|<
name|fw_naddr
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|p
operator|->
name|valid_to_idx
operator|=
name|htons
argument_list|(
name|F_FW_VI_MAC_CMD_VALID
operator||
name|V_FW_VI_MAC_CMD_IDX
argument_list|(
name|FW_VI_MAC_ADD_MAC
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|macaddr
argument_list|,
name|addr
index|[
name|offset
operator|+
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * It's okay if we run out of space in our MAC address arena. 		 * Some of the addresses we submit may get stored so we need 		 * to run through the reply to see what the results were ... 		 */
name|ret
operator|=
name|t4_wr_mbox_meat
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|ret
operator|!=
operator|-
name|FW_ENOMEM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|c
operator|.
name|u
operator|.
name|exact
init|;
name|i
operator|<
name|fw_naddr
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|u16
name|index
init|=
name|G_FW_VI_MAC_CMD_IDX
argument_list|(
name|ntohs
argument_list|(
name|p
operator|->
name|valid_to_idx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
condition|)
name|idx
index|[
name|offset
operator|+
name|i
index|]
operator|=
operator|(
name|index
operator|>=
name|max_naddr
condition|?
literal|0xffff
else|:
name|index
operator|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|max_naddr
condition|)
name|nfilters
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|hash
condition|)
operator|*
name|hash
operator||=
operator|(
literal|1ULL
operator|<<
name|hash_mac_addr
argument_list|(
name|addr
index|[
name|offset
operator|+
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
name|free
operator|=
name|false
expr_stmt|;
name|offset
operator|+=
name|fw_naddr
expr_stmt|;
name|rem
operator|-=
name|fw_naddr
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
operator|-
name|FW_ENOMEM
condition|)
name|ret
operator|=
name|nfilters
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_change_mac - modifies the exact-match filter for a MAC address  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@idx: index of existing filter for old value of MAC address, or -1  *	@addr: the new MAC address value  *	@persist: whether a new MAC allocation should be persistent  *	@add_smt: if true also add the address to the HW SMT  *  *	Modifies an exact-match filter and sets it to the new MAC address if  *	@idx>= 0, or adds the MAC address to a new filter if @idx< 0.  In the  *	latter case the address is added persistently if @persist is %true.  *  *	Note that in general it is not possible to modify the value of a given  *	filter so the generic way to modify an address filter is to free the one  *	being used by the old address value and allocate a new filter for the  *	new address value.  *  *	Returns a negative error number or the index of the filter with the new  *	MAC value.  Note that this index may differ from @idx.  */
end_comment

begin_function
name|int
name|t4_change_mac
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
name|bool
name|persist
parameter_list|,
name|bool
name|add_smt
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|fw_vi_mac_cmd
name|c
decl_stmt|;
name|struct
name|fw_vi_mac_exact
modifier|*
name|p
init|=
name|c
operator|.
name|u
operator|.
name|exact
decl_stmt|;
name|unsigned
name|int
name|max_mac_addr
init|=
name|is_t4
argument_list|(
name|adap
argument_list|)
condition|?
name|NUM_MPS_CLS_SRAM_L_INSTANCES
else|:
name|NUM_MPS_T5_CLS_SRAM_L_INSTANCES
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
comment|/* new allocation */
name|idx
operator|=
name|persist
condition|?
name|FW_VI_MAC_ADD_PERSIST_MAC
else|:
name|FW_VI_MAC_ADD_MAC
expr_stmt|;
name|mode
operator|=
name|add_smt
condition|?
name|FW_VI_MAC_SMT_AND_MPSTCAM
else|:
name|FW_VI_MAC_MPS_TCAM_ENTRY
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_MAC_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_VI_MAC_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|freemacs_to_len16
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_LEN16
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|valid_to_idx
operator|=
name|htons
argument_list|(
name|F_FW_VI_MAC_CMD_VALID
operator||
name|V_FW_VI_MAC_CMD_SMAC_RESULT
argument_list|(
name|mode
argument_list|)
operator||
name|V_FW_VI_MAC_CMD_IDX
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|macaddr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|G_FW_VI_MAC_CMD_IDX
argument_list|(
name|ntohs
argument_list|(
name|p
operator|->
name|valid_to_idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|max_mac_addr
condition|)
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_set_addr_hash - program the MAC inexact-match hash filter  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@ucast: whether the hash filter should also match unicast addresses  *	@vec: the value to be written to the hash filter  *	@sleep_ok: call is allowed to sleep  *  *	Sets the 64-bit inexact-match hash filter for a virtual interface.  */
end_comment

begin_function
name|int
name|t4_set_addr_hash
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|bool
name|ucast
parameter_list|,
name|u64
name|vec
parameter_list|,
name|bool
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_vi_mac_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_MAC_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|V_FW_VI_ENABLE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|freemacs_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_VI_MAC_CMD_HASHVECEN
operator||
name|V_FW_VI_MAC_CMD_HASHUNIEN
argument_list|(
name|ucast
argument_list|)
operator||
name|V_FW_CMD_LEN16
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|u
operator|.
name|hash
operator|.
name|hashvec
operator|=
name|cpu_to_be64
argument_list|(
name|vec
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_enable_vi - enable/disable a virtual interface  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@rx_en: 1=enable Rx, 0=disable Rx  *	@tx_en: 1=enable Tx, 0=disable Tx  *  *	Enables/disables a virtual interface.  */
end_comment

begin_function
name|int
name|t4_enable_vi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|bool
name|rx_en
parameter_list|,
name|bool
name|tx_en
parameter_list|)
block|{
name|struct
name|fw_vi_enable_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_ENABLE_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_ENABLE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|ien_to_len16
operator|=
name|htonl
argument_list|(
name|V_FW_VI_ENABLE_CMD_IEN
argument_list|(
name|rx_en
argument_list|)
operator||
name|V_FW_VI_ENABLE_CMD_EEN
argument_list|(
name|tx_en
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_identify_port - identify a VI's port by blinking its LED  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@viid: the VI id  *	@nblinks: how many times to blink LED at 2.5 Hz  *  *	Identifies a VI's port by blinking its LED.  */
end_comment

begin_function
name|int
name|t4_identify_port
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|viid
parameter_list|,
name|unsigned
name|int
name|nblinks
parameter_list|)
block|{
name|struct
name|fw_vi_enable_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_viid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_VI_ENABLE_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_VI_ENABLE_CMD_VIID
argument_list|(
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|ien_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_VI_ENABLE_CMD_LED
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|blinkdur
operator|=
name|htons
argument_list|(
name|nblinks
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_iq_start_stop - enable/disable an ingress queue and its FLs  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@start: %true to enable the queues, %false to disable them  *	@pf: the PF owning the queues  *	@vf: the VF owning the queues  *	@iqid: ingress queue id  *	@fl0id: FL0 queue id or 0xffff if no attached FL0  *	@fl1id: FL1 queue id or 0xffff if no attached FL1  *  *	Starts or stops an ingress queue and its associated FLs, if any.  */
end_comment

begin_function
name|int
name|t4_iq_start_stop
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|bool
name|start
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|iqid
parameter_list|,
name|unsigned
name|int
name|fl0id
parameter_list|,
name|unsigned
name|int
name|fl1id
parameter_list|)
block|{
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|V_FW_IQ_CMD_IQSTART
argument_list|(
name|start
argument_list|)
operator||
name|V_FW_IQ_CMD_IQSTOP
argument_list|(
operator|!
name|start
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqid
operator|=
name|htons
argument_list|(
name|iqid
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0id
operator|=
name|htons
argument_list|(
name|fl0id
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl1id
operator|=
name|htons
argument_list|(
name|fl1id
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_iq_free - free an ingress queue and its FLs  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queues  *	@vf: the VF owning the queues  *	@iqtype: the ingress queue type (FW_IQ_TYPE_FL_INT_CAP, etc.)  *	@iqid: ingress queue id  *	@fl0id: FL0 queue id or 0xffff if no attached FL0  *	@fl1id: FL1 queue id or 0xffff if no attached FL1  *  *	Frees an ingress queue and its associated FLs, if any.  */
end_comment

begin_function
name|int
name|t4_iq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|iqtype
parameter_list|,
name|unsigned
name|int
name|iqid
parameter_list|,
name|unsigned
name|int
name|fl0id
parameter_list|,
name|unsigned
name|int
name|fl1id
parameter_list|)
block|{
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_IQ_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_iqandstindex
operator|=
name|htonl
argument_list|(
name|V_FW_IQ_CMD_TYPE
argument_list|(
name|iqtype
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqid
operator|=
name|htons
argument_list|(
name|iqid
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0id
operator|=
name|htons
argument_list|(
name|fl0id
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl1id
operator|=
name|htons
argument_list|(
name|fl1id
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_eth_eq_free - free an Ethernet egress queue  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queue  *	@vf: the VF owning the queue  *	@eqid: egress queue id  *  *	Frees an Ethernet egress queue.  */
end_comment

begin_function
name|int
name|t4_eth_eq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|eqid
parameter_list|)
block|{
name|struct
name|fw_eq_eth_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_ETH_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_ETH_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_EQ_ETH_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqid_pkd
operator|=
name|htonl
argument_list|(
name|V_FW_EQ_ETH_CMD_EQID
argument_list|(
name|eqid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_ctrl_eq_free - free a control egress queue  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queue  *	@vf: the VF owning the queue  *	@eqid: egress queue id  *  *	Frees a control egress queue.  */
end_comment

begin_function
name|int
name|t4_ctrl_eq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|eqid
parameter_list|)
block|{
name|struct
name|fw_eq_ctrl_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_CTRL_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_CTRL_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_EQ_CTRL_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_EQ_CTRL_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cmpliqid_eqid
operator|=
name|htonl
argument_list|(
name|V_FW_EQ_CTRL_CMD_EQID
argument_list|(
name|eqid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_ofld_eq_free - free an offload egress queue  *	@adap: the adapter  *	@mbox: mailbox to use for the FW command  *	@pf: the PF owning the queue  *	@vf: the VF owning the queue  *	@eqid: egress queue id  *  *	Frees a control egress queue.  */
end_comment

begin_function
name|int
name|t4_ofld_eq_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|mbox
parameter_list|,
name|unsigned
name|int
name|pf
parameter_list|,
name|unsigned
name|int
name|vf
parameter_list|,
name|unsigned
name|int
name|eqid
parameter_list|)
block|{
name|struct
name|fw_eq_ofld_cmd
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_OFLD_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_OFLD_CMD_PFN
argument_list|(
name|pf
argument_list|)
operator||
name|V_FW_EQ_OFLD_CMD_VFN
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_EQ_OFLD_CMD_FREE
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqid_pkd
operator|=
name|htonl
argument_list|(
name|V_FW_EQ_OFLD_CMD_EQID
argument_list|(
name|eqid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_handle_fw_rpl - process a FW reply message  *	@adap: the adapter  *	@rpl: start of the FW message  *  *	Processes a FW message, such as link state change messages.  */
end_comment

begin_function
name|int
name|t4_handle_fw_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
name|u8
name|opcode
init|=
operator|*
operator|(
specifier|const
name|u8
operator|*
operator|)
name|rpl
decl_stmt|;
specifier|const
name|struct
name|fw_port_cmd
modifier|*
name|p
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|rpl
decl_stmt|;
name|unsigned
name|int
name|action
init|=
name|G_FW_PORT_CMD_ACTION
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|action_to_len16
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|FW_PORT_CMD
operator|&&
name|action
operator|==
name|FW_PORT_ACTION_GET_PORT_INFO
condition|)
block|{
comment|/* link/module state change message */
name|int
name|speed
init|=
literal|0
decl_stmt|,
name|fc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
name|chan
init|=
name|G_FW_PORT_CMD_PORTID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|op_to_portid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|NULL
decl_stmt|;
name|struct
name|link_config
modifier|*
name|lc
decl_stmt|;
name|u32
name|stat
init|=
name|ntohl
argument_list|(
name|p
operator|->
name|u
operator|.
name|info
operator|.
name|lstatus_to_modtype
argument_list|)
decl_stmt|;
name|int
name|link_ok
init|=
operator|(
name|stat
operator|&
name|F_FW_PORT_CMD_LSTATUS
operator|)
operator|!=
literal|0
decl_stmt|;
name|u32
name|mod
init|=
name|G_FW_PORT_CMD_MODTYPE
argument_list|(
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|&
name|F_FW_PORT_CMD_RXPAUSE
condition|)
name|fc
operator||=
name|PAUSE_RX
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|F_FW_PORT_CMD_TXPAUSE
condition|)
name|fc
operator||=
name|PAUSE_TX
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_100M
argument_list|)
condition|)
name|speed
operator|=
name|SPEED_100
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_1G
argument_list|)
condition|)
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_10G
argument_list|)
condition|)
name|speed
operator|=
name|SPEED_10000
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|&
name|V_FW_PORT_CMD_LSPEED
argument_list|(
name|FW_PORT_CAP_SPEED_40G
argument_list|)
condition|)
name|speed
operator|=
name|SPEED_40000
expr_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
block|{
name|pi
operator|=
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|tx_chan
operator|==
name|chan
condition|)
break|break;
block|}
name|lc
operator|=
operator|&
name|pi
operator|->
name|link_cfg
expr_stmt|;
if|if
condition|(
name|link_ok
operator|!=
name|lc
operator|->
name|link_ok
operator|||
name|speed
operator|!=
name|lc
operator|->
name|speed
operator|||
name|fc
operator|!=
name|lc
operator|->
name|fc
condition|)
block|{
comment|/* something changed */
name|int
name|reason
decl_stmt|;
if|if
condition|(
operator|!
name|link_ok
operator|&&
name|lc
operator|->
name|link_ok
condition|)
name|reason
operator|=
name|G_FW_PORT_CMD_LINKDNRC
argument_list|(
name|stat
argument_list|)
expr_stmt|;
else|else
name|reason
operator|=
operator|-
literal|1
expr_stmt|;
name|lc
operator|->
name|link_ok
operator|=
name|link_ok
expr_stmt|;
name|lc
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
name|fc
expr_stmt|;
name|lc
operator|->
name|supported
operator|=
name|ntohs
argument_list|(
name|p
operator|->
name|u
operator|.
name|info
operator|.
name|pcap
argument_list|)
expr_stmt|;
name|t4_os_link_changed
argument_list|(
name|adap
argument_list|,
name|i
argument_list|,
name|link_ok
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mod
operator|!=
name|pi
operator|->
name|mod_type
condition|)
block|{
name|pi
operator|->
name|mod_type
operator|=
name|mod
expr_stmt|;
name|t4_os_portmod_changed
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CH_WARN_RATELIMIT
argument_list|(
name|adap
argument_list|,
literal|"Unknown firmware reply 0x%x (0x%x)\n"
argument_list|,
name|opcode
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	get_pci_mode - determine a card's PCI mode  *	@adapter: the adapter  *	@p: where to store the PCI settings  *  *	Determines a card's PCI mode and associated parameters, such as speed  *	and width.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|get_pci_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|pci_params
modifier|*
name|p
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|u32
name|pcie_cap
decl_stmt|;
name|pcie_cap
operator|=
name|t4_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_cap
condition|)
block|{
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_LNKSTA
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|p
operator|->
name|speed
operator|=
name|val
operator|&
name|PCI_EXP_LNKSTA_CLS
expr_stmt|;
name|p
operator|->
name|width
operator|=
operator|(
name|val
operator|&
name|PCI_EXP_LNKSTA_NLW
operator|)
operator|>>
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	init_link_config - initialize a link's SW state  *	@lc: structure holding the link state  *	@caps: link capabilities  *  *	Initializes the SW state maintained for each link, including the link's  *	capabilities and default speed/flow-control/autonegotiation settings.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|init_link_config
parameter_list|(
name|struct
name|link_config
modifier|*
name|lc
parameter_list|,
name|unsigned
name|int
name|caps
parameter_list|)
block|{
name|lc
operator|->
name|supported
operator|=
name|caps
expr_stmt|;
name|lc
operator|->
name|requested_speed
operator|=
literal|0
expr_stmt|;
name|lc
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
name|lc
operator|->
name|requested_fc
operator|=
name|lc
operator|->
name|fc
operator|=
name|PAUSE_RX
operator||
name|PAUSE_TX
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|supported
operator|&
name|FW_PORT_CAP_ANEG
condition|)
block|{
name|lc
operator|->
name|advertising
operator|=
name|lc
operator|->
name|supported
operator|&
name|ADVERT_MASK
expr_stmt|;
name|lc
operator|->
name|autoneg
operator|=
name|AUTONEG_ENABLE
expr_stmt|;
name|lc
operator|->
name|requested_fc
operator||=
name|PAUSE_AUTONEG
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|->
name|advertising
operator|=
literal|0
expr_stmt|;
name|lc
operator|->
name|autoneg
operator|=
name|AUTONEG_DISABLE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|__devinit
name|get_flash_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|info
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|SF_RD_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unlock SF */
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|info
operator|&
literal|0xff
operator|)
operator|!=
literal|0x20
condition|)
comment|/* not a Numonix flash */
return|return
operator|-
name|EINVAL
return|;
name|info
operator|>>=
literal|16
expr_stmt|;
comment|/* log2 of size */
if|if
condition|(
name|info
operator|>=
literal|0x14
operator|&&
name|info
operator|<
literal|0x18
condition|)
name|adapter
operator|->
name|params
operator|.
name|sf_nsec
operator|=
literal|1
operator|<<
operator|(
name|info
operator|-
literal|16
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|==
literal|0x18
condition|)
name|adapter
operator|->
name|params
operator|.
name|sf_nsec
operator|=
literal|64
expr_stmt|;
else|else
return|return
operator|-
name|EINVAL
return|;
name|adapter
operator|->
name|params
operator|.
name|sf_size
operator|=
literal|1
operator|<<
name|info
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__devinit
name|set_pcie_completion_timeout
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u8
name|range
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|u32
name|pcie_cap
decl_stmt|;
name|pcie_cap
operator|=
name|t4_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_cap
condition|)
block|{
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_DEVCTL2
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xfff0
expr_stmt|;
name|val
operator||=
name|range
expr_stmt|;
name|t4_os_pci_write_cfg2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_DEVCTL2
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_prep_adapter - prepare SW and HW for operation  *	@adapter: the adapter  *	@reset: if true perform a HW reset  *  *	Initialize adapter SW state for the various HW modules, set initial  *	values for some adapter tunables, take PHYs out of reset, and  *	initialize the MDIO interface.  */
end_comment

begin_function
name|int
name|__devinit
name|t4_prep_adapter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|uint32_t
name|pl_rev
decl_stmt|;
name|get_pci_mode
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|pci
argument_list|)
expr_stmt|;
name|pl_rev
operator|=
name|t4_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_REV
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|=
name|G_CHIPID
argument_list|(
name|pl_rev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|rev
operator|=
name|G_REV
argument_list|(
name|pl_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|==
literal|0
condition|)
block|{
comment|/* T4 did not have chipid in PL_REV (T5 onwards do) */
name|adapter
operator|->
name|params
operator|.
name|chipid
operator|=
name|CHELSIO_T4
expr_stmt|;
comment|/* T4A1 chip is not supported */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|1
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"T4 rev 1 chip is not supported.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
operator|=
name|t4_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_VPD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_flash_params
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|get_vpd_params
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|vpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* Cards with real ASICs have the chipid in the PCIe device id */
name|t4_os_pci_read_cfg2
argument_list|(
name|adapter
argument_list|,
name|PCI_DEVICE_ID
argument_list|,
operator|&
name|device_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_id
operator|>>
literal|12
operator|==
name|adapter
operator|->
name|params
operator|.
name|chipid
condition|)
name|adapter
operator|->
name|params
operator|.
name|cim_la_size
operator|=
name|CIMLA_SIZE
expr_stmt|;
else|else
block|{
comment|/* FPGA */
name|adapter
operator|->
name|params
operator|.
name|fpga
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|cim_la_size
operator|=
literal|2
operator|*
name|CIMLA_SIZE
expr_stmt|;
block|}
name|init_cong_ctrl
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|a_wnd
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|b_wnd
argument_list|)
expr_stmt|;
comment|/* 	 * Default port and clock for debugging in case we can't reach FW. 	 */
name|adapter
operator|->
name|params
operator|.
name|nports
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|portvec
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|=
literal|50000
expr_stmt|;
comment|/* Set pci completion timeout value to 4 seconds. */
name|set_pcie_completion_timeout
argument_list|(
name|adapter
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_init_tp_params - initialize adap->params.tp  *	@adap: the adapter  *  *	Initialize various fields of the adapter's TP Parameters structure.  */
end_comment

begin_function
name|int
name|__devinit
name|t4_init_tp_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
name|int
name|chan
decl_stmt|;
name|u32
name|v
decl_stmt|;
name|v
operator|=
name|t4_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TIMER_RESOLUTION
argument_list|)
expr_stmt|;
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|tre
operator|=
name|G_TIMERRESOLUTION
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|dack_re
operator|=
name|G_DELAYEDACKRESOLUTION
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* MODQ_REQ_MAP defaults to setting queues 0-3 to chan 0-3 */
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|NCHAN
condition|;
name|chan
operator|++
control|)
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_modq
index|[
name|chan
index|]
operator|=
name|chan
expr_stmt|;
comment|/* 	 * Cache the adapter's Compressed Filter Mode and global Incress 	 * Configuration. 	 */
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
argument_list|,
literal|1
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|)
expr_stmt|;
name|t4_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
operator|&
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|ingress_config
argument_list|,
literal|1
argument_list|,
name|A_TP_INGRESS_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we have TP_VLAN_PRI_MAP cached, we can calculate the field 	 * shift positions of several elements of the Compressed Filter Tuple 	 * for this adapter which we need frequently ... 	 */
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_VLAN
argument_list|)
expr_stmt|;
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|vnic_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_VNIC_ID
argument_list|)
expr_stmt|;
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|port_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_PORT
argument_list|)
expr_stmt|;
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|protocol_shift
operator|=
name|t4_filter_field_shift
argument_list|(
name|adap
argument_list|,
name|F_PROTOCOL
argument_list|)
expr_stmt|;
comment|/* 	 * If TP_INGRESS_CONFIG.VNID == 0, then TP_VLAN_PRI_MAP.VNIC_ID 	 * represents the presense of an Outer VLAN instead of a VNIC ID. 	 */
if|if
condition|(
operator|(
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|ingress_config
operator|&
name|F_VNIC
operator|)
operator|==
literal|0
condition|)
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|vnic_shift
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_filter_field_shift - calculate filter field shift  *	@adap: the adapter  *	@filter_sel: the desired field (from TP_VLAN_PRI_MAP bits)  *  *	Return the shift position of a filter field within the Compressed  *	Filter Tuple.  The filter field is specified via its selection bit  *	within TP_VLAN_PRI_MAL (filter mode).  E.g. F_VLAN.  */
end_comment

begin_function
name|int
name|t4_filter_field_shift
parameter_list|(
specifier|const
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|filter_sel
parameter_list|)
block|{
name|unsigned
name|int
name|filter_mode
init|=
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|vlan_pri_map
decl_stmt|;
name|unsigned
name|int
name|sel
decl_stmt|;
name|int
name|field_shift
decl_stmt|;
if|if
condition|(
operator|(
name|filter_mode
operator|&
name|filter_sel
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|sel
operator|=
literal|1
operator|,
name|field_shift
operator|=
literal|0
init|;
name|sel
operator|<
name|filter_sel
condition|;
name|sel
operator|<<=
literal|1
control|)
block|{
switch|switch
condition|(
name|filter_mode
operator|&
name|sel
condition|)
block|{
case|case
name|F_FCOE
case|:
name|field_shift
operator|+=
name|W_FT_FCOE
expr_stmt|;
break|break;
case|case
name|F_PORT
case|:
name|field_shift
operator|+=
name|W_FT_PORT
expr_stmt|;
break|break;
case|case
name|F_VNIC_ID
case|:
name|field_shift
operator|+=
name|W_FT_VNIC_ID
expr_stmt|;
break|break;
case|case
name|F_VLAN
case|:
name|field_shift
operator|+=
name|W_FT_VLAN
expr_stmt|;
break|break;
case|case
name|F_TOS
case|:
name|field_shift
operator|+=
name|W_FT_TOS
expr_stmt|;
break|break;
case|case
name|F_PROTOCOL
case|:
name|field_shift
operator|+=
name|W_FT_PROTOCOL
expr_stmt|;
break|break;
case|case
name|F_ETHERTYPE
case|:
name|field_shift
operator|+=
name|W_FT_ETHERTYPE
expr_stmt|;
break|break;
case|case
name|F_MACMATCH
case|:
name|field_shift
operator|+=
name|W_FT_MACMATCH
expr_stmt|;
break|break;
case|case
name|F_MPSHITTYPE
case|:
name|field_shift
operator|+=
name|W_FT_MPSHITTYPE
expr_stmt|;
break|break;
case|case
name|F_FRAGMENTATION
case|:
name|field_shift
operator|+=
name|W_FT_FRAGMENTATION
expr_stmt|;
break|break;
block|}
block|}
return|return
name|field_shift
return|;
block|}
end_function

begin_function
name|int
name|__devinit
name|t4_port_init
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|,
name|int
name|mbox
parameter_list|,
name|int
name|pf
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|u8
name|addr
index|[
literal|6
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|fw_port_cmd
name|c
decl_stmt|;
name|u16
name|rss_size
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|p
operator|->
name|port_id
condition|;
name|i
operator|++
control|)
block|{
do|do
block|{
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|adap
operator|->
name|params
operator|.
name|portvec
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
do|;
block|}
name|c
operator|.
name|op_to_portid
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_PORT_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_READ
operator||
name|V_FW_PORT_CMD_PORTID
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|action_to_len16
operator|=
name|htonl
argument_list|(
name|V_FW_PORT_CMD_ACTION
argument_list|(
name|FW_PORT_ACTION_GET_PORT_INFO
argument_list|)
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_wr_mbox
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|t4_alloc_vi
argument_list|(
name|adap
argument_list|,
name|mbox
argument_list|,
name|j
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
operator|&
name|rss_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|p
operator|->
name|viid
operator|=
name|ret
expr_stmt|;
name|p
operator|->
name|tx_chan
operator|=
name|j
expr_stmt|;
name|p
operator|->
name|rx_chan_map
operator|=
name|get_mps_bg_map
argument_list|(
name|adap
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p
operator|->
name|lport
operator|=
name|j
expr_stmt|;
name|p
operator|->
name|rss_size
operator|=
name|rss_size
expr_stmt|;
name|t4_os_set_hw_addr
argument_list|(
name|adap
argument_list|,
name|p
operator|->
name|port_id
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ntohl
argument_list|(
name|c
operator|.
name|u
operator|.
name|info
operator|.
name|lstatus_to_modtype
argument_list|)
expr_stmt|;
name|p
operator|->
name|mdio_addr
operator|=
operator|(
name|ret
operator|&
name|F_FW_PORT_CMD_MDIOCAP
operator|)
condition|?
name|G_FW_PORT_CMD_MDIOADDR
argument_list|(
name|ret
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|port_type
operator|=
name|G_FW_PORT_CMD_PTYPE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|p
operator|->
name|mod_type
operator|=
name|G_FW_PORT_CMD_MODTYPE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|init_link_config
argument_list|(
operator|&
name|p
operator|->
name|link_cfg
argument_list|,
name|ntohs
argument_list|(
name|c
operator|.
name|u
operator|.
name|info
operator|.
name|pcap
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|t4_sched_config
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|minmaxen
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_sched_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_SCHED_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|config
operator|.
name|sc
operator|=
name|FW_SCHED_SC_CONFIG
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|config
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|config
operator|.
name|minmaxen
operator|=
name|minmaxen
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t4_sched_params
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|rateunit
parameter_list|,
name|int
name|ratemode
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|cl
parameter_list|,
name|int
name|minrate
parameter_list|,
name|int
name|maxrate
parameter_list|,
name|int
name|weight
parameter_list|,
name|int
name|pktsize
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|struct
name|fw_sched_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_to_write
operator|=
name|cpu_to_be32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_SCHED_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|retval_len16
operator|=
name|cpu_to_be32
argument_list|(
name|FW_LEN16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|sc
operator|=
name|FW_SCHED_SC_PARAMS
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|ch
operator|=
name|channel
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|cl
operator|=
name|cl
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|unit
operator|=
name|rateunit
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|rate
operator|=
name|ratemode
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|min
operator|=
name|cpu_to_be32
argument_list|(
name|minrate
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|max
operator|=
name|cpu_to_be32
argument_list|(
name|maxrate
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|weight
operator|=
name|cpu_to_be16
argument_list|(
name|weight
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|params
operator|.
name|pktsize
operator|=
name|cpu_to_be16
argument_list|(
name|pktsize
argument_list|)
expr_stmt|;
return|return
name|t4_wr_mbox_meat
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|mbox
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sleep_ok
argument_list|)
return|;
block|}
end_function

end_unit

