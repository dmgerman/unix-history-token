begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__T4_ADAPTER_H__
end_ifndef

begin_define
define|#
directive|define
name|__T4_ADAPTER_H__
end_define

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_include
include|#
directive|include
file|"offload.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"firmware/t4fw_interface.h"
end_include

begin_define
define|#
directive|define
name|KTR_CXGBE
value|KTR_SPARE3
end_define

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_CXGBE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CXGBE_UNIMPLEMENTED
parameter_list|(
name|s
parameter_list|)
define|\
value|panic("%s (%s, line %d) not implemented yet.", s, __FILE__, __LINE__)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function
specifier|static
name|__inline
name|void
name|prefetch
parameter_list|(
name|void
modifier|*
name|x
parameter_list|)
block|{
asm|__asm volatile("prefetcht0 %0" :: "m" (*(unsigned long *)x));
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSCTL_ADD_UQUAD
end_ifndef

begin_define
define|#
directive|define
name|SYSCTL_ADD_UQUAD
value|SYSCTL_ADD_QUAD
end_define

begin_define
define|#
directive|define
name|sysctl_handle_64
value|sysctl_handle_quad
end_define

begin_define
define|#
directive|define
name|CTLTYPE_U64
value|CTLTYPE_QUAD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|900030
operator|)
operator|||
expr|\
operator|(
operator|(
name|__FreeBSD_version
operator|>=
literal|802507
operator|)
operator|&&
operator|(
name|__FreeBSD_version
operator|<
literal|900000
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|SBUF_DRAIN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_comment
comment|/* XXX: need systemwide bus_space_read_8/bus_space_write_8 */
end_comment

begin_function
specifier|static
name|__inline
name|uint64_t
name|t4_bus_space_read_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|handle
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tag
operator|==
name|X86_BUS_SPACE_MEM
argument_list|,
operator|(
literal|"%s: can only handle mem space"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
operator|(
specifier|volatile
name|uint64_t
operator|*
operator|)
operator|(
name|handle
operator|+
name|offset
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|t4_bus_space_write_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tag
operator|==
name|X86_BUS_SPACE_MEM
argument_list|,
operator|(
literal|"%s: can only handle mem space"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|uint64_t
operator|*
operator|)
operator|(
name|bsh
operator|+
name|offset
operator|)
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|__inline
name|uint64_t
name|t4_bus_space_read_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|handle
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
return|return
operator|(
name|uint64_t
operator|)
name|bus_space_read_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
argument_list|)
operator|+
operator|(
operator|(
name|uint64_t
operator|)
name|bus_space_read_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
operator|<<
literal|32
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|t4_bus_space_write_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|tag
argument_list|,
name|bsh
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|tag
argument_list|,
name|bsh
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|value
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|adapter
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|adapter
name|adapter_t
typedef|;
end_typedef

begin_enum
enum|enum
block|{
comment|/* 	 * All ingress queues use this entry size.  Note that the firmware event 	 * queue and any iq expecting CPL_RX_PKT in the descriptor needs this to 	 * be at least 64. 	 */
name|IQ_ESIZE
init|=
literal|64
block|,
comment|/* Default queue sizes for all kinds of ingress queues */
name|FW_IQ_QSIZE
init|=
literal|256
block|,
name|RX_IQ_QSIZE
init|=
literal|1024
block|,
comment|/* All egress queues use this entry size */
name|EQ_ESIZE
init|=
literal|64
block|,
comment|/* Default queue sizes for all kinds of egress queues */
name|CTRL_EQ_QSIZE
init|=
literal|128
block|,
name|TX_EQ_QSIZE
init|=
literal|1024
block|,
if|#
directive|if
name|MJUMPAGESIZE
operator|!=
name|MCLBYTES
name|SW_ZONE_SIZES
init|=
literal|4
block|,
comment|/* cluster, jumbop, jumbo9k, jumbo16k */
else|#
directive|else
name|SW_ZONE_SIZES
init|=
literal|3
block|,
comment|/* cluster, jumbo9k, jumbo16k */
endif|#
directive|endif
name|CL_METADATA_SIZE
init|=
name|CACHE_LINE_SIZE
block|,
name|SGE_MAX_WR_NDESC
init|=
name|SGE_MAX_WR_LEN
operator|/
name|EQ_ESIZE
block|,
comment|/* max WR size in desc */
name|TX_SGL_SEGS
init|=
literal|39
block|,
name|TX_SGL_SEGS_TSO
init|=
literal|38
block|,
name|TX_WR_FLITS
init|=
name|SGE_MAX_WR_LEN
operator|/
literal|8
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* adapter intr_type */
name|INTR_INTX
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|INTR_MSI
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|INTR_MSIX
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|XGMAC_MTU
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|XGMAC_PROMISC
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|XGMAC_ALLMULTI
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|XGMAC_VLANEX
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|XGMAC_UCADDR
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|XGMAC_MCADDRS
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|XGMAC_ALL
init|=
literal|0xffff
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* flags understood by begin_synchronized_op */
name|HOLD_LOCK
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|SLEEP_OK
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|INTR_OK
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
comment|/* flags understood by end_synchronized_op */
name|LOCK_HELD
init|=
name|HOLD_LOCK
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* adapter flags */
name|FULL_INIT_DONE
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|FW_OK
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
comment|/* INTR_DIRECT	= (1<< 2),	No longer used. */
name|MASTER_PF
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|ADAP_SYSCTL_CTX
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
comment|/* TOM_INIT_DONE= (1<< 5),	No longer used */
name|BUF_PACKING_OK
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|CXGBE_BUSY
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
comment|/* port flags */
name|DOOMED
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|PORT_INIT_DONE
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|PORT_SYSCTL_CTX
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|HAS_TRACEQ
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|INTR_RXQ
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
comment|/* All NIC rxq's take interrupts */
name|INTR_OFLD_RXQ
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
comment|/* All TOE rxq's take interrupts */
name|INTR_NM_RXQ
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
comment|/* All netmap rxq's take interrupts */
name|INTR_ALL
init|=
operator|(
name|INTR_RXQ
operator||
name|INTR_OFLD_RXQ
operator||
name|INTR_NM_RXQ
operator|)
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|IS_DOOMED
parameter_list|(
name|pi
parameter_list|)
value|((pi)->flags& DOOMED)
end_define

begin_define
define|#
directive|define
name|SET_DOOMED
parameter_list|(
name|pi
parameter_list|)
value|do {(pi)->flags |= DOOMED;} while (0)
end_define

begin_define
define|#
directive|define
name|IS_BUSY
parameter_list|(
name|sc
parameter_list|)
value|((sc)->flags& CXGBE_BUSY)
end_define

begin_define
define|#
directive|define
name|SET_BUSY
parameter_list|(
name|sc
parameter_list|)
value|do {(sc)->flags |= CXGBE_BUSY;} while (0)
end_define

begin_define
define|#
directive|define
name|CLR_BUSY
parameter_list|(
name|sc
parameter_list|)
value|do {(sc)->flags&= ~CXGBE_BUSY;} while (0)
end_define

begin_struct
struct|struct
name|port_info
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmedia
name|media
decl_stmt|;
name|struct
name|mtx
name|pi_lock
decl_stmt|;
name|char
name|lockname
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|if_flags
decl_stmt|;
name|uint16_t
modifier|*
name|rss
decl_stmt|;
name|uint16_t
name|viid
decl_stmt|;
name|int16_t
name|xact_addr_filt
decl_stmt|;
comment|/* index of exact MAC address filter */
name|uint16_t
name|rss_size
decl_stmt|;
comment|/* size of VI's RSS table slice */
name|uint8_t
name|lport
decl_stmt|;
comment|/* associated offload logical port */
name|int8_t
name|mdio_addr
decl_stmt|;
name|uint8_t
name|port_type
decl_stmt|;
name|uint8_t
name|mod_type
decl_stmt|;
name|uint8_t
name|port_id
decl_stmt|;
name|uint8_t
name|tx_chan
decl_stmt|;
name|uint8_t
name|rx_chan_map
decl_stmt|;
comment|/* rx MPS channel bitmap */
comment|/* These need to be int as they are used in sysctl */
name|int
name|ntxq
decl_stmt|;
comment|/* # of tx queues */
name|int
name|first_txq
decl_stmt|;
comment|/* index of first tx queue */
name|int
name|rsrv_noflowq
decl_stmt|;
comment|/* Reserve queue 0 for non-flowid packets */
name|int
name|nrxq
decl_stmt|;
comment|/* # of rx queues */
name|int
name|first_rxq
decl_stmt|;
comment|/* index of first rx queue */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|int
name|nofldtxq
decl_stmt|;
comment|/* # of offload tx queues */
name|int
name|first_ofld_txq
decl_stmt|;
comment|/* index of first offload tx queue */
name|int
name|nofldrxq
decl_stmt|;
comment|/* # of offload rx queues */
name|int
name|first_ofld_rxq
decl_stmt|;
comment|/* index of first offload rx queue */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|int
name|nnmtxq
decl_stmt|;
comment|/* # of netmap tx queues */
name|int
name|first_nm_txq
decl_stmt|;
comment|/* index of first netmap tx queue */
name|int
name|nnmrxq
decl_stmt|;
comment|/* # of netmap rx queues */
name|int
name|first_nm_rxq
decl_stmt|;
comment|/* index of first netmap rx queue */
name|struct
name|ifnet
modifier|*
name|nm_ifp
decl_stmt|;
name|struct
name|ifmedia
name|nm_media
decl_stmt|;
name|int
name|nmif_flags
decl_stmt|;
name|uint16_t
name|nm_viid
decl_stmt|;
name|int16_t
name|nm_xact_addr_filt
decl_stmt|;
name|uint16_t
name|nm_rss_size
decl_stmt|;
comment|/* size of netmap VI's RSS table slice */
endif|#
directive|endif
name|int
name|tmr_idx
decl_stmt|;
name|int
name|pktc_idx
decl_stmt|;
name|int
name|qsize_rxq
decl_stmt|;
name|int
name|qsize_txq
decl_stmt|;
name|int
name|linkdnrc
decl_stmt|;
name|struct
name|link_config
name|link_cfg
decl_stmt|;
name|struct
name|timeval
name|last_refreshed
decl_stmt|;
name|struct
name|port_stats
name|stats
decl_stmt|;
name|u_int
name|tnl_cong_drops
decl_stmt|;
name|u_int
name|tx_parse_error
decl_stmt|;
name|eventhandler_tag
name|vlan_c
decl_stmt|;
name|struct
name|callout
name|tick
decl_stmt|;
name|struct
name|sysctl_ctx_list
name|ctx
decl_stmt|;
comment|/* from ifconfig up to driver detach */
name|uint8_t
name|hw_addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* factory MAC address, won't change */
block|}
struct|;
end_struct

begin_comment
comment|/* Where the cluster came from, how it has been carved up. */
end_comment

begin_struct
struct|struct
name|cluster_layout
block|{
name|int8_t
name|zidx
decl_stmt|;
name|int8_t
name|hwidx
decl_stmt|;
name|uint16_t
name|region1
decl_stmt|;
comment|/* mbufs laid out within this region */
comment|/* region2 is the DMA region */
name|uint16_t
name|region3
decl_stmt|;
comment|/* cluster_metadata within this region */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cluster_metadata
block|{
name|u_int
name|refcount
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|fl_sdesc
modifier|*
name|sd
decl_stmt|;
comment|/* For debug only.  Could easily be stale */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fl_sdesc
block|{
name|caddr_t
name|cl
decl_stmt|;
name|uint16_t
name|nmbuf
decl_stmt|;
comment|/* # of driver originated mbufs with ref on cluster */
name|struct
name|cluster_layout
name|cll
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tx_desc
block|{
name|__be64
name|flit
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tx_sdesc
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* m_nextpkt linked chain of frames */
name|uint8_t
name|desc_used
decl_stmt|;
comment|/* # of hardware descriptors used by the WR */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IQ_PAD
value|(IQ_ESIZE - sizeof(struct rsp_ctrl) - sizeof(struct rss_header))
end_define

begin_struct
struct|struct
name|iq_desc
block|{
name|struct
name|rss_header
name|rss
decl_stmt|;
name|uint8_t
name|cpl
index|[
name|IQ_PAD
index|]
decl_stmt|;
name|struct
name|rsp_ctrl
name|rsp
decl_stmt|;
block|}
struct|;
end_struct

begin_undef
undef|#
directive|undef
name|IQ_PAD
end_undef

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iq_desc
argument_list|)
operator|==
name|IQ_ESIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
comment|/* iq flags */
name|IQ_ALLOCATED
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
comment|/* firmware resources allocated */
name|IQ_HAS_FL
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
comment|/* iq associated with a freelist */
name|IQ_INTR
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
comment|/* iq takes direct interrupt */
name|IQ_LRO_ENABLED
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
comment|/* iq is an eth rxq with LRO enabled */
comment|/* iq state */
name|IQS_DISABLED
init|=
literal|0
block|,
name|IQS_BUSY
init|=
literal|1
block|,
name|IQS_IDLE
init|=
literal|2
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Ingress Queue: T4 is producer, driver is consumer.  */
end_comment

begin_struct
struct|struct
name|sge_iq
block|{
name|uint32_t
name|flags
decl_stmt|;
specifier|volatile
name|int
name|state
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|iq_desc
modifier|*
name|desc
decl_stmt|;
comment|/* KVA of descriptor ring */
name|int8_t
name|intr_pktc_idx
decl_stmt|;
comment|/* packet count threshold index */
name|uint8_t
name|gen
decl_stmt|;
comment|/* generation bit */
name|uint8_t
name|intr_params
decl_stmt|;
comment|/* interrupt holdoff parameters */
name|uint8_t
name|intr_next
decl_stmt|;
comment|/* XXX: holdoff for next interrupt */
name|uint16_t
name|qsize
decl_stmt|;
comment|/* size (# of entries) of the queue */
name|uint16_t
name|sidx
decl_stmt|;
comment|/* index of the entry with the status page */
name|uint16_t
name|cidx
decl_stmt|;
comment|/* consumer index */
name|uint16_t
name|cntxt_id
decl_stmt|;
comment|/* SGE context id for the iq */
name|uint16_t
name|abs_id
decl_stmt|;
comment|/* absolute SGE id for the iq */
name|STAILQ_ENTRY
argument_list|(
argument|sge_iq
argument_list|)
name|link
expr_stmt|;
name|bus_dma_tag_t
name|desc_tag
decl_stmt|;
name|bus_dmamap_t
name|desc_map
decl_stmt|;
name|bus_addr_t
name|ba
decl_stmt|;
comment|/* bus address of descriptor ring */
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|EQ_CTRL
init|=
literal|1
block|,
name|EQ_ETH
init|=
literal|2
block|,
name|EQ_OFLD
init|=
literal|3
block|,
comment|/* eq flags */
name|EQ_TYPEMASK
init|=
literal|0x3
block|,
comment|/* 2 lsbits hold the type (see above) */
name|EQ_ALLOCATED
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
comment|/* firmware resources allocated */
name|EQ_ENABLED
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
comment|/* open for business */
block|}
enum|;
end_enum

begin_comment
comment|/* Listed in order of preference.  Update t4_sysctls too if you change these */
end_comment

begin_enum
enum|enum
block|{
name|DOORBELL_UDB
block|,
name|DOORBELL_WCWR
block|,
name|DOORBELL_UDBWC
block|,
name|DOORBELL_KDB
block|}
enum|;
end_enum

begin_comment
comment|/*  * Egress Queue: driver is producer, T4 is consumer.  *  * Note: A free list is an egress queue (driver produces the buffers and T4  * consumes them) but it's special enough to have its own struct (see sge_fl).  */
end_comment

begin_struct
struct|struct
name|sge_eq
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
comment|/* MUST be first */
name|unsigned
name|int
name|cntxt_id
decl_stmt|;
comment|/* SGE context id for the eq */
name|struct
name|mtx
name|eq_lock
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|desc
decl_stmt|;
comment|/* KVA of descriptor ring */
name|uint16_t
name|doorbells
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|udb
decl_stmt|;
comment|/* KVA of doorbell (lies within BAR2) */
name|u_int
name|udb_qid
decl_stmt|;
comment|/* relative qid within the doorbell page */
name|uint16_t
name|sidx
decl_stmt|;
comment|/* index of the entry with the status page */
name|uint16_t
name|cidx
decl_stmt|;
comment|/* consumer idx (desc idx) */
name|uint16_t
name|pidx
decl_stmt|;
comment|/* producer idx (desc idx) */
name|uint16_t
name|equeqidx
decl_stmt|;
comment|/* EQUEQ last requested at this pidx */
name|uint16_t
name|dbidx
decl_stmt|;
comment|/* pidx of the most recent doorbell */
name|uint16_t
name|iqid
decl_stmt|;
comment|/* iq that gets egr_update for the eq */
name|uint8_t
name|tx_chan
decl_stmt|;
comment|/* tx channel used by the eq */
specifier|volatile
name|u_int
name|equiq
decl_stmt|;
comment|/* EQUIQ outstanding */
name|bus_dma_tag_t
name|desc_tag
decl_stmt|;
name|bus_dmamap_t
name|desc_map
decl_stmt|;
name|bus_addr_t
name|ba
decl_stmt|;
comment|/* bus address of descriptor ring */
name|char
name|lockname
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sw_zone_info
block|{
name|uma_zone_t
name|zone
decl_stmt|;
comment|/* zone that this cluster comes from */
name|int
name|size
decl_stmt|;
comment|/* size of cluster: 2K, 4K, 9K, 16K, etc. */
name|int
name|type
decl_stmt|;
comment|/* EXT_xxx type of the cluster */
name|int8_t
name|head_hwidx
decl_stmt|;
name|int8_t
name|tail_hwidx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hw_buf_info
block|{
name|int8_t
name|zidx
decl_stmt|;
comment|/* backpointer to zone; -ve means unused */
name|int8_t
name|next
decl_stmt|;
comment|/* next hwidx for this zone; -1 means no more */
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|FL_STARVING
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
comment|/* on the adapter's list of starving fl's */
name|FL_DOOMED
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
comment|/* about to be destroyed */
name|FL_BUF_PACKING
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
comment|/* buffer packing enabled */
name|FL_BUF_RESUME
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
comment|/* resume from the middle of the frame */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|FL_RUNNING_LOW
parameter_list|(
name|fl
parameter_list|)
define|\
value|(IDXDIFF(fl->dbidx * 8, fl->cidx, fl->sidx * 8)<= fl->lowat)
end_define

begin_define
define|#
directive|define
name|FL_NOT_RUNNING_LOW
parameter_list|(
name|fl
parameter_list|)
define|\
value|(IDXDIFF(fl->dbidx * 8, fl->cidx, fl->sidx * 8)>= 2 * fl->lowat)
end_define

begin_struct
struct|struct
name|sge_fl
block|{
name|struct
name|mtx
name|fl_lock
decl_stmt|;
name|__be64
modifier|*
name|desc
decl_stmt|;
comment|/* KVA of descriptor ring, ptr to addresses */
name|struct
name|fl_sdesc
modifier|*
name|sdesc
decl_stmt|;
comment|/* KVA of software descriptor ring */
name|struct
name|cluster_layout
name|cll_def
decl_stmt|;
comment|/* default refill zone, layout */
name|uint16_t
name|lowat
decl_stmt|;
comment|/* # of buffers<= this means fl needs help */
name|int
name|flags
decl_stmt|;
name|uint16_t
name|buf_boundary
decl_stmt|;
comment|/* The 16b idx all deal with hw descriptors */
name|uint16_t
name|dbidx
decl_stmt|;
comment|/* hw pidx after last doorbell */
name|uint16_t
name|sidx
decl_stmt|;
comment|/* index of status page */
specifier|volatile
name|uint16_t
name|hw_cidx
decl_stmt|;
comment|/* The 32b idx are all buffer idx, not hardware descriptor idx */
name|uint32_t
name|cidx
decl_stmt|;
comment|/* consumer index */
name|uint32_t
name|pidx
decl_stmt|;
comment|/* producer index */
name|uint32_t
name|dbval
decl_stmt|;
name|u_int
name|rx_offset
decl_stmt|;
comment|/* offset in fl buf (when buffer packing) */
specifier|volatile
name|uint32_t
modifier|*
name|udb
decl_stmt|;
name|uint64_t
name|mbuf_allocated
decl_stmt|;
comment|/* # of mbuf allocated from zone_mbuf */
name|uint64_t
name|mbuf_inlined
decl_stmt|;
comment|/* # of mbuf created within clusters */
name|uint64_t
name|cl_allocated
decl_stmt|;
comment|/* # of clusters allocated */
name|uint64_t
name|cl_recycled
decl_stmt|;
comment|/* # of clusters recycled */
name|uint64_t
name|cl_fast_recycled
decl_stmt|;
comment|/* # of clusters recycled (fast) */
comment|/* These 3 are valid when FL_BUF_RESUME is set, stale otherwise. */
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|pnext
decl_stmt|;
name|u_int
name|remaining
decl_stmt|;
name|uint16_t
name|qsize
decl_stmt|;
comment|/* # of hw descriptors (status page included) */
name|uint16_t
name|cntxt_id
decl_stmt|;
comment|/* SGE context id for the freelist */
name|TAILQ_ENTRY
argument_list|(
argument|sge_fl
argument_list|)
name|link
expr_stmt|;
comment|/* All starving freelists */
name|bus_dma_tag_t
name|desc_tag
decl_stmt|;
name|bus_dmamap_t
name|desc_map
decl_stmt|;
name|char
name|lockname
index|[
literal|16
index|]
decl_stmt|;
name|bus_addr_t
name|ba
decl_stmt|;
comment|/* bus address of descriptor ring */
name|struct
name|cluster_layout
name|cll_alt
decl_stmt|;
comment|/* alternate refill zone, layout */
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|mp_ring
struct_decl|;
end_struct_decl

begin_comment
comment|/* txq: SGE egress queue + what's needed for Ethernet NIC */
end_comment

begin_struct
struct|struct
name|sge_txq
block|{
name|struct
name|sge_eq
name|eq
decl_stmt|;
comment|/* MUST be first */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* the interface this txq belongs to */
name|struct
name|mp_ring
modifier|*
name|r
decl_stmt|;
comment|/* tx software ring */
name|struct
name|tx_sdesc
modifier|*
name|sdesc
decl_stmt|;
comment|/* KVA of software descriptor ring */
name|struct
name|sglist
modifier|*
name|gl
decl_stmt|;
name|__be32
name|cpl_ctrl0
decl_stmt|;
comment|/* for convenience */
name|struct
name|task
name|tx_reclaim_task
decl_stmt|;
comment|/* stats for common events first */
name|uint64_t
name|txcsum
decl_stmt|;
comment|/* # of times hardware assisted with checksum */
name|uint64_t
name|tso_wrs
decl_stmt|;
comment|/* # of TSO work requests */
name|uint64_t
name|vlan_insertion
decl_stmt|;
comment|/* # of times VLAN tag was inserted */
name|uint64_t
name|imm_wrs
decl_stmt|;
comment|/* # of work requests with immediate data */
name|uint64_t
name|sgl_wrs
decl_stmt|;
comment|/* # of work requests with direct SGL */
name|uint64_t
name|txpkt_wrs
decl_stmt|;
comment|/* # of txpkt work requests (not coalesced) */
name|uint64_t
name|txpkts0_wrs
decl_stmt|;
comment|/* # of type0 coalesced tx work requests */
name|uint64_t
name|txpkts1_wrs
decl_stmt|;
comment|/* # of type1 coalesced tx work requests */
name|uint64_t
name|txpkts0_pkts
decl_stmt|;
comment|/* # of frames in type0 coalesced tx WRs */
name|uint64_t
name|txpkts1_pkts
decl_stmt|;
comment|/* # of frames in type1 coalesced tx WRs */
comment|/* stats for not-that-common events */
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_comment
comment|/* rxq: SGE ingress queue + SGE free list + miscellaneous items */
end_comment

begin_struct
struct|struct
name|sge_rxq
block|{
name|struct
name|sge_iq
name|iq
decl_stmt|;
comment|/* MUST be first */
name|struct
name|sge_fl
name|fl
decl_stmt|;
comment|/* MUST follow iq */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* the interface this rxq belongs to */
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|lro_ctrl
name|lro
decl_stmt|;
comment|/* LRO state */
endif|#
directive|endif
comment|/* stats for common events first */
name|uint64_t
name|rxcsum
decl_stmt|;
comment|/* # of times hardware assisted with checksum */
name|uint64_t
name|vlan_extraction
decl_stmt|;
comment|/* # of times VLAN tag was extracted */
comment|/* stats for not-that-common events */
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|sge_rxq
modifier|*
name|iq_to_rxq
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|)
block|{
return|return
operator|(
name|__containerof
argument_list|(
name|iq
argument_list|,
expr|struct
name|sge_rxq
argument_list|,
name|iq
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_comment
comment|/* ofld_rxq: SGE ingress queue + SGE free list + miscellaneous items */
end_comment

begin_struct
struct|struct
name|sge_ofld_rxq
block|{
name|struct
name|sge_iq
name|iq
decl_stmt|;
comment|/* MUST be first */
name|struct
name|sge_fl
name|fl
decl_stmt|;
comment|/* MUST follow iq */
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|sge_ofld_rxq
modifier|*
name|iq_to_ofld_rxq
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|)
block|{
return|return
operator|(
name|__containerof
argument_list|(
name|iq
argument_list|,
expr|struct
name|sge_ofld_rxq
argument_list|,
name|iq
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|wrqe
block|{
name|STAILQ_ENTRY
argument_list|(
argument|wrqe
argument_list|)
name|link
expr_stmt|;
name|struct
name|sge_wrq
modifier|*
name|wrq
decl_stmt|;
name|int
name|wr_len
decl_stmt|;
name|char
name|wr
index|[]
name|__aligned
argument_list|(
literal|16
argument_list|)
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wrq_cookie
block|{
name|TAILQ_ENTRY
argument_list|(
argument|wrq_cookie
argument_list|)
name|link
expr_stmt|;
name|int
name|ndesc
decl_stmt|;
name|int
name|pidx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * wrq: SGE egress queue that is given prebuilt work requests.  Both the control  * and offload tx queues are of this type.  */
end_comment

begin_struct
struct|struct
name|sge_wrq
block|{
name|struct
name|sge_eq
name|eq
decl_stmt|;
comment|/* MUST be first */
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|task
name|wrq_tx_task
decl_stmt|;
comment|/* Tx desc reserved but WR not "committed" yet. */
name|TAILQ_HEAD
argument_list|(
argument|wrq_incomplete_wrs
argument_list|,
argument|wrq_cookie
argument_list|)
name|incomplete_wrs
expr_stmt|;
comment|/* List of WRs ready to go out as soon as descriptors are available. */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|wrqe
argument_list|)
name|wr_list
expr_stmt|;
name|u_int
name|nwr_pending
decl_stmt|;
name|u_int
name|ndesc_needed
decl_stmt|;
comment|/* stats for common events first */
name|uint64_t
name|tx_wrs_direct
decl_stmt|;
comment|/* # of WRs written directly to desc ring. */
name|uint64_t
name|tx_wrs_ss
decl_stmt|;
comment|/* # of WRs copied from scratch space. */
name|uint64_t
name|tx_wrs_copied
decl_stmt|;
comment|/* # of WRs queued and copied to desc ring. */
comment|/* stats for not-that-common events */
comment|/* 	 * Scratch space for work requests that wrap around after reaching the 	 * status page, and some infomation about the last WR that used it. 	 */
name|uint16_t
name|ss_pidx
decl_stmt|;
name|uint16_t
name|ss_len
decl_stmt|;
name|uint8_t
name|ss
index|[
name|SGE_MAX_WR_LEN
index|]
decl_stmt|;
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_struct
struct|struct
name|sge_nm_rxq
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|iq_desc
modifier|*
name|iq_desc
decl_stmt|;
name|uint16_t
name|iq_abs_id
decl_stmt|;
name|uint16_t
name|iq_cntxt_id
decl_stmt|;
name|uint16_t
name|iq_cidx
decl_stmt|;
name|uint16_t
name|iq_sidx
decl_stmt|;
name|uint8_t
name|iq_gen
decl_stmt|;
name|__be64
modifier|*
name|fl_desc
decl_stmt|;
name|uint16_t
name|fl_cntxt_id
decl_stmt|;
name|uint32_t
name|fl_cidx
decl_stmt|;
name|uint32_t
name|fl_pidx
decl_stmt|;
name|uint32_t
name|fl_sidx
decl_stmt|;
name|uint32_t
name|fl_db_val
decl_stmt|;
name|u_int
name|fl_hwidx
range|:
literal|4
decl_stmt|;
name|u_int
name|nid
decl_stmt|;
comment|/* netmap ring # for this queue */
comment|/* infrequently used items after this */
name|bus_dma_tag_t
name|iq_desc_tag
decl_stmt|;
name|bus_dmamap_t
name|iq_desc_map
decl_stmt|;
name|bus_addr_t
name|iq_ba
decl_stmt|;
name|int
name|intr_idx
decl_stmt|;
name|bus_dma_tag_t
name|fl_desc_tag
decl_stmt|;
name|bus_dmamap_t
name|fl_desc_map
decl_stmt|;
name|bus_addr_t
name|fl_ba
decl_stmt|;
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|sge_nm_txq
block|{
name|struct
name|tx_desc
modifier|*
name|desc
decl_stmt|;
name|uint16_t
name|cidx
decl_stmt|;
name|uint16_t
name|pidx
decl_stmt|;
name|uint16_t
name|sidx
decl_stmt|;
name|uint16_t
name|equiqidx
decl_stmt|;
comment|/* EQUIQ last requested at this pidx */
name|uint16_t
name|equeqidx
decl_stmt|;
comment|/* EQUEQ last requested at this pidx */
name|uint16_t
name|dbidx
decl_stmt|;
comment|/* pidx of the most recent doorbell */
name|uint16_t
name|doorbells
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|udb
decl_stmt|;
name|u_int
name|udb_qid
decl_stmt|;
name|u_int
name|cntxt_id
decl_stmt|;
name|__be32
name|cpl_ctrl0
decl_stmt|;
comment|/* for convenience */
name|u_int
name|nid
decl_stmt|;
comment|/* netmap ring # for this queue */
comment|/* infrequently used items after this */
name|bus_dma_tag_t
name|desc_tag
decl_stmt|;
name|bus_dmamap_t
name|desc_map
decl_stmt|;
name|bus_addr_t
name|ba
decl_stmt|;
name|int
name|iqidx
decl_stmt|;
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|sge
block|{
name|int
name|timer_val
index|[
name|SGE_NTIMERS
index|]
decl_stmt|;
name|int
name|counter_val
index|[
name|SGE_NCOUNTERS
index|]
decl_stmt|;
name|int
name|fl_starve_threshold
decl_stmt|;
name|int
name|fl_starve_threshold2
decl_stmt|;
name|int
name|eq_s_qpp
decl_stmt|;
name|int
name|iq_s_qpp
decl_stmt|;
name|int
name|nrxq
decl_stmt|;
comment|/* total # of Ethernet rx queues */
name|int
name|ntxq
decl_stmt|;
comment|/* total # of Ethernet tx tx queues */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|int
name|nofldrxq
decl_stmt|;
comment|/* total # of TOE rx queues */
name|int
name|nofldtxq
decl_stmt|;
comment|/* total # of TOE tx queues */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|int
name|nnmrxq
decl_stmt|;
comment|/* total # of netmap rx queues */
name|int
name|nnmtxq
decl_stmt|;
comment|/* total # of netmap tx queues */
endif|#
directive|endif
name|int
name|niq
decl_stmt|;
comment|/* total # of ingress queues */
name|int
name|neq
decl_stmt|;
comment|/* total # of egress queues */
name|struct
name|sge_iq
name|fwq
decl_stmt|;
comment|/* Firmware event queue */
name|struct
name|sge_wrq
name|mgmtq
decl_stmt|;
comment|/* Management queue (control queue) */
name|struct
name|sge_wrq
modifier|*
name|ctrlq
decl_stmt|;
comment|/* Control queues */
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
comment|/* NIC tx queues */
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
comment|/* NIC rx queues */
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
comment|/* TOE tx queues */
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
comment|/* TOE rx queues */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
comment|/* netmap tx queues */
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
comment|/* netmap rx queues */
endif|#
directive|endif
name|uint16_t
name|iq_start
decl_stmt|;
name|int
name|eq_start
decl_stmt|;
name|struct
name|sge_iq
modifier|*
modifier|*
name|iqmap
decl_stmt|;
comment|/* iq->cntxt_id to iq mapping */
name|struct
name|sge_eq
modifier|*
modifier|*
name|eqmap
decl_stmt|;
comment|/* eq->cntxt_id to eq mapping */
name|int
name|pad_boundary
decl_stmt|;
name|int
name|pack_boundary
decl_stmt|;
name|int8_t
name|safe_hwidx1
decl_stmt|;
comment|/* may not have room for metadata */
name|int8_t
name|safe_hwidx2
decl_stmt|;
comment|/* with room for metadata and maybe more */
name|struct
name|sw_zone_info
name|sw_zone_info
index|[
name|SW_ZONE_SIZES
index|]
decl_stmt|;
name|struct
name|hw_buf_info
name|hw_buf_info
index|[
name|SGE_FLBUF_SIZES
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|rss_header
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|cpl_handler_t
function_decl|)
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|an_handler_t
function_decl|)
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|fw_msg_handler_t
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|__be64
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|adapter
block|{
name|SLIST_ENTRY
argument_list|(
argument|adapter
argument_list|)
name|link
expr_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
comment|/* PCIe register resources */
name|int
name|regs_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|regs_res
decl_stmt|;
name|int
name|msix_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|msix_res
decl_stmt|;
name|bus_space_handle_t
name|bh
decl_stmt|;
name|bus_space_tag_t
name|bt
decl_stmt|;
name|bus_size_t
name|mmio_len
decl_stmt|;
name|int
name|udbs_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|udbs_res
decl_stmt|;
specifier|volatile
name|uint8_t
modifier|*
name|udbs_base
decl_stmt|;
name|unsigned
name|int
name|pf
decl_stmt|;
name|unsigned
name|int
name|mbox
decl_stmt|;
comment|/* Interrupt information */
name|int
name|intr_type
decl_stmt|;
name|int
name|intr_count
decl_stmt|;
struct|struct
name|irq
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
block|}
modifier|*
name|irq
struct|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
comment|/* Parent DMA tag */
name|struct
name|sge
name|sge
decl_stmt|;
name|int
name|lro_timeout
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|tq
index|[
name|NCHAN
index|]
decl_stmt|;
comment|/* General purpose taskqueues */
name|struct
name|port_info
modifier|*
name|port
index|[
name|MAX_NPORTS
index|]
decl_stmt|;
name|uint8_t
name|chan_map
index|[
name|NCHAN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|void
modifier|*
name|tom_softc
decl_stmt|;
comment|/* (struct tom_data *) */
name|struct
name|tom_tunables
name|tt
decl_stmt|;
name|void
modifier|*
name|iwarp_softc
decl_stmt|;
comment|/* (struct c4iw_dev *) */
name|void
modifier|*
name|iscsi_softc
decl_stmt|;
endif|#
directive|endif
name|struct
name|l2t_data
modifier|*
name|l2t
decl_stmt|;
comment|/* L2 table */
name|struct
name|tid_info
name|tids
decl_stmt|;
name|uint16_t
name|doorbells
decl_stmt|;
name|int
name|open_device_map
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|int
name|offload_map
decl_stmt|;
comment|/* ports with IFCAP_TOE enabled */
name|int
name|active_ulds
decl_stmt|;
comment|/* ULDs activated on this adapter */
endif|#
directive|endif
name|int
name|flags
decl_stmt|;
name|char
name|ifp_lockname
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|mtx
name|ifp_lock
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* tracer ifp */
name|struct
name|ifmedia
name|media
decl_stmt|;
name|int
name|traceq
decl_stmt|;
comment|/* iq used by all tracers, -1 if none */
name|int
name|tracer_valid
decl_stmt|;
comment|/* bitmap of valid tracers */
name|int
name|tracer_enabled
decl_stmt|;
comment|/* bitmap of enabled tracers */
name|char
name|fw_version
index|[
literal|32
index|]
decl_stmt|;
name|char
name|cfg_file
index|[
literal|32
index|]
decl_stmt|;
name|u_int
name|cfcsum
decl_stmt|;
name|struct
name|adapter_params
name|params
decl_stmt|;
name|struct
name|t4_virt_res
name|vres
decl_stmt|;
name|uint16_t
name|linkcaps
decl_stmt|;
name|uint16_t
name|niccaps
decl_stmt|;
name|uint16_t
name|toecaps
decl_stmt|;
name|uint16_t
name|rdmacaps
decl_stmt|;
name|uint16_t
name|iscsicaps
decl_stmt|;
name|uint16_t
name|fcoecaps
decl_stmt|;
name|struct
name|sysctl_ctx_list
name|ctx
decl_stmt|;
comment|/* from adapter_full_init to full_uninit */
name|struct
name|mtx
name|sc_lock
decl_stmt|;
name|char
name|lockname
index|[
literal|16
index|]
decl_stmt|;
comment|/* Starving free lists */
name|struct
name|mtx
name|sfl_lock
decl_stmt|;
comment|/* same cache-line as sc_lock? but that's ok */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|sge_fl
argument_list|)
name|sfl
expr_stmt|;
name|struct
name|callout
name|sfl_callout
decl_stmt|;
name|struct
name|mtx
name|regwin_lock
decl_stmt|;
comment|/* for indirect reads and memory windows */
name|an_handler_t
name|an_handler
name|__aligned
parameter_list|(
name|CACHE_LINE_SIZE
parameter_list|)
function_decl|;
name|fw_msg_handler_t
name|fw_msg_handler
index|[
literal|5
index|]
decl_stmt|;
comment|/* NUM_FW6_TYPES */
name|cpl_handler_t
name|cpl_handler
index|[
literal|0xef
index|]
decl_stmt|;
comment|/* NUM_CPL_CMDS */
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|last_op
decl_stmt|;
specifier|const
name|void
modifier|*
name|last_op_thr
decl_stmt|;
endif|#
directive|endif
name|int
name|sc_do_rxcopy
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ADAPTER_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->sc_lock)
end_define

begin_define
define|#
directive|define
name|ADAPTER_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->sc_lock)
end_define

begin_define
define|#
directive|define
name|ADAPTER_LOCK_ASSERT_OWNED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->sc_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|ADAPTER_LOCK_ASSERT_NOTOWNED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->sc_lock, MA_NOTOWNED)
end_define

begin_define
define|#
directive|define
name|ASSERT_SYNCHRONIZED_OP
parameter_list|(
name|sc
parameter_list|)
define|\
value|KASSERT(IS_BUSY(sc)&& \ 	(mtx_owned(&(sc)->sc_lock) || sc->last_op_thr == curthread), \ 	("%s: operation not synchronized.", __func__))
end_define

begin_define
define|#
directive|define
name|PORT_LOCK
parameter_list|(
name|pi
parameter_list|)
value|mtx_lock(&(pi)->pi_lock)
end_define

begin_define
define|#
directive|define
name|PORT_UNLOCK
parameter_list|(
name|pi
parameter_list|)
value|mtx_unlock(&(pi)->pi_lock)
end_define

begin_define
define|#
directive|define
name|PORT_LOCK_ASSERT_OWNED
parameter_list|(
name|pi
parameter_list|)
value|mtx_assert(&(pi)->pi_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|PORT_LOCK_ASSERT_NOTOWNED
parameter_list|(
name|pi
parameter_list|)
value|mtx_assert(&(pi)->pi_lock, MA_NOTOWNED)
end_define

begin_define
define|#
directive|define
name|FL_LOCK
parameter_list|(
name|fl
parameter_list|)
value|mtx_lock(&(fl)->fl_lock)
end_define

begin_define
define|#
directive|define
name|FL_TRYLOCK
parameter_list|(
name|fl
parameter_list|)
value|mtx_trylock(&(fl)->fl_lock)
end_define

begin_define
define|#
directive|define
name|FL_UNLOCK
parameter_list|(
name|fl
parameter_list|)
value|mtx_unlock(&(fl)->fl_lock)
end_define

begin_define
define|#
directive|define
name|FL_LOCK_ASSERT_OWNED
parameter_list|(
name|fl
parameter_list|)
value|mtx_assert(&(fl)->fl_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|FL_LOCK_ASSERT_NOTOWNED
parameter_list|(
name|fl
parameter_list|)
value|mtx_assert(&(fl)->fl_lock, MA_NOTOWNED)
end_define

begin_define
define|#
directive|define
name|RXQ_FL_LOCK
parameter_list|(
name|rxq
parameter_list|)
value|FL_LOCK(&(rxq)->fl)
end_define

begin_define
define|#
directive|define
name|RXQ_FL_UNLOCK
parameter_list|(
name|rxq
parameter_list|)
value|FL_UNLOCK(&(rxq)->fl)
end_define

begin_define
define|#
directive|define
name|RXQ_FL_LOCK_ASSERT_OWNED
parameter_list|(
name|rxq
parameter_list|)
value|FL_LOCK_ASSERT_OWNED(&(rxq)->fl)
end_define

begin_define
define|#
directive|define
name|RXQ_FL_LOCK_ASSERT_NOTOWNED
parameter_list|(
name|rxq
parameter_list|)
value|FL_LOCK_ASSERT_NOTOWNED(&(rxq)->fl)
end_define

begin_define
define|#
directive|define
name|EQ_LOCK
parameter_list|(
name|eq
parameter_list|)
value|mtx_lock(&(eq)->eq_lock)
end_define

begin_define
define|#
directive|define
name|EQ_TRYLOCK
parameter_list|(
name|eq
parameter_list|)
value|mtx_trylock(&(eq)->eq_lock)
end_define

begin_define
define|#
directive|define
name|EQ_UNLOCK
parameter_list|(
name|eq
parameter_list|)
value|mtx_unlock(&(eq)->eq_lock)
end_define

begin_define
define|#
directive|define
name|EQ_LOCK_ASSERT_OWNED
parameter_list|(
name|eq
parameter_list|)
value|mtx_assert(&(eq)->eq_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|EQ_LOCK_ASSERT_NOTOWNED
parameter_list|(
name|eq
parameter_list|)
value|mtx_assert(&(eq)->eq_lock, MA_NOTOWNED)
end_define

begin_define
define|#
directive|define
name|TXQ_LOCK
parameter_list|(
name|txq
parameter_list|)
value|EQ_LOCK(&(txq)->eq)
end_define

begin_define
define|#
directive|define
name|TXQ_TRYLOCK
parameter_list|(
name|txq
parameter_list|)
value|EQ_TRYLOCK(&(txq)->eq)
end_define

begin_define
define|#
directive|define
name|TXQ_UNLOCK
parameter_list|(
name|txq
parameter_list|)
value|EQ_UNLOCK(&(txq)->eq)
end_define

begin_define
define|#
directive|define
name|TXQ_LOCK_ASSERT_OWNED
parameter_list|(
name|txq
parameter_list|)
value|EQ_LOCK_ASSERT_OWNED(&(txq)->eq)
end_define

begin_define
define|#
directive|define
name|TXQ_LOCK_ASSERT_NOTOWNED
parameter_list|(
name|txq
parameter_list|)
value|EQ_LOCK_ASSERT_NOTOWNED(&(txq)->eq)
end_define

begin_define
define|#
directive|define
name|for_each_txq
parameter_list|(
name|pi
parameter_list|,
name|iter
parameter_list|,
name|q
parameter_list|)
define|\
value|for (q =&pi->adapter->sge.txq[pi->first_txq], iter = 0; \ 	    iter< pi->ntxq; ++iter, ++q)
end_define

begin_define
define|#
directive|define
name|for_each_rxq
parameter_list|(
name|pi
parameter_list|,
name|iter
parameter_list|,
name|q
parameter_list|)
define|\
value|for (q =&pi->adapter->sge.rxq[pi->first_rxq], iter = 0; \ 	    iter< pi->nrxq; ++iter, ++q)
end_define

begin_define
define|#
directive|define
name|for_each_ofld_txq
parameter_list|(
name|pi
parameter_list|,
name|iter
parameter_list|,
name|q
parameter_list|)
define|\
value|for (q =&pi->adapter->sge.ofld_txq[pi->first_ofld_txq], iter = 0; \ 	    iter< pi->nofldtxq; ++iter, ++q)
end_define

begin_define
define|#
directive|define
name|for_each_ofld_rxq
parameter_list|(
name|pi
parameter_list|,
name|iter
parameter_list|,
name|q
parameter_list|)
define|\
value|for (q =&pi->adapter->sge.ofld_rxq[pi->first_ofld_rxq], iter = 0; \ 	    iter< pi->nofldrxq; ++iter, ++q)
end_define

begin_define
define|#
directive|define
name|for_each_nm_txq
parameter_list|(
name|pi
parameter_list|,
name|iter
parameter_list|,
name|q
parameter_list|)
define|\
value|for (q =&pi->adapter->sge.nm_txq[pi->first_nm_txq], iter = 0; \ 	    iter< pi->nnmtxq; ++iter, ++q)
end_define

begin_define
define|#
directive|define
name|for_each_nm_rxq
parameter_list|(
name|pi
parameter_list|,
name|iter
parameter_list|,
name|q
parameter_list|)
define|\
value|for (q =&pi->adapter->sge.nm_rxq[pi->first_nm_rxq], iter = 0; \ 	    iter< pi->nnmrxq; ++iter, ++q)
end_define

begin_define
define|#
directive|define
name|IDXINCR
parameter_list|(
name|idx
parameter_list|,
name|incr
parameter_list|,
name|wrap
parameter_list|)
value|do { \ 	idx = wrap - idx> incr ? idx + incr : incr - (wrap - idx); \ } while (0)
end_define

begin_define
define|#
directive|define
name|IDXDIFF
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|,
name|wrap
parameter_list|)
define|\
value|((head)>= (tail) ? (head) - (tail) : (wrap) - (tail) + (head))
end_define

begin_comment
comment|/* One for errors, one for firmware events */
end_comment

begin_define
define|#
directive|define
name|T4_EXTRA_INTR
value|2
end_define

begin_function
specifier|static
specifier|inline
name|uint32_t
name|t4_read_reg
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|bt
argument_list|,
name|sc
operator|->
name|bh
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_write_reg
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|bt
argument_list|,
name|sc
operator|->
name|bh
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|t4_read_reg64
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
return|return
name|t4_bus_space_read_8
argument_list|(
name|sc
operator|->
name|bt
argument_list|,
name|sc
operator|->
name|bh
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_write_reg64
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|t4_bus_space_write_8
argument_list|(
name|sc
operator|->
name|bt
argument_list|,
name|sc
operator|->
name|bh
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_os_pci_read_cfg1
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
operator|*
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_os_pci_write_cfg1
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_os_pci_read_cfg2
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint16_t
modifier|*
name|val
parameter_list|)
block|{
operator|*
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_os_pci_write_cfg2
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_os_pci_read_cfg4
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
operator|*
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_os_pci_write_cfg4
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|port_info
modifier|*
name|adap2pinfo
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|port
index|[
name|idx
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_os_set_hw_addr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint8_t
name|hw_addr
index|[]
parameter_list|)
block|{
name|bcopy
argument_list|(
name|hw_addr
argument_list|,
name|sc
operator|->
name|port
index|[
name|idx
index|]
operator|->
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|is_10G_port
parameter_list|(
specifier|const
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pi
operator|->
name|link_cfg
operator|.
name|supported
operator|&
name|FW_PORT_CAP_SPEED_10G
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|is_40G_port
parameter_list|(
specifier|const
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pi
operator|->
name|link_cfg
operator|.
name|supported
operator|&
name|FW_PORT_CAP_SPEED_40G
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|tx_resume_threshold
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
comment|/* not quite the same as qsize / 4, but this will do. */
return|return
operator|(
name|eq
operator|->
name|sidx
operator|/
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* t4_main.c */
end_comment

begin_function_decl
name|int
name|t4_os_find_pci_capability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_os_portmod_changed
parameter_list|(
specifier|const
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_os_link_changed
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_iterate
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_register_cpl_handler
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cpl_handler_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_register_an_handler
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|an_handler_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_register_fw_msg_handler
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|fw_msg_handler_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_filter_rpl
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|begin_synchronized_op
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|port_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|end_synchronized_op
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|update_mac_settings
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|adapter_full_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|adapter_full_uninit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|port_full_init
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|port_full_uninit
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_comment
comment|/* t4_netmap.c */
end_comment

begin_function_decl
name|int
name|create_netmap_ifnet
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|destroy_netmap_ifnet
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_nm_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* t4_sge.c */
end_comment

begin_function_decl
name|void
name|t4_sge_modload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_sge_modunload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|t4_sge_extfree_refs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_init_sge_cpl_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_tweak_chip_settings
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_read_chip_settings
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_create_dma_tag
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_sge_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_destroy_dma_tag
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_setup_adapter_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_teardown_adapter_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_setup_port_queues
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_teardown_port_queues
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_intr_all
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_intr_err
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_intr_evt
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_wrq_tx_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_wrq
modifier|*
parameter_list|,
name|struct
name|wrqe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_update_fl_bufsize
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|parse_pkt
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|start_wrq_wr
parameter_list|(
name|struct
name|sge_wrq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|wrq_cookie
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|commit_wrq_wr
parameter_list|(
name|struct
name|sge_wrq
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|wrq_cookie
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tnl_cong
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* t4_tracer.c */
end_comment

begin_struct_decl
struct_decl|struct
name|t4_tracer
struct_decl|;
end_struct_decl

begin_function_decl
name|void
name|t4_tracer_modload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_tracer_modunload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|t4_tracer_port_detach
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_get_tracer
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_tracer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_set_tracer
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|t4_tracer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t4_trace_pkt
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t5_trace_pkt
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|struct
name|wrqe
modifier|*
name|alloc_wrqe
parameter_list|(
name|int
name|wr_len
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|)
block|{
name|int
name|len
init|=
name|offsetof
argument_list|(
expr|struct
name|wrqe
argument_list|,
name|wr
argument_list|)
operator|+
name|wr_len
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|wr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|wr
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|wr
operator|->
name|wr_len
operator|=
name|wr_len
expr_stmt|;
name|wr
operator|->
name|wrq
operator|=
name|wrq
expr_stmt|;
return|return
operator|(
name|wr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|wrtod
parameter_list|(
name|struct
name|wrqe
modifier|*
name|wr
parameter_list|)
block|{
return|return
operator|(
operator|&
name|wr
operator|->
name|wr
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_wrqe
parameter_list|(
name|struct
name|wrqe
modifier|*
name|wr
parameter_list|)
block|{
name|free
argument_list|(
name|wr
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|t4_wrq_tx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|wrqe
modifier|*
name|wr
parameter_list|)
block|{
name|struct
name|sge_wrq
modifier|*
name|wrq
init|=
name|wr
operator|->
name|wrq
decl_stmt|;
name|TXQ_LOCK
argument_list|(
name|wrq
argument_list|)
expr_stmt|;
name|t4_wrq_tx_locked
argument_list|(
name|sc
argument_list|,
name|wrq
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|wrq
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

