begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Chelsio Communications, Inc.  * All rights reserved.  * Written by: John Baldwin<jhb@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/xform.h>
end_include

begin_include
include|#
directive|include
file|"cryptodev_if.h"
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"crypto/t4_crypto.h"
end_include

begin_comment
comment|/*  * Requests consist of:  *  * +-------------------------------+  * | struct fw_crypto_lookaside_wr |  * +-------------------------------+  * | struct ulp_txpkt              |  * +-------------------------------+  * | struct ulptx_idata            |  * +-------------------------------+  * | struct cpl_tx_sec_pdu         |  * +-------------------------------+  * | struct cpl_tls_tx_scmd_fmt    |  * +-------------------------------+  * | key context header            |  * +-------------------------------+  * | AES key                       |  ----- For requests with AES  * +-------------------------------+ -  * | IPAD (16-byte aligned)        |  \  * +-------------------------------+  +---- For requests with HMAC  * | OPAD (16-byte aligned)        |  /  * +-------------------------------+ -  * | GMAC H                        |  ----- For AES-GCM  * +-------------------------------+ -  * | struct cpl_rx_phys_dsgl       |  \  * +-------------------------------+  +---- Destination buffer for  * | PHYS_DSGL entries             |  /     non-hash-only requests  * +-------------------------------+ -  * | 16 dummy bytes                |  ----- Only for hash-only requests  * +-------------------------------+  * | IV                            |  ----- If immediate IV  * +-------------------------------+  * | Payload                       |  ----- If immediate Payload  * +-------------------------------+ -  * | struct ulptx_sgl              |  \  * +-------------------------------+  +---- If payload via SGL  * | SGL entries                   |  /  * +-------------------------------+ -  *  * Note that the key context must be padded to ensure 16-byte alignment.  * For HMAC requests, the key consists of the partial hash of the IPAD  * followed by the partial hash of the OPAD.  *  * Replies consist of:  *  * +-------------------------------+  * | struct cpl_fw6_pld            |  * +-------------------------------+  * | hash digest                   |  ----- For HMAC request with  * +-------------------------------+        'hash_size' set in work request  *  * A 32-bit big-endian error status word is supplied in the last 4  * bytes of data[0] in the CPL_FW6_PLD message.  bit 0 indicates a  * "MAC" error and bit 1 indicates a "PAD" error.  *  * The 64-bit 'cookie' field from the fw_crypto_lookaside_wr message  * in the request is returned in data[1] of the CPL_FW6_PLD message.  *  * For block cipher replies, the updated IV is supplied in data[2] and  * data[3] of the CPL_FW6_PLD message.  *  * For hash replies where the work request set 'hash_size' to request  * a copy of the hash in the reply, the hash digest is supplied  * immediately following the CPL_FW6_PLD message.  */
end_comment

begin_comment
comment|/*  * The documentation for CPL_RX_PHYS_DSGL claims a maximum of 32  * SG entries.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RX_PHYS_DSGL_SGE
value|32
end_define

begin_define
define|#
directive|define
name|DSGL_SGE_MAXLEN
value|65535
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CCR
argument_list|,
literal|"ccr"
argument_list|,
literal|"Chelsio T6 crypto"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ccr_session_hmac
block|{
name|struct
name|auth_hash
modifier|*
name|auth_hash
decl_stmt|;
name|int
name|hash_len
decl_stmt|;
name|unsigned
name|int
name|partial_digest_len
decl_stmt|;
name|unsigned
name|int
name|auth_mode
decl_stmt|;
name|unsigned
name|int
name|mk_size
decl_stmt|;
name|char
name|ipad
index|[
name|CHCR_HASH_MAX_BLOCK_SIZE_128
index|]
decl_stmt|;
name|char
name|opad
index|[
name|CHCR_HASH_MAX_BLOCK_SIZE_128
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ccr_session_gmac
block|{
name|int
name|hash_len
decl_stmt|;
name|char
name|ghash_h
index|[
name|GMAC_BLOCK_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ccr_session_blkcipher
block|{
name|unsigned
name|int
name|cipher_mode
decl_stmt|;
name|unsigned
name|int
name|key_len
decl_stmt|;
name|unsigned
name|int
name|iv_len
decl_stmt|;
name|__be32
name|key_ctx_hdr
decl_stmt|;
name|char
name|enckey
index|[
name|CHCR_AES_MAX_KEY_LEN
index|]
decl_stmt|;
name|char
name|deckey
index|[
name|CHCR_AES_MAX_KEY_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ccr_session
block|{
name|bool
name|active
decl_stmt|;
name|int
name|pending
decl_stmt|;
enum|enum
block|{
name|HMAC
block|,
name|BLKCIPHER
block|,
name|AUTHENC
block|,
name|GCM
block|}
name|mode
enum|;
union|union
block|{
name|struct
name|ccr_session_hmac
name|hmac
decl_stmt|;
name|struct
name|ccr_session_gmac
name|gmac
decl_stmt|;
block|}
union|;
name|struct
name|ccr_session_blkcipher
name|blkcipher
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ccr_softc
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|cid
decl_stmt|;
name|int
name|tx_channel_id
decl_stmt|;
name|struct
name|ccr_session
modifier|*
name|sessions
decl_stmt|;
name|int
name|nsessions
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|bool
name|detaching
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
comment|/* 	 * Pre-allocate S/G lists used when preparing a work request. 	 * 'sg_crp' contains an sglist describing the entire buffer 	 * for a 'struct cryptop'.  'sg_ulptx' is used to describe 	 * the data the engine should DMA as input via ULPTX_SGL. 	 * 'sg_dsgl' is used to describe the destination that cipher 	 * text and a tag should be written to. 	 */
name|struct
name|sglist
modifier|*
name|sg_crp
decl_stmt|;
name|struct
name|sglist
modifier|*
name|sg_ulptx
decl_stmt|;
name|struct
name|sglist
modifier|*
name|sg_dsgl
decl_stmt|;
comment|/* Statistics. */
name|uint64_t
name|stats_blkcipher_encrypt
decl_stmt|;
name|uint64_t
name|stats_blkcipher_decrypt
decl_stmt|;
name|uint64_t
name|stats_hmac
decl_stmt|;
name|uint64_t
name|stats_authenc_encrypt
decl_stmt|;
name|uint64_t
name|stats_authenc_decrypt
decl_stmt|;
name|uint64_t
name|stats_gcm_encrypt
decl_stmt|;
name|uint64_t
name|stats_gcm_decrypt
decl_stmt|;
name|uint64_t
name|stats_wr_nomem
decl_stmt|;
name|uint64_t
name|stats_inflight
decl_stmt|;
name|uint64_t
name|stats_mac_error
decl_stmt|;
name|uint64_t
name|stats_pad_error
decl_stmt|;
name|uint64_t
name|stats_bad_session
decl_stmt|;
name|uint64_t
name|stats_sglist_error
decl_stmt|;
name|uint64_t
name|stats_process_error
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Crypto requests involve two kind of scatter/gather lists.  *  * Non-hash-only requests require a PHYS_DSGL that describes the  * location to store the results of the encryption or decryption  * operation.  This SGL uses a different format (PHYS_DSGL) and should  * exclude the crd_skip bytes at the start of the data as well as  * any AAD or IV.  For authenticated encryption requests it should  * cover include the destination of the hash or tag.  *  * The input payload may either be supplied inline as immediate data,  * or via a standard ULP_TX SGL.  This SGL should include AAD,  * ciphertext, and the hash or tag for authenticated decryption  * requests.  *  * These scatter/gather lists can describe different subsets of the  * buffer described by the crypto operation.  ccr_populate_sglist()  * generates a scatter/gather list that covers the entire crypto  * operation buffer that is then used to construct the other  * scatter/gather lists.  */
end_comment

begin_function
specifier|static
name|int
name|ccr_populate_sglist
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sglist_reset
argument_list|(
name|sg
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
name|error
operator|=
name|sglist_append_mbuf
argument_list|(
name|sg
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
name|error
operator|=
name|sglist_append_uio
argument_list|(
name|sg
argument_list|,
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sglist_append
argument_list|(
name|sg
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crp
operator|->
name|crp_ilen
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Segments in 'sg' larger than 'maxsegsize' are counted as multiple  * segments.  */
end_comment

begin_function
specifier|static
name|int
name|ccr_count_sgl
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|int
name|maxsegsize
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nsegs
decl_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg
operator|->
name|sg_nseg
condition|;
name|i
operator|++
control|)
name|nsegs
operator|+=
name|howmany
argument_list|(
name|sg
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
argument_list|,
name|maxsegsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|nsegs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* These functions deal with PHYS_DSGL for the reply buffer. */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ccr_phys_dsgl_len
parameter_list|(
name|int
name|nsegs
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|nsegs
operator|/
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|phys_sge_pairs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nsegs
operator|%
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
literal|8
expr_stmt|;
name|len
operator|+=
name|roundup2
argument_list|(
name|nsegs
operator|%
literal|8
argument_list|,
literal|2
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_write_phys_dsgl
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|struct
name|cpl_rx_phys_dsgl
modifier|*
name|cpl
decl_stmt|;
name|struct
name|phys_sge_pairs
modifier|*
name|sgl
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|size_t
name|seglen
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sg
operator|=
name|sc
operator|->
name|sg_dsgl
expr_stmt|;
name|cpl
operator|=
name|dst
expr_stmt|;
name|cpl
operator|->
name|op_to_tid
operator|=
name|htobe32
argument_list|(
name|V_CPL_RX_PHYS_DSGL_OPCODE
argument_list|(
name|CPL_RX_PHYS_DSGL
argument_list|)
operator||
name|V_CPL_RX_PHYS_DSGL_ISRDMA
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|pcirlxorder_to_noofsgentr
operator|=
name|htobe32
argument_list|(
name|V_CPL_RX_PHYS_DSGL_PCIRLXORDER
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_RX_PHYS_DSGL_PCINOSNOOP
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_RX_PHYS_DSGL_PCITPHNTENB
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_RX_PHYS_DSGL_DCAID
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_RX_PHYS_DSGL_NOOFSGENTR
argument_list|(
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|rss_hdr_int
operator|.
name|opcode
operator|=
name|CPL_RX_PHYS_ADDR
expr_stmt|;
name|cpl
operator|->
name|rss_hdr_int
operator|.
name|qid
operator|=
name|htobe16
argument_list|(
name|sc
operator|->
name|rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|rss_hdr_int
operator|.
name|hash_val
operator|=
literal|0
expr_stmt|;
name|sgl
operator|=
operator|(
expr|struct
name|phys_sge_pairs
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg
operator|->
name|sg_nseg
condition|;
name|i
operator|++
control|)
block|{
name|seglen
operator|=
name|sg
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
expr_stmt|;
name|paddr
operator|=
name|sg
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_paddr
expr_stmt|;
do|do
block|{
name|sgl
operator|->
name|addr
index|[
name|j
index|]
operator|=
name|htobe64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|seglen
operator|>
name|DSGL_SGE_MAXLEN
condition|)
block|{
name|sgl
operator|->
name|len
index|[
name|j
index|]
operator|=
name|htobe16
argument_list|(
name|DSGL_SGE_MAXLEN
argument_list|)
expr_stmt|;
name|paddr
operator|+=
name|DSGL_SGE_MAXLEN
expr_stmt|;
name|seglen
operator|-=
name|DSGL_SGE_MAXLEN
expr_stmt|;
block|}
else|else
block|{
name|sgl
operator|->
name|len
index|[
name|j
index|]
operator|=
name|htobe16
argument_list|(
name|seglen
argument_list|)
expr_stmt|;
name|seglen
operator|=
literal|0
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|8
condition|)
block|{
name|sgl
operator|++
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|seglen
operator|!=
literal|0
condition|)
do|;
block|}
name|MPASS
argument_list|(
name|j
operator|+
literal|8
operator|*
operator|(
name|sgl
operator|-
operator|(
expr|struct
name|phys_sge_pairs
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
operator|)
operator|==
name|nsegs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These functions deal with the ULPTX_SGL for input payload. */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ccr_ulptx_sgl_len
parameter_list|(
name|int
name|nsegs
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|nsegs
operator|--
expr_stmt|;
comment|/* first segment is part of ulptx_sgl */
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_sgl
argument_list|)
operator|+
literal|8
operator|*
operator|(
operator|(
literal|3
operator|*
name|nsegs
operator|)
operator|/
literal|2
operator|+
operator|(
name|nsegs
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|roundup2
argument_list|(
name|n
argument_list|,
literal|16
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_write_ulptx_sgl
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|struct
name|ulptx_sgl
modifier|*
name|usgl
decl_stmt|;
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|struct
name|sglist_seg
modifier|*
name|ss
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sg
operator|=
name|sc
operator|->
name|sg_ulptx
expr_stmt|;
name|MPASS
argument_list|(
name|nsegs
operator|==
name|sg
operator|->
name|sg_nseg
argument_list|)
expr_stmt|;
name|ss
operator|=
operator|&
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
expr_stmt|;
name|usgl
operator|=
name|dst
expr_stmt|;
name|usgl
operator|->
name|cmd_nsge
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_DSGL
argument_list|)
operator||
name|V_ULPTX_NSGE
argument_list|(
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|len0
operator|=
name|htobe32
argument_list|(
name|ss
operator|->
name|ss_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|addr0
operator|=
name|htobe64
argument_list|(
name|ss
operator|->
name|ss_paddr
argument_list|)
expr_stmt|;
name|ss
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg
operator|->
name|sg_nseg
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|len
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|ss
operator|->
name|ss_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|addr
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|ss
operator|->
name|ss_paddr
argument_list|)
expr_stmt|;
name|ss
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|ccr_use_imm_data
parameter_list|(
name|u_int
name|transhdr_len
parameter_list|,
name|u_int
name|input_len
parameter_list|)
block|{
if|if
condition|(
name|input_len
operator|>
name|CRYPTO_MAX_IMM_TX_PKT_LEN
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|roundup2
argument_list|(
name|transhdr_len
argument_list|,
literal|16
argument_list|)
operator|+
name|roundup2
argument_list|(
name|input_len
argument_list|,
literal|16
argument_list|)
operator|>
name|SGE_MAX_WR_LEN
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_populate_wreq
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chcr_wr
modifier|*
name|crwr
parameter_list|,
name|u_int
name|kctx_len
parameter_list|,
name|u_int
name|wr_len
parameter_list|,
name|uint32_t
name|sid
parameter_list|,
name|u_int
name|imm_len
parameter_list|,
name|u_int
name|sgl_len
parameter_list|,
name|u_int
name|hash_size
parameter_list|,
name|u_int
name|iv_loc
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|u_int
name|cctx_size
decl_stmt|;
name|cctx_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|_key_ctx
argument_list|)
operator|+
name|kctx_len
expr_stmt|;
name|crwr
operator|->
name|wreq
operator|.
name|op_to_cctx_size
operator|=
name|htobe32
argument_list|(
name|V_FW_CRYPTO_LOOKASIDE_WR_OPCODE
argument_list|(
name|FW_CRYPTO_LOOKASIDE_WR
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_COMPL
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_IMM_LEN
argument_list|(
name|imm_len
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_CCTX_LOC
argument_list|(
literal|1
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_CCTX_SIZE
argument_list|(
name|cctx_size
operator|>>
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|wreq
operator|.
name|len16_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_CRYPTO_LOOKASIDE_WR_LEN16
argument_list|(
name|wr_len
operator|/
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|wreq
operator|.
name|session_id
operator|=
name|htobe32
argument_list|(
name|sid
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|wreq
operator|.
name|rx_chid_to_rx_q_id
operator|=
name|htobe32
argument_list|(
name|V_FW_CRYPTO_LOOKASIDE_WR_RX_CHID
argument_list|(
name|sc
operator|->
name|tx_channel_id
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_LCB
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_PHASH
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_IV
argument_list|(
name|iv_loc
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_FQIDX
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_TX_CH
argument_list|(
literal|0
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_RX_Q_ID
argument_list|(
name|sc
operator|->
name|rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|wreq
operator|.
name|key_addr
operator|=
literal|0
expr_stmt|;
name|crwr
operator|->
name|wreq
operator|.
name|pld_size_hash_size
operator|=
name|htobe32
argument_list|(
name|V_FW_CRYPTO_LOOKASIDE_WR_PLD_SIZE
argument_list|(
name|sgl_len
argument_list|)
operator||
name|V_FW_CRYPTO_LOOKASIDE_WR_HASH_SIZE
argument_list|(
name|hash_size
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|wreq
operator|.
name|cookie
operator|=
name|htobe64
argument_list|(
operator|(
name|uintptr_t
operator|)
name|crp
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|ulptx
operator|.
name|cmd_dest
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_PKT
argument_list|)
operator||
name|V_ULP_TXPKT_DATAMODIFY
argument_list|(
literal|0
argument_list|)
operator||
name|V_ULP_TXPKT_CHANNELID
argument_list|(
name|sc
operator|->
name|tx_channel_id
argument_list|)
operator||
name|V_ULP_TXPKT_DEST
argument_list|(
literal|0
argument_list|)
operator||
name|V_ULP_TXPKT_FID
argument_list|(
literal|0
argument_list|)
operator||
name|V_ULP_TXPKT_RO
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|ulptx
operator|.
name|len
operator|=
name|htobe32
argument_list|(
operator|(
operator|(
name|wr_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|fw_crypto_lookaside_wr
argument_list|)
operator|)
operator|/
literal|16
operator|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sc_imm
operator|.
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
operator||
name|V_ULP_TX_SC_MORE
argument_list|(
name|imm_len
operator|!=
literal|0
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sc_imm
operator|.
name|len
operator|=
name|htobe32
argument_list|(
name|wr_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|chcr_wr
argument_list|,
name|sec_cpl
argument_list|)
operator|-
name|sgl_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_hmac
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sid
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|struct
name|chcr_wr
modifier|*
name|crwr
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|axf
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_int
name|hash_size_in_response
decl_stmt|,
name|kctx_flits
decl_stmt|,
name|kctx_len
decl_stmt|,
name|transhdr_len
decl_stmt|,
name|wr_len
decl_stmt|;
name|u_int
name|imm_len
decl_stmt|,
name|iopad_size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sgl_nsegs
decl_stmt|,
name|sgl_len
decl_stmt|;
name|axf
operator|=
name|s
operator|->
name|hmac
operator|.
name|auth_hash
expr_stmt|;
comment|/* PADs must be 128-bit aligned. */
name|iopad_size
operator|=
name|roundup2
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* 	 * The 'key' part of the context includes the aligned IPAD and 	 * OPAD. 	 */
name|kctx_len
operator|=
name|iopad_size
operator|*
literal|2
expr_stmt|;
name|hash_size_in_response
operator|=
name|axf
operator|->
name|hashsize
expr_stmt|;
name|transhdr_len
operator|=
name|HASH_TRANSHDR_SIZE
argument_list|(
name|kctx_len
argument_list|)
expr_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
if|if
condition|(
name|ccr_use_imm_data
argument_list|(
name|transhdr_len
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|)
condition|)
block|{
name|imm_len
operator|=
name|crd
operator|->
name|crd_len
expr_stmt|;
name|sgl_nsegs
operator|=
literal|0
expr_stmt|;
name|sgl_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|imm_len
operator|=
literal|0
expr_stmt|;
name|sglist_reset
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sgl_nsegs
operator|=
name|sc
operator|->
name|sg_ulptx
operator|->
name|sg_nseg
expr_stmt|;
name|sgl_len
operator|=
name|ccr_ulptx_sgl_len
argument_list|(
name|sgl_nsegs
argument_list|)
expr_stmt|;
block|}
name|wr_len
operator|=
name|roundup2
argument_list|(
name|transhdr_len
argument_list|,
literal|16
argument_list|)
operator|+
name|roundup2
argument_list|(
name|imm_len
argument_list|,
literal|16
argument_list|)
operator|+
name|sgl_len
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|wr_len
argument_list|,
name|sc
operator|->
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|stats_wr_nomem
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|crwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|crwr
argument_list|,
literal|0
argument_list|,
name|wr_len
argument_list|)
expr_stmt|;
name|ccr_populate_wreq
argument_list|(
name|sc
argument_list|,
name|crwr
argument_list|,
name|kctx_len
argument_list|,
name|wr_len
argument_list|,
name|sid
argument_list|,
name|imm_len
argument_list|,
name|sgl_len
argument_list|,
name|hash_size_in_response
argument_list|,
name|IV_NOP
argument_list|,
name|crp
argument_list|)
expr_stmt|;
comment|/* XXX: Hardcodes SGE loopback channel of 0. */
name|crwr
operator|->
name|sec_cpl
operator|.
name|op_ivinsrtofst
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_OPCODE
argument_list|(
name|CPL_TX_SEC_PDU
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_RXCHID
argument_list|(
name|sc
operator|->
name|tx_channel_id
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ACKFOLLOWS
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ULPTXLPBK
argument_list|(
literal|1
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CPLLEN
argument_list|(
literal|2
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_PLACEHOLDER
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_IVINSRTOFST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|pldlen
operator|=
name|htobe32
argument_list|(
name|crd
operator|->
name|crd_len
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|cipherstop_lo_authinsert
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_AUTHSTART
argument_list|(
literal|1
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AUTHSTOP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These two flits are actually a CPL_TLS_TX_SCMD_FMT. */
name|crwr
operator|->
name|sec_cpl
operator|.
name|seqno_numivs
operator|=
name|htobe32
argument_list|(
name|V_SCMD_SEQ_NO_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_PROTO_VERSION
argument_list|(
name|CHCR_SCMD_PROTO_VERSION_GENERIC
argument_list|)
operator||
name|V_SCMD_CIPH_MODE
argument_list|(
name|CHCR_SCMD_CIPHER_MODE_NOP
argument_list|)
operator||
name|V_SCMD_AUTH_MODE
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|auth_mode
argument_list|)
operator||
name|V_SCMD_HMAC_CTRL
argument_list|(
name|CHCR_SCMD_HMAC_CTRL_NO_TRUNC
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|ivgen_hdrlen
operator|=
name|htobe32
argument_list|(
name|V_SCMD_LAST_FRAG
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MORE_FRAGS
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MAC_ONLY
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|ipad
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
operator|+
name|iopad_size
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|opad
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
argument_list|)
expr_stmt|;
comment|/* XXX: F_KEY_CONTEXT_SALT_PRESENT set, but 'salt' not set. */
name|kctx_flits
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_key_ctx
argument_list|)
operator|+
name|kctx_len
operator|)
operator|/
literal|16
expr_stmt|;
name|crwr
operator|->
name|key_ctx
operator|.
name|ctx_hdr
operator|=
name|htobe32
argument_list|(
name|V_KEY_CONTEXT_CTX_LEN
argument_list|(
name|kctx_flits
argument_list|)
operator||
name|V_KEY_CONTEXT_OPAD_PRESENT
argument_list|(
literal|1
argument_list|)
operator||
name|V_KEY_CONTEXT_SALT_PRESENT
argument_list|(
literal|1
argument_list|)
operator||
name|V_KEY_CONTEXT_CK_SIZE
argument_list|(
name|CHCR_KEYCTX_NO_KEY
argument_list|)
operator||
name|V_KEY_CONTEXT_MK_SIZE
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|mk_size
argument_list|)
operator||
name|V_KEY_CONTEXT_VALID
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|crwr
operator|+
literal|1
operator|)
operator|+
name|kctx_len
operator|+
name|DUMMY_BYTES
expr_stmt|;
if|if
condition|(
name|imm_len
operator|!=
literal|0
condition|)
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
name|ccr_write_ulptx_sgl
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|sgl_nsegs
argument_list|)
expr_stmt|;
comment|/* XXX: TODO backpressure */
name|t4_wrq_tx
argument_list|(
name|sc
operator|->
name|adapter
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_hmac_done
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
specifier|const
name|struct
name|cpl_fw6_pld
modifier|*
name|cpl
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|hash_len
argument_list|,
call|(
name|c_caddr_t
call|)
argument_list|(
name|cpl
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_blkcipher
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sid
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|char
name|iv
index|[
name|CHCR_MAX_CRYPTO_IV_LEN
index|]
decl_stmt|;
name|struct
name|chcr_wr
modifier|*
name|crwr
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_int
name|iv_loc
decl_stmt|,
name|kctx_len
decl_stmt|,
name|key_half
decl_stmt|,
name|op_type
decl_stmt|,
name|transhdr_len
decl_stmt|,
name|wr_len
decl_stmt|;
name|u_int
name|imm_len
decl_stmt|;
name|int
name|dsgl_nsegs
decl_stmt|,
name|dsgl_len
decl_stmt|;
name|int
name|sgl_nsegs
decl_stmt|,
name|sgl_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|&&
operator|(
name|crd
operator|->
name|crd_len
operator|%
name|AES_BLOCK_LEN
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|iv_loc
operator|=
name|IV_NOP
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|op_type
operator|=
name|CHCR_ENCRYPT_OP
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|memcpy
argument_list|(
name|iv
argument_list|,
name|crd
operator|->
name|crd_iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
else|else
name|arc4rand
argument_list|(
name|iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iv_loc
operator|=
name|IV_IMMEDIATE
expr_stmt|;
if|if
condition|(
operator|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_type
operator|=
name|CHCR_DECRYPT_OP
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
block|{
name|memcpy
argument_list|(
name|iv
argument_list|,
name|crd
operator|->
name|crd_iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
name|iv_loc
operator|=
name|IV_IMMEDIATE
expr_stmt|;
block|}
else|else
name|iv_loc
operator|=
name|IV_DSGL
expr_stmt|;
block|}
name|sglist_reset
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dsgl_nsegs
operator|=
name|ccr_count_sgl
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|DSGL_SGE_MAXLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsgl_nsegs
operator|>
name|MAX_RX_PHYS_DSGL_SGE
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|dsgl_len
operator|=
name|ccr_phys_dsgl_len
argument_list|(
name|dsgl_nsegs
argument_list|)
expr_stmt|;
comment|/* The 'key' must be 128-bit aligned. */
name|kctx_len
operator|=
name|roundup2
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|transhdr_len
operator|=
name|CIPHER_TRANSHDR_SIZE
argument_list|(
name|kctx_len
argument_list|,
name|dsgl_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccr_use_imm_data
argument_list|(
name|transhdr_len
argument_list|,
name|crd
operator|->
name|crd_len
operator|+
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
condition|)
block|{
name|imm_len
operator|=
name|crd
operator|->
name|crd_len
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_DSGL
condition|)
block|{
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|iv_loc
operator|=
name|IV_IMMEDIATE
expr_stmt|;
block|}
name|sgl_nsegs
operator|=
literal|0
expr_stmt|;
name|sgl_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|imm_len
operator|=
literal|0
expr_stmt|;
name|sglist_reset
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_DSGL
condition|)
block|{
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sgl_nsegs
operator|=
name|sc
operator|->
name|sg_ulptx
operator|->
name|sg_nseg
expr_stmt|;
name|sgl_len
operator|=
name|ccr_ulptx_sgl_len
argument_list|(
name|sgl_nsegs
argument_list|)
expr_stmt|;
block|}
name|wr_len
operator|=
name|roundup2
argument_list|(
name|transhdr_len
argument_list|,
literal|16
argument_list|)
operator|+
name|roundup2
argument_list|(
name|imm_len
argument_list|,
literal|16
argument_list|)
operator|+
name|sgl_len
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_IMMEDIATE
condition|)
name|wr_len
operator|+=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|wr_len
argument_list|,
name|sc
operator|->
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|stats_wr_nomem
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|crwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|crwr
argument_list|,
literal|0
argument_list|,
name|wr_len
argument_list|)
expr_stmt|;
name|ccr_populate_wreq
argument_list|(
name|sc
argument_list|,
name|crwr
argument_list|,
name|kctx_len
argument_list|,
name|wr_len
argument_list|,
name|sid
argument_list|,
name|imm_len
argument_list|,
name|sgl_len
argument_list|,
literal|0
argument_list|,
name|iv_loc
argument_list|,
name|crp
argument_list|)
expr_stmt|;
comment|/* XXX: Hardcodes SGE loopback channel of 0. */
name|crwr
operator|->
name|sec_cpl
operator|.
name|op_ivinsrtofst
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_OPCODE
argument_list|(
name|CPL_TX_SEC_PDU
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_RXCHID
argument_list|(
name|sc
operator|->
name|tx_channel_id
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ACKFOLLOWS
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ULPTXLPBK
argument_list|(
literal|1
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CPLLEN
argument_list|(
literal|2
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_PLACEHOLDER
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_IVINSRTOFST
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|pldlen
operator|=
name|htobe32
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|+
name|crd
operator|->
name|crd_len
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|aadstart_cipherstop_hi
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_CIPHERSTART
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|+
literal|1
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CIPHERSTOP_HI
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|cipherstop_lo_authinsert
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_CIPHERSTOP_LO
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These two flits are actually a CPL_TLS_TX_SCMD_FMT. */
name|crwr
operator|->
name|sec_cpl
operator|.
name|seqno_numivs
operator|=
name|htobe32
argument_list|(
name|V_SCMD_SEQ_NO_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_PROTO_VERSION
argument_list|(
name|CHCR_SCMD_PROTO_VERSION_GENERIC
argument_list|)
operator||
name|V_SCMD_ENC_DEC_CTRL
argument_list|(
name|op_type
argument_list|)
operator||
name|V_SCMD_CIPH_MODE
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|cipher_mode
argument_list|)
operator||
name|V_SCMD_AUTH_MODE
argument_list|(
name|CHCR_SCMD_AUTH_MODE_NOP
argument_list|)
operator||
name|V_SCMD_HMAC_CTRL
argument_list|(
name|CHCR_SCMD_HMAC_CTRL_NOP
argument_list|)
operator||
name|V_SCMD_IV_SIZE
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|/
literal|2
argument_list|)
operator||
name|V_SCMD_NUM_IVS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|ivgen_hdrlen
operator|=
name|htobe32
argument_list|(
name|V_SCMD_IV_GEN_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MORE_FRAGS
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_LAST_FRAG
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MAC_ONLY
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_AADIVDROP
argument_list|(
literal|1
argument_list|)
operator||
name|V_SCMD_HDR_LEN
argument_list|(
name|dsgl_len
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|key_ctx
operator|.
name|ctx_hdr
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|key_ctx_hdr
expr_stmt|;
switch|switch
condition|(
name|crd
operator|->
name|crd_alg
condition|)
block|{
case|case
name|CRYPTO_AES_CBC
case|:
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|deckey
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_ICM
case|:
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_XTS
case|:
name|key_half
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|key_len
operator|/
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
operator|+
name|key_half
argument_list|,
name|key_half
argument_list|)
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
operator|+
name|key_half
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|key_half
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
operator|+
name|key_half
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|deckey
argument_list|,
name|key_half
argument_list|)
expr_stmt|;
break|break;
block|}
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|crwr
operator|+
literal|1
operator|)
operator|+
name|kctx_len
expr_stmt|;
name|ccr_write_phys_dsgl
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|dsgl_nsegs
argument_list|)
expr_stmt|;
name|dst
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_phys_dsgl
argument_list|)
operator|+
name|dsgl_len
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_IMMEDIATE
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
expr_stmt|;
block|}
if|if
condition|(
name|imm_len
operator|!=
literal|0
condition|)
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
name|ccr_write_ulptx_sgl
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|sgl_nsegs
argument_list|)
expr_stmt|;
comment|/* XXX: TODO backpressure */
name|t4_wrq_tx
argument_list|(
name|sc
operator|->
name|adapter
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_blkcipher_done
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
specifier|const
name|struct
name|cpl_fw6_pld
modifier|*
name|cpl
parameter_list|,
name|int
name|error
parameter_list|)
block|{
comment|/* 	 * The updated IV to permit chained requests is at 	 * cpl->data[2], but OCF doesn't permit chained requests. 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'hashsize' is the length of a full digest.  'authsize' is the  * requested digest length for this operation which may be less  * than 'hashsize'.  */
end_comment

begin_function
specifier|static
name|int
name|ccr_hmac_ctrl
parameter_list|(
name|unsigned
name|int
name|hashsize
parameter_list|,
name|unsigned
name|int
name|authsize
parameter_list|)
block|{
if|if
condition|(
name|authsize
operator|==
literal|10
condition|)
return|return
operator|(
name|CHCR_SCMD_HMAC_CTRL_TRUNC_RFC4366
operator|)
return|;
if|if
condition|(
name|authsize
operator|==
literal|12
condition|)
return|return
operator|(
name|CHCR_SCMD_HMAC_CTRL_IPSEC_96BIT
operator|)
return|;
if|if
condition|(
name|authsize
operator|==
name|hashsize
operator|/
literal|2
condition|)
return|return
operator|(
name|CHCR_SCMD_HMAC_CTRL_DIV2
operator|)
return|;
return|return
operator|(
name|CHCR_SCMD_HMAC_CTRL_NO_TRUNC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_authenc
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sid
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|struct
name|cryptodesc
modifier|*
name|crda
parameter_list|,
name|struct
name|cryptodesc
modifier|*
name|crde
parameter_list|)
block|{
name|char
name|iv
index|[
name|CHCR_MAX_CRYPTO_IV_LEN
index|]
decl_stmt|;
name|struct
name|chcr_wr
modifier|*
name|crwr
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|axf
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_int
name|iv_loc
decl_stmt|,
name|kctx_len
decl_stmt|,
name|key_half
decl_stmt|,
name|op_type
decl_stmt|,
name|transhdr_len
decl_stmt|,
name|wr_len
decl_stmt|;
name|u_int
name|hash_size_in_response
decl_stmt|,
name|imm_len
decl_stmt|,
name|iopad_size
decl_stmt|;
name|u_int
name|aad_start
decl_stmt|,
name|aad_len
decl_stmt|,
name|aad_stop
decl_stmt|;
name|u_int
name|auth_start
decl_stmt|,
name|auth_stop
decl_stmt|,
name|auth_insert
decl_stmt|;
name|u_int
name|cipher_start
decl_stmt|,
name|cipher_stop
decl_stmt|;
name|u_int
name|hmac_ctrl
decl_stmt|,
name|input_len
decl_stmt|;
name|int
name|dsgl_nsegs
decl_stmt|,
name|dsgl_len
decl_stmt|;
name|int
name|sgl_nsegs
decl_stmt|,
name|sgl_len
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|crde
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|&&
operator|(
name|crde
operator|->
name|crd_len
operator|%
name|AES_BLOCK_LEN
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * AAD is only permitted before the cipher/plain text, not 	 * after. 	 */
if|if
condition|(
name|crda
operator|->
name|crd_len
operator|+
name|crda
operator|->
name|crd_skip
operator|>
name|crde
operator|->
name|crd_len
operator|+
name|crde
operator|->
name|crd_skip
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|axf
operator|=
name|s
operator|->
name|hmac
operator|.
name|auth_hash
expr_stmt|;
name|hash_size_in_response
operator|=
name|s
operator|->
name|hmac
operator|.
name|hash_len
expr_stmt|;
comment|/* 	 * The IV is always stored at the start of the buffer even 	 * though it may be duplicated in the payload.  The crypto 	 * engine doesn't work properly if the IV offset points inside 	 * of the AAD region, so a second copy is always required. 	 */
name|iv_loc
operator|=
name|IV_IMMEDIATE
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|op_type
operator|=
name|CHCR_ENCRYPT_OP
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|memcpy
argument_list|(
name|iv
argument_list|,
name|crde
operator|->
name|crd_iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
else|else
name|arc4rand
argument_list|(
name|iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crde
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_type
operator|=
name|CHCR_DECRYPT_OP
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|memcpy
argument_list|(
name|iv
argument_list|,
name|crde
operator|->
name|crd_iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
else|else
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crde
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The output buffer consists of the cipher text followed by 	 * the hash when encrypting.  For decryption it only contains 	 * the plain text. 	 */
name|sglist_reset
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crde
operator|->
name|crd_skip
argument_list|,
name|crde
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_ENCRYPT_OP
condition|)
block|{
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|hash_size_in_response
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dsgl_nsegs
operator|=
name|ccr_count_sgl
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|DSGL_SGE_MAXLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsgl_nsegs
operator|>
name|MAX_RX_PHYS_DSGL_SGE
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|dsgl_len
operator|=
name|ccr_phys_dsgl_len
argument_list|(
name|dsgl_nsegs
argument_list|)
expr_stmt|;
comment|/* PADs must be 128-bit aligned. */
name|iopad_size
operator|=
name|roundup2
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* 	 * The 'key' part of the key context consists of the key followed 	 * by the IPAD and OPAD. 	 */
name|kctx_len
operator|=
name|roundup2
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|,
literal|16
argument_list|)
operator|+
name|iopad_size
operator|*
literal|2
expr_stmt|;
name|transhdr_len
operator|=
name|CIPHER_TRANSHDR_SIZE
argument_list|(
name|kctx_len
argument_list|,
name|dsgl_len
argument_list|)
expr_stmt|;
comment|/* 	 * The input buffer consists of the IV, any AAD, and then the 	 * cipher/plain text.  For decryption requests the hash is 	 * appended after the cipher text. 	 */
if|if
condition|(
name|crda
operator|->
name|crd_skip
operator|<
name|crde
operator|->
name|crd_skip
condition|)
block|{
if|if
condition|(
name|crda
operator|->
name|crd_skip
operator|+
name|crda
operator|->
name|crd_len
operator|>
name|crde
operator|->
name|crd_skip
condition|)
name|aad_len
operator|=
operator|(
name|crde
operator|->
name|crd_skip
operator|-
name|crda
operator|->
name|crd_skip
operator|)
expr_stmt|;
else|else
name|aad_len
operator|=
name|crda
operator|->
name|crd_len
expr_stmt|;
block|}
else|else
name|aad_len
operator|=
literal|0
expr_stmt|;
name|input_len
operator|=
name|aad_len
operator|+
name|crde
operator|->
name|crd_len
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|input_len
operator|+=
name|hash_size_in_response
expr_stmt|;
if|if
condition|(
name|ccr_use_imm_data
argument_list|(
name|transhdr_len
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|+
name|input_len
argument_list|)
condition|)
block|{
name|imm_len
operator|=
name|input_len
expr_stmt|;
name|sgl_nsegs
operator|=
literal|0
expr_stmt|;
name|sgl_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|imm_len
operator|=
literal|0
expr_stmt|;
name|sglist_reset
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|)
expr_stmt|;
if|if
condition|(
name|aad_len
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crda
operator|->
name|crd_skip
argument_list|,
name|aad_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crde
operator|->
name|crd_skip
argument_list|,
name|crde
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
block|{
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|hash_size_in_response
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sgl_nsegs
operator|=
name|sc
operator|->
name|sg_ulptx
operator|->
name|sg_nseg
expr_stmt|;
name|sgl_len
operator|=
name|ccr_ulptx_sgl_len
argument_list|(
name|sgl_nsegs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Any auth-only data before the cipher region is marked as AAD. 	 * Auth-data that overlaps with the cipher region is placed in 	 * the auth section. 	 */
if|if
condition|(
name|aad_len
operator|!=
literal|0
condition|)
block|{
name|aad_start
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|+
literal|1
expr_stmt|;
name|aad_stop
operator|=
name|aad_start
operator|+
name|aad_len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|aad_start
operator|=
literal|0
expr_stmt|;
name|aad_stop
operator|=
literal|0
expr_stmt|;
block|}
name|cipher_start
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|+
name|aad_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|cipher_stop
operator|=
name|hash_size_in_response
expr_stmt|;
else|else
name|cipher_stop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aad_len
operator|==
name|crda
operator|->
name|crd_len
condition|)
block|{
name|auth_start
operator|=
literal|0
expr_stmt|;
name|auth_stop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aad_len
operator|!=
literal|0
condition|)
name|auth_start
operator|=
name|cipher_start
expr_stmt|;
else|else
name|auth_start
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|+
name|crda
operator|->
name|crd_skip
operator|-
name|crde
operator|->
name|crd_skip
operator|+
literal|1
expr_stmt|;
name|auth_stop
operator|=
operator|(
name|crde
operator|->
name|crd_skip
operator|+
name|crde
operator|->
name|crd_len
operator|)
operator|-
operator|(
name|crda
operator|->
name|crd_skip
operator|+
name|crda
operator|->
name|crd_len
operator|)
operator|+
name|cipher_stop
expr_stmt|;
block|}
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|auth_insert
operator|=
name|hash_size_in_response
expr_stmt|;
else|else
name|auth_insert
operator|=
literal|0
expr_stmt|;
name|wr_len
operator|=
name|roundup2
argument_list|(
name|transhdr_len
argument_list|,
literal|16
argument_list|)
operator|+
name|roundup2
argument_list|(
name|imm_len
argument_list|,
literal|16
argument_list|)
operator|+
name|sgl_len
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_IMMEDIATE
condition|)
name|wr_len
operator|+=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|wr_len
argument_list|,
name|sc
operator|->
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|stats_wr_nomem
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|crwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|crwr
argument_list|,
literal|0
argument_list|,
name|wr_len
argument_list|)
expr_stmt|;
name|ccr_populate_wreq
argument_list|(
name|sc
argument_list|,
name|crwr
argument_list|,
name|kctx_len
argument_list|,
name|wr_len
argument_list|,
name|sid
argument_list|,
name|imm_len
argument_list|,
name|sgl_len
argument_list|,
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|?
name|hash_size_in_response
else|:
literal|0
argument_list|,
name|iv_loc
argument_list|,
name|crp
argument_list|)
expr_stmt|;
comment|/* XXX: Hardcodes SGE loopback channel of 0. */
name|crwr
operator|->
name|sec_cpl
operator|.
name|op_ivinsrtofst
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_OPCODE
argument_list|(
name|CPL_TX_SEC_PDU
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_RXCHID
argument_list|(
name|sc
operator|->
name|tx_channel_id
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ACKFOLLOWS
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ULPTXLPBK
argument_list|(
literal|1
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CPLLEN
argument_list|(
literal|2
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_PLACEHOLDER
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_IVINSRTOFST
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|pldlen
operator|=
name|htobe32
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|+
name|input_len
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|aadstart_cipherstop_hi
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_AADSTART
argument_list|(
name|aad_start
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AADSTOP
argument_list|(
name|aad_stop
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CIPHERSTART
argument_list|(
name|cipher_start
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CIPHERSTOP_HI
argument_list|(
name|cipher_stop
operator|>>
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|cipherstop_lo_authinsert
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_CIPHERSTOP_LO
argument_list|(
name|cipher_stop
operator|&
literal|0xf
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AUTHSTART
argument_list|(
name|auth_start
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AUTHSTOP
argument_list|(
name|auth_stop
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AUTHINSERT
argument_list|(
name|auth_insert
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These two flits are actually a CPL_TLS_TX_SCMD_FMT. */
name|hmac_ctrl
operator|=
name|ccr_hmac_ctrl
argument_list|(
name|axf
operator|->
name|hashsize
argument_list|,
name|hash_size_in_response
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|seqno_numivs
operator|=
name|htobe32
argument_list|(
name|V_SCMD_SEQ_NO_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_PROTO_VERSION
argument_list|(
name|CHCR_SCMD_PROTO_VERSION_GENERIC
argument_list|)
operator||
name|V_SCMD_ENC_DEC_CTRL
argument_list|(
name|op_type
argument_list|)
operator||
name|V_SCMD_CIPH_AUTH_SEQ_CTRL
argument_list|(
name|op_type
operator|==
name|CHCR_ENCRYPT_OP
condition|?
literal|1
else|:
literal|0
argument_list|)
operator||
name|V_SCMD_CIPH_MODE
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|cipher_mode
argument_list|)
operator||
name|V_SCMD_AUTH_MODE
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|auth_mode
argument_list|)
operator||
name|V_SCMD_HMAC_CTRL
argument_list|(
name|hmac_ctrl
argument_list|)
operator||
name|V_SCMD_IV_SIZE
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|/
literal|2
argument_list|)
operator||
name|V_SCMD_NUM_IVS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|ivgen_hdrlen
operator|=
name|htobe32
argument_list|(
name|V_SCMD_IV_GEN_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MORE_FRAGS
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_LAST_FRAG
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MAC_ONLY
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_AADIVDROP
argument_list|(
literal|1
argument_list|)
operator||
name|V_SCMD_HDR_LEN
argument_list|(
name|dsgl_len
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|key_ctx
operator|.
name|ctx_hdr
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|key_ctx_hdr
expr_stmt|;
switch|switch
condition|(
name|crde
operator|->
name|crd_alg
condition|)
block|{
case|case
name|CRYPTO_AES_CBC
case|:
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|deckey
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_ICM
case|:
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_XTS
case|:
name|key_half
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|key_len
operator|/
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
operator|+
name|key_half
argument_list|,
name|key_half
argument_list|)
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
operator|+
name|key_half
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|key_half
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
operator|+
name|key_half
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|deckey
argument_list|,
name|key_half
argument_list|)
expr_stmt|;
break|break;
block|}
name|dst
operator|=
name|crwr
operator|->
name|key_ctx
operator|.
name|key
operator|+
name|roundup2
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|ipad
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
name|iopad_size
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|opad
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|crwr
operator|+
literal|1
operator|)
operator|+
name|kctx_len
expr_stmt|;
name|ccr_write_phys_dsgl
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|dsgl_nsegs
argument_list|)
expr_stmt|;
name|dst
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_phys_dsgl
argument_list|)
operator|+
name|dsgl_len
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_IMMEDIATE
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
expr_stmt|;
block|}
if|if
condition|(
name|imm_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|aad_len
operator|!=
literal|0
condition|)
block|{
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crda
operator|->
name|crd_skip
argument_list|,
name|aad_len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|aad_len
expr_stmt|;
block|}
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crde
operator|->
name|crd_skip
argument_list|,
name|crde
operator|->
name|crd_len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|crde
operator|->
name|crd_len
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|hash_size_in_response
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
name|ccr_write_ulptx_sgl
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|sgl_nsegs
argument_list|)
expr_stmt|;
comment|/* XXX: TODO backpressure */
name|t4_wrq_tx
argument_list|(
name|sc
operator|->
name|adapter
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_authenc_done
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
specifier|const
name|struct
name|cpl_fw6_pld
modifier|*
name|cpl
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
comment|/* 	 * The updated IV to permit chained requests is at 	 * cpl->data[2], but OCF doesn't permit chained requests. 	 * 	 * For a decryption request, the hardware may do a verification 	 * of the HMAC which will fail if the existing HMAC isn't in the 	 * buffer.  If that happens, clear the error and copy the HMAC 	 * from the CPL reply into the buffer. 	 * 	 * For encryption requests, crd should be the cipher request 	 * which will have CRD_F_ENCRYPT set.  For decryption 	 * requests, crp_desc will be the HMAC request which should 	 * not have this flag set. 	 */
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBADMSG
operator|&&
operator|!
name|CHK_PAD_ERR_BIT
argument_list|(
name|be64toh
argument_list|(
name|cpl
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
condition|)
block|{
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|hash_len
argument_list|,
call|(
name|c_caddr_t
call|)
argument_list|(
name|cpl
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_gcm
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sid
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|struct
name|cryptodesc
modifier|*
name|crda
parameter_list|,
name|struct
name|cryptodesc
modifier|*
name|crde
parameter_list|)
block|{
name|char
name|iv
index|[
name|CHCR_MAX_CRYPTO_IV_LEN
index|]
decl_stmt|;
name|struct
name|chcr_wr
modifier|*
name|crwr
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_int
name|iv_len
decl_stmt|,
name|iv_loc
decl_stmt|,
name|kctx_len
decl_stmt|,
name|op_type
decl_stmt|,
name|transhdr_len
decl_stmt|,
name|wr_len
decl_stmt|;
name|u_int
name|hash_size_in_response
decl_stmt|,
name|imm_len
decl_stmt|;
name|u_int
name|aad_start
decl_stmt|,
name|aad_stop
decl_stmt|,
name|cipher_start
decl_stmt|,
name|cipher_stop
decl_stmt|,
name|auth_insert
decl_stmt|;
name|u_int
name|hmac_ctrl
decl_stmt|,
name|input_len
decl_stmt|;
name|int
name|dsgl_nsegs
decl_stmt|,
name|dsgl_len
decl_stmt|;
name|int
name|sgl_nsegs
decl_stmt|,
name|sgl_len
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * AAD is only permitted before the cipher/plain text, not 	 * after. 	 */
if|if
condition|(
name|crda
operator|->
name|crd_len
operator|+
name|crda
operator|->
name|crd_skip
operator|>
name|crde
operator|->
name|crd_len
operator|+
name|crde
operator|->
name|crd_skip
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hash_size_in_response
operator|=
name|s
operator|->
name|gmac
operator|.
name|hash_len
expr_stmt|;
comment|/* 	 * The IV is always stored at the start of the buffer even 	 * though it may be duplicated in the payload.  The crypto 	 * engine doesn't work properly if the IV offset points inside 	 * of the AAD region, so a second copy is always required. 	 * 	 * The IV for GCM is further complicated in that IPSec 	 * provides a full 16-byte IV (including the counter), whereas 	 * the /dev/crypto interface sometimes provides a full 16-byte 	 * IV (if no IV is provided in the ioctl) and sometimes a 	 * 12-byte IV (if the IV was explicit).  For now the driver 	 * always assumes a 12-byte IV and initializes the low 4 byte 	 * counter to 1. 	 */
name|iv_loc
operator|=
name|IV_IMMEDIATE
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|op_type
operator|=
name|CHCR_ENCRYPT_OP
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|memcpy
argument_list|(
name|iv
argument_list|,
name|crde
operator|->
name|crd_iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
else|else
name|arc4rand
argument_list|(
name|iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crde
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_type
operator|=
name|CHCR_DECRYPT_OP
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|memcpy
argument_list|(
name|iv
argument_list|,
name|crde
operator|->
name|crd_iv
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|)
expr_stmt|;
else|else
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crde
operator|->
name|crd_inject
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the input IV is 12 bytes, append an explicit counter of 	 * 1. 	 */
if|if
condition|(
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|==
literal|12
condition|)
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|iv
index|[
literal|12
index|]
operator|=
name|htobe32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|iv_len
operator|=
name|AES_BLOCK_LEN
expr_stmt|;
block|}
else|else
name|iv_len
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
expr_stmt|;
comment|/* 	 * The output buffer consists of the cipher text followed by 	 * the tag when encrypting.  For decryption it only contains 	 * the plain text. 	 */
name|sglist_reset
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crde
operator|->
name|crd_skip
argument_list|,
name|crde
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_ENCRYPT_OP
condition|)
block|{
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|hash_size_in_response
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dsgl_nsegs
operator|=
name|ccr_count_sgl
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|,
name|DSGL_SGE_MAXLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsgl_nsegs
operator|>
name|MAX_RX_PHYS_DSGL_SGE
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|dsgl_len
operator|=
name|ccr_phys_dsgl_len
argument_list|(
name|dsgl_nsegs
argument_list|)
expr_stmt|;
comment|/* 	 * The 'key' part of the key context consists of the key followed 	 * by the Galois hash key. 	 */
name|kctx_len
operator|=
name|roundup2
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|,
literal|16
argument_list|)
operator|+
name|GMAC_BLOCK_LEN
expr_stmt|;
name|transhdr_len
operator|=
name|CIPHER_TRANSHDR_SIZE
argument_list|(
name|kctx_len
argument_list|,
name|dsgl_len
argument_list|)
expr_stmt|;
comment|/* 	 * The input buffer consists of the IV, any AAD, and then the 	 * cipher/plain text.  For decryption requests the hash is 	 * appended after the cipher text. 	 */
name|input_len
operator|=
name|crda
operator|->
name|crd_len
operator|+
name|crde
operator|->
name|crd_len
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|input_len
operator|+=
name|hash_size_in_response
expr_stmt|;
if|if
condition|(
name|ccr_use_imm_data
argument_list|(
name|transhdr_len
argument_list|,
name|iv_len
operator|+
name|input_len
argument_list|)
condition|)
block|{
name|imm_len
operator|=
name|input_len
expr_stmt|;
name|sgl_nsegs
operator|=
literal|0
expr_stmt|;
name|sgl_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|imm_len
operator|=
literal|0
expr_stmt|;
name|sglist_reset
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|)
expr_stmt|;
if|if
condition|(
name|crda
operator|->
name|crd_len
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crda
operator|->
name|crd_skip
argument_list|,
name|crda
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crde
operator|->
name|crd_skip
argument_list|,
name|crde
operator|->
name|crd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
block|{
name|error
operator|=
name|sglist_append_sglist
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|,
name|sc
operator|->
name|sg_crp
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|hash_size_in_response
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sgl_nsegs
operator|=
name|sc
operator|->
name|sg_ulptx
operator|->
name|sg_nseg
expr_stmt|;
name|sgl_len
operator|=
name|ccr_ulptx_sgl_len
argument_list|(
name|sgl_nsegs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crda
operator|->
name|crd_len
operator|!=
literal|0
condition|)
block|{
name|aad_start
operator|=
name|iv_len
operator|+
literal|1
expr_stmt|;
name|aad_stop
operator|=
name|aad_start
operator|+
name|crda
operator|->
name|crd_len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|aad_start
operator|=
literal|0
expr_stmt|;
name|aad_stop
operator|=
literal|0
expr_stmt|;
block|}
name|cipher_start
operator|=
name|iv_len
operator|+
name|crda
operator|->
name|crd_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|cipher_stop
operator|=
name|hash_size_in_response
expr_stmt|;
else|else
name|cipher_stop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|auth_insert
operator|=
name|hash_size_in_response
expr_stmt|;
else|else
name|auth_insert
operator|=
literal|0
expr_stmt|;
name|wr_len
operator|=
name|roundup2
argument_list|(
name|transhdr_len
argument_list|,
literal|16
argument_list|)
operator|+
name|roundup2
argument_list|(
name|imm_len
argument_list|,
literal|16
argument_list|)
operator|+
name|sgl_len
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_IMMEDIATE
condition|)
name|wr_len
operator|+=
name|iv_len
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|wr_len
argument_list|,
name|sc
operator|->
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|stats_wr_nomem
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|crwr
operator|=
name|wrtod
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|crwr
argument_list|,
literal|0
argument_list|,
name|wr_len
argument_list|)
expr_stmt|;
name|ccr_populate_wreq
argument_list|(
name|sc
argument_list|,
name|crwr
argument_list|,
name|kctx_len
argument_list|,
name|wr_len
argument_list|,
name|sid
argument_list|,
name|imm_len
argument_list|,
name|sgl_len
argument_list|,
literal|0
argument_list|,
name|iv_loc
argument_list|,
name|crp
argument_list|)
expr_stmt|;
comment|/* XXX: Hardcodes SGE loopback channel of 0. */
name|crwr
operator|->
name|sec_cpl
operator|.
name|op_ivinsrtofst
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_OPCODE
argument_list|(
name|CPL_TX_SEC_PDU
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_RXCHID
argument_list|(
name|sc
operator|->
name|tx_channel_id
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ACKFOLLOWS
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_ULPTXLPBK
argument_list|(
literal|1
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CPLLEN
argument_list|(
literal|2
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_PLACEHOLDER
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_IVINSRTOFST
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|pldlen
operator|=
name|htobe32
argument_list|(
name|iv_len
operator|+
name|input_len
argument_list|)
expr_stmt|;
comment|/* 	 * NB: cipherstop is explicitly set to 0.  On encrypt it 	 * should normally be set to 0 anyway (as the encrypt crd ends 	 * at the end of the input).  However, for decrypt the cipher 	 * ends before the tag in the AUTHENC case (and authstop is 	 * set to stop before the tag), but for GCM the cipher still 	 * runs to the end of the buffer.  Not sure if this is 	 * intentional or a firmware quirk, but it is required for 	 * working tag validation with GCM decryption. 	 */
name|crwr
operator|->
name|sec_cpl
operator|.
name|aadstart_cipherstop_hi
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_AADSTART
argument_list|(
name|aad_start
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AADSTOP
argument_list|(
name|aad_stop
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CIPHERSTART
argument_list|(
name|cipher_start
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_CIPHERSTOP_HI
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|cipherstop_lo_authinsert
operator|=
name|htobe32
argument_list|(
name|V_CPL_TX_SEC_PDU_CIPHERSTOP_LO
argument_list|(
literal|0
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AUTHSTART
argument_list|(
name|cipher_start
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AUTHSTOP
argument_list|(
name|cipher_stop
argument_list|)
operator||
name|V_CPL_TX_SEC_PDU_AUTHINSERT
argument_list|(
name|auth_insert
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These two flits are actually a CPL_TLS_TX_SCMD_FMT. */
name|hmac_ctrl
operator|=
name|ccr_hmac_ctrl
argument_list|(
name|AES_GMAC_HASH_LEN
argument_list|,
name|hash_size_in_response
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|seqno_numivs
operator|=
name|htobe32
argument_list|(
name|V_SCMD_SEQ_NO_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_PROTO_VERSION
argument_list|(
name|CHCR_SCMD_PROTO_VERSION_GENERIC
argument_list|)
operator||
name|V_SCMD_ENC_DEC_CTRL
argument_list|(
name|op_type
argument_list|)
operator||
name|V_SCMD_CIPH_AUTH_SEQ_CTRL
argument_list|(
name|op_type
operator|==
name|CHCR_ENCRYPT_OP
condition|?
literal|1
else|:
literal|0
argument_list|)
operator||
name|V_SCMD_CIPH_MODE
argument_list|(
name|CHCR_SCMD_CIPHER_MODE_AES_GCM
argument_list|)
operator||
name|V_SCMD_AUTH_MODE
argument_list|(
name|CHCR_SCMD_AUTH_MODE_GHASH
argument_list|)
operator||
name|V_SCMD_HMAC_CTRL
argument_list|(
name|hmac_ctrl
argument_list|)
operator||
name|V_SCMD_IV_SIZE
argument_list|(
name|iv_len
operator|/
literal|2
argument_list|)
operator||
name|V_SCMD_NUM_IVS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|sec_cpl
operator|.
name|ivgen_hdrlen
operator|=
name|htobe32
argument_list|(
name|V_SCMD_IV_GEN_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MORE_FRAGS
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_LAST_FRAG
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_MAC_ONLY
argument_list|(
literal|0
argument_list|)
operator||
name|V_SCMD_AADIVDROP
argument_list|(
literal|1
argument_list|)
operator||
name|V_SCMD_HDR_LEN
argument_list|(
name|dsgl_len
argument_list|)
argument_list|)
expr_stmt|;
name|crwr
operator|->
name|key_ctx
operator|.
name|ctx_hdr
operator|=
name|s
operator|->
name|blkcipher
operator|.
name|key_ctx_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|crwr
operator|->
name|key_ctx
operator|.
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
name|dst
operator|=
name|crwr
operator|->
name|key_ctx
operator|.
name|key
operator|+
name|roundup2
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|s
operator|->
name|gmac
operator|.
name|ghash_h
argument_list|,
name|GMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|crwr
operator|+
literal|1
operator|)
operator|+
name|kctx_len
expr_stmt|;
name|ccr_write_phys_dsgl
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|dsgl_nsegs
argument_list|)
expr_stmt|;
name|dst
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_phys_dsgl
argument_list|)
operator|+
name|dsgl_len
expr_stmt|;
if|if
condition|(
name|iv_loc
operator|==
name|IV_IMMEDIATE
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|iv
argument_list|,
name|iv_len
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|iv_len
expr_stmt|;
block|}
if|if
condition|(
name|imm_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|crda
operator|->
name|crd_len
operator|!=
literal|0
condition|)
block|{
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crda
operator|->
name|crd_skip
argument_list|,
name|crda
operator|->
name|crd_len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|crda
operator|->
name|crd_len
expr_stmt|;
block|}
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crde
operator|->
name|crd_skip
argument_list|,
name|crde
operator|->
name|crd_len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|crde
operator|->
name|crd_len
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CHCR_DECRYPT_OP
condition|)
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|hash_size_in_response
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
name|ccr_write_ulptx_sgl
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|sgl_nsegs
argument_list|)
expr_stmt|;
comment|/* XXX: TODO backpressure */
name|t4_wrq_tx
argument_list|(
name|sc
operator|->
name|adapter
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_gcm_done
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
specifier|const
name|struct
name|cpl_fw6_pld
modifier|*
name|cpl
parameter_list|,
name|int
name|error
parameter_list|)
block|{
comment|/* 	 * The updated IV to permit chained requests is at 	 * cpl->data[2], but OCF doesn't permit chained requests. 	 * 	 * Note that the hardware should always verify the GMAC hash. 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cryptocaps
operator|&
name|FW_CAPS_CONFIG_CRYPTO_LOOKASIDE
operator|&&
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"ccr"
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
condition|)
name|device_add_child
argument_list|(
name|parent
argument_list|,
literal|"ccr"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Chelsio Crypto Accelerator"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_sysctls
parameter_list|(
name|struct
name|ccr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * dev.ccr.X. 	 */
name|oid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
comment|/* 	 * dev.ccr.X.stats. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"statistics"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hmac"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_hmac
argument_list|,
literal|0
argument_list|,
literal|"HMAC requests submitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cipher_encrypt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_blkcipher_encrypt
argument_list|,
literal|0
argument_list|,
literal|"Cipher encryption requests submitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cipher_decrypt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_blkcipher_decrypt
argument_list|,
literal|0
argument_list|,
literal|"Cipher decryption requests submitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"authenc_encrypt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_authenc_encrypt
argument_list|,
literal|0
argument_list|,
literal|"Combined AES+HMAC encryption requests submitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"authenc_decrypt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_authenc_decrypt
argument_list|,
literal|0
argument_list|,
literal|"Combined AES+HMAC decryption requests submitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"gcm_encrypt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_gcm_encrypt
argument_list|,
literal|0
argument_list|,
literal|"AES-GCM encryption requests submitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"gcm_decrypt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_gcm_decrypt
argument_list|,
literal|0
argument_list|,
literal|"AES-GCM decryption requests submitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wr_nomem"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_wr_nomem
argument_list|,
literal|0
argument_list|,
literal|"Work request memory allocation failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inflight"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_inflight
argument_list|,
literal|0
argument_list|,
literal|"Requests currently pending"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_error"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_mac_error
argument_list|,
literal|0
argument_list|,
literal|"MAC errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pad_error"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_pad_error
argument_list|,
literal|0
argument_list|,
literal|"Padding errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bad_session"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_pad_error
argument_list|,
literal|0
argument_list|,
literal|"Requests with invalid session ID"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sglist_error"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_pad_error
argument_list|,
literal|0
argument_list|,
literal|"Requests for which DMA mapping failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"process_error"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stats_pad_error
argument_list|,
literal|0
argument_list|,
literal|"Requests failed during queueing"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ccr_softc
modifier|*
name|sc
decl_stmt|;
name|int32_t
name|cid
decl_stmt|;
comment|/* 	 * TODO: Crypto requests will panic if the parent device isn't 	 * initialized so that the queues are up and running.  Need to 	 * figure out how to handle that correctly, maybe just reject 	 * requests if the adapter isn't fully initialized? 	 */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txq
operator|=
operator|&
name|sc
operator|->
name|adapter
operator|->
name|sge
operator|.
name|ctrlq
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|rxq
operator|=
operator|&
name|sc
operator|->
name|adapter
operator|->
name|sge
operator|.
name|rxq
index|[
literal|0
index|]
expr_stmt|;
name|cid
operator|=
name|crypto_get_driverid
argument_list|(
name|dev
argument_list|,
name|CRYPTOCAP_F_HARDWARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cid
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not get crypto driver id\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|cid
operator|=
name|cid
expr_stmt|;
name|sc
operator|->
name|adapter
operator|->
name|ccr_softc
operator|=
name|sc
expr_stmt|;
comment|/* XXX: TODO? */
name|sc
operator|->
name|tx_channel_id
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|,
literal|"ccr"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sg_crp
operator|=
name|sglist_alloc
argument_list|(
name|TX_SGL_SEGS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sg_ulptx
operator|=
name|sglist_alloc
argument_list|(
name|TX_SGL_SEGS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sg_dsgl
operator|=
name|sglist_alloc
argument_list|(
name|MAX_RX_PHYS_DSGL_SGE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ccr_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_SHA1_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_SHA2_256_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_SHA2_384_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_SHA2_512_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_AES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_AES_ICM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_AES_NIST_GCM_16
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_AES_128_NIST_GMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_AES_192_NIST_GMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_AES_256_NIST_GMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|cid
argument_list|,
name|CRYPTO_AES_XTS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ccr_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nsessions
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sessions
index|[
name|i
index|]
operator|.
name|active
operator|||
name|sc
operator|->
name|sessions
index|[
name|i
index|]
operator|.
name|pending
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|detaching
operator|=
name|true
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|cid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sessions
argument_list|,
name|M_CCR
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sglist_free
argument_list|(
name|sc
operator|->
name|sg_dsgl
argument_list|)
expr_stmt|;
name|sglist_free
argument_list|(
name|sc
operator|->
name|sg_ulptx
argument_list|)
expr_stmt|;
name|sglist_free
argument_list|(
name|sc
operator|->
name|sg_crp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|adapter
operator|->
name|ccr_softc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_copy_partial_hash
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|int
name|cri_alg
parameter_list|,
name|union
name|authctx
modifier|*
name|auth_ctx
parameter_list|)
block|{
name|uint32_t
modifier|*
name|u32
decl_stmt|;
name|uint64_t
modifier|*
name|u64
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u32
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|dst
expr_stmt|;
name|u64
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|dst
expr_stmt|;
switch|switch
condition|(
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_SHA1_HMAC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHA1_HASH_LEN
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|u32
index|[
name|i
index|]
operator|=
name|htobe32
argument_list|(
name|auth_ctx
operator|->
name|sha1ctx
operator|.
name|h
operator|.
name|b32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHA2_256_HASH_LEN
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|u32
index|[
name|i
index|]
operator|=
name|htobe32
argument_list|(
name|auth_ctx
operator|->
name|sha256ctx
operator|.
name|state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHA2_512_HASH_LEN
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|u64
index|[
name|i
index|]
operator|=
name|htobe64
argument_list|(
name|auth_ctx
operator|->
name|sha384ctx
operator|.
name|state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHA2_512_HASH_LEN
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|u64
index|[
name|i
index|]
operator|=
name|htobe64
argument_list|(
name|auth_ctx
operator|->
name|sha512ctx
operator|.
name|state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_init_hmac_digest
parameter_list|(
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|int
name|cri_alg
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|int
name|klen
parameter_list|)
block|{
name|union
name|authctx
name|auth_ctx
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|axf
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* 	 * If the key is larger than the block size, use the digest of 	 * the key as the key instead. 	 */
name|axf
operator|=
name|s
operator|->
name|hmac
operator|.
name|auth_hash
expr_stmt|;
name|klen
operator|/=
literal|8
expr_stmt|;
if|if
condition|(
name|klen
operator|>
name|axf
operator|->
name|blocksize
condition|)
block|{
name|axf
operator|->
name|Init
argument_list|(
operator|&
name|auth_ctx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|auth_ctx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Final
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|ipad
argument_list|,
operator|&
name|auth_ctx
argument_list|)
expr_stmt|;
name|klen
operator|=
name|axf
operator|->
name|hashsize
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|ipad
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|ipad
operator|+
name|klen
argument_list|,
literal|0
argument_list|,
name|axf
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|opad
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|ipad
argument_list|,
name|axf
operator|->
name|blocksize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|axf
operator|->
name|blocksize
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|->
name|hmac
operator|.
name|ipad
index|[
name|i
index|]
operator|^=
name|HMAC_IPAD_VAL
expr_stmt|;
name|s
operator|->
name|hmac
operator|.
name|opad
index|[
name|i
index|]
operator|^=
name|HMAC_OPAD_VAL
expr_stmt|;
block|}
comment|/* 	 * Hash the raw ipad and opad and store the partial result in 	 * the same buffer. 	 */
name|axf
operator|->
name|Init
argument_list|(
operator|&
name|auth_ctx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|auth_ctx
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|ipad
argument_list|,
name|axf
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|ccr_copy_partial_hash
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|ipad
argument_list|,
name|cri_alg
argument_list|,
operator|&
name|auth_ctx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Init
argument_list|(
operator|&
name|auth_ctx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|auth_ctx
argument_list|,
name|s
operator|->
name|hmac
operator|.
name|opad
argument_list|,
name|axf
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|ccr_copy_partial_hash
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|opad
argument_list|,
name|cri_alg
argument_list|,
operator|&
name|auth_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Borrowed from AES_GMAC_Setkey().  */
end_comment

begin_function
specifier|static
name|void
name|ccr_init_gmac_hash
parameter_list|(
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|int
name|klen
parameter_list|)
block|{
specifier|static
name|char
name|zeroes
index|[
name|GMAC_BLOCK_LEN
index|]
decl_stmt|;
name|uint32_t
name|keysched
index|[
literal|4
operator|*
operator|(
name|RIJNDAEL_MAXNR
operator|+
literal|1
operator|)
index|]
decl_stmt|;
name|int
name|rounds
decl_stmt|;
name|rounds
operator|=
name|rijndaelKeySetupEnc
argument_list|(
name|keysched
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|rijndaelEncrypt
argument_list|(
name|keysched
argument_list|,
name|rounds
argument_list|,
name|zeroes
argument_list|,
name|s
operator|->
name|gmac
operator|.
name|ghash_h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_aes_check_keylen
parameter_list|(
name|int
name|alg
parameter_list|,
name|int
name|klen
parameter_list|)
block|{
switch|switch
condition|(
name|klen
condition|)
block|{
case|case
literal|128
case|:
case|case
literal|192
case|:
if|if
condition|(
name|alg
operator|==
name|CRYPTO_AES_XTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
literal|256
case|:
break|break;
case|case
literal|512
case|:
if|if
condition|(
name|alg
operator|!=
name|CRYPTO_AES_XTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Borrowed from cesa_prep_aes_key().  We should perhaps have a public  * function to generate this instead.  *  * NB: The crypto engine wants the words in the decryption key in reverse  * order.  */
end_comment

begin_function
specifier|static
name|void
name|ccr_aes_getdeckey
parameter_list|(
name|void
modifier|*
name|dec_key
parameter_list|,
specifier|const
name|void
modifier|*
name|enc_key
parameter_list|,
name|unsigned
name|int
name|kbits
parameter_list|)
block|{
name|uint32_t
name|ek
index|[
literal|4
operator|*
operator|(
name|RIJNDAEL_MAXNR
operator|+
literal|1
operator|)
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|dkey
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rijndaelKeySetupEnc
argument_list|(
name|ek
argument_list|,
name|enc_key
argument_list|,
name|kbits
argument_list|)
expr_stmt|;
name|dkey
operator|=
name|dec_key
expr_stmt|;
name|dkey
operator|+=
operator|(
name|kbits
operator|/
literal|8
operator|)
operator|/
literal|4
expr_stmt|;
switch|switch
condition|(
name|kbits
condition|)
block|{
case|case
literal|128
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
operator|--
name|dkey
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|10
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|192
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
operator|*
operator|--
name|dkey
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|11
operator|+
literal|2
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
operator|--
name|dkey
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|12
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|256
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
operator|--
name|dkey
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|13
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
operator|--
name|dkey
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|14
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|MPASS
argument_list|(
name|dkey
operator|==
name|dec_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ccr_aes_setkey
parameter_list|(
name|struct
name|ccr_session
modifier|*
name|s
parameter_list|,
name|int
name|alg
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|int
name|klen
parameter_list|)
block|{
name|unsigned
name|int
name|ck_size
decl_stmt|,
name|iopad_size
decl_stmt|,
name|kctx_flits
decl_stmt|,
name|kctx_len
decl_stmt|,
name|kbits
decl_stmt|,
name|mk_size
decl_stmt|;
name|unsigned
name|int
name|opad_present
decl_stmt|;
if|if
condition|(
name|alg
operator|==
name|CRYPTO_AES_XTS
condition|)
name|kbits
operator|=
name|klen
operator|/
literal|2
expr_stmt|;
else|else
name|kbits
operator|=
name|klen
expr_stmt|;
switch|switch
condition|(
name|kbits
condition|)
block|{
case|case
literal|128
case|:
name|ck_size
operator|=
name|CHCR_KEYCTX_CIPHER_KEY_SIZE_128
expr_stmt|;
break|break;
case|case
literal|192
case|:
name|ck_size
operator|=
name|CHCR_KEYCTX_CIPHER_KEY_SIZE_192
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|ck_size
operator|=
name|CHCR_KEYCTX_CIPHER_KEY_SIZE_256
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"should not get here"
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|blkcipher
operator|.
name|key_len
operator|=
name|klen
operator|/
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|enckey
argument_list|,
name|key
argument_list|,
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|CRYPTO_AES_CBC
case|:
case|case
name|CRYPTO_AES_XTS
case|:
name|ccr_aes_getdeckey
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|deckey
argument_list|,
name|key
argument_list|,
name|kbits
argument_list|)
expr_stmt|;
break|break;
block|}
name|kctx_len
operator|=
name|roundup2
argument_list|(
name|s
operator|->
name|blkcipher
operator|.
name|key_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|mode
condition|)
block|{
case|case
name|AUTHENC
case|:
name|mk_size
operator|=
name|s
operator|->
name|hmac
operator|.
name|mk_size
expr_stmt|;
name|opad_present
operator|=
literal|1
expr_stmt|;
name|iopad_size
operator|=
name|roundup2
argument_list|(
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|kctx_len
operator|+=
name|iopad_size
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|GCM
case|:
name|mk_size
operator|=
name|CHCR_KEYCTX_MAC_KEY_SIZE_128
expr_stmt|;
name|opad_present
operator|=
literal|0
expr_stmt|;
name|kctx_len
operator|+=
name|GMAC_BLOCK_LEN
expr_stmt|;
break|break;
default|default:
name|mk_size
operator|=
name|CHCR_KEYCTX_NO_KEY
expr_stmt|;
name|opad_present
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|kctx_flits
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_key_ctx
argument_list|)
operator|+
name|kctx_len
operator|)
operator|/
literal|16
expr_stmt|;
name|s
operator|->
name|blkcipher
operator|.
name|key_ctx_hdr
operator|=
name|htobe32
argument_list|(
name|V_KEY_CONTEXT_CTX_LEN
argument_list|(
name|kctx_flits
argument_list|)
operator||
name|V_KEY_CONTEXT_DUAL_CK
argument_list|(
name|alg
operator|==
name|CRYPTO_AES_XTS
argument_list|)
operator||
name|V_KEY_CONTEXT_OPAD_PRESENT
argument_list|(
name|opad_present
argument_list|)
operator||
name|V_KEY_CONTEXT_SALT_PRESENT
argument_list|(
literal|1
argument_list|)
operator||
name|V_KEY_CONTEXT_CK_SIZE
argument_list|(
name|ck_size
argument_list|)
operator||
name|V_KEY_CONTEXT_MK_SIZE
argument_list|(
name|mk_size
argument_list|)
operator||
name|V_KEY_CONTEXT_VALID
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_newsession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|sidp
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cri
parameter_list|)
block|{
name|struct
name|ccr_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ccr_session
modifier|*
name|s
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|auth_hash
decl_stmt|;
name|struct
name|cryptoini
modifier|*
name|c
decl_stmt|,
modifier|*
name|hash
decl_stmt|,
modifier|*
name|cipher
decl_stmt|;
name|unsigned
name|int
name|auth_mode
decl_stmt|,
name|cipher_mode
decl_stmt|,
name|iv_len
decl_stmt|,
name|mk_size
decl_stmt|;
name|unsigned
name|int
name|partial_digest_len
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|sess
decl_stmt|;
name|bool
name|gcm_hash
decl_stmt|;
if|if
condition|(
name|sidp
operator|==
name|NULL
operator|||
name|cri
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gcm_hash
operator|=
name|false
expr_stmt|;
name|cipher
operator|=
name|NULL
expr_stmt|;
name|hash
operator|=
name|NULL
expr_stmt|;
name|auth_hash
operator|=
name|NULL
expr_stmt|;
name|auth_mode
operator|=
name|CHCR_SCMD_AUTH_MODE_NOP
expr_stmt|;
name|cipher_mode
operator|=
name|CHCR_SCMD_CIPHER_MODE_NOP
expr_stmt|;
name|iv_len
operator|=
literal|0
expr_stmt|;
name|mk_size
operator|=
literal|0
expr_stmt|;
name|partial_digest_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cri
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|cri_next
control|)
block|{
switch|switch
condition|(
name|c
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
case|case
name|CRYPTO_AES_128_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_192_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_256_NIST_GMAC
case|:
if|if
condition|(
name|hash
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hash
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_SHA1_HMAC
case|:
name|auth_hash
operator|=
operator|&
name|auth_hash_hmac_sha1
expr_stmt|;
name|auth_mode
operator|=
name|CHCR_SCMD_AUTH_MODE_SHA1
expr_stmt|;
name|mk_size
operator|=
name|CHCR_KEYCTX_MAC_KEY_SIZE_160
expr_stmt|;
name|partial_digest_len
operator|=
name|SHA1_HASH_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
name|auth_hash
operator|=
operator|&
name|auth_hash_hmac_sha2_256
expr_stmt|;
name|auth_mode
operator|=
name|CHCR_SCMD_AUTH_MODE_SHA256
expr_stmt|;
name|mk_size
operator|=
name|CHCR_KEYCTX_MAC_KEY_SIZE_256
expr_stmt|;
name|partial_digest_len
operator|=
name|SHA2_256_HASH_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
name|auth_hash
operator|=
operator|&
name|auth_hash_hmac_sha2_384
expr_stmt|;
name|auth_mode
operator|=
name|CHCR_SCMD_AUTH_MODE_SHA512_384
expr_stmt|;
name|mk_size
operator|=
name|CHCR_KEYCTX_MAC_KEY_SIZE_512
expr_stmt|;
name|partial_digest_len
operator|=
name|SHA2_512_HASH_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
name|auth_hash
operator|=
operator|&
name|auth_hash_hmac_sha2_512
expr_stmt|;
name|auth_mode
operator|=
name|CHCR_SCMD_AUTH_MODE_SHA512_512
expr_stmt|;
name|mk_size
operator|=
name|CHCR_KEYCTX_MAC_KEY_SIZE_512
expr_stmt|;
name|partial_digest_len
operator|=
name|SHA2_512_HASH_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_128_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_192_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_256_NIST_GMAC
case|:
name|gcm_hash
operator|=
name|true
expr_stmt|;
name|auth_mode
operator|=
name|CHCR_SCMD_AUTH_MODE_GHASH
expr_stmt|;
name|mk_size
operator|=
name|CHCR_KEYCTX_MAC_KEY_SIZE_128
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CRYPTO_AES_CBC
case|:
case|case
name|CRYPTO_AES_ICM
case|:
case|case
name|CRYPTO_AES_NIST_GCM_16
case|:
case|case
name|CRYPTO_AES_XTS
case|:
if|if
condition|(
name|cipher
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cipher
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_AES_CBC
case|:
name|cipher_mode
operator|=
name|CHCR_SCMD_CIPHER_MODE_AES_CBC
expr_stmt|;
name|iv_len
operator|=
name|AES_BLOCK_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_ICM
case|:
name|cipher_mode
operator|=
name|CHCR_SCMD_CIPHER_MODE_AES_CTR
expr_stmt|;
name|iv_len
operator|=
name|AES_BLOCK_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_NIST_GCM_16
case|:
name|cipher_mode
operator|=
name|CHCR_SCMD_CIPHER_MODE_AES_GCM
expr_stmt|;
name|iv_len
operator|=
name|AES_GCM_IV_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_XTS
case|:
name|cipher_mode
operator|=
name|CHCR_SCMD_CIPHER_MODE_AES_XTS
expr_stmt|;
name|iv_len
operator|=
name|AES_BLOCK_LEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|cri_key
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ccr_aes_check_keylen
argument_list|(
name|c
operator|->
name|cri_alg
argument_list|,
name|c
operator|->
name|cri_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|gcm_hash
operator|!=
operator|(
name|cipher_mode
operator|==
name|CHCR_SCMD_CIPHER_MODE_AES_GCM
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|hash
operator|==
name|NULL
operator|&&
name|cipher
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|hash
operator|!=
name|NULL
operator|&&
name|hash
operator|->
name|cri_key
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|detaching
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sess
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nsessions
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sessions
index|[
name|i
index|]
operator|.
name|active
operator|&&
name|sc
operator|->
name|sessions
index|[
name|i
index|]
operator|.
name|pending
operator|==
literal|0
condition|)
block|{
name|sess
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sess
operator|==
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|nsessions
operator|+
literal|1
operator|)
argument_list|,
name|M_CCR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sessions
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|s
argument_list|,
name|sc
operator|->
name|sessions
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
operator|*
name|sc
operator|->
name|nsessions
argument_list|)
expr_stmt|;
name|sess
operator|=
name|sc
operator|->
name|nsessions
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sessions
argument_list|,
name|M_CCR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sessions
operator|=
name|s
expr_stmt|;
name|sc
operator|->
name|nsessions
operator|++
expr_stmt|;
block|}
name|s
operator|=
operator|&
name|sc
operator|->
name|sessions
index|[
name|sess
index|]
expr_stmt|;
if|if
condition|(
name|gcm_hash
condition|)
name|s
operator|->
name|mode
operator|=
name|GCM
expr_stmt|;
elseif|else
if|if
condition|(
name|hash
operator|!=
name|NULL
operator|&&
name|cipher
operator|!=
name|NULL
condition|)
name|s
operator|->
name|mode
operator|=
name|AUTHENC
expr_stmt|;
elseif|else
if|if
condition|(
name|hash
operator|!=
name|NULL
condition|)
name|s
operator|->
name|mode
operator|=
name|HMAC
expr_stmt|;
else|else
block|{
name|MPASS
argument_list|(
name|cipher
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|BLKCIPHER
expr_stmt|;
block|}
if|if
condition|(
name|gcm_hash
condition|)
block|{
if|if
condition|(
name|hash
operator|->
name|cri_mlen
operator|==
literal|0
condition|)
name|s
operator|->
name|gmac
operator|.
name|hash_len
operator|=
name|AES_GMAC_HASH_LEN
expr_stmt|;
else|else
name|s
operator|->
name|gmac
operator|.
name|hash_len
operator|=
name|hash
operator|->
name|cri_mlen
expr_stmt|;
name|ccr_init_gmac_hash
argument_list|(
name|s
argument_list|,
name|hash
operator|->
name|cri_key
argument_list|,
name|hash
operator|->
name|cri_klen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hash
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|hmac
operator|.
name|auth_hash
operator|=
name|auth_hash
expr_stmt|;
name|s
operator|->
name|hmac
operator|.
name|auth_mode
operator|=
name|auth_mode
expr_stmt|;
name|s
operator|->
name|hmac
operator|.
name|mk_size
operator|=
name|mk_size
expr_stmt|;
name|s
operator|->
name|hmac
operator|.
name|partial_digest_len
operator|=
name|partial_digest_len
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|cri_mlen
operator|==
literal|0
condition|)
name|s
operator|->
name|hmac
operator|.
name|hash_len
operator|=
name|auth_hash
operator|->
name|hashsize
expr_stmt|;
else|else
name|s
operator|->
name|hmac
operator|.
name|hash_len
operator|=
name|hash
operator|->
name|cri_mlen
expr_stmt|;
name|ccr_init_hmac_digest
argument_list|(
name|s
argument_list|,
name|hash
operator|->
name|cri_alg
argument_list|,
name|hash
operator|->
name|cri_key
argument_list|,
name|hash
operator|->
name|cri_klen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cipher
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|blkcipher
operator|.
name|cipher_mode
operator|=
name|cipher_mode
expr_stmt|;
name|s
operator|->
name|blkcipher
operator|.
name|iv_len
operator|=
name|iv_len
expr_stmt|;
if|if
condition|(
name|cipher
operator|->
name|cri_key
operator|!=
name|NULL
condition|)
name|ccr_aes_setkey
argument_list|(
name|s
argument_list|,
name|cipher
operator|->
name|cri_alg
argument_list|,
name|cipher
operator|->
name|cri_key
argument_list|,
name|cipher
operator|->
name|cri_klen
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|sidp
operator|=
name|sess
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_freesession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|tid
parameter_list|)
block|{
name|struct
name|ccr_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|sid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sid
operator|=
name|CRYPTO_SESID2LID
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sid
operator|>=
name|sc
operator|->
name|nsessions
operator|||
operator|!
name|sc
operator|->
name|sessions
index|[
name|sid
index|]
operator|.
name|active
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sessions
index|[
name|sid
index|]
operator|.
name|pending
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"session %d freed with %d pending requests\n"
argument_list|,
name|sid
argument_list|,
name|sc
operator|->
name|sessions
index|[
name|sid
index|]
operator|.
name|pending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sessions
index|[
name|sid
index|]
operator|.
name|active
operator|=
name|false
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_process
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|ccr_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ccr_session
modifier|*
name|s
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|,
modifier|*
name|crda
decl_stmt|,
modifier|*
name|crde
decl_stmt|;
name|uint32_t
name|sid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|sid
operator|=
name|CRYPTO_SESID2LID
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sid
operator|>=
name|sc
operator|->
name|nsessions
operator|||
operator|!
name|sc
operator|->
name|sessions
index|[
name|sid
index|]
operator|.
name|active
condition|)
block|{
name|sc
operator|->
name|stats_bad_session
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|ccr_populate_sglist
argument_list|(
name|sc
operator|->
name|sg_crp
argument_list|,
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sc
operator|->
name|stats_sglist_error
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|s
operator|=
operator|&
name|sc
operator|->
name|sessions
index|[
name|sid
index|]
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|mode
condition|)
block|{
case|case
name|HMAC
case|:
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
name|ccr_init_hmac_digest
argument_list|(
name|s
argument_list|,
name|crd
operator|->
name|crd_alg
argument_list|,
name|crd
operator|->
name|crd_key
argument_list|,
name|crd
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
name|error
operator|=
name|ccr_hmac
argument_list|(
name|sc
argument_list|,
name|sid
argument_list|,
name|s
argument_list|,
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|stats_hmac
operator|++
expr_stmt|;
break|break;
case|case
name|BLKCIPHER
case|:
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
name|error
operator|=
name|ccr_aes_check_keylen
argument_list|(
name|crd
operator|->
name|crd_alg
argument_list|,
name|crd
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ccr_aes_setkey
argument_list|(
name|s
argument_list|,
name|crd
operator|->
name|crd_alg
argument_list|,
name|crd
operator|->
name|crd_key
argument_list|,
name|crd
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ccr_blkcipher
argument_list|(
name|sc
argument_list|,
name|sid
argument_list|,
name|s
argument_list|,
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|sc
operator|->
name|stats_blkcipher_encrypt
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|stats_blkcipher_decrypt
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|AUTHENC
case|:
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|crd
operator|->
name|crd_alg
condition|)
block|{
case|case
name|CRYPTO_AES_CBC
case|:
case|case
name|CRYPTO_AES_ICM
case|:
case|case
name|CRYPTO_AES_XTS
case|:
comment|/* Only encrypt-then-authenticate supported. */
name|crde
operator|=
name|crd
expr_stmt|;
name|crda
operator|=
name|crd
operator|->
name|crd_next
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|crda
operator|=
name|crd
expr_stmt|;
name|crde
operator|=
name|crd
operator|->
name|crd_next
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|crda
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
name|ccr_init_hmac_digest
argument_list|(
name|s
argument_list|,
name|crda
operator|->
name|crd_alg
argument_list|,
name|crda
operator|->
name|crd_key
argument_list|,
name|crda
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
name|error
operator|=
name|ccr_aes_check_keylen
argument_list|(
name|crde
operator|->
name|crd_alg
argument_list|,
name|crde
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ccr_aes_setkey
argument_list|(
name|s
argument_list|,
name|crde
operator|->
name|crd_alg
argument_list|,
name|crde
operator|->
name|crd_key
argument_list|,
name|crde
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ccr_authenc
argument_list|(
name|sc
argument_list|,
name|sid
argument_list|,
name|s
argument_list|,
name|crp
argument_list|,
name|crda
argument_list|,
name|crde
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|sc
operator|->
name|stats_authenc_encrypt
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|stats_authenc_decrypt
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|GCM
case|:
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_NIST_GCM_16
condition|)
block|{
name|crde
operator|=
name|crd
expr_stmt|;
name|crda
operator|=
name|crd
operator|->
name|crd_next
expr_stmt|;
block|}
else|else
block|{
name|crda
operator|=
name|crd
expr_stmt|;
name|crde
operator|=
name|crd
operator|->
name|crd_next
expr_stmt|;
block|}
if|if
condition|(
name|crda
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
name|ccr_init_gmac_hash
argument_list|(
name|s
argument_list|,
name|crda
operator|->
name|crd_key
argument_list|,
name|crda
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
name|error
operator|=
name|ccr_aes_check_keylen
argument_list|(
name|crde
operator|->
name|crd_alg
argument_list|,
name|crde
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ccr_aes_setkey
argument_list|(
name|s
argument_list|,
name|crde
operator|->
name|crd_alg
argument_list|,
name|crde
operator|->
name|crd_key
argument_list|,
name|crde
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ccr_gcm
argument_list|(
name|sc
argument_list|,
name|sid
argument_list|,
name|s
argument_list|,
name|crp
argument_list|,
name|crda
argument_list|,
name|crde
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|sc
operator|->
name|stats_gcm_encrypt
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|stats_gcm_decrypt
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|pending
operator|++
expr_stmt|;
name|sc
operator|->
name|stats_inflight
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|stats_process_error
operator|++
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|error
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_cpl6_fw_pld
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ccr_softc
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
operator|->
name|ccr_softc
decl_stmt|;
name|struct
name|ccr_session
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|cpl_fw6_pld
modifier|*
name|cpl
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|uint32_t
name|sid
decl_stmt|,
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|cpl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
else|else
name|cpl
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
expr_stmt|;
name|crp
operator|=
operator|(
expr|struct
name|cryptop
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|be64toh
argument_list|(
name|cpl
operator|->
name|data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sid
operator|=
name|CRYPTO_SESID2LID
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
expr_stmt|;
name|status
operator|=
name|be64toh
argument_list|(
name|cpl
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHK_MAC_ERR_BIT
argument_list|(
name|status
argument_list|)
operator|||
name|CHK_PAD_ERR_BIT
argument_list|(
name|status
argument_list|)
condition|)
name|error
operator|=
name|EBADMSG
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sid
operator|<
name|sc
operator|->
name|nsessions
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|sc
operator|->
name|sessions
index|[
name|sid
index|]
expr_stmt|;
name|s
operator|->
name|pending
operator|--
expr_stmt|;
name|sc
operator|->
name|stats_inflight
operator|--
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|mode
condition|)
block|{
case|case
name|HMAC
case|:
name|error
operator|=
name|ccr_hmac_done
argument_list|(
name|sc
argument_list|,
name|s
argument_list|,
name|crp
argument_list|,
name|cpl
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|BLKCIPHER
case|:
name|error
operator|=
name|ccr_blkcipher_done
argument_list|(
name|sc
argument_list|,
name|s
argument_list|,
name|crp
argument_list|,
name|cpl
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTHENC
case|:
name|error
operator|=
name|ccr_authenc_done
argument_list|(
name|sc
argument_list|,
name|s
argument_list|,
name|crp
argument_list|,
name|cpl
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|GCM
case|:
name|error
operator|=
name|ccr_gcm_done
argument_list|(
name|sc
argument_list|,
name|s
argument_list|,
name|crp
argument_list|,
name|cpl
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
name|EBADMSG
condition|)
block|{
if|if
condition|(
name|CHK_MAC_ERR_BIT
argument_list|(
name|status
argument_list|)
condition|)
name|sc
operator|->
name|stats_mac_error
operator|++
expr_stmt|;
if|if
condition|(
name|CHK_PAD_ERR_BIT
argument_list|(
name|status
argument_list|)
condition|)
name|sc
operator|->
name|stats_pad_error
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|error
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ccr_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|t4_register_cpl_handler
argument_list|(
name|CPL_FW6_PLD
argument_list|,
name|do_cpl6_fw_pld
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MOD_UNLOAD
case|:
name|t4_register_cpl_handler
argument_list|(
name|CPL_FW6_PLD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ccr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|ccr_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ccr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ccr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ccr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_newsession
argument_list|,
name|ccr_newsession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_freesession
argument_list|,
name|ccr_freesession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_process
argument_list|,
name|ccr_process
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ccr_driver
init|=
block|{
literal|"ccr"
block|,
name|ccr_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ccr_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ccr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ccr
argument_list|,
name|t6nex
argument_list|,
name|ccr_driver
argument_list|,
name|ccr_devclass
argument_list|,
name|ccr_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ccr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ccr
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ccr
argument_list|,
name|t6nex
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

