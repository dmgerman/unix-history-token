begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    FastLZ - lightning-fast lossless compression library     Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)    Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)    Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)     Permission is hereby granted, free of charge, to any person obtaining a copy    of this software and associated documentation files (the "Software"), to deal    in the Software without restriction, including without limitation the rights    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell    copies of the Software, and to permit persons to whom the Software is    furnished to do so, subject to the following conditions:     The above copyright notice and this permission notice shall be included in    all copies or substantial portions of the Software.     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN    THE SOFTWARE.    */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"osdep.h"
end_include

begin_include
include|#
directive|include
file|"fastlz.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FASTLZ__COMPRESSOR
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FASTLZ_DECOMPRESSOR
argument_list|)
end_if

begin_comment
comment|/*  * Always check for bound when decompressing.  * Generally it is best to leave it defined.  */
end_comment

begin_define
define|#
directive|define
name|FASTLZ_SAFE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__NT__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_comment
comment|/* #include<windows.h> */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4242
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Give hints to the compiler for branch prediction optimization.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|2
operator|)
end_if

begin_define
define|#
directive|define
name|FASTLZ_EXPECT_CONDITIONAL
parameter_list|(
name|c
parameter_list|)
value|(__builtin_expect((c), 1))
end_define

begin_define
define|#
directive|define
name|FASTLZ_UNEXPECT_CONDITIONAL
parameter_list|(
name|c
parameter_list|)
value|(__builtin_expect((c), 0))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FASTLZ_EXPECT_CONDITIONAL
parameter_list|(
name|c
parameter_list|)
value|(c)
end_define

begin_define
define|#
directive|define
name|FASTLZ_UNEXPECT_CONDITIONAL
parameter_list|(
name|c
parameter_list|)
value|(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Use inlined functions for supported systems.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__DMC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POCC__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__SUNPRO_C
argument_list|)
end_if

begin_define
define|#
directive|define
name|FASTLZ_INLINE
value|inline
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__LCC__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|FASTLZ_INLINE
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FASTLZ_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prevent accessing more than 8-bit at once, except on x86 architectures.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FASTLZ_STRICT_ALIGN
argument_list|)
end_if

begin_define
define|#
directive|define
name|FASTLZ_STRICT_ALIGN
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__386
argument_list|)
end_if

begin_comment
comment|/* GNU C, Sun Studio */
end_comment

begin_undef
undef|#
directive|undef
name|FASTLZ_STRICT_ALIGN
end_undef

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__i486__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i586__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i686__
argument_list|)
end_elif

begin_comment
comment|/* GNU C */
end_comment

begin_undef
undef|#
directive|undef
name|FASTLZ_STRICT_ALIGN
end_undef

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_elif

begin_comment
comment|/* Intel, MSVC */
end_comment

begin_undef
undef|#
directive|undef
name|FASTLZ_STRICT_ALIGN
end_undef

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__386
argument_list|)
end_elif

begin_undef
undef|#
directive|undef
name|FASTLZ_STRICT_ALIGN
end_undef

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_X86_
argument_list|)
end_elif

begin_comment
comment|/* MinGW */
end_comment

begin_undef
undef|#
directive|undef
name|FASTLZ_STRICT_ALIGN
end_undef

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__I86__
argument_list|)
end_elif

begin_comment
comment|/* Digital Mars */
end_comment

begin_undef
undef|#
directive|undef
name|FASTLZ_STRICT_ALIGN
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * FIXME: use preprocessor magic to set this on different platforms!  */
end_comment

begin_define
define|#
directive|define
name|MAX_COPY
value|32
end_define

begin_define
define|#
directive|define
name|MAX_LEN
value|264
end_define

begin_comment
comment|/* 256 + 8 */
end_comment

begin_define
define|#
directive|define
name|MAX_DISTANCE
value|8192
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FASTLZ_STRICT_ALIGN
argument_list|)
end_if

begin_define
define|#
directive|define
name|FASTLZ_READU16
parameter_list|(
name|p
parameter_list|)
value|(*((const unsigned short *)(p)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FASTLZ_READU16
parameter_list|(
name|p
parameter_list|)
value|((p)[0] | (p)[1]<<8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HASH_LOG
value|13
end_define

begin_define
define|#
directive|define
name|HASH_SIZE
value|(1<< HASH_LOG)
end_define

begin_define
define|#
directive|define
name|HASH_MASK
value|(HASH_SIZE - 1)
end_define

begin_define
define|#
directive|define
name|HASH_FUNCTION
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|)
value|{\ 				v = FASTLZ_READU16(p);\ 				v ^= FASTLZ_READU16(p + 1)^\ 				     (v>>(16 - HASH_LOG));\ 				v&= HASH_MASK;\ 			    }
end_define

begin_undef
undef|#
directive|undef
name|FASTLZ_LEVEL
end_undef

begin_define
define|#
directive|define
name|FASTLZ_LEVEL
value|1
end_define

begin_undef
undef|#
directive|undef
name|FASTLZ_COMPRESSOR
end_undef

begin_undef
undef|#
directive|undef
name|FASTLZ_DECOMPRESSOR
end_undef

begin_define
define|#
directive|define
name|FASTLZ_COMPRESSOR
value|fastlz1_compress
end_define

begin_define
define|#
directive|define
name|FASTLZ_DECOMPRESSOR
value|fastlz1_decompress
end_define

begin_function_decl
specifier|static
name|FASTLZ_INLINE
name|int
name|FASTLZ_COMPRESSOR
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FASTLZ_INLINE
name|int
name|FASTLZ_DECOMPRESSOR
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|,
name|int
name|maxout
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"fastlz.c"
end_include

begin_undef
undef|#
directive|undef
name|FASTLZ_LEVEL
end_undef

begin_define
define|#
directive|define
name|FASTLZ_LEVEL
value|2
end_define

begin_undef
undef|#
directive|undef
name|MAX_DISTANCE
end_undef

begin_define
define|#
directive|define
name|MAX_DISTANCE
value|8191
end_define

begin_define
define|#
directive|define
name|MAX_FARDISTANCE
value|(65535 + MAX_DISTANCE - 1)
end_define

begin_undef
undef|#
directive|undef
name|FASTLZ_COMPRESSOR
end_undef

begin_undef
undef|#
directive|undef
name|FASTLZ_DECOMPRESSOR
end_undef

begin_define
define|#
directive|define
name|FASTLZ_COMPRESSOR
value|fastlz2_compress
end_define

begin_define
define|#
directive|define
name|FASTLZ_DECOMPRESSOR
value|fastlz2_decompress
end_define

begin_function_decl
specifier|static
name|FASTLZ_INLINE
name|int
name|FASTLZ_COMPRESSOR
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FASTLZ_INLINE
name|int
name|FASTLZ_DECOMPRESSOR
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|,
name|int
name|maxout
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"fastlz.c"
end_include

begin_function
name|int
name|fastlz_compress
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
block|{
comment|/* for short block, choose fastlz1 */
if|if
condition|(
name|length
operator|<
literal|65536
condition|)
return|return
name|fastlz1_compress
argument_list|(
name|input
argument_list|,
name|length
argument_list|,
name|output
argument_list|)
return|;
comment|/* else... */
return|return
name|fastlz2_compress
argument_list|(
name|input
argument_list|,
name|length
argument_list|,
name|output
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|fastlz_decompress
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|,
name|int
name|maxout
parameter_list|)
block|{
comment|/* magic identifier for compression level */
name|int
name|level
init|=
operator|(
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|input
operator|)
operator|>>
literal|5
operator|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
return|return
name|fastlz1_decompress
argument_list|(
name|input
argument_list|,
name|length
argument_list|,
name|output
argument_list|,
name|maxout
argument_list|)
return|;
if|if
condition|(
name|level
operator|==
literal|2
condition|)
return|return
name|fastlz2_decompress
argument_list|(
name|input
argument_list|,
name|length
argument_list|,
name|output
argument_list|,
name|maxout
argument_list|)
return|;
comment|/* unknown level, trigger error */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fastlz_compress_level
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
literal|1
condition|)
return|return
name|fastlz1_compress
argument_list|(
name|input
argument_list|,
name|length
argument_list|,
name|output
argument_list|)
return|;
if|if
condition|(
name|level
operator|==
literal|2
condition|)
return|return
name|fastlz2_compress
argument_list|(
name|input
argument_list|,
name|length
argument_list|,
name|output
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined(FASTLZ_COMPRESSOR)&& !defined(FASTLZ_DECOMPRESSOR) */
end_comment

begin_function
specifier|static
name|FASTLZ_INLINE
name|int
name|FASTLZ_COMPRESSOR
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ip
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ip_bound
init|=
name|ip
operator|+
name|length
operator|-
literal|2
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ip_limit
init|=
name|ip
operator|+
name|length
operator|-
literal|12
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|output
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|g_htab
index|[
name|HASH_SIZE
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|htab
init|=
name|g_htab
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|hslot
decl_stmt|;
name|unsigned
name|int
name|hval
decl_stmt|;
name|unsigned
name|int
name|copy
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|length
operator|<
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
comment|/* create literal copy only */
operator|*
name|op
operator|++
operator|=
name|length
operator|-
literal|1
expr_stmt|;
name|ip_bound
operator|++
expr_stmt|;
while|while
condition|(
name|ip
operator|<=
name|ip_bound
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
return|return
name|length
operator|+
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* initializes hash table */
for|for
control|(
name|hslot
operator|=
name|htab
init|;
name|hslot
operator|<
name|htab
operator|+
name|HASH_SIZE
condition|;
name|hslot
operator|++
control|)
operator|*
name|hslot
operator|=
name|ip
expr_stmt|;
comment|/* we start with literal copy */
name|copy
operator|=
literal|2
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|MAX_COPY
operator|-
literal|1
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
comment|/* main loop */
while|while
condition|(
name|FASTLZ_EXPECT_CONDITIONAL
argument_list|(
name|ip
operator|<
name|ip_limit
argument_list|)
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ref
decl_stmt|;
name|unsigned
name|int
name|distance
decl_stmt|;
comment|/* minimum match length */
name|unsigned
name|int
name|len
init|=
literal|3
decl_stmt|;
comment|/* comparison starting-point */
specifier|const
name|unsigned
name|char
modifier|*
name|anchor
init|=
name|ip
decl_stmt|;
comment|/* check for a run */
if|#
directive|if
name|FASTLZ_LEVEL
operator|==
literal|2
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|ip
index|[
operator|-
literal|1
index|]
operator|&&
name|FASTLZ_READU16
argument_list|(
name|ip
operator|-
literal|1
argument_list|)
operator|==
name|FASTLZ_READU16
argument_list|(
name|ip
operator|+
literal|1
argument_list|)
condition|)
block|{
name|distance
operator|=
literal|1
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
name|ref
operator|=
name|anchor
operator|-
literal|1
operator|+
literal|3
expr_stmt|;
goto|goto
name|match
goto|;
block|}
endif|#
directive|endif
comment|/* find potential match */
name|HASH_FUNCTION
argument_list|(
name|hval
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|hslot
operator|=
name|htab
operator|+
name|hval
expr_stmt|;
name|ref
operator|=
name|htab
index|[
name|hval
index|]
expr_stmt|;
comment|/* calculate distance to the match */
name|distance
operator|=
name|anchor
operator|-
name|ref
expr_stmt|;
comment|/* update hash table */
operator|*
name|hslot
operator|=
name|anchor
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
goto|goto
name|literal
goto|;
comment|/* is this a match? check the first 3 bytes */
if|if
condition|(
name|distance
operator|==
literal|0
operator|||
if|#
directive|if
name|FASTLZ_LEVEL
operator|==
literal|1
operator|(
name|distance
operator|>=
name|MAX_DISTANCE
operator|)
operator|||
else|#
directive|else
operator|(
name|distance
operator|>=
name|MAX_FARDISTANCE
operator|)
operator|||
endif|#
directive|endif
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
operator|||
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
operator|||
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
goto|goto
name|literal
goto|;
if|#
directive|if
name|FASTLZ_LEVEL
operator|==
literal|2
comment|/* far, needs at least 5-byte match */
if|if
condition|(
name|distance
operator|>=
name|MAX_DISTANCE
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|++
operator|!=
operator|*
name|ref
operator|++
operator|||
operator|*
name|ip
operator|++
operator|!=
operator|*
name|ref
operator|++
condition|)
goto|goto
name|literal
goto|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
name|match
label|:
endif|#
directive|endif
comment|/* last matched byte */
name|ip
operator|=
name|anchor
operator|+
name|len
expr_stmt|;
comment|/* distance is biased */
name|distance
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|distance
condition|)
block|{
comment|/* zero distance means a run */
name|unsigned
name|char
name|x
init|=
name|ip
index|[
operator|-
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|ip
operator|<
name|ip_bound
condition|)
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
name|x
condition|)
break|break;
else|else
name|ip
operator|++
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* safe because the outer check 				 * against ip limit */
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
while|while
condition|(
name|ip
operator|<
name|ip_bound
condition|)
if|if
condition|(
operator|*
name|ref
operator|++
operator|!=
operator|*
name|ip
operator|++
condition|)
break|break;
break|break;
block|}
comment|/* if we have copied something, adjust the copy count */
if|if
condition|(
name|copy
condition|)
comment|/* copy is biased, '0' means 1 byte copy */
operator|*
operator|(
name|op
operator|-
name|copy
operator|-
literal|1
operator|)
operator|=
name|copy
operator|-
literal|1
expr_stmt|;
else|else
comment|/* back, to overwrite the copy count */
name|op
operator|--
expr_stmt|;
comment|/* reset literal counter */
name|copy
operator|=
literal|0
expr_stmt|;
comment|/* length is biased, '1' means a match of 3 bytes */
name|ip
operator|-=
literal|3
expr_stmt|;
name|len
operator|=
name|ip
operator|-
name|anchor
expr_stmt|;
comment|/* encode the match */
if|#
directive|if
name|FASTLZ_LEVEL
operator|==
literal|2
if|if
condition|(
name|distance
operator|<
name|MAX_DISTANCE
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|7
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|(
name|len
operator|<<
literal|5
operator|)
operator|+
operator|(
name|distance
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|distance
operator|&
literal|255
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op
operator|++
operator|=
operator|(
literal|7
operator|<<
literal|5
operator|)
operator|+
operator|(
name|distance
operator|>>
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|len
operator|-=
literal|7
init|;
name|len
operator|>=
literal|255
condition|;
name|len
operator|-=
literal|255
control|)
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|len
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|distance
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* far away, but not yet in the another galaxy... */
if|if
condition|(
name|len
operator|<
literal|7
condition|)
block|{
name|distance
operator|-=
name|MAX_DISTANCE
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|len
operator|<<
literal|5
operator|)
operator|+
literal|31
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|distance
operator|>>
literal|8
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|distance
operator|&
literal|255
expr_stmt|;
block|}
else|else
block|{
name|distance
operator|-=
name|MAX_DISTANCE
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
literal|7
operator|<<
literal|5
operator|)
operator|+
literal|31
expr_stmt|;
for|for
control|(
name|len
operator|-=
literal|7
init|;
name|len
operator|>=
literal|255
condition|;
name|len
operator|-=
literal|255
control|)
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|len
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|distance
operator|>>
literal|8
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|distance
operator|&
literal|255
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|len
operator|>
name|MAX_LEN
operator|-
literal|2
argument_list|)
condition|)
while|while
condition|(
name|len
operator|>
name|MAX_LEN
operator|-
literal|2
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|(
literal|7
operator|<<
literal|5
operator|)
operator|+
operator|(
name|distance
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|MAX_LEN
operator|-
literal|2
operator|-
literal|7
operator|-
literal|2
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|distance
operator|&
literal|255
operator|)
expr_stmt|;
name|len
operator|-=
name|MAX_LEN
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|7
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|(
name|len
operator|<<
literal|5
operator|)
operator|+
operator|(
name|distance
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|distance
operator|&
literal|255
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op
operator|++
operator|=
operator|(
literal|7
operator|<<
literal|5
operator|)
operator|+
operator|(
name|distance
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|len
operator|-
literal|7
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|distance
operator|&
literal|255
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* update the hash at match boundary */
name|HASH_FUNCTION
argument_list|(
name|hval
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|htab
index|[
name|hval
index|]
operator|=
name|ip
operator|++
expr_stmt|;
name|HASH_FUNCTION
argument_list|(
name|hval
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|htab
index|[
name|hval
index|]
operator|=
name|ip
operator|++
expr_stmt|;
comment|/* assuming literal copy */
operator|*
name|op
operator|++
operator|=
name|MAX_COPY
operator|-
literal|1
expr_stmt|;
continue|continue;
name|literal
label|:
operator|*
name|op
operator|++
operator|=
operator|*
name|anchor
operator|++
expr_stmt|;
name|ip
operator|=
name|anchor
expr_stmt|;
name|copy
operator|++
expr_stmt|;
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|copy
operator|==
name|MAX_COPY
argument_list|)
condition|)
block|{
name|copy
operator|=
literal|0
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|MAX_COPY
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* left-over as literal copy */
name|ip_bound
operator|++
expr_stmt|;
while|while
condition|(
name|ip
operator|<=
name|ip_bound
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|copy
operator|++
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|MAX_COPY
condition|)
block|{
name|copy
operator|=
literal|0
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|MAX_COPY
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* if we have copied something, adjust the copy length */
if|if
condition|(
name|copy
condition|)
operator|*
operator|(
name|op
operator|-
name|copy
operator|-
literal|1
operator|)
operator|=
name|copy
operator|-
literal|1
expr_stmt|;
else|else
name|op
operator|--
expr_stmt|;
if|#
directive|if
name|FASTLZ_LEVEL
operator|==
literal|2
comment|/* marker for fastlz2 */
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|output
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|op
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|output
return|;
block|}
end_function

begin_function
specifier|static
name|FASTLZ_INLINE
name|int
name|FASTLZ_DECOMPRESSOR
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|output
parameter_list|,
name|int
name|maxout
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ip
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ip_limit
init|=
name|ip
operator|+
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|output
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op_limit
init|=
name|op
operator|+
name|maxout
decl_stmt|;
name|unsigned
name|int
name|ctrl
init|=
operator|(
operator|*
name|ip
operator|++
operator|)
operator|&
literal|31
decl_stmt|;
name|int
name|loop
init|=
literal|1
decl_stmt|;
do|do
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ref
init|=
name|op
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|ctrl
operator|>>
literal|5
decl_stmt|;
name|unsigned
name|int
name|ofs
init|=
operator|(
name|ctrl
operator|&
literal|31
operator|)
operator|<<
literal|8
decl_stmt|;
if|if
condition|(
name|ctrl
operator|>=
literal|32
condition|)
block|{
if|#
directive|if
name|FASTLZ_LEVEL
operator|==
literal|2
name|unsigned
name|char
name|code
decl_stmt|;
endif|#
directive|endif
name|len
operator|--
expr_stmt|;
name|ref
operator|-=
name|ofs
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|7
operator|-
literal|1
condition|)
if|#
directive|if
name|FASTLZ_LEVEL
operator|==
literal|1
name|len
operator|+=
operator|*
name|ip
operator|++
expr_stmt|;
name|ref
operator|-=
operator|*
name|ip
operator|++
expr_stmt|;
else|#
directive|else
do|do
block|{
name|code
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|len
operator|+=
name|code
expr_stmt|;
block|}
do|while
condition|(
name|code
operator|==
literal|255
condition|)
do|;
name|code
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|ref
operator|-=
name|code
expr_stmt|;
comment|/* match from 16-bit distance */
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|code
operator|==
literal|255
argument_list|)
condition|)
if|if
condition|(
name|FASTLZ_EXPECT_CONDITIONAL
argument_list|(
name|ofs
operator|==
operator|(
literal|31
operator|<<
literal|8
operator|)
argument_list|)
condition|)
block|{
name|ofs
operator|=
operator|(
operator|*
name|ip
operator|++
operator|)
operator|<<
literal|8
expr_stmt|;
name|ofs
operator|+=
operator|*
name|ip
operator|++
expr_stmt|;
name|ref
operator|=
name|op
operator|-
name|ofs
operator|-
name|MAX_DISTANCE
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FASTLZ_SAFE
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|op
operator|+
name|len
operator|+
literal|3
operator|>
name|op_limit
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|ref
operator|-
literal|1
operator|<
operator|(
name|unsigned
name|char
operator|*
operator|)
name|output
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|FASTLZ_EXPECT_CONDITIONAL
argument_list|(
name|ip
operator|<
name|ip_limit
argument_list|)
condition|)
name|ctrl
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
else|else
name|loop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ref
operator|==
name|op
condition|)
block|{
comment|/* optimize copy for a run */
name|unsigned
name|char
name|b
init|=
name|ref
index|[
operator|-
literal|1
index|]
decl_stmt|;
operator|*
name|op
operator|++
operator|=
name|b
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|b
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|b
expr_stmt|;
for|for
control|(
init|;
name|len
condition|;
operator|--
name|len
control|)
operator|*
name|op
operator|++
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FASTLZ_STRICT_ALIGN
argument_list|)
specifier|const
name|unsigned
name|short
modifier|*
name|p
decl_stmt|;
name|unsigned
name|short
modifier|*
name|q
decl_stmt|;
endif|#
directive|endif
comment|/* copy from reference */
name|ref
operator|--
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|ref
operator|++
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|ref
operator|++
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|ref
operator|++
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FASTLZ_STRICT_ALIGN
argument_list|)
comment|/* copy a byte, so that now it's word aligned */
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|*
name|ref
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|/* copy 16-bit at once */
name|q
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|op
expr_stmt|;
name|op
operator|+=
name|len
expr_stmt|;
name|p
operator|=
operator|(
specifier|const
name|unsigned
name|short
operator|*
operator|)
name|ref
expr_stmt|;
for|for
control|(
name|len
operator|>>=
literal|1
init|;
name|len
operator|>
literal|4
condition|;
name|len
operator|-=
literal|4
control|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|len
condition|;
operator|--
name|len
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|#
directive|else
for|for
control|(
init|;
name|len
condition|;
operator|--
name|len
control|)
operator|*
name|op
operator|++
operator|=
operator|*
name|ref
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|ctrl
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|FASTLZ_SAFE
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|op
operator|+
name|ctrl
operator|>
name|op_limit
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|FASTLZ_UNEXPECT_CONDITIONAL
argument_list|(
name|ip
operator|+
name|ctrl
operator|>
name|ip_limit
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
for|for
control|(
operator|--
name|ctrl
init|;
name|ctrl
condition|;
name|ctrl
operator|--
control|)
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|loop
operator|=
name|FASTLZ_EXPECT_CONDITIONAL
argument_list|(
name|ip
operator|<
name|ip_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|ctrl
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|FASTLZ_EXPECT_CONDITIONAL
argument_list|(
name|loop
argument_list|)
condition|)
do|;
return|return
name|op
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|output
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(FASTLZ_COMPRESSOR)&& !defined(FASTLZ_DECOMPRESSOR) */
end_comment

end_unit

