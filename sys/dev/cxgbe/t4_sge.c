begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/counter.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"t4_l2t.h"
end_include

begin_include
include|#
directive|include
file|"t4_mp_ring.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|T4_PKT_TIMESTAMP
end_ifdef

begin_define
define|#
directive|define
name|RX_COPY_THRESHOLD
value|(MINCLSIZE - 8)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RX_COPY_THRESHOLD
value|MINCLSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Ethernet frames are DMA'd at this byte offset into the freelist buffer.  * 0-7 are valid values.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fl_pktshift
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fl_pktshift"
argument_list|,
operator|&
name|fl_pktshift
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Pad ethernet payload up to this boundary.  * -1: driver should figure out a good value.  *  0: disable padding.  *  Any power of 2 from 32 to 4096 (both inclusive) is also a valid value.  */
end_comment

begin_decl_stmt
name|int
name|fl_pad
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fl_pad"
argument_list|,
operator|&
name|fl_pad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Status page length.  * -1: driver should figure out a good value.  *  64 or 128 are the only other valid values.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spg_len
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.spg_len"
argument_list|,
operator|&
name|spg_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Congestion drops.  * -1: no congestion feedback (not recommended).  *  0: backpressure the channel instead of dropping packets right away.  *  1: no backpressure, drop packets for the congested queue immediately.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cong_drop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.cong_drop"
argument_list|,
operator|&
name|cong_drop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Deliver multiple frames in the same free list buffer if they fit.  * -1: let the driver decide whether to enable buffer packing or not.  *  0: disable buffer packing.  *  1: enable buffer packing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|buffer_packing
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.buffer_packing"
argument_list|,
operator|&
name|buffer_packing
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Start next frame in a packed buffer at this boundary.  * -1: driver should figure out a good value.  * T4: driver will ignore this and use the same value as fl_pad above.  * T5: 16, or a power of 2 from 64 to 4096 (both inclusive) is a valid value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fl_pack
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.fl_pack"
argument_list|,
operator|&
name|fl_pack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allow the driver to create mbuf(s) in a cluster allocated for rx.  * 0: never; always allocate mbufs from the zone_mbuf UMA zone.  * 1: ok to create mbuf(s) within a cluster if there is room.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_mbufs_in_cluster
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.allow_mbufs_in_cluster"
argument_list|,
operator|&
name|allow_mbufs_in_cluster
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Largest rx cluster size that the driver is allowed to allocate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|largest_rx_cluster
init|=
name|MJUM16BYTES
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.largest_rx_cluster"
argument_list|,
operator|&
name|largest_rx_cluster
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Size of cluster allocation that's most likely to succeed.  The driver will  * fall back to this size if it fails to allocate clusters larger than this.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|safest_rx_cluster
init|=
name|PAGE_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.safest_rx_cluster"
argument_list|,
operator|&
name|safest_rx_cluster
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The interrupt holdoff timers are multiplied by this value on T6+.  * 1 and 3-17 (both inclusive) are legal values.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tscale
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.tscale"
argument_list|,
operator|&
name|tscale
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Number of LRO entries in the lro_ctrl structure per rx queue.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lro_entries
init|=
name|TCP_LRO_ENTRIES
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.lro_entries"
argument_list|,
operator|&
name|lro_entries
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This enables presorting of frames before they're fed into tcp_lro_rx.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lro_mbufs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgbe.lro_mbufs"
argument_list|,
operator|&
name|lro_mbufs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|txpkts
block|{
name|u_int
name|wr_type
decl_stmt|;
comment|/* type 0 or type 1 */
name|u_int
name|npkt
decl_stmt|;
comment|/* # of packets in this work request */
name|u_int
name|plen
decl_stmt|;
comment|/* total payload (sum of all packets) */
name|u_int
name|len16
decl_stmt|;
comment|/* # of 16B pieces used by this work request */
block|}
struct|;
end_struct

begin_comment
comment|/* A packet's SGL.  This + m_pkthdr has all info needed for tx */
end_comment

begin_struct
struct|struct
name|sgl
block|{
name|struct
name|sglist
name|sg
decl_stmt|;
name|struct
name|sglist_seg
name|seg
index|[
name|TX_SGL_SEGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|service_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|get_fl_payload
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_eth_rx
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|init_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|init_fl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|init_eq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_ring
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|bus_dma_tag_t
modifier|*
parameter_list|,
name|bus_dmamap_t
modifier|*
parameter_list|,
name|bus_addr_t
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_ring
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_dma_tag_t
parameter_list|,
name|bus_dmamap_t
parameter_list|,
name|bus_addr_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_iq_fl
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_iq_fl
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_fl_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_fwq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_fwq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_mgmtq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_mgmtq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_rxq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function_decl
specifier|static
name|int
name|alloc_ofld_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_ofld_rxq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_ofld_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_ofld_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_function_decl
specifier|static
name|int
name|alloc_nm_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_nm_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_nm_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_nm_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ctrl_eq_alloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eth_eq_alloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function_decl
specifier|static
name|int
name|ofld_eq_alloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|alloc_eq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_eq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_wrq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_wrq
modifier|*
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_wrq
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_wrq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oneseg_dma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ring_fl_db
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|refill_fl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|refill_sfl
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_fl_sdesc
parameter_list|(
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_fl_sdesc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_best_refill_source
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_safe_refill_source
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_fl_to_sfl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|get_pkt_gl
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sglist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_int
name|txpkt_len16
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_int
name|txpkt_vm_len16
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_int
name|txpkts0_len16
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_int
name|txpkts1_len16
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|write_txpkt_wr
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|fw_eth_tx_pkt_wr
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|write_txpkt_vm_wr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|fw_eth_tx_pkt_vm_wr
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_txpkts
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|txpkts
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_to_txpkts
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|txpkts
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|write_txpkts_wr
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|txpkts
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gl_to_txd
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|copy_to_txd
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ring_eq_db
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint16_t
name|read_hw_cidx
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_int
name|reclaimable_tx_desc
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_int
name|total_available_tx_desc
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|reclaim_tx_descs
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tx_reclaim
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__be64
name|get_flit
parameter_list|(
name|struct
name|sglist_seg
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_sge_egr_update
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_fw_msg
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|t4_handle_wrerr_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|__be64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wrq_tx_drain
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|drain_wrq_wr_list
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_wrq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_uint16
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_bufsizes
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_tc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|counter_u64_t
name|extfree_refs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|counter_u64_t
name|extfree_rels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|an_handler_t
name|t4_an_handler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fw_msg_handler_t
name|t4_fw_msg_handler
index|[
name|NUM_FW6_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpl_handler_t
name|t4_cpl_handler
index|[
name|NUM_CPL_CMDS
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|an_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rsp_ctrl
modifier|*
name|ctrl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: async notification on iq %p (ctrl %p)"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: async notification on iq %p (ctrl %p)\n"
argument_list|,
name|__func__
argument_list|,
name|iq
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_an_handler
parameter_list|(
name|an_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|an_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|t4_an_handler
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_msg_not_handled
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_fw6_msg
modifier|*
name|cpl
init|=
name|__containerof
argument_list|(
name|rpl
argument_list|,
expr|struct
name|cpl_fw6_msg
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: fw_msg type %d"
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: fw_msg type %d\n"
argument_list|,
name|__func__
argument_list|,
name|cpl
operator|->
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_fw_msg_handler
parameter_list|(
name|int
name|type
parameter_list|,
name|fw_msg_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|nitems
argument_list|(
name|t4_fw_msg_handler
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * These are dispatched by the handler for FW{4|6}_CPL_MSG using the CPL 	 * handler dispatch table.  Reject any attempt to install a handler for 	 * this subtype. 	 */
if|if
condition|(
name|type
operator|==
name|FW_TYPE_RSSCPL
operator|||
name|type
operator|==
name|FW6_TYPE_RSSCPL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|fw_msg_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|t4_fw_msg_handler
index|[
name|type
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: opcode 0x%02x on iq %p with payload %p"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: opcode 0x%02x on iq %p with payload %p\n"
argument_list|,
name|__func__
argument_list|,
name|rss
operator|->
name|opcode
argument_list|,
name|iq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_register_cpl_handler
parameter_list|(
name|int
name|opcode
parameter_list|,
name|cpl_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|opcode
operator|>=
name|nitems
argument_list|(
name|t4_cpl_handler
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|cpl_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|t4_cpl_handler
index|[
name|opcode
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called on MOD_LOAD.  Validates and calculates the SGE tunables.  */
end_comment

begin_function
name|void
name|t4_sge_modload
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fl_pktshift
operator|<
literal|0
operator|||
name|fl_pktshift
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid hw.cxgbe.fl_pktshift value (%d),"
literal|" using 2 instead.\n"
argument_list|,
name|fl_pktshift
argument_list|)
expr_stmt|;
name|fl_pktshift
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|spg_len
operator|!=
literal|64
operator|&&
name|spg_len
operator|!=
literal|128
condition|)
block|{
name|int
name|len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|len
operator|=
name|cpu_clflush_line_size
operator|>
literal|64
condition|?
literal|128
else|:
literal|64
expr_stmt|;
else|#
directive|else
name|len
operator|=
literal|64
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spg_len
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid hw.cxgbe.spg_len value (%d),"
literal|" using %d instead.\n"
argument_list|,
name|spg_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|spg_len
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|cong_drop
operator|<
operator|-
literal|1
operator|||
name|cong_drop
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid hw.cxgbe.cong_drop value (%d),"
literal|" using 0 instead.\n"
argument_list|,
name|cong_drop
argument_list|)
expr_stmt|;
name|cong_drop
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tscale
operator|!=
literal|1
operator|&&
operator|(
name|tscale
operator|<
literal|3
operator|||
name|tscale
operator|>
literal|17
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid hw.cxgbe.tscale value (%d),"
literal|" using 1 instead.\n"
argument_list|,
name|tscale
argument_list|)
expr_stmt|;
name|tscale
operator|=
literal|1
expr_stmt|;
block|}
name|extfree_refs
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|extfree_rels
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|counter_u64_zero
argument_list|(
name|extfree_refs
argument_list|)
expr_stmt|;
name|counter_u64_zero
argument_list|(
name|extfree_rels
argument_list|)
expr_stmt|;
name|t4_an_handler
operator|=
name|an_not_handled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t4_fw_msg_handler
argument_list|)
condition|;
name|i
operator|++
control|)
name|t4_fw_msg_handler
index|[
name|i
index|]
operator|=
name|fw_msg_not_handled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t4_cpl_handler
argument_list|)
condition|;
name|i
operator|++
control|)
name|t4_cpl_handler
index|[
name|i
index|]
operator|=
name|cpl_not_handled
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_FW4_MSG
argument_list|,
name|handle_fw_msg
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_FW6_MSG
argument_list|,
name|handle_fw_msg
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_SGE_EGR_UPDATE
argument_list|,
name|handle_sge_egr_update
argument_list|)
expr_stmt|;
name|t4_register_cpl_handler
argument_list|(
name|CPL_RX_PKT
argument_list|,
name|t4_eth_rx
argument_list|)
expr_stmt|;
name|t4_register_fw_msg_handler
argument_list|(
name|FW6_TYPE_CMD_RPL
argument_list|,
name|t4_handle_fw_rpl
argument_list|)
expr_stmt|;
name|t4_register_fw_msg_handler
argument_list|(
name|FW6_TYPE_WRERR_RPL
argument_list|,
name|t4_handle_wrerr_rpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_sge_modunload
parameter_list|(
name|void
parameter_list|)
block|{
name|counter_u64_free
argument_list|(
name|extfree_refs
argument_list|)
expr_stmt|;
name|counter_u64_free
argument_list|(
name|extfree_rels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|t4_sge_extfree_refs
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|refs
decl_stmt|,
name|rels
decl_stmt|;
name|rels
operator|=
name|counter_u64_fetch
argument_list|(
name|extfree_rels
argument_list|)
expr_stmt|;
name|refs
operator|=
name|counter_u64_fetch
argument_list|(
name|extfree_refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|refs
operator|-
name|rels
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|setup_pad_and_pack_boundaries
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|,
name|m
decl_stmt|;
name|int
name|pad
decl_stmt|,
name|pack
decl_stmt|,
name|pad_shift
decl_stmt|;
name|pad_shift
operator|=
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>
name|CHELSIO_T5
condition|?
name|X_T6_INGPADBOUNDARY_SHIFT
else|:
name|X_INGPADBOUNDARY_SHIFT
expr_stmt|;
name|pad
operator|=
name|fl_pad
expr_stmt|;
if|if
condition|(
name|fl_pad
operator|<
operator|(
literal|1
operator|<<
name|pad_shift
operator|)
operator|||
name|fl_pad
operator|>
operator|(
literal|1
operator|<<
operator|(
name|pad_shift
operator|+
name|M_INGPADBOUNDARY
operator|)
operator|)
operator|||
operator|!
name|powerof2
argument_list|(
name|fl_pad
argument_list|)
condition|)
block|{
comment|/* 		 * If there is any chance that we might use buffer packing and 		 * the chip is a T4, then pick 64 as the pad/pack boundary.  Set 		 * it to the minimum allowed in all other cases. 		 */
name|pad
operator|=
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|buffer_packing
condition|?
literal|64
else|:
literal|1
operator|<<
name|pad_shift
expr_stmt|;
comment|/* 		 * For fl_pad = 0 we'll still write a reasonable value to the 		 * register but all the freelists will opt out of padding. 		 * We'll complain here only if the user tried to set it to a 		 * value greater than 0 that was invalid. 		 */
if|if
condition|(
name|fl_pad
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Invalid hw.cxgbe.fl_pad value"
literal|" (%d), using %d instead.\n"
argument_list|,
name|fl_pad
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
name|V_INGPADBOUNDARY
argument_list|(
name|M_INGPADBOUNDARY
argument_list|)
expr_stmt|;
name|v
operator|=
name|V_INGPADBOUNDARY
argument_list|(
name|ilog2
argument_list|(
name|pad
argument_list|)
operator|-
name|pad_shift
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|fl_pack
operator|!=
operator|-
literal|1
operator|&&
name|fl_pack
operator|!=
name|pad
condition|)
block|{
comment|/* Complain but carry on. */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"hw.cxgbe.fl_pack (%d) ignored,"
literal|" using %d instead.\n"
argument_list|,
name|fl_pack
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|pack
operator|=
name|fl_pack
expr_stmt|;
if|if
condition|(
name|fl_pack
operator|<
literal|16
operator|||
name|fl_pack
operator|==
literal|32
operator|||
name|fl_pack
operator|>
literal|4096
operator|||
operator|!
name|powerof2
argument_list|(
name|fl_pack
argument_list|)
condition|)
block|{
name|pack
operator|=
name|max
argument_list|(
name|sc
operator|->
name|params
operator|.
name|pci
operator|.
name|mps
argument_list|,
name|CACHE_LINE_SIZE
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|powerof2
argument_list|(
name|pack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|<
literal|16
condition|)
name|pack
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|pack
operator|==
literal|32
condition|)
name|pack
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|pack
operator|>
literal|4096
condition|)
name|pack
operator|=
literal|4096
expr_stmt|;
if|if
condition|(
name|fl_pack
operator|!=
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Invalid hw.cxgbe.fl_pack value"
literal|" (%d), using %d instead.\n"
argument_list|,
name|fl_pack
argument_list|,
name|pack
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
name|V_INGPACKBOUNDARY
argument_list|(
name|M_INGPACKBOUNDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|==
literal|16
condition|)
name|v
operator|=
name|V_INGPACKBOUNDARY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|V_INGPACKBOUNDARY
argument_list|(
name|ilog2
argument_list|(
name|pack
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
name|is_t4
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* T4 doesn't have SGE_CONTROL2 */
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL2
argument_list|,
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * adap->params.vpd.cclk must be set up before this is called.  */
end_comment

begin_function
name|void
name|t4_tweak_chip_settings
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|v
decl_stmt|,
name|m
decl_stmt|;
name|int
name|intr_timer
index|[
name|SGE_NTIMERS
index|]
init|=
block|{
literal|1
block|,
literal|5
block|,
literal|10
block|,
literal|50
block|,
literal|100
block|,
literal|200
block|}
decl_stmt|;
name|int
name|timer_max
init|=
name|M_TIMERVALUE0
operator|*
literal|1000
operator|/
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
decl_stmt|;
name|int
name|intr_pktcount
index|[
name|SGE_NCOUNTERS
index|]
init|=
block|{
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|}
decl_stmt|;
comment|/* 63 max */
name|uint16_t
name|indsz
init|=
name|min
argument_list|(
name|RX_COPY_THRESHOLD
operator|-
literal|1
argument_list|,
name|M_INDICATESIZE
argument_list|)
decl_stmt|;
specifier|static
name|int
name|sge_flbuf_sizes
index|[]
init|=
block|{
name|MCLBYTES
block|,
if|#
directive|if
name|MJUMPAGESIZE
operator|!=
name|MCLBYTES
name|MJUMPAGESIZE
block|,
name|MJUMPAGESIZE
operator|-
name|CL_METADATA_SIZE
block|,
name|MJUMPAGESIZE
operator|-
literal|2
operator|*
name|MSIZE
operator|-
name|CL_METADATA_SIZE
block|,
endif|#
directive|endif
name|MJUM9BYTES
block|,
name|MJUM16BYTES
block|,
name|MCLBYTES
operator|-
name|MSIZE
operator|-
name|CL_METADATA_SIZE
block|,
name|MJUM9BYTES
operator|-
name|CL_METADATA_SIZE
block|,
name|MJUM16BYTES
operator|-
name|CL_METADATA_SIZE
block|, 	}
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|MASTER_PF
argument_list|,
operator|(
literal|"%s: trying to change chip settings when not master."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|V_PKTSHIFT
argument_list|(
name|M_PKTSHIFT
argument_list|)
operator||
name|F_RXPKTCPLMODE
operator||
name|F_EGRSTATUSPAGESIZE
expr_stmt|;
name|v
operator|=
name|V_PKTSHIFT
argument_list|(
name|fl_pktshift
argument_list|)
operator||
name|F_RXPKTCPLMODE
operator||
name|V_EGRSTATUSPAGESIZE
argument_list|(
name|spg_len
operator|==
literal|128
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|setup_pad_and_pack_boundaries
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|V_HOSTPAGESIZEPF0
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
operator||
name|V_HOSTPAGESIZEPF1
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
operator||
name|V_HOSTPAGESIZEPF2
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
operator||
name|V_HOSTPAGESIZEPF3
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
operator||
name|V_HOSTPAGESIZEPF4
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
operator||
name|V_HOSTPAGESIZEPF5
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
operator||
name|V_HOSTPAGESIZEPF6
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
operator||
name|V_HOSTPAGESIZEPF7
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_HOST_PAGE_SIZE
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nitems
argument_list|(
name|sge_flbuf_sizes
argument_list|)
operator|<=
name|SGE_FLBUF_SIZES
argument_list|,
operator|(
literal|"%s: hw buffer size table too big"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
argument_list|(
name|nitems
argument_list|(
name|sge_flbuf_sizes
argument_list|)
argument_list|,
name|SGE_FLBUF_SIZES
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_FL_BUFFER_SIZE0
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|,
name|sge_flbuf_sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|V_THRESHOLD_0
argument_list|(
name|intr_pktcount
index|[
literal|0
index|]
argument_list|)
operator||
name|V_THRESHOLD_1
argument_list|(
name|intr_pktcount
index|[
literal|1
index|]
argument_list|)
operator||
name|V_THRESHOLD_2
argument_list|(
name|intr_pktcount
index|[
literal|2
index|]
argument_list|)
operator||
name|V_THRESHOLD_3
argument_list|(
name|intr_pktcount
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_INGRESS_RX_THRESHOLD
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|intr_timer
index|[
literal|0
index|]
operator|<=
name|timer_max
argument_list|,
operator|(
literal|"%s: not a single usable timer (%d, %d)"
operator|,
name|__func__
operator|,
name|intr_timer
index|[
literal|0
index|]
operator|,
name|timer_max
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nitems
argument_list|(
name|intr_timer
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|intr_timer
index|[
name|i
index|]
operator|>=
name|intr_timer
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
literal|"%s: timers not listed in increasing order (%d)"
operator|,
name|__func__
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|intr_timer
index|[
name|i
index|]
operator|>
name|timer_max
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|nitems
argument_list|(
name|intr_timer
argument_list|)
operator|-
literal|1
condition|)
block|{
name|intr_timer
index|[
name|i
index|]
operator|=
name|timer_max
expr_stmt|;
break|break;
block|}
name|intr_timer
index|[
name|i
index|]
operator|+=
name|intr_timer
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|intr_timer
index|[
name|i
index|]
operator|/=
literal|2
expr_stmt|;
block|}
block|}
name|v
operator|=
name|V_TIMERVALUE0
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|intr_timer
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator||
name|V_TIMERVALUE1
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|intr_timer
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_TIMER_VALUE_0_AND_1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|V_TIMERVALUE2
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|intr_timer
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator||
name|V_TIMERVALUE3
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|intr_timer
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_TIMER_VALUE_2_AND_3
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|V_TIMERVALUE4
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|intr_timer
index|[
literal|4
index|]
argument_list|)
argument_list|)
operator||
name|V_TIMERVALUE5
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|intr_timer
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_TIMER_VALUE_4_AND_5
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>=
name|CHELSIO_T6
condition|)
block|{
name|m
operator|=
name|V_TSCALE
argument_list|(
name|M_TSCALE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tscale
operator|==
literal|1
condition|)
name|v
operator|=
literal|0
expr_stmt|;
else|else
name|v
operator|=
name|V_TSCALE
argument_list|(
name|tscale
operator|-
literal|2
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_ITP_CONTROL
argument_list|,
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* 4K, 16K, 64K, 256K DDP "page sizes" for TDDP */
name|v
operator|=
name|V_HPZ0
argument_list|(
literal|0
argument_list|)
operator||
name|V_HPZ1
argument_list|(
literal|2
argument_list|)
operator||
name|V_HPZ2
argument_list|(
literal|4
argument_list|)
operator||
name|V_HPZ3
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_TDDP_PSZ
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * 4K, 8K, 16K, 64K DDP "page sizes" for iSCSI DDP.  These have been 	 * chosen with MAXPHYS = 128K in mind.  The largest DDP buffer that we 	 * may have to deal with is MAXPHYS + 1 page. 	 */
name|v
operator|=
name|V_HPZ0
argument_list|(
literal|0
argument_list|)
operator||
name|V_HPZ1
argument_list|(
literal|1
argument_list|)
operator||
name|V_HPZ2
argument_list|(
literal|2
argument_list|)
operator||
name|V_HPZ3
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_ISCSI_PSZ
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* We use multiple DDP page sizes both in plain-TOE and ISCSI modes. */
name|m
operator|=
name|v
operator|=
name|F_TDDPTAGTCB
operator||
name|F_ISCSITAGTCB
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_CTL
argument_list|,
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|m
operator|=
name|V_INDICATESIZE
argument_list|(
name|M_INDICATESIZE
argument_list|)
operator||
name|F_REARMDDPOFFSET
operator||
name|F_RESETDDPOFFSET
expr_stmt|;
name|v
operator|=
name|V_INDICATESIZE
argument_list|(
name|indsz
argument_list|)
operator||
name|F_REARMDDPOFFSET
operator||
name|F_RESETDDPOFFSET
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG5
argument_list|,
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SGE wants the buffer to be at least 64B and then a multiple of 16.  If  * padding is in use, the buffer's start and end need to be aligned to the pad  * boundary as well.  We'll just make sure that the size is a multiple of the  * boundary here, it is up to the buffer allocation code to make sure the start  * of the buffer is aligned as well.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|hwsz_ok
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|hwsz
parameter_list|)
block|{
name|int
name|mask
init|=
name|fl_pad
condition|?
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|pad_boundary
operator|-
literal|1
else|:
literal|16
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|hwsz
operator|>=
literal|64
operator|&&
operator|(
name|hwsz
operator|&
name|mask
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: driver really should be able to deal with unexpected settings.  */
end_comment

begin_function
name|int
name|t4_read_chip_settings
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sge
modifier|*
name|s
init|=
operator|&
name|sc
operator|->
name|sge
decl_stmt|;
name|struct
name|sge_params
modifier|*
name|sp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|uint32_t
name|m
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|uint16_t
name|indsz
init|=
name|min
argument_list|(
name|RX_COPY_THRESHOLD
operator|-
literal|1
argument_list|,
name|M_INDICATESIZE
argument_list|)
decl_stmt|;
specifier|static
name|int
name|sw_buf_sizes
index|[]
init|=
block|{
comment|/* Sorted by size */
name|MCLBYTES
block|,
if|#
directive|if
name|MJUMPAGESIZE
operator|!=
name|MCLBYTES
name|MJUMPAGESIZE
block|,
endif|#
directive|endif
name|MJUM9BYTES
block|,
name|MJUM16BYTES
block|}
decl_stmt|;
name|struct
name|sw_zone_info
modifier|*
name|swz
decl_stmt|,
modifier|*
name|safe_swz
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|hwb
decl_stmt|;
name|m
operator|=
name|F_RXPKTCPLMODE
expr_stmt|;
name|v
operator|=
name|F_RXPKTCPLMODE
expr_stmt|;
name|r
operator|=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|sge_control
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|m
operator|)
operator|!=
name|v
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid SGE_CONTROL(0x%x)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* 	 * If this changes then every single use of PAGE_SHIFT in the driver 	 * needs to be carefully reviewed for PAGE_SHIFT vs sp->page_shift. 	 */
if|if
condition|(
name|sp
operator|->
name|page_shift
operator|!=
name|PAGE_SHIFT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid SGE_HOST_PAGE_SIZE(0x%x)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* Filter out unusable hw buffer sizes entirely (mark with -2). */
name|hwb
operator|=
operator|&
name|s
operator|->
name|hw_buf_info
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|s
operator|->
name|hw_buf_info
argument_list|)
condition|;
name|i
operator|++
operator|,
name|hwb
operator|++
control|)
block|{
name|r
operator|=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|sge_fl_buffer_size
index|[
name|i
index|]
expr_stmt|;
name|hwb
operator|->
name|size
operator|=
name|r
expr_stmt|;
name|hwb
operator|->
name|zidx
operator|=
name|hwsz_ok
argument_list|(
name|sc
argument_list|,
name|r
argument_list|)
condition|?
operator|-
literal|1
else|:
operator|-
literal|2
expr_stmt|;
name|hwb
operator|->
name|next
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Create a sorted list in decreasing order of hw buffer sizes (and so 	 * increasing order of spare area) for each software zone. 	 * 	 * If padding is enabled then the start and end of the buffer must align 	 * to the pad boundary; if packing is enabled then they must align with 	 * the pack boundary as well.  Allocations from the cluster zones are 	 * aligned to min(size, 4K), so the buffer starts at that alignment and 	 * ends at hwb->size alignment.  If mbuf inlining is allowed the 	 * starting alignment will be reduced to MSIZE and the driver will 	 * exercise appropriate caution when deciding on the best buffer layout 	 * to use. 	 */
name|n
operator|=
literal|0
expr_stmt|;
comment|/* no usable buffer size to begin with */
name|swz
operator|=
operator|&
name|s
operator|->
name|sw_zone_info
index|[
literal|0
index|]
expr_stmt|;
name|safe_swz
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SW_ZONE_SIZES
condition|;
name|i
operator|++
operator|,
name|swz
operator|++
control|)
block|{
name|int8_t
name|head
init|=
operator|-
literal|1
decl_stmt|,
name|tail
init|=
operator|-
literal|1
decl_stmt|;
name|swz
operator|->
name|size
operator|=
name|sw_buf_sizes
index|[
name|i
index|]
expr_stmt|;
name|swz
operator|->
name|zone
operator|=
name|m_getzone
argument_list|(
name|swz
operator|->
name|size
argument_list|)
expr_stmt|;
name|swz
operator|->
name|type
operator|=
name|m_gettype
argument_list|(
name|swz
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|swz
operator|->
name|size
operator|<
name|PAGE_SIZE
condition|)
block|{
name|MPASS
argument_list|(
name|powerof2
argument_list|(
name|swz
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl_pad
operator|&&
operator|(
name|swz
operator|->
name|size
operator|%
name|sp
operator|->
name|pad_boundary
operator|!=
literal|0
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|swz
operator|->
name|size
operator|==
name|safest_rx_cluster
condition|)
name|safe_swz
operator|=
name|swz
expr_stmt|;
name|hwb
operator|=
operator|&
name|s
operator|->
name|hw_buf_info
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SGE_FLBUF_SIZES
condition|;
name|j
operator|++
operator|,
name|hwb
operator|++
control|)
block|{
if|if
condition|(
name|hwb
operator|->
name|zidx
operator|!=
operator|-
literal|1
operator|||
name|hwb
operator|->
name|size
operator|>
name|swz
operator|->
name|size
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|fl_pad
condition|)
name|MPASS
argument_list|(
name|hwb
operator|->
name|size
operator|%
name|sp
operator|->
name|pad_boundary
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hwb
operator|->
name|zidx
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|-
literal|1
condition|)
name|head
operator|=
name|tail
operator|=
name|j
expr_stmt|;
elseif|else
if|if
condition|(
name|hwb
operator|->
name|size
operator|<
name|s
operator|->
name|hw_buf_info
index|[
name|tail
index|]
operator|.
name|size
condition|)
block|{
name|s
operator|->
name|hw_buf_info
index|[
name|tail
index|]
operator|.
name|next
operator|=
name|j
expr_stmt|;
name|tail
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|int8_t
modifier|*
name|cur
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|&
name|head
init|;
operator|*
name|cur
operator|!=
operator|-
literal|1
condition|;
name|cur
operator|=
operator|&
name|t
operator|->
name|next
control|)
block|{
name|t
operator|=
operator|&
name|s
operator|->
name|hw_buf_info
index|[
operator|*
name|cur
index|]
expr_stmt|;
if|if
condition|(
name|hwb
operator|->
name|size
operator|==
name|t
operator|->
name|size
condition|)
block|{
name|hwb
operator|->
name|zidx
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hwb
operator|->
name|size
operator|>
name|t
operator|->
name|size
condition|)
block|{
name|hwb
operator|->
name|next
operator|=
operator|*
name|cur
expr_stmt|;
operator|*
name|cur
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|swz
operator|->
name|head_hwidx
operator|=
name|head
expr_stmt|;
name|swz
operator|->
name|tail_hwidx
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|tail
operator|!=
operator|-
literal|1
condition|)
block|{
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|swz
operator|->
name|size
operator|-
name|s
operator|->
name|hw_buf_info
index|[
name|tail
index|]
operator|.
name|size
operator|>=
name|CL_METADATA_SIZE
condition|)
name|sc
operator|->
name|flags
operator||=
name|BUF_PACKING_OK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"no usable SGE FL buffer size.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|s
operator|->
name|safe_hwidx1
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|safe_hwidx2
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|safe_swz
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|safe_hwidx1
operator|=
name|safe_swz
operator|->
name|head_hwidx
expr_stmt|;
for|for
control|(
name|i
operator|=
name|safe_swz
operator|->
name|head_hwidx
init|;
name|i
operator|!=
operator|-
literal|1
condition|;
name|i
operator|=
name|hwb
operator|->
name|next
control|)
block|{
name|int
name|spare
decl_stmt|;
name|hwb
operator|=
operator|&
name|s
operator|->
name|hw_buf_info
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|fl_pad
condition|)
name|MPASS
argument_list|(
name|hwb
operator|->
name|size
operator|%
name|sp
operator|->
name|pad_boundary
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spare
operator|=
name|safe_swz
operator|->
name|size
operator|-
name|hwb
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|spare
operator|>=
name|CL_METADATA_SIZE
condition|)
block|{
name|s
operator|->
name|safe_hwidx2
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|v
operator|=
name|V_HPZ0
argument_list|(
literal|0
argument_list|)
operator||
name|V_HPZ1
argument_list|(
literal|2
argument_list|)
operator||
name|V_HPZ2
argument_list|(
literal|4
argument_list|)
operator||
name|V_HPZ3
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_TDDP_PSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|v
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid ULP_RX_TDDP_PSZ(0x%x)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|m
operator|=
name|v
operator|=
name|F_TDDPTAGTCB
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_ULP_RX_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|m
operator|)
operator|!=
name|v
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid ULP_RX_CTL(0x%x)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|m
operator|=
name|V_INDICATESIZE
argument_list|(
name|M_INDICATESIZE
argument_list|)
operator||
name|F_REARMDDPOFFSET
operator||
name|F_RESETDDPOFFSET
expr_stmt|;
name|v
operator|=
name|V_INDICATESIZE
argument_list|(
name|indsz
argument_list|)
operator||
name|F_REARMDDPOFFSET
operator||
name|F_RESETDDPOFFSET
expr_stmt|;
name|r
operator|=
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|m
operator|)
operator|!=
name|v
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid TP_PARA_REG5(0x%x)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|t4_init_tp_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t4_read_mtu_tbl
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t4_load_mtus
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|sc
operator|->
name|params
operator|.
name|a_wnd
argument_list|,
name|sc
operator|->
name|params
operator|.
name|b_wnd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_create_dma_tag
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_SPACE_UNRESTRICTED
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create main DMA tag: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_sge_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|children
parameter_list|)
block|{
name|struct
name|sge_params
modifier|*
name|sp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
decl_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"buffer_sizes"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sge
argument_list|,
literal|0
argument_list|,
name|sysctl_bufsizes
argument_list|,
literal|"A"
argument_list|,
literal|"freelist buffer sizes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl_pktshift"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sp
operator|->
name|fl_pktshift
argument_list|,
literal|"payload DMA offset in rx buffer (bytes)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl_pad"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sp
operator|->
name|pad_boundary
argument_list|,
literal|"payload pad boundary (bytes)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"spg_len"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sp
operator|->
name|spg_len
argument_list|,
literal|"status page size (bytes)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cong_drop"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|cong_drop
argument_list|,
literal|"congestion drop setting"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl_pack"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|sp
operator|->
name|pack_boundary
argument_list|,
literal|"payload pack boundary (bytes)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t4_destroy_dma_tag
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialize the firmware event queue and the management queue.  *  * Returns errno on failure.  Resources allocated up to that point may still be  * allocated.  Caller is responsible for cleanup in case this function fails.  */
end_comment

begin_function
name|int
name|t4_setup_adapter_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|ADAP_SYSCTL_CTX
expr_stmt|;
comment|/* 	 * Firmware event queue 	 */
name|rc
operator|=
name|alloc_fwq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Management queue.  This is just a control queue that uses the fwq as 	 * its associated iq. 	 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
operator|)
condition|)
name|rc
operator|=
name|alloc_mgmtq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
name|int
name|t4_teardown_adapter_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Do this before freeing the queue */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|ADAP_SYSCTL_CTX
condition|)
block|{
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|ADAP_SYSCTL_CTX
expr_stmt|;
block|}
name|free_mgmtq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free_fwq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|first_vector
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|vi
operator|->
name|first_intr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an arbitrary "index," come up with an iq that can be used by other  * queues (of this VI) for interrupt forwarding, SGE egress updates, etc.  * The iq returned is guaranteed to be something that takes direct interrupts.  */
end_comment

begin_function
specifier|static
name|struct
name|sge_iq
modifier|*
name|vi_intr_iq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge
modifier|*
name|s
init|=
operator|&
name|sc
operator|->
name|sge
decl_stmt|;
name|struct
name|sge_iq
modifier|*
name|iq
init|=
name|NULL
decl_stmt|;
name|int
name|nintr
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
condition|)
return|return
operator|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|)
return|;
name|nintr
operator|=
name|vi
operator|->
name|nintr
expr_stmt|;
name|KASSERT
argument_list|(
name|nintr
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: vi %p has no exclusive interrupts, total interrupts = %d"
operator|,
name|__func__
operator|,
name|vi
operator|,
name|sc
operator|->
name|intr_count
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|idx
operator|%
name|nintr
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_RXQ
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|vi
operator|->
name|nrxq
condition|)
block|{
name|iq
operator|=
operator|&
name|s
operator|->
name|rxq
index|[
name|vi
operator|->
name|first_rxq
operator|+
name|i
index|]
operator|.
name|iq
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|i
operator|-=
name|vi
operator|->
name|nrxq
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_OFLD_RXQ
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|vi
operator|->
name|nofldrxq
condition|)
block|{
name|iq
operator|=
operator|&
name|s
operator|->
name|ofld_rxq
index|[
name|vi
operator|->
name|first_ofld_rxq
operator|+
name|i
index|]
operator|.
name|iq
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|i
operator|-=
name|vi
operator|->
name|nofldrxq
expr_stmt|;
block|}
endif|#
directive|endif
name|panic
argument_list|(
literal|"%s: vi %p, intr_flags 0x%lx, idx %d, total intr %d\n"
argument_list|,
name|__func__
argument_list|,
name|vi
argument_list|,
name|vi
operator|->
name|flags
operator|&
name|INTR_ALL
argument_list|,
name|idx
argument_list|,
name|nintr
argument_list|)
expr_stmt|;
name|done
label|:
name|MPASS
argument_list|(
name|iq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|iq
operator|->
name|flags
operator|&
name|IQ_INTR
argument_list|,
operator|(
literal|"%s: iq %p (vi %p, intr_flags 0x%lx, idx %d)"
operator|,
name|__func__
operator|,
name|iq
operator|,
name|vi
operator|,
name|vi
operator|->
name|flags
operator|&
name|INTR_ALL
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|iq
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Maximum payload that can be delivered with a single iq descriptor */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|mtu_to_max_payload
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|mtu
parameter_list|,
specifier|const
name|int
name|toe
parameter_list|)
block|{
name|int
name|payload
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|toe
condition|)
block|{
name|payload
operator|=
name|sc
operator|->
name|tt
operator|.
name|rx_coalesce
condition|?
name|G_RXCOALESCESIZE
argument_list|(
name|t4_read_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG2
argument_list|)
argument_list|)
else|:
name|mtu
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* large enough even when hw VLAN extraction is disabled */
name|payload
operator|=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|fl_pktshift
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|mtu
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
block|}
endif|#
directive|endif
return|return
operator|(
name|payload
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_setup_vi_queues
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|intr_idx
decl_stmt|,
name|iqid
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ctrlq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|int
name|saved_idx
decl_stmt|;
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
endif|#
directive|endif
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vi
operator|->
name|ifp
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
init|=
name|device_get_sysctl_tree
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|int
name|maxp
decl_stmt|,
name|mtu
init|=
name|ifp
operator|->
name|if_mtu
decl_stmt|;
comment|/* Interrupt vector to start from (when using multiple vectors) */
name|intr_idx
operator|=
name|first_vector
argument_list|(
name|vi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|saved_idx
operator|=
name|intr_idx
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_NETMAP
condition|)
block|{
comment|/* netmap is supported with direct interrupts only. */
name|MPASS
argument_list|(
name|vi
operator|->
name|flags
operator|&
name|INTR_RXQ
argument_list|)
expr_stmt|;
comment|/* 		 * We don't have buffers to back the netmap rx queues 		 * right now so we create the queues in a way that 		 * doesn't set off any congestion signal in the chip. 		 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nm_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queues"
argument_list|)
expr_stmt|;
name|for_each_nm_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|rc
operator|=
name|alloc_nm_rxq
argument_list|(
name|vi
argument_list|,
name|nm_rxq
argument_list|,
name|intr_idx
argument_list|,
name|i
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|intr_idx
operator|++
expr_stmt|;
block|}
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nm_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"tx queues"
argument_list|)
expr_stmt|;
name|for_each_nm_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_txq
argument_list|)
block|{
name|iqid
operator|=
name|vi
operator|->
name|first_nm_rxq
operator|+
operator|(
name|i
operator|%
name|vi
operator|->
name|nnmrxq
operator|)
expr_stmt|;
name|rc
operator|=
name|alloc_nm_txq
argument_list|(
name|vi
argument_list|,
name|nm_txq
argument_list|,
name|iqid
argument_list|,
name|i
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Normal rx queues and netmap rx queues share the same interrupts. */
name|intr_idx
operator|=
name|saved_idx
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * First pass over all NIC and TOE rx queues: 	 * a) initialize iq and fl 	 * b) allocate queue iff it will take direct interrupts. 	 */
name|maxp
operator|=
name|mtu_to_max_payload
argument_list|(
name|sc
argument_list|,
name|mtu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_RXQ
condition|)
block|{
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queues"
argument_list|)
expr_stmt|;
block|}
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|init_iq
argument_list|(
operator|&
name|rxq
operator|->
name|iq
argument_list|,
name|sc
argument_list|,
name|vi
operator|->
name|tmr_idx
argument_list|,
name|vi
operator|->
name|pktc_idx
argument_list|,
name|vi
operator|->
name|qsize_rxq
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s rxq%d-fl"
argument_list|,
name|device_get_nameunit
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|,
name|vi
operator|->
name|qsize_rxq
operator|/
literal|8
argument_list|,
name|maxp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_RXQ
condition|)
block|{
name|rxq
operator|->
name|iq
operator|.
name|flags
operator||=
name|IQ_INTR
expr_stmt|;
name|rc
operator|=
name|alloc_rxq
argument_list|(
name|vi
argument_list|,
name|rxq
argument_list|,
name|intr_idx
argument_list|,
name|i
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|intr_idx
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_NETMAP
condition|)
name|intr_idx
operator|=
name|saved_idx
operator|+
name|max
argument_list|(
name|vi
operator|->
name|nrxq
argument_list|,
name|vi
operator|->
name|nnmrxq
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|maxp
operator|=
name|mtu_to_max_payload
argument_list|(
name|sc
argument_list|,
name|mtu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_OFLD_RXQ
condition|)
block|{
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ofld_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
block|}
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|init_iq
argument_list|(
operator|&
name|ofld_rxq
operator|->
name|iq
argument_list|,
name|sc
argument_list|,
name|vi
operator|->
name|tmr_idx
argument_list|,
name|vi
operator|->
name|pktc_idx
argument_list|,
name|vi
operator|->
name|qsize_rxq
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s ofld_rxq%d-fl"
argument_list|,
name|device_get_nameunit
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|fl
argument_list|,
name|vi
operator|->
name|qsize_rxq
operator|/
literal|8
argument_list|,
name|maxp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|INTR_OFLD_RXQ
condition|)
block|{
name|ofld_rxq
operator|->
name|iq
operator|.
name|flags
operator||=
name|IQ_INTR
expr_stmt|;
name|rc
operator|=
name|alloc_ofld_rxq
argument_list|(
name|vi
argument_list|,
name|ofld_rxq
argument_list|,
name|intr_idx
argument_list|,
name|i
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|intr_idx
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Second pass over all NIC and TOE rx queues.  The queues forwarding 	 * their interrupts are allocated now. 	 */
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vi
operator|->
name|flags
operator|&
name|INTR_RXQ
operator|)
condition|)
block|{
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queues"
argument_list|)
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|MPASS
argument_list|(
operator|!
operator|(
name|rxq
operator|->
name|iq
operator|.
name|flags
operator|&
name|IQ_INTR
operator|)
argument_list|)
expr_stmt|;
name|intr_idx
operator|=
name|vi_intr_iq
argument_list|(
name|vi
argument_list|,
name|j
argument_list|)
operator|->
name|abs_id
expr_stmt|;
name|rc
operator|=
name|alloc_rxq
argument_list|(
name|vi
argument_list|,
name|rxq
argument_list|,
name|intr_idx
argument_list|,
name|i
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|j
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|vi
operator|->
name|nofldrxq
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|vi
operator|->
name|flags
operator|&
name|INTR_OFLD_RXQ
operator|)
condition|)
block|{
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ofld_rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|MPASS
argument_list|(
operator|!
operator|(
name|ofld_rxq
operator|->
name|iq
operator|.
name|flags
operator|&
name|IQ_INTR
operator|)
argument_list|)
expr_stmt|;
name|intr_idx
operator|=
name|vi_intr_iq
argument_list|(
name|vi
argument_list|,
name|j
argument_list|)
operator|->
name|abs_id
expr_stmt|;
name|rc
operator|=
name|alloc_ofld_rxq
argument_list|(
name|vi
argument_list|,
name|ofld_rxq
argument_list|,
name|intr_idx
argument_list|,
name|i
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|j
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Now the tx queues.  Only one pass needed. 	 */
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"tx queues"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|iqid
operator|=
name|vi_intr_iq
argument_list|(
name|vi
argument_list|,
name|j
argument_list|)
operator|->
name|cntxt_id
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s txq%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|txq
operator|->
name|eq
argument_list|,
name|EQ_ETH
argument_list|,
name|vi
operator|->
name|qsize_txq
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|iqid
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_txq
argument_list|(
name|vi
argument_list|,
name|txq
argument_list|,
name|i
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|j
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ofld_txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"tx queues for offloaded TCP connections"
argument_list|)
expr_stmt|;
name|for_each_ofld_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_txq
argument_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|oid2
decl_stmt|;
name|iqid
operator|=
name|vi_intr_iq
argument_list|(
name|vi
argument_list|,
name|j
argument_list|)
operator|->
name|cntxt_id
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s ofld_txq%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|ofld_txq
operator|->
name|eq
argument_list|,
name|EQ_OFLD
argument_list|,
name|vi
operator|->
name|qsize_txq
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|iqid
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|oid2
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"offload tx queue"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_wrq
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|ofld_txq
argument_list|,
name|oid2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|j
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Finally, the control queue. 	 */
if|if
condition|(
operator|!
name|IS_MAIN_VI
argument_list|(
name|vi
argument_list|)
operator|||
name|sc
operator|->
name|flags
operator|&
name|IS_VF
condition|)
goto|goto
name|done
goto|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ctrlq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"ctrl queue"
argument_list|)
expr_stmt|;
name|ctrlq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
expr_stmt|;
name|iqid
operator|=
name|vi_intr_iq
argument_list|(
name|vi
argument_list|,
literal|0
argument_list|)
operator|->
name|cntxt_id
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s ctrlq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|vi
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|init_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|ctrlq
operator|->
name|eq
argument_list|,
name|EQ_CTRL
argument_list|,
name|CTRL_EQ_QSIZE
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|,
name|iqid
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_wrq
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|ctrlq
argument_list|,
name|oid
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|rc
condition|)
name|t4_teardown_vi_queues
argument_list|(
name|vi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
name|int
name|t4_teardown_vi_queues
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|ofld_txq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
decl_stmt|;
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
decl_stmt|;
endif|#
directive|endif
comment|/* Do this before freeing the queues */
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|VI_SYSCTL_CTX
condition|)
block|{
name|sysctl_ctx_free
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|vi
operator|->
name|flags
operator|&=
operator|~
name|VI_SYSCTL_CTX
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|vi
operator|->
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|for_each_nm_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_txq
argument_list|)
block|{
name|free_nm_txq
argument_list|(
name|vi
argument_list|,
name|nm_txq
argument_list|)
expr_stmt|;
block|}
name|for_each_nm_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|nm_rxq
argument_list|)
block|{
name|free_nm_rxq
argument_list|(
name|vi
argument_list|,
name|nm_rxq
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Take down all the tx queues first, as they reference the rx queues 	 * (for egress updates, etc.). 	 */
if|if
condition|(
name|IS_MAIN_VI
argument_list|(
name|vi
argument_list|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
operator|)
condition|)
name|free_wrq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|ctrlq
index|[
name|pi
operator|->
name|port_id
index|]
argument_list|)
expr_stmt|;
name|for_each_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|free_txq
argument_list|(
name|vi
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_txq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_txq
argument_list|)
block|{
name|free_wrq
argument_list|(
name|sc
argument_list|,
name|ofld_txq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Then take down the rx queues that forward their interrupts, as they 	 * reference other rx queues. 	 */
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|if
condition|(
operator|(
name|rxq
operator|->
name|iq
operator|.
name|flags
operator|&
name|IQ_INTR
operator|)
operator|==
literal|0
condition|)
name|free_rxq
argument_list|(
name|vi
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
if|if
condition|(
operator|(
name|ofld_rxq
operator|->
name|iq
operator|.
name|flags
operator|&
name|IQ_INTR
operator|)
operator|==
literal|0
condition|)
name|free_ofld_rxq
argument_list|(
name|vi
argument_list|,
name|ofld_rxq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Then take down the rx queues that take direct interrupts. 	 */
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
if|if
condition|(
name|rxq
operator|->
name|iq
operator|.
name|flags
operator|&
name|IQ_INTR
condition|)
name|free_rxq
argument_list|(
name|vi
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
if|if
condition|(
name|ofld_rxq
operator|->
name|iq
operator|.
name|flags
operator|&
name|IQ_INTR
condition|)
name|free_ofld_rxq
argument_list|(
name|vi
argument_list|,
name|ofld_rxq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deals with errors and the firmware event queue.  All data rx queues forward  * their interrupt to the firmware event queue.  */
end_comment

begin_function
name|void
name|t4_intr_all
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|sge_iq
modifier|*
name|fwq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
decl_stmt|;
name|t4_intr_err
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|fwq
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|,
name|IQS_BUSY
argument_list|)
condition|)
block|{
name|service_iq
argument_list|(
name|fwq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_cmpset_int
argument_list|(
operator|&
name|fwq
operator|->
name|state
argument_list|,
name|IQS_BUSY
argument_list|,
name|IQS_IDLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Deals with error interrupts */
end_comment

begin_function
name|void
name|t4_intr_err
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_PCIE_PF_CLI
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_slow_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_intr_evt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_iq
modifier|*
name|iq
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|,
name|IQS_BUSY
argument_list|)
condition|)
block|{
name|service_iq
argument_list|(
name|iq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_cmpset_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_BUSY
argument_list|,
name|IQS_IDLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_iq
modifier|*
name|iq
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|,
name|IQS_BUSY
argument_list|)
condition|)
block|{
name|service_iq
argument_list|(
name|iq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_cmpset_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_BUSY
argument_list|,
name|IQS_IDLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_vi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|irq
modifier|*
name|irq
init|=
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|irq
operator|->
name|nm_state
argument_list|,
name|NM_ON
argument_list|,
name|NM_BUSY
argument_list|)
condition|)
block|{
name|t4_nm_intr
argument_list|(
name|irq
operator|->
name|nm_rxq
argument_list|)
expr_stmt|;
name|atomic_cmpset_int
argument_list|(
operator|&
name|irq
operator|->
name|nm_state
argument_list|,
name|NM_BUSY
argument_list|,
name|NM_ON
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|irq
operator|->
name|rxq
operator|!=
name|NULL
condition|)
name|t4_intr
argument_list|(
name|irq
operator|->
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sort_before_lro
parameter_list|(
name|struct
name|lro_ctrl
modifier|*
name|lro
parameter_list|)
block|{
return|return
operator|(
name|lro
operator|->
name|lro_mbuf_max
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deals with anything and everything on the given ingress queue.  */
end_comment

begin_function
specifier|static
name|int
name|service_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|sge_iq
modifier|*
name|q
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
init|=
name|iq_to_rxq
argument_list|(
name|iq
argument_list|)
decl_stmt|;
comment|/* Use iff iq is part of rxq */
name|struct
name|sge_fl
modifier|*
name|fl
decl_stmt|;
comment|/* Use iff IQ_HAS_FL */
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|iq_desc
modifier|*
name|d
init|=
operator|&
name|iq
operator|->
name|desc
index|[
name|iq
operator|->
name|cidx
index|]
decl_stmt|;
name|int
name|ndescs
init|=
literal|0
decl_stmt|,
name|limit
decl_stmt|;
name|int
name|rsp_type
decl_stmt|,
name|refill
decl_stmt|;
name|uint32_t
name|lq
decl_stmt|;
name|uint16_t
name|fl_hw_cidx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sge_iq
argument_list|)
name|iql
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|iql
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
specifier|const
name|struct
name|timeval
name|lro_timeout
init|=
block|{
literal|0
block|,
name|sc
operator|->
name|lro_timeout
block|}
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxq
operator|->
name|lro
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|iq
operator|->
name|state
operator|==
name|IQS_BUSY
argument_list|,
operator|(
literal|"%s: iq %p not BUSY"
operator|,
name|__func__
operator|,
name|iq
operator|)
argument_list|)
expr_stmt|;
name|limit
operator|=
name|budget
condition|?
name|budget
else|:
name|iq
operator|->
name|qsize
operator|/
literal|16
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_HAS_FL
condition|)
block|{
name|fl
operator|=
operator|&
name|rxq
operator|->
name|fl
expr_stmt|;
name|fl_hw_cidx
operator|=
name|fl
operator|->
name|hw_cidx
expr_stmt|;
comment|/* stable snapshot */
block|}
else|else
block|{
name|fl
operator|=
name|NULL
expr_stmt|;
name|fl_hw_cidx
operator|=
literal|0
expr_stmt|;
comment|/* to silence gcc warning */
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_ADJ_CREDIT
condition|)
block|{
name|MPASS
argument_list|(
name|sort_before_lro
argument_list|(
name|lro
argument_list|)
argument_list|)
expr_stmt|;
name|iq
operator|->
name|flags
operator|&=
operator|~
name|IQ_ADJ_CREDIT
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
operator|&
name|F_RSPD_GEN
operator|)
operator|!=
name|iq
operator|->
name|gen
condition|)
block|{
name|tcp_lro_flush_all
argument_list|(
name|lro
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_gts_reg
argument_list|,
name|V_CIDXINC
argument_list|(
literal|1
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
operator|(
name|u32
operator|)
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|iq
operator|->
name|intr_params
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ndescs
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|MPASS
argument_list|(
operator|(
name|iq
operator|->
name|flags
operator|&
name|IQ_ADJ_CREDIT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We always come back and check the descriptor ring for new indirect 	 * interrupts and other responses after running a single handler. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
operator|&
name|F_RSPD_GEN
operator|)
operator|==
name|iq
operator|->
name|gen
condition|)
block|{
name|rmb
argument_list|()
expr_stmt|;
name|refill
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|rsp_type
operator|=
name|G_RSPD_TYPE
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|u
operator|.
name|type_gen
argument_list|)
expr_stmt|;
name|lq
operator|=
name|be32toh
argument_list|(
name|d
operator|->
name|rsp
operator|.
name|pldbuflen_qid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rsp_type
condition|)
block|{
case|case
name|X_RSPD_TYPE_FLBUF
case|:
name|KASSERT
argument_list|(
name|iq
operator|->
name|flags
operator|&
name|IQ_HAS_FL
argument_list|,
operator|(
literal|"%s: data for an iq (%p) with no freelist"
operator|,
name|__func__
operator|,
name|iq
operator|)
argument_list|)
expr_stmt|;
name|m0
operator|=
name|get_fl_payload
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|lq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m0
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|process_iql
goto|;
name|refill
operator|=
name|IDXDIFF
argument_list|(
name|fl
operator|->
name|hw_cidx
argument_list|,
name|fl_hw_cidx
argument_list|,
name|fl
operator|->
name|sidx
argument_list|)
operator|>
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|T4_PKT_TIMESTAMP
comment|/* 				 * 60 bit timestamp for the payload is 				 * *(uint64_t *)m0->m_pktdat.  Note that it is 				 * in the leading free-space in the mbuf.  The 				 * kernel can clobber it during a pullup, 				 * m_copymdata, etc.  You need to make sure that 				 * the mbuf reaches you unmolested if you care 				 * about the timestamp. 				 */
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|m0
operator|->
name|m_pktdat
operator|=
name|be64toh
argument_list|(
name|ctrl
operator|->
name|u
operator|.
name|last_flit
argument_list|)
operator|&
literal|0xfffffffffffffff
expr_stmt|;
endif|#
directive|endif
comment|/* fall through */
case|case
name|X_RSPD_TYPE_CPL
case|:
name|KASSERT
argument_list|(
name|d
operator|->
name|rss
operator|.
name|opcode
operator|<
name|NUM_CPL_CMDS
argument_list|,
operator|(
literal|"%s: bad opcode %02x."
operator|,
name|__func__
operator|,
name|d
operator|->
name|rss
operator|.
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|t4_cpl_handler
index|[
name|d
operator|->
name|rss
operator|.
name|opcode
index|]
operator|(
name|iq
operator|,
operator|&
name|d
operator|->
name|rss
operator|,
name|m0
operator|)
expr_stmt|;
break|break;
case|case
name|X_RSPD_TYPE_INTR
case|:
comment|/* 				 * Interrupts should be forwarded only to queues 				 * that are not forwarding their interrupts. 				 * This means service_iq can recurse but only 1 				 * level deep. 				 */
name|KASSERT
argument_list|(
name|budget
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: budget %u, rsp_type %u"
operator|,
name|__func__
operator|,
name|budget
operator|,
name|rsp_type
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * There are 1K interrupt-capable queues (qids 0 				 * through 1023).  A response type indicating a 				 * forwarded interrupt with a qid>= 1K is an 				 * iWARP async notification. 				 */
if|if
condition|(
name|lq
operator|>=
literal|1024
condition|)
block|{
name|t4_an_handler
argument_list|(
name|iq
argument_list|,
operator|&
name|d
operator|->
name|rsp
argument_list|)
expr_stmt|;
break|break;
block|}
name|q
operator|=
name|sc
operator|->
name|sge
operator|.
name|iqmap
index|[
name|lq
operator|-
name|sc
operator|->
name|sge
operator|.
name|iq_start
operator|-
name|sc
operator|->
name|sge
operator|.
name|iq_base
index|]
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|q
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|,
name|IQS_BUSY
argument_list|)
condition|)
block|{
if|if
condition|(
name|service_iq
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|qsize
operator|/
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
name|atomic_cmpset_int
argument_list|(
operator|&
name|q
operator|->
name|state
argument_list|,
name|IQS_BUSY
argument_list|,
name|IQS_IDLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|iql
argument_list|,
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: illegal response type %d on iq %p"
operator|,
name|__func__
operator|,
name|rsp_type
operator|,
name|iq
operator|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: illegal response type %d on iq %p"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|rsp_type
argument_list|,
name|iq
argument_list|)
expr_stmt|;
break|break;
block|}
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|iq
operator|->
name|cidx
operator|==
name|iq
operator|->
name|sidx
argument_list|)
condition|)
block|{
name|iq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|gen
operator|^=
name|F_RSPD_GEN
expr_stmt|;
name|d
operator|=
operator|&
name|iq
operator|->
name|desc
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|ndescs
operator|==
name|limit
argument_list|)
condition|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_gts_reg
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndescs
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|X_TIMERREG_UPDATE_CIDX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ndescs
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_LRO_ENABLED
operator|&&
operator|!
name|sort_before_lro
argument_list|(
name|lro
argument_list|)
operator|&&
name|sc
operator|->
name|lro_timeout
operator|!=
literal|0
condition|)
block|{
name|tcp_lro_flush_inactive
argument_list|(
name|lro
argument_list|,
operator|&
name|lro_timeout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|budget
condition|)
block|{
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_HAS_FL
condition|)
block|{
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
block|}
block|}
if|if
condition|(
name|refill
condition|)
block|{
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|fl_hw_cidx
operator|=
name|fl
operator|->
name|hw_cidx
expr_stmt|;
block|}
block|}
name|process_iql
label|:
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|iql
argument_list|)
condition|)
break|break;
comment|/* 		 * Process the head only, and send it to the back of the list if 		 * it's still not done. 		 */
name|q
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|iql
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|iql
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|service_iq
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|qsize
operator|/
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|atomic_cmpset_int
argument_list|(
operator|&
name|q
operator|->
name|state
argument_list|,
name|IQS_BUSY
argument_list|,
name|IQS_IDLE
argument_list|)
expr_stmt|;
else|else
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|iql
argument_list|,
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_LRO_ENABLED
condition|)
block|{
if|if
condition|(
name|ndescs
operator|>
literal|0
operator|&&
name|lro
operator|->
name|lro_mbuf_count
operator|>
literal|8
condition|)
block|{
name|MPASS
argument_list|(
name|sort_before_lro
argument_list|(
name|lro
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hold back one credit and don't flush LRO state */
name|iq
operator|->
name|flags
operator||=
name|IQ_ADJ_CREDIT
expr_stmt|;
name|ndescs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|tcp_lro_flush_all
argument_list|(
name|lro
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_gts_reg
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndescs
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
operator|(
name|u32
operator|)
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|iq
operator|->
name|intr_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_HAS_FL
condition|)
block|{
name|int
name|starved
decl_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|starved
operator|=
name|refill_fl
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|starved
operator|!=
literal|0
argument_list|)
condition|)
name|add_fl_to_sfl
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|cl_has_metadata
parameter_list|(
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|struct
name|cluster_layout
modifier|*
name|cll
parameter_list|)
block|{
name|int
name|rc
init|=
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
operator|||
name|cll
operator|->
name|region1
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|rc
condition|)
name|MPASS
argument_list|(
name|cll
operator|->
name|region3
operator|>=
name|CL_METADATA_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|cluster_metadata
modifier|*
name|cl_metadata
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|struct
name|cluster_layout
modifier|*
name|cll
parameter_list|,
name|caddr_t
name|cl
parameter_list|)
block|{
if|if
condition|(
name|cl_has_metadata
argument_list|(
name|fl
argument_list|,
name|cll
argument_list|)
condition|)
block|{
name|struct
name|sw_zone_info
modifier|*
name|swz
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|cll
operator|->
name|zidx
index|]
decl_stmt|;
return|return
operator|(
operator|(
expr|struct
name|cluster_metadata
operator|*
operator|)
operator|(
name|cl
operator|+
name|swz
operator|->
name|size
operator|)
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rxb_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|uma_zone_t
name|zone
init|=
name|arg1
decl_stmt|;
name|caddr_t
name|cl
init|=
name|arg2
decl_stmt|;
name|uma_zfree
argument_list|(
name|zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|extfree_rels
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The mbuf returned by this function could be allocated from zone_mbuf or  * constructed in spare room in the cluster.  *  * The mbuf carries the payload in one of these ways  * a) frame inside the mbuf (mbuf from zone_mbuf)  * b) m_cljset (for clusters without metadata) zone_mbuf  * c) m_extaddref (cluster with metadata) inline mbuf  * d) m_extaddref (cluster with metadata) zone_mbuf  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|get_scatter_segment
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|fr_offset
parameter_list|,
name|int
name|remaining
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fl_sdesc
modifier|*
name|sd
init|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|fl
operator|->
name|cidx
index|]
decl_stmt|;
name|struct
name|cluster_layout
modifier|*
name|cll
init|=
operator|&
name|sd
operator|->
name|cll
decl_stmt|;
name|struct
name|sw_zone_info
modifier|*
name|swz
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|cll
operator|->
name|zidx
index|]
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|hwb
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
name|cll
operator|->
name|hwidx
index|]
decl_stmt|;
name|struct
name|cluster_metadata
modifier|*
name|clm
init|=
name|cl_metadata
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|cll
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|,
name|blen
decl_stmt|;
name|caddr_t
name|payload
decl_stmt|;
name|blen
operator|=
name|hwb
operator|->
name|size
operator|-
name|fl
operator|->
name|rx_offset
expr_stmt|;
comment|/* max possible in this buf */
name|len
operator|=
name|min
argument_list|(
name|remaining
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|payload
operator|=
name|sd
operator|->
name|cl
operator|+
name|cll
operator|->
name|region1
operator|+
name|fl
operator|->
name|rx_offset
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|)
block|{
specifier|const
name|u_int
name|l
init|=
name|fr_offset
operator|+
name|len
decl_stmt|;
specifier|const
name|u_int
name|pad
init|=
name|roundup2
argument_list|(
name|l
argument_list|,
name|fl
operator|->
name|buf_boundary
argument_list|)
operator|-
name|l
decl_stmt|;
if|if
condition|(
name|fl
operator|->
name|rx_offset
operator|+
name|len
operator|+
name|pad
operator|<
name|hwb
operator|->
name|size
condition|)
name|blen
operator|=
name|len
operator|+
name|pad
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|rx_offset
operator|+
name|blen
operator|<=
name|hwb
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
name|fl
operator|->
name|rx_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* not packing */
block|}
if|if
condition|(
name|sc
operator|->
name|sc_do_rxcopy
operator|&&
name|len
operator|<
name|RX_COPY_THRESHOLD
condition|)
block|{
comment|/* 		 * Copy payload into a freshly allocated mbuf. 		 */
name|m
operator|=
name|fr_offset
operator|==
literal|0
condition|?
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
else|:
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fl
operator|->
name|mbuf_allocated
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|T4_PKT_TIMESTAMP
comment|/* Leave room for a timestamp */
name|m
operator|->
name|m_data
operator|+=
literal|8
expr_stmt|;
endif|#
directive|endif
comment|/* copy data to mbuf */
name|bcopy
argument_list|(
name|payload
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|nmbuf
operator|*
name|MSIZE
operator|<
name|cll
operator|->
name|region1
condition|)
block|{
comment|/* 		 * There's spare room in the cluster for an mbuf.  Create one 		 * and associate it with the payload that's in the cluster. 		 */
name|MPASS
argument_list|(
name|clm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|sd
operator|->
name|cl
operator|+
name|sd
operator|->
name|nmbuf
operator|*
name|MSIZE
operator|)
expr_stmt|;
comment|/* No bzero required */
if|if
condition|(
name|m_init
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|fr_offset
operator|==
literal|0
condition|?
name|M_PKTHDR
operator||
name|M_NOFREE
else|:
name|M_NOFREE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fl
operator|->
name|mbuf_inlined
operator|++
expr_stmt|;
name|m_extaddref
argument_list|(
name|m
argument_list|,
name|payload
argument_list|,
name|blen
argument_list|,
operator|&
name|clm
operator|->
name|refcount
argument_list|,
name|rxb_free
argument_list|,
name|swz
operator|->
name|zone
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|nmbuf
operator|++
operator|==
literal|0
condition|)
name|counter_u64_add
argument_list|(
name|extfree_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Grab an mbuf from zone_mbuf and associate it with the 		 * payload in the cluster. 		 */
name|m
operator|=
name|fr_offset
operator|==
literal|0
condition|?
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
else|:
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fl
operator|->
name|mbuf_allocated
operator|++
expr_stmt|;
if|if
condition|(
name|clm
operator|!=
name|NULL
condition|)
block|{
name|m_extaddref
argument_list|(
name|m
argument_list|,
name|payload
argument_list|,
name|blen
argument_list|,
operator|&
name|clm
operator|->
name|refcount
argument_list|,
name|rxb_free
argument_list|,
name|swz
operator|->
name|zone
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|nmbuf
operator|++
operator|==
literal|0
condition|)
name|counter_u64_add
argument_list|(
name|extfree_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_cljset
argument_list|(
name|m
argument_list|,
name|sd
operator|->
name|cl
argument_list|,
name|swz
operator|->
name|type
argument_list|)
expr_stmt|;
name|sd
operator|->
name|cl
operator|=
name|NULL
expr_stmt|;
comment|/* consumed, not a recycle candidate */
block|}
block|}
if|if
condition|(
name|fr_offset
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|remaining
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|)
block|{
name|fl
operator|->
name|rx_offset
operator|+=
name|blen
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|rx_offset
operator|<=
name|hwb
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|rx_offset
operator|<
name|hwb
operator|->
name|size
condition|)
return|return
operator|(
name|m
operator|)
return|;
comment|/* without advancing the cidx */
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|fl
operator|->
name|cidx
operator|%
literal|8
operator|==
literal|0
argument_list|)
condition|)
block|{
name|uint16_t
name|cidx
init|=
name|fl
operator|->
name|cidx
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cidx
operator|==
name|fl
operator|->
name|sidx
argument_list|)
condition|)
name|fl
operator|->
name|cidx
operator|=
name|cidx
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|hw_cidx
operator|=
name|cidx
expr_stmt|;
block|}
name|fl
operator|->
name|rx_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|get_fl_payload
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|uint32_t
name|len_newbuf
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pnext
decl_stmt|;
name|u_int
name|remaining
decl_stmt|;
specifier|const
name|u_int
name|total
init|=
name|G_RSPD_LEN
argument_list|(
name|len_newbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_RESUME
argument_list|)
condition|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|fl
operator|->
name|m0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
name|total
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|remaining
operator|<
name|total
argument_list|)
expr_stmt|;
name|m0
operator|=
name|fl
operator|->
name|m0
expr_stmt|;
name|pnext
operator|=
name|fl
operator|->
name|pnext
expr_stmt|;
name|remaining
operator|=
name|fl
operator|->
name|remaining
expr_stmt|;
name|fl
operator|->
name|flags
operator|&=
operator|~
name|FL_BUF_RESUME
expr_stmt|;
goto|goto
name|get_segment
goto|;
block|}
if|if
condition|(
name|fl
operator|->
name|rx_offset
operator|>
literal|0
operator|&&
name|len_newbuf
operator|&
name|F_RSPD_NEWBUF
condition|)
block|{
name|fl
operator|->
name|rx_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|fl
operator|->
name|cidx
operator|%
literal|8
operator|==
literal|0
argument_list|)
condition|)
block|{
name|uint16_t
name|cidx
init|=
name|fl
operator|->
name|cidx
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cidx
operator|==
name|fl
operator|->
name|sidx
argument_list|)
condition|)
name|fl
operator|->
name|cidx
operator|=
name|cidx
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|hw_cidx
operator|=
name|cidx
expr_stmt|;
block|}
block|}
comment|/* 	 * Payload starts at rx_offset in the current hw buffer.  Its length is 	 * 'len' and it may span multiple hw buffers. 	 */
name|m0
operator|=
name|get_scatter_segment
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
literal|0
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|remaining
operator|=
name|total
operator|-
name|m0
operator|->
name|m_len
expr_stmt|;
name|pnext
operator|=
operator|&
name|m0
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|get_segment
label|:
name|MPASS
argument_list|(
name|fl
operator|->
name|rx_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|m
operator|=
name|get_scatter_segment
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|total
operator|-
name|remaining
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|fl
operator|->
name|m0
operator|=
name|m0
expr_stmt|;
name|fl
operator|->
name|pnext
operator|=
name|pnext
expr_stmt|;
name|fl
operator|->
name|remaining
operator|=
name|remaining
expr_stmt|;
name|fl
operator|->
name|flags
operator||=
name|FL_BUF_RESUME
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|pnext
operator|=
name|m
expr_stmt|;
name|pnext
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|remaining
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
operator|*
name|pnext
operator|=
name|NULL
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|m0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t4_eth_rx
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|sge_rxq
modifier|*
name|rxq
init|=
name|iq_to_rxq
argument_list|(
name|iq
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rxq
operator|->
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxq
operator|->
name|lro
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|int
name|sw_hashtype
index|[
literal|4
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
name|M_HASHTYPE_NONE
block|,
name|M_HASHTYPE_NONE
block|}
block|,
block|{
name|M_HASHTYPE_RSS_IPV4
block|,
name|M_HASHTYPE_RSS_IPV6
block|}
block|,
block|{
name|M_HASHTYPE_RSS_TCP_IPV4
block|,
name|M_HASHTYPE_RSS_TCP_IPV6
block|}
block|,
block|{
name|M_HASHTYPE_RSS_UDP_IPV4
block|,
name|M_HASHTYPE_RSS_UDP_IPV6
block|}
block|, 	}
decl_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no payload with opcode %02x"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|fl_pktshift
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|fl_pktshift
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|fl_pktshift
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m0
argument_list|,
name|sw_hashtype
index|[
name|rss
operator|->
name|hash_type
index|]
index|[
name|rss
operator|->
name|ipv6
index|]
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|be32toh
argument_list|(
name|rss
operator|->
name|hash_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|csum_calc
operator|&&
operator|!
operator|(
name|cpl
operator|->
name|err_vec
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
operator|.
name|err_vec_mask
operator|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|&&
name|cpl
operator|->
name|l2info
operator|&
name|htobe32
argument_list|(
name|F_RXF_IP
argument_list|)
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|rxq
operator|->
name|rxcsum
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM_IPV6
operator|&&
name|cpl
operator|->
name|l2info
operator|&
name|htobe32
argument_list|(
name|F_RXF_IP6
argument_list|)
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_DATA_VALID_IPV6
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|rxq
operator|->
name|rxcsum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|cpl
operator|->
name|ip_frag
argument_list|)
condition|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|be16toh
argument_list|(
name|cpl
operator|->
name|csum
argument_list|)
expr_stmt|;
else|else
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|cpl
operator|->
name|vlan_ex
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|be16toh
argument_list|(
name|cpl
operator|->
name|vlan
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
name|rxq
operator|->
name|vlan_extraction
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_LRO_ENABLED
condition|)
block|{
if|if
condition|(
name|sort_before_lro
argument_list|(
name|lro
argument_list|)
condition|)
block|{
name|tcp_lro_queue_mbuf
argument_list|(
name|lro
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* queued for sort, then LRO */
block|}
if|if
condition|(
name|tcp_lro_rx
argument_list|(
name|lro
argument_list|,
name|m0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* queued for LRO */
block|}
endif|#
directive|endif
name|ifp
operator|->
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Must drain the wrq or make sure that someone else will.  */
end_comment

begin_function
specifier|static
name|void
name|wrq_tx_drain
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|sge_wrq
modifier|*
name|wrq
init|=
name|arg
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|wrq
operator|->
name|eq
decl_stmt|;
name|EQ_LOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|)
operator|&&
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|)
condition|)
name|drain_wrq_wr_list
argument_list|(
name|wrq
operator|->
name|adapter
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drain_wrq_wr_list
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|wrq
operator|->
name|eq
decl_stmt|;
name|u_int
name|available
decl_stmt|,
name|dbdiff
decl_stmt|;
comment|/* # of hardware descriptors */
name|u_int
name|n
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|struct
name|fw_eth_tx_pkt_wr
modifier|*
name|dst
decl_stmt|;
comment|/* any fw WR struct will do */
name|EQ_LOCK_ASSERT_OWNED
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Must be called with something useful to do */
name|MPASS
argument_list|(
name|eq
operator|->
name|pidx
operator|==
name|eq
operator|->
name|dbidx
argument_list|)
expr_stmt|;
name|dbdiff
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|eq
operator|->
name|cidx
operator|=
name|read_hw_cidx
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|pidx
operator|==
name|eq
operator|->
name|cidx
condition|)
name|available
operator|=
name|eq
operator|->
name|sidx
operator|-
literal|1
expr_stmt|;
else|else
name|available
operator|=
name|IDXDIFF
argument_list|(
name|eq
operator|->
name|cidx
argument_list|,
name|eq
operator|->
name|pidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|-
literal|1
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|wrq
operator|==
name|wrq
argument_list|)
expr_stmt|;
name|n
operator|=
name|howmany
argument_list|(
name|wr
operator|->
name|wr_len
argument_list|,
name|EQ_ESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|<
name|n
condition|)
break|break;
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|eq
operator|->
name|sidx
operator|-
name|eq
operator|->
name|pidx
operator|>
name|n
argument_list|)
condition|)
block|{
comment|/* Won't wrap, won't end exactly at the status page. */
name|bcopy
argument_list|(
operator|&
name|wr
operator|->
name|wr
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|,
name|wr
operator|->
name|wr_len
argument_list|)
expr_stmt|;
name|eq
operator|->
name|pidx
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|int
name|first_portion
init|=
operator|(
name|eq
operator|->
name|sidx
operator|-
name|eq
operator|->
name|pidx
operator|)
operator|*
name|EQ_ESIZE
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|wr
operator|->
name|wr
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|,
name|first_portion
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|->
name|wr_len
operator|>
name|first_portion
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|wr
operator|->
name|wr
index|[
name|first_portion
index|]
argument_list|,
operator|&
name|eq
operator|->
name|desc
index|[
literal|0
index|]
argument_list|,
name|wr
operator|->
name|wr_len
operator|-
name|first_portion
argument_list|)
expr_stmt|;
block|}
name|eq
operator|->
name|pidx
operator|=
name|n
operator|-
operator|(
name|eq
operator|->
name|sidx
operator|-
name|eq
operator|->
name|pidx
operator|)
expr_stmt|;
block|}
name|wrq
operator|->
name|tx_wrs_copied
operator|++
expr_stmt|;
if|if
condition|(
name|available
operator|<
name|eq
operator|->
name|sidx
operator|/
literal|4
operator|&&
name|atomic_cmpset_int
argument_list|(
operator|&
name|eq
operator|->
name|equiq
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dst
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUIQ
operator||
name|F_FW_WR_EQUEQ
argument_list|)
expr_stmt|;
name|eq
operator|->
name|equeqidx
operator|=
name|eq
operator|->
name|pidx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDXDIFF
argument_list|(
name|eq
operator|->
name|pidx
argument_list|,
name|eq
operator|->
name|equeqidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|>=
literal|32
condition|)
block|{
name|dst
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
argument_list|)
expr_stmt|;
name|eq
operator|->
name|equeqidx
operator|=
name|eq
operator|->
name|pidx
expr_stmt|;
block|}
name|dbdiff
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|dbdiff
operator|>=
literal|16
condition|)
block|{
name|ring_eq_db
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|,
name|dbdiff
argument_list|)
expr_stmt|;
name|dbdiff
operator|=
literal|0
expr_stmt|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free_wrqe
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wrq
operator|->
name|nwr_pending
operator|>
literal|0
argument_list|)
expr_stmt|;
name|wrq
operator|->
name|nwr_pending
operator|--
expr_stmt|;
name|MPASS
argument_list|(
name|wrq
operator|->
name|ndesc_needed
operator|>=
name|n
argument_list|)
expr_stmt|;
name|wrq
operator|->
name|ndesc_needed
operator|-=
name|n
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|wr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|dbdiff
condition|)
name|ring_eq_db
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|,
name|dbdiff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Doesn't fail.  Holds on to work requests it can't send right away.  */
end_comment

begin_function
name|void
name|t4_wrq_tx_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|,
name|struct
name|wrqe
modifier|*
name|wr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|wrq
operator|->
name|eq
decl_stmt|;
endif|#
directive|endif
name|EQ_LOCK_ASSERT_OWNED
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|->
name|wr_len
operator|>
literal|0
operator|&&
name|wr
operator|->
name|wr_len
operator|<=
name|SGE_MAX_WR_LEN
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|wr
operator|->
name|wr_len
operator|&
literal|0x7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|,
name|wr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|wrq
operator|->
name|nwr_pending
operator|++
expr_stmt|;
name|wrq
operator|->
name|ndesc_needed
operator|+=
name|howmany
argument_list|(
name|wr
operator|->
name|wr_len
argument_list|,
name|EQ_ESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|)
condition|)
return|return;
comment|/* commit_wrq_wr will drain wr_list as well. */
name|drain_wrq_wr_list
argument_list|(
name|sc
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
comment|/* Doorbell must have caught up to the pidx. */
name|MPASS
argument_list|(
name|eq
operator|->
name|pidx
operator|==
name|eq
operator|->
name|dbidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t4_update_fl_bufsize
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
decl_stmt|;
endif|#
directive|endif
name|struct
name|sge_fl
modifier|*
name|fl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxp
decl_stmt|,
name|mtu
init|=
name|ifp
operator|->
name|if_mtu
decl_stmt|;
name|maxp
operator|=
name|mtu_to_max_payload
argument_list|(
name|sc
argument_list|,
name|mtu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|for_each_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|fl
operator|=
operator|&
name|rxq
operator|->
name|fl
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|find_best_refill_source
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|maxp
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|maxp
operator|=
name|mtu_to_max_payload
argument_list|(
name|sc
argument_list|,
name|mtu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|for_each_ofld_rxq
argument_list|(
argument|vi
argument_list|,
argument|i
argument_list|,
argument|ofld_rxq
argument_list|)
block|{
name|fl
operator|=
operator|&
name|ofld_rxq
operator|->
name|fl
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|find_best_refill_source
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|maxp
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mbuf_nsegs
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|l5hlen
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: mbuf %p missing information on # of segments."
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|l5hlen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_mbuf_nsegs
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|nsegs
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|l5hlen
operator|=
name|nsegs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mbuf_len16
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|eight
index|[
literal|0
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<=
name|SGE_MAX_WR_LEN
operator|/
literal|16
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_mbuf_len16
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|len16
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|eight
index|[
literal|0
index|]
operator|=
name|len16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|needs_tso
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: TSO requested in mbuf %p but MSS not provided"
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|needs_l3_csum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TSO
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|needs_l4_csum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_TSO
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|needs_vlan_insertion
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: HWVLAN requested in mbuf %p but tag not provided"
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|m_advance
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
modifier|*
name|poffset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|pm
decl_stmt|;
name|int
name|offset
init|=
operator|*
name|poffset
decl_stmt|;
name|uintptr_t
name|p
init|=
literal|0
decl_stmt|;
name|MPASS
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|offset
operator|+
name|len
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
name|offset
operator|+=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uintptr_t
argument_list|)
operator|+
name|offset
expr_stmt|;
break|break;
block|}
name|len
operator|-=
name|m
operator|->
name|m_len
operator|-
name|offset
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|poffset
operator|=
name|offset
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can deal with empty mbufs in the chain that have m_len = 0, but the chain  * must have at least one mbuf that's not empty.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|count_mbuf_nsegs
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|vm_paddr_t
name|lastb
decl_stmt|,
name|next
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|len
decl_stmt|,
name|nsegs
decl_stmt|;
name|MPASS
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
name|lastb
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|len
operator|==
literal|0
argument_list|)
condition|)
continue|continue;
name|va
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
expr_stmt|;
name|next
operator|=
name|pmap_kextract
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|nsegs
operator|+=
name|sglist_count
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastb
operator|+
literal|1
operator|==
name|next
condition|)
name|nsegs
operator|--
expr_stmt|;
name|lastb
operator|=
name|pmap_kextract
argument_list|(
name|va
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|nsegs
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|nsegs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Analyze the mbuf to determine its tx needs.  The mbuf passed in may change:  * a) caller can assume it's been freed if this function returns with an error.  * b) it may get defragged up if the gather list is too long for the hardware.  */
end_comment

begin_function
name|int
name|parse_pkt
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
operator|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|nsegs
decl_stmt|,
name|defragged
init|=
literal|0
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|void
modifier|*
name|l3hdr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|eh_type
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|ETHER_HDR_LEN
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|fail
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|restart
label|:
comment|/* 	 * First count the number of gather list segments in the payload. 	 * Defrag the mbuf if nsegs exceeds the hardware limit. 	 */
name|M_ASSERTPKTHDR
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nsegs
operator|=
name|count_mbuf_nsegs
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|>
operator|(
name|needs_tso
argument_list|(
name|m0
argument_list|)
condition|?
name|TX_SGL_SEGS_TSO
else|:
name|TX_SGL_SEGS
operator|)
condition|)
block|{
if|if
condition|(
name|defragged
operator|++
operator|>
literal|0
operator|||
operator|(
name|m
operator|=
name|m_defrag
argument_list|(
name|m0
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
operator|*
name|mp
operator|=
name|m0
operator|=
name|m
expr_stmt|;
comment|/* update caller's copy after defrag */
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|nsegs
operator|>
literal|2
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|MHLEN
argument_list|)
condition|)
block|{
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
comment|/* Should have left well enough alone. */
name|rc
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
operator|*
name|mp
operator|=
name|m0
expr_stmt|;
comment|/* update caller's copy after pullup */
goto|goto
name|restart
goto|;
block|}
name|set_mbuf_nsegs
argument_list|(
name|m0
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
condition|)
name|set_mbuf_len16
argument_list|(
name|m0
argument_list|,
name|txpkt_vm_len16
argument_list|(
name|nsegs
argument_list|,
name|needs_tso
argument_list|(
name|m0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_mbuf_len16
argument_list|(
name|m0
argument_list|,
name|txpkt_len16
argument_list|(
name|nsegs
argument_list|,
name|needs_tso
argument_list|(
name|m0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_tso
argument_list|(
name|m0
argument_list|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
operator|&&
operator|(
name|needs_l3_csum
argument_list|(
name|m0
argument_list|)
operator|||
name|needs_l4_csum
argument_list|(
name|m0
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|=
name|m0
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eh_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_type
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|evh
init|=
operator|(
name|void
operator|*
operator|)
name|eh
decl_stmt|;
name|eh_type
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|evh
argument_list|)
expr_stmt|;
block|}
else|else
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|l3hdr
operator|=
name|m_advance
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|offset
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|eh_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|l3hdr
decl_stmt|;
name|MPASS
argument_list|(
operator|!
name|needs_tso
argument_list|(
name|m0
argument_list|)
operator|||
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|l3hdr
decl_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|*
literal|4
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: ethertype 0x%04x unknown.  if_cxgbe must be compiled"
literal|" with the same INET/INET6 options as the kernel."
argument_list|,
name|__func__
argument_list|,
name|eh_type
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|needs_tso
argument_list|(
name|m0
argument_list|)
condition|)
block|{
name|tcp
operator|=
name|m_advance
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|offset
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|l4hlen
operator|=
name|tcp
operator|->
name|th_off
operator|*
literal|4
expr_stmt|;
block|}
endif|#
directive|endif
name|MPASS
argument_list|(
name|m0
operator|==
operator|*
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|start_wrq_wr
parameter_list|(
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|,
name|int
name|len16
parameter_list|,
name|struct
name|wrq_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|wrq
operator|->
name|eq
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|wrq
operator|->
name|adapter
decl_stmt|;
name|int
name|ndesc
decl_stmt|,
name|available
decl_stmt|;
name|struct
name|wrqe
modifier|*
name|wr
decl_stmt|;
name|void
modifier|*
name|w
decl_stmt|;
name|MPASS
argument_list|(
name|len16
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|howmany
argument_list|(
name|len16
argument_list|,
name|EQ_ESIZE
operator|/
literal|16
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ndesc
operator|>
literal|0
operator|&&
name|ndesc
operator|<=
name|SGE_MAX_WR_NDESC
argument_list|)
expr_stmt|;
name|EQ_LOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|)
condition|)
name|drain_wrq_wr_list
argument_list|(
name|sc
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|)
condition|)
block|{
name|slowpath
label|:
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|wr
operator|=
name|alloc_wrqe
argument_list|(
name|len16
operator|*
literal|16
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|wr
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cookie
operator|->
name|pidx
operator|=
operator|-
literal|1
expr_stmt|;
name|cookie
operator|->
name|ndesc
operator|=
name|ndesc
expr_stmt|;
return|return
operator|(
operator|&
name|wr
operator|->
name|wr
operator|)
return|;
block|}
name|eq
operator|->
name|cidx
operator|=
name|read_hw_cidx
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|pidx
operator|==
name|eq
operator|->
name|cidx
condition|)
name|available
operator|=
name|eq
operator|->
name|sidx
operator|-
literal|1
expr_stmt|;
else|else
name|available
operator|=
name|IDXDIFF
argument_list|(
name|eq
operator|->
name|cidx
argument_list|,
name|eq
operator|->
name|pidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|available
operator|<
name|ndesc
condition|)
goto|goto
name|slowpath
goto|;
name|cookie
operator|->
name|pidx
operator|=
name|eq
operator|->
name|pidx
expr_stmt|;
name|cookie
operator|->
name|ndesc
operator|=
name|ndesc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|,
name|cookie
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|w
operator|=
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|IDXINCR
argument_list|(
name|eq
operator|->
name|pidx
argument_list|,
name|ndesc
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cookie
operator|->
name|pidx
operator|+
name|ndesc
operator|>
name|eq
operator|->
name|sidx
argument_list|)
condition|)
block|{
name|w
operator|=
operator|&
name|wrq
operator|->
name|ss
index|[
literal|0
index|]
expr_stmt|;
name|wrq
operator|->
name|ss_pidx
operator|=
name|cookie
operator|->
name|pidx
expr_stmt|;
name|wrq
operator|->
name|ss_len
operator|=
name|len16
operator|*
literal|16
expr_stmt|;
block|}
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|)
return|;
block|}
end_function

begin_function
name|void
name|commit_wrq_wr
parameter_list|(
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|,
name|void
modifier|*
name|w
parameter_list|,
name|struct
name|wrq_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|wrq
operator|->
name|eq
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|wrq
operator|->
name|adapter
decl_stmt|;
name|int
name|ndesc
decl_stmt|,
name|pidx
decl_stmt|;
name|struct
name|wrq_cookie
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|cookie
operator|->
name|pidx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|wrqe
modifier|*
name|wr
init|=
name|__containerof
argument_list|(
name|w
argument_list|,
expr|struct
name|wrqe
argument_list|,
name|wr
argument_list|)
decl_stmt|;
name|t4_wrq_tx
argument_list|(
name|sc
argument_list|,
name|wr
argument_list|)
expr_stmt|;
return|return;
block|}
name|ndesc
operator|=
name|cookie
operator|->
name|ndesc
expr_stmt|;
comment|/* Can be more than SGE_MAX_WR_NDESC here. */
name|pidx
operator|=
name|cookie
operator|->
name|pidx
expr_stmt|;
name|MPASS
argument_list|(
name|pidx
operator|>=
literal|0
operator|&&
name|pidx
operator|<
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|w
operator|==
operator|&
name|wrq
operator|->
name|ss
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|n
init|=
operator|(
name|eq
operator|->
name|sidx
operator|-
name|wrq
operator|->
name|ss_pidx
operator|)
operator|*
name|EQ_ESIZE
decl_stmt|;
name|MPASS
argument_list|(
name|wrq
operator|->
name|ss_len
operator|>
name|n
argument_list|)
expr_stmt|;
comment|/* WR had better wrap around. */
name|bcopy
argument_list|(
operator|&
name|wrq
operator|->
name|ss
index|[
literal|0
index|]
argument_list|,
operator|&
name|eq
operator|->
name|desc
index|[
name|wrq
operator|->
name|ss_pidx
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|wrq
operator|->
name|ss
index|[
name|n
index|]
argument_list|,
operator|&
name|eq
operator|->
name|desc
index|[
literal|0
index|]
argument_list|,
name|wrq
operator|->
name|ss_len
operator|-
name|n
argument_list|)
expr_stmt|;
name|wrq
operator|->
name|tx_wrs_ss
operator|++
expr_stmt|;
block|}
else|else
name|wrq
operator|->
name|tx_wrs_direct
operator|++
expr_stmt|;
name|EQ_LOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|prev
operator|=
name|TAILQ_PREV
argument_list|(
name|cookie
argument_list|,
name|wrq_incomplete_wrs
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|cookie
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
name|pidx
operator|==
name|eq
operator|->
name|dbidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
operator|||
name|ndesc
operator|>=
literal|16
condition|)
name|ring_eq_db
argument_list|(
name|wrq
operator|->
name|adapter
argument_list|,
name|eq
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
else|else
block|{
name|MPASS
argument_list|(
name|IDXDIFF
argument_list|(
name|next
operator|->
name|pidx
argument_list|,
name|pidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|==
name|ndesc
argument_list|)
expr_stmt|;
name|next
operator|->
name|pidx
operator|=
name|pidx
expr_stmt|;
name|next
operator|->
name|ndesc
operator|+=
name|ndesc
expr_stmt|;
block|}
block|}
else|else
block|{
name|MPASS
argument_list|(
name|IDXDIFF
argument_list|(
name|pidx
argument_list|,
name|prev
operator|->
name|pidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|==
name|prev
operator|->
name|ndesc
argument_list|)
expr_stmt|;
name|prev
operator|->
name|ndesc
operator|+=
name|ndesc
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|,
name|cookie
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|)
operator|&&
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|)
condition|)
name|drain_wrq_wr_list
argument_list|(
name|sc
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|)
condition|)
block|{
comment|/* Doorbell must have caught up to the pidx. */
name|MPASS
argument_list|(
name|wrq
operator|->
name|eq
operator|.
name|pidx
operator|==
name|wrq
operator|->
name|eq
operator|.
name|dbidx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|EQ_UNLOCK
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|can_resume_eth_tx
parameter_list|(
name|struct
name|mp_ring
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
name|r
operator|->
name|cookie
decl_stmt|;
return|return
operator|(
name|total_available_tx_desc
argument_list|(
name|eq
argument_list|)
operator|>
name|eq
operator|->
name|sidx
operator|/
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|cannot_use_txpkts
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
comment|/* maybe put a GL limit too, to avoid silliness? */
return|return
operator|(
name|needs_tso
argument_list|(
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * r->items[cidx] to r->items[pidx], with a wraparound at r->size, are ready to  * be consumed.  Return the actual number consumed.  0 indicates a stall.  */
end_comment

begin_function
specifier|static
name|u_int
name|eth_tx
parameter_list|(
name|struct
name|mp_ring
modifier|*
name|r
parameter_list|,
name|u_int
name|cidx
parameter_list|,
name|u_int
name|pidx
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|r
operator|->
name|cookie
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|txq
operator|->
name|ifp
decl_stmt|;
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|u_int
name|total
decl_stmt|,
name|remaining
decl_stmt|;
comment|/* # of packets */
name|u_int
name|available
decl_stmt|,
name|dbdiff
decl_stmt|;
comment|/* # of hardware descriptors */
name|u_int
name|n
decl_stmt|,
name|next_cidx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|struct
name|txpkts
name|txp
decl_stmt|;
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
name|wr
decl_stmt|;
comment|/* any fw WR struct will do */
name|remaining
operator|=
name|IDXDIFF
argument_list|(
name|pidx
argument_list|,
name|cidx
argument_list|,
name|r
operator|->
name|size
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|remaining
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Must not be called without work to do. */
name|total
operator|=
literal|0
expr_stmt|;
name|TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_ENABLED
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
while|while
condition|(
name|cidx
operator|!=
name|pidx
condition|)
block|{
name|m0
operator|=
name|r
operator|->
name|items
index|[
name|cidx
index|]
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|r
operator|->
name|size
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
name|reclaim_tx_descs
argument_list|(
name|txq
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|total
operator|=
name|remaining
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* How many hardware descriptors do we have readily available. */
if|if
condition|(
name|eq
operator|->
name|pidx
operator|==
name|eq
operator|->
name|cidx
condition|)
name|available
operator|=
name|eq
operator|->
name|sidx
operator|-
literal|1
expr_stmt|;
else|else
name|available
operator|=
name|IDXDIFF
argument_list|(
name|eq
operator|->
name|cidx
argument_list|,
name|eq
operator|->
name|pidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|-
literal|1
expr_stmt|;
name|dbdiff
operator|=
name|IDXDIFF
argument_list|(
name|eq
operator|->
name|pidx
argument_list|,
name|eq
operator|->
name|dbidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|m0
operator|=
name|r
operator|->
name|items
index|[
name|cidx
index|]
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|m0
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|<
name|SGE_MAX_WR_NDESC
condition|)
block|{
name|available
operator|+=
name|reclaim_tx_descs
argument_list|(
name|txq
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|<
name|howmany
argument_list|(
name|mbuf_len16
argument_list|(
name|m0
argument_list|)
argument_list|,
name|EQ_ESIZE
operator|/
literal|16
argument_list|)
condition|)
break|break;
comment|/* out of descriptors */
block|}
name|next_cidx
operator|=
name|cidx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|next_cidx
operator|==
name|r
operator|->
name|size
argument_list|)
condition|)
name|next_cidx
operator|=
literal|0
expr_stmt|;
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|n
operator|=
name|write_txpkt_vm_wr
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|wr
argument_list|,
name|m0
argument_list|,
name|available
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remaining
operator|>
literal|1
operator|&&
name|try_txpkts
argument_list|(
name|m0
argument_list|,
name|r
operator|->
name|items
index|[
name|next_cidx
index|]
argument_list|,
operator|&
name|txp
argument_list|,
name|available
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* pkts at cidx, next_cidx should both be in txp. */
name|MPASS
argument_list|(
name|txp
operator|.
name|npkt
operator|==
literal|2
argument_list|)
expr_stmt|;
name|tail
operator|=
name|r
operator|->
name|items
index|[
name|next_cidx
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|tail
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|next_cidx
operator|==
name|r
operator|->
name|size
argument_list|)
condition|)
name|next_cidx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|next_cidx
operator|!=
name|pidx
condition|)
block|{
if|if
condition|(
name|add_to_txpkts
argument_list|(
name|r
operator|->
name|items
index|[
name|next_cidx
index|]
argument_list|,
operator|&
name|txp
argument_list|,
name|available
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|tail
operator|->
name|m_nextpkt
operator|=
name|r
operator|->
name|items
index|[
name|next_cidx
index|]
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|m_nextpkt
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|next_cidx
operator|==
name|r
operator|->
name|size
argument_list|)
condition|)
name|next_cidx
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|=
name|write_txpkts_wr
argument_list|(
name|txq
argument_list|,
name|wr
argument_list|,
name|m0
argument_list|,
operator|&
name|txp
argument_list|,
name|available
argument_list|)
expr_stmt|;
name|total
operator|+=
name|txp
operator|.
name|npkt
expr_stmt|;
name|remaining
operator|-=
name|txp
operator|.
name|npkt
expr_stmt|;
block|}
else|else
block|{
name|total
operator|++
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|n
operator|=
name|write_txpkt_wr
argument_list|(
name|txq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|wr
argument_list|,
name|m0
argument_list|,
name|available
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|n
operator|>=
literal|1
operator|&&
name|n
operator|<=
name|available
operator|&&
name|n
operator|<=
name|SGE_MAX_WR_NDESC
argument_list|)
expr_stmt|;
name|available
operator|-=
name|n
expr_stmt|;
name|dbdiff
operator|+=
name|n
expr_stmt|;
name|IDXINCR
argument_list|(
name|eq
operator|->
name|pidx
argument_list|,
name|n
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_available_tx_desc
argument_list|(
name|eq
argument_list|)
operator|<
name|eq
operator|->
name|sidx
operator|/
literal|4
operator|&&
name|atomic_cmpset_int
argument_list|(
operator|&
name|eq
operator|->
name|equiq
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUIQ
operator||
name|F_FW_WR_EQUEQ
argument_list|)
expr_stmt|;
name|eq
operator|->
name|equeqidx
operator|=
name|eq
operator|->
name|pidx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDXDIFF
argument_list|(
name|eq
operator|->
name|pidx
argument_list|,
name|eq
operator|->
name|equeqidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|>=
literal|32
condition|)
block|{
name|wr
operator|->
name|equiq_to_len16
operator||=
name|htobe32
argument_list|(
name|F_FW_WR_EQUEQ
argument_list|)
expr_stmt|;
name|eq
operator|->
name|equeqidx
operator|=
name|eq
operator|->
name|pidx
expr_stmt|;
block|}
if|if
condition|(
name|dbdiff
operator|>=
literal|16
operator|&&
name|remaining
operator|>=
literal|4
condition|)
block|{
name|ring_eq_db
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|,
name|dbdiff
argument_list|)
expr_stmt|;
name|available
operator|+=
name|reclaim_tx_descs
argument_list|(
name|txq
argument_list|,
literal|4
operator|*
name|dbdiff
argument_list|)
expr_stmt|;
name|dbdiff
operator|=
literal|0
expr_stmt|;
block|}
name|cidx
operator|=
name|next_cidx
expr_stmt|;
block|}
if|if
condition|(
name|dbdiff
operator|!=
literal|0
condition|)
block|{
name|ring_eq_db
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|,
name|dbdiff
argument_list|)
expr_stmt|;
name|reclaim_tx_descs
argument_list|(
name|txq
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|init_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tmr_idx
parameter_list|,
name|int
name|pktc_idx
parameter_list|,
name|int
name|qsize
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tmr_idx
operator|>=
literal|0
operator|&&
name|tmr_idx
operator|<
name|SGE_NTIMERS
argument_list|,
operator|(
literal|"%s: bad tmr_idx %d"
operator|,
name|__func__
operator|,
name|tmr_idx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pktc_idx
operator|<
name|SGE_NCOUNTERS
argument_list|,
comment|/* -ve is ok, means don't use */
operator|(
literal|"%s: bad pktc_idx %d"
operator|,
name|__func__
operator|,
name|pktc_idx
operator|)
argument_list|)
expr_stmt|;
name|iq
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|iq
operator|->
name|intr_params
operator|=
name|V_QINTR_TIMER_IDX
argument_list|(
name|tmr_idx
argument_list|)
expr_stmt|;
name|iq
operator|->
name|intr_pktc_idx
operator|=
name|SGE_NCOUNTERS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pktc_idx
operator|>=
literal|0
condition|)
block|{
name|iq
operator|->
name|intr_params
operator||=
name|F_QINTR_CNT_EN
expr_stmt|;
name|iq
operator|->
name|intr_pktc_idx
operator|=
name|pktc_idx
expr_stmt|;
block|}
name|iq
operator|->
name|qsize
operator|=
name|roundup2
argument_list|(
name|qsize
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* See FW_IQ_CMD/iqsize */
name|iq
operator|->
name|sidx
operator|=
name|iq
operator|->
name|qsize
operator|-
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|IQ_ESIZE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|init_fl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|qsize
parameter_list|,
name|int
name|maxp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fl
operator|->
name|qsize
operator|=
name|qsize
expr_stmt|;
name|fl
operator|->
name|sidx
operator|=
name|qsize
operator|-
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|EQ_ESIZE
expr_stmt|;
name|strlcpy
argument_list|(
name|fl
operator|->
name|lockname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|fl
operator|->
name|lockname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|BUF_PACKING_OK
operator|&&
operator|(
operator|(
operator|!
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|buffer_packing
operator|)
operator|||
comment|/* T5+: enabled unless 0 */
operator|(
name|is_t4
argument_list|(
name|sc
argument_list|)
operator|&&
name|buffer_packing
operator|==
literal|1
operator|)
operator|)
condition|)
comment|/* T4: disabled unless 1 */
name|fl
operator|->
name|flags
operator||=
name|FL_BUF_PACKING
expr_stmt|;
name|find_best_refill_source
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|maxp
argument_list|)
expr_stmt|;
name|find_safe_refill_source
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|init_eq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|,
name|int
name|eqtype
parameter_list|,
name|int
name|qsize
parameter_list|,
name|uint8_t
name|tx_chan
parameter_list|,
name|uint16_t
name|iqid
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|eqtype
operator|<=
name|EQ_TYPEMASK
argument_list|,
operator|(
literal|"%s: bad qtype %d"
operator|,
name|__func__
operator|,
name|eqtype
operator|)
argument_list|)
expr_stmt|;
name|eq
operator|->
name|flags
operator|=
name|eqtype
operator|&
name|EQ_TYPEMASK
expr_stmt|;
name|eq
operator|->
name|tx_chan
operator|=
name|tx_chan
expr_stmt|;
name|eq
operator|->
name|iqid
operator|=
name|iqid
expr_stmt|;
name|eq
operator|->
name|sidx
operator|=
name|qsize
operator|-
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|EQ_ESIZE
expr_stmt|;
name|strlcpy
argument_list|(
name|eq
operator|->
name|lockname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|eq
operator|->
name|lockname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_ring
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|size_t
name|len
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|tag
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|,
name|bus_addr_t
modifier|*
name|pa
parameter_list|,
name|void
modifier|*
modifier|*
name|va
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
literal|512
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot allocate DMA tag: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|bus_dmamem_alloc
argument_list|(
operator|*
name|tag
argument_list|,
name|va
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot allocate DMA memory: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
operator|*
name|va
argument_list|,
name|len
argument_list|,
name|oneseg_dma_callback
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot load DMA map: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
if|if
condition|(
name|rc
condition|)
name|free_ring
argument_list|(
name|sc
argument_list|,
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
operator|*
name|pa
argument_list|,
operator|*
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_ring
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|bus_dma_tag_t
name|tag
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|bus_addr_t
name|pa
parameter_list|,
name|void
modifier|*
name|va
parameter_list|)
block|{
if|if
condition|(
name|pa
condition|)
name|bus_dmamap_unload
argument_list|(
name|tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
condition|)
name|bus_dmamem_free
argument_list|(
name|tag
argument_list|,
name|va
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates the ring for an ingress queue and an optional freelist.  If the  * freelist is specified it will be allocated and then associated with the  * ingress queue.  *  * Returns errno on failure.  Resources allocated up to that point may still be  * allocated.  Caller is responsible for cleanup in case this function fails.  *  * If the ingress queue will take interrupts directly (iq->flags& IQ_INTR) then  * the intr_idx specifies the vector, starting from 0.  Otherwise it specifies  * the abs_id of the ingress queue to which its interrupts should be forwarded.  */
end_comment

begin_function
specifier|static
name|int
name|alloc_iq_fl
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|intr_idx
parameter_list|,
name|int
name|cong
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_params
modifier|*
name|sp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
decl_stmt|;
name|__be32
name|v
init|=
literal|0
decl_stmt|;
name|len
operator|=
name|iq
operator|->
name|qsize
operator|*
name|IQ_ESIZE
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|iq
operator|->
name|desc_tag
argument_list|,
operator|&
name|iq
operator|->
name|desc_map
argument_list|,
operator|&
name|iq
operator|->
name|ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|iq
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_IQ_CMD_ALLOC
operator||
name|F_FW_IQ_CMD_IQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special handling for firmware event queue */
if|if
condition|(
name|iq
operator|==
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
condition|)
name|v
operator||=
name|F_FW_IQ_CMD_IQASYNCH
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_INTR
condition|)
block|{
name|KASSERT
argument_list|(
name|intr_idx
operator|<
name|sc
operator|->
name|intr_count
argument_list|,
operator|(
literal|"%s: invalid direct intr_idx %d"
operator|,
name|__func__
operator|,
name|intr_idx
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|v
operator||=
name|F_FW_IQ_CMD_IQANDST
expr_stmt|;
name|v
operator||=
name|V_FW_IQ_CMD_IQANDSTINDEX
argument_list|(
name|intr_idx
argument_list|)
expr_stmt|;
name|c
operator|.
name|type_to_iqandstindex
operator|=
name|htobe32
argument_list|(
name|v
operator||
name|V_FW_IQ_CMD_TYPE
argument_list|(
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|)
operator||
name|V_FW_IQ_CMD_VIID
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
operator||
name|V_FW_IQ_CMD_IQANUD
argument_list|(
name|X_UPDATEDELIVERY_INTERRUPT
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqdroprss_to_iqesize
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_IQPCIECH
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_IQ_CMD_IQGTSMODE
operator||
name|V_FW_IQ_CMD_IQINTCNTTHRESH
argument_list|(
name|iq
operator|->
name|intr_pktc_idx
argument_list|)
operator||
name|V_FW_IQ_CMD_IQESIZE
argument_list|(
name|ilog2
argument_list|(
name|IQ_ESIZE
argument_list|)
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqsize
operator|=
name|htobe16
argument_list|(
name|iq
operator|->
name|qsize
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqaddr
operator|=
name|htobe64
argument_list|(
name|iq
operator|->
name|ba
argument_list|)
expr_stmt|;
if|if
condition|(
name|cong
operator|>=
literal|0
condition|)
name|c
operator|.
name|iqns_to_fl0congen
operator|=
name|htobe32
argument_list|(
name|F_FW_IQ_CMD_IQFLINTCONGEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
condition|)
block|{
name|mtx_init
argument_list|(
operator|&
name|fl
operator|->
name|fl_lock
argument_list|,
name|fl
operator|->
name|lockname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|len
operator|=
name|fl
operator|->
name|qsize
operator|*
name|EQ_ESIZE
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|fl
operator|->
name|desc_tag
argument_list|,
operator|&
name|fl
operator|->
name|desc_map
argument_list|,
operator|&
name|fl
operator|->
name|ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fl
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Allocate space for one software descriptor per buffer. */
name|rc
operator|=
name|alloc_fl_sdesc
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup fl software descriptors: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|)
block|{
name|fl
operator|->
name|lowat
operator|=
name|roundup2
argument_list|(
name|sp
operator|->
name|fl_starve_threshold2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fl
operator|->
name|buf_boundary
operator|=
name|sp
operator|->
name|pack_boundary
expr_stmt|;
block|}
else|else
block|{
name|fl
operator|->
name|lowat
operator|=
name|roundup2
argument_list|(
name|sp
operator|->
name|fl_starve_threshold
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fl
operator|->
name|buf_boundary
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|fl_pad
operator|&&
name|fl
operator|->
name|buf_boundary
operator|<
name|sp
operator|->
name|pad_boundary
condition|)
name|fl
operator|->
name|buf_boundary
operator|=
name|sp
operator|->
name|pad_boundary
expr_stmt|;
name|c
operator|.
name|iqns_to_fl0congen
operator||=
name|htobe32
argument_list|(
name|V_FW_IQ_CMD_FL0HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
operator||
name|F_FW_IQ_CMD_FL0FETCHRO
operator||
name|F_FW_IQ_CMD_FL0DATARO
operator||
operator|(
name|fl_pad
condition|?
name|F_FW_IQ_CMD_FL0PADEN
else|:
literal|0
operator|)
operator||
operator|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|?
name|F_FW_IQ_CMD_FL0PACKEN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cong
operator|>=
literal|0
condition|)
block|{
name|c
operator|.
name|iqns_to_fl0congen
operator||=
name|htobe32
argument_list|(
name|V_FW_IQ_CMD_FL0CNGCHMAP
argument_list|(
name|cong
argument_list|)
operator||
name|F_FW_IQ_CMD_FL0CONGCIF
operator||
name|F_FW_IQ_CMD_FL0CONGEN
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|fl0dcaen_to_fl0cidxfthresh
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_FL0FBMIN
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|X_FETCHBURSTMIN_128B
else|:
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_IQ_CMD_FL0FBMAX
argument_list|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|?
name|X_FETCHBURSTMAX_512B
else|:
name|X_FETCHBURSTMAX_256B
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0size
operator|=
name|htobe16
argument_list|(
name|fl
operator|->
name|qsize
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0addr
operator|=
name|htobe64
argument_list|(
name|fl
operator|->
name|ba
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create ingress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|iq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|gen
operator|=
name|F_RSPD_GEN
expr_stmt|;
name|iq
operator|->
name|intr_next
operator|=
name|iq
operator|->
name|intr_params
expr_stmt|;
name|iq
operator|->
name|cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|iqid
argument_list|)
expr_stmt|;
name|iq
operator|->
name|abs_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|physiqid
argument_list|)
expr_stmt|;
name|iq
operator|->
name|flags
operator||=
name|IQ_ALLOCATED
expr_stmt|;
name|cntxt_id
operator|=
name|iq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|iq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|niq
condition|)
block|{
name|panic
argument_list|(
literal|"%s: iq->cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|niq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sge
operator|.
name|iqmap
index|[
name|cntxt_id
index|]
operator|=
name|iq
expr_stmt|;
if|if
condition|(
name|fl
condition|)
block|{
name|u_int
name|qid
decl_stmt|;
name|iq
operator|->
name|flags
operator||=
name|IQ_HAS_FL
expr_stmt|;
name|fl
operator|->
name|cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|fl0id
argument_list|)
expr_stmt|;
name|fl
operator|->
name|pidx
operator|=
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|cntxt_id
operator|=
name|fl
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
block|{
name|panic
argument_list|(
literal|"%s: fl->cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|fl
expr_stmt|;
name|qid
operator|=
name|fl
operator|->
name|cntxt_id
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
condition|)
block|{
name|uint32_t
name|s_qpp
init|=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|eq_s_qpp
decl_stmt|;
name|uint32_t
name|mask
init|=
operator|(
literal|1
operator|<<
name|s_qpp
operator|)
operator|-
literal|1
decl_stmt|;
specifier|volatile
name|uint8_t
modifier|*
name|udb
decl_stmt|;
name|udb
operator|=
name|sc
operator|->
name|udbs_base
operator|+
name|UDBS_DB_OFFSET
expr_stmt|;
name|udb
operator|+=
operator|(
name|qid
operator|>>
name|s_qpp
operator|)
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|qid
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|qid
operator|<
name|PAGE_SIZE
operator|/
name|UDBS_SEG_SIZE
condition|)
block|{
name|udb
operator|+=
name|qid
operator|<<
name|UDBS_SEG_SHIFT
expr_stmt|;
name|qid
operator|=
literal|0
expr_stmt|;
block|}
name|fl
operator|->
name|udb
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|udb
expr_stmt|;
block|}
name|fl
operator|->
name|dbval
operator|=
name|V_QID
argument_list|(
name|qid
argument_list|)
operator||
name|sc
operator|->
name|chip_params
operator|->
name|sge_fl_db
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
comment|/* Enough to make sure the SGE doesn't think it's starved */
name|refill_fl
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|fl
operator|->
name|lowat
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|>=
name|CHELSIO_T5
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
operator|)
operator|&&
name|cong
operator|>=
literal|0
condition|)
block|{
name|uint32_t
name|param
decl_stmt|,
name|val
decl_stmt|;
name|param
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DMAQ
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DMAQ_CONM_CTXT
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|iq
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cong
operator|==
literal|0
condition|)
name|val
operator|=
literal|1
operator|<<
literal|19
expr_stmt|;
else|else
block|{
name|val
operator|=
literal|2
operator|<<
literal|19
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cong
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|val
operator||=
literal|1
operator|<<
operator|(
name|i
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
operator|-
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* report error but carry on */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to set congestion manager context for "
literal|"ingress queue %d: %d\n"
argument_list|,
name|iq
operator|->
name|cntxt_id
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable IQ interrupts */
name|atomic_store_rel_int
argument_list|(
operator|&
name|iq
operator|->
name|state
argument_list|,
name|IQS_IDLE
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_gts_reg
argument_list|,
name|V_SEINTARM
argument_list|(
name|iq
operator|->
name|intr_params
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|iq
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_iq_fl
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to do */
name|dev
operator|=
name|vi
condition|?
name|vi
operator|->
name|dev
else|:
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_ALLOCATED
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_iq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|,
name|iq
operator|->
name|cntxt_id
argument_list|,
name|fl
condition|?
name|fl
operator|->
name|cntxt_id
else|:
literal|0xffff
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to free queue %p: %d\n"
argument_list|,
name|iq
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|iq
operator|->
name|flags
operator|&=
operator|~
name|IQ_ALLOCATED
expr_stmt|;
block|}
name|free_ring
argument_list|(
name|sc
argument_list|,
name|iq
operator|->
name|desc_tag
argument_list|,
name|iq
operator|->
name|desc_map
argument_list|,
name|iq
operator|->
name|ba
argument_list|,
name|iq
operator|->
name|desc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|iq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
condition|)
block|{
name|free_ring
argument_list|(
name|sc
argument_list|,
name|fl
operator|->
name|desc_tag
argument_list|,
name|fl
operator|->
name|desc_map
argument_list|,
name|fl
operator|->
name|ba
argument_list|,
name|fl
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|sdesc
condition|)
name|free_fl_sdesc
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|fl
operator|->
name|fl_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|fl
operator|->
name|fl_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_fl_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|oid
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"freelist"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ba"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ba
argument_list|,
literal|"bus address of descriptor ring"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmalen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|fl
operator|->
name|sidx
operator|*
name|EQ_ESIZE
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
argument_list|,
literal|"desc ring size in bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"SGE context id of the freelist"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"padding"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|fl_pad
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|"padding enabled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"packing"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|"packing enabled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|cidx
argument_list|,
literal|0
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|)
block|{
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_offset"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|rx_offset
argument_list|,
literal|0
argument_list|,
literal|"packing rx offset"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|pidx
argument_list|,
literal|0
argument_list|,
literal|"producer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_allocated"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|mbuf_allocated
argument_list|,
literal|"# of mbuf allocated"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_inlined"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|mbuf_inlined
argument_list|,
literal|"# of mbuf inlined in clusters"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cluster_allocated"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|cl_allocated
argument_list|,
literal|"# of clusters allocated"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cluster_recycled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|cl_recycled
argument_list|,
literal|"# of clusters recycled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cluster_fast_recycled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|cl_fast_recycled
argument_list|,
literal|"# of clusters recycled (fast)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_fwq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|intr_idx
decl_stmt|;
name|struct
name|sge_iq
modifier|*
name|fwq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|init_iq
argument_list|(
name|fwq
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FW_IQ_QSIZE
argument_list|)
expr_stmt|;
name|fwq
operator|->
name|flags
operator||=
name|IQ_INTR
expr_stmt|;
comment|/* always */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
condition|)
name|intr_idx
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|intr_idx
operator|=
name|sc
operator|->
name|intr_count
operator|>
literal|1
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|fwq
operator|->
name|set_tcb_rpl
operator|=
name|t4_filter_rpl
expr_stmt|;
name|fwq
operator|->
name|l2t_write_rpl
operator|=
name|do_l2t_write_rpl
expr_stmt|;
block|}
name|rc
operator|=
name|alloc_iq_fl
argument_list|(
operator|&
name|sc
operator|->
name|port
index|[
literal|0
index|]
operator|->
name|vi
index|[
literal|0
index|]
argument_list|,
name|fwq
argument_list|,
name|NULL
argument_list|,
name|intr_idx
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create firmware event queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fwq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"firmware event queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ba"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fwq
operator|->
name|ba
argument_list|,
literal|"bus address of descriptor ring"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmalen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|fwq
operator|->
name|qsize
operator|*
name|IQ_ESIZE
argument_list|,
literal|"descriptor ring size in bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"abs_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fwq
operator|->
name|abs_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"absolute id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fwq
operator|->
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"SGE context id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fwq
operator|->
name|cidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_fwq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|free_iq_fl
argument_list|(
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_mgmtq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sge_wrq
modifier|*
name|mgmtq
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mgmtq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"management queue"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s mgmtq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|init_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|mgmtq
operator|->
name|eq
argument_list|,
name|EQ_CTRL
argument_list|,
name|CTRL_EQ_QSIZE
argument_list|,
name|sc
operator|->
name|port
index|[
literal|0
index|]
operator|->
name|tx_chan
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|fwq
operator|.
name|cntxt_id
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_wrq
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|mgmtq
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create management queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_mgmtq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|free_wrq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|mgmtq
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|tnl_cong
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|drop
parameter_list|)
block|{
if|if
condition|(
name|drop
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|drop
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|pi
operator|->
name|rx_chan_map
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_rxq
modifier|*
name|rxq
parameter_list|,
name|int
name|intr_idx
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|oid
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|rc
operator|=
name|alloc_iq_fl
argument_list|(
name|vi
argument_list|,
operator|&
name|rxq
operator|->
name|iq
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|,
name|intr_idx
argument_list|,
name|tnl_cong
argument_list|(
name|vi
operator|->
name|pi
argument_list|,
name|cong_drop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
name|sc
operator|->
name|sge
operator|.
name|iq_base
operator|=
name|rxq
operator|->
name|iq
operator|.
name|abs_id
operator|-
name|rxq
operator|->
name|iq
operator|.
name|cntxt_id
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|rxq
operator|->
name|iq
operator|.
name|cntxt_id
operator|+
name|sc
operator|->
name|sge
operator|.
name|iq_base
operator|==
name|rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|,
operator|(
literal|"iq_base mismatch"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|iq_base
operator|==
literal|0
operator|||
name|sc
operator|->
name|flags
operator|&
name|IS_VF
argument_list|,
operator|(
literal|"PF with non-zero iq_base"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The freelist is just barely above the starvation threshold right now, 	 * fill it up a bit more. 	 */
name|FL_LOCK
argument_list|(
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|rc
operator|=
name|tcp_lro_init_args
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|,
name|vi
operator|->
name|ifp
argument_list|,
name|lro_entries
argument_list|,
name|lro_mbufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|MPASS
argument_list|(
name|rxq
operator|->
name|lro
operator|.
name|ifp
operator|==
name|vi
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* also indicates LRO init'ed */
if|if
condition|(
name|vi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
name|rxq
operator|->
name|iq
operator|.
name|flags
operator||=
name|IQ_LRO_ENABLED
expr_stmt|;
endif|#
directive|endif
name|rxq
operator|->
name|ifp
operator|=
name|vi
operator|->
name|ifp
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ba"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|iq
operator|.
name|ba
argument_list|,
literal|"bus address of descriptor ring"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmalen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|rxq
operator|->
name|iq
operator|.
name|qsize
operator|*
name|IQ_ESIZE
argument_list|,
literal|"descriptor ring size in bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"abs_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"absolute id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|iq
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"SGE context id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|iq
operator|.
name|cidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|SYSCTL_ADD_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|lro
operator|.
name|lro_queued
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|lro
operator|.
name|lro_flushed
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxcsum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|rxcsum
argument_list|,
literal|"# of times hardware assisted with checksum"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vlan_extraction"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|vlan_extraction
argument_list|,
literal|"# of times hardware extracted 802.1Q tag"
argument_list|)
expr_stmt|;
name|add_fl_sysctls
argument_list|(
name|sc
argument_list|,
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|oid
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|rxq
operator|->
name|lro
operator|.
name|ifp
condition|)
block|{
name|tcp_lro_free
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|lro
operator|.
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|rc
operator|=
name|free_iq_fl
argument_list|(
name|vi
argument_list|,
operator|&
name|rxq
operator|->
name|iq
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|rxq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rxq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function
specifier|static
name|int
name|alloc_ofld_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
parameter_list|,
name|int
name|intr_idx
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|oid
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|rc
operator|=
name|alloc_iq_fl
argument_list|(
name|vi
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|fl
argument_list|,
name|intr_idx
argument_list|,
name|pi
operator|->
name|rx_chan_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ba"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
operator|.
name|ba
argument_list|,
literal|"bus address of descriptor ring"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmalen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|ofld_rxq
operator|->
name|iq
operator|.
name|qsize
operator|*
name|IQ_ESIZE
argument_list|,
literal|"descriptor ring size in bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"abs_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
operator|.
name|abs_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"absolute id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"SGE context id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
operator|.
name|cidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|add_fl_sysctls
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|oid
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_ofld_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_ofld_rxq
modifier|*
name|ofld_rxq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|free_iq_fl
argument_list|(
name|vi
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|iq
argument_list|,
operator|&
name|ofld_rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|ofld_rxq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ofld_rxq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_function
specifier|static
name|int
name|alloc_nm_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
parameter_list|,
name|int
name|intr_idx
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|oid
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|vi
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|MPASS
argument_list|(
name|na
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|vi
operator|->
name|qsize_rxq
operator|*
name|IQ_ESIZE
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|nm_rxq
operator|->
name|iq_desc_tag
argument_list|,
operator|&
name|nm_rxq
operator|->
name|iq_desc_map
argument_list|,
operator|&
name|nm_rxq
operator|->
name|iq_ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|nm_rxq
operator|->
name|iq_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|len
operator|=
name|na
operator|->
name|num_rx_desc
operator|*
name|EQ_ESIZE
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|nm_rxq
operator|->
name|fl_desc_tag
argument_list|,
operator|&
name|nm_rxq
operator|->
name|fl_desc_map
argument_list|,
operator|&
name|nm_rxq
operator|->
name|fl_ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|nm_rxq
operator|->
name|fl_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|nm_rxq
operator|->
name|vi
operator|=
name|vi
expr_stmt|;
name|nm_rxq
operator|->
name|nid
operator|=
name|idx
expr_stmt|;
name|nm_rxq
operator|->
name|iq_cidx
operator|=
literal|0
expr_stmt|;
name|nm_rxq
operator|->
name|iq_sidx
operator|=
name|vi
operator|->
name|qsize_rxq
operator|-
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|IQ_ESIZE
expr_stmt|;
name|nm_rxq
operator|->
name|iq_gen
operator|=
name|F_RSPD_GEN
expr_stmt|;
name|nm_rxq
operator|->
name|fl_pidx
operator|=
name|nm_rxq
operator|->
name|fl_cidx
operator|=
literal|0
expr_stmt|;
name|nm_rxq
operator|->
name|fl_sidx
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nm_rxq
operator|->
name|intr_idx
operator|=
name|intr_idx
expr_stmt|;
name|ctx
operator|=
operator|&
name|vi
operator|->
name|ctx
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"abs_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_rxq
operator|->
name|iq_abs_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"absolute id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_rxq
operator|->
name|iq_cntxt_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"SGE context id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_rxq
operator|->
name|iq_cidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"freelist"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_rxq
operator|->
name|fl_cntxt_id
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"SGE context id of the freelist"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_rxq
operator|->
name|fl_cidx
argument_list|,
literal|0
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_rxq
operator|->
name|fl_pidx
argument_list|,
literal|0
argument_list|,
literal|"producer index"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_nm_rxq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_rxq
modifier|*
name|nm_rxq
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|free_ring
argument_list|(
name|sc
argument_list|,
name|nm_rxq
operator|->
name|iq_desc_tag
argument_list|,
name|nm_rxq
operator|->
name|iq_desc_map
argument_list|,
name|nm_rxq
operator|->
name|iq_ba
argument_list|,
name|nm_rxq
operator|->
name|iq_desc
argument_list|)
expr_stmt|;
name|free_ring
argument_list|(
name|sc
argument_list|,
name|nm_rxq
operator|->
name|fl_desc_tag
argument_list|,
name|nm_rxq
operator|->
name|fl_desc_map
argument_list|,
name|nm_rxq
operator|->
name|fl_ba
argument_list|,
name|nm_rxq
operator|->
name|fl_desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_nm_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|,
name|int
name|iqidx
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|oid
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|vi
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|len
operator|=
name|na
operator|->
name|num_tx_desc
operator|*
name|EQ_ESIZE
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|nm_txq
operator|->
name|desc_tag
argument_list|,
operator|&
name|nm_txq
operator|->
name|desc_map
argument_list|,
operator|&
name|nm_txq
operator|->
name|ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|nm_txq
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|nm_txq
operator|->
name|pidx
operator|=
name|nm_txq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|nm_txq
operator|->
name|sidx
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|nm_txq
operator|->
name|nid
operator|=
name|idx
expr_stmt|;
name|nm_txq
operator|->
name|iqidx
operator|=
name|iqidx
expr_stmt|;
name|nm_txq
operator|->
name|cpl_ctrl0
operator|=
name|htobe32
argument_list|(
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
operator||
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|V_TXPKT_PF
argument_list|(
name|G_FW_VIID_PFN
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
operator||
name|V_TXPKT_VF
argument_list|(
name|G_FW_VIID_VIN
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
operator||
name|V_TXPKT_VF_VLD
argument_list|(
name|G_FW_VIID_VIVLD
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"netmap tx queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_txq
operator|->
name|cntxt_id
argument_list|,
literal|0
argument_list|,
literal|"SGE context id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_txq
operator|->
name|cidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_txq
operator|->
name|pidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"producer index"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_nm_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_nm_txq
modifier|*
name|nm_txq
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|free_ring
argument_list|(
name|sc
argument_list|,
name|nm_txq
operator|->
name|desc_tag
argument_list|,
name|nm_txq
operator|->
name|desc_map
argument_list|,
name|nm_txq
operator|->
name|ba
argument_list|,
name|nm_txq
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ctrl_eq_alloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|struct
name|fw_eq_ctrl_cmd
name|c
decl_stmt|;
name|int
name|qsize
init|=
name|eq
operator|->
name|sidx
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|EQ_ESIZE
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_CTRL_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_CTRL_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_EQ_CTRL_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_EQ_CTRL_CMD_ALLOC
operator||
name|F_FW_EQ_CTRL_CMD_EQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|cmpliqid_eqid
operator|=
name|htonl
argument_list|(
name|V_FW_EQ_CTRL_CMD_CMPLIQID
argument_list|(
name|eq
operator|->
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|physeqid_pkd
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c
operator|.
name|fetchszm_to_iqid
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_CTRL_CMD_HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_STATUS_PAGE
argument_list|)
operator||
name|V_FW_EQ_CTRL_CMD_PCIECHN
argument_list|(
name|eq
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_EQ_CTRL_CMD_FETCHRO
operator||
name|V_FW_EQ_CTRL_CMD_IQID
argument_list|(
name|eq
operator|->
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|dcaen_to_eqsize
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_CTRL_CMD_FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_EQ_CTRL_CMD_FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
operator||
name|V_FW_EQ_CTRL_CMD_CIDXFTHRESH
argument_list|(
name|X_CIDXFLUSHTHRESH_32
argument_list|)
operator||
name|V_FW_EQ_CTRL_CMD_EQSIZE
argument_list|(
name|qsize
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqaddr
operator|=
name|htobe64
argument_list|(
name|eq
operator|->
name|ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create control queue %d: %d\n"
argument_list|,
name|eq
operator|->
name|tx_chan
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|eq
operator|->
name|flags
operator||=
name|EQ_ALLOCATED
expr_stmt|;
name|eq
operator|->
name|cntxt_id
operator|=
name|G_FW_EQ_CTRL_CMD_EQID
argument_list|(
name|be32toh
argument_list|(
name|c
operator|.
name|cmpliqid_eqid
argument_list|)
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|eq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
name|panic
argument_list|(
literal|"%s: eq->cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
name|eq
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eth_eq_alloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|struct
name|fw_eq_eth_cmd
name|c
decl_stmt|;
name|int
name|qsize
init|=
name|eq
operator|->
name|sidx
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|EQ_ESIZE
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_ETH_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_ETH_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_EQ_ETH_CMD_ALLOC
operator||
name|F_FW_EQ_ETH_CMD_EQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|autoequiqe_to_viid
operator|=
name|htobe32
argument_list|(
name|F_FW_EQ_ETH_CMD_AUTOEQUIQE
operator||
name|F_FW_EQ_ETH_CMD_AUTOEQUEQE
operator||
name|V_FW_EQ_ETH_CMD_VIID
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fetchszm_to_iqid
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_PCIECHN
argument_list|(
name|eq
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_EQ_ETH_CMD_FETCHRO
operator||
name|V_FW_EQ_ETH_CMD_IQID
argument_list|(
name|eq
operator|->
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|dcaen_to_eqsize
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_EQSIZE
argument_list|(
name|qsize
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqaddr
operator|=
name|htobe64
argument_list|(
name|eq
operator|->
name|ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|vi
operator|->
name|dev
argument_list|,
literal|"failed to create Ethernet egress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|eq
operator|->
name|flags
operator||=
name|EQ_ALLOCATED
expr_stmt|;
name|eq
operator|->
name|cntxt_id
operator|=
name|G_FW_EQ_ETH_CMD_EQID
argument_list|(
name|be32toh
argument_list|(
name|c
operator|.
name|eqid_pkd
argument_list|)
argument_list|)
expr_stmt|;
name|eq
operator|->
name|abs_id
operator|=
name|G_FW_EQ_ETH_CMD_PHYSEQID
argument_list|(
name|be32toh
argument_list|(
name|c
operator|.
name|physeqid_pkd
argument_list|)
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|eq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
name|panic
argument_list|(
literal|"%s: eq->cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
name|eq
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function
specifier|static
name|int
name|ofld_eq_alloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|struct
name|fw_eq_ofld_cmd
name|c
decl_stmt|;
name|int
name|qsize
init|=
name|eq
operator|->
name|sidx
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|EQ_ESIZE
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htonl
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_OFLD_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_OFLD_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_EQ_OFLD_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htonl
argument_list|(
name|F_FW_EQ_OFLD_CMD_ALLOC
operator||
name|F_FW_EQ_OFLD_CMD_EQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fetchszm_to_iqid
operator|=
name|htonl
argument_list|(
name|V_FW_EQ_OFLD_CMD_HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
operator||
name|V_FW_EQ_OFLD_CMD_PCIECHN
argument_list|(
name|eq
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_EQ_OFLD_CMD_FETCHRO
operator||
name|V_FW_EQ_OFLD_CMD_IQID
argument_list|(
name|eq
operator|->
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|dcaen_to_eqsize
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_OFLD_CMD_FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_EQ_OFLD_CMD_FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
operator||
name|V_FW_EQ_OFLD_CMD_EQSIZE
argument_list|(
name|qsize
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqaddr
operator|=
name|htobe64
argument_list|(
name|eq
operator|->
name|ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|vi
operator|->
name|dev
argument_list|,
literal|"failed to create egress queue for TCP offload: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|eq
operator|->
name|flags
operator||=
name|EQ_ALLOCATED
expr_stmt|;
name|eq
operator|->
name|cntxt_id
operator|=
name|G_FW_EQ_OFLD_CMD_EQID
argument_list|(
name|be32toh
argument_list|(
name|c
operator|.
name|eqid_pkd
argument_list|)
argument_list|)
expr_stmt|;
name|cntxt_id
operator|=
name|eq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
if|if
condition|(
name|cntxt_id
operator|>=
name|sc
operator|->
name|sge
operator|.
name|neq
condition|)
name|panic
argument_list|(
literal|"%s: eq->cntxt_id (%d) more than the max (%d)"
argument_list|,
name|__func__
argument_list|,
name|cntxt_id
argument_list|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
name|eq
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|alloc_eq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|qsize
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|eq
operator|->
name|eq_lock
argument_list|,
name|eq
operator|->
name|lockname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|qsize
operator|=
name|eq
operator|->
name|sidx
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
operator|/
name|EQ_ESIZE
expr_stmt|;
name|len
operator|=
name|qsize
operator|*
name|EQ_ESIZE
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|eq
operator|->
name|desc_tag
argument_list|,
operator|&
name|eq
operator|->
name|desc_map
argument_list|,
operator|&
name|eq
operator|->
name|ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|eq
operator|->
name|pidx
operator|=
name|eq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|eq
operator|->
name|equeqidx
operator|=
name|eq
operator|->
name|dbidx
operator|=
literal|0
expr_stmt|;
name|eq
operator|->
name|doorbells
operator|=
name|sc
operator|->
name|doorbells
expr_stmt|;
switch|switch
condition|(
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
condition|)
block|{
case|case
name|EQ_CTRL
case|:
name|rc
operator|=
name|ctrl_eq_alloc
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_ETH
case|:
name|rc
operator|=
name|eth_eq_alloc
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|eq
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
case|case
name|EQ_OFLD
case|:
name|rc
operator|=
name|ofld_eq_alloc
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|eq
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: invalid eq type %d."
argument_list|,
name|__func__
argument_list|,
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate egress queue(%d): %d\n"
argument_list|,
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
operator|&
name|eq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDB
argument_list|)
operator|||
name|isset
argument_list|(
operator|&
name|eq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_UDBWC
argument_list|)
operator|||
name|isset
argument_list|(
operator|&
name|eq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
condition|)
block|{
name|uint32_t
name|s_qpp
init|=
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|eq_s_qpp
decl_stmt|;
name|uint32_t
name|mask
init|=
operator|(
literal|1
operator|<<
name|s_qpp
operator|)
operator|-
literal|1
decl_stmt|;
specifier|volatile
name|uint8_t
modifier|*
name|udb
decl_stmt|;
name|udb
operator|=
name|sc
operator|->
name|udbs_base
operator|+
name|UDBS_DB_OFFSET
expr_stmt|;
name|udb
operator|+=
operator|(
name|eq
operator|->
name|cntxt_id
operator|>>
name|s_qpp
operator|)
operator|<<
name|PAGE_SHIFT
expr_stmt|;
comment|/* pg offset */
name|eq
operator|->
name|udb_qid
operator|=
name|eq
operator|->
name|cntxt_id
operator|&
name|mask
expr_stmt|;
comment|/* id in page */
if|if
condition|(
name|eq
operator|->
name|udb_qid
operator|>=
name|PAGE_SIZE
operator|/
name|UDBS_SEG_SIZE
condition|)
name|clrbit
argument_list|(
operator|&
name|eq
operator|->
name|doorbells
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
else|else
block|{
name|udb
operator|+=
name|eq
operator|->
name|udb_qid
operator|<<
name|UDBS_SEG_SHIFT
expr_stmt|;
comment|/* seg offset */
name|eq
operator|->
name|udb_qid
operator|=
literal|0
expr_stmt|;
block|}
name|eq
operator|->
name|udb
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|udb
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_eq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|eq
operator|->
name|flags
operator|&
name|EQ_ALLOCATED
condition|)
block|{
switch|switch
condition|(
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
condition|)
block|{
case|case
name|EQ_CTRL
case|:
name|rc
operator|=
operator|-
name|t4_ctrl_eq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|eq
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_ETH
case|:
name|rc
operator|=
operator|-
name|t4_eth_eq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|eq
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
case|case
name|EQ_OFLD
case|:
name|rc
operator|=
operator|-
name|t4_ofld_eq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|eq
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: invalid eq type %d."
argument_list|,
name|__func__
argument_list|,
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to free egress queue (%d): %d\n"
argument_list|,
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|eq
operator|->
name|flags
operator|&=
operator|~
name|EQ_ALLOCATED
expr_stmt|;
block|}
name|free_ring
argument_list|(
name|sc
argument_list|,
name|eq
operator|->
name|desc_tag
argument_list|,
name|eq
operator|->
name|desc_map
argument_list|,
name|eq
operator|->
name|ba
argument_list|,
name|eq
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|eq
operator|->
name|eq_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|eq
operator|->
name|eq_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|eq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_wrq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|oid
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|vi
condition|?
operator|&
name|vi
operator|->
name|ctx
else|:
operator|&
name|sc
operator|->
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|rc
operator|=
name|alloc_eq
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
operator|&
name|wrq
operator|->
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|wrq
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|wrq
operator|->
name|wrq_tx_task
argument_list|,
literal|0
argument_list|,
name|wrq_tx_drain
argument_list|,
name|wrq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|wrq
operator|->
name|incomplete_wrs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|wrq
operator|->
name|wr_list
argument_list|)
expr_stmt|;
name|wrq
operator|->
name|nwr_pending
operator|=
literal|0
expr_stmt|;
name|wrq
operator|->
name|ndesc_needed
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ba"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|wrq
operator|->
name|eq
operator|.
name|ba
argument_list|,
literal|"bus address of descriptor ring"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmalen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|wrq
operator|->
name|eq
operator|.
name|sidx
operator|*
name|EQ_ESIZE
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
argument_list|,
literal|"desc ring size in bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|wrq
operator|->
name|eq
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
literal|"SGE context id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|wrq
operator|->
name|eq
operator|.
name|cidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|wrq
operator|->
name|eq
operator|.
name|pidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"producer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|wrq
operator|->
name|eq
operator|.
name|sidx
argument_list|,
literal|"status page index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_wrs_direct"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|wrq
operator|->
name|tx_wrs_direct
argument_list|,
literal|"# of work requests (direct)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_wrs_copied"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|wrq
operator|->
name|tx_wrs_copied
argument_list|,
literal|"# of work requests (copied)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_wrs_sspace"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|wrq
operator|->
name|tx_wrs_ss
argument_list|,
literal|"# of work requests (copied from scratch space)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_wrq
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_wrq
modifier|*
name|wrq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|free_eq
argument_list|(
name|sc
argument_list|,
operator|&
name|wrq
operator|->
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|bzero
argument_list|(
name|wrq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wrq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|oid
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|vi
operator|->
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|rc
operator|=
name|mp_ring_alloc
argument_list|(
operator|&
name|txq
operator|->
name|r
argument_list|,
name|eq
operator|->
name|sidx
argument_list|,
name|txq
argument_list|,
name|eth_tx
argument_list|,
name|can_resume_eth_tx
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate mp_ring: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|alloc_eq
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|mp_ring_free
argument_list|(
name|txq
operator|->
name|r
argument_list|)
expr_stmt|;
name|txq
operator|->
name|r
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Can't fail after this point. */
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
name|sc
operator|->
name|sge
operator|.
name|eq_base
operator|=
name|eq
operator|->
name|abs_id
operator|-
name|eq
operator|->
name|cntxt_id
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|eq
operator|->
name|cntxt_id
operator|+
name|sc
operator|->
name|sge
operator|.
name|eq_base
operator|==
name|eq
operator|->
name|abs_id
argument_list|,
operator|(
literal|"eq_base mismatch"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|eq_base
operator|==
literal|0
operator|||
name|sc
operator|->
name|flags
operator|&
name|IS_VF
argument_list|,
operator|(
literal|"PF with non-zero eq_base"
operator|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txq
operator|->
name|tx_reclaim_task
argument_list|,
literal|0
argument_list|,
name|tx_reclaim
argument_list|,
name|eq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ifp
operator|=
name|vi
operator|->
name|ifp
expr_stmt|;
name|txq
operator|->
name|gl
operator|=
name|sglist_alloc
argument_list|(
name|TX_SGL_SEGS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
condition|)
name|txq
operator|->
name|cpl_ctrl0
operator|=
name|htobe32
argument_list|(
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT_XT
argument_list|)
operator||
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|txq
operator|->
name|cpl_ctrl0
operator|=
name|htobe32
argument_list|(
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
operator||
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|V_TXPKT_PF
argument_list|(
name|G_FW_VIID_PFN
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
operator||
name|V_TXPKT_VF
argument_list|(
name|G_FW_VIID_VIN
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
operator||
name|V_TXPKT_VF_VLD
argument_list|(
name|G_FW_VIID_VIVLD
argument_list|(
name|vi
operator|->
name|viid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|txq
operator|->
name|tc_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|txq
operator|->
name|sdesc
operator|=
name|malloc
argument_list|(
name|eq
operator|->
name|sidx
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tx_sdesc
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"tx queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ba"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|eq
operator|->
name|ba
argument_list|,
literal|"bus address of descriptor ring"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmalen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|eq
operator|->
name|sidx
operator|*
name|EQ_ESIZE
operator|+
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|spg_len
argument_list|,
literal|"desc ring size in bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"abs_id"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|eq
operator|->
name|abs_id
argument_list|,
literal|0
argument_list|,
literal|"absolute id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cntxt_id"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|eq
operator|->
name|cntxt_id
argument_list|,
literal|0
argument_list|,
literal|"SGE context id of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|eq
operator|->
name|cidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pidx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|eq
operator|->
name|pidx
argument_list|,
literal|0
argument_list|,
name|sysctl_uint16
argument_list|,
literal|"I"
argument_list|,
literal|"producer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|eq
operator|->
name|sidx
argument_list|,
literal|"status page index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|vi
argument_list|,
name|idx
argument_list|,
name|sysctl_tc
argument_list|,
literal|"I"
argument_list|,
literal|"traffic class (-1 means none)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txcsum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txcsum
argument_list|,
literal|"# of times hardware assisted with checksum"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vlan_insertion"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|vlan_insertion
argument_list|,
literal|"# of times hardware inserted 802.1Q tag"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|tso_wrs
argument_list|,
literal|"# of TSO work requests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"imm_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|imm_wrs
argument_list|,
literal|"# of work requests with immediate data"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sgl_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|sgl_wrs
argument_list|,
literal|"# of work requests with direct SGL"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkt_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkt_wrs
argument_list|,
literal|"# of txpkt work requests (one pkt/WR)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkts0_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkts0_wrs
argument_list|,
literal|"# of txpkts (type 0) work requests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkts1_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkts1_wrs
argument_list|,
literal|"# of txpkts (type 1) work requests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkts0_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkts0_pkts
argument_list|,
literal|"# of frames tx'd using type0 txpkts work requests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkts1_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkts1_pkts
argument_list|,
literal|"# of frames tx'd using type1 txpkts work requests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_enqueues"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|r
operator|->
name|enqueues
argument_list|,
literal|"# of enqueues to the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_drops"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|r
operator|->
name|drops
argument_list|,
literal|"# of drops in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_starts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|r
operator|->
name|starts
argument_list|,
literal|"# of normal consumer starts in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_stalls"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|r
operator|->
name|stalls
argument_list|,
literal|"# of consumer stalls in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_restarts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|r
operator|->
name|restarts
argument_list|,
literal|"# of consumer restarts in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
operator|&
name|vi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_abdications"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|r
operator|->
name|abdications
argument_list|,
literal|"# of consumer abdications in the mp_ring for this queue"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_txq
parameter_list|(
name|struct
name|vi_info
modifier|*
name|vi
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|vi
operator|->
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|rc
operator|=
name|free_eq
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sglist_free
argument_list|(
name|txq
operator|->
name|gl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|sdesc
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|mp_ring_free
argument_list|(
name|txq
operator|->
name|r
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|txq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|oneseg_dma_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|ba
init|=
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"%s meant for single segment mappings only."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ba
operator|=
name|error
condition|?
literal|0
else|:
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ring_fl_db
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|uint32_t
name|n
decl_stmt|,
name|v
decl_stmt|;
name|n
operator|=
name|IDXDIFF
argument_list|(
name|fl
operator|->
name|pidx
operator|/
literal|8
argument_list|,
name|fl
operator|->
name|dbidx
argument_list|,
name|fl
operator|->
name|sidx
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|v
operator|=
name|fl
operator|->
name|dbval
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|udb
condition|)
operator|*
name|fl
operator|->
name|udb
operator|=
name|htole32
argument_list|(
name|v
argument_list|)
expr_stmt|;
else|else
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|IDXINCR
argument_list|(
name|fl
operator|->
name|dbidx
argument_list|,
name|n
argument_list|,
name|fl
operator|->
name|sidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fills up the freelist by allocating up to 'n' buffers.  Buffers that are  * recycled do not count towards this allocation budget.  *  * Returns non-zero to indicate that this freelist should be added to the list  * of starving freelists.  */
end_comment

begin_function
specifier|static
name|int
name|refill_fl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|__be64
modifier|*
name|d
decl_stmt|;
name|struct
name|fl_sdesc
modifier|*
name|sd
decl_stmt|;
name|uintptr_t
name|pa
decl_stmt|;
name|caddr_t
name|cl
decl_stmt|;
name|struct
name|cluster_layout
modifier|*
name|cll
decl_stmt|;
name|struct
name|sw_zone_info
modifier|*
name|swz
decl_stmt|;
name|struct
name|cluster_metadata
modifier|*
name|clm
decl_stmt|;
name|uint16_t
name|max_pidx
decl_stmt|;
name|uint16_t
name|hw_cidx
init|=
name|fl
operator|->
name|hw_cidx
decl_stmt|;
comment|/* stable snapshot */
name|FL_LOCK_ASSERT_OWNED
argument_list|(
name|fl
argument_list|)
expr_stmt|;
comment|/* 	 * We always stop at the beginning of the hardware descriptor that's just 	 * before the one with the hw cidx.  This is to avoid hw pidx = hw cidx, 	 * which would mean an empty freelist to the chip. 	 */
name|max_pidx
operator|=
name|__predict_false
argument_list|(
name|hw_cidx
operator|==
literal|0
argument_list|)
condition|?
name|fl
operator|->
name|sidx
operator|-
literal|1
else|:
name|hw_cidx
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|pidx
operator|==
name|max_pidx
operator|*
literal|8
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|d
operator|=
operator|&
name|fl
operator|->
name|desc
index|[
name|fl
operator|->
name|pidx
index|]
expr_stmt|;
name|sd
operator|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|fl
operator|->
name|pidx
index|]
expr_stmt|;
name|cll
operator|=
operator|&
name|fl
operator|->
name|cll_def
expr_stmt|;
comment|/* default layout */
name|swz
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|cll
operator|->
name|zidx
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|cl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|nmbuf
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Fast recycle without involving any atomics on 				 * the cluster's metadata (if the cluster has 				 * metadata).  This happens when all frames 				 * received in the cluster were small enough to 				 * fit within a single mbuf each. 				 */
name|fl
operator|->
name|cl_fast_recycled
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|clm
operator|=
name|cl_metadata
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
operator|&
name|sd
operator|->
name|cll
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|clm
operator|!=
name|NULL
condition|)
name|MPASS
argument_list|(
name|clm
operator|->
name|refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recycled_fast
goto|;
block|}
comment|/* 			 * Cluster is guaranteed to have metadata.  Clusters 			 * without metadata always take the fast recycle path 			 * when they're recycled. 			 */
name|clm
operator|=
name|cl_metadata
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
operator|&
name|sd
operator|->
name|cll
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|clm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|clm
operator|->
name|refcount
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fl
operator|->
name|cl_recycled
operator|++
expr_stmt|;
name|counter_u64_add
argument_list|(
name|extfree_rels
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|recycled
goto|;
block|}
name|sd
operator|->
name|cl
operator|=
name|NULL
expr_stmt|;
comment|/* gave up my reference */
block|}
name|MPASS
argument_list|(
name|sd
operator|->
name|cl
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|alloc
label|:
name|cl
operator|=
name|uma_zalloc
argument_list|(
name|swz
operator|->
name|zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cl
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|cll
operator|==
operator|&
name|fl
operator|->
name|cll_alt
operator|||
name|fl
operator|->
name|cll_alt
operator|.
name|zidx
operator|==
operator|-
literal|1
operator|||
name|fl
operator|->
name|cll_def
operator|.
name|zidx
operator|==
name|fl
operator|->
name|cll_alt
operator|.
name|zidx
condition|)
break|break;
comment|/* fall back to the safe zone */
name|cll
operator|=
operator|&
name|fl
operator|->
name|cll_alt
expr_stmt|;
name|swz
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|cll
operator|->
name|zidx
index|]
expr_stmt|;
goto|goto
name|alloc
goto|;
block|}
name|fl
operator|->
name|cl_allocated
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|pa
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|cl
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|cll
operator|->
name|region1
expr_stmt|;
name|sd
operator|->
name|cl
operator|=
name|cl
expr_stmt|;
name|sd
operator|->
name|cll
operator|=
operator|*
name|cll
expr_stmt|;
operator|*
name|d
operator|=
name|htobe64
argument_list|(
name|pa
operator||
name|cll
operator|->
name|hwidx
argument_list|)
expr_stmt|;
name|clm
operator|=
name|cl_metadata
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|cll
argument_list|,
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|clm
operator|!=
name|NULL
condition|)
block|{
name|recycled
label|:
ifdef|#
directive|ifdef
name|INVARIANTS
name|clm
operator|->
name|sd
operator|=
name|sd
expr_stmt|;
endif|#
directive|endif
name|clm
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
name|sd
operator|->
name|nmbuf
operator|=
literal|0
expr_stmt|;
name|recycled_fast
label|:
name|d
operator|++
expr_stmt|;
name|sd
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|fl
operator|->
name|pidx
operator|%
literal|8
operator|==
literal|0
argument_list|)
condition|)
block|{
name|uint16_t
name|pidx
init|=
name|fl
operator|->
name|pidx
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pidx
operator|==
name|fl
operator|->
name|sidx
argument_list|)
condition|)
block|{
name|fl
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|pidx
operator|=
literal|0
expr_stmt|;
name|sd
operator|=
name|fl
operator|->
name|sdesc
expr_stmt|;
name|d
operator|=
name|fl
operator|->
name|desc
expr_stmt|;
block|}
if|if
condition|(
name|pidx
operator|==
name|max_pidx
condition|)
break|break;
if|if
condition|(
name|IDXDIFF
argument_list|(
name|pidx
argument_list|,
name|fl
operator|->
name|dbidx
argument_list|,
name|fl
operator|->
name|sidx
argument_list|)
operator|>=
literal|4
condition|)
name|ring_fl_db
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fl
operator|->
name|pidx
operator|/
literal|8
operator|!=
name|fl
operator|->
name|dbidx
condition|)
name|ring_fl_db
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
return|return
operator|(
name|FL_RUNNING_LOW
argument_list|(
name|fl
argument_list|)
operator|&&
operator|!
operator|(
name|fl
operator|->
name|flags
operator|&
name|FL_STARVING
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to refill all starving freelists.  */
end_comment

begin_function
specifier|static
name|void
name|refill_sfl
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|sge_fl
modifier|*
name|fl
decl_stmt|,
modifier|*
name|fl_temp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|fl
argument_list|,
argument|&sc->sfl
argument_list|,
argument|link
argument_list|,
argument|fl_temp
argument_list|)
block|{
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|FL_NOT_RUNNING_LOW
argument_list|(
name|fl
argument_list|)
operator|||
name|fl
operator|->
name|flags
operator|&
name|FL_DOOMED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sfl
argument_list|,
name|fl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fl
operator|->
name|flags
operator|&=
operator|~
name|FL_STARVING
expr_stmt|;
block|}
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sfl
argument_list|)
condition|)
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_fl_sdesc
parameter_list|(
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|fl
operator|->
name|sdesc
operator|=
name|malloc
argument_list|(
name|fl
operator|->
name|sidx
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fl_sdesc
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_fl_sdesc
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|fl_sdesc
modifier|*
name|sd
decl_stmt|;
name|struct
name|cluster_metadata
modifier|*
name|clm
decl_stmt|;
name|struct
name|cluster_layout
modifier|*
name|cll
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sd
operator|=
name|fl
operator|->
name|sdesc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl
operator|->
name|sidx
operator|*
literal|8
condition|;
name|i
operator|++
operator|,
name|sd
operator|++
control|)
block|{
if|if
condition|(
name|sd
operator|->
name|cl
operator|==
name|NULL
condition|)
continue|continue;
name|cll
operator|=
operator|&
name|sd
operator|->
name|cll
expr_stmt|;
name|clm
operator|=
name|cl_metadata
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|,
name|cll
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|nmbuf
operator|==
literal|0
condition|)
name|uma_zfree
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|cll
operator|->
name|zidx
index|]
operator|.
name|zone
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|clm
operator|&&
name|atomic_fetchadd_int
argument_list|(
operator|&
name|clm
operator|->
name|refcount
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|uma_zfree
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|cll
operator|->
name|zidx
index|]
operator|.
name|zone
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|extfree_rels
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sd
operator|->
name|cl
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|fl
operator|->
name|sdesc
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|fl
operator|->
name|sdesc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|get_pkt_gl
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sglist
modifier|*
name|gl
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sglist_reset
argument_list|(
name|gl
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sglist_append_mbuf
argument_list|(
name|gl
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: mbuf %p (%d segs) was vetted earlier but now fails "
literal|"with %d."
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|mbuf_nsegs
argument_list|(
name|m
argument_list|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|gl
operator|->
name|sg_nseg
operator|==
name|mbuf_nsegs
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"%s: nsegs changed for mbuf %p from %d to %d"
operator|,
name|__func__
operator|,
name|m
operator|,
name|mbuf_nsegs
argument_list|(
name|m
argument_list|)
operator|,
name|gl
operator|->
name|sg_nseg
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|gl
operator|->
name|sg_nseg
operator|>
literal|0
operator|&&
name|gl
operator|->
name|sg_nseg
operator|<=
operator|(
name|needs_tso
argument_list|(
name|m
argument_list|)
condition|?
name|TX_SGL_SEGS_TSO
else|:
name|TX_SGL_SEGS
operator|)
argument_list|,
operator|(
literal|"%s: %d segments, should have been 1<= nsegs<= %d"
operator|,
name|__func__
operator|,
name|gl
operator|->
name|sg_nseg
operator|,
name|needs_tso
argument_list|(
name|m
argument_list|)
condition|?
name|TX_SGL_SEGS_TSO
else|:
name|TX_SGL_SEGS
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * len16 for a txpkt WR with a GL.  Includes the firmware work request header.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int
name|txpkt_len16
parameter_list|(
name|u_int
name|nsegs
parameter_list|,
name|u_int
name|tso
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|MPASS
argument_list|(
name|nsegs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nsegs
operator|--
expr_stmt|;
comment|/* first segment is part of ulptx_sgl */
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fw_eth_tx_pkt_wr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_sgl
argument_list|)
operator|+
literal|8
operator|*
operator|(
operator|(
literal|3
operator|*
name|nsegs
operator|)
operator|/
literal|2
operator|+
operator|(
name|nsegs
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|tso
condition|)
name|n
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_lso_core
argument_list|)
expr_stmt|;
return|return
operator|(
name|howmany
argument_list|(
name|n
argument_list|,
literal|16
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * len16 for a txpkt_vm WR with a GL.  Includes the firmware work  * request header.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int
name|txpkt_vm_len16
parameter_list|(
name|u_int
name|nsegs
parameter_list|,
name|u_int
name|tso
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|MPASS
argument_list|(
name|nsegs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nsegs
operator|--
expr_stmt|;
comment|/* first segment is part of ulptx_sgl */
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fw_eth_tx_pkt_vm_wr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_sgl
argument_list|)
operator|+
literal|8
operator|*
operator|(
operator|(
literal|3
operator|*
name|nsegs
operator|)
operator|/
literal|2
operator|+
operator|(
name|nsegs
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|tso
condition|)
name|n
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_lso_core
argument_list|)
expr_stmt|;
return|return
operator|(
name|howmany
argument_list|(
name|n
argument_list|,
literal|16
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * len16 for a txpkts type 0 WR with a GL.  Does not include the firmware work  * request header.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int
name|txpkts0_len16
parameter_list|(
name|u_int
name|nsegs
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|MPASS
argument_list|(
name|nsegs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nsegs
operator|--
expr_stmt|;
comment|/* first segment is part of ulptx_sgl */
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ulp_txpkt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_idata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_sgl
argument_list|)
operator|+
literal|8
operator|*
operator|(
operator|(
literal|3
operator|*
name|nsegs
operator|)
operator|/
literal|2
operator|+
operator|(
name|nsegs
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|howmany
argument_list|(
name|n
argument_list|,
literal|16
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * len16 for a txpkts type 1 WR with a GL.  Does not include the firmware work  * request header.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int
name|txpkts1_len16
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ulptx_sgl
argument_list|)
expr_stmt|;
return|return
operator|(
name|howmany
argument_list|(
name|n
argument_list|,
literal|16
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_int
name|imm_payload
parameter_list|(
name|u_int
name|ndesc
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|n
operator|=
name|ndesc
operator|*
name|EQ_ESIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|fw_eth_tx_pkt_wr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a VM txpkt WR for this packet to the hardware descriptors, update the  * software descriptor, and advance the pidx.  It is guaranteed that enough  * descriptors are available.  *  * The return value is the # of hardware descriptors used.  */
end_comment

begin_function
specifier|static
name|u_int
name|write_txpkt_vm_wr
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|fw_eth_tx_pkt_vm_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int
name|available
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|cpl_tx_pkt_core
modifier|*
name|cpl
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
comment|/* used in many unrelated places */
name|uint64_t
name|ctrl1
decl_stmt|;
name|int
name|csum_type
decl_stmt|,
name|len16
decl_stmt|,
name|ndesc
decl_stmt|,
name|pktlen
decl_stmt|,
name|nsegs
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|available
operator|>
literal|0
operator|&&
name|available
operator|<
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
name|len16
operator|=
name|mbuf_len16
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|nsegs
operator|=
name|mbuf_nsegs
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ctrl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_tso
argument_list|(
name|m0
argument_list|)
condition|)
name|ctrl
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_lso_core
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|howmany
argument_list|(
name|len16
argument_list|,
name|EQ_ESIZE
operator|/
literal|16
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ndesc
operator|<=
name|available
argument_list|)
expr_stmt|;
comment|/* Firmware work request header */
name|MPASS
argument_list|(
name|wr
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
argument_list|)
expr_stmt|;
name|wr
operator|->
name|op_immdlen
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKT_VM_WR
argument_list|)
operator||
name|V_FW_ETH_TX_PKT_WR_IMMDLEN
argument_list|(
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|V_FW_WR_LEN16
argument_list|(
name|len16
argument_list|)
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|wr
operator|->
name|r3
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|wr
operator|->
name|r3
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Copy over ethmacdst, ethmacsrc, ethtype, and vlantci. 	 * vlantci is ignored unless the ethtype is 0x8100, so it's 	 * simpler to always copy it rather than making it 	 * conditional.  Also, it seems that we do not have to set 	 * vlantci or fake the ethtype when doing VLAN tag insertion. 	 */
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
literal|2
argument_list|,
name|wr
operator|->
name|ethmacdst
argument_list|)
expr_stmt|;
name|csum_type
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|needs_tso
argument_list|(
name|m0
argument_list|)
condition|)
block|{
name|struct
name|cpl_tx_pkt_lso_core
modifier|*
name|lso
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|>
literal|0
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|>
literal|0
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|l4hlen
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: mbuf %p needs TSO but missing header lengths"
operator|,
name|__func__
operator|,
name|m0
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|V_LSO_OPCODE
argument_list|(
name|CPL_TX_PKT_LSO
argument_list|)
operator||
name|F_LSO_FIRST_SLICE
operator||
name|F_LSO_LAST_SLICE
operator||
name|V_LSO_IPHDR_LEN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|>>
literal|2
argument_list|)
operator||
name|V_LSO_TCPHDR_LEN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l4hlen
operator|>>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
condition|)
name|ctrl
operator||=
name|V_LSO_ETHHDR_LEN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
name|ctrl
operator||=
name|F_LSO_IPV6
expr_stmt|;
name|lso
operator|->
name|lso_ctrl
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|lso
operator|->
name|ipid_ofst
operator|=
name|htobe16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lso
operator|->
name|mss
operator|=
name|htobe16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|lso
operator|->
name|seqno_offset
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lso
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
name|csum_type
operator|=
name|TX_CSUM_TCPIP6
expr_stmt|;
else|else
name|csum_type
operator|=
name|TX_CSUM_TCPIP
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|lso
operator|+
literal|1
operator|)
expr_stmt|;
name|txq
operator|->
name|tso_wrs
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_TCP
condition|)
name|csum_type
operator|=
name|TX_CSUM_TCPIP
expr_stmt|;
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_UDP
condition|)
name|csum_type
operator|=
name|TX_CSUM_UDPIP
expr_stmt|;
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP6_TCP
condition|)
name|csum_type
operator|=
name|TX_CSUM_TCPIP6
expr_stmt|;
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP6_UDP
condition|)
name|csum_type
operator|=
name|TX_CSUM_UDPIP6
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
comment|/* 			 * XXX: The firmware appears to stomp on the 			 * fragment/flags field of the IP header when 			 * using TX_CSUM_IP.  Fall back to doing 			 * software checksums. 			 */
name|u_short
modifier|*
name|sump
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|sump
operator|=
name|m_advance
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|offset
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_sum
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sump
operator|=
name|in_cksum_skip
argument_list|(
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|+
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_IP
expr_stmt|;
block|}
endif|#
directive|endif
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Checksum offload */
name|ctrl1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needs_l3_csum
argument_list|(
name|m0
argument_list|)
operator|==
literal|0
condition|)
name|ctrl1
operator||=
name|F_TXPKT_IPCSUM_DIS
expr_stmt|;
if|if
condition|(
name|csum_type
operator|>=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|>
literal|0
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: mbuf %p needs checksum offload but missing header lengths"
operator|,
name|__func__
operator|,
name|m0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
argument_list|(
name|sc
argument_list|)
operator|<=
name|CHELSIO_T5
condition|)
block|{
name|ctrl1
operator||=
name|V_TXPKT_ETHHDR_LEN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|-
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl1
operator||=
name|V_T6_TXPKT_ETHHDR_LEN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|-
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
block|}
name|ctrl1
operator||=
name|V_TXPKT_IPHDR_LEN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
argument_list|)
expr_stmt|;
name|ctrl1
operator||=
name|V_TXPKT_CSUM_TYPE
argument_list|(
name|csum_type
argument_list|)
expr_stmt|;
block|}
else|else
name|ctrl1
operator||=
name|F_TXPKT_L4CSUM_DIS
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_TSO
operator|)
condition|)
name|txq
operator|->
name|txcsum
operator|++
expr_stmt|;
comment|/* some hardware assistance provided */
comment|/* VLAN tag insertion */
if|if
condition|(
name|needs_vlan_insertion
argument_list|(
name|m0
argument_list|)
condition|)
block|{
name|ctrl1
operator||=
name|F_TXPKT_VLAN_VLD
operator||
name|V_TXPKT_VLAN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vlan_insertion
operator|++
expr_stmt|;
block|}
comment|/* CPL header */
name|cpl
operator|->
name|ctrl0
operator|=
name|txq
operator|->
name|cpl_ctrl0
expr_stmt|;
name|cpl
operator|->
name|pack
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|ctrl1
operator|=
name|htobe64
argument_list|(
name|ctrl1
argument_list|)
expr_stmt|;
comment|/* SGL */
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 * A packet using TSO will use up an entire descriptor for the 	 * firmware work request header, LSO CPL, and TX_PKT_XT CPL. 	 * If this descriptor is the last descriptor in the ring, wrap 	 * around to the front of the ring explicitly for the start of 	 * the sgl. 	 */
if|if
condition|(
name|dst
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
condition|)
block|{
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
literal|0
index|]
expr_stmt|;
name|write_gl_to_txd
argument_list|(
name|txq
argument_list|,
name|m0
argument_list|,
operator|&
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|write_gl_to_txd
argument_list|(
name|txq
argument_list|,
name|m0
argument_list|,
operator|&
name|dst
argument_list|,
name|eq
operator|->
name|sidx
operator|-
name|ndesc
operator|<
name|eq
operator|->
name|pidx
argument_list|)
expr_stmt|;
name|txq
operator|->
name|sgl_wrs
operator|++
expr_stmt|;
name|txq
operator|->
name|txpkt_wrs
operator|++
expr_stmt|;
name|txsd
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|txsd
operator|->
name|desc_used
operator|=
name|ndesc
expr_stmt|;
return|return
operator|(
name|ndesc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a txpkt WR for this packet to the hardware descriptors, update the  * software descriptor, and advance the pidx.  It is guaranteed that enough  * descriptors are available.  *  * The return value is the # of hardware descriptors used.  */
end_comment

begin_function
specifier|static
name|u_int
name|write_txpkt_wr
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|fw_eth_tx_pkt_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int
name|available
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|cpl_tx_pkt_core
modifier|*
name|cpl
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
comment|/* used in many unrelated places */
name|uint64_t
name|ctrl1
decl_stmt|;
name|int
name|len16
decl_stmt|,
name|ndesc
decl_stmt|,
name|pktlen
decl_stmt|,
name|nsegs
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|available
operator|>
literal|0
operator|&&
name|available
operator|<
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
name|len16
operator|=
name|mbuf_len16
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|nsegs
operator|=
name|mbuf_nsegs
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ctrl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_tso
argument_list|(
name|m0
argument_list|)
condition|)
name|ctrl
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_lso_core
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pktlen
operator|<=
name|imm_payload
argument_list|(
literal|2
argument_list|)
operator|&&
name|available
operator|>=
literal|2
condition|)
block|{
comment|/* Immediate data.  Recalculate len16 and set nsegs to 0. */
name|ctrl
operator|+=
name|pktlen
expr_stmt|;
name|len16
operator|=
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_eth_tx_pkt_wr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
operator|+
name|pktlen
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
block|}
name|ndesc
operator|=
name|howmany
argument_list|(
name|len16
argument_list|,
name|EQ_ESIZE
operator|/
literal|16
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ndesc
operator|<=
name|available
argument_list|)
expr_stmt|;
comment|/* Firmware work request header */
name|MPASS
argument_list|(
name|wr
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
argument_list|)
expr_stmt|;
name|wr
operator|->
name|op_immdlen
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKT_WR
argument_list|)
operator||
name|V_FW_ETH_TX_PKT_WR_IMMDLEN
argument_list|(
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|V_FW_WR_LEN16
argument_list|(
name|len16
argument_list|)
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|wr
operator|->
name|r3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needs_tso
argument_list|(
name|m0
argument_list|)
condition|)
block|{
name|struct
name|cpl_tx_pkt_lso_core
modifier|*
name|lso
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|>
literal|0
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|>
literal|0
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|l4hlen
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: mbuf %p needs TSO but missing header lengths"
operator|,
name|__func__
operator|,
name|m0
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|V_LSO_OPCODE
argument_list|(
name|CPL_TX_PKT_LSO
argument_list|)
operator||
name|F_LSO_FIRST_SLICE
operator||
name|F_LSO_LAST_SLICE
operator||
name|V_LSO_IPHDR_LEN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|>>
literal|2
argument_list|)
operator||
name|V_LSO_TCPHDR_LEN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l4hlen
operator|>>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l2hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
condition|)
name|ctrl
operator||=
name|V_LSO_ETHHDR_LEN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|l3hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
name|ctrl
operator||=
name|F_LSO_IPV6
expr_stmt|;
name|lso
operator|->
name|lso_ctrl
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|lso
operator|->
name|ipid_ofst
operator|=
name|htobe16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lso
operator|->
name|mss
operator|=
name|htobe16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|lso
operator|->
name|seqno_offset
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lso
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|lso
operator|+
literal|1
operator|)
expr_stmt|;
name|txq
operator|->
name|tso_wrs
operator|++
expr_stmt|;
block|}
else|else
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Checksum offload */
name|ctrl1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needs_l3_csum
argument_list|(
name|m0
argument_list|)
operator|==
literal|0
condition|)
name|ctrl1
operator||=
name|F_TXPKT_IPCSUM_DIS
expr_stmt|;
if|if
condition|(
name|needs_l4_csum
argument_list|(
name|m0
argument_list|)
operator|==
literal|0
condition|)
name|ctrl1
operator||=
name|F_TXPKT_L4CSUM_DIS
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_TSO
operator|)
condition|)
name|txq
operator|->
name|txcsum
operator|++
expr_stmt|;
comment|/* some hardware assistance provided */
comment|/* VLAN tag insertion */
if|if
condition|(
name|needs_vlan_insertion
argument_list|(
name|m0
argument_list|)
condition|)
block|{
name|ctrl1
operator||=
name|F_TXPKT_VLAN_VLD
operator||
name|V_TXPKT_VLAN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vlan_insertion
operator|++
expr_stmt|;
block|}
comment|/* CPL header */
name|cpl
operator|->
name|ctrl0
operator|=
name|txq
operator|->
name|cpl_ctrl0
expr_stmt|;
name|cpl
operator|->
name|pack
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|ctrl1
operator|=
name|htobe64
argument_list|(
name|ctrl1
argument_list|)
expr_stmt|;
comment|/* SGL */
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|>
literal|0
condition|)
block|{
name|write_gl_to_txd
argument_list|(
name|txq
argument_list|,
name|m0
argument_list|,
operator|&
name|dst
argument_list|,
name|eq
operator|->
name|sidx
operator|-
name|ndesc
operator|<
name|eq
operator|->
name|pidx
argument_list|)
expr_stmt|;
name|txq
operator|->
name|sgl_wrs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|copy_to_txd
argument_list|(
name|eq
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|&
name|dst
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|pktlen
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
name|pktlen
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d bytes left."
operator|,
name|__func__
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|txq
operator|->
name|imm_wrs
operator|++
expr_stmt|;
block|}
name|txq
operator|->
name|txpkt_wrs
operator|++
expr_stmt|;
name|txsd
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|txsd
operator|->
name|desc_used
operator|=
name|ndesc
expr_stmt|;
return|return
operator|(
name|ndesc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|try_txpkts
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|n
parameter_list|,
name|struct
name|txpkts
modifier|*
name|txp
parameter_list|,
name|u_int
name|available
parameter_list|)
block|{
name|u_int
name|needed
decl_stmt|,
name|nsegs1
decl_stmt|,
name|nsegs2
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|;
if|if
condition|(
name|cannot_use_txpkts
argument_list|(
name|m
argument_list|)
operator|||
name|cannot_use_txpkts
argument_list|(
name|n
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|nsegs1
operator|=
name|mbuf_nsegs
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|nsegs2
operator|=
name|mbuf_nsegs
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs1
operator|+
name|nsegs2
operator|==
literal|2
condition|)
block|{
name|txp
operator|->
name|wr_type
operator|=
literal|1
expr_stmt|;
name|l1
operator|=
name|l2
operator|=
name|txpkts1_len16
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|txp
operator|->
name|wr_type
operator|=
literal|0
expr_stmt|;
name|l1
operator|=
name|txpkts0_len16
argument_list|(
name|nsegs1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|txpkts0_len16
argument_list|(
name|nsegs2
argument_list|)
expr_stmt|;
block|}
name|txp
operator|->
name|len16
operator|=
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_eth_tx_pkts_wr
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|+
name|l1
operator|+
name|l2
expr_stmt|;
name|needed
operator|=
name|howmany
argument_list|(
name|txp
operator|->
name|len16
argument_list|,
name|EQ_ESIZE
operator|/
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|SGE_MAX_WR_NDESC
operator|||
name|needed
operator|>
name|available
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|txp
operator|->
name|plen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|n
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|txp
operator|->
name|plen
operator|>
literal|65535
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|txp
operator|->
name|npkt
operator|=
literal|2
expr_stmt|;
name|set_mbuf_len16
argument_list|(
name|m
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|set_mbuf_len16
argument_list|(
name|n
argument_list|,
name|l2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_to_txpkts
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|txpkts
modifier|*
name|txp
parameter_list|,
name|u_int
name|available
parameter_list|)
block|{
name|u_int
name|plen
decl_stmt|,
name|len16
decl_stmt|,
name|needed
decl_stmt|,
name|nsegs
decl_stmt|;
name|MPASS
argument_list|(
name|txp
operator|->
name|wr_type
operator|==
literal|0
operator|||
name|txp
operator|->
name|wr_type
operator|==
literal|1
argument_list|)
expr_stmt|;
name|nsegs
operator|=
name|mbuf_nsegs
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_tso
argument_list|(
name|m
argument_list|)
operator|||
operator|(
name|txp
operator|->
name|wr_type
operator|==
literal|1
operator|&&
name|nsegs
operator|!=
literal|1
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|plen
operator|=
name|txp
operator|->
name|plen
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|65535
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|txp
operator|->
name|wr_type
operator|==
literal|0
condition|)
name|len16
operator|=
name|txpkts0_len16
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
else|else
name|len16
operator|=
name|txpkts1_len16
argument_list|()
expr_stmt|;
name|needed
operator|=
name|howmany
argument_list|(
name|txp
operator|->
name|len16
operator|+
name|len16
argument_list|,
name|EQ_ESIZE
operator|/
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|SGE_MAX_WR_NDESC
operator|||
name|needed
operator|>
name|available
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|txp
operator|->
name|npkt
operator|++
expr_stmt|;
name|txp
operator|->
name|plen
operator|=
name|plen
expr_stmt|;
name|txp
operator|->
name|len16
operator|+=
name|len16
expr_stmt|;
name|set_mbuf_len16
argument_list|(
name|m
argument_list|,
name|len16
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a txpkts WR for the packets in txp to the hardware descriptors, update  * the software descriptor, and advance the pidx.  It is guaranteed that enough  * descriptors are available.  *  * The return value is the # of hardware descriptors used.  */
end_comment

begin_function
specifier|static
name|u_int
name|write_txpkts_wr
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
specifier|const
name|struct
name|txpkts
modifier|*
name|txp
parameter_list|,
name|u_int
name|available
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|cpl_tx_pkt_core
modifier|*
name|cpl
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
name|uint64_t
name|ctrl1
decl_stmt|;
name|int
name|ndesc
decl_stmt|,
name|checkwrap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
name|flitp
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|txp
operator|->
name|npkt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|txp
operator|->
name|plen
operator|<
literal|65536
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|m0
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|m0
operator|->
name|m_nextpkt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|txp
operator|->
name|len16
operator|<=
name|howmany
argument_list|(
name|SGE_MAX_WR_LEN
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|available
operator|>
literal|0
operator|&&
name|available
operator|<
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|howmany
argument_list|(
name|txp
operator|->
name|len16
argument_list|,
name|EQ_ESIZE
operator|/
literal|16
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ndesc
operator|<=
name|available
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wr
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
argument_list|)
expr_stmt|;
name|wr
operator|->
name|op_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKTS_WR
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|V_FW_WR_LEN16
argument_list|(
name|txp
operator|->
name|len16
argument_list|)
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|wr
operator|->
name|plen
operator|=
name|htobe16
argument_list|(
name|txp
operator|->
name|plen
argument_list|)
expr_stmt|;
name|wr
operator|->
name|npkt
operator|=
name|txp
operator|->
name|npkt
expr_stmt|;
name|wr
operator|->
name|r3
operator|=
literal|0
expr_stmt|;
name|wr
operator|->
name|type
operator|=
name|txp
operator|->
name|wr_type
expr_stmt|;
name|flitp
operator|=
name|wr
operator|+
literal|1
expr_stmt|;
comment|/* 	 * At this point we are 16B into a hardware descriptor.  If checkwrap is 	 * set then we know the WR is going to wrap around somewhere.  We'll 	 * check for that at appropriate points. 	 */
name|checkwrap
operator|=
name|eq
operator|->
name|sidx
operator|-
name|ndesc
operator|<
name|eq
operator|->
name|pidx
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|wr_type
operator|==
literal|0
condition|)
block|{
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
decl_stmt|;
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
comment|/* ULP master command */
name|ulpmc
operator|=
name|flitp
expr_stmt|;
name|ulpmc
operator|->
name|cmd_dest
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_PKT
argument_list|)
operator||
name|V_ULP_TXPKT_DEST
argument_list|(
literal|0
argument_list|)
operator||
name|V_ULP_TXPKT_FID
argument_list|(
name|eq
operator|->
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|mbuf_len16
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ULP subcommand */
name|ulpsc
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_IMM
argument_list|)
operator||
name|F_ULP_TX_SC_MORE
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
argument_list|)
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ulpsc
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|checkwrap
operator|&&
operator|(
name|uintptr_t
operator|)
name|cpl
operator|==
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
condition|)
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
literal|0
index|]
expr_stmt|;
name|txq
operator|->
name|txpkts0_pkts
operator|+=
name|txp
operator|->
name|npkt
expr_stmt|;
name|txq
operator|->
name|txpkts0_wrs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cpl
operator|=
name|flitp
expr_stmt|;
name|txq
operator|->
name|txpkts1_pkts
operator|+=
name|txp
operator|->
name|npkt
expr_stmt|;
name|txq
operator|->
name|txpkts1_wrs
operator|++
expr_stmt|;
block|}
comment|/* Checksum offload */
name|ctrl1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needs_l3_csum
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
name|ctrl1
operator||=
name|F_TXPKT_IPCSUM_DIS
expr_stmt|;
if|if
condition|(
name|needs_l4_csum
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
name|ctrl1
operator||=
name|F_TXPKT_L4CSUM_DIS
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_TSO
operator|)
condition|)
name|txq
operator|->
name|txcsum
operator|++
expr_stmt|;
comment|/* some hardware assistance provided */
comment|/* VLAN tag insertion */
if|if
condition|(
name|needs_vlan_insertion
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|ctrl1
operator||=
name|F_TXPKT_VLAN_VLD
operator||
name|V_TXPKT_VLAN
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vlan_insertion
operator|++
expr_stmt|;
block|}
comment|/* CPL header */
name|cpl
operator|->
name|ctrl0
operator|=
name|txq
operator|->
name|cpl_ctrl0
expr_stmt|;
name|cpl
operator|->
name|pack
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|ctrl1
operator|=
name|htobe64
argument_list|(
name|ctrl1
argument_list|)
expr_stmt|;
name|flitp
operator|=
name|cpl
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|checkwrap
operator|&&
operator|(
name|uintptr_t
operator|)
name|flitp
operator|==
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
condition|)
name|flitp
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
literal|0
index|]
expr_stmt|;
name|write_gl_to_txd
argument_list|(
name|txq
argument_list|,
name|m
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
operator|(
operator|&
name|flitp
operator|)
argument_list|,
name|checkwrap
argument_list|)
expr_stmt|;
block|}
name|txsd
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|txsd
operator|->
name|desc_used
operator|=
name|ndesc
expr_stmt|;
return|return
operator|(
name|ndesc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the SGL ends on an address that is not 16 byte aligned, this function will  * add a 0 filled flit at the end.  */
end_comment

begin_function
specifier|static
name|void
name|write_gl_to_txd
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|caddr_t
modifier|*
name|to
parameter_list|,
name|int
name|checkwrap
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|sglist
modifier|*
name|gl
init|=
name|txq
operator|->
name|gl
decl_stmt|;
name|struct
name|sglist_seg
modifier|*
name|seg
decl_stmt|;
name|__be64
modifier|*
name|flitp
decl_stmt|,
modifier|*
name|wrap
decl_stmt|;
name|struct
name|ulptx_sgl
modifier|*
name|usgl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nflits
decl_stmt|,
name|nsegs
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: SGL must start at a 16 byte boundary: %p"
operator|,
name|__func__
operator|,
operator|*
name|to
operator|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|>=
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|<
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
argument_list|)
expr_stmt|;
name|get_pkt_gl
argument_list|(
name|m
argument_list|,
name|gl
argument_list|)
expr_stmt|;
name|nsegs
operator|=
name|gl
operator|->
name|sg_nseg
expr_stmt|;
name|MPASS
argument_list|(
name|nsegs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nflits
operator|=
operator|(
literal|3
operator|*
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|/
literal|2
operator|+
operator|(
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
name|flitp
operator|=
operator|(
name|__be64
operator|*
operator|)
operator|(
operator|*
name|to
operator|)
expr_stmt|;
name|wrap
operator|=
operator|(
name|__be64
operator|*
operator|)
operator|(
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
operator|)
expr_stmt|;
name|seg
operator|=
operator|&
name|gl
operator|->
name|sg_segs
index|[
literal|0
index|]
expr_stmt|;
name|usgl
operator|=
operator|(
name|void
operator|*
operator|)
name|flitp
expr_stmt|;
comment|/* 	 * We start at a 16 byte boundary somewhere inside the tx descriptor 	 * ring, so we're at least 16 bytes away from the status page.  There is 	 * no chance of a wrap around in the middle of usgl (which is 16 bytes). 	 */
name|usgl
operator|->
name|cmd_nsge
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_DSGL
argument_list|)
operator||
name|V_ULPTX_NSGE
argument_list|(
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|len0
operator|=
name|htobe32
argument_list|(
name|seg
operator|->
name|ss_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|addr0
operator|=
name|htobe64
argument_list|(
name|seg
operator|->
name|ss_paddr
argument_list|)
expr_stmt|;
name|seg
operator|++
expr_stmt|;
if|if
condition|(
name|checkwrap
operator|==
literal|0
operator|||
call|(
name|uintptr_t
call|)
argument_list|(
name|flitp
operator|+
name|nflits
argument_list|)
operator|<=
operator|(
name|uintptr_t
operator|)
name|wrap
condition|)
block|{
comment|/* Won't wrap around at all */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|seg
operator|++
control|)
block|{
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|len
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|seg
operator|->
name|ss_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|addr
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|seg
operator|->
name|ss_paddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|len
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|flitp
operator|+=
name|nflits
expr_stmt|;
block|}
else|else
block|{
comment|/* Will wrap somewhere in the rest of the SGL */
comment|/* 2 flits already written, write the rest flit by flit */
name|flitp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|usgl
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nflits
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|flitp
operator|==
name|wrap
condition|)
name|flitp
operator|=
operator|(
name|void
operator|*
operator|)
name|eq
operator|->
name|desc
expr_stmt|;
operator|*
name|flitp
operator|++
operator|=
name|get_flit
argument_list|(
name|seg
argument_list|,
name|nsegs
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nflits
operator|&
literal|1
condition|)
block|{
name|MPASS
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|flitp
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|flitp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|MPASS
argument_list|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|flitp
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|flitp
operator|==
name|wrap
argument_list|)
condition|)
operator|*
name|to
operator|=
operator|(
name|void
operator|*
operator|)
name|eq
operator|->
name|desc
expr_stmt|;
else|else
operator|*
name|to
operator|=
operator|(
name|void
operator|*
operator|)
name|flitp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|copy_to_txd
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|,
name|caddr_t
name|from
parameter_list|,
name|caddr_t
modifier|*
name|to
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|MPASS
argument_list|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|>=
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|<
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|+
name|len
operator|<=
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|from
argument_list|,
operator|*
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|to
operator|)
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|int
name|portion
init|=
operator|(
name|uintptr_t
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
operator|-
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|from
argument_list|,
operator|*
name|to
argument_list|,
name|portion
argument_list|)
expr_stmt|;
name|from
operator|+=
name|portion
expr_stmt|;
name|portion
operator|=
name|len
operator|-
name|portion
expr_stmt|;
comment|/* remaining */
name|bcopy
argument_list|(
name|from
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eq
operator|->
name|desc
argument_list|,
name|portion
argument_list|)
expr_stmt|;
operator|(
operator|*
name|to
operator|)
operator|=
operator|(
name|caddr_t
operator|)
name|eq
operator|->
name|desc
operator|+
name|portion
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ring_eq_db
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|,
name|u_int
name|n
parameter_list|)
block|{
name|u_int
name|db
decl_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|db
operator|=
name|eq
operator|->
name|doorbells
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|clrbit
argument_list|(
operator|&
name|db
argument_list|,
name|DOORBELL_WCWR
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffs
argument_list|(
name|db
argument_list|)
operator|-
literal|1
condition|)
block|{
case|case
name|DOORBELL_UDB
case|:
operator|*
name|eq
operator|->
name|udb
operator|=
name|htole32
argument_list|(
name|V_QID
argument_list|(
name|eq
operator|->
name|udb_qid
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOORBELL_WCWR
case|:
block|{
specifier|volatile
name|uint64_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * Queues whose 128B doorbell segment fits in the page do not 		 * use relative qid (udb_qid is always 0).  Only queues with 		 * doorbell segments can do WCWR. 		 */
name|KASSERT
argument_list|(
name|eq
operator|->
name|udb_qid
operator|==
literal|0
operator|&&
name|n
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: inappropriate doorbell (0x%x, %d, %d) for eq %p"
operator|,
name|__func__
operator|,
name|eq
operator|->
name|doorbells
operator|,
name|n
operator|,
name|eq
operator|->
name|dbidx
operator|,
name|eq
operator|)
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|udb
operator|+
name|UDBS_WR_OFFSET
operator|-
name|UDBS_DB_OFFSET
operator|)
expr_stmt|;
name|i
operator|=
name|eq
operator|->
name|dbidx
expr_stmt|;
name|src
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|src
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|i
operator|+
literal|1
index|]
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DOORBELL_UDBWC
case|:
operator|*
name|eq
operator|->
name|udb
operator|=
name|htole32
argument_list|(
name|V_QID
argument_list|(
name|eq
operator|->
name|udb_qid
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
break|break;
case|case
name|DOORBELL_KDB
case|:
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sge_kdoorbell_reg
argument_list|,
name|V_QID
argument_list|(
name|eq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|IDXINCR
argument_list|(
name|eq
operator|->
name|dbidx
argument_list|,
name|n
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_int
name|reclaimable_tx_desc
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|uint16_t
name|hw_cidx
decl_stmt|;
name|hw_cidx
operator|=
name|read_hw_cidx
argument_list|(
name|eq
argument_list|)
expr_stmt|;
return|return
operator|(
name|IDXDIFF
argument_list|(
name|hw_cidx
argument_list|,
name|eq
operator|->
name|cidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_int
name|total_available_tx_desc
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|uint16_t
name|hw_cidx
decl_stmt|,
name|pidx
decl_stmt|;
name|hw_cidx
operator|=
name|read_hw_cidx
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|pidx
operator|=
name|eq
operator|->
name|pidx
expr_stmt|;
if|if
condition|(
name|pidx
operator|==
name|hw_cidx
condition|)
return|return
operator|(
name|eq
operator|->
name|sidx
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|IDXDIFF
argument_list|(
name|hw_cidx
argument_list|,
name|pidx
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint16_t
name|read_hw_cidx
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|sge_qstat
modifier|*
name|spg
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|sidx
index|]
decl_stmt|;
name|uint16_t
name|cidx
init|=
name|spg
operator|->
name|cidx
decl_stmt|;
comment|/* stable snapshot */
return|return
operator|(
name|be16toh
argument_list|(
name|cidx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim 'n' descriptors approximately.  */
end_comment

begin_function
specifier|static
name|u_int
name|reclaim_tx_descs
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|u_int
name|n
parameter_list|)
block|{
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|u_int
name|can_reclaim
decl_stmt|,
name|reclaimed
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reclaimed
operator|=
literal|0
expr_stmt|;
name|can_reclaim
operator|=
name|reclaimable_tx_desc
argument_list|(
name|eq
argument_list|)
expr_stmt|;
while|while
condition|(
name|can_reclaim
operator|&&
name|reclaimed
operator|<
name|n
condition|)
block|{
name|int
name|ndesc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nextpkt
decl_stmt|;
name|txsd
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|cidx
index|]
expr_stmt|;
name|ndesc
operator|=
name|txsd
operator|->
name|desc_used
expr_stmt|;
comment|/* Firmware doesn't return "partial" credits. */
name|KASSERT
argument_list|(
name|can_reclaim
operator|>=
name|ndesc
argument_list|,
operator|(
literal|"%s: unexpected number of credits: %d, %d"
operator|,
name|__func__
operator|,
name|can_reclaim
operator|,
name|ndesc
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|txsd
operator|->
name|m
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|nextpkt
control|)
block|{
name|nextpkt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|reclaimed
operator|+=
name|ndesc
expr_stmt|;
name|can_reclaim
operator|-=
name|ndesc
expr_stmt|;
name|IDXINCR
argument_list|(
name|eq
operator|->
name|cidx
argument_list|,
name|ndesc
argument_list|,
name|eq
operator|->
name|sidx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|reclaimed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tx_reclaim
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|arg
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
do|do
block|{
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|n
operator|=
name|reclaim_tx_descs
argument_list|(
name|txq
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|cidx
operator|==
name|eq
operator|->
name|pidx
condition|)
name|eq
operator|->
name|equeqidx
operator|=
name|eq
operator|->
name|pidx
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|__be64
name|get_flit
parameter_list|(
name|struct
name|sglist_seg
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|idx
operator|/
literal|3
operator|)
operator|*
literal|2
decl_stmt|;
switch|switch
condition|(
name|idx
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
block|{
name|__be64
name|rc
decl_stmt|;
name|rc
operator|=
name|htobe32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ss_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nsegs
condition|)
name|rc
operator||=
operator|(
name|uint64_t
operator|)
name|htobe32
argument_list|(
name|segs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ss_len
argument_list|)
operator|<<
literal|32
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
case|case
literal|1
case|:
return|return
operator|(
name|htobe64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ss_paddr
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|htobe64
argument_list|(
name|segs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ss_paddr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_best_refill_source
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|maxp
parameter_list|)
block|{
name|int8_t
name|zidx
decl_stmt|,
name|hwidx
decl_stmt|,
name|idx
decl_stmt|;
name|uint16_t
name|region1
decl_stmt|,
name|region3
decl_stmt|;
name|int
name|spare
decl_stmt|,
name|spare_needed
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|sw_zone_info
modifier|*
name|swz
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|hwb
decl_stmt|,
modifier|*
name|hwb_list
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Buffer Packing: Look for PAGE_SIZE or larger zone which has a bufsize 	 * large enough for the max payload and cluster metadata.  Otherwise 	 * settle for the largest bufsize that leaves enough room in the cluster 	 * for metadata. 	 * 	 * Without buffer packing: Look for the smallest zone which has a 	 * bufsize large enough for the max payload.  Settle for the largest 	 * bufsize available if there's nothing big enough for max payload. 	 */
name|spare_needed
operator|=
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|?
name|CL_METADATA_SIZE
else|:
literal|0
expr_stmt|;
name|swz
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
literal|0
index|]
expr_stmt|;
name|hwidx
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|zidx
operator|=
literal|0
init|;
name|zidx
operator|<
name|SW_ZONE_SIZES
condition|;
name|zidx
operator|++
operator|,
name|swz
operator|++
control|)
block|{
if|if
condition|(
name|swz
operator|->
name|size
operator|>
name|largest_rx_cluster
condition|)
block|{
if|if
condition|(
name|__predict_true
argument_list|(
name|hwidx
operator|!=
operator|-
literal|1
argument_list|)
condition|)
break|break;
comment|/* 			 * This is a misconfiguration.  largest_rx_cluster is 			 * preventing us from finding a refill source.  See 			 * dev.t5nex.<n>.buffer_sizes to figure out why. 			 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"largest_rx_cluster=%u leaves no"
literal|" refill source for fl %p (dma %u).  Ignored.\n"
argument_list|,
name|largest_rx_cluster
argument_list|,
name|fl
argument_list|,
name|maxp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
name|swz
operator|->
name|head_hwidx
init|;
name|idx
operator|!=
operator|-
literal|1
condition|;
name|idx
operator|=
name|hwb
operator|->
name|next
control|)
block|{
name|hwb
operator|=
operator|&
name|hwb_list
index|[
name|idx
index|]
expr_stmt|;
name|spare
operator|=
name|swz
operator|->
name|size
operator|-
name|hwb
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|spare
operator|<
name|spare_needed
condition|)
continue|continue;
name|hwidx
operator|=
name|idx
expr_stmt|;
comment|/* best option so far */
if|if
condition|(
name|hwb
operator|->
name|size
operator|>=
name|maxp
condition|)
block|{
if|if
condition|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* stop looking (not packing) */
if|if
condition|(
name|swz
operator|->
name|size
operator|>=
name|safest_rx_cluster
condition|)
goto|goto
name|done
goto|;
comment|/* stop looking (packing) */
block|}
break|break;
comment|/* keep looking, next zone */
block|}
block|}
name|done
label|:
comment|/* A usable hwidx has been located. */
name|MPASS
argument_list|(
name|hwidx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hwb
operator|=
operator|&
name|hwb_list
index|[
name|hwidx
index|]
expr_stmt|;
name|zidx
operator|=
name|hwb
operator|->
name|zidx
expr_stmt|;
name|swz
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|zidx
index|]
expr_stmt|;
name|region1
operator|=
literal|0
expr_stmt|;
name|region3
operator|=
name|swz
operator|->
name|size
operator|-
name|hwb
operator|->
name|size
expr_stmt|;
comment|/* 	 * Stay within this zone and see if there is a better match when mbuf 	 * inlining is allowed.  Remember that the hwidx's are sorted in 	 * decreasing order of size (so in increasing order of spare area). 	 */
for|for
control|(
name|idx
operator|=
name|hwidx
init|;
name|idx
operator|!=
operator|-
literal|1
condition|;
name|idx
operator|=
name|hwb
operator|->
name|next
control|)
block|{
name|hwb
operator|=
operator|&
name|hwb_list
index|[
name|idx
index|]
expr_stmt|;
name|spare
operator|=
name|swz
operator|->
name|size
operator|-
name|hwb
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|allow_mbufs_in_cluster
operator|==
literal|0
operator|||
name|hwb
operator|->
name|size
operator|<
name|maxp
condition|)
break|break;
comment|/* 		 * Do not inline mbufs if doing so would violate the pad/pack 		 * boundary alignment requirement. 		 */
if|if
condition|(
name|fl_pad
operator|&&
operator|(
name|MSIZE
operator|%
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|pad_boundary
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
operator|&&
operator|(
name|MSIZE
operator|%
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|pack_boundary
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|spare
operator|<
name|CL_METADATA_SIZE
operator|+
name|MSIZE
condition|)
continue|continue;
name|n
operator|=
operator|(
name|spare
operator|-
name|CL_METADATA_SIZE
operator|)
operator|/
name|MSIZE
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|howmany
argument_list|(
name|hwb
operator|->
name|size
argument_list|,
name|maxp
argument_list|)
condition|)
break|break;
name|hwidx
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|)
block|{
name|region1
operator|=
name|n
operator|*
name|MSIZE
expr_stmt|;
name|region3
operator|=
name|spare
operator|-
name|region1
expr_stmt|;
block|}
else|else
block|{
name|region1
operator|=
name|MSIZE
expr_stmt|;
name|region3
operator|=
name|spare
operator|-
name|region1
expr_stmt|;
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|zidx
operator|>=
literal|0
operator|&&
name|zidx
operator|<
name|SW_ZONE_SIZES
argument_list|,
operator|(
literal|"%s: bad zone %d for fl %p, maxp %d"
operator|,
name|__func__
operator|,
name|zidx
operator|,
name|fl
operator|,
name|maxp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|hwidx
operator|>=
literal|0
operator|&&
name|hwidx
operator|<=
name|SGE_FLBUF_SIZES
argument_list|,
operator|(
literal|"%s: bad hwidx %d for fl %p, maxp %d"
operator|,
name|__func__
operator|,
name|hwidx
operator|,
name|fl
operator|,
name|maxp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|region1
operator|+
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
name|hwidx
index|]
operator|.
name|size
operator|+
name|region3
operator|==
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|zidx
index|]
operator|.
name|size
argument_list|,
operator|(
literal|"%s: bad buffer layout for fl %p, maxp %d. "
literal|"cl %d; r1 %d, payload %d, r3 %d"
operator|,
name|__func__
operator|,
name|fl
operator|,
name|maxp
operator|,
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|zidx
index|]
operator|.
name|size
operator|,
name|region1
operator|,
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
name|hwidx
index|]
operator|.
name|size
operator|,
name|region3
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
operator|||
name|region1
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|region3
operator|>=
name|CL_METADATA_SIZE
argument_list|,
operator|(
literal|"%s: no room for metadata.  fl %p, maxp %d; "
literal|"cl %d; r1 %d, payload %d, r3 %d"
operator|,
name|__func__
operator|,
name|fl
operator|,
name|maxp
operator|,
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|zidx
index|]
operator|.
name|size
operator|,
name|region1
operator|,
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
name|hwidx
index|]
operator|.
name|size
operator|,
name|region3
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|region1
operator|%
name|MSIZE
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: bad mbuf region for fl %p, maxp %d. "
literal|"cl %d; r1 %d, payload %d, r3 %d"
operator|,
name|__func__
operator|,
name|fl
operator|,
name|maxp
operator|,
name|sc
operator|->
name|sge
operator|.
name|sw_zone_info
index|[
name|zidx
index|]
operator|.
name|size
operator|,
name|region1
operator|,
name|sc
operator|->
name|sge
operator|.
name|hw_buf_info
index|[
name|hwidx
index|]
operator|.
name|size
operator|,
name|region3
operator|)
argument_list|)
expr_stmt|;
block|}
name|fl
operator|->
name|cll_def
operator|.
name|zidx
operator|=
name|zidx
expr_stmt|;
name|fl
operator|->
name|cll_def
operator|.
name|hwidx
operator|=
name|hwidx
expr_stmt|;
name|fl
operator|->
name|cll_def
operator|.
name|region1
operator|=
name|region1
expr_stmt|;
name|fl
operator|->
name|cll_def
operator|.
name|region3
operator|=
name|region3
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_safe_refill_source
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|sge
modifier|*
name|s
init|=
operator|&
name|sc
operator|->
name|sge
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|hwb
decl_stmt|;
name|struct
name|sw_zone_info
modifier|*
name|swz
decl_stmt|;
name|int
name|spare
decl_stmt|;
name|int8_t
name|hwidx
decl_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|FL_BUF_PACKING
condition|)
name|hwidx
operator|=
name|s
operator|->
name|safe_hwidx2
expr_stmt|;
comment|/* with room for metadata */
elseif|else
if|if
condition|(
name|allow_mbufs_in_cluster
operator|&&
name|s
operator|->
name|safe_hwidx2
operator|!=
operator|-
literal|1
condition|)
block|{
name|hwidx
operator|=
name|s
operator|->
name|safe_hwidx2
expr_stmt|;
name|hwb
operator|=
operator|&
name|s
operator|->
name|hw_buf_info
index|[
name|hwidx
index|]
expr_stmt|;
name|swz
operator|=
operator|&
name|s
operator|->
name|sw_zone_info
index|[
name|hwb
operator|->
name|zidx
index|]
expr_stmt|;
name|spare
operator|=
name|swz
operator|->
name|size
operator|-
name|hwb
operator|->
name|size
expr_stmt|;
comment|/* no good if there isn't room for an mbuf as well */
if|if
condition|(
name|spare
operator|<
name|CL_METADATA_SIZE
operator|+
name|MSIZE
condition|)
name|hwidx
operator|=
name|s
operator|->
name|safe_hwidx1
expr_stmt|;
block|}
else|else
name|hwidx
operator|=
name|s
operator|->
name|safe_hwidx1
expr_stmt|;
if|if
condition|(
name|hwidx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No fallback source */
name|fl
operator|->
name|cll_alt
operator|.
name|hwidx
operator|=
operator|-
literal|1
expr_stmt|;
name|fl
operator|->
name|cll_alt
operator|.
name|zidx
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|hwb
operator|=
operator|&
name|s
operator|->
name|hw_buf_info
index|[
name|hwidx
index|]
expr_stmt|;
name|swz
operator|=
operator|&
name|s
operator|->
name|sw_zone_info
index|[
name|hwb
operator|->
name|zidx
index|]
expr_stmt|;
name|spare
operator|=
name|swz
operator|->
name|size
operator|-
name|hwb
operator|->
name|size
expr_stmt|;
name|fl
operator|->
name|cll_alt
operator|.
name|hwidx
operator|=
name|hwidx
expr_stmt|;
name|fl
operator|->
name|cll_alt
operator|.
name|zidx
operator|=
name|hwb
operator|->
name|zidx
expr_stmt|;
if|if
condition|(
name|allow_mbufs_in_cluster
operator|&&
operator|(
name|fl_pad
operator|==
literal|0
operator|||
operator|(
name|MSIZE
operator|%
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|pad_boundary
operator|)
operator|==
literal|0
operator|)
condition|)
name|fl
operator|->
name|cll_alt
operator|.
name|region1
operator|=
operator|(
operator|(
name|spare
operator|-
name|CL_METADATA_SIZE
operator|)
operator|/
name|MSIZE
operator|)
operator|*
name|MSIZE
expr_stmt|;
else|else
name|fl
operator|->
name|cll_alt
operator|.
name|region1
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|cll_alt
operator|.
name|region3
operator|=
name|spare
operator|-
name|fl
operator|->
name|cll_alt
operator|.
name|region1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_fl_to_sfl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|FL_DOOMED
operator|)
operator|==
literal|0
condition|)
block|{
name|fl
operator|->
name|flags
operator||=
name|FL_STARVING
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sfl
argument_list|,
name|fl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sfl_callout
argument_list|,
name|hz
operator|/
literal|5
argument_list|,
name|refill_sfl
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sfl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_wrq_egr_update
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|sge_wrq
modifier|*
name|wrq
init|=
operator|(
name|void
operator|*
operator|)
name|eq
decl_stmt|;
name|atomic_readandclear_int
argument_list|(
operator|&
name|eq
operator|->
name|equiq
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
index|[
name|eq
operator|->
name|tx_chan
index|]
argument_list|,
operator|&
name|wrq
operator|->
name|wrq_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_eth_egr_update
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|(
name|void
operator|*
operator|)
name|eq
decl_stmt|;
name|MPASS
argument_list|(
operator|(
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
operator|)
operator|==
name|EQ_ETH
argument_list|)
expr_stmt|;
name|atomic_readandclear_int
argument_list|(
operator|&
name|eq
operator|->
name|equiq
argument_list|)
expr_stmt|;
name|mp_ring_check_drainage
argument_list|(
name|txq
operator|->
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
index|[
name|eq
operator|->
name|tx_chan
index|]
argument_list|,
operator|&
name|txq
operator|->
name|tx_reclaim_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|handle_sge_egr_update
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_sge_egr_update
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|qid
init|=
name|G_EGR_QID
argument_list|(
name|ntohl
argument_list|(
name|cpl
operator|->
name|opcode_qid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge
modifier|*
name|s
init|=
operator|&
name|sc
operator|->
name|sge
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
decl_stmt|;
specifier|static
name|void
function_decl|(
modifier|*
name|h
index|[]
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
init|=
block|{
name|NULL
operator|,
function_decl|&handle_wrq_egr_update
operator|,
function_decl|&handle_eth_egr_update
operator|,
function_decl|&handle_wrq_egr_update
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: payload with opcode %02x"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eq
operator|=
name|s
operator|->
name|eqmap
index|[
name|qid
operator|-
name|s
operator|->
name|eq_start
operator|-
name|s
operator|->
name|eq_base
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
call|(
modifier|*
name|h
index|[
name|eq
operator|->
name|flags
operator|&
name|EQ_TYPEMASK
index|]
call|)
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* handle_fw_msg works for both fw4_msg and fw6_msg because this is valid */
end_comment

begin_expr_stmt
unit|CTASSERT
operator|(
name|offsetof
argument_list|(
expr|struct
name|cpl_fw4_msg
argument_list|,
name|data
argument_list|)
operator|==
expr|\
name|offsetof
argument_list|(
expr|struct
name|cpl_fw6_msg
argument_list|,
name|data
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|handle_fw_msg
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|cpl_fw6_msg
modifier|*
name|cpl
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: payload with opcode %02x"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|type
operator|==
name|FW_TYPE_RSSCPL
operator|||
name|cpl
operator|->
name|type
operator|==
name|FW6_TYPE_RSSCPL
condition|)
block|{
specifier|const
name|struct
name|rss_header
modifier|*
name|rss2
decl_stmt|;
name|rss2
operator|=
operator|(
specifier|const
expr|struct
name|rss_header
operator|*
operator|)
operator|&
name|cpl
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|t4_cpl_handler
index|[
name|rss2
operator|->
name|opcode
index|]
operator|(
name|iq
operator|,
name|rss2
operator|,
name|m
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|t4_fw_msg_handler
index|[
name|cpl
operator|->
name|type
index|]
operator|(
name|sc
operator|,
operator|&
name|cpl
operator|->
name|data
index|[
literal|0
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t4_handle_wrerr_rpl - process a FW work request error message  *	@adap: the adapter  *	@rpl: start of the FW message  */
end_comment

begin_function
specifier|static
name|int
name|t4_handle_wrerr_rpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
specifier|const
name|__be64
modifier|*
name|rpl
parameter_list|)
block|{
name|u8
name|opcode
init|=
operator|*
operator|(
specifier|const
name|u8
operator|*
operator|)
name|rpl
decl_stmt|;
specifier|const
name|struct
name|fw_error_cmd
modifier|*
name|e
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|rpl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|FW_ERROR_CMD
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Received WRERR_RPL message with opcode %#x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adap
operator|->
name|dev
argument_list|)
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: FW_ERROR (%s) "
argument_list|,
name|device_get_nameunit
argument_list|(
name|adap
operator|->
name|dev
argument_list|)
argument_list|,
name|G_FW_ERROR_CMD_FATAL
argument_list|(
name|be32toh
argument_list|(
name|e
operator|->
name|op_to_type
argument_list|)
argument_list|)
condition|?
literal|"fatal"
else|:
literal|"non-fatal"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|G_FW_ERROR_CMD_TYPE
argument_list|(
name|be32toh
argument_list|(
name|e
operator|->
name|op_to_type
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FW_ERROR_TYPE_EXCEPTION
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"exception info:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|e
operator|->
name|u
operator|.
name|exception
operator|.
name|info
argument_list|)
condition|;
name|i
operator|++
control|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%08x"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|"\t"
else|:
literal|" "
argument_list|,
name|be32toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|exception
operator|.
name|info
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_ERROR_TYPE_HWMODULE
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"HW module regaddr %08x regval %08x\n"
argument_list|,
name|be32toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|hwmodule
operator|.
name|regaddr
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|hwmodule
operator|.
name|regval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_ERROR_TYPE_WR
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WR cidx %d PF %d VF %d eqid %d hdr:\n"
argument_list|,
name|be16toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|wr
operator|.
name|cidx
argument_list|)
argument_list|,
name|G_FW_ERROR_CMD_PFN
argument_list|(
name|be16toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|wr
operator|.
name|pfn_vfn
argument_list|)
argument_list|)
argument_list|,
name|G_FW_ERROR_CMD_VFN
argument_list|(
name|be16toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|wr
operator|.
name|pfn_vfn
argument_list|)
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|wr
operator|.
name|eqid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|e
operator|->
name|u
operator|.
name|wr
operator|.
name|wrhdr
argument_list|)
condition|;
name|i
operator|++
control|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%02x"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|"\t"
else|:
literal|" "
argument_list|,
name|e
operator|->
name|u
operator|.
name|wr
operator|.
name|wrhdr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_ERROR_TYPE_ACL
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ACL cidx %d PF %d VF %d eqid %d %s"
argument_list|,
name|be16toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|acl
operator|.
name|cidx
argument_list|)
argument_list|,
name|G_FW_ERROR_CMD_PFN
argument_list|(
name|be16toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|acl
operator|.
name|pfn_vfn
argument_list|)
argument_list|)
argument_list|,
name|G_FW_ERROR_CMD_VFN
argument_list|(
name|be16toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|acl
operator|.
name|pfn_vfn
argument_list|)
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|acl
operator|.
name|eqid
argument_list|)
argument_list|,
name|G_FW_ERROR_CMD_MV
argument_list|(
name|be16toh
argument_list|(
name|e
operator|->
name|u
operator|.
name|acl
operator|.
name|mv_pkd
argument_list|)
argument_list|)
condition|?
literal|"vlanid"
else|:
literal|"MAC"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|e
operator|->
name|u
operator|.
name|acl
operator|.
name|val
argument_list|)
condition|;
name|i
operator|++
control|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" %02x"
argument_list|,
name|e
operator|->
name|u
operator|.
name|acl
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"type %#x\n"
argument_list|,
name|G_FW_ERROR_CMD_TYPE
argument_list|(
name|be32toh
argument_list|(
name|e
operator|->
name|op_to_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_uint16
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint16_t
modifier|*
name|id
init|=
name|arg1
decl_stmt|;
name|int
name|i
init|=
operator|*
name|id
decl_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_bufsizes
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sge
modifier|*
name|s
init|=
name|arg1
decl_stmt|;
name|struct
name|hw_buf_info
modifier|*
name|hwb
init|=
operator|&
name|s
operator|->
name|hw_buf_info
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|sw_zone_info
modifier|*
name|swz
init|=
operator|&
name|s
operator|->
name|sw_zone_info
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|c
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|32
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_FLBUF_SIZES
condition|;
name|i
operator|++
operator|,
name|hwb
operator|++
control|)
block|{
if|if
condition|(
name|hwb
operator|->
name|zidx
operator|>=
literal|0
operator|&&
name|swz
index|[
name|hwb
operator|->
name|zidx
index|]
operator|.
name|size
operator|<=
name|largest_rx_cluster
condition|)
name|c
operator|=
literal|'*'
expr_stmt|;
else|else
name|c
operator|=
literal|'\0'
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%u%c "
argument_list|,
name|hwb
operator|->
name|size
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_tc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|vi_info
modifier|*
name|vi
init|=
name|arg1
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|tx_cl_rl_params
modifier|*
name|tc
decl_stmt|;
name|int
name|qidx
init|=
name|arg2
decl_stmt|,
name|rc
decl_stmt|,
name|tc_idx
decl_stmt|;
name|uint32_t
name|fw_queue
decl_stmt|,
name|fw_class
decl_stmt|;
name|MPASS
argument_list|(
name|qidx
operator|>=
literal|0
operator|&&
name|qidx
operator|<
name|vi
operator|->
name|ntxq
argument_list|)
expr_stmt|;
name|pi
operator|=
name|vi
operator|->
name|pi
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|txq
index|[
name|vi
operator|->
name|first_txq
operator|+
name|qidx
index|]
expr_stmt|;
name|tc_idx
operator|=
name|txq
operator|->
name|tc_idx
expr_stmt|;
name|rc
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tc_idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IS_VF
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Note that -1 is legitimate input (it means unbind). */
if|if
condition|(
name|tc_idx
operator|<
operator|-
literal|1
operator|||
name|tc_idx
operator|>=
name|sc
operator|->
name|chip_params
operator|->
name|nsched_cls
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc_idx
operator|==
name|txq
operator|->
name|tc_idx
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* No change, nothing to do. */
goto|goto
name|done
goto|;
block|}
name|fw_queue
operator|=
name|V_FW_PARAMS_MNEM
argument_list|(
name|FW_PARAMS_MNEM_DMAQ
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_X
argument_list|(
name|FW_PARAMS_PARAM_DMAQ_EQ_SCHEDCLASS_ETH
argument_list|)
operator||
name|V_FW_PARAMS_PARAM_YZ
argument_list|(
name|txq
operator|->
name|eq
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc_idx
operator|==
operator|-
literal|1
condition|)
name|fw_class
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* Unbind. */
else|else
block|{
comment|/* 		 * Bind to a different class. 		 */
name|tc
operator|=
operator|&
name|pi
operator|->
name|sched_params
operator|->
name|cl_rl
index|[
name|tc_idx
index|]
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|flags
operator|&
name|TX_CLRL_ERROR
condition|)
block|{
comment|/* Previous attempt to set the cl-rl params failed. */
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* 			 * Ok to proceed.  Place a reference on the new class 			 * while still holding on to the reference on the 			 * previous class, if any. 			 */
name|fw_class
operator|=
name|tc_idx
expr_stmt|;
name|tc
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|begin_synchronized_op
argument_list|(
name|sc
argument_list|,
name|vi
argument_list|,
name|SLEEP_OK
operator||
name|INTR_OK
argument_list|,
literal|"t4stc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
operator|-
name|t4_set_params
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|fw_queue
argument_list|,
operator|&
name|fw_class
argument_list|)
expr_stmt|;
name|end_synchronized_op
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|txq
operator|->
name|tc_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|tc
operator|=
operator|&
name|pi
operator|->
name|sched_params
operator|->
name|cl_rl
index|[
name|txq
operator|->
name|tc_idx
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|tc
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tc
operator|->
name|refcount
operator|--
expr_stmt|;
block|}
name|txq
operator|->
name|tc_idx
operator|=
name|tc_idx
expr_stmt|;
block|}
else|else
block|{
name|tc
operator|=
operator|&
name|pi
operator|->
name|sched_params
operator|->
name|cl_rl
index|[
name|tc_idx
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|tc
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tc
operator|->
name|refcount
operator|--
expr_stmt|;
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

