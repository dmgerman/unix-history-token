begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|"common/common.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_regs_values.h"
end_include

begin_include
include|#
directive|include
file|"common/t4_msg.h"
end_include

begin_include
include|#
directive|include
file|"common/t4fw_interface.h"
end_include

begin_struct
struct|struct
name|fl_buf_info
block|{
name|int
name|size
decl_stmt|;
name|int
name|type
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Filled up by t4_sge_modload */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fl_buf_info
name|fl_buf_info
index|[
name|FL_BUF_SIZES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FL_BUF_SIZE
parameter_list|(
name|x
parameter_list|)
value|(fl_buf_info[x].size)
end_define

begin_define
define|#
directive|define
name|FL_BUF_TYPE
parameter_list|(
name|x
parameter_list|)
value|(fl_buf_info[x].type)
end_define

begin_define
define|#
directive|define
name|FL_BUF_ZONE
parameter_list|(
name|x
parameter_list|)
value|(fl_buf_info[x].zone)
end_define

begin_enum
enum|enum
block|{
name|FL_PKTSHIFT
init|=
literal|2
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|FL_ALIGN
value|min(CACHE_LINE_SIZE, 32)
end_define

begin_if
if|#
directive|if
name|CACHE_LINE_SIZE
operator|>
literal|64
end_if

begin_define
define|#
directive|define
name|SPG_LEN
value|128
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPG_LEN
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used to track coalesced tx work request */
end_comment

begin_struct
struct|struct
name|txpkts
block|{
name|uint64_t
modifier|*
name|flitp
decl_stmt|;
comment|/* ptr to flit where next pkt should start */
name|uint8_t
name|npkt
decl_stmt|;
comment|/* # of packets in this work request */
name|uint8_t
name|nflits
decl_stmt|;
comment|/* # of flits used by this work request */
name|uint16_t
name|plen
decl_stmt|;
comment|/* total payload (sum of all packets) */
block|}
struct|;
end_struct

begin_comment
comment|/* A packet's SGL.  This + m_pkthdr has all info needed for tx */
end_comment

begin_struct
struct|struct
name|sgl
block|{
name|int
name|nsegs
decl_stmt|;
comment|/* # of segments in the SGL, 0 means imm. tx */
name|int
name|nflits
decl_stmt|;
comment|/* # of flits needed for the SGL */
name|bus_dma_segment_t
name|seg
index|[
name|TX_SGL_SEGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
specifier|inline
name|void
name|init_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|iq_intr_handler_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|init_fl
parameter_list|(
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|init_txq
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_ring
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|bus_dma_tag_t
modifier|*
parameter_list|,
name|bus_dmamap_t
modifier|*
parameter_list|,
name|bus_addr_t
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_ring
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_dma_tag_t
parameter_list|,
name|bus_dmamap_t
parameter_list|,
name|bus_addr_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_iq_fl
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_iq_fl
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_rxq
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_rxq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_rxq
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_txq
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_txq
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oneseg_dma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|is_new_response
parameter_list|(
specifier|const
name|struct
name|sge_iq
modifier|*
parameter_list|,
name|struct
name|rsp_ctrl
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|iq_next
parameter_list|(
name|struct
name|sge_iq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ring_fl_db
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|refill_fl
parameter_list|(
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_fl_sdesc
parameter_list|(
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_fl_sdesc
parameter_list|(
name|struct
name|sge_fl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_eq_maps
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_eq_maps
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_fl_tag_idx
parameter_list|(
name|struct
name|sge_fl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_pkt_sgl
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|sgl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_pkt_sgl
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|sgl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_txpkt_wr
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sgl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_to_txpkts
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|txpkts
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sgl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_txpkts_wr
parameter_list|(
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|txpkts
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|write_ulp_cpl_sgl
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|struct
name|sge_txq
modifier|*
parameter_list|,
name|struct
name|txpkts
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sgl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_sgl_to_txd
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|,
name|struct
name|sgl
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|copy_to_txd
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ring_tx_db
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|reclaimable
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reclaim_tx_descs
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_eqflush_wr
parameter_list|(
name|struct
name|sge_eq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__be64
name|get_flit
parameter_list|(
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_sge_egr_update
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|struct
name|cpl_sge_egr_update
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called on MOD_LOAD and fills up fl_buf_info[].  */
end_comment

begin_function
name|void
name|t4_sge_modload
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|bufsize
index|[
name|FL_BUF_SIZES
index|]
init|=
block|{
name|MCLBYTES
block|,
if|#
directive|if
name|MJUMPAGESIZE
operator|!=
name|MCLBYTES
name|MJUMPAGESIZE
block|,
endif|#
directive|endif
name|MJUM9BYTES
block|,
name|MJUM16BYTES
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FL_BUF_SIZES
condition|;
name|i
operator|++
control|)
block|{
name|FL_BUF_SIZE
argument_list|(
name|i
argument_list|)
operator|=
name|bufsize
index|[
name|i
index|]
expr_stmt|;
name|FL_BUF_TYPE
argument_list|(
name|i
argument_list|)
operator|=
name|m_gettype
argument_list|(
name|bufsize
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FL_BUF_ZONE
argument_list|(
name|i
argument_list|)
operator|=
name|m_getzone
argument_list|(
name|bufsize
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t4_sge_init - initialize SGE  *	@sc: the adapter  *  *	Performs SGE initialization needed every time after a chip reset.  *	We do not initialize any of the queues here, instead the driver  *	top-level must request them individually.  */
end_comment

begin_function
name|void
name|t4_sge_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sge
modifier|*
name|s
init|=
operator|&
name|sc
operator|->
name|sge
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_CONTROL
argument_list|,
name|V_PKTSHIFT
argument_list|(
name|M_PKTSHIFT
argument_list|)
operator||
name|V_INGPADBOUNDARY
argument_list|(
name|M_INGPADBOUNDARY
argument_list|)
operator||
name|F_EGRSTATUSPAGESIZE
argument_list|,
name|V_INGPADBOUNDARY
argument_list|(
name|ilog2
argument_list|(
name|FL_ALIGN
argument_list|)
operator|-
literal|5
argument_list|)
operator||
name|V_PKTSHIFT
argument_list|(
name|FL_PKTSHIFT
argument_list|)
operator||
name|F_RXPKTCPLMODE
operator||
name|V_EGRSTATUSPAGESIZE
argument_list|(
name|SPG_LEN
operator|==
literal|128
argument_list|)
argument_list|)
expr_stmt|;
name|t4_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SGE_HOST_PAGE_SIZE
argument_list|,
name|V_HOSTPAGESIZEPF0
argument_list|(
name|M_HOSTPAGESIZEPF0
argument_list|)
argument_list|,
name|V_HOSTPAGESIZEPF0
argument_list|(
name|PAGE_SHIFT
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FL_BUF_SIZES
condition|;
name|i
operator|++
control|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_FL_BUFFER_SIZE0
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|,
name|FL_BUF_SIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_INGRESS_RX_THRESHOLD
argument_list|,
name|V_THRESHOLD_0
argument_list|(
name|s
operator|->
name|counter_val
index|[
literal|0
index|]
argument_list|)
operator||
name|V_THRESHOLD_1
argument_list|(
name|s
operator|->
name|counter_val
index|[
literal|1
index|]
argument_list|)
operator||
name|V_THRESHOLD_2
argument_list|(
name|s
operator|->
name|counter_val
index|[
literal|2
index|]
argument_list|)
operator||
name|V_THRESHOLD_3
argument_list|(
name|s
operator|->
name|counter_val
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_TIMER_VALUE_0_AND_1
argument_list|,
name|V_TIMERVALUE0
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|s
operator|->
name|timer_val
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator||
name|V_TIMERVALUE1
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|s
operator|->
name|timer_val
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_TIMER_VALUE_2_AND_3
argument_list|,
name|V_TIMERVALUE2
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|s
operator|->
name|timer_val
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator||
name|V_TIMERVALUE3
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|s
operator|->
name|timer_val
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SGE_TIMER_VALUE_4_AND_5
argument_list|,
name|V_TIMERVALUE4
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|s
operator|->
name|timer_val
index|[
literal|4
index|]
argument_list|)
argument_list|)
operator||
name|V_TIMERVALUE5
argument_list|(
name|us_to_core_ticks
argument_list|(
name|sc
argument_list|,
name|s
operator|->
name|timer_val
index|[
literal|5
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t4_create_dma_tag
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_SPACE_UNRESTRICTED
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create main DMA tag: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_destroy_dma_tag
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialize the firmware event queue and the forwarded interrupt  * queues, if any.  The adapter owns all these queues as they are not associated  * with any particular port.  *  * Returns errno on failure.  Resources allocated up to that point may still be  * allocated.  Caller is responsible for cleanup in case this function fails.  */
end_comment

begin_function
name|int
name|t4_setup_adapter_iqs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|sge_iq
modifier|*
name|iq
decl_stmt|,
modifier|*
name|fwq
decl_stmt|;
name|iq_intr_handler_t
modifier|*
name|handler
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fwq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|INTR_FWD
condition|)
block|{
name|iq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|fiq
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * Forwarded interrupt queues - allocate 1 if there's only 1 		 * vector available, one less than the number of vectors 		 * otherwise (the first vector is reserved for the error 		 * interrupt in that case). 		 */
name|i
operator|=
name|sc
operator|->
name|intr_count
operator|>
literal|1
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
operator|,
name|iq
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s fiq%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_iq
argument_list|(
name|iq
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|sc
operator|->
name|sge
operator|.
name|nrxq
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_iq
argument_list|(
name|iq
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create fwd intr queue %d: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|handler
operator|=
name|t4_intr_evt
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* forward fwq's interrupt to the first fiq */
block|}
else|else
block|{
name|handler
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* fwq should use vector 1 (0 is used by error) */
block|}
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s fwq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|init_iq
argument_list|(
name|fwq
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FW_IQ_QSIZE
argument_list|,
name|FW_IQ_ESIZE
argument_list|,
name|handler
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_iq
argument_list|(
name|fwq
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create firmware event queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
name|int
name|t4_teardown_adapter_iqs
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sge_iq
modifier|*
name|iq
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
expr_stmt|;
name|free_iq
argument_list|(
name|iq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|INTR_FWD
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFIQ
argument_list|(
name|sc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|iq
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|fiq
index|[
name|i
index|]
expr_stmt|;
name|free_iq
argument_list|(
name|iq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t4_setup_eth_queues
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|intr_idx
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|sysctl_ctx_init
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|oid
init|=
name|device_get_sysctl_tree
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|pi
operator|->
name|oid_rxq
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queues"
argument_list|)
expr_stmt|;
name|pi
operator|->
name|oid_txq
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"tx queues"
argument_list|)
expr_stmt|;
block|}
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s rxq%d-iq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_iq
argument_list|(
operator|&
name|rxq
operator|->
name|iq
argument_list|,
name|sc
argument_list|,
name|pi
operator|->
name|tmr_idx
argument_list|,
name|pi
operator|->
name|pktc_idx
argument_list|,
name|pi
operator|->
name|qsize_rxq
argument_list|,
name|RX_IQ_ESIZE
argument_list|,
name|sc
operator|->
name|flags
operator|&
name|INTR_FWD
condition|?
name|t4_intr_data
else|:
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s rxq%d-fl"
argument_list|,
name|device_get_nameunit
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_fl
argument_list|(
operator|&
name|rxq
operator|->
name|fl
argument_list|,
name|pi
operator|->
name|qsize_rxq
operator|/
literal|8
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|INTR_FWD
condition|)
name|intr_idx
operator|=
operator|(
name|pi
operator|->
name|first_rxq
operator|+
name|i
operator|)
operator|%
name|NFIQ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|intr_idx
operator|=
name|pi
operator|->
name|first_rxq
operator|+
name|i
operator|+
literal|2
expr_stmt|;
name|rc
operator|=
name|alloc_rxq
argument_list|(
name|pi
argument_list|,
name|rxq
argument_list|,
name|intr_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|intr_idx
operator|++
expr_stmt|;
block|}
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s txq%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|pi
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_txq
argument_list|(
name|txq
argument_list|,
name|pi
operator|->
name|qsize_txq
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_txq
argument_list|(
name|pi
argument_list|,
name|txq
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|done
label|:
if|if
condition|(
name|rc
condition|)
name|t4_teardown_eth_queues
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Idempotent  */
end_comment

begin_function
name|int
name|t4_teardown_eth_queues
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
comment|/* Do this before freeing the queues */
if|if
condition|(
name|pi
operator|->
name|oid_txq
operator|||
name|pi
operator|->
name|oid_rxq
condition|)
block|{
name|sysctl_ctx_free
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|pi
operator|->
name|oid_txq
operator|=
name|pi
operator|->
name|oid_rxq
operator|=
name|NULL
expr_stmt|;
block|}
name|for_each_txq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|txq
argument_list|)
block|{
name|free_txq
argument_list|(
name|pi
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|free_rxq
argument_list|(
name|pi
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Deals with errors and forwarded interrupts */
end_comment

begin_function
name|void
name|t4_intr_all
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|t4_intr_err
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|t4_intr_fwd
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|fiq
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deals with forwarded interrupts on the given ingress queue */
end_comment

begin_function
name|void
name|t4_intr_fwd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_iq
modifier|*
name|iq
init|=
name|arg
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|rsp_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|int
name|ndesc_pending
init|=
literal|0
decl_stmt|,
name|ndesc_total
init|=
literal|0
decl_stmt|;
name|int
name|qid
decl_stmt|;
while|while
condition|(
name|is_new_response
argument_list|(
name|iq
argument_list|,
operator|&
name|ctrl
argument_list|)
condition|)
block|{
name|rmb
argument_list|()
expr_stmt|;
comment|/* Only interrupt muxing expected on this queue */
name|KASSERT
argument_list|(
name|G_RSPD_TYPE
argument_list|(
name|ctrl
operator|->
name|u
operator|.
name|type_gen
argument_list|)
operator|==
name|X_RSPD_TYPE_INTR
argument_list|,
operator|(
literal|"unexpected event on forwarded interrupt queue: %x"
operator|,
name|G_RSPD_TYPE
argument_list|(
name|ctrl
operator|->
name|u
operator|.
name|type_gen
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|qid
operator|=
name|ntohl
argument_list|(
name|ctrl
operator|->
name|pldbuflen_qid
argument_list|)
operator|-
name|sc
operator|->
name|sge
operator|.
name|iq_start
expr_stmt|;
name|q
operator|=
name|sc
operator|->
name|sge
operator|.
name|iqmap
index|[
name|qid
index|]
expr_stmt|;
name|q
operator|->
name|handler
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ndesc_total
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|ndesc_pending
operator|>=
name|iq
operator|->
name|qsize
operator|/
literal|4
condition|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndesc_pending
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|X_TIMERREG_UPDATE_CIDX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ndesc_pending
operator|=
literal|0
expr_stmt|;
block|}
name|iq_next
argument_list|(
name|iq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndesc_total
operator|>
literal|0
condition|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndesc_pending
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
operator|(
name|u32
operator|)
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|iq
operator|->
name|intr_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Deals with error interrupts */
end_comment

begin_function
name|void
name|t4_intr_err
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_type
operator|==
literal|1
condition|)
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_PCIE_PF_CLI
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4_slow_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deals with the firmware event queue */
end_comment

begin_function
name|void
name|t4_intr_evt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_iq
modifier|*
name|iq
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|rsp_ctrl
modifier|*
name|ctrl
decl_stmt|;
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
decl_stmt|;
name|int
name|ndesc_pending
init|=
literal|0
decl_stmt|,
name|ndesc_total
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|iq
operator|==
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
argument_list|,
operator|(
literal|"%s: unexpected ingress queue"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_new_response
argument_list|(
name|iq
argument_list|,
operator|&
name|ctrl
argument_list|)
condition|)
block|{
name|rmb
argument_list|()
expr_stmt|;
name|rss
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|iq
operator|->
name|cdesc
expr_stmt|;
comment|/* Should only get CPL on this queue */
name|KASSERT
argument_list|(
name|G_RSPD_TYPE
argument_list|(
name|ctrl
operator|->
name|u
operator|.
name|type_gen
argument_list|)
operator|==
name|X_RSPD_TYPE_CPL
argument_list|,
operator|(
literal|"%s: unexpected type %d"
operator|,
name|__func__
operator|,
name|G_RSPD_TYPE
argument_list|(
name|ctrl
operator|->
name|u
operator|.
name|type_gen
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rss
operator|->
name|opcode
condition|)
block|{
case|case
name|CPL_FW4_MSG
case|:
case|case
name|CPL_FW6_MSG
case|:
block|{
specifier|const
name|struct
name|cpl_fw6_msg
modifier|*
name|cpl
decl_stmt|;
name|cpl
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|type
operator|==
name|FW6_TYPE_CMD_RPL
condition|)
name|t4_handle_fw_rpl
argument_list|(
name|sc
argument_list|,
name|cpl
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CPL_SGE_EGR_UPDATE
case|:
name|handle_sge_egr_update
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't handle CPL opcode %d."
argument_list|,
name|rss
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
name|ndesc_total
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|ndesc_pending
operator|>=
name|iq
operator|->
name|qsize
operator|/
literal|4
condition|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndesc_pending
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|X_TIMERREG_UPDATE_CIDX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ndesc_pending
operator|=
literal|0
expr_stmt|;
block|}
name|iq_next
argument_list|(
name|iq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndesc_total
operator|>
literal|0
condition|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndesc_pending
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|iq
operator|->
name|intr_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t4_intr_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_rxq
modifier|*
name|rxq
init|=
name|arg
decl_stmt|;
name|struct
name|sge_iq
modifier|*
name|iq
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|struct
name|rsp_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rxq
operator|->
name|ifp
decl_stmt|;
name|struct
name|sge_fl
modifier|*
name|fl
init|=
operator|&
name|rxq
operator|->
name|fl
decl_stmt|;
name|struct
name|fl_sdesc
modifier|*
name|sd
init|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|fl
operator|->
name|cidx
index|]
decl_stmt|,
modifier|*
name|sd_next
decl_stmt|;
specifier|const
name|struct
name|rss_header
modifier|*
name|rss
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|int
name|ndescs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxq
operator|->
name|lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|l
decl_stmt|;
endif|#
directive|endif
name|prefetch
argument_list|(
name|sd
operator|->
name|m
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
name|iq
operator|->
name|intr_next
operator|=
name|iq
operator|->
name|intr_params
expr_stmt|;
while|while
condition|(
name|is_new_response
argument_list|(
name|iq
argument_list|,
operator|&
name|ctrl
argument_list|)
condition|)
block|{
name|rmb
argument_list|()
expr_stmt|;
name|rss
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|iq
operator|->
name|cdesc
expr_stmt|;
name|i
operator|=
name|G_RSPD_TYPE
argument_list|(
name|ctrl
operator|->
name|u
operator|.
name|type_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|i
operator|==
name|X_RSPD_TYPE_CPL
argument_list|)
condition|)
block|{
comment|/* Can't be anything except an egress update */
name|KASSERT
argument_list|(
name|rss
operator|->
name|opcode
operator|==
name|CPL_SGE_EGR_UPDATE
argument_list|,
operator|(
literal|"%s: unexpected CPL %x"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|handle_sge_egr_update
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|nextdesc
goto|;
block|}
name|KASSERT
argument_list|(
name|i
operator|==
name|X_RSPD_TYPE_FLBUF
operator|&&
name|rss
operator|->
name|opcode
operator|==
name|CPL_RX_PKT
argument_list|,
operator|(
literal|"%s: unexpected CPL %x rsp %d"
operator|,
name|__func__
operator|,
name|rss
operator|->
name|opcode
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|sd_next
operator|=
name|sd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|fl
operator|->
name|cidx
operator|+
literal|1
operator|==
name|fl
operator|->
name|cap
argument_list|)
condition|)
name|sd_next
operator|=
name|fl
operator|->
name|sdesc
expr_stmt|;
name|prefetch
argument_list|(
name|sd_next
operator|->
name|m
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|sd_next
operator|->
name|cl
argument_list|)
expr_stmt|;
name|cpl
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|rss
operator|+
literal|1
operator|)
expr_stmt|;
name|m0
operator|=
name|sd
operator|->
name|m
expr_stmt|;
name|sd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* consumed */
name|len
operator|=
name|be32toh
argument_list|(
name|ctrl
operator|->
name|pldbuflen_qid
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|len
operator|&
name|F_RSPD_NEWBUF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: cannot handle packed frames"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|len
operator|=
name|G_RSPD_LEN
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|m_init
argument_list|(
name|m0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|MINCLSIZE
condition|)
block|{
comment|/* copy data to mbuf, buffer will be recycled */
name|bcopy
argument_list|(
name|sd
operator|->
name|cl
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_cljset
argument_list|(
name|m0
argument_list|,
name|sd
operator|->
name|cl
argument_list|,
name|FL_BUF_TYPE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|->
name|cl
operator|=
name|NULL
expr_stmt|;
comment|/* consumed */
name|m0
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|FL_BUF_SIZE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|FL_PKTSHIFT
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
name|FL_PKTSHIFT
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
name|FL_PKTSHIFT
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|rss
operator|->
name|hash_val
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|csum_calc
operator|&&
operator|!
name|cpl
operator|->
name|err_vec
operator|&&
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|ip_frag
condition|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|be16toh
argument_list|(
name|cpl
operator|->
name|csum
argument_list|)
expr_stmt|;
else|else
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|rxq
operator|->
name|rxcsum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cpl
operator|->
name|vlan_ex
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|be16toh
argument_list|(
name|cpl
operator|->
name|vlan
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
name|rxq
operator|->
name|vlan_extraction
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
comment|/* # of fl sdesc used */
name|sd
operator|=
name|sd_next
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|fl
operator|->
name|cidx
operator|==
name|fl
operator|->
name|cap
argument_list|)
condition|)
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|sd_next
operator|=
name|sd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|fl
operator|->
name|cidx
operator|+
literal|1
operator|==
name|fl
operator|->
name|cap
argument_list|)
condition|)
name|sd_next
operator|=
name|fl
operator|->
name|sdesc
expr_stmt|;
name|prefetch
argument_list|(
name|sd_next
operator|->
name|m
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|sd_next
operator|->
name|cl
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|sd
operator|->
name|m
expr_stmt|;
name|sd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* consumed */
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|m_init
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|MLEN
condition|)
block|{
name|bcopy
argument_list|(
name|sd
operator|->
name|cl
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_cljset
argument_list|(
name|m
argument_list|,
name|sd
operator|->
name|cl
argument_list|,
name|FL_BUF_TYPE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|->
name|cl
operator|=
name|NULL
expr_stmt|;
comment|/* consumed */
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|FL_BUF_SIZE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|sd
operator|=
name|sd_next
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|fl
operator|->
name|cidx
operator|==
name|fl
operator|->
name|cap
argument_list|)
condition|)
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|cpl
operator|->
name|l2info
operator|&
name|htobe32
argument_list|(
name|F_RXF_LRO
argument_list|)
operator|&&
name|rxq
operator|->
name|flags
operator|&
name|RXQ_LRO_ENABLED
operator|&&
name|tcp_lro_rx
argument_list|(
name|lro
argument_list|,
name|m0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* queued for LRO */
block|}
else|else
endif|#
directive|endif
name|ifp
operator|->
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|needed
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|needed
operator|>=
literal|32
condition|)
name|refill_fl
argument_list|(
name|fl
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|pending
operator|>=
literal|32
condition|)
name|ring_fl_db
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|nextdesc
label|:
name|ndescs
operator|++
expr_stmt|;
name|iq_next
argument_list|(
name|iq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndescs
operator|>
literal|32
condition|)
block|{
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndescs
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
operator|(
name|u32
operator|)
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|V_QINTR_TIMER_IDX
argument_list|(
name|X_TIMERREG_UPDATE_CIDX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ndescs
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|INET
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
condition|)
block|{
name|l
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_CIDXINC
argument_list|(
name|ndescs
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
operator|(
name|u32
operator|)
name|iq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_SEINTARM
argument_list|(
name|iq
operator|->
name|intr_next
argument_list|)
argument_list|)
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|needed
operator|>=
literal|32
condition|)
name|refill_fl
argument_list|(
name|fl
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|pending
operator|>=
literal|8
condition|)
name|ring_fl_db
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Per-packet header in a coalesced tx WR, before the SGL starts (in flits) */
end_comment

begin_define
define|#
directive|define
name|TXPKTS_PKT_HDR
value|((\     sizeof(struct ulp_txpkt) + \     sizeof(struct ulptx_idata) + \     sizeof(struct cpl_tx_pkt_core) \     ) / 8)
end_define

begin_comment
comment|/* Header of a coalesced tx WR, before SGL of first packet (in flits) */
end_comment

begin_define
define|#
directive|define
name|TXPKTS_WR_HDR
value|(\     sizeof(struct fw_eth_tx_pkts_wr) / 8 + \     TXPKTS_PKT_HDR)
end_define

begin_comment
comment|/* Header of a tx WR, before SGL of first packet (in flits) */
end_comment

begin_define
define|#
directive|define
name|TXPKT_WR_HDR
value|((\     sizeof(struct fw_eth_tx_pkt_wr) + \     sizeof(struct cpl_tx_pkt_core) \     ) / 8 )
end_define

begin_comment
comment|/* Header of a tx LSO WR, before SGL of first packet (in flits) */
end_comment

begin_define
define|#
directive|define
name|TXPKT_LSO_WR_HDR
value|((\     sizeof(struct fw_eth_tx_pkt_wr) + \     sizeof(struct cpl_tx_pkt_lso) + \     sizeof(struct cpl_tx_pkt_core) \     ) / 8 )
end_define

begin_function
name|int
name|t4_eth_tx
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|(
name|void
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
init|=
name|eq
operator|->
name|br
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|coalescing
decl_stmt|,
name|can_reclaim
decl_stmt|;
name|struct
name|txpkts
name|txpkts
decl_stmt|;
name|struct
name|sgl
name|sgl
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
argument_list|,
operator|(
literal|"%s: called with nothing to do."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|eq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
argument_list|)
expr_stmt|;
name|txpkts
operator|.
name|npkt
operator|=
literal|0
expr_stmt|;
comment|/* indicates there's nothing in txpkts */
name|coalescing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|avail
operator|<
literal|8
condition|)
name|reclaim_tx_descs
argument_list|(
name|eq
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|next
condition|?
name|next
else|:
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
control|)
block|{
if|if
condition|(
name|eq
operator|->
name|avail
operator|<
literal|8
condition|)
break|break;
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|next
operator|||
name|buf_ring_peek
argument_list|(
name|br
argument_list|)
condition|)
name|coalescing
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|get_pkt_sgl
argument_list|(
name|txq
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|sgl
argument_list|,
name|coalescing
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|ENOMEM
condition|)
block|{
comment|/* Short of resources, suspend tx */
name|m
operator|->
name|m_nextpkt
operator|=
name|next
expr_stmt|;
break|break;
block|}
comment|/* 			 * Unrecoverable error for this packet, throw it away 			 * and move on to the next.  get_pkt_sgl may already 			 * have freed m (it will be NULL in that case and the 			 * m_freem here is still safe). 			 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|coalescing
operator|&&
name|add_to_txpkts
argument_list|(
name|pi
argument_list|,
name|txq
argument_list|,
operator|&
name|txpkts
argument_list|,
name|m
argument_list|,
operator|&
name|sgl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Successfully absorbed into txpkts */
name|write_ulp_cpl_sgl
argument_list|(
name|pi
argument_list|,
name|txq
argument_list|,
operator|&
name|txpkts
argument_list|,
name|m
argument_list|,
operator|&
name|sgl
argument_list|)
expr_stmt|;
goto|goto
name|doorbell
goto|;
block|}
comment|/* 		 * We weren't coalescing to begin with, or current frame could 		 * not be coalesced (add_to_txpkts flushes txpkts if a frame 		 * given to it can't be coalesced).  Either way there should be 		 * nothing in txpkts. 		 */
name|KASSERT
argument_list|(
name|txpkts
operator|.
name|npkt
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: txpkts not empty: %d"
operator|,
name|__func__
operator|,
name|txpkts
operator|.
name|npkt
operator|)
argument_list|)
expr_stmt|;
comment|/* We're sending out individual packets now */
name|coalescing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|avail
operator|<
literal|8
condition|)
name|reclaim_tx_descs
argument_list|(
name|eq
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|rc
operator|=
name|write_txpkt_wr
argument_list|(
name|pi
argument_list|,
name|txq
argument_list|,
name|m
argument_list|,
operator|&
name|sgl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* Short of hardware descriptors, suspend tx */
comment|/* 			 * This is an unlikely but expensive failure.  We've 			 * done all the hard work (DMA mappings etc.) and now we 			 * can't send out the packet.  What's worse, we have to 			 * spend even more time freeing up everything in sgl. 			 */
name|txq
operator|->
name|no_desc
operator|++
expr_stmt|;
name|free_pkt_sgl
argument_list|(
name|txq
argument_list|,
operator|&
name|sgl
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|next
expr_stmt|;
break|break;
block|}
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgl
operator|.
name|nsegs
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|doorbell
label|:
comment|/* Fewer and fewer doorbells as the queue fills up */
if|if
condition|(
name|eq
operator|->
name|pending
operator|>=
operator|(
literal|1
operator|<<
operator|(
name|fls
argument_list|(
name|eq
operator|->
name|qsize
operator|-
name|eq
operator|->
name|avail
argument_list|)
operator|/
literal|2
operator|)
operator|)
condition|)
name|ring_tx_db
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|)
expr_stmt|;
name|can_reclaim
operator|=
name|reclaimable
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_reclaim
operator|>=
literal|32
condition|)
name|reclaim_tx_descs
argument_list|(
name|eq
argument_list|,
name|can_reclaim
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txpkts
operator|.
name|npkt
operator|>
literal|0
condition|)
name|write_txpkts_wr
argument_list|(
name|txq
argument_list|,
operator|&
name|txpkts
argument_list|)
expr_stmt|;
comment|/* 	 * m not NULL means there was an error but we haven't thrown it away. 	 * This can happen when we're short of tx descriptors (no_desc) or maybe 	 * even DMA maps (no_dmamap).  Either way, a credit flush and reclaim 	 * will get things going again. 	 * 	 * If eq->avail is already 0 we know a credit flush was requested in the 	 * WR that reduced it to 0 so we don't need another flush (we don't have 	 * any descriptor for a flush WR anyway, duh). 	 */
if|if
condition|(
name|m
operator|&&
name|eq
operator|->
name|avail
operator|>
literal|0
condition|)
name|write_eqflush_wr
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|m
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|pending
condition|)
name|ring_tx_db
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|)
expr_stmt|;
name|can_reclaim
operator|=
name|reclaimable
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_reclaim
operator|>=
literal|32
condition|)
name|reclaim_tx_descs
argument_list|(
name|eq
argument_list|,
name|can_reclaim
argument_list|,
literal|128
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t4_update_fl_bufsize
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sge_fl
modifier|*
name|fl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_rxq
argument_list|(
argument|pi
argument_list|,
argument|i
argument_list|,
argument|rxq
argument_list|)
block|{
name|fl
operator|=
operator|&
name|rxq
operator|->
name|fl
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|set_fl_tag_idx
argument_list|(
name|fl
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * A non-NULL handler indicates this iq will not receive direct interrupts, the  * handler will be invoked by a forwarded interrupt queue.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|init_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|tmr_idx
parameter_list|,
name|int
name|pktc_idx
parameter_list|,
name|int
name|qsize
parameter_list|,
name|int
name|esize
parameter_list|,
name|iq_intr_handler_t
modifier|*
name|handler
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tmr_idx
operator|>=
literal|0
operator|&&
name|tmr_idx
operator|<
name|SGE_NTIMERS
argument_list|,
operator|(
literal|"%s: bad tmr_idx %d"
operator|,
name|__func__
operator|,
name|tmr_idx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pktc_idx
operator|<
name|SGE_NCOUNTERS
argument_list|,
comment|/* -ve is ok, means don't use */
operator|(
literal|"%s: bad pktc_idx %d"
operator|,
name|__func__
operator|,
name|pktc_idx
operator|)
argument_list|)
expr_stmt|;
name|iq
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|iq
operator|->
name|intr_params
operator|=
name|V_QINTR_TIMER_IDX
argument_list|(
name|tmr_idx
argument_list|)
operator||
name|V_QINTR_CNT_EN
argument_list|(
name|pktc_idx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|iq
operator|->
name|intr_pktc_idx
operator|=
name|pktc_idx
expr_stmt|;
name|iq
operator|->
name|qsize
operator|=
name|roundup
argument_list|(
name|qsize
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* See FW_IQ_CMD/iqsize */
name|iq
operator|->
name|esize
operator|=
name|max
argument_list|(
name|esize
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* See FW_IQ_CMD/iqesize */
name|iq
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|strlcpy
argument_list|(
name|iq
operator|->
name|lockname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|iq
operator|->
name|lockname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|init_fl
parameter_list|(
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fl
operator|->
name|qsize
operator|=
name|qsize
expr_stmt|;
name|strlcpy
argument_list|(
name|fl
operator|->
name|lockname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|fl
operator|->
name|lockname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|init_txq
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|txq
operator|->
name|eq
operator|.
name|qsize
operator|=
name|qsize
expr_stmt|;
name|strlcpy
argument_list|(
name|txq
operator|->
name|eq
operator|.
name|lockname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|txq
operator|->
name|eq
operator|.
name|lockname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_ring
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|size_t
name|len
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|tag
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|,
name|bus_addr_t
modifier|*
name|pa
parameter_list|,
name|void
modifier|*
modifier|*
name|va
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
literal|512
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot allocate DMA tag: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|bus_dmamem_alloc
argument_list|(
operator|*
name|tag
argument_list|,
name|va
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot allocate DMA memory: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
operator|*
name|va
argument_list|,
name|len
argument_list|,
name|oneseg_dma_callback
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot load DMA map: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
if|if
condition|(
name|rc
condition|)
name|free_ring
argument_list|(
name|sc
argument_list|,
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
operator|*
name|pa
argument_list|,
operator|*
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_ring
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|bus_dma_tag_t
name|tag
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|bus_addr_t
name|pa
parameter_list|,
name|void
modifier|*
name|va
parameter_list|)
block|{
if|if
condition|(
name|pa
condition|)
name|bus_dmamap_unload
argument_list|(
name|tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
condition|)
name|bus_dmamem_free
argument_list|(
name|tag
argument_list|,
name|va
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates the ring for an ingress queue and an optional freelist.  If the  * freelist is specified it will be allocated and then associated with the  * ingress queue.  *  * Returns errno on failure.  Resources allocated up to that point may still be  * allocated.  Caller is responsible for cleanup in case this function fails.  *  * If the ingress queue will take interrupts directly (iq->handler == NULL) then  * the intr_idx specifies the vector, starting from 0.  Otherwise it specifies  * the index of the queue to which its interrupts will be forwarded.  */
end_comment

begin_function
specifier|static
name|int
name|alloc_iq_fl
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|intr_idx
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|fw_iq_cmd
name|c
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|__be32
name|v
init|=
literal|0
decl_stmt|;
comment|/* The adapter queues are nominally allocated in port[0]'s name */
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
name|pi
operator|=
name|sc
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|iq
operator|->
name|iq_lock
argument_list|,
name|iq
operator|->
name|lockname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|len
operator|=
name|iq
operator|->
name|qsize
operator|*
name|iq
operator|->
name|esize
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|iq
operator|->
name|desc_tag
argument_list|,
operator|&
name|iq
operator|->
name|desc_map
argument_list|,
operator|&
name|iq
operator|->
name|ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|iq
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_IQ_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_IQ_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_IQ_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_IQ_CMD_ALLOC
operator||
name|F_FW_IQ_CMD_IQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special handling for firmware event queue */
if|if
condition|(
name|iq
operator|==
operator|&
name|sc
operator|->
name|sge
operator|.
name|fwq
condition|)
name|v
operator||=
name|F_FW_IQ_CMD_IQASYNCH
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|handler
condition|)
block|{
name|KASSERT
argument_list|(
name|intr_idx
operator|<
name|NFIQ
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: invalid indirect intr_idx %d"
operator|,
name|__func__
operator|,
name|intr_idx
operator|)
argument_list|)
expr_stmt|;
name|v
operator||=
name|F_FW_IQ_CMD_IQANDST
expr_stmt|;
name|v
operator||=
name|V_FW_IQ_CMD_IQANDSTINDEX
argument_list|(
name|sc
operator|->
name|sge
operator|.
name|fiq
index|[
name|intr_idx
index|]
operator|.
name|abs_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|intr_idx
operator|<
name|sc
operator|->
name|intr_count
argument_list|,
operator|(
literal|"%s: invalid direct intr_idx %d"
operator|,
name|__func__
operator|,
name|intr_idx
operator|)
argument_list|)
expr_stmt|;
name|v
operator||=
name|V_FW_IQ_CMD_IQANDSTINDEX
argument_list|(
name|intr_idx
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|type_to_iqandstindex
operator|=
name|htobe32
argument_list|(
name|v
operator||
name|V_FW_IQ_CMD_TYPE
argument_list|(
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|)
operator||
name|V_FW_IQ_CMD_VIID
argument_list|(
name|pi
operator|->
name|viid
argument_list|)
operator||
name|V_FW_IQ_CMD_IQANUD
argument_list|(
name|X_UPDATEDELIVERY_INTERRUPT
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqdroprss_to_iqesize
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_IQPCIECH
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|F_FW_IQ_CMD_IQGTSMODE
operator||
name|V_FW_IQ_CMD_IQINTCNTTHRESH
argument_list|(
name|iq
operator|->
name|intr_pktc_idx
argument_list|)
operator||
name|V_FW_IQ_CMD_IQESIZE
argument_list|(
name|ilog2
argument_list|(
name|iq
operator|->
name|esize
argument_list|)
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqsize
operator|=
name|htobe16
argument_list|(
name|iq
operator|->
name|qsize
argument_list|)
expr_stmt|;
name|c
operator|.
name|iqaddr
operator|=
name|htobe64
argument_list|(
name|iq
operator|->
name|ba
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
condition|)
block|{
name|mtx_init
argument_list|(
operator|&
name|fl
operator|->
name|fl_lock
argument_list|,
name|fl
operator|->
name|lockname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FL_BUF_SIZES
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * A freelist buffer must be 16 byte aligned as the SGE 			 * uses the low 4 bits of the bus addr to figure out the 			 * buffer size. 			 */
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FL_BUF_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
name|FL_BUF_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|fl
operator|->
name|tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create fl DMA tag[%d]: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|len
operator|=
name|fl
operator|->
name|qsize
operator|*
name|RX_FL_ESIZE
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|fl
operator|->
name|desc_tag
argument_list|,
operator|&
name|fl
operator|->
name|desc_map
argument_list|,
operator|&
name|fl
operator|->
name|ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fl
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Allocate space for one software descriptor per buffer. */
name|fl
operator|->
name|cap
operator|=
operator|(
name|fl
operator|->
name|qsize
operator|-
name|SPG_LEN
operator|/
name|RX_FL_ESIZE
operator|)
operator|*
literal|8
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|set_fl_tag_idx
argument_list|(
name|fl
argument_list|,
name|pi
operator|->
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|rc
operator|=
name|alloc_fl_sdesc
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup fl software descriptors: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|fl
operator|->
name|needed
operator|=
name|fl
operator|->
name|cap
operator|-
literal|1
expr_stmt|;
comment|/* one less to avoid cidx = pidx */
name|c
operator|.
name|iqns_to_fl0congen
operator|=
name|htobe32
argument_list|(
name|V_FW_IQ_CMD_FL0HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_NONE
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0dcaen_to_fl0cidxfthresh
operator|=
name|htobe16
argument_list|(
name|V_FW_IQ_CMD_FL0FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_IQ_CMD_FL0FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0size
operator|=
name|htobe16
argument_list|(
name|fl
operator|->
name|qsize
argument_list|)
expr_stmt|;
name|c
operator|.
name|fl0addr
operator|=
name|htobe64
argument_list|(
name|fl
operator|->
name|ba
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create ingress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|iq
operator|->
name|cdesc
operator|=
name|iq
operator|->
name|desc
expr_stmt|;
name|iq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|gen
operator|=
literal|1
expr_stmt|;
name|iq
operator|->
name|intr_next
operator|=
name|iq
operator|->
name|intr_params
expr_stmt|;
name|iq
operator|->
name|cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|iqid
argument_list|)
expr_stmt|;
name|iq
operator|->
name|abs_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|physiqid
argument_list|)
expr_stmt|;
name|iq
operator|->
name|flags
operator||=
operator|(
name|IQ_ALLOCATED
operator||
name|IQ_STARTED
operator|)
expr_stmt|;
name|cntxt_id
operator|=
name|iq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|iq_start
expr_stmt|;
name|KASSERT
argument_list|(
name|cntxt_id
operator|<
name|sc
operator|->
name|sge
operator|.
name|niq
argument_list|,
operator|(
literal|"%s: iq->cntxt_id (%d) more than the max (%d)"
operator|,
name|__func__
operator|,
name|cntxt_id
operator|,
name|sc
operator|->
name|sge
operator|.
name|niq
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|iqmap
index|[
name|cntxt_id
index|]
operator|=
name|iq
expr_stmt|;
if|if
condition|(
name|fl
condition|)
block|{
name|fl
operator|->
name|cntxt_id
operator|=
name|be16toh
argument_list|(
name|c
operator|.
name|fl0id
argument_list|)
expr_stmt|;
name|fl
operator|->
name|pidx
operator|=
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|cntxt_id
operator|=
name|fl
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
name|KASSERT
argument_list|(
name|cntxt_id
operator|<
name|sc
operator|->
name|sge
operator|.
name|neq
argument_list|,
operator|(
literal|"%s: fl->cntxt_id (%d) more than the max (%d)"
operator|,
name|__func__
operator|,
name|cntxt_id
operator|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|fl
expr_stmt|;
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|fl
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|pending
operator|>=
literal|8
condition|)
name|ring_fl_db
argument_list|(
name|sc
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
comment|/* Enable IQ interrupts */
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_GTS
argument_list|)
argument_list|,
name|V_SEINTARM
argument_list|(
name|iq
operator|->
name|intr_params
argument_list|)
operator||
name|V_INGRESSQID
argument_list|(
name|iq
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This can be called with the iq/fl in any state - fully allocated and  * functional, partially allocated, even all-zeroed out.  */
end_comment

begin_function
specifier|static
name|int
name|free_iq_fl
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|iq
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to do */
name|dev
operator|=
name|pi
condition|?
name|pi
operator|->
name|dev
else|:
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_STARTED
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_iq_start_stop
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|iq
operator|->
name|cntxt_id
argument_list|,
name|fl
condition|?
name|fl
operator|->
name|cntxt_id
else|:
literal|0xffff
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to stop queue %p: %d\n"
argument_list|,
name|iq
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|iq
operator|->
name|flags
operator|&=
operator|~
name|IQ_STARTED
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|flags
operator|&
name|IQ_ALLOCATED
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_iq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|FW_IQ_TYPE_FL_INT_CAP
argument_list|,
name|iq
operator|->
name|cntxt_id
argument_list|,
name|fl
condition|?
name|fl
operator|->
name|cntxt_id
else|:
literal|0xffff
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to free queue %p: %d\n"
argument_list|,
name|iq
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|iq
operator|->
name|flags
operator|&=
operator|~
name|IQ_ALLOCATED
expr_stmt|;
block|}
name|free_ring
argument_list|(
name|sc
argument_list|,
name|iq
operator|->
name|desc_tag
argument_list|,
name|iq
operator|->
name|desc_map
argument_list|,
name|iq
operator|->
name|ba
argument_list|,
name|iq
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|iq
operator|->
name|iq_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|iq
operator|->
name|iq_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|iq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
condition|)
block|{
name|free_ring
argument_list|(
name|sc
argument_list|,
name|fl
operator|->
name|desc_tag
argument_list|,
name|fl
operator|->
name|desc_map
argument_list|,
name|fl
operator|->
name|ba
argument_list|,
name|fl
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|sdesc
condition|)
block|{
name|FL_LOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|free_fl_sdesc
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|FL_UNLOCK
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|fl
operator|->
name|fl_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|fl
operator|->
name|fl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FL_BUF_SIZES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fl
operator|->
name|tag
index|[
name|i
index|]
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|fl
operator|->
name|tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|fl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|int
name|intr_idx
parameter_list|)
block|{
return|return
name|alloc_iq_fl
argument_list|(
name|NULL
argument_list|,
name|iq
argument_list|,
name|NULL
argument_list|,
name|intr_idx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_iq
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|)
block|{
return|return
name|free_iq_fl
argument_list|(
name|NULL
argument_list|,
name|iq
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_rxq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_rxq
modifier|*
name|rxq
parameter_list|,
name|int
name|intr_idx
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|rc
operator|=
name|alloc_iq_fl
argument_list|(
name|pi
argument_list|,
operator|&
name|rxq
operator|->
name|iq
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|,
name|intr_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
ifdef|#
directive|ifdef
name|INET
name|rc
operator|=
name|tcp_lro_init
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rxq
operator|->
name|lro
operator|.
name|ifp
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
comment|/* also indicates LRO init'ed */
if|if
condition|(
name|pi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
name|rxq
operator|->
name|flags
operator||=
name|RXQ_LRO_ENABLED
expr_stmt|;
endif|#
directive|endif
name|rxq
operator|->
name|ifp
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|pi
operator|->
name|oid_rxq
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rx queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|lro
operator|.
name|lro_queued
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|lro
operator|.
name|lro_flushed
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxcsum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|rxcsum
argument_list|,
literal|"# of times hardware assisted with checksum"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vlan_extraction"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|vlan_extraction
argument_list|,
literal|"# of times hardware extracted 802.1Q tag"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_rxq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|rxq
operator|->
name|lro
operator|.
name|ifp
condition|)
block|{
name|tcp_lro_free
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|lro
operator|.
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|rc
operator|=
name|free_iq_fl
argument_list|(
name|pi
argument_list|,
operator|&
name|rxq
operator|->
name|iq
argument_list|,
operator|&
name|rxq
operator|->
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|rxq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rxq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_txq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cntxt_id
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|fw_eq_eth_cmd
name|c
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|txq
operator|->
name|ifp
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txq
operator|->
name|resume_tx
argument_list|,
literal|0
argument_list|,
name|cxgbe_txq_start
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|eq
operator|->
name|eq_lock
argument_list|,
name|eq
operator|->
name|lockname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|len
operator|=
name|eq
operator|->
name|qsize
operator|*
name|TX_EQ_ESIZE
expr_stmt|;
name|rc
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|&
name|eq
operator|->
name|desc_tag
argument_list|,
operator|&
name|eq
operator|->
name|desc_map
argument_list|,
operator|&
name|eq
operator|->
name|ba
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|eq
operator|->
name|cap
operator|=
name|eq
operator|->
name|qsize
operator|-
name|SPG_LEN
operator|/
name|TX_EQ_ESIZE
expr_stmt|;
name|eq
operator|->
name|spg
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|cap
index|]
expr_stmt|;
name|eq
operator|->
name|avail
operator|=
name|eq
operator|->
name|cap
operator|-
literal|1
expr_stmt|;
comment|/* one less to avoid cidx = pidx */
name|eq
operator|->
name|sdesc
operator|=
name|malloc
argument_list|(
name|eq
operator|->
name|cap
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tx_sdesc
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|eq
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|eq
operator|->
name|qsize
argument_list|,
name|M_CXGBE
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|eq
operator|->
name|eq_lock
argument_list|)
expr_stmt|;
name|eq
operator|->
name|iqid
operator|=
name|sc
operator|->
name|sge
operator|.
name|rxq
index|[
name|pi
operator|->
name|first_rxq
index|]
operator|.
name|iq
operator|.
name|cntxt_id
expr_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|TX_SGL_SEGS
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|eq
operator|->
name|tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to create tx DMA tag: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|alloc_eq_maps
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup tx DMA maps: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|op_to_vfn
operator|=
name|htobe32
argument_list|(
name|V_FW_CMD_OP
argument_list|(
name|FW_EQ_ETH_CMD
argument_list|)
operator||
name|F_FW_CMD_REQUEST
operator||
name|F_FW_CMD_WRITE
operator||
name|F_FW_CMD_EXEC
operator||
name|V_FW_EQ_ETH_CMD_PFN
argument_list|(
name|sc
operator|->
name|pf
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_VFN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|alloc_to_len16
operator|=
name|htobe32
argument_list|(
name|F_FW_EQ_ETH_CMD_ALLOC
operator||
name|F_FW_EQ_ETH_CMD_EQSTART
operator||
name|FW_LEN16
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|viid_pkd
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_VIID
argument_list|(
name|pi
operator|->
name|viid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fetchszm_to_iqid
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_HOSTFCMODE
argument_list|(
name|X_HOSTFCMODE_STATUS_PAGE
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_PCIECHN
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_IQID
argument_list|(
name|eq
operator|->
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|dcaen_to_eqsize
operator|=
name|htobe32
argument_list|(
name|V_FW_EQ_ETH_CMD_FBMIN
argument_list|(
name|X_FETCHBURSTMIN_64B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_FBMAX
argument_list|(
name|X_FETCHBURSTMAX_512B
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_CIDXFTHRESH
argument_list|(
name|X_CIDXFLUSHTHRESH_32
argument_list|)
operator||
name|V_FW_EQ_ETH_CMD_EQSIZE
argument_list|(
name|eq
operator|->
name|qsize
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|eqaddr
operator|=
name|htobe64
argument_list|(
name|eq
operator|->
name|ba
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|t4_wr_mbox
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"failed to create egress queue: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|eq
operator|->
name|pidx
operator|=
name|eq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|eq
operator|->
name|cntxt_id
operator|=
name|G_FW_EQ_ETH_CMD_EQID
argument_list|(
name|be32toh
argument_list|(
name|c
operator|.
name|eqid_pkd
argument_list|)
argument_list|)
expr_stmt|;
name|eq
operator|->
name|flags
operator||=
operator|(
name|EQ_ALLOCATED
operator||
name|EQ_STARTED
operator|)
expr_stmt|;
name|cntxt_id
operator|=
name|eq
operator|->
name|cntxt_id
operator|-
name|sc
operator|->
name|sge
operator|.
name|eq_start
expr_stmt|;
name|KASSERT
argument_list|(
name|cntxt_id
operator|<
name|sc
operator|->
name|sge
operator|.
name|neq
argument_list|,
operator|(
literal|"%s: eq->cntxt_id (%d) more than the max (%d)"
operator|,
name|__func__
operator|,
name|cntxt_id
operator|,
name|sc
operator|->
name|sge
operator|.
name|neq
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sge
operator|.
name|eqmap
index|[
name|cntxt_id
index|]
operator|=
name|eq
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|pi
operator|->
name|oid_txq
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"tx queue"
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txcsum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txcsum
argument_list|,
literal|"# of times hardware assisted with checksum"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vlan_insertion"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|vlan_insertion
argument_list|,
literal|"# of times hardware inserted 802.1Q tag"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|tso_wrs
argument_list|,
literal|"# of IPv4 TSO work requests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"imm_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|imm_wrs
argument_list|,
literal|"# of work requests with immediate data"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sgl_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|sgl_wrs
argument_list|,
literal|"# of work requests with direct SGL"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkt_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkt_wrs
argument_list|,
literal|"# of txpkt work requests (one pkt/WR)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkts_wrs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkts_wrs
argument_list|,
literal|"# of txpkts work requests (multiple pkts/WR)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpkts_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txpkts_pkts
argument_list|,
literal|"# of frames tx'd using txpkts work requests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_dmamap"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|no_dmamap
argument_list|,
literal|0
argument_list|,
literal|"# of times txq ran out of DMA maps"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|no_desc
argument_list|,
literal|0
argument_list|,
literal|"# of times txq ran out of hardware descriptors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|pi
operator|->
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"egr_update"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|egr_update
argument_list|,
literal|0
argument_list|,
literal|"egress update notifications from the SGE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_txq
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
if|if
condition|(
name|eq
operator|->
name|flags
operator|&
operator|(
name|EQ_ALLOCATED
operator||
name|EQ_STARTED
operator|)
condition|)
block|{
name|rc
operator|=
operator|-
name|t4_eth_eq_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mbox
argument_list|,
name|sc
operator|->
name|pf
argument_list|,
literal|0
argument_list|,
name|eq
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pi
operator|->
name|dev
argument_list|,
literal|"failed to free egress queue %p: %d\n"
argument_list|,
name|eq
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|eq
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EQ_ALLOCATED
operator||
name|EQ_STARTED
operator|)
expr_stmt|;
block|}
name|free_ring
argument_list|(
name|sc
argument_list|,
name|eq
operator|->
name|desc_tag
argument_list|,
name|eq
operator|->
name|desc_map
argument_list|,
name|eq
operator|->
name|ba
argument_list|,
name|eq
operator|->
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|eq
operator|->
name|sdesc
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|maps
condition|)
name|free_eq_maps
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|buf_ring_free
argument_list|(
name|eq
operator|->
name|br
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|tx_tag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|eq
operator|->
name|eq_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|eq
operator|->
name|eq_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|txq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|oneseg_dma_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|ba
init|=
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"%s meant for single segment mappings only."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ba
operator|=
name|error
condition|?
literal|0
else|:
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|is_new_response
parameter_list|(
specifier|const
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|,
name|struct
name|rsp_ctrl
modifier|*
modifier|*
name|ctrl
parameter_list|)
block|{
operator|*
name|ctrl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|iq
operator|->
name|cdesc
operator|+
operator|(
name|iq
operator|->
name|esize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_ctrl
argument_list|)
operator|)
operator|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
operator|*
name|ctrl
operator|)
operator|->
name|u
operator|.
name|type_gen
operator|>>
name|S_RSPD_GEN
operator|)
operator|==
name|iq
operator|->
name|gen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|iq_next
parameter_list|(
name|struct
name|sge_iq
modifier|*
name|iq
parameter_list|)
block|{
name|iq
operator|->
name|cdesc
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|iq
operator|->
name|cdesc
operator|+
name|iq
operator|->
name|esize
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|iq
operator|->
name|cidx
operator|==
name|iq
operator|->
name|qsize
operator|-
literal|1
argument_list|)
condition|)
block|{
name|iq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|iq
operator|->
name|cdesc
operator|=
name|iq
operator|->
name|desc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ring_fl_db
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|int
name|ndesc
init|=
name|fl
operator|->
name|pending
operator|/
literal|8
decl_stmt|;
comment|/* Caller responsible for ensuring there's something useful to do */
name|KASSERT
argument_list|(
name|ndesc
operator|>
literal|0
argument_list|,
operator|(
literal|"%s called with no useful work to do."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_KDOORBELL
argument_list|)
argument_list|,
name|F_DBPRIO
operator||
name|V_QID
argument_list|(
name|fl
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|ndesc
argument_list|)
argument_list|)
expr_stmt|;
name|fl
operator|->
name|pending
operator|&=
literal|7
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|refill_fl
parameter_list|(
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|nbufs
parameter_list|)
block|{
name|__be64
modifier|*
name|d
init|=
operator|&
name|fl
operator|->
name|desc
index|[
name|fl
operator|->
name|pidx
index|]
decl_stmt|;
name|struct
name|fl_sdesc
modifier|*
name|sd
init|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|fl
operator|->
name|pidx
index|]
decl_stmt|;
name|bus_dma_tag_t
name|tag
decl_stmt|;
name|bus_addr_t
name|pa
decl_stmt|;
name|caddr_t
name|cl
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|FL_LOCK_ASSERT_OWNED
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|<
literal|0
operator|||
name|nbufs
operator|>
name|fl
operator|->
name|needed
condition|)
name|nbufs
operator|=
name|fl
operator|->
name|needed
expr_stmt|;
while|while
condition|(
name|nbufs
operator|--
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|cl
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * This happens when a frame small enough to fit 			 * entirely in an mbuf was received in cl last time. 			 * We'd held on to cl and can reuse it now.  Note that 			 * we reuse a cluster of the old size if fl->tag_idx is 			 * no longer the same as sd->tag_idx. 			 */
name|KASSERT
argument_list|(
operator|*
name|d
operator|==
name|sd
operator|->
name|ba_tag
argument_list|,
operator|(
literal|"%s: recyling problem at pidx %d"
operator|,
name|__func__
operator|,
name|fl
operator|->
name|pidx
operator|)
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
goto|goto
name|recycled
goto|;
block|}
if|if
condition|(
name|fl
operator|->
name|tag_idx
operator|!=
name|sd
operator|->
name|tag_idx
condition|)
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_tag_t
name|newtag
init|=
name|fl
operator|->
name|tag
index|[
name|fl
operator|->
name|tag_idx
index|]
decl_stmt|;
name|bus_dma_tag_t
name|oldtag
init|=
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
decl_stmt|;
comment|/* 			 * An MTU change can get us here.  Discard the old map 			 * which was created with the old tag, but only if 			 * we're able to get a new one. 			 */
name|rc
operator|=
name|bus_dmamap_create
argument_list|(
name|newtag
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|oldtag
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
name|sd
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|sd
operator|->
name|tag_idx
operator|=
name|fl
operator|->
name|tag_idx
expr_stmt|;
block|}
block|}
name|tag
operator|=
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
expr_stmt|;
name|cl
operator|=
name|m_cljget
argument_list|(
name|NULL
argument_list|,
name|M_NOWAIT
argument_list|,
name|FL_BUF_SIZE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
break|break;
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
name|tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|cl
argument_list|,
name|FL_BUF_SIZE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|,
name|oneseg_dma_callback
argument_list|,
operator|&
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|pa
operator|==
literal|0
condition|)
block|{
name|fl
operator|->
name|dmamap_failed
operator|++
expr_stmt|;
name|uma_zfree
argument_list|(
name|FL_BUF_ZONE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|,
name|cl
argument_list|)
expr_stmt|;
break|break;
block|}
name|sd
operator|->
name|cl
operator|=
name|cl
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|htobe64
argument_list|(
name|pa
operator||
name|sd
operator|->
name|tag_idx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sd
operator|->
name|ba_tag
operator|=
name|htobe64
argument_list|(
name|pa
operator||
name|sd
operator|->
name|tag_idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|recycled
label|:
comment|/* sd->m is never recycled, should always be NULL */
name|KASSERT
argument_list|(
name|sd
operator|->
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: stray mbuf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sd
operator|->
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_NOINIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|m
operator|==
name|NULL
condition|)
break|break;
name|fl
operator|->
name|pending
operator|++
expr_stmt|;
name|fl
operator|->
name|needed
operator|--
expr_stmt|;
name|sd
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|fl
operator|->
name|pidx
operator|==
name|fl
operator|->
name|cap
condition|)
block|{
name|fl
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|sd
operator|=
name|fl
operator|->
name|sdesc
expr_stmt|;
name|d
operator|=
name|fl
operator|->
name|desc
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_fl_sdesc
parameter_list|(
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|fl_sdesc
modifier|*
name|sd
decl_stmt|;
name|bus_dma_tag_t
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|FL_LOCK_ASSERT_OWNED
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|sdesc
operator|=
name|malloc
argument_list|(
name|fl
operator|->
name|cap
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fl_sdesc
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|tag
operator|=
name|fl
operator|->
name|tag
index|[
name|fl
operator|->
name|tag_idx
index|]
expr_stmt|;
name|sd
operator|=
name|fl
operator|->
name|sdesc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl
operator|->
name|cap
condition|;
name|i
operator|++
operator|,
name|sd
operator|++
control|)
block|{
name|sd
operator|->
name|tag_idx
operator|=
name|fl
operator|->
name|tag_idx
expr_stmt|;
name|rc
operator|=
name|bus_dmamap_create
argument_list|(
name|tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|sd
operator|--
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|tag
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|m
condition|)
block|{
name|m_init
argument_list|(
name|sd
operator|->
name|m
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|sd
operator|->
name|m
argument_list|)
expr_stmt|;
name|sd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|sd
operator|==
name|fl
operator|->
name|sdesc
argument_list|,
operator|(
literal|"%s: EDOOFUS"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fl
operator|->
name|sdesc
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|fl
operator|->
name|sdesc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_fl_sdesc
parameter_list|(
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|fl_sdesc
modifier|*
name|sd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FL_LOCK_ASSERT_OWNED
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|sd
operator|=
name|fl
operator|->
name|sdesc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl
operator|->
name|cap
condition|;
name|i
operator|++
operator|,
name|sd
operator|++
control|)
block|{
if|if
condition|(
name|sd
operator|->
name|m
condition|)
block|{
name|m_init
argument_list|(
name|sd
operator|->
name|m
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|sd
operator|->
name|m
argument_list|)
expr_stmt|;
name|sd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sd
operator|->
name|cl
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|FL_BUF_ZONE
argument_list|(
name|sd
operator|->
name|tag_idx
argument_list|)
argument_list|,
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
name|sd
operator|->
name|cl
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|fl
operator|->
name|tag
index|[
name|sd
operator|->
name|tag_idx
index|]
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fl
operator|->
name|sdesc
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|fl
operator|->
name|sdesc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_eq_maps
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|tx_map
modifier|*
name|txm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|count
decl_stmt|;
comment|/* 	 * We can stuff ~10 frames in an 8-descriptor txpkts WR (8 is the SGE 	 * limit for any WR).  txq->no_dmamap events shouldn't occur if maps is 	 * sized for the worst case. 	 */
name|count
operator|=
name|eq
operator|->
name|qsize
operator|*
literal|10
operator|/
literal|8
expr_stmt|;
name|eq
operator|->
name|map_total
operator|=
name|eq
operator|->
name|map_avail
operator|=
name|count
expr_stmt|;
name|eq
operator|->
name|map_cidx
operator|=
name|eq
operator|->
name|map_pidx
operator|=
literal|0
expr_stmt|;
name|eq
operator|->
name|maps
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tx_map
argument_list|)
argument_list|,
name|M_CXGBE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|txm
operator|=
name|eq
operator|->
name|maps
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|txm
operator|++
control|)
block|{
name|rc
operator|=
name|bus_dmamap_create
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txm
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|txm
operator|--
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|,
name|txm
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|txm
operator|==
name|eq
operator|->
name|maps
argument_list|,
operator|(
literal|"%s: EDOOFUS"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|eq
operator|->
name|maps
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|eq
operator|->
name|maps
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_eq_maps
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|tx_map
modifier|*
name|txm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|txm
operator|=
name|eq
operator|->
name|maps
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eq
operator|->
name|map_total
condition|;
name|i
operator|++
operator|,
name|txm
operator|++
control|)
block|{
if|if
condition|(
name|txm
operator|->
name|m
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|,
name|txm
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txm
operator|->
name|m
argument_list|)
expr_stmt|;
name|txm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|,
name|txm
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|eq
operator|->
name|maps
argument_list|,
name|M_CXGBE
argument_list|)
expr_stmt|;
name|eq
operator|->
name|maps
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We'll do immediate data tx for non-TSO, but only when not coalescing.  We're  * willing to use upto 2 hardware descriptors which means a maximum of 96 bytes  * of immediate data.  */
end_comment

begin_define
define|#
directive|define
name|IMM_LEN
value|( \       2 * TX_EQ_ESIZE \     - sizeof(struct fw_eth_tx_pkt_wr) \     - sizeof(struct cpl_tx_pkt_core))
end_define

begin_comment
comment|/*  * Returns non-zero on failure, no need to cleanup anything in that case.  *  * Note 1: We always try to defrag the mbuf if required and return EFBIG only  * if the resulting chain still won't fit in a tx descriptor.  *  * Note 2: We'll pullup the mbuf chain if TSO is requested and the first mbuf  * does not have the TCP header in it.  */
end_comment

begin_function
specifier|static
name|int
name|get_pkt_sgl
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|fp
parameter_list|,
name|struct
name|sgl
modifier|*
name|sgl
parameter_list|,
name|int
name|sgl_only
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|fp
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|tx_map
modifier|*
name|txm
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|defragged
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
condition|)
name|sgl_only
operator|=
literal|1
expr_stmt|;
comment|/* Do not allow immediate data with LSO */
name|start
label|:
name|sgl
operator|->
name|nsegs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|IMM_LEN
operator|&&
operator|!
name|sgl_only
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nsegs = 0 tells caller to use imm. tx */
if|if
condition|(
name|eq
operator|->
name|map_avail
operator|==
literal|0
condition|)
block|{
name|txq
operator|->
name|no_dmamap
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|txm
operator|=
operator|&
name|eq
operator|->
name|maps
index|[
name|eq
operator|->
name|map_pidx
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|&&
name|m
operator|->
name|m_len
operator|<
literal|50
condition|)
block|{
operator|*
name|fp
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|fp
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|,
name|txm
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|sgl
operator|->
name|seg
argument_list|,
operator|&
name|sgl
operator|->
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EFBIG
operator|&&
name|defragged
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|defragged
operator|=
literal|1
expr_stmt|;
operator|*
name|fp
operator|=
name|m
expr_stmt|;
goto|goto
name|start
goto|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|txm
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|eq
operator|->
name|map_avail
operator|--
expr_stmt|;
if|if
condition|(
operator|++
name|eq
operator|->
name|map_pidx
operator|==
name|eq
operator|->
name|map_total
condition|)
name|eq
operator|->
name|map_pidx
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|sgl
operator|->
name|nsegs
operator|>
literal|0
operator|&&
name|sgl
operator|->
name|nsegs
operator|<=
name|TX_SGL_SEGS
argument_list|,
operator|(
literal|"%s: bad DMA mapping (%d segments)"
operator|,
name|__func__
operator|,
name|sgl
operator|->
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Store the # of flits required to hold this frame's SGL in nflits.  An 	 * SGL has a (ULPTX header + len0, addr0) tuple optionally followed by 	 * multiple (len0 + len1, addr0, addr1) tuples.  If addr1 is not used 	 * then len1 must be set to 0. 	 */
name|n
operator|=
name|sgl
operator|->
name|nsegs
operator|-
literal|1
expr_stmt|;
name|sgl
operator|->
name|nflits
operator|=
operator|(
literal|3
operator|*
name|n
operator|)
operator|/
literal|2
operator|+
operator|(
name|n
operator|&
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Releases all the txq resources used up in the specified sgl.  */
end_comment

begin_function
specifier|static
name|int
name|free_pkt_sgl
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|sgl
modifier|*
name|sgl
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|tx_map
modifier|*
name|txm
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgl
operator|->
name|nsegs
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* didn't use any map */
comment|/* 1 pkt uses exactly 1 map, back it out */
name|eq
operator|->
name|map_avail
operator|++
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|map_pidx
operator|>
literal|0
condition|)
name|eq
operator|->
name|map_pidx
operator|--
expr_stmt|;
else|else
name|eq
operator|->
name|map_pidx
operator|=
name|eq
operator|->
name|map_total
operator|-
literal|1
expr_stmt|;
name|txm
operator|=
operator|&
name|eq
operator|->
name|maps
index|[
name|eq
operator|->
name|map_pidx
index|]
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|,
name|txm
operator|->
name|map
argument_list|)
expr_stmt|;
name|txm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_txpkt_wr
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sgl
modifier|*
name|sgl
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|fw_eth_tx_pkt_wr
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_tx_pkt_core
modifier|*
name|cpl
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
comment|/* used in many unrelated places */
name|uint64_t
name|ctrl1
decl_stmt|;
name|int
name|nflits
decl_stmt|,
name|ndesc
decl_stmt|,
name|pktlen
decl_stmt|;
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * Do we have enough flits to send this frame out? 	 */
name|ctrl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
condition|)
block|{
name|nflits
operator|=
name|TXPKT_LSO_WR_HDR
expr_stmt|;
name|ctrl
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_lso
argument_list|)
expr_stmt|;
block|}
else|else
name|nflits
operator|=
name|TXPKT_WR_HDR
expr_stmt|;
if|if
condition|(
name|sgl
operator|->
name|nsegs
operator|>
literal|0
condition|)
name|nflits
operator|+=
name|sgl
operator|->
name|nflits
expr_stmt|;
else|else
block|{
name|nflits
operator|+=
name|howmany
argument_list|(
name|pktlen
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ctrl
operator|+=
name|pktlen
expr_stmt|;
block|}
name|ndesc
operator|=
name|howmany
argument_list|(
name|nflits
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndesc
operator|>
name|eq
operator|->
name|avail
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Firmware work request header */
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|wr
operator|->
name|op_immdlen
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKT_WR
argument_list|)
operator||
name|V_FW_WR_IMMDLEN
argument_list|(
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|V_FW_WR_LEN16
argument_list|(
name|howmany
argument_list|(
name|nflits
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|avail
operator|==
name|ndesc
condition|)
name|ctrl
operator||=
name|F_FW_WR_EQUEQ
operator||
name|F_FW_WR_EQUIQ
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|wr
operator|->
name|r3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
condition|)
block|{
name|struct
name|cpl_tx_pkt_lso
modifier|*
name|lso
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|ctrl
operator|=
name|V_LSO_OPCODE
argument_list|(
name|CPL_TX_PKT_LSO
argument_list|)
operator||
name|F_LSO_FIRST_SLICE
operator||
name|F_LSO_LAST_SLICE
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ctrl
operator||=
name|V_LSO_ETHHDR_LEN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
expr|struct
name|ether_vlan_header
operator|*
operator|)
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|ip
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
name|tcp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ip
operator|+
name|ip
operator|->
name|ip_hl
operator|*
literal|4
operator|)
expr_stmt|;
name|ctrl
operator||=
name|V_LSO_IPHDR_LEN
argument_list|(
name|ip
operator|->
name|ip_hl
argument_list|)
operator||
name|V_LSO_TCPHDR_LEN
argument_list|(
name|tcp
operator|->
name|th_off
argument_list|)
expr_stmt|;
name|lso
operator|->
name|lso_ctrl
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|lso
operator|->
name|ipid_ofst
operator|=
name|htobe16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lso
operator|->
name|mss
operator|=
name|htobe16
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|lso
operator|->
name|seqno_offset
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lso
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|lso
operator|+
literal|1
operator|)
expr_stmt|;
name|txq
operator|->
name|tso_wrs
operator|++
expr_stmt|;
block|}
else|else
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Checksum offload */
name|ctrl1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
operator|)
condition|)
name|ctrl1
operator||=
name|F_TXPKT_IPCSUM_DIS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
condition|)
name|ctrl1
operator||=
name|F_TXPKT_L4CSUM_DIS
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
condition|)
name|txq
operator|->
name|txcsum
operator|++
expr_stmt|;
comment|/* some hardware assistance provided */
comment|/* VLAN tag insertion */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|ctrl1
operator||=
name|F_TXPKT_VLAN_VLD
operator||
name|V_TXPKT_VLAN
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vlan_insertion
operator|++
expr_stmt|;
block|}
comment|/* CPL header */
name|cpl
operator|->
name|ctrl0
operator|=
name|htobe32
argument_list|(
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
operator||
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|V_TXPKT_PF
argument_list|(
name|pi
operator|->
name|adapter
operator|->
name|pf
argument_list|)
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|pack
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|ctrl1
operator|=
name|htobe64
argument_list|(
name|ctrl1
argument_list|)
expr_stmt|;
comment|/* Software descriptor */
name|txsd
operator|=
operator|&
name|eq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|desc_used
operator|=
name|ndesc
expr_stmt|;
name|eq
operator|->
name|pending
operator|+=
name|ndesc
expr_stmt|;
name|eq
operator|->
name|avail
operator|-=
name|ndesc
expr_stmt|;
name|eq
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|pidx
operator|>=
name|eq
operator|->
name|cap
condition|)
name|eq
operator|->
name|pidx
operator|-=
name|eq
operator|->
name|cap
expr_stmt|;
comment|/* SGL */
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sgl
operator|->
name|nsegs
operator|>
literal|0
condition|)
block|{
name|txsd
operator|->
name|map_used
operator|=
literal|1
expr_stmt|;
name|txq
operator|->
name|sgl_wrs
operator|++
expr_stmt|;
name|write_sgl_to_txd
argument_list|(
name|eq
argument_list|,
name|sgl
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txsd
operator|->
name|map_used
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|imm_wrs
operator|++
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|copy_to_txd
argument_list|(
name|eq
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|&
name|dst
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|pktlen
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
name|pktlen
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d bytes left."
operator|,
name|__func__
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|txq
operator|->
name|txpkt_wrs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 to indicate that m has been accepted into a coalesced tx work  * request.  It has either been folded into txpkts or txpkts was flushed and m  * has started a new coalesced work request (as the first frame in a fresh  * txpkts).  *  * Returns non-zero to indicate a failure - caller is responsible for  * transmitting m, if there was anything in txpkts it has been flushed.  */
end_comment

begin_function
specifier|static
name|int
name|add_to_txpkts
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|txpkts
modifier|*
name|txpkts
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sgl
modifier|*
name|sgl
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|int
name|can_coalesce
decl_stmt|;
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|int
name|flits
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|txpkts
operator|->
name|npkt
operator|>
literal|0
condition|)
block|{
name|flits
operator|=
name|TXPKTS_PKT_HDR
operator|+
name|sgl
operator|->
name|nflits
expr_stmt|;
name|can_coalesce
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|==
literal|0
operator|&&
name|txpkts
operator|->
name|nflits
operator|+
name|flits
operator|<=
name|TX_WR_FLITS
operator|&&
name|txpkts
operator|->
name|nflits
operator|+
name|flits
operator|<=
name|eq
operator|->
name|avail
operator|*
literal|8
operator|&&
name|txpkts
operator|->
name|plen
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|65536
expr_stmt|;
if|if
condition|(
name|can_coalesce
condition|)
block|{
name|txpkts
operator|->
name|npkt
operator|++
expr_stmt|;
name|txpkts
operator|->
name|nflits
operator|+=
name|flits
expr_stmt|;
name|txpkts
operator|->
name|plen
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|txsd
operator|=
operator|&
name|eq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|map_used
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Couldn't coalesce m into txpkts.  The first order of business 		 * is to send txpkts on its way.  Then we'll revisit m. 		 */
name|write_txpkts_wr
argument_list|(
name|txq
argument_list|,
name|txpkts
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if we can start a new coalesced tx work request with m as 	 * the first packet in it. 	 */
name|KASSERT
argument_list|(
name|txpkts
operator|->
name|npkt
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: txpkts not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|flits
operator|=
name|TXPKTS_WR_HDR
operator|+
name|sgl
operator|->
name|nflits
expr_stmt|;
name|can_coalesce
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|==
literal|0
operator|&&
name|flits
operator|<=
name|eq
operator|->
name|avail
operator|*
literal|8
operator|&&
name|flits
operator|<=
name|TX_WR_FLITS
expr_stmt|;
if|if
condition|(
name|can_coalesce
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Start a fresh coalesced tx WR with m as the first frame in it. 	 */
name|txpkts
operator|->
name|npkt
operator|=
literal|1
expr_stmt|;
name|txpkts
operator|->
name|nflits
operator|=
name|flits
expr_stmt|;
name|txpkts
operator|->
name|flitp
operator|=
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
operator|.
name|flit
index|[
literal|2
index|]
expr_stmt|;
name|txpkts
operator|->
name|plen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|txsd
operator|=
operator|&
name|eq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|map_used
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that write_txpkts_wr can never run out of hardware descriptors (but  * write_txpkt_wr can).  add_to_txpkts ensures that a frame is accepted for  * coalescing only if sufficient hardware descriptors are available.  */
end_comment

begin_function
specifier|static
name|void
name|write_txpkts_wr
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|txpkts
modifier|*
name|txpkts
parameter_list|)
block|{
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|struct
name|fw_eth_tx_pkts_wr
modifier|*
name|wr
decl_stmt|;
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
name|int
name|ndesc
decl_stmt|;
name|TXQ_LOCK_ASSERT_OWNED
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|howmany
argument_list|(
name|txpkts
operator|->
name|nflits
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|wr
operator|->
name|op_immdlen
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_OP
argument_list|(
name|FW_ETH_TX_PKTS_WR
argument_list|)
operator||
name|V_FW_WR_IMMDLEN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* immdlen does not matter in this WR */
name|ctrl
operator|=
name|V_FW_WR_LEN16
argument_list|(
name|howmany
argument_list|(
name|txpkts
operator|->
name|nflits
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|avail
operator|==
name|ndesc
condition|)
name|ctrl
operator||=
name|F_FW_WR_EQUEQ
operator||
name|F_FW_WR_EQUIQ
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|wr
operator|->
name|plen
operator|=
name|htobe16
argument_list|(
name|txpkts
operator|->
name|plen
argument_list|)
expr_stmt|;
name|wr
operator|->
name|npkt
operator|=
name|txpkts
operator|->
name|npkt
expr_stmt|;
name|wr
operator|->
name|r3
operator|=
name|wr
operator|->
name|r4
operator|=
literal|0
expr_stmt|;
comment|/* Everything else already written */
name|txsd
operator|=
operator|&
name|eq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|desc_used
operator|=
name|ndesc
expr_stmt|;
name|KASSERT
argument_list|(
name|eq
operator|->
name|avail
operator|>=
name|ndesc
argument_list|,
operator|(
literal|"%s: out ouf descriptors"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|eq
operator|->
name|pending
operator|+=
name|ndesc
expr_stmt|;
name|eq
operator|->
name|avail
operator|-=
name|ndesc
expr_stmt|;
name|eq
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|pidx
operator|>=
name|eq
operator|->
name|cap
condition|)
name|eq
operator|->
name|pidx
operator|-=
name|eq
operator|->
name|cap
expr_stmt|;
name|txq
operator|->
name|txpkts_pkts
operator|+=
name|txpkts
operator|->
name|npkt
expr_stmt|;
name|txq
operator|->
name|txpkts_wrs
operator|++
expr_stmt|;
name|txpkts
operator|->
name|npkt
operator|=
literal|0
expr_stmt|;
comment|/* emptied */
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|write_ulp_cpl_sgl
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|txpkts
modifier|*
name|txpkts
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sgl
modifier|*
name|sgl
parameter_list|)
block|{
name|struct
name|ulp_txpkt
modifier|*
name|ulpmc
decl_stmt|;
name|struct
name|ulptx_idata
modifier|*
name|ulpsc
decl_stmt|;
name|struct
name|cpl_tx_pkt_core
modifier|*
name|cpl
decl_stmt|;
name|struct
name|sge_eq
modifier|*
name|eq
init|=
operator|&
name|txq
operator|->
name|eq
decl_stmt|;
name|uintptr_t
name|flitp
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
name|uint64_t
name|ctrl
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
name|KASSERT
argument_list|(
name|txpkts
operator|->
name|npkt
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: txpkts is empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|desc
expr_stmt|;
name|end
operator|=
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|spg
expr_stmt|;
comment|/* Checksum offload */
name|ctrl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
operator|)
condition|)
name|ctrl
operator||=
name|F_TXPKT_IPCSUM_DIS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
condition|)
name|ctrl
operator||=
name|F_TXPKT_L4CSUM_DIS
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
condition|)
name|txq
operator|->
name|txcsum
operator|++
expr_stmt|;
comment|/* some hardware assistance provided */
comment|/* VLAN tag insertion */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|ctrl
operator||=
name|F_TXPKT_VLAN_VLD
operator||
name|V_TXPKT_VLAN
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vlan_insertion
operator|++
expr_stmt|;
block|}
comment|/* 	 * The previous packet's SGL must have ended at a 16 byte boundary (this 	 * is required by the firmware/hardware).  It follows that flitp cannot 	 * wrap around between the ULPTX master command and ULPTX subcommand (8 	 * bytes each), and that it can not wrap around in the middle of the 	 * cpl_tx_pkt_core either. 	 */
name|flitp
operator|=
operator|(
name|uintptr_t
operator|)
name|txpkts
operator|->
name|flitp
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flitp
operator|&
literal|0xf
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: last SGL did not end at 16 byte boundary: %p"
operator|,
name|__func__
operator|,
name|txpkts
operator|->
name|flitp
operator|)
argument_list|)
expr_stmt|;
comment|/* ULP master command */
name|ulpmc
operator|=
operator|(
name|void
operator|*
operator|)
name|flitp
expr_stmt|;
name|ulpmc
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_PKT
argument_list|)
operator||
name|V_ULP_TXPKT_DEST
argument_list|(
literal|0
argument_list|)
operator||
name|V_ULP_TXPKT_FID
argument_list|(
name|eq
operator|->
name|iqid
argument_list|)
argument_list|)
expr_stmt|;
name|ulpmc
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ulpmc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ulpsc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
literal|8
operator|*
name|sgl
operator|->
name|nflits
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ULP subcommand */
name|ulpsc
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ulpmc
operator|+
literal|1
operator|)
expr_stmt|;
name|ulpsc
operator|->
name|cmd_more
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
operator|(
name|u32
operator|)
name|ULP_TX_SC_IMM
argument_list|)
operator||
name|F_ULP_TX_SC_MORE
argument_list|)
expr_stmt|;
name|ulpsc
operator|->
name|len
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt_core
argument_list|)
argument_list|)
expr_stmt|;
name|flitp
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ulpmc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ulpsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flitp
operator|==
name|end
condition|)
name|flitp
operator|=
name|start
expr_stmt|;
comment|/* CPL_TX_PKT */
name|cpl
operator|=
operator|(
name|void
operator|*
operator|)
name|flitp
expr_stmt|;
name|cpl
operator|->
name|ctrl0
operator|=
name|htobe32
argument_list|(
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
operator||
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|tx_chan
argument_list|)
operator||
name|V_TXPKT_PF
argument_list|(
name|pi
operator|->
name|adapter
operator|->
name|pf
argument_list|)
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|pack
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|ctrl1
operator|=
name|htobe64
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
name|flitp
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flitp
operator|==
name|end
condition|)
name|flitp
operator|=
name|start
expr_stmt|;
comment|/* SGL for this frame */
name|dst
operator|=
operator|(
name|caddr_t
operator|)
name|flitp
expr_stmt|;
name|txpkts
operator|->
name|nflits
operator|+=
name|write_sgl_to_txd
argument_list|(
name|eq
argument_list|,
name|sgl
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|txpkts
operator|->
name|flitp
operator|=
operator|(
name|void
operator|*
operator|)
name|dst
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|dst
operator|&
literal|0xf
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: SGL ends at %p (not a 16 byte boundary)"
operator|,
name|__func__
operator|,
name|dst
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the SGL ends on an address that is not 16 byte aligned, this function will  * add a 0 filled flit at the end.  It returns 1 in that case.  */
end_comment

begin_function
specifier|static
name|int
name|write_sgl_to_txd
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|,
name|struct
name|sgl
modifier|*
name|sgl
parameter_list|,
name|caddr_t
modifier|*
name|to
parameter_list|)
block|{
name|__be64
modifier|*
name|flitp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|ulptx_sgl
modifier|*
name|usgl
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|padded
decl_stmt|;
name|KASSERT
argument_list|(
name|sgl
operator|->
name|nsegs
operator|>
literal|0
operator|&&
name|sgl
operator|->
name|nflits
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: bad SGL - nsegs=%d, nflits=%d"
operator|,
name|__func__
operator|,
name|sgl
operator|->
name|nsegs
operator|,
name|sgl
operator|->
name|nflits
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: SGL must start at a 16 byte boundary: %p"
operator|,
name|__func__
operator|,
operator|*
name|to
operator|)
argument_list|)
expr_stmt|;
name|flitp
operator|=
operator|(
name|__be64
operator|*
operator|)
operator|(
operator|*
name|to
operator|)
expr_stmt|;
name|end
operator|=
name|flitp
operator|+
name|sgl
operator|->
name|nflits
expr_stmt|;
name|seg
operator|=
operator|&
name|sgl
operator|->
name|seg
index|[
literal|0
index|]
expr_stmt|;
name|usgl
operator|=
operator|(
name|void
operator|*
operator|)
name|flitp
expr_stmt|;
comment|/* 	 * We start at a 16 byte boundary somewhere inside the tx descriptor 	 * ring, so we're at least 16 bytes away from the status page.  There is 	 * no chance of a wrap around in the middle of usgl (which is 16 bytes). 	 */
name|usgl
operator|->
name|cmd_nsge
operator|=
name|htobe32
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TX_SC_DSGL
argument_list|)
operator||
name|V_ULPTX_NSGE
argument_list|(
name|sgl
operator|->
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|len0
operator|=
name|htobe32
argument_list|(
name|seg
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|addr0
operator|=
name|htobe64
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|seg
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|end
operator|<=
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|spg
condition|)
block|{
comment|/* Won't wrap around at all */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sgl
operator|->
name|nsegs
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|seg
operator|++
control|)
block|{
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|len
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|seg
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|addr
index|[
name|i
operator|&
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|usgl
operator|->
name|sge
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|len
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Will wrap somewhere in the rest of the SGL */
comment|/* 2 flits already written, write the rest flit by flit */
name|flitp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|usgl
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sgl
operator|->
name|nflits
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|flitp
operator|==
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|spg
condition|)
name|flitp
operator|=
operator|(
name|void
operator|*
operator|)
name|eq
operator|->
name|desc
expr_stmt|;
operator|*
name|flitp
operator|++
operator|=
name|get_flit
argument_list|(
name|seg
argument_list|,
name|sgl
operator|->
name|nsegs
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|flitp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|end
operator|&
literal|0xf
condition|)
block|{
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|padded
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|padded
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|end
operator|==
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|spg
condition|)
operator|*
name|to
operator|=
operator|(
name|void
operator|*
operator|)
name|eq
operator|->
name|desc
expr_stmt|;
else|else
operator|*
name|to
operator|=
operator|(
name|void
operator|*
operator|)
name|end
expr_stmt|;
return|return
operator|(
name|padded
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|copy_to_txd
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|,
name|caddr_t
name|from
parameter_list|,
name|caddr_t
modifier|*
name|to
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
operator|+
name|len
operator|<=
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|spg
condition|)
block|{
name|bcopy
argument_list|(
name|from
argument_list|,
operator|*
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|to
operator|)
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|int
name|portion
init|=
operator|(
name|uintptr_t
operator|)
name|eq
operator|->
name|spg
operator|-
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|to
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|from
argument_list|,
operator|*
name|to
argument_list|,
name|portion
argument_list|)
expr_stmt|;
name|from
operator|+=
name|portion
expr_stmt|;
name|portion
operator|=
name|len
operator|-
name|portion
expr_stmt|;
comment|/* remaining */
name|bcopy
argument_list|(
name|from
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eq
operator|->
name|desc
argument_list|,
name|portion
argument_list|)
expr_stmt|;
operator|(
operator|*
name|to
operator|)
operator|=
operator|(
name|caddr_t
operator|)
name|eq
operator|->
name|desc
operator|+
name|portion
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ring_tx_db
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|t4_write_reg
argument_list|(
name|sc
argument_list|,
name|MYPF_REG
argument_list|(
name|A_SGE_PF_KDOORBELL
argument_list|)
argument_list|,
name|V_QID
argument_list|(
name|eq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_PIDX
argument_list|(
name|eq
operator|->
name|pending
argument_list|)
argument_list|)
expr_stmt|;
name|eq
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|reclaimable
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|unsigned
name|int
name|cidx
decl_stmt|;
name|cidx
operator|=
name|eq
operator|->
name|spg
operator|->
name|cidx
expr_stmt|;
comment|/* stable snapshot */
name|cidx
operator|=
name|be16_to_cpu
argument_list|(
name|cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cidx
operator|>=
name|eq
operator|->
name|cidx
condition|)
return|return
operator|(
name|cidx
operator|-
name|eq
operator|->
name|cidx
operator|)
return|;
else|else
return|return
operator|(
name|cidx
operator|+
name|eq
operator|->
name|cap
operator|-
name|eq
operator|->
name|cidx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * There are "can_reclaim" tx descriptors ready to be reclaimed.  Reclaim as  * many as possible but stop when there are around "n" mbufs to free.  *  * The actual number reclaimed is provided as the return value.  */
end_comment

begin_function
specifier|static
name|int
name|reclaim_tx_descs
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|,
name|int
name|can_reclaim
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|tx_map
modifier|*
name|txm
decl_stmt|;
name|unsigned
name|int
name|reclaimed
decl_stmt|,
name|maps
decl_stmt|;
name|EQ_LOCK_ASSERT_OWNED
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_reclaim
operator|==
literal|0
condition|)
name|can_reclaim
operator|=
name|reclaimable
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|maps
operator|=
name|reclaimed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|can_reclaim
operator|&&
name|maps
operator|<
name|n
condition|)
block|{
name|int
name|ndesc
decl_stmt|;
name|txsd
operator|=
operator|&
name|eq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|cidx
index|]
expr_stmt|;
name|ndesc
operator|=
name|txsd
operator|->
name|desc_used
expr_stmt|;
comment|/* Firmware doesn't return "partial" credits. */
name|KASSERT
argument_list|(
name|can_reclaim
operator|>=
name|ndesc
argument_list|,
operator|(
literal|"%s: unexpected number of credits: %d, %d"
operator|,
name|__func__
operator|,
name|can_reclaim
operator|,
name|ndesc
operator|)
argument_list|)
expr_stmt|;
name|maps
operator|+=
name|txsd
operator|->
name|map_used
expr_stmt|;
name|reclaimed
operator|+=
name|ndesc
expr_stmt|;
name|can_reclaim
operator|-=
name|ndesc
expr_stmt|;
name|eq
operator|->
name|cidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|eq
operator|->
name|cidx
operator|>=
name|eq
operator|->
name|cap
argument_list|)
condition|)
name|eq
operator|->
name|cidx
operator|-=
name|eq
operator|->
name|cap
expr_stmt|;
block|}
name|txm
operator|=
operator|&
name|eq
operator|->
name|maps
index|[
name|eq
operator|->
name|map_cidx
index|]
expr_stmt|;
if|if
condition|(
name|maps
condition|)
name|prefetch
argument_list|(
name|txm
operator|->
name|m
argument_list|)
expr_stmt|;
name|eq
operator|->
name|avail
operator|+=
name|reclaimed
expr_stmt|;
name|KASSERT
argument_list|(
name|eq
operator|->
name|avail
operator|<
name|eq
operator|->
name|cap
argument_list|,
comment|/* avail tops out at (cap - 1) */
operator|(
literal|"%s: too many descriptors available"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|eq
operator|->
name|map_avail
operator|+=
name|maps
expr_stmt|;
name|KASSERT
argument_list|(
name|eq
operator|->
name|map_avail
operator|<=
name|eq
operator|->
name|map_total
argument_list|,
operator|(
literal|"%s: too many maps available"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|maps
operator|--
condition|)
block|{
name|struct
name|tx_map
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|txm
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|eq
operator|->
name|map_cidx
operator|+
literal|1
operator|==
name|eq
operator|->
name|map_total
argument_list|)
condition|)
name|next
operator|=
name|eq
operator|->
name|maps
expr_stmt|;
name|prefetch
argument_list|(
name|next
operator|->
name|m
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|eq
operator|->
name|tx_tag
argument_list|,
name|txm
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txm
operator|->
name|m
argument_list|)
expr_stmt|;
name|txm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|txm
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|eq
operator|->
name|map_cidx
operator|==
name|eq
operator|->
name|map_total
argument_list|)
condition|)
name|eq
operator|->
name|map_cidx
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|reclaimed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_eqflush_wr
parameter_list|(
name|struct
name|sge_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|fw_eq_flush_wr
modifier|*
name|wr
decl_stmt|;
name|struct
name|tx_sdesc
modifier|*
name|txsd
decl_stmt|;
name|EQ_LOCK_ASSERT_OWNED
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|eq
operator|->
name|avail
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: no descriptors left."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|eq
operator|->
name|desc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|bzero
argument_list|(
name|wr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|->
name|opcode
operator|=
name|FW_EQ_FLUSH_WR
expr_stmt|;
name|wr
operator|->
name|equiq_to_len16
operator|=
name|htobe32
argument_list|(
name|V_FW_WR_LEN16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
operator|/
literal|16
argument_list|)
operator||
name|F_FW_WR_EQUEQ
operator||
name|F_FW_WR_EQUIQ
argument_list|)
expr_stmt|;
name|txsd
operator|=
operator|&
name|eq
operator|->
name|sdesc
index|[
name|eq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|->
name|desc_used
operator|=
literal|1
expr_stmt|;
name|txsd
operator|->
name|map_used
operator|=
literal|0
expr_stmt|;
name|eq
operator|->
name|pending
operator|++
expr_stmt|;
name|eq
operator|->
name|avail
operator|--
expr_stmt|;
if|if
condition|(
operator|++
name|eq
operator|->
name|pidx
operator|==
name|eq
operator|->
name|cap
condition|)
name|eq
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__be64
name|get_flit
parameter_list|(
name|bus_dma_segment_t
modifier|*
name|sgl
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|idx
operator|/
literal|3
operator|)
operator|*
literal|2
decl_stmt|;
switch|switch
condition|(
name|idx
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
block|{
name|__be64
name|rc
decl_stmt|;
name|rc
operator|=
name|htobe32
argument_list|(
name|sgl
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nsegs
condition|)
name|rc
operator||=
operator|(
name|uint64_t
operator|)
name|htobe32
argument_list|(
name|sgl
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ds_len
argument_list|)
operator|<<
literal|32
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
case|case
literal|1
case|:
return|return
name|htobe64
argument_list|(
name|sgl
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|htobe64
argument_list|(
name|sgl
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ds_addr
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_fl_tag_idx
parameter_list|(
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|FL_LOCK_ASSERT_OWNED
argument_list|(
name|fl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FL_BUF_SIZES
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FL_BUF_SIZE
argument_list|(
name|i
argument_list|)
operator|>=
operator|(
name|mtu
operator|+
name|FL_PKTSHIFT
operator|)
condition|)
break|break;
block|}
name|fl
operator|->
name|tag_idx
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|handle_sge_egr_update
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|cpl_sge_egr_update
modifier|*
name|cpl
parameter_list|)
block|{
name|unsigned
name|int
name|qid
init|=
name|G_EGR_QID
argument_list|(
name|ntohl
argument_list|(
name|cpl
operator|->
name|opcode_qid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|sge
modifier|*
name|s
init|=
operator|&
name|sc
operator|->
name|sge
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|txq
operator|=
operator|(
name|void
operator|*
operator|)
name|s
operator|->
name|eqmap
index|[
name|qid
operator|-
name|s
operator|->
name|eq_start
index|]
expr_stmt|;
name|pi
operator|=
name|txq
operator|->
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pi
operator|->
name|tq
argument_list|,
operator|&
name|txq
operator|->
name|resume_tx
argument_list|)
expr_stmt|;
name|txq
operator|->
name|egr_update
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

