begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, University of Vermont and State  *  Agricultural College.  * Copyright (c) 1992, 1993, Garrett A. Wollman.  *  * Portions:  * Copyright (c) 1990, 1991, William F. Jolitz  * Copyright (c) 1990, The Regents of the University of California  *  * 3Com 3C507 support:  * Copyright (c) 1993, 1994, Charles M. Hannum  *  * EtherExpress 16 support:  * Copyright (c) 1993, 1994, 1995, Rodney W. Grimes  * Copyright (c) 1997, Aaron C. Smith  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	Vermont and State Agricultural College and Garrett A. Wollman, by  *	William F. Jolitz, by the University of California, Berkeley,  *	Lawrence Berkeley Laboratory, and their contributors, by  *	Charles M. Hannum, by Rodney W. Grimes, and by Aaron C. Smith.  * 4. Neither the names of the Universities nor the names of the authors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR AUTHORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Intel 82586 Ethernet chip  * Register, bit, and structure definitions.  *  * Written by GAW with reference to the Clarkson Packet Driver code for this  * chip written by Russ Nelson and others.  *  * Intel EtherExpress 16 support from if_ix.c, written by Rodney W. Grimes.  */
end_comment

begin_comment
comment|/*  * The i82586 is a very versatile chip, found in many implementations.  * Programming this chip is mostly the same, but certain details differ  * from card to card.  This driver is written so that different cards  * can be automatically detected at run-time.  */
end_comment

begin_comment
comment|/* Mode of operation:  We run the 82586 in a standard Ethernet mode.  We keep NFRAMES received frame descriptors around for the receiver to use, and NRXBUFS associated receive buffer descriptors, both in a circular list.  Whenever a frame is received, we rotate both lists as necessary.  (The 586 treats both lists as a simple queue.)  We also keep a transmit command around so that packets can be sent off quickly.  We configure the adapter in AL-LOC = 1 mode, which means that the Ethernet/802.3 MAC header is placed at the beginning of the receive buffer rather than being split off into various fields in the RFD.  This also means that we must include this header in the transmit buffer as well.  By convention, all transmit commands, and only transmit commands, shall have the I (IE_CMD_INTR) bit set in the command.  This way, when an interrupt arrives at ieintr(), it is immediately possible to tell what precisely caused it.  ANY OTHER command-sending routines should run at splimp(), and should post an acknowledgement to every interrupt they generate.  The 82586 has a 24-bit address space internally, and the adaptor's memory is located at the top of this region.  However, the value we are given in configuration is normally the *bottom* of the adaptor RAM.  So, we must go through a few gyrations to come up with a kernel virtual address which represents the actual beginning of the 586 address space.  First, we autosize the RAM by running through several possible sizes and trying to initialize the adapter under the assumption that the selected size is correct.  Then, knowing the correct RAM size, we set up our pointers in ie_softc[unit].  `iomem' represents the computed base of the 586 address space.  `iomembot' represents the actual configured base of adapter RAM. Finally, `iosize' represents the calculated size of 586 RAM.  Then, when laying out commands, we use the interval [iomembot, iomembot + iosize); to make 24-pointers, we subtract iomem, and to make 16-pointers, we subtract iomem and and with 0xffff.  */
end_comment

begin_include
include|#
directive|include
file|"ie.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/i82586.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<dev/ie/if_iereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ie/if_ie507.h>
end_include

begin_include
include|#
directive|include
file|<dev/ie/if_iee16.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/elink.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|IED_RINT
value|0x01
end_define

begin_define
define|#
directive|define
name|IED_TINT
value|0x02
end_define

begin_define
define|#
directive|define
name|IED_RNR
value|0x04
end_define

begin_define
define|#
directive|define
name|IED_CNA
value|0x08
end_define

begin_define
define|#
directive|define
name|IED_READFRAME
value|0x10
end_define

begin_decl_stmt
specifier|static
name|int
name|ie_debug
init|=
name|IED_RNR
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IE_BUF_LEN
value|ETHER_MAX_LEN
end_define

begin_comment
comment|/* length of transmit buffer */
end_comment

begin_comment
comment|/* Forward declaration */
end_comment

begin_struct_decl
struct_decl|struct
name|ie_softc
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|ieprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ointhand2_t
name|ieintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sl_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ni_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ee16_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_ie_present
parameter_list|(
name|int
name|unit
parameter_list|,
name|caddr_t
name|where
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_stop
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iestart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_reset_586
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_chan_attn
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sl_reset_586
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sl_chan_attn
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ee16_reset_586
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ee16_chan_attn
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ee16_interrupt_enable
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ee16_eeprom_outbits
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|edata
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ee16_eeprom_clock
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|ee16_read_eeprom
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|location
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ee16_eeprom_inbits
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ee16_shutdown
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iereset
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_readframe
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|bufno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_drop_packet_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sl_read_ether
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|char
name|addr
index|[
literal|6
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_ie_mem_size
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chan_attn_timeout
parameter_list|(
name|void
modifier|*
name|rock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|command_and_wait
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|command
parameter_list|,
name|void
specifier|volatile
modifier|*
name|pcmd
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run_tdr
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|volatile
name|struct
name|ie_tdr_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ierint
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ietint
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iernr
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_receiver
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ieget
parameter_list|(
name|int
parameter_list|,
name|struct
name|ie_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ether_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|v_caddr_t
name|setup_rfa
parameter_list|(
name|v_caddr_t
name|ptr
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mc_setup
parameter_list|(
name|int
parameter_list|,
name|v_caddr_t
parameter_list|,
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_mc_reset
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|print_rbd
parameter_list|(
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|in_ierint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_ietint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This tells the autoconf code how to set us up.  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|iedriver
init|=
block|{
name|ieprobe
block|,
name|ieattach
block|,
literal|"ie"
block|, }
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|ie_hardware
block|{
name|IE_STARLAN10
block|,
name|IE_EN100
block|,
name|IE_SLFIBER
block|,
name|IE_3C507
block|,
name|IE_NI5210
block|,
name|IE_EE16
block|,
name|IE_UNKNOWN
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ie_hardware_names
index|[]
init|=
block|{
literal|"StarLAN 10"
block|,
literal|"EN100"
block|,
literal|"StarLAN Fiber"
block|,
literal|"3C507"
block|,
literal|"NI5210"
block|,
literal|"EtherExpress 16"
block|,
literal|"Unknown"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sizeof(iscp) == 1+1+2+4 == 8 sizeof(scb) == 2+2+2+2+2+2+2+2 == 16 NFRAMES * sizeof(rfd) == NFRAMES*(2+2+2+2+6+6+2+2) == NFRAMES*24 == 384 sizeof(xmit_cmd) == 2+2+2+2+6+2 == 18 sizeof(transmit buffer) == 1512 sizeof(transmit buffer desc) == 8 ----- 1946  NRXBUFS * sizeof(rbd) == NRXBUFS*(2+2+4+2+2) == NRXBUFS*12 NRXBUFS * IE_RBUF_SIZE == NRXBUFS*256  NRXBUFS should be (16384 - 1946) / (256 + 12) == 14438 / 268 == 53  With NRXBUFS == 48, this leaves us 1574 bytes for another command or more buffers.  Another transmit command would be 18+8+1512 == 1538 ---just barely fits!  Obviously all these would have to be reduced for smaller memory sizes. With a larger memory, it would be possible to roughly double the number of both transmit and receive buffers. */
end_comment

begin_define
define|#
directive|define
name|NFRAMES
value|8
end_define

begin_comment
comment|/* number of receive frames */
end_comment

begin_define
define|#
directive|define
name|NRXBUFS
value|48
end_define

begin_comment
comment|/* number of buffers to allocate */
end_comment

begin_define
define|#
directive|define
name|IE_RBUF_SIZE
value|256
end_define

begin_comment
comment|/* size of each buffer, MUST BE POWER OF TWO */
end_comment

begin_define
define|#
directive|define
name|NTXBUFS
value|2
end_define

begin_comment
comment|/* number of transmit commands */
end_comment

begin_define
define|#
directive|define
name|IE_TBUF_SIZE
value|ETHER_MAX_LEN
end_define

begin_comment
comment|/* size of transmit buffer */
end_comment

begin_comment
comment|/*  * Ethernet status, per interface.  */
end_comment

begin_struct
specifier|static
struct|struct
name|ie_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
name|void
function_decl|(
modifier|*
name|ie_reset_586
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|ie_chan_attn
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|enum
name|ie_hardware
name|hard_type
decl_stmt|;
name|int
name|hard_vers
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|u_short
name|port
decl_stmt|;
comment|/* i/o base address for this interface */
name|caddr_t
name|iomem
decl_stmt|;
comment|/* memory size */
name|caddr_t
name|iomembot
decl_stmt|;
comment|/* memory base address */
name|unsigned
name|iosize
decl_stmt|;
name|int
name|bus_use
decl_stmt|;
comment|/* 0 means 16bit, 1 means 8 bit adapter */
name|int
name|want_mcsetup
decl_stmt|;
name|int
name|promisc
decl_stmt|;
name|int
name|nframes
decl_stmt|;
name|int
name|nrxbufs
decl_stmt|;
name|int
name|ntxbufs
decl_stmt|;
specifier|volatile
name|struct
name|ie_int_sys_conf_ptr
modifier|*
name|iscp
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
decl_stmt|;
specifier|volatile
name|struct
name|ie_recv_frame_desc
modifier|*
modifier|*
name|rframes
decl_stmt|;
comment|/* nframes worth */
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
modifier|*
name|rbuffs
decl_stmt|;
comment|/* nrxbufs worth */
specifier|volatile
name|u_char
modifier|*
modifier|*
name|cbuffs
decl_stmt|;
comment|/* nrxbufs worth */
name|int
name|rfhead
decl_stmt|,
name|rftail
decl_stmt|,
name|rbhead
decl_stmt|,
name|rbtail
decl_stmt|;
specifier|volatile
name|struct
name|ie_xmit_cmd
modifier|*
modifier|*
name|xmit_cmds
decl_stmt|;
comment|/* ntxbufs worth */
specifier|volatile
name|struct
name|ie_xmit_buf
modifier|*
modifier|*
name|xmit_buffs
decl_stmt|;
comment|/* ntxbufs worth */
specifier|volatile
name|u_char
modifier|*
modifier|*
name|xmit_cbuffs
decl_stmt|;
comment|/* ntxbufs worth */
name|int
name|xmit_count
decl_stmt|;
name|struct
name|ie_en_addr
name|mcast_addrs
index|[
name|MAXMCAST
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|mcast_count
decl_stmt|;
name|u_short
name|irq_encoded
decl_stmt|;
comment|/* encoded interrupt on IEE16 */
block|}
name|ie_softc
index|[
name|NIE
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|MK_24
parameter_list|(
name|base
parameter_list|,
name|ptr
parameter_list|)
value|((caddr_t)((uintptr_t)ptr - (uintptr_t)base))
end_define

begin_define
define|#
directive|define
name|MK_16
parameter_list|(
name|base
parameter_list|,
name|ptr
parameter_list|)
value|((u_short)(uintptr_t)MK_24(base, ptr))
end_define

begin_define
define|#
directive|define
name|PORT
value|ie_softc[unit].port
end_define

begin_define
define|#
directive|define
name|MEM
value|ie_softc[unit].iomem
end_define

begin_function
name|int
name|ieprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sl_probe
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|el_probe
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|ni_probe
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|ee16_probe
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sl_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomembot
operator|=
name|dvp
operator|->
name|id_maddr
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomem
operator|=
literal|0
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|bus_use
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IEATT_REVISION
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SL_BOARD
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|SL10_BOARD
case|:
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
operator|=
name|IE_STARLAN10
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|=
name|sl_reset_586
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|=
name|sl_chan_attn
expr_stmt|;
break|break;
case|case
name|EN100_BOARD
case|:
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
operator|=
name|IE_EN100
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|=
name|sl_reset_586
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|=
name|sl_chan_attn
expr_stmt|;
break|break;
case|case
name|SLFIBER_BOARD
case|:
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
operator|=
name|IE_SLFIBER
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|=
name|sl_reset_586
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|=
name|sl_chan_attn
expr_stmt|;
break|break;
comment|/* 		 * Anything else is not recognized or cannot be used. 		 */
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_vers
operator|=
name|SL_REV
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Divine memory size on-board the card.  Ususally 16k. 	 */
name|find_ie_mem_size
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dvp
operator|->
name|id_msize
operator|=
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
expr_stmt|;
switch|switch
condition|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
condition|)
block|{
case|case
name|IE_EN100
case|:
case|case
name|IE_STARLAN10
case|:
case|case
name|IE_SLFIBER
case|:
name|sl_read_ether
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ie%d: unknown AT&T board type code %d\n"
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|el_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
init|=
operator|&
name|ie_softc
index|[
name|dvp
operator|->
name|id_unit
index|]
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|signature
index|[]
init|=
literal|"*3COM*"
decl_stmt|;
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|iomembot
operator|=
name|dvp
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|bus_use
operator|=
literal|0
expr_stmt|;
comment|/* Need this for part of the probe. */
name|sc
operator|->
name|ie_reset_586
operator|=
name|el_reset_586
expr_stmt|;
name|sc
operator|->
name|ie_chan_attn
operator|=
name|el_chan_attn
expr_stmt|;
comment|/* Reset and put card in CONFIG state without changing address. */
name|elink_reset
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ELINK_ID_PORT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|elink_idseq
argument_list|(
name|ELINK_507_POLY
argument_list|)
expr_stmt|;
name|elink_idseq
argument_list|(
name|ELINK_507_POLY
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ELINK_ID_PORT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IE507_MADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x20
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"ie%d: can't map 3C507 RAM in high memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* go to RUN state */
name|outb
argument_list|(
name|ELINK_ID_PORT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|elink_idseq
argument_list|(
name|ELINK_507_POLY
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ELINK_ID_PORT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_NRST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inb
argument_list|(
name|PORT
operator|+
name|i
argument_list|)
operator|!=
name|signature
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IE507_IRQ
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|id_irq
operator|!=
operator|(
literal|1
operator|<<
name|c
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: kernel configured irq %d "
literal|"doesn't match board configured irq %d\n"
argument_list|,
name|unit
argument_list|,
name|ffs
argument_list|(
name|dvp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|=
operator|(
name|inb
argument_list|(
name|PORT
operator|+
name|IE507_MADDR
argument_list|)
operator|&
literal|0x1c
operator|)
operator|+
literal|0xc0
expr_stmt|;
if|if
condition|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|!=
operator|(
operator|(
name|int
operator|)
name|c
operator|<<
literal|12
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: kernel configured maddr %lx "
literal|"doesn't match board configured maddr %x\n"
argument_list|,
name|unit
argument_list|,
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|c
operator|<<
literal|12
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_NORMAL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hard_type
operator|=
name|IE_3C507
expr_stmt|;
name|sc
operator|->
name|hard_vers
operator|=
literal|0
expr_stmt|;
comment|/* 3C507 has no version number. */
comment|/* 	 * Divine memory size on-board the card. 	 */
name|find_ie_mem_size
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|iosize
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: can't find shared memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_NRST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dvp
operator|->
name|id_msize
condition|)
name|dvp
operator|->
name|id_msize
operator|=
name|sc
operator|->
name|iosize
expr_stmt|;
elseif|else
if|if
condition|(
name|dvp
operator|->
name|id_msize
operator|!=
name|sc
operator|->
name|iosize
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: kernel configured msize %d "
literal|"doesn't match board configured msize %d\n"
argument_list|,
name|unit
argument_list|,
name|dvp
operator|->
name|id_msize
argument_list|,
name|sc
operator|->
name|iosize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_NRST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sl_read_ether
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt latch just in case. */
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_ICTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|16
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ni_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|int
name|boardtype
decl_stmt|,
name|c
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomembot
operator|=
name|dvp
operator|->
name|id_maddr
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomem
operator|=
literal|0
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|bus_use
operator|=
literal|1
expr_stmt|;
name|boardtype
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IEATT_REVISION
argument_list|)
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IEATT_REVISION
operator|+
literal|1
argument_list|)
expr_stmt|;
name|boardtype
operator|=
name|boardtype
operator|+
operator|(
name|c
operator|<<
literal|8
operator|)
expr_stmt|;
switch|switch
condition|(
name|boardtype
condition|)
block|{
case|case
literal|0x5500
case|:
comment|/* This is the magic cookie for the NI5210 */
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
operator|=
name|IE_NI5210
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|=
name|sl_reset_586
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|=
name|sl_chan_attn
expr_stmt|;
break|break;
comment|/* 		 * Anything else is not recognized or cannot be used. 		 */
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_vers
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Divine memory size on-board the card.  Either 8 or 16k. 	 */
name|find_ie_mem_size
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dvp
operator|->
name|id_msize
condition|)
name|dvp
operator|->
name|id_msize
operator|=
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
expr_stmt|;
elseif|else
if|if
condition|(
name|dvp
operator|->
name|id_msize
operator|!=
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: kernel configured msize %d "
literal|"doesn't match board configured msize %d\n"
argument_list|,
name|unit
argument_list|,
name|dvp
operator|->
name|id_msize
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sl_read_ether
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ee16_shutdown
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|(
expr|struct
name|ie_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|int
name|unit
init|=
name|ie
operator|-
operator|&
name|ie_softc
index|[
literal|0
index|]
decl_stmt|;
name|ee16_reset_586
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_ECTRL
argument_list|,
name|IEE16_RESET_ASIC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_ECTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Taken almost exactly from Rod's if_ix.c. */
end_comment

begin_function
name|int
name|ee16_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
init|=
operator|&
name|ie_softc
index|[
name|dvp
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|u_short
name|board_id
decl_stmt|,
name|id_var1
decl_stmt|,
name|id_var2
decl_stmt|,
name|checksum
init|=
literal|0
decl_stmt|;
name|u_short
name|eaddrtemp
decl_stmt|,
name|irq
decl_stmt|;
name|u_short
name|pg
decl_stmt|,
name|adjust
decl_stmt|,
name|decode
decl_stmt|,
name|edecode
decl_stmt|;
name|u_char
name|bart_config
decl_stmt|;
name|u_long
name|bd_maddr
decl_stmt|;
name|short
name|irq_translate
index|[]
init|=
block|{
literal|0
block|,
name|IRQ9
block|,
name|IRQ3
block|,
name|IRQ4
block|,
name|IRQ5
block|,
name|IRQ10
block|,
name|IRQ11
block|,
literal|0
block|}
decl_stmt|;
name|char
name|irq_encode
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* Need this for part of the probe. */
name|sc
operator|->
name|ie_reset_586
operator|=
name|ee16_reset_586
expr_stmt|;
name|sc
operator|->
name|ie_chan_attn
operator|=
name|ee16_chan_attn
expr_stmt|;
comment|/* unsure if this is necessary */
name|sc
operator|->
name|bus_use
operator|=
literal|0
expr_stmt|;
comment|/* reset any ee16 at the current iobase */
name|outb
argument_list|(
name|dvp
operator|->
name|id_iobase
operator|+
name|IEE16_ECTRL
argument_list|,
name|IEE16_RESET_ASIC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dvp
operator|->
name|id_iobase
operator|+
name|IEE16_ECTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|240
argument_list|)
expr_stmt|;
comment|/* now look for ee16. */
name|board_id
operator|=
name|id_var1
operator|=
name|id_var2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|id_var1
operator|=
name|inb
argument_list|(
name|dvp
operator|->
name|id_iobase
operator|+
name|IEE16_ID_PORT
argument_list|)
expr_stmt|;
name|id_var2
operator|=
operator|(
operator|(
name|id_var1
operator|&
literal|0x03
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|board_id
operator||=
operator|(
operator|(
name|id_var1
operator|>>
literal|4
operator|)
operator|<<
name|id_var2
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|board_id
operator|!=
name|IEE16_ID
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ie%d: unknown board_id: %x\n"
argument_list|,
name|unit
argument_list|,
name|board_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* need sc->port for ee16_read_eeprom */
name|sc
operator|->
name|port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|hard_type
operator|=
name|IE_EE16
expr_stmt|;
comment|/* 	 * The shared RAM location on the EE16 is encoded into bits 3-7 of 	 * EEPROM location 6.  We zero the upper byte, and shift the 5 bits 	 * right 3.  The resulting number tells us the RAM location. 	 * Because the EE16 supports either 16k or 32k of shared RAM, we 	 * only worry about the 32k locations. 	 * 	 * NOTE: if a 64k EE16 exists, it should be added to this switch. then 	 * the ia->ia_msize would need to be set per case statement. 	 * 	 * value	msize	location =====	=====	======== 0x03	0x8000 	 * 0xCC000 0x06	0x8000	0xD0000 0x0C	0x8000	0xD4000 0x18 	 * 0x8000	0xD8000 	 * 	 */
name|bd_maddr
operator|=
literal|0
expr_stmt|;
name|i
operator|=
operator|(
name|ee16_read_eeprom
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|)
operator|&
literal|0x00ff
operator|)
operator|>>
literal|3
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0x03
case|:
name|bd_maddr
operator|=
literal|0xCC000
expr_stmt|;
break|break;
case|case
literal|0x06
case|:
name|bd_maddr
operator|=
literal|0xD0000
expr_stmt|;
break|break;
case|case
literal|0x0c
case|:
name|bd_maddr
operator|=
literal|0xD4000
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|bd_maddr
operator|=
literal|0xD8000
expr_stmt|;
break|break;
default|default:
name|bd_maddr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dvp
operator|->
name|id_msize
operator|=
literal|0x8000
expr_stmt|;
if|if
condition|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|!=
name|bd_maddr
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: kernel configured maddr %lx "
literal|"doesn't match board configured maddr %lx\n"
argument_list|,
name|unit
argument_list|,
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
argument_list|,
name|bd_maddr
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|iomembot
operator|=
name|dvp
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|iomem
operator|=
literal|0
expr_stmt|;
comment|/* XXX some probes set this and some don't */
name|sc
operator|->
name|iosize
operator|=
name|dvp
operator|->
name|id_msize
expr_stmt|;
comment|/* need to put the 586 in RESET while we access the eeprom. */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_ECTRL
argument_list|,
name|IEE16_RESET_586
argument_list|)
expr_stmt|;
comment|/* read the eeprom and checksum it, should == IEE16_ID */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x40
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
name|ee16_read_eeprom
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|IEE16_ID
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: invalid eeprom checksum: %x\n"
argument_list|,
name|unit
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Size and test the memory on the board.  The size of the memory 	 * can be one of 16k, 32k, 48k or 64k.	It can be located in the 	 * address range 0xC0000 to 0xEFFFF on 16k boundaries. 	 * 	 * If the size does not match the passed in memory allocation size 	 * issue a warning, but continue with the minimum of the two sizes. 	 */
switch|switch
condition|(
name|dvp
operator|->
name|id_msize
condition|)
block|{
case|case
literal|65536
case|:
case|case
literal|32768
case|:
comment|/* XXX Only support 32k and 64k right now */
break|break;
case|case
literal|16384
case|:
case|case
literal|49512
case|:
default|default:
name|printf
argument_list|(
literal|"ie%d: mapped memory size %d not supported\n"
argument_list|,
name|unit
argument_list|,
name|dvp
operator|->
name|id_msize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|<
literal|0xC0000
operator|)
operator|||
operator|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|+
name|sc
operator|->
name|iosize
operator|>
literal|0xF0000
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: mapped memory location %p out of range\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dvp
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pg
operator|=
operator|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|&
literal|0x3C000
operator|)
operator|>>
literal|14
expr_stmt|;
name|adjust
operator|=
name|IEE16_MCTRL_FMCS16
operator||
operator|(
name|pg
operator|&
literal|0x3
operator|)
operator|<<
literal|2
expr_stmt|;
name|decode
operator|=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|sc
operator|->
name|iosize
operator|/
literal|16384
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|pg
expr_stmt|;
name|edecode
operator|=
operator|(
operator|(
operator|~
name|decode
operator|>>
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
name|decode
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* ZZZ This should be checked against eeprom location 6, low byte */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_MEMDEC
argument_list|,
name|decode
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ZZZ This should be checked against eeprom location 1, low byte */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_MCTRL
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
comment|/* ZZZ Now if I could find this one I would have it made */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_MPCTRL
argument_list|,
operator|(
operator|~
name|decode
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
comment|/* ZZZ I think this is location 6, high byte */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_MECTRL
argument_list|,
name|edecode
argument_list|)
expr_stmt|;
comment|/* XXX disable Exxx */
operator|(
name|void
operator|)
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
comment|/* 	 * first prime the stupid bart DRAM controller so that it works, 	 * then zero out all of memory. 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|iomembot
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|iomembot
argument_list|,
name|sc
operator|->
name|iosize
argument_list|)
expr_stmt|;
comment|/* 	 * Get the encoded interrupt number from the EEPROM, check it 	 * against the passed in IRQ.  Issue a warning if they do not match. 	 * Always use the passed in IRQ, not the one in the EEPROM. 	 */
name|irq
operator|=
name|ee16_read_eeprom
argument_list|(
name|sc
argument_list|,
name|IEE16_EEPROM_CONFIG1
argument_list|)
expr_stmt|;
name|irq
operator|=
operator|(
name|irq
operator|&
name|IEE16_EEPROM_IRQ
operator|)
operator|>>
name|IEE16_EEPROM_IRQ_SHIFT
expr_stmt|;
name|irq
operator|=
name|irq_translate
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|id_irq
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|irq
operator|!=
name|dvp
operator|->
name|id_irq
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: WARNING: board configured "
literal|"at irq %u, using %u\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|dvp
operator|->
name|id_irq
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|irq
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
block|}
block|}
else|else
block|{
name|dvp
operator|->
name|id_irq
operator|=
name|irq
expr_stmt|;
block|}
name|sc
operator|->
name|irq_encoded
operator|=
name|irq_encode
index|[
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 	 * Get the hardware ethernet address from the EEPROM and save it in 	 * the softc for use by the 586 setup code. 	 */
name|eaddrtemp
operator|=
name|ee16_read_eeprom
argument_list|(
name|sc
argument_list|,
name|IEE16_EEPROM_ENET_HIGH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
operator|=
name|eaddrtemp
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|=
name|eaddrtemp
operator|>>
literal|8
expr_stmt|;
name|eaddrtemp
operator|=
name|ee16_read_eeprom
argument_list|(
name|sc
argument_list|,
name|IEE16_EEPROM_ENET_MID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|3
index|]
operator|=
name|eaddrtemp
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|=
name|eaddrtemp
operator|>>
literal|8
expr_stmt|;
name|eaddrtemp
operator|=
name|ee16_read_eeprom
argument_list|(
name|sc
argument_list|,
name|IEE16_EEPROM_ENET_LOW
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|5
index|]
operator|=
name|eaddrtemp
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|4
index|]
operator|=
name|eaddrtemp
operator|>>
literal|8
expr_stmt|;
comment|/* disable the board interrupts */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_IRQ
argument_list|,
name|sc
operator|->
name|irq_encoded
argument_list|)
expr_stmt|;
comment|/* enable loopback to keep bad packets off the wire */
if|if
condition|(
name|sc
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
block|{
name|bart_config
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IEE16_CONFIG
argument_list|)
expr_stmt|;
name|bart_config
operator||=
name|IEE16_BART_LOOPBACK
expr_stmt|;
name|bart_config
operator||=
name|IEE16_BART_MCS16_TEST
expr_stmt|;
comment|/* inb doesn't get bit! */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_CONFIG
argument_list|,
name|bart_config
argument_list|)
expr_stmt|;
name|bart_config
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IEE16_CONFIG
argument_list|)
expr_stmt|;
block|}
comment|/* take the board out of reset state */
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_ECTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_ie_present
argument_list|(
name|unit
argument_list|,
name|dvp
operator|->
name|id_maddr
argument_list|,
name|sc
operator|->
name|iosize
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|16
operator|)
return|;
comment|/* return the number of I/O ports */
block|}
end_function

begin_comment
comment|/*  * Taken almost exactly from Bill's if_is.c, then modified beyond recognition.  */
end_comment

begin_function
name|int
name|ieattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|factor
decl_stmt|;
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|size_t
name|allocsize
decl_stmt|;
name|dvp
operator|->
name|id_ointr
operator|=
name|ieintr
expr_stmt|;
comment|/* 	 * based on the amount of memory we have, allocate our tx and rx 	 * resources. 	 */
name|factor
operator|=
name|dvp
operator|->
name|id_msize
operator|/
literal|16384
expr_stmt|;
name|ie
operator|->
name|nframes
operator|=
name|factor
operator|*
name|NFRAMES
expr_stmt|;
name|ie
operator|->
name|nrxbufs
operator|=
name|factor
operator|*
name|NRXBUFS
expr_stmt|;
name|ie
operator|->
name|ntxbufs
operator|=
name|factor
operator|*
name|NTXBUFS
expr_stmt|;
comment|/* 	 * Since all of these guys are arrays of pointers, allocate as one 	 * big chunk and dole out accordingly. 	 */
name|allocsize
operator|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|ie
operator|->
name|nframes
operator|+
operator|(
name|ie
operator|->
name|nrxbufs
operator|*
literal|2
operator|)
operator|+
operator|(
name|ie
operator|->
name|ntxbufs
operator|*
literal|3
operator|)
operator|)
expr_stmt|;
name|ie
operator|->
name|rframes
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_recv_frame_desc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|allocsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|rframes
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ie
operator|->
name|rbuffs
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_recv_buf_desc
operator|*
operator|*
operator|)
operator|&
name|ie
operator|->
name|rframes
index|[
name|ie
operator|->
name|nframes
index|]
expr_stmt|;
name|ie
operator|->
name|cbuffs
operator|=
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|nrxbufs
index|]
expr_stmt|;
name|ie
operator|->
name|xmit_cmds
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_xmit_cmd
operator|*
operator|*
operator|)
operator|&
name|ie
operator|->
name|cbuffs
index|[
name|ie
operator|->
name|nrxbufs
index|]
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_xmit_buf
operator|*
operator|*
operator|)
operator|&
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|ntxbufs
index|]
expr_stmt|;
name|ie
operator|->
name|xmit_cbuffs
operator|=
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|ntxbufs
index|]
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|ie
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
name|iedriver
operator|.
name|name
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|printf
argument_list|(
literal|"ie%d:<%s R%d> address %6D\n"
argument_list|,
name|unit
argument_list|,
name|ie_hardware_names
index|[
name|ie
operator|->
name|hard_type
index|]
argument_list|,
name|ie
operator|->
name|hard_vers
operator|+
literal|1
argument_list|,
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|iestart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ieioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ieinit
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|6
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
literal|14
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|ee16_shutdown
argument_list|,
name|ie
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * What to do upon receipt of an interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|ieintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|u_short
name|status
decl_stmt|;
comment|/* Clear the interrupt latch on the 3C507. */
if|if
condition|(
name|ie
operator|->
name|hard_type
operator|==
name|IE_3C507
operator|&&
operator|(
name|inb
argument_list|(
name|PORT
operator|+
name|IE507_CTRL
argument_list|)
operator|&
name|EL_CTRL_INTL
operator|)
condition|)
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_ICTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* disable interrupts on the EE16. */
if|if
condition|(
name|ie
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_IRQ
argument_list|,
name|ie
operator|->
name|irq_encoded
argument_list|)
expr_stmt|;
name|status
operator|=
name|ie
operator|->
name|scb
operator|->
name|ie_status
expr_stmt|;
name|loop
label|:
comment|/* Don't ack interrupts which we didn't receive */
name|ie_ack
argument_list|(
name|ie
operator|->
name|scb
argument_list|,
name|IE_ST_WHENCE
operator|&
name|status
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|ie_chan_attn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|IE_ST_RECV
operator||
name|IE_ST_RNR
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|in_ierint
operator|++
expr_stmt|;
if|if
condition|(
name|ie_debug
operator|&
name|IED_RINT
condition|)
name|printf
argument_list|(
literal|"ie%d: rint\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ierint
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|in_ierint
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|IE_ST_DONE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|in_ietint
operator|++
expr_stmt|;
if|if
condition|(
name|ie_debug
operator|&
name|IED_TINT
condition|)
name|printf
argument_list|(
literal|"ie%d: tint\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ietint
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|in_ietint
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|IE_ST_RNR
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ie_debug
operator|&
name|IED_RNR
condition|)
name|printf
argument_list|(
literal|"ie%d: rnr\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iernr
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|status
operator|&
name|IE_ST_ALLDONE
operator|)
operator|&&
operator|(
name|ie_debug
operator|&
name|IED_CNA
operator|)
condition|)
name|printf
argument_list|(
literal|"ie%d: cna\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|=
name|ie
operator|->
name|scb
operator|->
name|ie_status
operator|)
operator|&
name|IE_ST_WHENCE
condition|)
goto|goto
name|loop
goto|;
comment|/* Clear the interrupt latch on the 3C507. */
if|if
condition|(
name|ie
operator|->
name|hard_type
operator|==
name|IE_3C507
condition|)
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_ICTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* enable interrupts on the EE16. */
if|if
condition|(
name|ie
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_IRQ
argument_list|,
name|ie
operator|->
name|irq_encoded
operator||
name|IEE16_IRQ_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received-frame interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|ierint
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|status
decl_stmt|;
specifier|static
name|int
name|timesthru
init|=
literal|1024
decl_stmt|;
name|i
operator|=
name|ie
operator|->
name|rfhead
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|ie
operator|->
name|rframes
index|[
name|i
index|]
operator|->
name|ie_fd_status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|IE_FD_COMPLETE
operator|)
operator|&&
operator|(
name|status
operator|&
name|IE_FD_OK
operator|)
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|timesthru
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|+=
name|ie
operator|->
name|scb
operator|->
name|ie_err_crc
operator|+
name|ie
operator|->
name|scb
operator|->
name|ie_err_align
operator|+
name|ie
operator|->
name|scb
operator|->
name|ie_err_resource
operator|+
name|ie
operator|->
name|scb
operator|->
name|ie_err_overrun
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_crc
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_align
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_resource
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_overrun
operator|=
literal|0
expr_stmt|;
name|timesthru
operator|=
literal|1024
expr_stmt|;
block|}
name|ie_readframe
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|IE_FD_RNR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|scb
operator|->
name|ie_status
operator|&
name|IE_RU_READY
operator|)
condition|)
block|{
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
operator|->
name|ie_fd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rbuffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nframes
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a command-complete interrupt.  These are only generated by  * the transmission of frames.	This routine is deceptively simple, since  * most of the real work is done by iestart().  */
end_comment

begin_function
specifier|static
name|int
name|ietint
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|xmit_count
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|ie
operator|->
name|xmit_cmds
index|[
name|i
index|]
operator|->
name|ie_xmit_status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|IE_XS_LATECOLL
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: late collision\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_NOCARRIER
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: no carrier\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_LOSTCTS
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: lost CTS\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_UNDERRUN
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: DMA underrun\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_EXCMAX
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: too many collisions\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
name|status
operator|&
name|IE_XS_MAXCOLL
expr_stmt|;
block|}
block|}
name|ie
operator|->
name|xmit_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If multicast addresses were added or deleted while we were 	 * transmitting, ie_mc_reset() set the want_mcsetup flag indicating 	 * that we should do it. 	 */
if|if
condition|(
name|ie
operator|->
name|want_mcsetup
condition|)
block|{
name|mc_setup
argument_list|(
name|unit
argument_list|,
operator|(
name|v_caddr_t
operator|)
name|ie
operator|->
name|xmit_cbuffs
index|[
literal|0
index|]
argument_list|,
name|ie
operator|->
name|scb
argument_list|)
expr_stmt|;
name|ie
operator|->
name|want_mcsetup
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Wish I knew why this seems to be necessary... */
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
operator|->
name|ie_xmit_status
operator||=
name|IE_STAT_COMPL
expr_stmt|;
name|iestart
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* shouldn't be necessary */
block|}
end_function

begin_comment
comment|/*  * Process a receiver-not-ready interrupt.  I believe that we get these  * when there aren't enough buffers to go around.  For now (FIXME), we  * just restart the receiver, and hope everything's ok.  */
end_comment

begin_function
specifier|static
name|int
name|iernr
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|doesnt_work
name|setup_rfa
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* This doesn't work either, but it doesn't hang either. */
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just in case */
name|setup_rfa
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* was ENABLE */
endif|#
directive|endif
name|ie_ack
argument_list|(
name|ie
operator|->
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|ie_chan_attn
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two Ether/802 addresses for equality, inlined and  * unrolled for speed.	I'd love to have an inline assembler  * version of this...  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ether_equal
parameter_list|(
name|u_char
modifier|*
name|one
parameter_list|,
name|u_char
modifier|*
name|two
parameter_list|)
block|{
if|if
condition|(
name|one
index|[
literal|0
index|]
operator|!=
name|two
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|1
index|]
operator|!=
name|two
index|[
literal|1
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|2
index|]
operator|!=
name|two
index|[
literal|2
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|3
index|]
operator|!=
name|two
index|[
literal|3
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|4
index|]
operator|!=
name|two
index|[
literal|4
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|5
index|]
operator|!=
name|two
index|[
literal|5
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Determine quickly whether we should bother reading in this packet.  * This depends on whether BPF and/or bridging is enabled, whether we  * are receiving multicast address, and whether promiscuous mode is enabled.  * We assume that if IFF_PROMISC is set, then *somebody* wants to see  * all incoming packets.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|check_eh
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|)
block|{
comment|/* Optimize the common case: normal operation. We've received 	   either a unicast with our dest or a multicast packet. */
if|if
condition|(
name|ie
operator|->
name|promisc
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If not multicast, it's definitely for us */
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Accept broadcasts (loose but fast check) */
if|if
condition|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|==
literal|0xff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Compare against our multicast addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|mcast_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ie
operator|->
name|mcast_addrs
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Always accept packets when in promiscuous mode */
if|if
condition|(
operator|(
name|ie
operator|->
name|promisc
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Always accept packets directed at us */
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Must have IFF_ALLMULTI but not IFF_PROMISC set. The chip is 	   actually in promiscuous mode, so discard unicast packets. */
return|return
operator|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We want to isolate the bits that have meaning...  This assumes that  * IE_RBUF_SIZE is an even power of two.  If somehow the act_len exceeds  * the size of the buffer, then we are screwed anyway.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ie_buflen
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|head
parameter_list|)
block|{
return|return
operator|(
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|&
operator|(
name|IE_RBUF_SIZE
operator||
operator|(
name|IE_RBUF_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|ie_packet_len
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|head
init|=
name|ie
operator|->
name|rbhead
decl_stmt|;
name|int
name|acc
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_USED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|print_rbd
argument_list|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ie%d: receive descriptors out of sync at %d\n"
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|rbhead
argument_list|)
expr_stmt|;
name|iereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|=
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_LAST
expr_stmt|;
name|acc
operator|+=
name|ie_buflen
argument_list|(
name|ie
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nrxbufs
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|i
condition|)
do|;
return|return
operator|(
name|acc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read data off the interface, and turn it into an mbuf chain.  *  * This code is DRAMATICALLY different from the previous version; this  * version tries to allocate the entire mbuf chain up front, given the  * length of the data available.  This enables us to allocate mbuf  * clusters in many situations where before we would have had a long  * chain of partially-full mbufs.  This should help to speed up the  * operation considerably.  (Provided that it works, of course.)  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ieget
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|ether_header
modifier|*
name|ehp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mymp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|thismboff
decl_stmt|;
name|int
name|head
decl_stmt|;
name|totlen
operator|=
name|ie_packet_len
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|=
name|ie
operator|->
name|rbhead
expr_stmt|;
comment|/* 	 * Snarf the Ethernet header. 	 */
name|bcopy
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|ie
operator|->
name|cbuffs
index|[
name|i
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|ehp
argument_list|,
sizeof|sizeof
expr|*
name|ehp
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual warning here */
comment|/* 	 * As quickly as possible, check if this packet is for us. If not, 	 * don't waste a single cycle copying the rest of the packet in. 	 * This is only a consideration when FILTER is defined; i.e., when 	 * we are either running BPF or doing multicasting. 	 */
if|if
condition|(
operator|!
name|check_eh
argument_list|(
name|ie
argument_list|,
name|ehp
argument_list|)
condition|)
block|{
name|ie_drop_packet_buffer
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|--
expr_stmt|;
comment|/* just this case, it's not an 						 * error 						 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|totlen
operator|-=
operator|(
name|offset
operator|=
sizeof|sizeof
expr|*
name|ehp
operator|)
expr_stmt|;
name|MGETHDR
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|mp
condition|)
block|{
name|ie_drop_packet_buffer
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|resid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mymp
operator|=
operator|&
name|top
expr_stmt|;
comment|/* 	 * This loop goes through and allocates mbufs for all the data we 	 * will be copying in.	It does not actually do the copying yet. 	 */
do|do
block|{
comment|/* while(resid> 0) */
comment|/* 		 * Try to allocate an mbuf to hold the data that we have. 		 * If we already allocated one, just get another one and 		 * stick it on the end (eventually).  If we don't already 		 * have one, try to allocate an mbuf cluster big enough to 		 * hold the whole packet, if we think it's reasonable, or a 		 * single mbuf which may or may not be big enough. Got that? 		 */
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|ie_drop_packet_buffer
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|resid
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|resid
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
name|resid
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|resid
expr_stmt|;
block|}
block|}
name|resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|mymp
operator|=
name|m
expr_stmt|;
name|mymp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|resid
operator|>
literal|0
condition|)
do|;
name|resid
operator|=
name|totlen
expr_stmt|;
name|m
operator|=
name|top
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
name|head
operator|=
name|ie
operator|->
name|rbhead
expr_stmt|;
comment|/* 	 * Now we take the mbuf chain (hopefully only one mbuf most of the 	 * time) and stuff the data into it.  There are no possible failures 	 * at or after this point. 	 */
while|while
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* while there's stuff left */
name|int
name|thislen
init|=
name|ie_buflen
argument_list|(
name|ie
argument_list|,
name|head
argument_list|)
operator|-
name|offset
decl_stmt|;
comment|/* 		 * If too much data for the current mbuf, then fill the 		 * current one up, go to the next one, and try again. 		 */
if|if
condition|(
name|thislen
operator|>
name|m
operator|->
name|m_len
operator|-
name|thismboff
condition|)
block|{
name|int
name|newlen
init|=
name|m
operator|->
name|m_len
operator|-
name|thismboff
decl_stmt|;
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|ie
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|v_caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|newlen
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual warning */
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
comment|/* new mbuf, so no offset */
name|offset
operator|+=
name|newlen
expr_stmt|;
comment|/* we are now this far into 						 * the packet */
name|resid
operator|-=
name|newlen
expr_stmt|;
comment|/* so there is this much left 						 * to get */
continue|continue;
block|}
comment|/* 		 * If there is more than enough space in the mbuf to hold 		 * the contents of this buffer, copy everything in, advance 		 * pointers, and so on. 		 */
if|if
condition|(
name|thislen
operator|<
name|m
operator|->
name|m_len
operator|-
name|thismboff
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|ie
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|thislen
argument_list|)
expr_stmt|;
name|thismboff
operator|+=
name|thislen
expr_stmt|;
comment|/* we are this far into the 						 * mbuf */
name|resid
operator|-=
name|thislen
expr_stmt|;
comment|/* and this much is left */
goto|goto
name|nextbuf
goto|;
block|}
comment|/* 		 * Otherwise, there is exactly enough space to put this 		 * buffer's contents into the current mbuf.  Do the 		 * combination of the above actions. 		 */
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|ie
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|thislen
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
comment|/* new mbuf, start at the beginning */
name|resid
operator|-=
name|thislen
expr_stmt|;
comment|/* and we are this far through */
comment|/* 		 * Advance all the pointers.  We can get here from either of 		 * the last two cases, but never the first. 		 */
name|nextbuf
label|:
name|offset
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbhead
operator|=
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nrxbufs
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbtail
index|]
operator|->
name|ie_rbd_length
operator|&=
operator|~
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbtail
operator|=
operator|(
name|ie
operator|->
name|rbtail
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nrxbufs
expr_stmt|;
block|}
comment|/* 	 * Unless something changed strangely while we were doing the copy, 	 * we have now copied everything in from the shared memory. This 	 * means that we are done. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read frame NUM from unit UNIT (pre-cached as IE).  *  * This routine reads the RFD at NUM, and copies in the buffers from  * the list of RBD, then rotates the RBD and RFD lists so that the receiver  * doesn't start complaining.  Trailers are DROPPED---there's no point  * in wasting time on confusing code to deal with them.	 Hopefully,  * this machine will never ARP for trailers anyway.  */
end_comment

begin_function
specifier|static
name|void
name|ie_readframe
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|num
comment|/* frame number to read */
parameter_list|)
block|{
name|struct
name|ie_recv_frame_desc
name|rfd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
literal|0
decl_stmt|;
name|struct
name|ether_header
name|eh
decl_stmt|;
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|ie
operator|->
name|rframes
index|[
name|num
index|]
argument_list|)
argument_list|,
operator|&
name|rfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ie_recv_frame_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Immediately advance the RFD list, since we we have copied ours 	 * now. 	 */
name|ie
operator|->
name|rframes
index|[
name|num
index|]
operator|->
name|ie_fd_status
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rframes
index|[
name|num
index|]
operator|->
name|ie_fd_last
operator||=
name|IE_FD_LAST
expr_stmt|;
name|ie
operator|->
name|rframes
index|[
name|ie
operator|->
name|rftail
index|]
operator|->
name|ie_fd_last
operator|&=
operator|~
name|IE_FD_LAST
expr_stmt|;
name|ie
operator|->
name|rftail
operator|=
operator|(
name|ie
operator|->
name|rftail
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nframes
expr_stmt|;
name|ie
operator|->
name|rfhead
operator|=
operator|(
name|ie
operator|->
name|rfhead
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nframes
expr_stmt|;
if|if
condition|(
name|rfd
operator|.
name|ie_fd_status
operator|&
name|IE_FD_OK
condition|)
block|{
if|if
condition|(
name|ieget
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|eh
argument_list|)
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
comment|/* this counts as an 							 * error */
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ie_debug
operator|&
name|IED_READFRAME
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: frame from ether %6D type %x\n"
argument_list|,
name|unit
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|,
literal|":"
argument_list|,
operator|(
name|unsigned
operator|)
name|eh
operator|.
name|ether_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
operator|>
name|ETHERTYPE_TRAIL
operator|&&
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
operator|<
operator|(
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
operator|)
condition|)
name|printf
argument_list|(
literal|"received trailer!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m
condition|)
return|return;
comment|/* 	 * Finally pass this packet up to higher layers. 	 */
name|ether_input
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
operator|&
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_drop_packet_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
do|do
block|{
comment|/* 		 * This means we are somehow out of sync.  So, we reset the 		 * adapter. 		 */
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_USED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|print_rbd
argument_list|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ie%d: receive descriptors out of sync at %d\n"
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|rbhead
argument_list|)
expr_stmt|;
name|iereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbhead
operator|=
operator|(
name|ie
operator|->
name|rbhead
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nrxbufs
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbtail
index|]
operator|->
name|ie_rbd_length
operator|&=
operator|~
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbtail
operator|=
operator|(
name|ie
operator|->
name|rbtail
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nrxbufs
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|i
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Start transmission on an interface.  */
end_comment

begin_function
specifier|static
name|void
name|iestart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|volatile
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|u_short
name|len
decl_stmt|;
comment|/* 	 * This is not really volatile, in this routine, but it makes gcc 	 * happy. 	 */
specifier|volatile
name|u_short
modifier|*
name|bptr
init|=
operator|&
name|ie
operator|->
name|scb
operator|->
name|ie_command_list
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
break|break;
name|buffer
operator|=
name|ie
operator|->
name|xmit_cbuffs
index|[
name|ie
operator|->
name|xmit_count
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|&&
name|len
operator|<
name|IE_BUF_LEN
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|len
operator|=
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* 		 * See if bpf is listening on this interface, let it see the 		 * packet before we commit it to the wire. 		 */
if|if
condition|(
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
name|bpf_tap
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ie
operator|->
name|xmit_cbuffs
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_flags
operator|=
name|IE_XMIT_LAST
operator||
name|len
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_next
operator|=
literal|0xffff
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_buf
operator|=
name|MK_24
argument_list|(
name|ie
operator|->
name|iomem
argument_list|,
name|ie
operator|->
name|xmit_cbuffs
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_XMIT
expr_stmt|;
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_status
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_desc
operator|=
name|MK_16
argument_list|(
name|ie
operator|->
name|iomem
argument_list|,
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
operator|*
name|bptr
operator|=
name|MK_16
argument_list|(
name|ie
operator|->
name|iomem
argument_list|,
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
name|bptr
operator|=
operator|&
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|com
operator|.
name|ie_cmd_link
expr_stmt|;
name|ie
operator|->
name|xmit_count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ie
operator|->
name|xmit_count
operator|<
name|ie
operator|->
name|ntxbufs
condition|)
do|;
comment|/* 	 * If we queued up anything for transmission, send it. 	 */
if|if
condition|(
name|ie
operator|->
name|xmit_count
condition|)
block|{
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
operator|-
literal|1
index|]
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator||=
name|IE_CMD_LAST
operator||
name|IE_CMD_INTR
expr_stmt|;
comment|/* 		 * By passing the command pointer as a null, we tell 		 * command_and_wait() to pretend that this isn't an action 		 * command.  I wish I understood what was happening here. 		 */
name|command_and_wait
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|,
name|IE_CU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Check to see if there's an 82586 out there.  */
end_comment

begin_function
specifier|static
name|int
name|check_ie_present
parameter_list|(
name|int
name|unit
parameter_list|,
name|caddr_t
name|where
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_sys_conf_ptr
modifier|*
name|scp
decl_stmt|;
specifier|volatile
name|struct
name|ie_int_sys_conf_ptr
modifier|*
name|iscp
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
decl_stmt|;
name|u_long
name|realbase
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|realbase
operator|=
operator|(
name|uintptr_t
operator|)
name|where
operator|+
name|size
operator|-
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
name|scp
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_sys_conf_ptr
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|realbase
operator|+
name|IE_SCP_ADDR
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|scp
argument_list|,
sizeof|sizeof
expr|*
name|scp
argument_list|)
expr_stmt|;
comment|/* 	 * First we put the ISCP at the bottom of memory; this tests to make 	 * sure that our idea of the size of memory is the same as the 	 * controller's. This is NOT where the ISCP will be in normal 	 * operation. 	 */
name|iscp
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_int_sys_conf_ptr
operator|*
operator|)
name|where
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
argument_list|,
sizeof|sizeof
expr|*
name|iscp
argument_list|)
expr_stmt|;
name|scb
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_sys_ctl_block
operator|*
operator|)
name|where
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|scb
argument_list|,
sizeof|sizeof
expr|*
name|scb
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ie_bus_use
operator|=
name|ie_softc
index|[
name|unit
index|]
operator|.
name|bus_use
expr_stmt|;
comment|/* 8-bit or 16-bit */
name|scp
operator|->
name|ie_iscp_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
operator|-
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|realbase
argument_list|)
expr_stmt|;
name|iscp
operator|->
name|ie_busy
operator|=
literal|1
expr_stmt|;
name|iscp
operator|->
name|ie_scb_offset
operator|=
name|MK_16
argument_list|(
name|realbase
argument_list|,
name|scb
argument_list|)
operator|+
literal|256
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* wait a while... */
if|if
condition|(
name|iscp
operator|->
name|ie_busy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now relocate the ISCP to its real home, and reset the controller 	 * again. 	 */
name|iscp
operator|=
operator|(
name|void
operator|*
operator|)
name|Align
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|realbase
operator|+
name|IE_SCP_ADDR
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ie_int_sys_conf_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
argument_list|,
sizeof|sizeof
expr|*
name|iscp
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|scp
operator|->
name|ie_iscp_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
operator|-
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|realbase
argument_list|)
expr_stmt|;
name|iscp
operator|->
name|ie_busy
operator|=
literal|1
expr_stmt|;
name|iscp
operator|->
name|ie_scb_offset
operator|=
name|MK_16
argument_list|(
name|realbase
argument_list|,
name|scb
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscp
operator|->
name|ie_busy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
operator|=
name|size
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomem
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|realbase
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iscp
operator|=
name|iscp
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|=
name|scb
expr_stmt|;
comment|/* 	 * Acknowledge any interrupts we may have caused... 	 */
name|ie_ack
argument_list|(
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Divine the memory size of ie board UNIT.  * Better hope there's nothing important hiding just below the ie card...  */
end_comment

begin_function
specifier|static
name|void
name|find_ie_mem_size
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|unsigned
name|size
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|size
operator|=
literal|65536
init|;
name|size
operator|>=
literal|8192
condition|;
name|size
operator|-=
literal|8192
control|)
block|{
if|if
condition|(
name|check_ie_present
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomembot
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|el_reset_586
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_NORMAL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_reset_586
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IEATT_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ee16_reset_586
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_ECTRL
argument_list|,
name|IEE16_RESET_586
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_ECTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|el_chan_attn
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IE507_ATTN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_chan_attn
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IEATT_ATTN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ee16_chan_attn
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_ATTN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_short
name|ee16_read_eeprom
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|int
name|ectrl
decl_stmt|,
name|edata
decl_stmt|;
name|ectrl
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|)
expr_stmt|;
name|ectrl
operator|&=
name|IEE16_ECTRL_MASK
expr_stmt|;
name|ectrl
operator||=
name|IEE16_ECTRL_EECS
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|,
name|ectrl
argument_list|)
expr_stmt|;
name|ee16_eeprom_outbits
argument_list|(
name|sc
argument_list|,
name|IEE16_EEPROM_READ
argument_list|,
name|IEE16_EEPROM_OPSIZE1
argument_list|)
expr_stmt|;
name|ee16_eeprom_outbits
argument_list|(
name|sc
argument_list|,
name|location
argument_list|,
name|IEE16_EEPROM_ADDR_SIZE
argument_list|)
expr_stmt|;
name|edata
operator|=
name|ee16_eeprom_inbits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ectrl
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|)
expr_stmt|;
name|ectrl
operator|&=
operator|~
operator|(
name|IEE16_RESET_ASIC
operator||
name|IEE16_ECTRL_EEDI
operator||
name|IEE16_ECTRL_EECS
operator|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|,
name|ectrl
argument_list|)
expr_stmt|;
name|ee16_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ee16_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|edata
return|;
block|}
end_function

begin_function
name|void
name|ee16_eeprom_outbits
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|int
name|edata
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|ectrl
decl_stmt|,
name|i
decl_stmt|;
name|ectrl
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|)
expr_stmt|;
name|ectrl
operator|&=
operator|~
name|IEE16_RESET_ASIC
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ectrl
operator|&=
operator|~
name|IEE16_ECTRL_EEDI
expr_stmt|;
if|if
condition|(
name|edata
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|ectrl
operator||=
name|IEE16_ECTRL_EEDI
expr_stmt|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|,
name|ectrl
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* eeprom data must be setup for 0.4 uSec */
name|ee16_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ee16_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ectrl
operator|&=
operator|~
name|IEE16_ECTRL_EEDI
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|,
name|ectrl
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* eeprom data must be held for 0.4 uSec */
block|}
end_function

begin_function
name|int
name|ee16_eeprom_inbits
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ectrl
decl_stmt|,
name|edata
decl_stmt|,
name|i
decl_stmt|;
name|ectrl
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|)
expr_stmt|;
name|ectrl
operator|&=
operator|~
name|IEE16_RESET_ASIC
expr_stmt|;
for|for
control|(
name|edata
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|edata
operator|=
name|edata
operator|<<
literal|1
expr_stmt|;
name|ee16_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ectrl
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ectrl
operator|&
name|IEE16_ECTRL_EEDO
condition|)
block|{
name|edata
operator||=
literal|1
expr_stmt|;
block|}
name|ee16_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|edata
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ee16_eeprom_clock
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|int
name|ectrl
decl_stmt|;
name|ectrl
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|)
expr_stmt|;
name|ectrl
operator|&=
operator|~
operator|(
name|IEE16_RESET_ASIC
operator||
name|IEE16_ECTRL_EESK
operator|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|ectrl
operator||=
name|IEE16_ECTRL_EESK
expr_stmt|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_ECTRL
argument_list|,
name|ectrl
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|9
argument_list|)
expr_stmt|;
comment|/* EESK must be stable for 8.38 uSec */
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ee16_interrupt_enable
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_IRQ
argument_list|,
name|sc
operator|->
name|irq_encoded
operator||
name|IEE16_IRQ_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_read_ether
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|char
name|addr
index|[
literal|6
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|addr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iereset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NIE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ie%d: reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|ieioctl
argument_list|(
operator|&
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Stop i82586 dead in its tracks. 	 */
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_ABORT
operator||
name|IE_CU_ABORT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ie%d: abort commands timed out\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_DISABLE
operator||
name|IE_CU_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ie%d: disable commands timed out\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|!
name|check_ie_present
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomembot
argument_list|,
name|e_softc
index|[
name|unit
index|]
operator|.
name|iosize
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ie disappeared!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|ieioctl
argument_list|(
operator|&
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is called if we time out.  */
end_comment

begin_function
specifier|static
name|void
name|chan_attn_timeout
parameter_list|(
name|void
modifier|*
name|rock
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|rock
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the controller and wait for it to either  * complete or be accepted, depending on the command.  If the  * command pointer is null, then pretend that the command is  * not an action command.  If the command pointer is not null,  * and the command is an action command, wait for  * ((volatile struct ie_cmd_common *)pcmd)->ie_cmd_status& MASK  * to become true.  */
end_comment

begin_function
specifier|static
name|int
name|command_and_wait
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
specifier|volatile
name|void
modifier|*
name|pcmd
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_cmd_common
modifier|*
name|cc
init|=
name|pcmd
decl_stmt|;
specifier|volatile
name|int
name|timedout
init|=
literal|0
decl_stmt|;
name|struct
name|callout_handle
name|ch
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_command
operator|=
operator|(
name|u_short
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|IE_ACTION_COMMAND
argument_list|(
name|cmd
argument_list|)
operator|&&
name|pcmd
condition|)
block|{
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
comment|/* 		 * According to the packet driver, the minimum timeout 		 * should be .369 seconds, which we round up to .37. 		 */
name|ch
operator|=
name|timeout
argument_list|(
name|chan_attn_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|timedout
argument_list|,
literal|37
operator|*
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
comment|/* 		 * Now spin-lock waiting for status.  This is not a very 		 * nice thing to do, but I haven't figured out how, or 		 * indeed if, we can put the process waiting for action to 		 * sleep.  (We may be getting called through some other 		 * timeout running in the kernel.) 		 */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cc
operator|->
name|ie_cmd_status
operator|&
name|mask
operator|)
operator|||
name|timedout
condition|)
break|break;
block|}
name|untimeout
argument_list|(
name|chan_attn_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|timedout
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
return|return
operator|(
name|timedout
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, just wait for the command to be accepted. 		 */
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
while|while
condition|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_command
condition|)
empty_stmt|;
comment|/* spin lock */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Run the time-domain reflectometer...  */
end_comment

begin_function
specifier|static
name|void
name|run_tdr
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|volatile
name|struct
name|ie_tdr_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_TDR
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|cmd
operator|->
name|ie_tdr_time
operator|=
literal|0
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ie_tdr_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
condition|)
name|result
operator|=
literal|0x2000
expr_stmt|;
else|else
name|result
operator|=
name|cmd
operator|->
name|ie_tdr_time
expr_stmt|;
name|ie_ack
argument_list|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|IE_TDR_SUCCESS
condition|)
return|return;
if|if
condition|(
name|result
operator|&
name|IE_TDR_XCVR
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: transceiver problem\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|&
name|IE_TDR_OPEN
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: TDR detected an open %d clocks away\n"
argument_list|,
name|unit
argument_list|,
name|result
operator|&
name|IE_TDR_TIME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|&
name|IE_TDR_SHORT
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: TDR detected a short %d clocks away\n"
argument_list|,
name|unit
argument_list|,
name|result
operator|&
name|IE_TDR_TIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ie%d: TDR returned unknown status %x\n"
argument_list|,
name|unit
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|start_receiver
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ie_ack
argument_list|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Here is a helper routine for iernr() and ieinit().  This sets up  * the RFA.  */
end_comment

begin_function
specifier|static
name|v_caddr_t
name|setup_rfa
parameter_list|(
name|v_caddr_t
name|ptr
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_recv_frame_desc
modifier|*
name|rfd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|unit
init|=
name|ie
operator|-
operator|&
name|ie_softc
index|[
literal|0
index|]
decl_stmt|;
comment|/* First lay them out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rframes
index|[
name|i
index|]
operator|=
name|rfd
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|rfd
argument_list|,
sizeof|sizeof
expr|*
name|rfd
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|rfd
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
name|Alignvol
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
comment|/* Now link them together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rframes
index|[
name|i
index|]
operator|->
name|ie_fd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rframes
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nframes
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, set the EOL bit on the last one. */
name|ie
operator|->
name|rframes
index|[
name|ie
operator|->
name|nframes
operator|-
literal|1
index|]
operator|->
name|ie_fd_last
operator||=
name|IE_FD_LAST
expr_stmt|;
comment|/* 	 * Now lay out some buffers for the incoming frames.  Note that we 	 * set aside a bit of slop in each buffer, to make sure that we have 	 * enough space to hold a single frame in every buffer. 	 */
name|rbd
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|nrxbufs
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rbuffs
index|[
name|i
index|]
operator|=
name|rbd
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|rbd
argument_list|,
sizeof|sizeof
expr|*
name|rbd
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
operator|+
sizeof|sizeof
expr|*
name|rbd
argument_list|)
expr_stmt|;
name|rbd
operator|->
name|ie_rbd_length
operator|=
name|IE_RBUF_SIZE
expr_stmt|;
name|rbd
operator|->
name|ie_rbd_buffer
operator|=
name|MK_24
argument_list|(
name|MEM
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ie
operator|->
name|cbuffs
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|IE_RBUF_SIZE
expr_stmt|;
name|rbd
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
comment|/* Now link them together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|nrxbufs
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rbuffs
index|[
name|i
index|]
operator|->
name|ie_rbd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rbuffs
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|ie
operator|->
name|nrxbufs
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Tag EOF on the last one */
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|nrxbufs
operator|-
literal|1
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
comment|/* 	 * We use the head and tail pointers on receive to keep track of the 	 * order in which RFDs and RBDs are used. 	 */
name|ie
operator|->
name|rfhead
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rftail
operator|=
name|ie
operator|->
name|nframes
operator|-
literal|1
expr_stmt|;
name|ie
operator|->
name|rbhead
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbtail
operator|=
name|ie
operator|->
name|nrxbufs
operator|-
literal|1
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
operator|->
name|ie_fd_buf_desc
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rbuffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the multicast setup command.  * Call at splimp().  */
end_comment

begin_function
specifier|static
name|int
name|mc_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|v_caddr_t
name|ptr
parameter_list|,
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|ie_mcast_cmd
modifier|*
name|cmd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_MCAST
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
comment|/* ignore cast-qual */
name|bcopy
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|ie
operator|->
name|mcast_addrs
argument_list|,
operator|(
name|v_caddr_t
operator|)
name|cmd
operator|->
name|ie_mcast_addrs
argument_list|,
name|ie
operator|->
name|mcast_count
operator|*
sizeof|sizeof
expr|*
name|ie
operator|->
name|mcast_addrs
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ie_mcast_bytes
operator|=
name|ie
operator|->
name|mcast_count
operator|*
literal|6
expr_stmt|;
comment|/* grrr... */
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: multicast address setup command failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine takes the environment generated by check_ie_present()  * and adds to it all the other structures we need to operate the adapter.  * This includes executing the CONFIGURE, IA-SETUP, and MC-SETUP commands,  * starting the receiver unit, and clearing interrupts.  *  * THIS ROUTINE MUST BE CALLED AT splimp() OR HIGHER.  */
end_comment

begin_function
specifier|static
name|void
name|ieinit
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
name|xsc
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
init|=
name|ie
operator|->
name|scb
decl_stmt|;
name|v_caddr_t
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|unit
init|=
name|ie
operator|->
name|unit
decl_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|scb
operator|+
sizeof|sizeof
expr|*
name|scb
argument_list|)
expr_stmt|;
comment|/* 	 * Send the configure command first. 	 */
block|{
specifier|volatile
name|struct
name|ie_config_cmd
modifier|*
name|cmd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|ie_setup_config
argument_list|(
name|cmd
argument_list|,
name|ie
operator|->
name|promisc
argument_list|,
name|ie
operator|->
name|hard_type
operator|==
name|IE_STARLAN10
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_CONFIG
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: configure command failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now send the Individual Address Setup command. 	 */
block|{
specifier|volatile
name|struct
name|ie_iasetup_cmd
modifier|*
name|cmd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_IASETUP
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|bcopy
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|&
name|cmd
operator|->
name|ie_address
argument_list|,
sizeof|sizeof
name|cmd
operator|->
name|ie_address
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: individual address "
literal|"setup command failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now run the time-domain reflectometer. 	 */
name|run_tdr
argument_list|(
name|unit
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
comment|/* 	 * Acknowledge any interrupts we have generated thus far. 	 */
name|ie_ack
argument_list|(
name|ie
operator|->
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|ie_chan_attn
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the RFA. 	 */
name|ptr
operator|=
name|setup_rfa
argument_list|(
name|ptr
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, the transmit command and buffer are the last little bit 	 * of work. 	 */
comment|/* transmit command buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|ntxbufs
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|xmit_cmds
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_cmds
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_buffs
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|/* transmit buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|ntxbufs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|xmit_cbuffs
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|IE_BUF_LEN
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ie
operator|->
name|xmit_cbuffs
index|[
name|ie
operator|->
name|ntxbufs
operator|-
literal|1
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ie
operator|->
name|ntxbufs
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|ie
operator|->
name|xmit_cmds
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_cmds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|ie
operator|->
name|xmit_buffs
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_buffs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This must be coordinated with iestart() and ietint(). 	 */
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
operator|->
name|ie_xmit_status
operator|=
name|IE_STAT_COMPL
expr_stmt|;
comment|/* take the ee16 out of loopback */
if|if
condition|(
name|ie
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
block|{
name|u_int8_t
name|bart_config
decl_stmt|;
name|bart_config
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IEE16_CONFIG
argument_list|)
expr_stmt|;
name|bart_config
operator|&=
operator|~
name|IEE16_BART_LOOPBACK
expr_stmt|;
comment|/* inb doesn't get bit! */
name|bart_config
operator||=
name|IEE16_BART_MCS16_TEST
expr_stmt|;
name|outb
argument_list|(
name|PORT
operator|+
name|IEE16_CONFIG
argument_list|,
name|bart_config
argument_list|)
expr_stmt|;
name|ee16_interrupt_enable
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|ee16_chan_attn
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* tell higher levels 							 * we're here */
name|start_receiver
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_stop
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * Note that this device doesn't have an "all multicast" 		 * mode, so we must turn on promiscuous mode and do the 		 * filtering manually. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ie_stop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
expr_stmt|;
name|ieinit
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|promisc
operator|^
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
condition|)
block|{
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
expr_stmt|;
name|ieinit
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Update multicast listeners 		 */
comment|/* reset multicast filtering */
name|ie_mc_reset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_mc_reset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* 	 * Step through the list of addresses. 	 */
name|ie
operator|->
name|mcast_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ifma
operator|=
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
comment|/* XXX - this is broken... */
if|if
condition|(
name|ie
operator|->
name|mcast_count
operator|>=
name|MAXMCAST
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|ieioctl
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|setflag
goto|;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
operator|(
name|ie
operator|->
name|mcast_addrs
index|[
name|ie
operator|->
name|mcast_count
index|]
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|ie
operator|->
name|mcast_count
operator|++
expr_stmt|;
block|}
name|setflag
label|:
name|ie
operator|->
name|want_mcsetup
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|print_rbd
parameter_list|(
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
parameter_list|)
block|{
name|printf
argument_list|(
literal|"RBD at %p:\n"
literal|"actual %04x, next %04x, buffer %p\n"
literal|"length %04x, mbz %04x\n"
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|rbd
argument_list|,
name|rbd
operator|->
name|ie_rbd_actual
argument_list|,
name|rbd
operator|->
name|ie_rbd_next
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rbd
operator|->
name|ie_rbd_buffer
argument_list|,
name|rbd
operator|->
name|ie_rbd_length
argument_list|,
name|rbd
operator|->
name|mbz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

