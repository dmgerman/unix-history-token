begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, University of Vermont and State  *  Agricultural College.  * Copyright (c) 1992, 1993, Garrett A. Wollman.  *  * Portions:  * Copyright (c) 1990, 1991, William F. Jolitz  * Copyright (c) 1990, The Regents of the University of California  *  * 3Com 3C507 support:  * Copyright (c) 1993, 1994, Charles M. Hannum  *  * EtherExpress 16 support:  * Copyright (c) 1993, 1994, 1995, Rodney W. Grimes  * Copyright (c) 1997, Aaron C. Smith  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	Vermont and State Agricultural College and Garrett A. Wollman, by  *	William F. Jolitz, by the University of California, Berkeley,  *	Lawrence Berkeley Laboratory, and their contributors, by  *	Charles M. Hannum, by Rodney W. Grimes, and by Aaron C. Smith.  * 4. Neither the names of the Universities nor the names of the authors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR AUTHORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * MAINTAINER: Matthew N. Dodd<winter@jurai.net>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Intel 82586 Ethernet chip  * Register, bit, and structure definitions.  *  * Written by GAW with reference to the Clarkson Packet Driver code for this  * chip written by Russ Nelson and others.  *  * Intel EtherExpress 16 support from if_ix.c, written by Rodney W. Grimes.  */
end_comment

begin_comment
comment|/*  * The i82586 is a very versatile chip, found in many implementations.  * Programming this chip is mostly the same, but certain details differ  * from card to card.  This driver is written so that different cards  * can be automatically detected at run-time.  */
end_comment

begin_comment
comment|/*  * Mode of operation:  *  * We run the 82586 in a standard Ethernet mode.  We keep NFRAMES     * received frame descriptors around for the receiver to use, and     * NRXBUFS associated receive buffer descriptors, both in a circular  * list.  Whenever a frame is received, we rotate both lists as  * necessary.  (The 586 treats both lists as a simple queue.)  We also  * keep a transmit command around so that packets can be sent off  * quickly.  *  * We configure the adapter in AL-LOC = 1 mode, which means that the  * Ethernet/802.3 MAC header is placed at the beginning of the receive  * buffer rather than being split off into various fields in the RFD.   * This also means that we must include this header in the transmit   * buffer as well.  *  * By convention, all transmit commands, and only transmit commands,  * shall have the I (IE_CMD_INTR) bit set in the command.  This way,   * when an interrupt arrives at ieintr(), it is immediately possible  * to tell what precisely caused it.  ANY OTHER command-sending routines  * should run at splimp(), and should post an acknowledgement to every  * interrupt they generate.  *  * The 82586 has a 24-bit address space internally, and the adaptor's  * memory is located at the top of this region.  However, the value  * we are given in configuration is normally the *bottom* of the adaptor  * RAM.  So, we must go through a few gyrations to come up with a  * kernel virtual address which represents the actual beginning of the  * 586 address space.  First, we autosize the RAM by running through  * several possible sizes and trying to initialize the adapter under  * the assumption that the selected size is correct.  Then, knowing  * the correct RAM size, we set up our pointers in the softc `iomem'  * represents the computed base of the 586 address space.  `iomembot'  * represents the actual configured base of adapter RAM.  Finally,  * `iosize' represents the calculated size of 586 RAM.  Then, when  * laying out commands, we use the interval [iomembot, iomembot +  * iosize); to make 24-pointers, we subtract iomem, and to make  * 16-pointers, we subtract iomem and and with 0xffff.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/i82586.h>
end_include

begin_include
include|#
directive|include
file|<dev/ie/if_ievar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ie/if_iereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ie/if_ie507.h>
end_include

begin_include
include|#
directive|include
file|<dev/ie/if_iee16.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/elink.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|IED_RINT
value|0x01
end_define

begin_define
define|#
directive|define
name|IED_TINT
value|0x02
end_define

begin_define
define|#
directive|define
name|IED_RNR
value|0x04
end_define

begin_define
define|#
directive|define
name|IED_CNA
value|0x08
end_define

begin_define
define|#
directive|define
name|IED_READFRAME
value|0x10
end_define

begin_decl_stmt
specifier|static
name|int
name|ie_debug
init|=
name|IED_RNR
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IE_BUF_LEN
value|ETHER_MAX_LEN
end_define

begin_comment
comment|/* length of transmit buffer */
end_comment

begin_comment
comment|/* XXX this driver uses `volatile' and `caddr_t' to a fault. */
end_comment

begin_typedef
typedef|typedef
specifier|volatile
name|char
modifier|*
name|v_caddr_t
typedef|;
end_typedef

begin_comment
comment|/* core address, pointer to volatile */
end_comment

begin_comment
comment|/* Forward declaration */
end_comment

begin_struct_decl
struct_decl|struct
name|ie_softc
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|ieinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieinit_locked
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_stop
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iestart
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iestart_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ee16_interrupt_enable
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ie_ack
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iereset
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_readframe
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_drop_packet_buffer
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|command_and_wait
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
specifier|volatile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run_tdr
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|,
specifier|volatile
name|struct
name|ie_tdr_cmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ierint
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ietint
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iernr
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_receiver
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ieget
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|v_caddr_t
name|setup_rfa
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|,
name|v_caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mc_setup
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_mc_reset
parameter_list|(
name|struct
name|ie_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|print_rbd
parameter_list|(
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|in_ierint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_ietint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ie_hardware_names
index|[]
init|=
block|{
literal|"None"
block|,
literal|"StarLAN 10"
block|,
literal|"EN100"
block|,
literal|"StarLAN Fiber"
block|,
literal|"3C507"
block|,
literal|"NI5210"
block|,
literal|"EtherExpress 16"
block|,
literal|"Unknown"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * sizeof(iscp) == 1+1+2+4 == 8  * sizeof(scb) == 2+2+2+2+2+2+2+2 == 16  * NFRAMES * sizeof(rfd) == NFRAMES*(2+2+2+2+6+6+2+2) == NFRAMES*24 == 384  * sizeof(xmit_cmd) == 2+2+2+2+6+2 == 18  * sizeof(transmit buffer) == 1512  * sizeof(transmit buffer desc) == 8  * -----  * 1946  *   * NRXBUFS * sizeof(rbd) == NRXBUFS*(2+2+4+2+2) == NRXBUFS*12  * NRXBUFS * IE_RBUF_SIZE == NRXBUFS*256  *   * NRXBUFS should be (16384 - 1946) / (256 + 12) == 14438 / 268 == 53  *   * With NRXBUFS == 48, this leaves us 1574 bytes for another command or  * more buffers.  Another transmit command would be 18+8+1512 == 1538  * ---just barely fits!  *   * Obviously all these would have to be reduced for smaller memory sizes.  * With a larger memory, it would be possible to roughly double the number  * of both transmit and receive buffers.  */
end_comment

begin_define
define|#
directive|define
name|NFRAMES
value|4
end_define

begin_comment
comment|/* number of receive frames */
end_comment

begin_define
define|#
directive|define
name|NRXBUFS
value|24
end_define

begin_comment
comment|/* number of buffers to allocate */
end_comment

begin_define
define|#
directive|define
name|IE_RBUF_SIZE
value|256
end_define

begin_comment
comment|/* size of each buffer, MUST BE POWER OF TWO */
end_comment

begin_define
define|#
directive|define
name|NTXBUFS
value|1
end_define

begin_comment
comment|/* number of transmit commands */
end_comment

begin_define
define|#
directive|define
name|IE_TBUF_SIZE
value|ETHER_MAX_LEN
end_define

begin_comment
comment|/* size of transmit buffer */
end_comment

begin_define
define|#
directive|define
name|MK_24
parameter_list|(
name|base
parameter_list|,
name|ptr
parameter_list|)
value|((caddr_t)((uintptr_t)ptr - (uintptr_t)base))
end_define

begin_define
define|#
directive|define
name|MK_16
parameter_list|(
name|base
parameter_list|,
name|ptr
parameter_list|)
value|((u_short)(uintptr_t)MK_24(base, ptr))
end_define

begin_function
name|void
name|ee16_shutdown
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ee16_reset_586
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_ECTRL
argument_list|,
name|IEE16_RESET_ASIC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_ECTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Taken almost exactly from Bill's if_is.c, then modified beyond recognition.  */
end_comment

begin_function
name|int
name|ie_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|allocsize
decl_stmt|;
name|int
name|error
decl_stmt|,
name|factor
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * based on the amount of memory we have, allocate our tx and rx 	 * resources. 	 */
name|factor
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
operator|/
literal|8192
expr_stmt|;
name|sc
operator|->
name|nframes
operator|=
name|factor
operator|*
name|NFRAMES
expr_stmt|;
name|sc
operator|->
name|nrxbufs
operator|=
name|factor
operator|*
name|NRXBUFS
expr_stmt|;
name|sc
operator|->
name|ntxbufs
operator|=
name|factor
operator|*
name|NTXBUFS
expr_stmt|;
comment|/* 	 * Since all of these guys are arrays of pointers, allocate as one 	 * big chunk and dole out accordingly. 	 */
name|allocsize
operator|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|nframes
operator|+
operator|(
name|sc
operator|->
name|nrxbufs
operator|*
literal|2
operator|)
operator|+
operator|(
name|sc
operator|->
name|ntxbufs
operator|*
literal|3
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|rframes
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_recv_frame_desc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|allocsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rframes
operator|==
name|NULL
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|rbuffs
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_recv_buf_desc
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|rframes
index|[
name|sc
operator|->
name|nframes
index|]
expr_stmt|;
name|sc
operator|->
name|cbuffs
operator|=
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|nrxbufs
index|]
expr_stmt|;
name|sc
operator|->
name|xmit_cmds
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_xmit_cmd
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|cbuffs
index|[
name|sc
operator|->
name|nrxbufs
index|]
expr_stmt|;
name|sc
operator|->
name|xmit_buffs
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_xmit_buf
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|xmit_cmds
index|[
name|sc
operator|->
name|ntxbufs
index|]
expr_stmt|;
name|sc
operator|->
name|xmit_cbuffs
operator|=
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|xmit_buffs
index|[
name|sc
operator|->
name|ntxbufs
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"hardware type %s, revision %d\n"
argument_list|,
name|ie_hardware_names
index|[
name|sc
operator|->
name|hard_type
index|]
argument_list|,
name|sc
operator|->
name|hard_vers
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|iestart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ieioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ieinit
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ie_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to register interrupt handler\n"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ie_ack
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|mask
parameter_list|)
block|{
name|sc
operator|->
name|scb
operator|->
name|ie_command
operator|=
name|sc
operator|->
name|scb
operator|->
name|ie_status
operator|&
name|mask
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|ie_chan_attn
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * What to do upon receipt of an interrupt.  */
end_comment

begin_function
name|void
name|ie_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ie_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|u_short
name|status
decl_stmt|;
name|IE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt latch on the 3C507. */
if|if
condition|(
name|sc
operator|->
name|hard_type
operator|==
name|IE_3C507
operator|&&
operator|(
name|inb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IE507_CTRL
argument_list|)
operator|&
name|EL_CTRL_INTL
operator|)
condition|)
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IE507_ICTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* disable interrupts on the EE16. */
if|if
condition|(
name|sc
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_IRQ
argument_list|,
name|sc
operator|->
name|irq_encoded
argument_list|)
expr_stmt|;
name|status
operator|=
name|sc
operator|->
name|scb
operator|->
name|ie_status
expr_stmt|;
name|loop
label|:
comment|/* Don't ack interrupts which we didn't receive */
name|ie_ack
argument_list|(
name|sc
argument_list|,
name|IE_ST_WHENCE
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|IE_ST_RECV
operator||
name|IE_ST_RNR
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|in_ierint
operator|++
expr_stmt|;
if|if
condition|(
name|ie_debug
operator|&
name|IED_RINT
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"rint\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ierint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|in_ierint
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|IE_ST_DONE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|in_ietint
operator|++
expr_stmt|;
if|if
condition|(
name|ie_debug
operator|&
name|IED_TINT
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"tint\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ietint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|in_ietint
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|IE_ST_RNR
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ie_debug
operator|&
name|IED_RNR
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"rnr\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iernr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|status
operator|&
name|IE_ST_ALLDONE
operator|)
operator|&&
operator|(
name|ie_debug
operator|&
name|IED_CNA
operator|)
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"cna\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|=
name|sc
operator|->
name|scb
operator|->
name|ie_status
operator|)
operator|&
name|IE_ST_WHENCE
condition|)
goto|goto
name|loop
goto|;
comment|/* Clear the interrupt latch on the 3C507. */
if|if
condition|(
name|sc
operator|->
name|hard_type
operator|==
name|IE_3C507
condition|)
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IE507_ICTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* enable interrupts on the EE16. */
if|if
condition|(
name|sc
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_IRQ
argument_list|,
name|sc
operator|->
name|irq_encoded
operator||
name|IEE16_IRQ_ENABLE
argument_list|)
expr_stmt|;
name|IE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received-frame interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|ierint
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|status
decl_stmt|;
specifier|static
name|int
name|timesthru
init|=
literal|1024
decl_stmt|;
name|i
operator|=
name|sc
operator|->
name|rfhead
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|sc
operator|->
name|rframes
index|[
name|i
index|]
operator|->
name|ie_fd_status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|IE_FD_COMPLETE
operator|)
operator|&&
operator|(
name|status
operator|&
name|IE_FD_OK
operator|)
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|timesthru
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
operator|+=
name|sc
operator|->
name|scb
operator|->
name|ie_err_crc
operator|+
name|sc
operator|->
name|scb
operator|->
name|ie_err_align
operator|+
name|sc
operator|->
name|scb
operator|->
name|ie_err_resource
operator|+
name|sc
operator|->
name|scb
operator|->
name|ie_err_overrun
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_err_crc
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_err_align
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_err_resource
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_err_overrun
operator|=
literal|0
expr_stmt|;
name|timesthru
operator|=
literal|1024
expr_stmt|;
block|}
name|ie_readframe
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|IE_FD_RNR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|scb
operator|->
name|ie_status
operator|&
name|IE_RU_READY
operator|)
condition|)
block|{
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
operator|->
name|ie_fd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rbuffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nframes
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a command-complete interrupt.  These are only generated by  * the transmission of frames.	This routine is deceptively simple, since  * most of the real work is done by iestart().  */
end_comment

begin_function
specifier|static
name|int
name|ietint
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|xmit_count
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|sc
operator|->
name|xmit_cmds
index|[
name|i
index|]
operator|->
name|ie_xmit_status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|IE_XS_LATECOLL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"late collision\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_NOCARRIER
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"no carrier\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_LOSTCTS
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"lost CTS\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_UNDERRUN
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"DMA underrun\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_EXCMAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"too many collisions\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
literal|16
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|status
operator|&
name|IE_XS_MAXCOLL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|xmit_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If multicast addresses were added or deleted while we were 	 * transmitting, ie_mc_reset() set the want_mcsetup flag indicating 	 * that we should do it. 	 */
if|if
condition|(
name|sc
operator|->
name|want_mcsetup
condition|)
block|{
name|mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|want_mcsetup
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Wish I knew why this seems to be necessary... */
name|sc
operator|->
name|xmit_cmds
index|[
literal|0
index|]
operator|->
name|ie_xmit_status
operator||=
name|IE_STAT_COMPL
expr_stmt|;
name|iestart_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* shouldn't be necessary */
block|}
end_function

begin_comment
comment|/*  * Process a receiver-not-ready interrupt.  I believe that we get these  * when there aren't enough buffers to go around.  For now (FIXME), we  * just restart the receiver, and hope everything's ok.  */
end_comment

begin_function
specifier|static
name|int
name|iernr
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|doesnt_work
name|setup_rfa
argument_list|(
name|sc
argument_list|,
operator|(
name|v_caddr_t
operator|)
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* This doesn't work either, but it doesn't hang either. */
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just in case */
name|setup_rfa
argument_list|(
name|sc
argument_list|,
operator|(
name|v_caddr_t
operator|)
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|sc
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* was ENABLE */
endif|#
directive|endif
name|ie_ack
argument_list|(
name|sc
argument_list|,
name|IE_ST_WHENCE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two Ether/802 addresses for equality, inlined and  * unrolled for speed.	I'd love to have an inline assembler  * version of this...  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ether_equal
parameter_list|(
name|u_char
modifier|*
name|one
parameter_list|,
name|u_char
modifier|*
name|two
parameter_list|)
block|{
if|if
condition|(
name|one
index|[
literal|0
index|]
operator|!=
name|two
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|1
index|]
operator|!=
name|two
index|[
literal|1
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|2
index|]
operator|!=
name|two
index|[
literal|2
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|3
index|]
operator|!=
name|two
index|[
literal|3
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|4
index|]
operator|!=
name|two
index|[
literal|4
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|one
index|[
literal|5
index|]
operator|!=
name|two
index|[
literal|5
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Determine quickly whether we should bother reading in this packet.  * This depends on whether BPF and/or bridging is enabled, whether we  * are receiving multicast address, and whether promiscuous mode is enabled.  * We assume that if IFF_PROMISC is set, then *somebody* wants to see  * all incoming packets.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|check_eh
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|)
block|{
comment|/* Optimize the common case: normal operation. We've received 	   either a unicast with our dest or a multicast packet. */
if|if
condition|(
name|sc
operator|->
name|promisc
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If not multicast, it's definitely for us */
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Accept broadcasts (loose but fast check) */
if|if
condition|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|==
literal|0xff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Compare against our multicast addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mcast_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sc
operator|->
name|mcast_addrs
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Always accept packets when in promiscuous mode */
if|if
condition|(
operator|(
name|sc
operator|->
name|promisc
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Always accept packets directed at us */
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Must have IFF_ALLMULTI but not IFF_PROMISC set. The chip is 	   actually in promiscuous mode, so discard unicast packets. */
return|return
operator|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We want to isolate the bits that have meaning...  This assumes that  * IE_RBUF_SIZE is an even power of two.  If somehow the act_len exceeds  * the size of the buffer, then we are screwed anyway.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ie_buflen
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|int
name|head
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|&
operator|(
name|IE_RBUF_SIZE
operator||
operator|(
name|IE_RBUF_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|ie_packet_len
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|head
init|=
name|sc
operator|->
name|rbhead
decl_stmt|;
name|int
name|acc
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_USED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|print_rbd
argument_list|(
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: receive descriptors out of sync at %d\n"
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|sc
operator|->
name|rbhead
argument_list|)
expr_stmt|;
name|iereset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|=
name|sc
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_LAST
expr_stmt|;
name|acc
operator|+=
name|ie_buflen
argument_list|(
name|sc
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nrxbufs
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|i
condition|)
do|;
return|return
operator|(
name|acc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read data off the interface, and turn it into an mbuf chain.  *  * This code is DRAMATICALLY different from the previous version; this  * version tries to allocate the entire mbuf chain up front, given the  * length of the data available.  This enables us to allocate mbuf  * clusters in many situations where before we would have had a long  * chain of partially-full mbufs.  This should help to speed up the  * operation considerably.  (Provided that it works, of course.)  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ieget
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mymp
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|thismboff
decl_stmt|;
name|int
name|head
decl_stmt|;
name|totlen
operator|=
name|ie_packet_len
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Snarf the Ethernet header. 	 */
name|bcopy
argument_list|(
name|sc
operator|->
name|cbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
argument_list|,
operator|&
name|eh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual warning here */
comment|/* 	 * As quickly as possible, check if this packet is for us. If not, 	 * don't waste a single cycle copying the rest of the packet in. 	 * This is only a consideration when FILTER is defined; i.e., when 	 * we are either running BPF or doing multicasting. 	 */
if|if
condition|(
operator|!
name|check_eh
argument_list|(
name|sc
argument_list|,
operator|&
name|eh
argument_list|)
condition|)
block|{
name|ie_drop_packet_buffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
operator|--
expr_stmt|;
comment|/* just this case, it's not an 						 * error 						 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|ie_drop_packet_buffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXXX if_ierrors++; */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|resid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mymp
operator|=
operator|&
name|top
expr_stmt|;
comment|/* 	 * This loop goes through and allocates mbufs for all the data we 	 * will be copying in.	It does not actually do the copying yet. 	 */
do|do
block|{
comment|/* while(resid> 0) */
comment|/* 		 * Try to allocate an mbuf to hold the data that we have. 		 * If we already allocated one, just get another one and 		 * stick it on the end (eventually).  If we don't already 		 * have one, try to allocate an mbuf cluster big enough to 		 * hold the whole packet, if we think it's reasonable, or a 		 * single mbuf which may or may not be big enough. Got that? 		 */
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|ie_drop_packet_buffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|resid
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|resid
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
name|resid
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|resid
expr_stmt|;
block|}
block|}
name|resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|mymp
operator|=
name|m
expr_stmt|;
name|mymp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|resid
operator|>
literal|0
condition|)
do|;
name|resid
operator|=
name|totlen
expr_stmt|;
comment|/* remaining data */
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* packet offset */
name|thismboff
operator|=
literal|0
expr_stmt|;
comment|/* offset in m */
name|m
operator|=
name|top
expr_stmt|;
comment|/* current mbuf */
name|head
operator|=
name|sc
operator|->
name|rbhead
expr_stmt|;
comment|/* current rx buffer */
comment|/* 	 * Now we take the mbuf chain (hopefully only one mbuf most of the 	 * time) and stuff the data into it.  There are no possible failures 	 * at or after this point. 	 */
while|while
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* while there's stuff left */
name|int
name|thislen
init|=
name|ie_buflen
argument_list|(
name|sc
argument_list|,
name|head
argument_list|)
operator|-
name|offset
decl_stmt|;
comment|/* 		 * If too much data for the current mbuf, then fill the 		 * current one up, go to the next one, and try again. 		 */
if|if
condition|(
name|thislen
operator|>
name|m
operator|->
name|m_len
operator|-
name|thismboff
condition|)
block|{
name|int
name|newlen
init|=
name|m
operator|->
name|m_len
operator|-
name|thismboff
decl_stmt|;
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|sc
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|newlen
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual warning */
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
comment|/* new mbuf, so no offset */
name|offset
operator|+=
name|newlen
expr_stmt|;
comment|/* we are now this far into 						 * the packet */
name|resid
operator|-=
name|newlen
expr_stmt|;
comment|/* so there is this much left 						 * to get */
continue|continue;
block|}
comment|/* 		 * If there is more than enough space in the mbuf to hold 		 * the contents of this buffer, copy everything in, advance 		 * pointers, and so on. 		 */
if|if
condition|(
name|thislen
operator|<
name|m
operator|->
name|m_len
operator|-
name|thismboff
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|sc
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|thislen
argument_list|)
expr_stmt|;
name|thismboff
operator|+=
name|thislen
expr_stmt|;
comment|/* we are this far into the 						 * mbuf */
name|resid
operator|-=
name|thislen
expr_stmt|;
comment|/* and this much is left */
goto|goto
name|nextbuf
goto|;
block|}
comment|/* 		 * Otherwise, there is exactly enough space to put this 		 * buffer's contents into the current mbuf.  Do the 		 * combination of the above actions. 		 */
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|sc
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|thislen
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
comment|/* new mbuf, start at the beginning */
name|resid
operator|-=
name|thislen
expr_stmt|;
comment|/* and we are this far through */
comment|/* 		 * Advance all the pointers.  We can get here from either of 		 * the last two cases, but never the first. 		 */
name|nextbuf
label|:
name|offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
name|sc
operator|->
name|rbhead
operator|=
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nrxbufs
expr_stmt|;
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbtail
index|]
operator|->
name|ie_rbd_length
operator|&=
operator|~
name|IE_RBD_LAST
expr_stmt|;
name|sc
operator|->
name|rbtail
operator|=
operator|(
name|sc
operator|->
name|rbtail
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nrxbufs
expr_stmt|;
block|}
comment|/* 	 * Unless something changed strangely while we were doing the copy, 	 * we have now copied everything in from the shared memory. This 	 * means that we are done. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read frame NUM from unit UNIT (pre-cached as IE).  *  * This routine reads the RFD at NUM, and copies in the buffers from  * the list of RBD, then rotates the RBD and RFD lists so that the receiver  * doesn't start complaining.  Trailers are DROPPED---there's no point  * in wasting time on confusing code to deal with them.	 Hopefully,  * this machine will never ARP for trailers anyway.  */
end_comment

begin_function
specifier|static
name|void
name|ie_readframe
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|int
name|num
comment|/* frame number to read */
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ie_recv_frame_desc
name|rfd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
call|(
name|v_caddr_t
call|)
argument_list|(
name|sc
operator|->
name|rframes
index|[
name|num
index|]
argument_list|)
argument_list|,
operator|&
name|rfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ie_recv_frame_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Immediately advance the RFD list, since we we have copied ours 	 * now. 	 */
name|sc
operator|->
name|rframes
index|[
name|num
index|]
operator|->
name|ie_fd_status
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rframes
index|[
name|num
index|]
operator|->
name|ie_fd_last
operator||=
name|IE_FD_LAST
expr_stmt|;
name|sc
operator|->
name|rframes
index|[
name|sc
operator|->
name|rftail
index|]
operator|->
name|ie_fd_last
operator|&=
operator|~
name|IE_FD_LAST
expr_stmt|;
name|sc
operator|->
name|rftail
operator|=
operator|(
name|sc
operator|->
name|rftail
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nframes
expr_stmt|;
name|sc
operator|->
name|rfhead
operator|=
operator|(
name|sc
operator|->
name|rfhead
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nframes
expr_stmt|;
if|if
condition|(
name|rfd
operator|.
name|ie_fd_status
operator|&
name|IE_FD_OK
condition|)
block|{
if|if
condition|(
name|ieget
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|)
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
comment|/* this counts as an 							 * error */
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie_debug
operator|&
name|IED_READFRAME
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"frame from ether %6D type %x\n"
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
literal|":"
argument_list|,
operator|(
name|unsigned
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|>
name|ETHERTYPE_TRAIL
operator|&&
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|<
operator|(
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
operator|)
condition|)
name|printf
argument_list|(
literal|"received trailer!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m
condition|)
return|return;
comment|/* 	 * Finally pass this packet up to higher layers. 	 */
name|IE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_drop_packet_buffer
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
do|do
block|{
comment|/* 		 * This means we are somehow out of sync.  So, we reset the 		 * adapter. 		 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_USED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|print_rbd
argument_list|(
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: receive descriptors out of sync at %d\n"
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|sc
operator|->
name|rbhead
argument_list|)
expr_stmt|;
name|iereset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_LAST
expr_stmt|;
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rbhead
operator|=
operator|(
name|sc
operator|->
name|rbhead
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nrxbufs
expr_stmt|;
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|rbtail
index|]
operator|->
name|ie_rbd_length
operator|&=
operator|~
name|IE_RBD_LAST
expr_stmt|;
name|sc
operator|->
name|rbtail
operator|=
operator|(
name|sc
operator|->
name|rbtail
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nrxbufs
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|i
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Start transmission on an interface.  */
end_comment

begin_function
specifier|static
name|void
name|iestart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iestart_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iestart_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|volatile
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|u_short
name|len
decl_stmt|;
comment|/* 	 * This is not really volatile, in this routine, but it makes gcc 	 * happy. 	 */
specifier|volatile
name|u_short
modifier|*
name|bptr
init|=
operator|&
name|sc
operator|->
name|scb
operator|->
name|ie_command_list
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
return|return;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
break|break;
name|buffer
operator|=
name|sc
operator|->
name|xmit_cbuffs
index|[
name|sc
operator|->
name|xmit_count
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|&&
name|len
operator|<
name|IE_BUF_LEN
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|len
operator|=
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* 		 * See if bpf is listening on this interface, let it see the 		 * packet before we commit it to the wire. 		 */
name|BPF_TAP
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|xmit_cbuffs
index|[
name|sc
operator|->
name|xmit_count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xmit_buffs
index|[
name|sc
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_flags
operator|=
name|IE_XMIT_LAST
operator||
name|len
expr_stmt|;
name|sc
operator|->
name|xmit_buffs
index|[
name|sc
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_next
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|xmit_buffs
index|[
name|sc
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_buf
operator|=
name|MK_24
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|sc
operator|->
name|xmit_cbuffs
index|[
name|sc
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xmit_cmds
index|[
name|sc
operator|->
name|xmit_count
index|]
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_XMIT
expr_stmt|;
name|sc
operator|->
name|xmit_cmds
index|[
name|sc
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_status
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|xmit_cmds
index|[
name|sc
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_desc
operator|=
name|MK_16
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|sc
operator|->
name|xmit_buffs
index|[
name|sc
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
operator|*
name|bptr
operator|=
name|MK_16
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|sc
operator|->
name|xmit_cmds
index|[
name|sc
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
name|bptr
operator|=
operator|&
name|sc
operator|->
name|xmit_cmds
index|[
name|sc
operator|->
name|xmit_count
index|]
operator|->
name|com
operator|.
name|ie_cmd_link
expr_stmt|;
name|sc
operator|->
name|xmit_count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|xmit_count
operator|<
name|sc
operator|->
name|ntxbufs
condition|)
do|;
comment|/* 	 * If we queued up anything for transmission, send it. 	 */
if|if
condition|(
name|sc
operator|->
name|xmit_count
condition|)
block|{
name|sc
operator|->
name|xmit_cmds
index|[
name|sc
operator|->
name|xmit_count
operator|-
literal|1
index|]
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator||=
name|IE_CMD_LAST
operator||
name|IE_CMD_INTR
expr_stmt|;
comment|/* 		 * By passing the command pointer as a null, we tell 		 * command_and_wait() to pretend that this isn't an action 		 * command.  I wish I understood what was happening here. 		 */
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_CU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Check to see if there's an 82586 out there.  */
end_comment

begin_function
name|int
name|check_ie_present
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_sys_conf_ptr
modifier|*
name|scp
decl_stmt|;
specifier|volatile
name|struct
name|ie_int_sys_conf_ptr
modifier|*
name|iscp
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
decl_stmt|;
name|u_long
name|realbase
decl_stmt|;
name|realbase
operator|=
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|iomembot
operator|+
name|sc
operator|->
name|iosize
operator|-
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
name|scp
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_sys_conf_ptr
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|realbase
operator|+
name|IE_SCP_ADDR
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|scp
argument_list|,
sizeof|sizeof
expr|*
name|scp
argument_list|)
expr_stmt|;
comment|/* 	 * First we put the ISCP at the bottom of memory; this tests to make 	 * sure that our idea of the size of memory is the same as the 	 * controller's. This is NOT where the ISCP will be in normal 	 * operation. 	 */
name|iscp
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_int_sys_conf_ptr
operator|*
operator|)
name|sc
operator|->
name|iomembot
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
argument_list|,
sizeof|sizeof
expr|*
name|iscp
argument_list|)
expr_stmt|;
name|scb
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_sys_ctl_block
operator|*
operator|)
name|sc
operator|->
name|iomembot
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|scb
argument_list|,
sizeof|sizeof
expr|*
name|scb
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ie_bus_use
operator|=
name|sc
operator|->
name|bus_use
expr_stmt|;
comment|/* 8-bit or 16-bit */
name|scp
operator|->
name|ie_iscp_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
operator|-
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|realbase
argument_list|)
expr_stmt|;
name|iscp
operator|->
name|ie_busy
operator|=
literal|1
expr_stmt|;
name|iscp
operator|->
name|ie_scb_offset
operator|=
name|MK_16
argument_list|(
name|realbase
argument_list|,
name|scb
argument_list|)
operator|+
literal|256
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|ie_reset_586
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|ie_chan_attn
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* wait a while... */
if|if
condition|(
name|iscp
operator|->
name|ie_busy
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now relocate the ISCP to its real home, and reset the controller 	 * again. 	 */
name|iscp
operator|=
operator|(
name|void
operator|*
operator|)
name|Align
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|realbase
operator|+
name|IE_SCP_ADDR
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ie_int_sys_conf_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
argument_list|,
sizeof|sizeof
expr|*
name|iscp
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|scp
operator|->
name|ie_iscp_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|iscp
operator|-
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|realbase
argument_list|)
expr_stmt|;
name|iscp
operator|->
name|ie_busy
operator|=
literal|1
expr_stmt|;
name|iscp
operator|->
name|ie_scb_offset
operator|=
name|MK_16
argument_list|(
name|realbase
argument_list|,
name|scb
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|ie_reset_586
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|ie_chan_attn
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscp
operator|->
name|ie_busy
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|iomem
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|realbase
expr_stmt|;
name|sc
operator|->
name|iscp
operator|=
name|iscp
expr_stmt|;
name|sc
operator|->
name|scb
operator|=
name|scb
expr_stmt|;
comment|/* 	 * Acknowledge any interrupts we may have caused... 	 */
name|ie_ack
argument_list|(
name|sc
argument_list|,
name|IE_ST_WHENCE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|el_reset_586
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IE507_CTRL
argument_list|,
name|EL_CTRL_NORMAL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_reset_586
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEATT_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ee16_reset_586
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_ECTRL
argument_list|,
name|IEE16_RESET_586
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_ECTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|el_chan_attn
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IE507_ATTN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_chan_attn
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEATT_ATTN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ee16_chan_attn
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_ATTN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ee16_interrupt_enable
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
name|IEE16_IRQ
argument_list|,
name|sc
operator|->
name|irq_encoded
operator||
name|IEE16_IRQ_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_read_ether
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|addr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iereset
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"reset\n"
argument_list|)
expr_stmt|;
name|ie_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop i82586 dead in its tracks. 	 */
if|if
condition|(
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_ABORT
operator||
name|IE_CU_ABORT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"abort commands timed out\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_DISABLE
operator||
name|IE_CU_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"disable commands timed out\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|!
name|check_ie_present
argument_list|(
name|sc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ie disappeared!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|ieinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Send a command to the controller and wait for it to either  * complete or be accepted, depending on the command.  If the  * command pointer is null, then pretend that the command is  * not an action command.  If the command pointer is not null,  * and the command is an action command, wait for  * ((volatile struct ie_cmd_common *)pcmd)->ie_cmd_status& MASK  * to become true.  */
end_comment

begin_function
specifier|static
name|int
name|command_and_wait
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|,
specifier|volatile
name|void
modifier|*
name|pcmd
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_cmd_common
modifier|*
name|cc
init|=
name|pcmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_command
operator|=
operator|(
name|u_short
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|IE_ACTION_COMMAND
argument_list|(
name|cmd
argument_list|)
operator|&&
name|pcmd
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|ie_chan_attn
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Now spin-lock waiting for status.  This is not a very 		 * nice thing to do, but I haven't figured out how, or 		 * indeed if, we can put the process waiting for action to 		 * sleep.  (We may be getting called through some other 		 * timeout running in the kernel.) 		 * 		 * According to the packet driver, the minimum timeout 		 * should be .369 seconds, which we round up to .37. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|370
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cc
operator|->
name|ie_cmd_status
operator|&
name|mask
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, just wait for the command to be accepted. 		 */
call|(
modifier|*
name|sc
operator|->
name|ie_chan_attn
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|scb
operator|->
name|ie_command
condition|)
empty_stmt|;
comment|/* spin lock */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Run the time-domain reflectometer...  */
end_comment

begin_function
specifier|static
name|void
name|run_tdr
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|struct
name|ie_tdr_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_TDR
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|cmd
operator|->
name|ie_tdr_time
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ie_tdr_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
condition|)
name|result
operator|=
literal|0x2000
expr_stmt|;
else|else
name|result
operator|=
name|cmd
operator|->
name|ie_tdr_time
expr_stmt|;
name|ie_ack
argument_list|(
name|sc
argument_list|,
name|IE_ST_WHENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|IE_TDR_SUCCESS
condition|)
return|return;
if|if
condition|(
name|result
operator|&
name|IE_TDR_XCVR
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"transceiver problem\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|&
name|IE_TDR_OPEN
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"TDR detected an open %d clocks away\n"
argument_list|,
name|result
operator|&
name|IE_TDR_TIME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|&
name|IE_TDR_SHORT
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"TDR detected a short %d clocks away\n"
argument_list|,
name|result
operator|&
name|IE_TDR_TIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"TDR returned unknown status %x\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|start_receiver
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ie_ack
argument_list|(
name|sc
argument_list|,
name|IE_ST_WHENCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Here is a helper routine for iernr() and ieinit().  This sets up  * the RFA.  */
end_comment

begin_function
specifier|static
name|v_caddr_t
name|setup_rfa
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|,
name|v_caddr_t
name|ptr
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_recv_frame_desc
modifier|*
name|rfd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First lay them out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rframes
index|[
name|i
index|]
operator|=
name|rfd
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|rfd
argument_list|,
sizeof|sizeof
expr|*
name|rfd
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|rfd
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
name|Alignvol
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
comment|/* Now link them together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rframes
index|[
name|i
index|]
operator|->
name|ie_fd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rframes
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nframes
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, set the EOL bit on the last one. */
name|sc
operator|->
name|rframes
index|[
name|sc
operator|->
name|nframes
operator|-
literal|1
index|]
operator|->
name|ie_fd_last
operator||=
name|IE_FD_LAST
expr_stmt|;
comment|/* 	 * Now lay out some buffers for the incoming frames.  Note that we 	 * set aside a bit of slop in each buffer, to make sure that we have 	 * enough space to hold a single frame in every buffer. 	 */
name|rbd
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nrxbufs
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rbuffs
index|[
name|i
index|]
operator|=
name|rbd
expr_stmt|;
name|bzero
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|rbd
argument_list|,
sizeof|sizeof
expr|*
name|rbd
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
operator|+
sizeof|sizeof
expr|*
name|rbd
argument_list|)
expr_stmt|;
name|rbd
operator|->
name|ie_rbd_length
operator|=
name|IE_RBUF_SIZE
expr_stmt|;
name|rbd
operator|->
name|ie_rbd_buffer
operator|=
name|MK_24
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cbuffs
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|IE_RBUF_SIZE
expr_stmt|;
name|rbd
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
comment|/* Now link them together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nrxbufs
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rbuffs
index|[
name|i
index|]
operator|->
name|ie_rbd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rbuffs
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|nrxbufs
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Tag EOF on the last one */
name|sc
operator|->
name|rbuffs
index|[
name|sc
operator|->
name|nrxbufs
operator|-
literal|1
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
comment|/* 	 * We use the head and tail pointers on receive to keep track of the 	 * order in which RFDs and RBDs are used. 	 */
name|sc
operator|->
name|rfhead
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rftail
operator|=
name|sc
operator|->
name|nframes
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|rbhead
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rbtail
operator|=
name|sc
operator|->
name|nrxbufs
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rframes
index|[
literal|0
index|]
operator|->
name|ie_fd_buf_desc
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|rbuffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the multicast setup command.  */
end_comment

begin_function
specifier|static
name|int
name|mc_setup
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_mcast_cmd
modifier|*
name|cmd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|sc
operator|->
name|xmit_cbuffs
index|[
literal|0
index|]
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_MCAST
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
comment|/* ignore cast-qual */
name|bcopy
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|sc
operator|->
name|mcast_addrs
argument_list|,
operator|(
name|v_caddr_t
operator|)
name|cmd
operator|->
name|ie_mcast_addrs
argument_list|,
name|sc
operator|->
name|mcast_count
operator|*
sizeof|sizeof
expr|*
name|sc
operator|->
name|mcast_addrs
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ie_mcast_bytes
operator|=
name|sc
operator|->
name|mcast_count
operator|*
literal|6
expr_stmt|;
comment|/* grrr... */
name|sc
operator|->
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"multicast address setup command failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine takes the environment generated by check_ie_present()  * and adds to it all the other structures we need to operate the adapter.  * This includes executing the CONFIGURE, IA-SETUP, and MC-SETUP commands,  * starting the receiver unit, and clearing interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|ieinit
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ie_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|IE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieinit_locked
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
init|=
name|sc
operator|->
name|scb
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|scb
operator|+
sizeof|sizeof
expr|*
name|scb
argument_list|)
expr_stmt|;
comment|/* 	 * Send the configure command first. 	 */
block|{
specifier|volatile
name|struct
name|ie_config_cmd
modifier|*
name|cmd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|ie_setup_config
argument_list|(
name|cmd
argument_list|,
name|sc
operator|->
name|promisc
argument_list|,
name|sc
operator|->
name|hard_type
operator|==
name|IE_STARLAN10
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_CONFIG
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"configure command failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now send the Individual Address Setup command. 	 */
block|{
specifier|volatile
name|struct
name|ie_iasetup_cmd
modifier|*
name|cmd
init|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_IASETUP
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|bcopy
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|&
name|cmd
operator|->
name|ie_address
argument_list|,
sizeof|sizeof
name|cmd
operator|->
name|ie_address
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|(
name|sc
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"individual address "
literal|"setup command failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now run the time-domain reflectometer. 	 */
name|run_tdr
argument_list|(
name|sc
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
comment|/* 	 * Acknowledge any interrupts we have generated thus far. 	 */
name|ie_ack
argument_list|(
name|sc
argument_list|,
name|IE_ST_WHENCE
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the RFA. 	 */
name|ptr
operator|=
name|setup_rfa
argument_list|(
name|sc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, the transmit command and buffer are the last little bit 	 * of work. 	 */
comment|/* transmit command buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ntxbufs
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|xmit_cmds
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|sc
operator|->
name|xmit_cmds
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xmit_buffs
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|sc
operator|->
name|xmit_buffs
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|/* transmit buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ntxbufs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|xmit_cbuffs
index|[
name|i
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|IE_BUF_LEN
expr_stmt|;
name|ptr
operator|=
name|Alignvol
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|xmit_cbuffs
index|[
name|sc
operator|->
name|ntxbufs
operator|-
literal|1
index|]
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|ntxbufs
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|sc
operator|->
name|xmit_cmds
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
expr|*
name|sc
operator|->
name|xmit_cmds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|v_caddr_t
operator|)
name|sc
operator|->
name|xmit_buffs
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
expr|*
name|sc
operator|->
name|xmit_buffs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This must be coordinated with iestart() and ietint(). 	 */
name|sc
operator|->
name|xmit_cmds
index|[
literal|0
index|]
operator|->
name|ie_xmit_status
operator|=
name|IE_STAT_COMPL
expr_stmt|;
comment|/* take the ee16 out of loopback */
if|if
condition|(
name|sc
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
block|{
name|u_int8_t
name|bart_config
decl_stmt|;
name|bart_config
operator|=
name|inb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_CONFIG
argument_list|)
expr_stmt|;
name|bart_config
operator|&=
operator|~
name|IEE16_BART_LOOPBACK
expr_stmt|;
comment|/* inb doesn't get bit! */
name|bart_config
operator||=
name|IEE16_BART_MCS16_TEST
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|sc
argument_list|)
operator|+
name|IEE16_CONFIG
argument_list|,
name|bart_config
argument_list|)
expr_stmt|;
name|ee16_interrupt_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ee16_chan_attn
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* tell higher levels 							 * we're here */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|start_receiver
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_stop
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|sc
argument_list|,
name|IE_RU_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * Note that this device doesn't have an "all multicast" 		 * mode, so we must turn on promiscuous mode and do the 		 * filtering manually. 		 */
name|IE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|ie_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
expr_stmt|;
name|ieinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|promisc
operator|^
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
condition|)
block|{
name|sc
operator|->
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
expr_stmt|;
name|ieinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Update multicast listeners 		 */
comment|/* reset multicast filtering */
name|IE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ie_mc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_mc_reset
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* 	 * Step through the list of addresses. 	 */
name|sc
operator|->
name|mcast_count
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&sc->ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
comment|/* XXX - this is broken... */
if|if
condition|(
name|sc
operator|->
name|mcast_count
operator|>=
name|MAXMCAST
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|ieinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|setflag
goto|;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|mcast_addrs
index|[
name|sc
operator|->
name|mcast_count
index|]
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mcast_count
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|setflag
label|:
name|sc
operator|->
name|want_mcsetup
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|print_rbd
parameter_list|(
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
parameter_list|)
block|{
name|printf
argument_list|(
literal|"RBD at %p:\n"
literal|"actual %04x, next %04x, buffer %p\n"
literal|"length %04x, mbz %04x\n"
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|rbd
argument_list|,
name|rbd
operator|->
name|ie_rbd_actual
argument_list|,
name|rbd
operator|->
name|ie_rbd_next
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rbd
operator|->
name|ie_rbd_buffer
argument_list|,
name|rbd
operator|->
name|ie_rbd_length
argument_list|,
name|rbd
operator|->
name|mbz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
name|int
name|ie_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|io_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|io_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No I/O space?!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|io_bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io_bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mem_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No Memory!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|mem_bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No IRQ!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|port
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
comment|/* XXX hack */
name|sc
operator|->
name|iomembot
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iosize
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ie_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|irq_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rframes
condition|)
name|free
argument_list|(
name|sc
operator|->
name|rframes
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|io_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|io_rid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ie_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|IE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hard_type
operator|==
name|IE_EE16
condition|)
name|ee16_shutdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ie_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ie_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

