begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Aironet 4500/4800 802.11 PCMCIA/ISA/PCI driver for FreeBSD.  *  * Written by Bill Paul<wpaul@ctr.columbia.edu>  * Electrical Engineering Department  * Columbia University, New York City  */
end_comment

begin_comment
comment|/*  * The Aironet 4500/4800 series cards some in PCMCIA, ISA and PCI form.  * This driver supports all three device types (PCI devices are supported  * through an extra PCI shim: /sys/pci/if_an_p.c). ISA devices can be  * supported either using hard-coded IO port/IRQ settings or via Plug  * and Play. The 4500 series devices support 1Mbps and 2Mbps data rates.  * The 4800 devices support 1, 2, 5.5 and 11Mbps rates.  *  * Like the WaveLAN/IEEE cards, the Aironet NICs are all essentially  * PCMCIA devices. The ISA and PCI cards are a combination of a PCMCIA  * device and a PCMCIA to ISA or PCMCIA to PCI adapter card. There are  * a couple of important differences though:  *  * - Lucent doesn't currently offer a PCI card, however Aironet does  * - Lucent ISA card looks to the host like a PCMCIA controller with  *   a PCMCIA WaveLAN card inserted. This means that even desktop  *   machines need to be configured with PCMCIA support in order to  *   use WaveLAN/IEEE ISA cards. The Aironet cards on the other hand  *   actually look like normal ISA and PCI devices to the host, so  *   no PCMCIA controller support is needed  *  * The latter point results in a small gotcha. The Aironet PCMCIA  * cards can be configured for one of two operating modes depending  * on how the Vpp1 and Vpp2 programming voltages are set when the  * card is activated. In order to put the card in proper PCMCIA  * operation (where the CIS table is visible and the interface is  * programmed for PCMCIA operation), both Vpp1 and Vpp2 have to be  * set to 5 volts. FreeBSD by default doesn't set the Vpp voltages,  * which leaves the card in ISA/PCI mode, which prevents it from  * being activated as an PCMCIA device. Consequently, /sys/pccard/pccard.c  * has to be patched slightly in order to enable the Vpp voltages in  * order to make the Aironet PCMCIA cards work.  *  * Note that some PCMCIA controller software packages for Windows NT  * fail to set the voltages as well.  *   * The Aironet devices can operate in both station mode and access point  * mode. Typically, when programmed for station mode, the card can be set  * to automatically perform encapsulation/decapsulation of Ethernet II  * and 802.3 frames within 802.11 frames so that the host doesn't have  * to do it itself. This driver doesn't program the card that way: the  * driver handles all of the encapsulation/decapsulation itself.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_define
define|#
directive|define
name|ANCACHE
end_define

begin_comment
comment|/* enable signal strength cache */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANCACHE
end_ifdef

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/an/if_aironet_ieee.h>
end_include

begin_include
include|#
directive|include
file|<dev/an/if_anreg.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are global because we need them in sys/pci/if_an_p.c. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|an_reset
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_init_tx_ring
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_rxeof
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_txeof
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_read_record
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|an_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_write_record
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|an_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_read_data
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_write_data
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_seek
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_alloc_nicmem
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_stats_update
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_setdef
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|an_req
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ANCACHE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|an_cache_store
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|ether_header
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|unsigned
name|short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * We probe for an Aironet 4500/4800 card by attempting to  * read the default SSID list. On reset, the first entry in  * the SSID list will contain the name "tsunami." If we don't  * find this, then there's no card present.  */
end_comment

begin_function
name|int
name|an_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|an_ltv_ssidlist
name|ssid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ssid
argument_list|,
sizeof|sizeof
argument_list|(
name|ssid
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|an_alloc_port
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|AN_IOSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* can't do autoprobing */
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We need to fake up a softc structure long enough 	 * to be able to issue commands and call some of the 	 * other routines. 	 */
name|sc
operator|->
name|an_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ssid
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
name|ssid
argument_list|)
expr_stmt|;
name|ssid
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
comment|/* Make sure interrupts are disabled. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_READCFG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|ssid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* See if the ssid matches what we expect. */
if|if
condition|(
name|strcmp
argument_list|(
name|ssid
operator|.
name|an_ssid1
argument_list|,
name|AN_DEF_SSID
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|AN_IOSIZ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a port resource with the given resource id.  */
end_comment

begin_function
name|int
name|an_alloc_port
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|size
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|port_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate an irq resource with the given resource id.  */
end_comment

begin_function
name|int
name|an_alloc_irq
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
operator|(
name|RF_ACTIVE
operator||
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|irq_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release all resources  */
end_comment

begin_function
name|void
name|an_release_resources
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|an_attach
parameter_list|(
name|sc
parameter_list|,
name|unit
parameter_list|,
name|flags
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|sc
operator|->
name|an_gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
comment|/* Reset the NIC. */
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load factory config */
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_READCFG
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to load config data\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read the current configuration */
name|sc
operator|->
name|an_config
operator|.
name|an_type
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read the card capabilities */
name|sc
operator|->
name|an_caps
operator|.
name|an_type
operator|=
name|AN_RID_CAPABILITIES
expr_stmt|;
name|sc
operator|->
name|an_caps
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_caps
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read ssid list */
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_ssidlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_ssidlist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read AP list */
name|sc
operator|->
name|an_aplist
operator|.
name|an_type
operator|=
name|AN_RID_APLIST
expr_stmt|;
name|sc
operator|->
name|an_aplist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_aplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_aplist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_caps
operator|.
name|an_oemaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"an%d: Ethernet address: %6D\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|an_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"an"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|an_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|an_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|an_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|an_init
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|an_config
operator|.
name|an_nodename
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|an_config
operator|.
name|an_nodename
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|AN_DEFAULT_NODENAME
argument_list|,
name|sc
operator|->
name|an_config
operator|.
name|an_nodename
argument_list|,
sizeof|sizeof
argument_list|(
name|AN_DEFAULT_NODENAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|AN_DEFAULT_NETNAME
argument_list|,
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1
argument_list|,
sizeof|sizeof
argument_list|(
name|AN_DEFAULT_NETNAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1_len
operator|=
name|strlen
argument_list|(
name|AN_DEFAULT_NETNAME
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_opmode
operator|=
name|AN_OPMODE_IBSS_ADHOC
expr_stmt|;
name|sc
operator|->
name|an_tx_rate
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|an_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Call MI attach routines. 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|an_stat_ch
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_rxeof
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|ANCACHE
name|struct
name|an_rxframe
name|rx_frame
decl_stmt|;
endif|#
directive|endif
name|struct
name|an_rxframe_802_3
name|rx_frame_802_3
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|id
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RX_FID
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ANCACHE
comment|/* Read NIC frame header */
if|if
condition|(
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Read in the 802_3 frame header */
if|if
condition|(
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x34
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame_802_3
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame_802_3
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rx_frame_802_3
operator|.
name|an_rx_802_3_status
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Check for insane frame length */
if|if
condition|(
name|rx_frame_802_3
operator|.
name|an_rx_802_3_payload_len
operator|>
name|MCLBYTES
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame_802_3
operator|.
name|an_rx_802_3_payload_len
operator|+
literal|12
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame_802_3
operator|.
name|an_rx_dst_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame_802_3
operator|.
name|an_rx_src_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* in mbuf header type is just before payload */
name|error
operator|=
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x44
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|eh
operator|->
name|ether_type
operator|)
argument_list|,
name|rx_frame_802_3
operator|.
name|an_rx_802_3_payload_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Receive packet. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ANCACHE
name|an_cache_store
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|m
argument_list|,
name|rx_frame
operator|.
name|an_rx_signal_strength
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_txeof
parameter_list|(
name|sc
parameter_list|,
name|status
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|id
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_TX_CMP_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|AN_EV_TX_EXC
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_cons
index|]
condition|)
name|printf
argument_list|(
literal|"an%d: id mismatch: expected %x, got %x\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_cons
index|]
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_cons
index|]
operator|=
literal|0
expr_stmt|;
name|AN_INC
argument_list|(
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_cons
argument_list|,
name|AN_TX_RING_CNT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * We abuse the stats updater to check the current NIC status. This  * is important because we don't want to allow transmissions until  * the NIC has synchronized to the current cell (either as the master  * in an ad-hoc group, or as a station connected to an access point).  */
end_comment

begin_function
name|void
name|an_stats_update
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|sc
operator|->
name|an_status
operator|.
name|an_type
operator|=
name|AN_RID_STATUS
expr_stmt|;
name|sc
operator|->
name|an_status
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_status
argument_list|)
expr_stmt|;
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_status
operator|.
name|an_opmode
operator|&
name|AN_STATUS_OPMODE_IN_SYNC
condition|)
name|sc
operator|->
name|an_associated
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
comment|/* Don't do this while we're transmitting */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_stat_ch
operator|=
name|timeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|an_stats
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_stats
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_stats
operator|.
name|an_type
operator|=
name|AN_RID_32BITS_CUM
expr_stmt|;
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_stats
operator|.
name|an_len
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_stat_ch
operator|=
name|timeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|an_intr
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|an_softc
operator|*
operator|)
name|xsc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_STAT
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
operator|~
name|AN_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|AN_EV_AWAKE
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_AWAKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_LINKSTAT
condition|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_LINKSTAT
argument_list|)
operator|==
name|AN_LINKSTAT_ASSOCIATED
condition|)
name|sc
operator|->
name|an_associated
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_LINKSTAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_RX
condition|)
block|{
name|an_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_RX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_TX
condition|)
block|{
name|an_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_TX_EXC
condition|)
block|{
name|an_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_TX_EXC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_ALLOC
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_ALLOC
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
name|AN_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|an_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|an_cmd
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|,
name|val
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_PARAM0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_PARAM1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_PARAM2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_STAT
argument_list|)
operator|&
name|AN_EV_CMD
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|)
operator|==
name|cmd
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RESP0
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RESP1
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RESP2
argument_list|)
expr_stmt|;
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|AN_STAT_CMD_CODE
operator|)
operator|==
operator|(
name|cmd
operator|&
name|AN_STAT_CMD_CODE
operator|)
condition|)
break|break;
block|}
comment|/* Ack the command */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|)
operator|&
name|AN_CMD_BUSY
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_CLR_STUCK_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|AN_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This reset sequence may look a little strange, but this is the  * most reliable method I've found to really kick the NIC in the  * head and force it to reboot correctly.  */
end_comment

begin_function
specifier|static
name|void
name|an_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_FW_RESTART
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_NOOP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_FORCE_SYNCLOSS
argument_list|,
literal|0
argument_list|)
operator|==
name|ETIMEDOUT
condition|)
name|printf
argument_list|(
literal|"an%d: reset failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Read an LTV record from the NIC.  */
end_comment

begin_function
specifier|static
name|int
name|an_read_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|ltv
operator|->
name|an_len
operator|==
literal|0
operator|||
name|ltv
operator|->
name|an_type
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Tell the NIC to enter record read mode. */
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ACCESS
operator||
name|AN_ACCESS_READ
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: RID access failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Seek to the record. */
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|,
literal|0
argument_list|,
name|AN_BAP1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: seek to record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Read the length and record type and make sure they 	 * match what we expect (this verifies that we have enough 	 * room to hold all of the returned data). 	 */
name|len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ltv
operator|->
name|an_len
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: record length mismatch -- expected %d, "
literal|"got %d\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|ltv
operator|->
name|an_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|ltv
operator|->
name|an_len
operator|=
name|len
expr_stmt|;
comment|/* Now read the data. */
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|an_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ltv
operator|->
name|an_len
operator|-
literal|1
operator|)
operator|>>
literal|1
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as read, except we inject data instead of reading it.  */
end_comment

begin_function
specifier|static
name|int
name|an_write_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ACCESS
operator||
name|AN_ACCESS_READ
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|,
literal|0
argument_list|,
name|AN_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|,
name|ltv
operator|->
name|an_len
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|an_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ltv
operator|->
name|an_len
operator|-
literal|1
operator|)
operator|>>
literal|1
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ACCESS
operator||
name|AN_ACCESS_WRITE
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_seek
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|chan
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|,
name|chan
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|selreg
decl_stmt|,
name|offreg
decl_stmt|;
switch|switch
condition|(
name|chan
condition|)
block|{
case|case
name|AN_BAP0
case|:
name|selreg
operator|=
name|AN_SEL0
expr_stmt|;
name|offreg
operator|=
name|AN_OFF0
expr_stmt|;
break|break;
case|case
name|AN_BAP1
case|:
name|selreg
operator|=
name|AN_SEL1
expr_stmt|;
name|offreg
operator|=
name|AN_OFF1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"an%d: invalid data path: %x\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|selreg
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|,
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|)
operator|&
operator|(
name|AN_OFF_BUSY
operator||
name|AN_OFF_ERR
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|AN_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_read_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr2
decl_stmt|;
if|if
condition|(
name|off
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|AN_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|ptr2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ptr2
index|[
name|i
index|]
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_write_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr2
decl_stmt|;
if|if
condition|(
name|off
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|AN_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA0
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|ptr2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|AN_DATA0
argument_list|,
name|ptr2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a region of memory inside the NIC and zero  * it out.  */
end_comment

begin_function
specifier|static
name|int
name|an_alloc_nicmem
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|id
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ALLOC_MEM
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to allocate %d bytes on NIC\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_STAT
argument_list|)
operator|&
name|AN_EV_ALLOC
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|AN_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_ALLOC
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_ALLOC_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
operator|*
name|id
argument_list|,
literal|0
argument_list|,
name|AN_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_setdef
parameter_list|(
name|sc
parameter_list|,
name|areq
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_req
modifier|*
name|areq
decl_stmt|;
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|an_ltv_genconfig
modifier|*
name|cfg
decl_stmt|;
name|struct
name|an_ltv_ssidlist
modifier|*
name|ssid
decl_stmt|;
name|struct
name|an_ltv_aplist
modifier|*
name|ap
decl_stmt|;
name|struct
name|an_ltv_gen
modifier|*
name|sp
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
switch|switch
condition|(
name|areq
operator|->
name|an_type
condition|)
block|{
case|case
name|AN_RID_GENCONFIG
case|:
name|cfg
operator|=
operator|(
expr|struct
name|an_ltv_genconfig
operator|*
operator|)
name|areq
expr_stmt|;
name|ifa
operator|=
name|ifnet_addrs
index|[
name|ifp
operator|->
name|if_index
operator|-
literal|1
index|]
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cfg
operator|->
name|an_macaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cfg
operator|->
name|an_macaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cfg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN_RID_SSIDLIST
case|:
name|ssid
operator|=
operator|(
expr|struct
name|an_ltv_ssidlist
operator|*
operator|)
name|areq
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ssid
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_ssidlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_ssidlist
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN_RID_APLIST
case|:
name|ap
operator|=
operator|(
expr|struct
name|an_ltv_aplist
operator|*
operator|)
name|areq
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_aplist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_aplist
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN_RID_TX_SPEED
case|:
name|sp
operator|=
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
name|areq
expr_stmt|;
name|sc
operator|->
name|an_tx_rate
operator|=
name|sp
operator|->
name|an_val
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"an%d: unknown RID: %x\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|areq
operator|->
name|an_type
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
comment|/* Reinitialize the card. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * We can't change the NIC configuration while the MAC is enabled,  * so in order to turn on RX monitor mode, we have to turn the MAC  * off first.  */
end_comment

begin_function
specifier|static
name|void
name|an_promisc
parameter_list|(
name|sc
parameter_list|,
name|promisc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|promisc
decl_stmt|;
block|{
comment|/* Disable the MAC. */
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set RX mode. */
if|if
condition|(
name|promisc
operator|&&
operator|!
operator|(
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|&
name|AN_RXMODE_LAN_MONITOR_CURBSS
operator|)
condition|)
block|{
name|sc
operator|->
name|an_rxmode
operator|=
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator||=
name|AN_RXMODE_LAN_MONITOR_CURBSS
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|=
name|sc
operator|->
name|an_rxmode
expr_stmt|;
block|}
comment|/* Transfer the configuration to the NIC */
name|sc
operator|->
name|an_config
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_type
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
if|if
condition|(
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to set configuration\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Turn the MAC back on. */
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|an_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_req
name|areq
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|an_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|an_promisc
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|an_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|an_promisc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|an_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|an_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* The Aironet has no multicast filter. */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGAIRONET
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|areq
argument_list|,
sizeof|sizeof
argument_list|(
name|areq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
ifdef|#
directive|ifdef
name|ANCACHE
if|if
condition|(
name|areq
operator|.
name|an_type
operator|==
name|AN_RID_ZERO_CACHE
condition|)
block|{
name|sc
operator|->
name|an_sigitems
operator|=
name|sc
operator|->
name|an_nextitem
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|areq
operator|.
name|an_type
operator|==
name|AN_RID_READ_CACHE
condition|)
block|{
name|char
modifier|*
name|pt
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|areq
operator|.
name|an_val
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_sigitems
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|/
literal|2
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_sigcache
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|an_sigitems
argument_list|)
expr_stmt|;
name|areq
operator|.
name|an_len
operator|+=
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|an_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|an_sigitems
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|areq
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|areq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSAIRONET
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|areq
argument_list|,
sizeof|sizeof
argument_list|(
name|areq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|an_setdef
argument_list|(
name|sc
argument_list|,
operator|&
name|areq
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_init_tx_ring
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|id
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|an_alloc_nicmem
argument_list|(
name|sc
argument_list|,
literal|1518
operator|+
literal|0x44
argument_list|,
operator|&
name|id
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_fids
index|[
name|i
index|]
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_cons
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|an_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the TX buffers */
if|if
condition|(
name|an_init_tx_ring
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_init_tx_ring
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: tx buffer allocation "
literal|"failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Set our MAC address. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
operator|.
name|an_macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|=
name|AN_RXMODE_BC_ADDR
expr_stmt|;
else|else
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|=
name|AN_RXMODE_ADDR
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|=
name|AN_RXMODE_BC_MC_ADDR
expr_stmt|;
comment|/* Initialize promisc mode. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator||=
name|AN_RXMODE_LAN_MONITOR_CURBSS
expr_stmt|;
name|sc
operator|->
name|an_rxmode
operator|=
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
expr_stmt|;
comment|/* Set the ssid list */
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_ssidlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_ssidlist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to set ssid list\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set the AP list */
name|sc
operator|->
name|an_aplist
operator|.
name|an_type
operator|=
name|AN_RID_APLIST
expr_stmt|;
name|sc
operator|->
name|an_aplist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_aplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_aplist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to set AP list\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set the configuration in the NIC */
name|sc
operator|->
name|an_config
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_type
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
if|if
condition|(
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to set configuration\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Enable the MAC */
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to enable MAC\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* enable interrupts */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
name|AN_INTRS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|an_stat_ch
operator|=
name|timeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|an_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|struct
name|an_txframe_802_3
name|tx_frame_802_3
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|unsigned
name|char
name|txcontrol
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
if|if
condition|(
operator|!
name|sc
operator|->
name|an_associated
condition|)
return|return;
name|idx
operator|=
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_prod
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame_802_3
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_frame_802_3
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|idx
index|]
operator|==
literal|0
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
name|id
operator|=
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_fids
index|[
name|idx
index|]
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame_802_3
operator|.
name|an_tx_dst_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame_802_3
operator|.
name|an_tx_src_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame_802_3
operator|.
name|an_tx_802_3_payload_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|12
expr_stmt|;
comment|/* minus src/dest mac& type */
name|m_copydata
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
literal|2
argument_list|,
name|tx_frame_802_3
operator|.
name|an_tx_802_3_payload_len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|an_txbuf
argument_list|)
expr_stmt|;
name|txcontrol
operator|=
name|AN_TXCTL_8023
expr_stmt|;
comment|/* write the txcontrol only */
name|an_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x08
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|txcontrol
argument_list|,
sizeof|sizeof
argument_list|(
name|txcontrol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 802_3 header */
name|an_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x34
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame_802_3
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_txframe_802_3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* in mbuf header type is just before payload */
name|an_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x44
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|an_txbuf
argument_list|,
name|tx_frame_802_3
operator|.
name|an_tx_802_3_payload_len
argument_list|)
expr_stmt|;
comment|/* 		 * If there's a BPF listner, bounce a copy of 		 * this frame to him. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|idx
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_TX
argument_list|,
name|id
argument_list|)
condition|)
name|printf
argument_list|(
literal|"an%d: xmit failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|AN_INC
argument_list|(
name|idx
argument_list|,
name|AN_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_prod
operator|=
name|idx
expr_stmt|;
comment|/* 	 * Set a timeout in case the chip goes out to lunch. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|an_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_FORCE_SYNCLOSS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TX_RING_CNT
condition|;
name|i
operator|++
control|)
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DEALLOC_MEM
argument_list|,
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_fids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|an_stat_ch
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|an_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
name|printf
argument_list|(
literal|"an%d: device timeout\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|an_shutdown
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|an_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ANCACHE
end_ifdef

begin_comment
comment|/* Aironet signal strength cache code.  * store signal/noise/quality on per MAC src basis in  * a small fixed cache.  The cache wraps if> MAX slots  * used.  The cache may be zeroed out to start over.  * Two simple filters exist to reduce computation:  * 1. ip only (literally 0x800) which may be used  * to ignore some packets.  It defaults to ip only.  * it could be used to focus on broadcast, non-IP 802.11 beacons.  * 2. multicast/broadcast only.  This may be used to  * ignore unicast packets and only cache signal strength  * for multicast/broadcast packets (beacons); e.g., Mobile-IP  * beacons and not unicast traffic.  *  * The cache stores (MAC src(index), IP src (major clue), signal,  *	quality, noise)  *  * No apologies for storing IP src here.  It's easy and saves much  * trouble elsewhere.  The cache is assumed to be INET dependent,   * although it need not be.  *  * Note: the Aironet only has a single byte of signal strength value  * in the rx frame header, and it's not scaled to anything sensible.  * This is kind of lame, but it's all we've got.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|documentation
end_ifdef

begin_decl_stmt
name|int
name|an_sigitems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached entries */
end_comment

begin_decl_stmt
name|struct
name|an_sigcache
name|an_sigcache
index|[
name|MAXANCACHE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  array of cache entries */
end_comment

begin_decl_stmt
name|int
name|an_nextitem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  index/# of entries */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* control variables for cache filtering.  Basic idea is  * to reduce cost (e.g., to only Mobile-IP agent beacons  * which are broadcast or multicast).  Still you might  * want to measure signal strength anth unicast ping packets  * on a pt. to pt. ant. setup.  */
end_comment

begin_comment
comment|/* set true if you want to limit cache items to broadcast/mcast   * only packets (not unicast).  Useful for mobile-ip beacons which  * are broadcast/multicast at network layer.  Default is all packets  * so ping/unicast anll work say anth pt. to pt. antennae setup.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|an_cache_mcastonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|an_cache_mcastonly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|an_cache_mcastonly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set true if you want to limit cache items to IP packets only */
end_comment

begin_decl_stmt
specifier|static
name|int
name|an_cache_iponly
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|an_cache_iponly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|an_cache_iponly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * an_cache_store, per rx packet store signal  * strength in MAC (src) indexed cache.  */
end_comment

begin_function
specifier|static
name|void
name|an_cache_store
parameter_list|(
name|sc
parameter_list|,
name|eh
parameter_list|,
name|m
parameter_list|,
name|rx_quality
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|short
name|rx_quality
decl_stmt|;
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|cache_slot
init|=
literal|0
decl_stmt|;
comment|/* use this cache entry */
specifier|static
name|int
name|wrapindex
init|=
literal|0
decl_stmt|;
comment|/* next "free" cache entry */
name|int
name|saanp
init|=
literal|0
decl_stmt|;
comment|/* filters: 	 * 1. ip only 	 * 2. configurable filter to throw out unicast packets, 	 * keep multicast only. 	 */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
literal|0x800
operator|)
condition|)
block|{
name|saanp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* filter for ip packets only  	*/
if|if
condition|(
name|an_cache_iponly
operator|&&
operator|!
name|saanp
condition|)
block|{
return|return;
block|}
comment|/* filter for broadcast/multicast only 	 */
if|if
condition|(
name|an_cache_mcastonly
operator|&&
operator|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|SIGDEBUG
name|printf
argument_list|(
literal|"an: q value %x (MSB=0x%x, LSB=0x%x) \n"
argument_list|,
name|rx_quality
operator|&
literal|0xffff
argument_list|,
name|rx_quality
operator|>>
literal|8
argument_list|,
name|rx_quality
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* find the ip header.  we want to store the ip_src 	 * address.   	 */
if|if
condition|(
name|saanp
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* do a linear search for a matching MAC address  	 * in the cache table 	 * . MAC address is 6 bytes, 	 * . var w_nextitem holds total number of entries already cached 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|an_nextitem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|an_sigcache
index|[
name|i
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/* Match!, 			 * so we already have this entry, 			 * update the data 			 */
break|break;
block|}
block|}
comment|/* did we find a matching mac address? 	 * if yes, then overwrite a previously existing cache entry 	 */
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|an_nextitem
condition|)
block|{
name|cache_slot
operator|=
name|i
expr_stmt|;
block|}
comment|/* else, have a new address entry,so 	 * add this new entry, 	 * if table full, then we need to replace LRU entry 	 */
else|else
block|{
comment|/* check for space in cache table  		 * note: an_nextitem also holds number of entries 		 * added in the cache table  		 */
if|if
condition|(
name|sc
operator|->
name|an_nextitem
operator|<
name|MAXANCACHE
condition|)
block|{
name|cache_slot
operator|=
name|sc
operator|->
name|an_nextitem
expr_stmt|;
name|sc
operator|->
name|an_nextitem
operator|++
expr_stmt|;
name|sc
operator|->
name|an_sigitems
operator|=
name|sc
operator|->
name|an_nextitem
expr_stmt|;
block|}
comment|/* no space found, so simply wrap anth wrap index 		 * and "zap" the next entry 		 */
else|else
block|{
if|if
condition|(
name|wrapindex
operator|==
name|MAXANCACHE
condition|)
block|{
name|wrapindex
operator|=
literal|0
expr_stmt|;
block|}
name|cache_slot
operator|=
name|wrapindex
operator|++
expr_stmt|;
block|}
block|}
comment|/* invariant: cache_slot now points at some slot 	 * in cache. 	 */
if|if
condition|(
name|cache_slot
operator|<
literal|0
operator|||
name|cache_slot
operator|>=
name|MAXANCACHE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"an_cache_store, bad index: %d of "
literal|"[0..%d], gross cache error\n"
argument_list|,
name|cache_slot
argument_list|,
name|MAXANCACHE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  store items in cache 	 *  .ip source address 	 *  .mac src 	 *  .signal, etc. 	 */
if|if
condition|(
name|saanp
condition|)
block|{
name|sc
operator|->
name|an_sigcache
index|[
name|cache_slot
index|]
operator|.
name|ipsrc
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|an_sigcache
index|[
name|cache_slot
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_sigcache
index|[
name|cache_slot
index|]
operator|.
name|signal
operator|=
name|rx_quality
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

