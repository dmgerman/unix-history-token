begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Aironet 4500/4800 802.11 PCMCIA/ISA/PCI driver for FreeBSD.  *  * Written by Bill Paul<wpaul@ctr.columbia.edu>  * Electrical Engineering Department  * Columbia University, New York City  */
end_comment

begin_comment
comment|/*  * The Aironet 4500/4800 series cards come in PCMCIA, ISA and PCI form.  * This driver supports all three device types (PCI devices are supported  * through an extra PCI shim: /sys/pci/if_an_p.c). ISA devices can be  * supported either using hard-coded IO port/IRQ settings or via Plug  * and Play. The 4500 series devices support 1Mbps and 2Mbps data rates.  * The 4800 devices support 1, 2, 5.5 and 11Mbps rates.  *  * Like the WaveLAN/IEEE cards, the Aironet NICs are all essentially  * PCMCIA devices. The ISA and PCI cards are a combination of a PCMCIA  * device and a PCMCIA to ISA or PCMCIA to PCI adapter card. There are  * a couple of important differences though:  *  * - Lucent ISA card looks to the host like a PCMCIA controller with  *   a PCMCIA WaveLAN card inserted. This means that even desktop  *   machines need to be configured with PCMCIA support in order to  *   use WaveLAN/IEEE ISA cards. The Aironet cards on the other hand  *   actually look like normal ISA and PCI devices to the host, so  *   no PCMCIA controller support is needed  *  * The latter point results in a small gotcha. The Aironet PCMCIA  * cards can be configured for one of two operating modes depending  * on how the Vpp1 and Vpp2 programming voltages are set when the  * card is activated. In order to put the card in proper PCMCIA  * operation (where the CIS table is visible and the interface is  * programmed for PCMCIA operation), both Vpp1 and Vpp2 have to be  * set to 5 volts. FreeBSD by default doesn't set the Vpp voltages,  * which leaves the card in ISA/PCI mode, which prevents it from  * being activated as an PCMCIA device.  *  * Note that some PCMCIA controller software packages for Windows NT  * fail to set the voltages as well.  *  * The Aironet devices can operate in both station mode and access point  * mode. Typically, when programmed for station mode, the card can be set  * to automatically perform encapsulation/decapsulation of Ethernet II  * and 802.3 frames within 802.11 frames so that the host doesn't have  * to do it itself. This driver doesn't program the card that way: the  * driver handles all of the encapsulation/decapsulation itself.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_define
define|#
directive|define
name|ANCACHE
end_define

begin_comment
comment|/* enable signal strength cache */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANCACHE
end_ifdef

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/an/if_aironet_ieee.h>
end_include

begin_include
include|#
directive|include
file|<dev/an/if_anreg.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are global because we need them in sys/pci/if_an_p.c. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|an_reset
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_init_tx_ring
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_rxeof
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_txeof
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_read_record
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|an_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_write_record
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|an_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_read_data
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_write_data
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_seek
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_alloc_nicmem
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_stats_update
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_setdef
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|an_req
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ANCACHE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|an_cache_store
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|ether_header
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|unsigned
name|short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* function definitions for use with the Cisco's Linux configuration    utilities */
end_comment

begin_decl_stmt
specifier|static
name|int
name|readrids
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|aironet_ioctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|writerids
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|aironet_ioctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flashcard
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|aironet_ioctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmdreset
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setflashmode
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flashgchar
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flashpchar
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flashputbuf
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flashrestart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|WaitBusy
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unstickbusy
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_dump_record
name|__P
argument_list|(
operator|(
expr|struct
name|an_softc
operator|*
operator|,
expr|struct
name|an_ltv_gen
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_media_change
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|an_media_status
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|an_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|an_conf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|an
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"dump RID"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_an_dump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|r
decl_stmt|,
name|last
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|an_conf
decl_stmt|;
name|last
operator|=
name|an_dump
expr_stmt|;
name|bzero
argument_list|(
name|an_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|an_conf
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|an_dump
condition|)
block|{
case|case
literal|0
case|:
name|strcat
argument_list|(
name|an_conf
argument_list|,
literal|"off"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strcat
argument_list|(
name|an_conf
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcat
argument_list|(
name|an_conf
argument_list|,
literal|"dump"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|an_conf
argument_list|,
literal|5
argument_list|,
literal|"%x"
argument_list|,
name|an_dump
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|an_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|an_conf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|an_conf
argument_list|,
literal|"off"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|an_dump
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|an_conf
argument_list|,
literal|"dump"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|an_dump
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|an_conf
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|an_dump
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'f'
condition|)
block|{
name|r
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|r
operator|=
name|r
operator|*
literal|16
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|r
operator|=
name|r
operator|*
literal|16
operator|+
operator|(
operator|*
name|s
operator|-
literal|'a'
operator|+
literal|10
operator|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|an_dump
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|an_dump
operator|!=
name|last
condition|)
name|printf
argument_list|(
literal|"Sysctl changed for Aironet driver\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|an_dump
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|an_conf
argument_list|)
argument_list|,
name|sysctl_an_dump
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * We probe for an Aironet 4500/4800 card by attempting to  * read the default SSID list. On reset, the first entry in  * the SSID list will contain the name "tsunami." If we don't  * find this, then there's no card present.  */
end_comment

begin_function
name|int
name|an_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|an_ltv_ssidlist
name|ssid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ssid
argument_list|,
sizeof|sizeof
argument_list|(
name|ssid
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|an_alloc_port
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|AN_IOSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* can't do autoprobing */
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We need to fake up a softc structure long enough 	 * to be able to issue commands and call some of the 	 * other routines. 	 */
name|sc
operator|->
name|an_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ssid
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
name|ssid
argument_list|)
expr_stmt|;
name|ssid
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
comment|/* Make sure interrupts are disabled. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_READCFG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|ssid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* See if the ssid matches what we expect ... but doesn't have to */
if|if
condition|(
name|strcmp
argument_list|(
name|ssid
operator|.
name|an_ssid1
argument_list|,
name|AN_DEF_SSID
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|AN_IOSIZ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a port resource with the given resource id.  */
end_comment

begin_function
name|int
name|an_alloc_port
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|size
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|port_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate an irq resource with the given resource id.  */
end_comment

begin_function
name|int
name|an_alloc_irq
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
operator|(
name|RF_ACTIVE
operator||
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|irq_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release all resources  */
end_comment

begin_function
name|void
name|an_release_resources
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|an_attach
parameter_list|(
name|sc
parameter_list|,
name|unit
parameter_list|,
name|flags
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|sc
operator|->
name|an_gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|an_monitor
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|an_was_monitor
operator|=
literal|0
expr_stmt|;
comment|/* Reset the NIC. */
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load factory config */
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_READCFG
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to load config data\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read the current configuration */
name|sc
operator|->
name|an_config
operator|.
name|an_type
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read the card capabilities */
name|sc
operator|->
name|an_caps
operator|.
name|an_type
operator|=
name|AN_RID_CAPABILITIES
expr_stmt|;
name|sc
operator|->
name|an_caps
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_caps
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read ssid list */
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_ssidlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_ssidlist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Read AP list */
name|sc
operator|->
name|an_aplist
operator|.
name|an_type
operator|=
name|AN_RID_APLIST
expr_stmt|;
name|sc
operator|->
name|an_aplist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_aplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_aplist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: read record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_caps
operator|.
name|an_oemaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"an%d: Ethernet address: %6D\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|an_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"an"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|an_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|an_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|an_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|an_init
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|an_config
operator|.
name|an_nodename
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|an_config
operator|.
name|an_nodename
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|AN_DEFAULT_NODENAME
argument_list|,
name|sc
operator|->
name|an_config
operator|.
name|an_nodename
argument_list|,
sizeof|sizeof
argument_list|(
name|AN_DEFAULT_NODENAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|AN_DEFAULT_NETNAME
argument_list|,
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1
argument_list|,
sizeof|sizeof
argument_list|(
name|AN_DEFAULT_NETNAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_ssid1_len
operator|=
name|strlen
argument_list|(
name|AN_DEFAULT_NETNAME
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_opmode
operator|=
name|AN_OPMODE_INFRASTRUCTURE_STATION
expr_stmt|;
name|sc
operator|->
name|an_tx_rate
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|an_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|an_ifmedia
argument_list|,
literal|0
argument_list|,
name|an_media_change
argument_list|,
name|an_media_status
argument_list|)
expr_stmt|;
define|#
directive|define
name|ADD
parameter_list|(
name|m
parameter_list|,
name|c
parameter_list|)
value|ifmedia_add(&sc->an_ifmedia, (m), (c), NULL)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS1
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS2
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_caps
operator|.
name|an_rates
index|[
literal|2
index|]
operator|==
name|AN_RATE_5_5MBPS
condition|)
block|{
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS5
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|an_caps
operator|.
name|an_rates
index|[
literal|3
index|]
operator|==
name|AN_RATE_11MBPS
condition|)
block|{
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS11
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS11
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|an_ifmedia
argument_list|,
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Call MI attach routine. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|an_stat_ch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_rxeof
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|ih
decl_stmt|;
name|struct
name|an_rxframe
name|rx_frame
decl_stmt|;
name|struct
name|an_rxframe_802_3
name|rx_frame_802_3
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|id
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ieee80211_header_len
decl_stmt|;
name|u_char
modifier|*
name|bpf_buf
decl_stmt|;
name|u_short
name|fc1
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RX_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
comment|/* read raw 802.11 packet */
name|bpf_buf
operator|=
name|sc
operator|->
name|buf_802_11
expr_stmt|;
comment|/* read header */
if|if
condition|(
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		 * skip beacon by default since this increases the 		 * system load a lot 		 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|an_monitor
operator|&
name|AN_MONITOR_INCLUDE_BEACON
operator|)
operator|&&
operator|(
name|rx_frame
operator|.
name|an_frame_ctl
operator|&
name|IEEE80211_FC0_SUBTYPE_BEACON
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|&
name|AN_MONITOR_AIRONET_HEADER
condition|)
block|{
name|len
operator|=
name|rx_frame
operator|.
name|an_rx_payload_len
operator|+
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
expr_stmt|;
comment|/* Check for insane frame length */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|buf_802_11
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: oversized packet received (%d, %d)\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
argument_list|,
name|bpf_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|bpf_buf
operator|+
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|,
name|rx_frame
operator|.
name|an_rx_payload_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fc1
operator|=
name|rx_frame
operator|.
name|an_frame_ctl
operator|>>
literal|8
expr_stmt|;
name|ieee80211_header_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fc1
operator|&
name|IEEE80211_FC1_DIR_TODS
operator|)
operator|&&
operator|(
name|fc1
operator|&
name|IEEE80211_FC1_DIR_FROMDS
operator|)
condition|)
block|{
name|ieee80211_header_len
operator|+=
name|ETHER_ADDR_LEN
expr_stmt|;
block|}
name|len
operator|=
name|rx_frame
operator|.
name|an_rx_payload_len
operator|+
name|ieee80211_header_len
expr_stmt|;
comment|/* Check for insane frame length */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|buf_802_11
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: oversized packet received (%d, %d)\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|ih
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
name|bpf_buf
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|an_frame_ctl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ih
argument_list|,
name|ieee80211_header_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
operator|+
name|rx_frame
operator|.
name|an_gaplen
argument_list|,
operator|(
name|caddr_t
operator|)
name|ih
operator|+
name|ieee80211_header_len
argument_list|,
name|rx_frame
operator|.
name|an_rx_payload_len
argument_list|)
expr_stmt|;
block|}
comment|/* dump raw 802.11 packet to bpf and skip ip stack */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
operator|!=
name|NULL
condition|)
block|{
name|bpf_tap
argument_list|(
name|ifp
argument_list|,
name|bpf_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* Read Ethernet encapsulated packet */
ifdef|#
directive|ifdef
name|ANCACHE
comment|/* Read NIC frame header */
if|if
condition|(
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Read in the 802_3 frame header */
if|if
condition|(
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x34
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame_802_3
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame_802_3
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rx_frame_802_3
operator|.
name|an_rx_802_3_status
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Check for insane frame length */
if|if
condition|(
name|rx_frame_802_3
operator|.
name|an_rx_802_3_payload_len
operator|>
name|MCLBYTES
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame_802_3
operator|.
name|an_rx_802_3_payload_len
operator|+
literal|12
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame_802_3
operator|.
name|an_rx_dst_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame_802_3
operator|.
name|an_rx_src_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* in mbuf header type is just before payload */
name|error
operator|=
name|an_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x44
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|eh
operator|->
name|ether_type
operator|)
argument_list|,
name|rx_frame_802_3
operator|.
name|an_rx_802_3_payload_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Receive packet. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ANCACHE
name|an_cache_store
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|m
argument_list|,
name|rx_frame
operator|.
name|an_rx_signal_strength
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|an_txeof
parameter_list|(
name|sc
parameter_list|,
name|status
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|id
decl_stmt|,
name|i
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_TX_CMP_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|AN_EV_TX_EXC
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|==
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|i
index|]
condition|)
block|{
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|AN_INC
argument_list|(
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_cons
argument_list|,
name|AN_TX_RING_CNT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * We abuse the stats updater to check the current NIC status. This  * is important because we don't want to allow transmissions until  * the NIC has synchronized to the current cell (either as the master  * in an ad-hoc group, or as a station connected to an access point).  */
end_comment

begin_function
name|void
name|an_stats_update
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|sc
operator|->
name|an_status
operator|.
name|an_type
operator|=
name|AN_RID_STATUS
expr_stmt|;
name|sc
operator|->
name|an_status
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_status
argument_list|)
expr_stmt|;
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_status
operator|.
name|an_opmode
operator|&
name|AN_STATUS_OPMODE_IN_SYNC
condition|)
name|sc
operator|->
name|an_associated
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
comment|/* Don't do this while we're transmitting */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|sc
operator|->
name|an_stat_ch
operator|=
name|timeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|an_stats
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_stats
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_stats
operator|.
name|an_type
operator|=
name|AN_RID_32BITS_CUM
expr_stmt|;
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_stats
operator|.
name|an_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_stat_ch
operator|=
name|timeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|an_intr
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|an_softc
operator|*
operator|)
name|xsc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* Disable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_STAT
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
operator|~
name|AN_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|AN_EV_AWAKE
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_AWAKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_LINKSTAT
condition|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_LINKSTAT
argument_list|)
operator|==
name|AN_LINKSTAT_ASSOCIATED
condition|)
name|sc
operator|->
name|an_associated
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_LINKSTAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_RX
condition|)
block|{
name|an_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_RX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_TX
condition|)
block|{
name|an_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_TX_EXC
condition|)
block|{
name|an_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_TX_EXC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|AN_EV_ALLOC
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_ALLOC
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
name|AN_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|an_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|an_cmd
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|,
name|val
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_PARAM0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_PARAM1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_PARAM2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_STAT
argument_list|)
operator|&
name|AN_EV_CMD
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|)
operator|==
name|cmd
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RESP0
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RESP1
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_RESP2
argument_list|)
expr_stmt|;
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|AN_STAT_CMD_CODE
operator|)
operator|==
operator|(
name|cmd
operator|&
name|AN_STAT_CMD_CODE
operator|)
condition|)
break|break;
block|}
comment|/* Ack the command */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|)
operator|&
name|AN_CMD_BUSY
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_CLR_STUCK_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|AN_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This reset sequence may look a little strange, but this is the  * most reliable method I've found to really kick the NIC in the  * head and force it to reboot correctly.  */
end_comment

begin_function
specifier|static
name|void
name|an_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_FW_RESTART
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_NOOP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_FORCE_SYNCLOSS
argument_list|,
literal|0
argument_list|)
operator|==
name|ETIMEDOUT
condition|)
name|printf
argument_list|(
literal|"an%d: reset failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Read an LTV record from the NIC.  */
end_comment

begin_function
specifier|static
name|int
name|an_read_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|ltv
operator|->
name|an_len
operator|<
literal|4
operator|||
name|ltv
operator|->
name|an_type
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Tell the NIC to enter record read mode. */
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ACCESS
operator||
name|AN_ACCESS_READ
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: RID access failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Seek to the record. */
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|,
literal|0
argument_list|,
name|AN_BAP1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: seek to record failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Read the length and record type and make sure they 	 * match what we expect (this verifies that we have enough 	 * room to hold all of the returned data). 	 * Length includes type but not length. 	 */
name|len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|ltv
operator|->
name|an_len
operator|-
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: record length mismatch -- expected %d, "
literal|"got %d for Rid %x\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|ltv
operator|->
name|an_len
operator|-
literal|2
argument_list|,
name|len
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|)
expr_stmt|;
name|len
operator|=
name|ltv
operator|->
name|an_len
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ltv
operator|->
name|an_len
operator|=
name|len
operator|+
literal|2
expr_stmt|;
block|}
comment|/* Now read the data. */
name|len
operator|-=
literal|2
expr_stmt|;
comment|/* skip the type */
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|an_val
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|-=
literal|2
control|)
operator|*
name|ptr
operator|++
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|ptr2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ptr
expr_stmt|;
operator|*
name|ptr2
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|an_dump
condition|)
name|an_dump_record
argument_list|(
name|sc
argument_list|,
name|ltv
argument_list|,
literal|"Read"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as read, except we inject data instead of reading it.  */
end_comment

begin_function
specifier|static
name|int
name|an_write_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|an_dump
condition|)
name|an_dump_record
argument_list|(
name|sc
argument_list|,
name|ltv
argument_list|,
literal|"Write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ACCESS
operator||
name|AN_ACCESS_READ
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|,
literal|0
argument_list|,
name|AN_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * Length includes type but not length. 	 */
name|len
operator|=
name|ltv
operator|->
name|an_len
operator|-
literal|2
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
comment|/* skip the type */
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|an_val
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|-=
literal|2
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|ptr2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|AN_DATA0
argument_list|,
operator|*
name|ptr2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ACCESS
operator||
name|AN_ACCESS_WRITE
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_dump_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|,
name|string
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_ltv_gen
modifier|*
name|ltv
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|u_int8_t
modifier|*
name|ptr2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|17
index|]
decl_stmt|,
name|temp
decl_stmt|;
name|len
operator|=
name|ltv
operator|->
name|an_len
operator|-
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"an%d: RID %4x, Length %4d, Mode %s\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|ltv
operator|->
name|an_type
argument_list|,
name|ltv
operator|->
name|an_len
operator|-
literal|4
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_dump
operator|==
literal|1
operator|||
operator|(
name|an_dump
operator|==
name|ltv
operator|->
name|an_type
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d:\t"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ptr2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|ltv
operator|->
name|an_val
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|*
name|ptr2
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|*
name|ptr2
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
literal|' '
operator|&&
name|temp
operator|<=
literal|'~'
condition|)
name|buf
index|[
name|count
index|]
operator|=
name|temp
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|>=
literal|'A'
operator|&&
name|temp
operator|<=
literal|'Z'
condition|)
name|buf
index|[
name|count
index|]
operator|=
name|temp
expr_stmt|;
else|else
name|buf
index|[
name|count
index|]
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|==
literal|16
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"an%d:\t"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|count
operator|!=
literal|16
condition|;
name|count
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|an_seek
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|chan
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|,
name|chan
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|selreg
decl_stmt|,
name|offreg
decl_stmt|;
switch|switch
condition|(
name|chan
condition|)
block|{
case|case
name|AN_BAP0
case|:
name|selreg
operator|=
name|AN_SEL0
expr_stmt|;
name|offreg
operator|=
name|AN_OFF0
expr_stmt|;
break|break;
case|case
name|AN_BAP1
case|:
name|selreg
operator|=
name|AN_SEL1
expr_stmt|;
name|offreg
operator|=
name|AN_OFF1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"an%d: invalid data path: %x\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|selreg
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|,
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|)
operator|&
operator|(
name|AN_OFF_BUSY
operator||
name|AN_OFF_ERR
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|AN_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_read_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr2
decl_stmt|;
if|if
condition|(
name|off
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|AN_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|-=
literal|2
control|)
operator|*
name|ptr
operator|++
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|ptr2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ptr
expr_stmt|;
operator|*
name|ptr2
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|AN_DATA1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_write_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr2
decl_stmt|;
if|if
condition|(
name|off
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|AN_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|-=
literal|2
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA0
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|ptr2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|AN_DATA0
argument_list|,
operator|*
name|ptr2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a region of memory inside the NIC and zero  * it out.  */
end_comment

begin_function
specifier|static
name|int
name|an_alloc_nicmem
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|id
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ALLOC_MEM
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to allocate %d bytes on NIC\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_STAT
argument_list|)
operator|&
name|AN_EV_ALLOC
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|AN_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_ALLOC
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_ALLOC_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_seek
argument_list|(
name|sc
argument_list|,
operator|*
name|id
argument_list|,
literal|0
argument_list|,
name|AN_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_setdef
parameter_list|(
name|sc
parameter_list|,
name|areq
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|an_req
modifier|*
name|areq
decl_stmt|;
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|an_ltv_genconfig
modifier|*
name|cfg
decl_stmt|;
name|struct
name|an_ltv_ssidlist
modifier|*
name|ssid
decl_stmt|;
name|struct
name|an_ltv_aplist
modifier|*
name|ap
decl_stmt|;
name|struct
name|an_ltv_gen
modifier|*
name|sp
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
switch|switch
condition|(
name|areq
operator|->
name|an_type
condition|)
block|{
case|case
name|AN_RID_GENCONFIG
case|:
name|cfg
operator|=
operator|(
expr|struct
name|an_ltv_genconfig
operator|*
operator|)
name|areq
expr_stmt|;
name|ifa
operator|=
name|ifnet_addrs
index|[
name|ifp
operator|->
name|if_index
operator|-
literal|1
index|]
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cfg
operator|->
name|an_macaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cfg
operator|->
name|an_macaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cfg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN_RID_SSIDLIST
case|:
name|ssid
operator|=
operator|(
expr|struct
name|an_ltv_ssidlist
operator|*
operator|)
name|areq
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ssid
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_ssidlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_ssidlist
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN_RID_APLIST
case|:
name|ap
operator|=
operator|(
expr|struct
name|an_ltv_aplist
operator|*
operator|)
name|areq
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_aplist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_aplist
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN_RID_TX_SPEED
case|:
name|sp
operator|=
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
name|areq
expr_stmt|;
name|sc
operator|->
name|an_tx_rate
operator|=
name|sp
operator|->
name|an_val
expr_stmt|;
break|break;
case|case
name|AN_RID_WEP_TEMP
case|:
case|case
name|AN_RID_WEP_PERM
case|:
case|case
name|AN_RID_LEAPUSERNAME
case|:
case|case
name|AN_RID_LEAPPASSWORD
case|:
comment|/* Disable the MAC. */
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write the key */
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
name|areq
argument_list|)
expr_stmt|;
comment|/* Turn the MAC back on. */
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN_RID_MONITOR_MODE
case|:
name|cfg
operator|=
operator|(
expr|struct
name|an_ltv_genconfig
operator|*
operator|)
name|areq
expr_stmt|;
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_ether_detach_p
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ng_ether_detach_p
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_monitor
operator|=
name|cfg
operator|->
name|an_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|&
name|AN_MONITOR
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|&
name|AN_MONITOR_AIRONET_HEADER
condition|)
block|{
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_AIRONET_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_IEEE802_11
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_ether_attach_p
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ng_ether_attach_p
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"an%d: unknown RID: %x\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|areq
operator|->
name|an_type
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
comment|/* Reinitialize the card. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
condition|)
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Derived from Linux driver to enable promiscious mode.  */
end_comment

begin_function
specifier|static
name|void
name|an_promisc
parameter_list|(
name|sc
parameter_list|,
name|promisc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|promisc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|an_was_monitor
condition|)
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|||
name|sc
operator|->
name|an_was_monitor
condition|)
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_was_monitor
operator|=
name|sc
operator|->
name|an_monitor
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_SET_MODE
argument_list|,
name|promisc
condition|?
literal|0xffff
else|:
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|an_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|struct
name|ieee80211req
modifier|*
name|ireq
decl_stmt|;
name|u_int8_t
name|tmpstr
index|[
name|IEEE80211_NWID_LEN
operator|*
literal|2
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|tmpptr
decl_stmt|;
name|struct
name|an_ltv_genconfig
modifier|*
name|config
decl_stmt|;
name|struct
name|an_ltv_key
modifier|*
name|key
decl_stmt|;
name|struct
name|an_ltv_status
modifier|*
name|status
decl_stmt|;
name|struct
name|an_ltv_ssidlist
modifier|*
name|ssids
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|aironet_ioctl
name|l_ioctl
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|ireq
operator|=
operator|(
expr|struct
name|ieee80211req
operator|*
operator|)
name|data
expr_stmt|;
name|config
operator|=
operator|(
expr|struct
name|an_ltv_genconfig
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
expr_stmt|;
name|key
operator|=
operator|(
expr|struct
name|an_ltv_key
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
expr_stmt|;
name|status
operator|=
operator|(
expr|struct
name|an_ltv_status
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
expr_stmt|;
name|ssids
operator|=
operator|(
expr|struct
name|an_ltv_ssidlist
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|an_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|an_promisc
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|an_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|an_promisc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|an_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|an_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|an_ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* The Aironet has no multicast filter. */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGAIRONET
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|sc
operator|->
name|areq
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|ANCACHE
if|if
condition|(
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|==
name|AN_RID_ZERO_CACHE
condition|)
block|{
name|sc
operator|->
name|an_sigitems
operator|=
name|sc
operator|->
name|an_nextitem
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|==
name|AN_RID_READ_CACHE
condition|)
block|{
name|char
modifier|*
name|pt
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
operator|.
name|an_val
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_sigitems
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|/
literal|2
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_sigcache
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|an_sigitems
argument_list|)
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|+=
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|an_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|an_sigitems
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|areq
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSAIRONET
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|sc
operator|->
name|areq
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|an_setdef
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGPRIVATE_0
case|:
comment|/* used by Cisco client utility */
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|l_ioctl
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioctl
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|l_ioctl
operator|.
name|command
expr_stmt|;
if|if
condition|(
name|mode
operator|>=
name|AIROGCAP
operator|&&
name|mode
operator|<=
name|AIROGSTATSD32
condition|)
block|{
name|error
operator|=
name|readrids
argument_list|(
name|ifp
argument_list|,
operator|&
name|l_ioctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|>=
name|AIROPCAP
operator|&&
name|mode
operator|<=
name|AIROPLEAPUSR
condition|)
block|{
name|error
operator|=
name|writerids
argument_list|(
name|ifp
argument_list|,
operator|&
name|l_ioctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|>=
name|AIROFLSHRST
operator|&&
name|mode
operator|<=
name|AIRORESTART
condition|)
block|{
name|error
operator|=
name|flashcard
argument_list|(
name|ifp
argument_list|,
operator|&
name|l_ioctl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* copy out the updated command info */
name|copyout
argument_list|(
operator|&
name|l_ioctl
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioctl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGPRIVATE_1
case|:
comment|/* used by Cisco client utility */
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|l_ioctl
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioctl
argument_list|)
argument_list|)
expr_stmt|;
name|l_ioctl
operator|.
name|command
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|AIROMAGIC
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|error
argument_list|,
name|l_ioctl
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCG80211
case|:
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
comment|/* was that a good idea DJA we are doing a short-cut */
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_SSID
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_STATUS
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|status
operator|->
name|an_ssidlen
expr_stmt|;
name|tmpptr
operator|=
name|status
operator|->
name|an_ssid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|>=
literal|0
condition|)
block|{
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|ssids
operator|->
name|an_ssid1_len
expr_stmt|;
name|tmpptr
operator|=
name|ssids
operator|->
name|an_ssid1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
literal|1
condition|)
block|{
name|len
operator|=
name|ssids
operator|->
name|an_ssid2_len
expr_stmt|;
name|tmpptr
operator|=
name|ssids
operator|->
name|an_ssid2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
literal|2
condition|)
block|{
name|len
operator|=
name|ssids
operator|->
name|an_ssid3_len
expr_stmt|;
name|tmpptr
operator|=
name|ssids
operator|->
name|an_ssid3
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|>
name|IEEE80211_NWID_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
name|bzero
argument_list|(
name|tmpstr
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmpptr
argument_list|,
name|tmpstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|tmpstr
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_NUMSSIDS
case|:
name|ireq
operator|->
name|i_val
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_WEP
case|:
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_ACTUALCFG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|config
operator|->
name|an_authtype
operator|&
name|AN_AUTHTYPE_PRIVACY_IN_USE
condition|)
block|{
if|if
condition|(
name|config
operator|->
name|an_authtype
operator|&
name|AN_AUTHTYPE_ALLOW_UNENCRYPTED
condition|)
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_WEP_MIXED
expr_stmt|;
else|else
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_WEP_ON
expr_stmt|;
block|}
else|else
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_WEP_OFF
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_IOC_WEPKEY
case|:
comment|/* 			 * XXX: I'm not entierly convinced this is 			 * correct, but it's what is implemented in 			 * ancontrol so it will have to do until we get 			 * access to actual Cisco code. 			 */
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|8
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|5
condition|)
block|{
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_TEMP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|key
operator|->
name|kindex
operator|==
literal|0xffff
condition|)
break|break;
if|if
condition|(
name|key
operator|->
name|kindex
operator|==
name|ireq
operator|->
name|i_val
condition|)
name|len
operator|=
name|key
operator|->
name|klen
expr_stmt|;
comment|/* Required to get next entry */
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_PERM
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* We aren't allowed to read the value of the 			 * key from the card so we just output zeros 			 * like we would if we could read the card, but 			 * denied the user access. 			 */
name|bzero
argument_list|(
name|tmpstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|tmpstr
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_NUMWEPKEYS
case|:
name|ireq
operator|->
name|i_val
operator|=
literal|9
expr_stmt|;
comment|/* include home key */
break|break;
case|case
name|IEEE80211_IOC_WEPTXKEY
case|:
comment|/* 			 * For some strange reason, you have to read all 			 * keys before you can read the txkey. 			 */
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_TEMP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|key
operator|->
name|kindex
operator|==
literal|0xffff
condition|)
break|break;
comment|/* Required to get next entry */
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_PERM
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_PERM
expr_stmt|;
name|key
operator|->
name|kindex
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ireq
operator|->
name|i_val
operator|=
name|key
operator|->
name|mac
index|[
literal|0
index|]
expr_stmt|;
comment|/* 			 * Check for home mode.  Map home mode into 			 * 5th key since that is how it is stored on 			 * the card 			 */
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|config
operator|->
name|an_home_product
operator|&
name|AN_HOME_NETWORK
condition|)
name|ireq
operator|->
name|i_val
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_AUTHMODE
case|:
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_ACTUALCFG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|config
operator|->
name|an_authtype
operator|&
name|AN_AUTHTYPE_MASK
operator|)
operator|==
name|AN_AUTHTYPE_NONE
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_AUTH_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|config
operator|->
name|an_authtype
operator|&
name|AN_AUTHTYPE_MASK
operator|)
operator|==
name|AN_AUTHTYPE_OPEN
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_AUTH_OPEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|config
operator|->
name|an_authtype
operator|&
name|AN_AUTHTYPE_MASK
operator|)
operator|==
name|AN_AUTHTYPE_SHAREDKEY
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_AUTH_SHARED
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_STATIONNAME
case|:
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_ACTUALCFG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ireq
operator|->
name|i_len
operator|=
sizeof|sizeof
argument_list|(
name|config
operator|->
name|an_nodename
argument_list|)
expr_stmt|;
name|tmpptr
operator|=
name|config
operator|->
name|an_nodename
expr_stmt|;
name|bzero
argument_list|(
name|tmpstr
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmpptr
argument_list|,
name|tmpstr
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|tmpstr
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_CHANNEL
case|:
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_STATUS
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ireq
operator|->
name|i_val
operator|=
name|status
operator|->
name|an_cur_channel
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_POWERSAVE
case|:
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_ACTUALCFG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|config
operator|->
name|an_psave_mode
operator|==
name|AN_PSAVE_NONE
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_POWERSAVE_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config
operator|->
name|an_psave_mode
operator|==
name|AN_PSAVE_CAM
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_POWERSAVE_CAM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config
operator|->
name|an_psave_mode
operator|==
name|AN_PSAVE_PSP
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_POWERSAVE_PSP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config
operator|->
name|an_psave_mode
operator|==
name|AN_PSAVE_PSP_CAM
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_POWERSAVE_PSP_CAM
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_POWERSAVESLEEP
case|:
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_ACTUALCFG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ireq
operator|->
name|i_val
operator|=
name|config
operator|->
name|an_listen_interval
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCS80211
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
comment|/* 		 * We need a config structure for everything but the WEP 		 * key management and SSIDs so we get it now so avoid 		 * duplicating this code every time. 		 */
if|if
condition|(
name|ireq
operator|->
name|i_type
operator|!=
name|IEEE80211_IOC_SSID
operator|&&
name|ireq
operator|->
name|i_type
operator|!=
name|IEEE80211_IOC_WEPKEY
operator|&&
name|ireq
operator|->
name|i_type
operator|!=
name|IEEE80211_IOC_WEPTXKEY
condition|)
block|{
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_SSID
case|:
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ireq
operator|->
name|i_len
operator|>
name|IEEE80211_NWID_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
case|case
literal|0
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|ssids
operator|->
name|an_ssid1
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|ssids
operator|->
name|an_ssid1_len
operator|=
name|ireq
operator|->
name|i_len
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|ssids
operator|->
name|an_ssid2
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|ssids
operator|->
name|an_ssid2_len
operator|=
name|ireq
operator|->
name|i_len
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|ssids
operator|->
name|an_ssid3
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|ssids
operator|->
name|an_ssid3_len
operator|=
name|ireq
operator|->
name|i_len
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_IOC_WEP
case|:
switch|switch
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
case|case
name|IEEE80211_WEP_OFF
case|:
name|config
operator|->
name|an_authtype
operator|&=
operator|~
operator|(
name|AN_AUTHTYPE_PRIVACY_IN_USE
operator||
name|AN_AUTHTYPE_ALLOW_UNENCRYPTED
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_WEP_ON
case|:
name|config
operator|->
name|an_authtype
operator||=
name|AN_AUTHTYPE_PRIVACY_IN_USE
expr_stmt|;
name|config
operator|->
name|an_authtype
operator|&=
operator|~
name|AN_AUTHTYPE_ALLOW_UNENCRYPTED
expr_stmt|;
break|break;
case|case
name|IEEE80211_WEP_MIXED
case|:
name|config
operator|->
name|an_authtype
operator||=
name|AN_AUTHTYPE_PRIVACY_IN_USE
operator||
name|AN_AUTHTYPE_ALLOW_UNENCRYPTED
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_IOC_WEPKEY
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|7
operator|||
name|ireq
operator|->
name|i_len
operator|>
literal|13
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|tmpstr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|areq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_key
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_key
argument_list|)
expr_stmt|;
name|key
operator|->
name|mac
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The others are 0. */
name|key
operator|->
name|kindex
operator|=
name|ireq
operator|->
name|i_val
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|4
condition|)
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_TEMP
expr_stmt|;
else|else
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_PERM
expr_stmt|;
name|key
operator|->
name|klen
operator|=
name|ireq
operator|->
name|i_len
expr_stmt|;
name|bcopy
argument_list|(
name|tmpstr
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|klen
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_WEPTXKEY
case|:
comment|/* 			 * Map the 5th key into the home mode 			 * since that is how it is stored on 			 * the card 			 */
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|4
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_ACTUALCFG
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
literal|4
condition|)
block|{
name|config
operator|->
name|an_home_product
operator||=
name|AN_HOME_NETWORK
expr_stmt|;
name|ireq
operator|->
name|i_val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|config
operator|->
name|an_home_product
operator|&=
operator|~
name|AN_HOME_NETWORK
expr_stmt|;
block|}
name|sc
operator|->
name|an_config
operator|.
name|an_home_product
operator|=
name|config
operator|->
name|an_home_product
expr_stmt|;
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|areq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_key
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_key
argument_list|)
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|AN_RID_WEP_PERM
expr_stmt|;
name|key
operator|->
name|kindex
operator|=
literal|0xffff
expr_stmt|;
name|key
operator|->
name|mac
index|[
literal|0
index|]
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_AUTHMODE
case|:
switch|switch
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
case|case
name|IEEE80211_AUTH_NONE
case|:
name|config
operator|->
name|an_authtype
operator|=
name|AN_AUTHTYPE_NONE
operator||
operator|(
name|config
operator|->
name|an_authtype
operator|&
operator|~
name|AN_AUTHTYPE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_AUTH_OPEN
case|:
name|config
operator|->
name|an_authtype
operator|=
name|AN_AUTHTYPE_OPEN
operator||
operator|(
name|config
operator|->
name|an_authtype
operator|&
operator|~
name|AN_AUTHTYPE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_AUTH_SHARED
case|:
name|config
operator|->
name|an_authtype
operator|=
name|AN_AUTHTYPE_SHAREDKEY
operator||
operator|(
name|config
operator|->
name|an_authtype
operator|&
operator|~
name|AN_AUTHTYPE_MASK
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_IOC_STATIONNAME
case|:
if|if
condition|(
name|ireq
operator|->
name|i_len
operator|>
literal|16
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|config
operator|->
name|an_nodename
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|config
operator|->
name|an_nodename
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_CHANNEL
case|:
comment|/* 			 * The actual range is 1-14, but if you set it 			 * to 0 you get the default so we let that work 			 * too. 			 */
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|14
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|config
operator|->
name|an_ds_channel
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_POWERSAVE
case|:
switch|switch
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
case|case
name|IEEE80211_POWERSAVE_OFF
case|:
name|config
operator|->
name|an_psave_mode
operator|=
name|AN_PSAVE_NONE
expr_stmt|;
break|break;
case|case
name|IEEE80211_POWERSAVE_CAM
case|:
name|config
operator|->
name|an_psave_mode
operator|=
name|AN_PSAVE_CAM
expr_stmt|;
break|break;
case|case
name|IEEE80211_POWERSAVE_PSP
case|:
name|config
operator|->
name|an_psave_mode
operator|=
name|AN_PSAVE_PSP
expr_stmt|;
break|break;
case|case
name|IEEE80211_POWERSAVE_PSP_CAM
case|:
name|config
operator|->
name|an_psave_mode
operator|=
name|AN_PSAVE_PSP_CAM
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_IOC_POWERSAVESLEEP
case|:
name|config
operator|->
name|an_listen_interval
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|an_setdef
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|an_init_tx_ring
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|id
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|an_alloc_nicmem
argument_list|(
name|sc
argument_list|,
literal|1518
operator|+
literal|0x44
argument_list|,
operator|&
name|id
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_fids
index|[
name|i
index|]
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_cons
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|an_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_associated
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the TX buffers */
if|if
condition|(
name|an_init_tx_ring
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_init_tx_ring
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: tx buffer allocation "
literal|"failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Set our MAC address. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
operator|.
name|an_macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|=
name|AN_RXMODE_BC_ADDR
expr_stmt|;
else|else
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|=
name|AN_RXMODE_ADDR
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator|=
name|AN_RXMODE_BC_MC_ADDR
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|&
name|AN_MONITOR
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|&
name|AN_MONITOR_ANY_BSS
condition|)
block|{
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator||=
name|AN_RXMODE_80211_MONITOR_ANYBSS
operator||
name|AN_RXMODE_NO_8023_HEADER
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|an_config
operator|.
name|an_rxmode
operator||=
name|AN_RXMODE_80211_MONITOR_CURBSS
operator||
name|AN_RXMODE_NO_8023_HEADER
expr_stmt|;
block|}
block|}
block|}
comment|/* Set the ssid list */
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_type
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
name|sc
operator|->
name|an_ssidlist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_ssidlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_ssidlist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to set ssid list\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set the AP list */
name|sc
operator|->
name|an_aplist
operator|.
name|an_type
operator|=
name|AN_RID_APLIST
expr_stmt|;
name|sc
operator|->
name|an_aplist
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_aplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_aplist
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to set AP list\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set the configuration in the NIC */
name|sc
operator|->
name|an_config
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|an_ltv_genconfig
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_config
operator|.
name|an_type
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
if|if
condition|(
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|an_config
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to set configuration\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Enable the MAC */
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: failed to enable MAC\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_SET_MODE
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
name|AN_INTRS
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|an_stat_ch
operator|=
name|timeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|an_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|struct
name|an_txframe_802_3
name|tx_frame_802_3
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|unsigned
name|char
name|txcontrol
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
if|if
condition|(
operator|!
name|sc
operator|->
name|an_associated
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|an_monitor
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
block|}
return|return;
block|}
name|idx
operator|=
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_prod
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame_802_3
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_frame_802_3
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|idx
index|]
operator|==
literal|0
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
name|id
operator|=
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_fids
index|[
name|idx
index|]
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame_802_3
operator|.
name|an_tx_dst_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame_802_3
operator|.
name|an_tx_src_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame_802_3
operator|.
name|an_tx_802_3_payload_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|12
expr_stmt|;
comment|/* minus src/dest mac& type */
name|m_copydata
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
literal|2
argument_list|,
name|tx_frame_802_3
operator|.
name|an_tx_802_3_payload_len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|an_txbuf
argument_list|)
expr_stmt|;
name|txcontrol
operator|=
name|AN_TXCTL_8023
expr_stmt|;
comment|/* write the txcontrol only */
name|an_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x08
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|txcontrol
argument_list|,
sizeof|sizeof
argument_list|(
name|txcontrol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 802_3 header */
name|an_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x34
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame_802_3
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|an_txframe_802_3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* in mbuf header type is just before payload */
name|an_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0x44
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|an_txbuf
argument_list|,
name|tx_frame_802_3
operator|.
name|an_tx_802_3_payload_len
argument_list|)
expr_stmt|;
comment|/* 		 * If there's a BPF listner, bounce a copy of 		 * this frame to him. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_ring
index|[
name|idx
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_TX
argument_list|,
name|id
argument_list|)
condition|)
name|printf
argument_list|(
literal|"an%d: xmit failed\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|AN_INC
argument_list|(
name|idx
argument_list|,
name|AN_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_prod
operator|=
name|idx
expr_stmt|;
comment|/* 	 * Set a timeout in case the chip goes out to lunch. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|an_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_FORCE_SYNCLOSS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_TX_RING_CNT
condition|;
name|i
operator|++
control|)
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DEALLOC_MEM
argument_list|,
name|sc
operator|->
name|an_rdata
operator|.
name|an_tx_fids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|an_stats_update
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|an_stat_ch
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|an_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_gone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"an%d: device timeout\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
name|an_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|an_shutdown
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|an_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ANCACHE
end_ifdef

begin_comment
comment|/* Aironet signal strength cache code.  * store signal/noise/quality on per MAC src basis in  * a small fixed cache.  The cache wraps if> MAX slots  * used.  The cache may be zeroed out to start over.  * Two simple filters exist to reduce computation:  * 1. ip only (literally 0x800, ETHERTYPE_IP) which may be used  * to ignore some packets.  It defaults to ip only.  * it could be used to focus on broadcast, non-IP 802.11 beacons.  * 2. multicast/broadcast only.  This may be used to  * ignore unicast packets and only cache signal strength  * for multicast/broadcast packets (beacons); e.g., Mobile-IP  * beacons and not unicast traffic.  *  * The cache stores (MAC src(index), IP src (major clue), signal,  *	quality, noise)  *  * No apologies for storing IP src here.  It's easy and saves much  * trouble elsewhere.  The cache is assumed to be INET dependent,  * although it need not be.  *  * Note: the Aironet only has a single byte of signal strength value  * in the rx frame header, and it's not scaled to anything sensible.  * This is kind of lame, but it's all we've got.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|documentation
end_ifdef

begin_decl_stmt
name|int
name|an_sigitems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached entries */
end_comment

begin_decl_stmt
name|struct
name|an_sigcache
name|an_sigcache
index|[
name|MAXANCACHE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  array of cache entries */
end_comment

begin_decl_stmt
name|int
name|an_nextitem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  index/# of entries */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* control variables for cache filtering.  Basic idea is  * to reduce cost (e.g., to only Mobile-IP agent beacons  * which are broadcast or multicast).  Still you might  * want to measure signal strength anth unicast ping packets  * on a pt. to pt. ant. setup.  */
end_comment

begin_comment
comment|/* set true if you want to limit cache items to broadcast/mcast  * only packets (not unicast).  Useful for mobile-ip beacons which  * are broadcast/multicast at network layer.  Default is all packets  * so ping/unicast anll work say anth pt. to pt. antennae setup.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|an_cache_mcastonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|an_cache_mcastonly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|an_cache_mcastonly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set true if you want to limit cache items to IP packets only */
end_comment

begin_decl_stmt
specifier|static
name|int
name|an_cache_iponly
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|an_cache_iponly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|an_cache_iponly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * an_cache_store, per rx packet store signal  * strength in MAC (src) indexed cache.  */
end_comment

begin_function
specifier|static
name|void
name|an_cache_store
parameter_list|(
name|sc
parameter_list|,
name|eh
parameter_list|,
name|m
parameter_list|,
name|rx_quality
parameter_list|)
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|short
name|rx_quality
decl_stmt|;
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|cache_slot
init|=
literal|0
decl_stmt|;
comment|/* use this cache entry */
specifier|static
name|int
name|wrapindex
init|=
literal|0
decl_stmt|;
comment|/* next "free" cache entry */
name|int
name|type_ipv4
init|=
literal|0
decl_stmt|;
comment|/* filters: 	 * 1. ip only 	 * 2. configurable filter to throw out unicast packets, 	 * keep multicast only. 	 */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_IP
operator|)
condition|)
block|{
name|type_ipv4
operator|=
literal|1
expr_stmt|;
block|}
comment|/* filter for ip packets only 	*/
if|if
condition|(
name|an_cache_iponly
operator|&&
operator|!
name|type_ipv4
condition|)
block|{
return|return;
block|}
comment|/* filter for broadcast/multicast only 	 */
if|if
condition|(
name|an_cache_mcastonly
operator|&&
operator|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|SIGDEBUG
name|printf
argument_list|(
literal|"an: q value %x (MSB=0x%x, LSB=0x%x) \n"
argument_list|,
name|rx_quality
operator|&
literal|0xffff
argument_list|,
name|rx_quality
operator|>>
literal|8
argument_list|,
name|rx_quality
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* find the ip header.  we want to store the ip_src 	 * address. 	 */
if|if
condition|(
name|type_ipv4
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* do a linear search for a matching MAC address 	 * in the cache table 	 * . MAC address is 6 bytes, 	 * . var w_nextitem holds total number of entries already cached 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|an_nextitem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|an_sigcache
index|[
name|i
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/* Match!, 			 * so we already have this entry, 			 * update the data 			 */
break|break;
block|}
block|}
comment|/* did we find a matching mac address? 	 * if yes, then overwrite a previously existing cache entry 	 */
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|an_nextitem
condition|)
block|{
name|cache_slot
operator|=
name|i
expr_stmt|;
block|}
comment|/* else, have a new address entry,so 	 * add this new entry, 	 * if table full, then we need to replace LRU entry 	 */
else|else
block|{
comment|/* check for space in cache table 		 * note: an_nextitem also holds number of entries 		 * added in the cache table 		 */
if|if
condition|(
name|sc
operator|->
name|an_nextitem
operator|<
name|MAXANCACHE
condition|)
block|{
name|cache_slot
operator|=
name|sc
operator|->
name|an_nextitem
expr_stmt|;
name|sc
operator|->
name|an_nextitem
operator|++
expr_stmt|;
name|sc
operator|->
name|an_sigitems
operator|=
name|sc
operator|->
name|an_nextitem
expr_stmt|;
block|}
comment|/* no space found, so simply wrap anth wrap index 		 * and "zap" the next entry 		 */
else|else
block|{
if|if
condition|(
name|wrapindex
operator|==
name|MAXANCACHE
condition|)
block|{
name|wrapindex
operator|=
literal|0
expr_stmt|;
block|}
name|cache_slot
operator|=
name|wrapindex
operator|++
expr_stmt|;
block|}
block|}
comment|/* invariant: cache_slot now points at some slot 	 * in cache. 	 */
if|if
condition|(
name|cache_slot
operator|<
literal|0
operator|||
name|cache_slot
operator|>=
name|MAXANCACHE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"an_cache_store, bad index: %d of "
literal|"[0..%d], gross cache error\n"
argument_list|,
name|cache_slot
argument_list|,
name|MAXANCACHE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  store items in cache 	 *  .ip source address 	 *  .mac src 	 *  .signal, etc. 	 */
if|if
condition|(
name|type_ipv4
condition|)
block|{
name|sc
operator|->
name|an_sigcache
index|[
name|cache_slot
index|]
operator|.
name|ipsrc
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|an_sigcache
index|[
name|cache_slot
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|an_sigcache
index|[
name|cache_slot
index|]
operator|.
name|signal
operator|=
name|rx_quality
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|an_media_change
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|otype
init|=
name|sc
operator|->
name|an_config
operator|.
name|an_opmode
decl_stmt|;
name|int
name|orate
init|=
name|sc
operator|->
name|an_tx_rate
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|an_ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|&
name|IFM_IEEE80211_ADHOC
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|an_config
operator|.
name|an_opmode
operator|=
name|AN_OPMODE_IBSS_ADHOC
expr_stmt|;
else|else
name|sc
operator|->
name|an_config
operator|.
name|an_opmode
operator|=
name|AN_OPMODE_INFRASTRUCTURE_STATION
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|an_ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_IEEE80211_DS1
case|:
name|sc
operator|->
name|an_tx_rate
operator|=
name|AN_RATE_1MBPS
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_DS2
case|:
name|sc
operator|->
name|an_tx_rate
operator|=
name|AN_RATE_2MBPS
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_DS5
case|:
name|sc
operator|->
name|an_tx_rate
operator|=
name|AN_RATE_5_5MBPS
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_DS11
case|:
name|sc
operator|->
name|an_tx_rate
operator|=
name|AN_RATE_11MBPS
expr_stmt|;
break|break;
case|case
name|IFM_AUTO
case|:
name|sc
operator|->
name|an_tx_rate
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|otype
operator|!=
name|sc
operator|->
name|an_config
operator|.
name|an_opmode
operator|||
name|orate
operator|!=
name|sc
operator|->
name|an_tx_rate
condition|)
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|an_media_status
parameter_list|(
name|ifp
parameter_list|,
name|imr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|imr
decl_stmt|;
block|{
name|struct
name|an_ltv_status
name|status
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|status
operator|.
name|an_len
operator|=
sizeof|sizeof
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|status
operator|.
name|an_type
operator|=
name|AN_RID_STATUS
expr_stmt|;
if|if
condition|(
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|status
argument_list|)
condition|)
block|{
comment|/* If the status read fails, just lie. */
name|imr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|an_ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|an_tx_rate
operator|==
literal|0
condition|)
block|{
name|imr
operator|->
name|ifm_active
operator|=
name|IFM_IEEE80211
operator||
name|IFM_AUTO
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|an_config
operator|.
name|an_opmode
operator|==
name|AN_OPMODE_IBSS_ADHOC
condition|)
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_ADHOC
expr_stmt|;
switch|switch
condition|(
name|status
operator|.
name|an_current_tx_rate
condition|)
block|{
case|case
name|AN_RATE_1MBPS
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS1
expr_stmt|;
break|break;
case|case
name|AN_RATE_2MBPS
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS2
expr_stmt|;
break|break;
case|case
name|AN_RATE_5_5MBPS
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS5
expr_stmt|;
break|break;
case|case
name|AN_RATE_11MBPS
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS11
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|imr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|an_ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
block|}
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|an_opmode
operator|&
name|AN_STATUS_OPMODE_ASSOCIATED
condition|)
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************** Cisco utility support routines *************/
end_comment

begin_comment
comment|/*  * ReadRids& WriteRids derived from Cisco driver additions to Ben Reed's  * Linux driver  */
end_comment

begin_function
specifier|static
name|int
name|readrids
parameter_list|(
name|ifp
parameter_list|,
name|l_ioctl
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|aironet_ioctl
modifier|*
name|l_ioctl
decl_stmt|;
block|{
name|unsigned
name|short
name|rid
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
switch|switch
condition|(
name|l_ioctl
operator|->
name|command
condition|)
block|{
case|case
name|AIROGCAP
case|:
name|rid
operator|=
name|AN_RID_CAPABILITIES
expr_stmt|;
break|break;
case|case
name|AIROGCFG
case|:
name|rid
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
break|break;
case|case
name|AIROGSLIST
case|:
name|rid
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
break|break;
case|case
name|AIROGVLIST
case|:
name|rid
operator|=
name|AN_RID_APLIST
expr_stmt|;
break|break;
case|case
name|AIROGDRVNAM
case|:
name|rid
operator|=
name|AN_RID_DRVNAME
expr_stmt|;
break|break;
case|case
name|AIROGEHTENC
case|:
name|rid
operator|=
name|AN_RID_ENCAPPROTO
expr_stmt|;
break|break;
case|case
name|AIROGWEPKTMP
case|:
name|rid
operator|=
name|AN_RID_WEP_TEMP
expr_stmt|;
break|break;
case|case
name|AIROGWEPKNV
case|:
name|rid
operator|=
name|AN_RID_WEP_PERM
expr_stmt|;
break|break;
case|case
name|AIROGSTAT
case|:
name|rid
operator|=
name|AN_RID_STATUS
expr_stmt|;
break|break;
case|case
name|AIROGSTATSD32
case|:
name|rid
operator|=
name|AN_RID_32BITS_DELTA
expr_stmt|;
break|break;
case|case
name|AIROGSTATSC32
case|:
name|rid
operator|=
name|AN_RID_32BITS_CUM
expr_stmt|;
break|break;
default|default:
name|rid
operator|=
literal|999
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rid
operator|==
literal|999
condition|)
comment|/* Is bad command */
return|return
operator|-
name|EINVAL
return|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
name|AN_MAX_DATALEN
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|rid
expr_stmt|;
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
name|l_ioctl
operator|->
name|len
operator|=
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|-
literal|4
expr_stmt|;
comment|/* just data */
comment|/* the data contains the length at first */
if|if
condition|(
name|copyout
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|)
argument_list|,
name|l_ioctl
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
operator|.
name|an_len
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
comment|/* Just copy the data back */
if|if
condition|(
name|copyout
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|areq
operator|.
name|an_val
operator|)
argument_list|,
name|l_ioctl
operator|->
name|data
operator|+
literal|2
argument_list|,
name|l_ioctl
operator|->
name|len
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|writerids
parameter_list|(
name|ifp
parameter_list|,
name|l_ioctl
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|aironet_ioctl
modifier|*
name|l_ioctl
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|command
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|command
operator|=
name|l_ioctl
operator|->
name|command
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|AIROPSIDS
case|:
name|rid
operator|=
name|AN_RID_SSIDLIST
expr_stmt|;
break|break;
case|case
name|AIROPCAP
case|:
name|rid
operator|=
name|AN_RID_CAPABILITIES
expr_stmt|;
break|break;
case|case
name|AIROPAPLIST
case|:
name|rid
operator|=
name|AN_RID_APLIST
expr_stmt|;
break|break;
case|case
name|AIROPCFG
case|:
name|rid
operator|=
name|AN_RID_GENCONFIG
expr_stmt|;
break|break;
case|case
name|AIROPMACON
case|:
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|AIROPMACOFF
case|:
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|AIROPSTCLR
case|:
comment|/* 		 * This command merely clears the counts does not actually 		 * store any data only reads rid. But as it changes the cards 		 * state, I put it in the writerid routines. 		 */
name|rid
operator|=
name|AN_RID_32BITS_DELTACLR
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
name|AN_MAX_DATALEN
expr_stmt|;
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|rid
expr_stmt|;
name|an_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
name|l_ioctl
operator|->
name|len
operator|=
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|-
literal|4
expr_stmt|;
comment|/* just data */
comment|/* the data contains the length at first */
if|if
condition|(
name|copyout
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|)
argument_list|,
name|l_ioctl
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
operator|.
name|an_len
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
comment|/* Just copy the data */
if|if
condition|(
name|copyout
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|areq
operator|.
name|an_val
operator|)
argument_list|,
name|l_ioctl
operator|->
name|data
operator|+
literal|2
argument_list|,
name|l_ioctl
operator|->
name|len
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
break|break;
case|case
name|AIROPWEPKEY
case|:
name|rid
operator|=
name|AN_RID_WEP_TEMP
expr_stmt|;
break|break;
case|case
name|AIROPWEPKEYNV
case|:
name|rid
operator|=
name|AN_RID_WEP_PERM
expr_stmt|;
break|break;
case|case
name|AIROPLEAPUSR
case|:
name|rid
operator|=
name|AN_RID_LEAPUSERNAME
expr_stmt|;
break|break;
case|case
name|AIROPLEAPPWD
case|:
name|rid
operator|=
name|AN_RID_LEAPPASSWORD
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EOPNOTSUPP
return|;
block|}
if|if
condition|(
name|rid
condition|)
block|{
if|if
condition|(
name|l_ioctl
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|areq
operator|.
name|an_val
argument_list|)
operator|+
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sc
operator|->
name|areq
operator|.
name|an_len
operator|=
name|l_ioctl
operator|->
name|len
operator|+
literal|4
expr_stmt|;
comment|/* add type& length */
name|sc
operator|->
name|areq
operator|.
name|an_type
operator|=
name|rid
expr_stmt|;
comment|/* Just copy the data back */
name|copyin
argument_list|(
operator|(
name|l_ioctl
operator|->
name|data
operator|)
operator|+
literal|2
argument_list|,
operator|&
name|sc
operator|->
name|areq
operator|.
name|an_val
argument_list|,
name|l_ioctl
operator|->
name|len
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|an_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|an_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*  * General Flash utilities derived from Cisco driver additions to Ben Reed's  * Linux driver  */
end_comment

begin_define
define|#
directive|define
name|FLASH_DELAY
parameter_list|(
name|x
parameter_list|)
value|tsleep(ifp, PZERO, "flash", ((x) / hz) + 1);
end_define

begin_function
specifier|static
name|int
name|unstickbusy
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|)
operator|&
name|AN_CMD_BUSY
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_EVENT_ACK
argument_list|,
name|AN_EV_CLR_STUCK_BUSY
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for busy completion from card wait for delay uSec's Return true for  * success meaning command reg is clear  */
end_comment

begin_function
specifier|static
name|int
name|WaitBusy
parameter_list|(
name|ifp
parameter_list|,
name|uSec
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|uSec
decl_stmt|;
block|{
name|int
name|statword
init|=
literal|0xffff
decl_stmt|;
name|int
name|delay
init|=
literal|0
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
while|while
condition|(
operator|(
name|statword
operator|&
name|AN_CMD_BUSY
operator|)
operator|&&
name|delay
operator|<=
operator|(
literal|1000
operator|*
literal|100
operator|)
condition|)
block|{
name|FLASH_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|delay
operator|+=
literal|10
expr_stmt|;
name|statword
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|AN_CMD_BUSY
operator|&
name|statword
operator|)
operator|&&
operator|(
name|delay
operator|%
literal|200
operator|)
condition|)
block|{
name|unstickbusy
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
operator|==
operator|(
name|AN_CMD_BUSY
operator|&
name|statword
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * STEP 1) Disable MAC and do soft reset on card.  */
end_comment

begin_function
specifier|static
name|int
name|cmdreset
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|an_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|an_cmd
argument_list|(
name|sc
argument_list|,
name|AN_CMD_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|=
name|WaitBusy
argument_list|(
name|ifp
argument_list|,
literal|600
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: Waitbusy hang b4 RESET =%d\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|,
name|AN_CMD_FW_RESTART
argument_list|)
expr_stmt|;
name|FLASH_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* WAS 600 12/7/00 */
if|if
condition|(
operator|!
operator|(
name|status
operator|=
name|WaitBusy
argument_list|(
name|ifp
argument_list|,
literal|100
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: Waitbusy hang AFTER RESET =%d\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * STEP 2) Put the card in legendary flash mode  */
end_comment

begin_define
define|#
directive|define
name|FLASH_COMMAND
value|0x7e7e
end_define

begin_function
specifier|static
name|int
name|setflashmode
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW0
argument_list|,
name|FLASH_COMMAND
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW1
argument_list|,
name|FLASH_COMMAND
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW0
argument_list|,
name|FLASH_COMMAND
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_COMMAND
argument_list|,
name|FLASH_COMMAND
argument_list|)
expr_stmt|;
comment|/* 	 * mdelay(500); // 500ms delay 	 */
name|FLASH_DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|=
name|WaitBusy
argument_list|(
name|ifp
argument_list|,
literal|600
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Waitbusy hang after setflash mode\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get a character from the card matching matchbyte Step 3)  */
end_comment

begin_function
specifier|static
name|int
name|flashgchar
parameter_list|(
name|ifp
parameter_list|,
name|matchbyte
parameter_list|,
name|dwelltime
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|matchbyte
decl_stmt|;
name|int
name|dwelltime
decl_stmt|;
block|{
name|int
name|rchar
decl_stmt|;
name|unsigned
name|char
name|rbyte
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
do|do
block|{
name|rchar
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_SW1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwelltime
operator|&&
operator|!
operator|(
literal|0x8000
operator|&
name|rchar
operator|)
condition|)
block|{
name|dwelltime
operator|-=
literal|10
expr_stmt|;
name|FLASH_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rbyte
operator|=
literal|0xff
operator|&
name|rchar
expr_stmt|;
if|if
condition|(
operator|(
name|rbyte
operator|==
name|matchbyte
operator|)
operator|&&
operator|(
literal|0x8000
operator|&
name|rchar
operator|)
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rbyte
operator|==
literal|0x81
operator|||
name|rbyte
operator|==
literal|0x82
operator|||
name|rbyte
operator|==
literal|0x83
operator|||
name|rbyte
operator|==
literal|0x1a
operator|||
literal|0xffff
operator|==
name|rchar
condition|)
break|break;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dwelltime
operator|>
literal|0
condition|)
do|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Put character to SWS0 wait for dwelltime x 50us for  echo .  */
end_comment

begin_function
specifier|static
name|int
name|flashpchar
parameter_list|(
name|ifp
parameter_list|,
name|byte
parameter_list|,
name|dwelltime
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|byte
decl_stmt|;
name|int
name|dwelltime
decl_stmt|;
block|{
name|int
name|echo
decl_stmt|;
name|int
name|pollbusy
decl_stmt|,
name|waittime
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|byte
operator||=
literal|0x8000
expr_stmt|;
if|if
condition|(
name|dwelltime
operator|==
literal|0
condition|)
name|dwelltime
operator|=
literal|200
expr_stmt|;
name|waittime
operator|=
name|dwelltime
expr_stmt|;
comment|/* 	 * Wait for busy bit d15 to go false indicating buffer empty 	 */
do|do
block|{
name|pollbusy
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_SW0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pollbusy
operator|&
literal|0x8000
condition|)
block|{
name|FLASH_DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|waittime
operator|-=
literal|50
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
do|while
condition|(
name|waittime
operator|>=
literal|0
condition|)
do|;
comment|/* timeout for busy clear wait */
if|if
condition|(
name|waittime
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: flash putchar busywait timeout! \n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Port is clear now write byte and wait for it to echo back 	 */
do|do
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW0
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|FLASH_DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|dwelltime
operator|-=
literal|50
expr_stmt|;
name|echo
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|AN_SW1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dwelltime
operator|>=
literal|0
operator|&&
name|echo
operator|!=
name|byte
condition|)
do|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|echo
operator|==
name|byte
return|;
block|}
end_function

begin_comment
comment|/*  * Transfer 32k of firmware data from user buffer to our buffer and send to  * the card  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|flashbuffer
index|[
literal|1024
operator|*
literal|38
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RAW Buffer for flash will be 					 * dynamic next */
end_comment

begin_function
specifier|static
name|int
name|flashputbuf
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|unsigned
name|short
modifier|*
name|bufp
decl_stmt|;
name|int
name|nwords
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* Write stuff */
name|bufp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|flashbuffer
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_AUX_PAGE
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_AUX_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|nwords
operator|=
literal|0
init|;
name|nwords
operator|!=
literal|16384
condition|;
name|nwords
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_AUX_DATA
argument_list|,
name|bufp
index|[
name|nwords
index|]
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|AN_SW0
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * After flashing restart the card.  */
end_comment

begin_function
specifier|static
name|int
name|flashrestart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|FLASH_DELAY
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
comment|/* Added 12/7/00 */
name|an_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FLASH_DELAY
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
comment|/* Added 12/7/00 */
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Entry point for flash ioclt.  */
end_comment

begin_function
specifier|static
name|int
name|flashcard
parameter_list|(
name|ifp
parameter_list|,
name|l_ioctl
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|aironet_ioctl
modifier|*
name|l_ioctl
decl_stmt|;
block|{
name|int
name|z
init|=
literal|0
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|an_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|status
operator|=
name|l_ioctl
operator|->
name|command
expr_stmt|;
switch|switch
condition|(
name|l_ioctl
operator|->
name|command
condition|)
block|{
case|case
name|AIROFLSHRST
case|:
return|return
name|cmdreset
argument_list|(
name|ifp
argument_list|)
return|;
break|break;
case|case
name|AIROFLSHSTFL
case|:
return|return
name|setflashmode
argument_list|(
name|ifp
argument_list|)
return|;
break|break;
case|case
name|AIROFLSHGCHR
case|:
comment|/* Get char from aux */
name|copyin
argument_list|(
name|l_ioctl
operator|->
name|data
argument_list|,
operator|&
name|sc
operator|->
name|areq
argument_list|,
name|l_ioctl
operator|->
name|len
argument_list|)
expr_stmt|;
name|z
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|flashgchar
argument_list|(
name|ifp
argument_list|,
name|z
argument_list|,
literal|8000
argument_list|)
operator|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|AIROFLSHPCHR
case|:
comment|/* Send char to card. */
name|copyin
argument_list|(
name|l_ioctl
operator|->
name|data
argument_list|,
operator|&
name|sc
operator|->
name|areq
argument_list|,
name|l_ioctl
operator|->
name|len
argument_list|)
expr_stmt|;
name|z
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|sc
operator|->
name|areq
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|flashpchar
argument_list|(
name|ifp
argument_list|,
name|z
argument_list|,
literal|8000
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
name|EIO
return|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|AIROFLPUTBUF
case|:
comment|/* Send 32k to card */
if|if
condition|(
name|l_ioctl
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|flashbuffer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: Buffer to big, %x %x\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|l_ioctl
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|flashbuffer
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|copyin
argument_list|(
name|l_ioctl
operator|->
name|data
argument_list|,
operator|&
name|flashbuffer
argument_list|,
name|l_ioctl
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|flashputbuf
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EIO
return|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|AIRORESTART
case|:
if|if
condition|(
operator|(
name|status
operator|=
name|flashrestart
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"an%d: FLASHRESTART returned %d\n"
argument_list|,
name|sc
operator|->
name|an_unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
else|else
return|return
literal|0
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

end_unit

