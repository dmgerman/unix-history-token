begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Scott Mitchell  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: if_xe.c,v 1.20 1999/06/13 19:17:40 scott Exp $  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Portions of this software were derived from Werner Koch's xirc2ps driver  * for Linux under the terms of the following license (from v1.30 of the  * xirc2ps driver):  *  * Copyright (c) 1997 by Werner Koch (dd9jn)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		  * FreeBSD device driver for Xircom CreditCard PCMCIA Ethernet adapters.  The  * following cards are currently known to work with the driver:  *   Xircom CreditCard 10/100 (CE3)  *   Xircom CreditCard Ethernet + Modem 28 (CEM28)  *   Xircom CreditCard Ethernet 10/100 + Modem 56 (CEM56)  *   Xircom RealPort Ethernet 10  *   Xircom RealPort Ethernet 10/100  *   Xircom RealPort Ethernet 10/100 + Modem 56 (REM56, REM56G)  *   Intel EtherExpress Pro/100 PC Card Mobile Adapter 16 (Pro/100 M16A)  *   Compaq Netelligent 10/100 PC Card (CPQ-10/100)  *  * Some other cards *should* work, but support for them is either broken or in   * an unknown state at the moment.  I'm always interested in hearing from  * people who own any of these cards:  *   Xircom CreditCard 10Base-T (PS-CE2-10)  *   Xircom CreditCard Ethernet + ModemII (CEM2)  *   Xircom CEM28 and CEM33 Ethernet/Modem cards (may be variants of CEM2?)  *  * Thanks to all who assisted with the development and testing of the driver,  * especially: Werner Koch, Duke Kamstra, Duncan Barclay, Jason George, Dru  * Nelson, Mike Kephart, Bill Rainey and Douglas Rand.  Apologies if I've left  * out anyone who deserves a mention here.  *  * Special thanks to Ade Lovett for both hosting the mailing list and doing  * the CEM56/REM56 support code; and the FreeBSD UK Users' Group for hosting  * the web pages.  *  * Contact points:  *  * Driver web page: http://ukug.uk.freebsd.org/~scott/xe_drv/  *  * Mailing list: http://www.lovett.com/lists/freebsd-xircom/  * or send "subscribe freebsd-xircom" to<majordomo@lovett.com>  *  * Author email:<scott@uk.freebsd.org>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XE_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|XE_DEBUG
value|1
end_define

begin_comment
comment|/* Increase for more voluminous output! */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xe.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_if
if|#
directive|if
name|NXE
operator|>
literal|0
end_if

begin_undef
undef|#
directive|undef
name|NCARD
end_undef

begin_define
define|#
directive|define
name|NCARD
value|0
end_define

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/if_xereg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|xe_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
name|struct
name|ifmib_iso_8802_3
name|mibdata
decl_stmt|;
name|struct
name|callout_handle
name|chand
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|pccard_devinfo
modifier|*
name|crd
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name */
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer */
name|int
name|unit
decl_stmt|;
comment|/* Unit number, from dev->id_unit */
name|int
name|srev
decl_stmt|;
comment|/* Silicon revision */
name|int
name|tx_queued
decl_stmt|;
comment|/* Packets currently waiting to transmit */
name|int
name|tx_tpr
decl_stmt|;
comment|/* Last value of TPR reg on card */
name|int
name|tx_collisions
decl_stmt|;
comment|/* Collisions since last successful send */
name|int
name|tx_timeouts
decl_stmt|;
comment|/* Count of transmit timeouts */
name|int
name|autoneg_status
decl_stmt|;
comment|/* Autonegotiation progress state */
name|int
name|media
decl_stmt|;
comment|/* Private media word */
name|u_char
name|version
decl_stmt|;
comment|/* Bonding Version register from card */
name|u_char
name|modem
decl_stmt|;
comment|/* 1 = Card has a modem */
name|u_char
name|ce2
decl_stmt|;
comment|/* 1 = Card has CE2 silicon */
name|u_char
name|mohawk
decl_stmt|;
comment|/* 1 = Card has Mohawk (CE3) silicon */
name|u_char
name|dingo
decl_stmt|;
comment|/* 1 = Card has Dingo (CEM56) silicon */
name|u_char
name|phy_ok
decl_stmt|;
comment|/* 1 = MII-compliant PHY found and initialised */
name|u_char
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out */
if|#
directive|if
name|NAPM
operator|>
literal|0
name|struct
name|apmhook
name|suspend_hook
decl_stmt|;
name|struct
name|apmhook
name|resume_hook
decl_stmt|;
endif|#
directive|endif
comment|/* NAPM> 0 */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|xe_softc
modifier|*
name|sca
index|[
name|MAXSLOT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MII command structure  */
end_comment

begin_struct
struct|struct
name|xe_mii_frame
block|{
name|u_int8_t
name|mii_stdelim
decl_stmt|;
name|u_int8_t
name|mii_opcode
decl_stmt|;
name|u_int8_t
name|mii_phyaddr
decl_stmt|;
name|u_int8_t
name|mii_regaddr
decl_stmt|;
name|u_int8_t
name|mii_turnaround
decl_stmt|;
name|u_int16_t
name|mii_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * For accessing card registers  */
end_comment

begin_define
define|#
directive|define
name|XE_INB
parameter_list|(
name|r
parameter_list|)
value|inb(scp->dev->id_iobase+(r))
end_define

begin_define
define|#
directive|define
name|XE_INW
parameter_list|(
name|r
parameter_list|)
value|inw(scp->dev->id_iobase+(r))
end_define

begin_define
define|#
directive|define
name|XE_OUTB
parameter_list|(
name|r
parameter_list|,
name|b
parameter_list|)
value|outb(scp->dev->id_iobase+(r), (b))
end_define

begin_define
define|#
directive|define
name|XE_OUTW
parameter_list|(
name|r
parameter_list|,
name|w
parameter_list|)
value|outw(scp->dev->id_iobase+(r), (w))
end_define

begin_define
define|#
directive|define
name|XE_SELECT_PAGE
parameter_list|(
name|p
parameter_list|)
value|XE_OUTB(XE_PR, (p))
end_define

begin_comment
comment|/*  * Horrid stuff for accessing CIS tuples  */
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_define
define|#
directive|define
name|CISTPL_BUFSIZE
value|512
end_define

begin_define
define|#
directive|define
name|CISTPL_TYPE
parameter_list|(
name|tpl
parameter_list|)
value|tpl[0]
end_define

begin_define
define|#
directive|define
name|CISTPL_LEN
parameter_list|(
name|tpl
parameter_list|)
value|tpl[2]
end_define

begin_define
define|#
directive|define
name|CISTPL_DATA
parameter_list|(
name|tpl
parameter_list|,
name|pos
parameter_list|)
value|tpl[4 + ((pos)<<1)]
end_define

begin_comment
comment|/*  * Media autonegotiation progress constants  */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_NONE
value|0
end_define

begin_comment
comment|/* No autonegotiation in progress */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_WAITING
value|1
end_define

begin_comment
comment|/* Waiting for transmitter to go idle */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_STARTED
value|2
end_define

begin_comment
comment|/* Waiting for autonegotiation to complete */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_100TX
value|3
end_define

begin_comment
comment|/* Trying to force 100baseTX link */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_FAIL
value|4
end_define

begin_comment
comment|/* Autonegotiation failed */
end_comment

begin_comment
comment|/*  * Prototypes start here  */
end_comment

begin_function_decl
specifier|static
name|int
name|xe_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_card_init
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|mrp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|xe_setmedia
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xe_hard_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_soft_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_enable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_disable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_setmulti
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_setaddrs
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_card_unload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|xe_compute_crc
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_compute_hashbit
parameter_list|(
name|u_int32_t
name|crc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * MII functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_mii_sync
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_send
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int32_t
name|bits
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|xe_phy_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_phy_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Debug functions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|XE_REG_DUMP
parameter_list|(
name|scp
parameter_list|)
value|xe_reg_dump((scp))
end_define

begin_define
define|#
directive|define
name|XE_MII_DUMP
parameter_list|(
name|scp
parameter_list|)
value|xe_mii_dump((scp))
end_define

begin_function_decl
specifier|static
name|void
name|xe_reg_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XE_REG_DUMP
parameter_list|(
name|scp
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XE_MII_DUMP
parameter_list|(
name|scp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_comment
comment|/*  * APM hook functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|xe_suspend
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_resume
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_comment
comment|/*  * PCMCIA driver hooks  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PCCARD_MODULE
end_ifdef

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|xe
argument_list|,
name|xe_card_init
argument_list|,
name|xe_card_unload
argument_list|,
name|xe_card_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|pccard_device
name|xe_info
init|=
block|{
comment|/* For pre 3.1-STABLE code */
literal|"xe"
block|,
name|xe_card_init
block|,
name|xe_card_unload
block|,
name|xe_card_intr
block|,
literal|0
block|,
operator|&
name|net_imask
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pccarddrv_set
argument_list|,
name|xe_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCCARD_MODULE */
end_comment

begin_comment
comment|/*  * ISA driver hooks.  I'd like to do without these but the kernel config stuff   * seems to require them.  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|xedriver
init|=
block|{
name|xe_probe
block|,
name|xe_attach
block|,
literal|"xe"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ISA probe routine.  * All of the supported devices are PCMCIA cards.  I have no idea if it's even   * possible to successfully probe/attach these at boot time (pccardd normally  * does a lot of setup work) so I don't even bother trying.  */
end_comment

begin_function
specifier|static
name|int
name|xe_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: probe\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|sca
argument_list|,
name|MAXSLOT
operator|*
sizeof|sizeof
argument_list|(
name|sca
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Two routines to read from/write to the attribute memory  * the write portion is used only for fixing up the RealPort cards,  * the reader portion was needed for debugging info, and duplicated some  * code in xe_card_init(), so it appears here instead with suitable  * modifications to xe_card_init()  * -aDe Lovett  */
end_comment

begin_function
specifier|static
name|int
name|xe_memwrite
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_char
name|byte
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|byte
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* THIS IS BOGUS */
block|return cdevsw[CARD_MAJOR]->d_write(makedev(CARD_MAJOR, devi->slt->slotnum),&uios, 0);
else|#
directive|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|xe_memread
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* THIS IS BOGUS */
block|return cdevsw[CARD_MAJOR]->d_read(makedev(CARD_MAJOR, devi->slt->slotnum),&uios, 0);
else|#
directive|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Hacking for RealPort cards  */
end_comment

begin_function
specifier|static
name|int
name|xe_cem56fix
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
decl_stmt|;
name|struct
name|slot
modifier|*
name|slt
decl_stmt|;
name|struct
name|slot_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|int
name|ioport
decl_stmt|,
name|fail
decl_stmt|;
comment|/* initialise a few variables */
name|devi
operator|=
name|scp
operator|->
name|crd
expr_stmt|;
name|slt
operator|=
name|devi
operator|->
name|slt
expr_stmt|;
name|ctrl
operator|=
name|slt
operator|->
name|ctrl
expr_stmt|;
comment|/* allocate a new I/O slot for the ethernet */
comment|/* XXX: ctrl->mapio() always appears to return 0 (success), so    *      this may cause problems if another device is listening    *	  on 0x300 already.  In this case, you should choose a    *      known free I/O port address in the kernel config line    *      for the driver.  It will be picked up here and used    *      instead of the autodetected value.    */
name|slt
operator|->
name|io
index|[
literal|1
index|]
operator|.
name|window
operator|=
literal|1
expr_stmt|;
name|slt
operator|->
name|io
index|[
literal|1
index|]
operator|.
name|flags
operator|=
name|IODF_WS
operator||
name|IODF_16BIT
operator||
name|IODF_ZEROWS
operator||
name|IODF_ACTIVE
expr_stmt|;
name|slt
operator|->
name|io
index|[
literal|1
index|]
operator|.
name|size
operator|=
literal|0x10
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_IOBASE
name|printf
argument_list|(
literal|"xe%d: user requested ioport 0x%x\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|XE_IOBASE
argument_list|)
expr_stmt|;
name|ioport
operator|=
name|XE_IOBASE
expr_stmt|;
name|slt
operator|->
name|io
index|[
literal|1
index|]
operator|.
name|start
operator|=
name|ioport
expr_stmt|;
name|fail
operator|=
name|ctrl
operator|->
name|mapio
argument_list|(
name|slt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|ioport
operator|=
literal|0x300
init|;
name|ioport
operator|<
literal|0x400
condition|;
name|ioport
operator|+=
literal|0x10
control|)
block|{
name|slt
operator|->
name|io
index|[
literal|1
index|]
operator|.
name|start
operator|=
name|ioport
expr_stmt|;
if|if
condition|(
operator|(
name|fail
operator|=
name|ctrl
operator|->
name|mapio
argument_list|(
name|slt
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* did we find one? */
if|if
condition|(
name|fail
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: xe_cem56fix: no free address space\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* munge the id_iobase entry for use by the rest of the driver */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: using 0x%x for RealPort ethernet\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|ioport
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|dev
operator|->
name|id_iobase
operator|=
name|ioport
expr_stmt|;
name|scp
operator|->
name|dev
operator|->
name|id_alive
operator|=
literal|0x10
expr_stmt|;
comment|/* magic to set up the ethernet */
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_ECOR
argument_list|,
name|DINGO_ECOR_IRQ_LEVEL
operator||
name|DINGO_ECOR_INT_ENABLE
operator||
name|DINGO_ECOR_IOB_ENABLE
operator||
name|DINGO_ECOR_ETH_ENABLE
argument_list|)
expr_stmt|;
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_EBAR0
argument_list|,
name|ioport
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_EBAR1
argument_list|,
operator|(
name|ioport
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_DCOR0
argument_list|,
name|DINGO_DCOR0_SF_INT
argument_list|)
expr_stmt|;
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_DCOR1
argument_list|,
name|DINGO_DCOR1_INT_LEVEL
operator||
name|DINGO_DCOR1_EEDIO
argument_list|)
expr_stmt|;
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_DCOR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_DCOR3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|xe_memwrite
argument_list|(
name|devi
argument_list|,
name|DINGO_DCOR4
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* success! */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * PCMCIA probe routine.  * Probe and identify the device.  Called by the slot manager when the card is   * inserted or the machine wakes up from suspend mode.  Assmes that the slot  * structure has been initialised already.  */
end_comment

begin_function
specifier|static
name|int
name|xe_card_init
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
name|u_char
name|buf
index|[
name|CISTPL_BUFSIZE
index|]
decl_stmt|;
name|u_char
name|ver_str
index|[
name|CISTPL_BUFSIZE
operator|>>
literal|1
index|]
expr_stmt|;
name|off_t
name|offs
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|success
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|dev
operator|=
operator|&
name|devi
operator|->
name|isahd
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe: Probing for unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check that unit number is OK */
if|if
condition|(
name|unit
operator|>
name|MAXSLOT
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: bad unit\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Don't attach an active device */
if|if
condition|(
name|scp
operator|&&
operator|!
name|scp
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: already attached\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Allocate per-instance storage */
if|if
condition|(
operator|!
name|scp
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: failed to allocage driver storage\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Re-attach an existing device */
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
block|{
name|scp
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Grep through CIS looking for relevant tuples */
name|offs
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|u_int16_t
name|vendor
decl_stmt|;
name|u_int8_t
name|rev
decl_stmt|,
name|media
decl_stmt|,
name|prod
decl_stmt|;
comment|/*      * Read tuples one at a time into buf.  Sucks, but it only happens once.      * XXX - This assumes that attribute has been mapped by pccardd, which      * XXX - seems to be the default situation.  If not, we're well and truly      * XXX - FUBAR.  This is a general PCCARD problem, not our fault :)      */
if|if
condition|(
operator|(
name|rc
operator|=
name|xe_memread
argument_list|(
name|devi
argument_list|,
name|offs
argument_list|,
name|buf
argument_list|,
name|CISTPL_BUFSIZE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|CISTPL_TYPE
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
literal|0x15
case|:
comment|/* Grab version string (needed to ID some weird CE2's) */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Got version string (0x15)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
condition|;
name|ver_str
index|[
name|i
index|]
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
name|i
operator|++
argument_list|)
control|)
empty_stmt|;
name|ver_str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ver_str
index|[
operator|(
name|CISTPL_BUFSIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|success
operator|++
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
comment|/* Figure out what type of card we have */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Got card ID (0x20)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vendor
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|+
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|rev
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|media
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|prod
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vendor
condition|)
block|{
comment|/* Get vendor ID */
case|case
literal|0x0105
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Xircom"
expr_stmt|;
break|break;
case|case
literal|0x0138
case|:
case|case
literal|0x0183
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Compaq"
expr_stmt|;
break|break;
case|case
literal|0x0089
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Intel"
expr_stmt|;
break|break;
default|default:
name|scp
operator|->
name|vendor
operator|=
literal|"Unknown"
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|prod
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|media
operator|&
literal|0x01
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Not a PCMCIA Ethernet card!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|ENODEV
expr_stmt|;
comment|/* Not a PCMCIA Ethernet device */
block|}
else|else
block|{
if|if
condition|(
name|media
operator|&
literal|0x10
condition|)
block|{
comment|/* Ethernet/modem cards */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Card is Ethernet/modem combo\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|modem
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|prod
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|1
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CEM"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM2"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM3"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM33"
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM56M"
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
comment|/* Some kind of RealPort card */
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|dingo
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM56"
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Ethernet-only cards */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Card is Ethernet only\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|prod
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|1
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CE"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CE2"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CE3"
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
block|}
name|success
operator|++
expr_stmt|;
break|break;
case|case
literal|0x22
case|:
comment|/* Get MAC address */
if|if
condition|(
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|==
literal|8
operator|)
operator|&&
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0x04
operator|)
operator|&&
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
name|ETHER_ADDR_LEN
operator|)
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Got MAC address (0x22)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|,
name|i
operator|++
control|)
empty_stmt|;
block|}
name|success
operator|++
expr_stmt|;
break|break;
default|default:
block|}
block|}
comment|/* Skip to next tuple */
name|offs
operator|+=
operator|(
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|+
literal|2
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|CISTPL_TYPE
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0xff
operator|)
operator|&&
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0xff
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
do|;
comment|/* Die now if something went wrong above */
if|if
condition|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|||
operator|(
name|success
operator|<
literal|3
operator|)
condition|)
block|{
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* Check for certain strange CE2's that look like CE's */
if|if
condition|(
name|strcmp
argument_list|(
name|scp
operator|->
name|card_type
argument_list|,
literal|"CE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_char
modifier|*
name|str
init|=
name|ver_str
decl_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Checking for weird CE2 string\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Skip forward to 3rd version string */
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|str
index|[
name|i
index|]
argument_list|,
literal|"CE2"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Look for "CE2" string */
name|scp
operator|->
name|card_type
operator|=
literal|"CE2"
expr_stmt|;
block|}
block|}
block|}
comment|/* Reject unsupported cards */
if|if
condition|(
name|strcmp
argument_list|(
name|scp
operator|->
name|card_type
argument_list|,
literal|"CE"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|scp
operator|->
name|card_type
argument_list|,
literal|"CEM"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: Sorry, your %s card is not supported :(\n"
argument_list|,
name|unit
argument_list|,
name|scp
operator|->
name|card_type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
comment|/* Fill in some private data */
name|sca
index|[
name|unit
index|]
operator|=
name|scp
expr_stmt|;
name|scp
operator|->
name|dev
operator|=
operator|&
name|devi
operator|->
name|isahd
expr_stmt|;
name|scp
operator|->
name|crd
operator|=
name|devi
expr_stmt|;
name|scp
operator|->
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|scp
operator|->
name|ifm
operator|=
operator|&
name|scp
operator|->
name|ifmedia
expr_stmt|;
name|scp
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
literal|0
expr_stmt|;
comment|/* Hack RealPorts into submission */
if|if
condition|(
name|scp
operator|->
name|dingo
operator|&&
name|xe_cem56fix
argument_list|(
name|scp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: Unable to fix your RealPort\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sca
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
comment|/* Hopefully safe to read this here */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|scp
operator|->
name|version
operator|=
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
expr_stmt|;
comment|/* Attempt to attach the device */
if|if
condition|(
operator|!
name|xe_attach
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
condition|)
block|{
name|sca
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|#
directive|if
name|NAPM
operator|>
literal|0
comment|/* Establish APM hooks once device attached */
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_name
operator|=
literal|"xe_suspend"
expr_stmt|;
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_fun
operator|=
name|xe_suspend
expr_stmt|;
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|unit
expr_stmt|;
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_order
operator|=
name|APM_MIN_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|scp
operator|->
name|suspend_hook
argument_list|)
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_name
operator|=
literal|"xe_resume"
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_fun
operator|=
name|xe_resume
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|unit
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_order
operator|=
name|APM_MIN_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|scp
operator|->
name|resume_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAPM> 0 */
comment|/* Success */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a device (called when xe_card_init succeeds).  Assume that the probe  * routine has set up the softc structure correctly and that we can trust the  * unit number.  */
end_comment

begin_function
specifier|static
name|int
name|xe_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|sca
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: attach\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialise the ifnet structure */
if|if
condition|(
operator|!
name|scp
operator|->
name|ifp
operator|->
name|if_name
condition|)
block|{
name|scp
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|scp
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_name
operator|=
literal|"xe"
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_unit
operator|=
name|scp
operator|->
name|unit
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|scp
operator|->
name|mibdata
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
name|scp
operator|->
name|mibdata
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_start
operator|=
name|xe_start
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_ioctl
operator|=
name|xe_ioctl
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_watchdog
operator|=
name|xe_watchdog
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_init
operator|=
name|xe_init
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
block|}
comment|/* Initialise the ifmedia structure */
name|ifmedia_init
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
literal|0
argument_list|,
name|xe_media_change
argument_list|,
name|xe_media_status
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|scp
operator|->
name|chand
argument_list|)
expr_stmt|;
comment|/*    * Fill in supported media types.  Some cards _do_ support full duplex    * operation, but this driver doesn't, yet.  Therefore we leave those modes    * out of the list.  We support some form of autoselection in all cases.    */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Default is to autoselect best supported media type */
name|ifmedia_set
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* Print some useful information */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xe%d: %s %s, bonding version %#x%s%s\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|scp
operator|->
name|vendor
argument_list|,
name|scp
operator|->
name|card_type
argument_list|,
name|scp
operator|->
name|version
argument_list|,
name|scp
operator|->
name|mohawk
condition|?
literal|", 100Mbps capable"
else|:
literal|""
argument_list|,
name|scp
operator|->
name|modem
condition|?
literal|", with modem"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x10
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xe%d: DingoID = %#x, RevisionID = %#x, VendorID = %#x\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|XE_INW
argument_list|(
name|XE_DINGOID
argument_list|)
argument_list|,
name|XE_INW
argument_list|(
name|XE_RevID
argument_list|)
argument_list|,
name|XE_INW
argument_list|(
name|XE_VendorID
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|ce2
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xe%d: CE2 version = %#x\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|XE_INB
argument_list|(
name|XE_REV
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print MAC address */
name|printf
argument_list|(
literal|"xe%d: Ethernet address %02x"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|":%02x"
argument_list|,
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Attach the interface */
name|if_attach
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* If BPF is in the kernel, call the attach for it */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: BPF listener attached\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bpfattach
argument_list|(
name|scp
operator|->
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.  Completes the reset procedure on the card and starts  * output.  If there's an autonegotiation in progress we DON'T do anything;  * the media selection code will call us again when it's done.  */
end_comment

begin_function
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|xscp
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: init\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|scp
operator|->
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
return|return;
comment|/* Reset transmitter flags */
name|scp
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_tpr
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC0
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Disable source insertion (WTF is that?) */
comment|/*    * Set the 'local memory dividing line' -- splits the 32K card memory into    * 8K for transmit buffers and 24K for receive.  This is done automatically    * on newer revision cards.    */
if|if
condition|(
name|scp
operator|->
name|srev
operator|!=
literal|1
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_RBS
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
block|}
comment|/* Set up multicast addresses */
name|xe_setmulti
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Fix the data offset register -- reset leaves it off-by-one */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_DO
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
comment|/*    * Set MAC interrupt masks and clear status regs.  The bit names are direct    * from the Linux code; I have no idea what most of them do.    */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Bit 7..0 */
name|XE_OUTB
argument_list|(
name|XE_RX0Msk
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* ROK, RAB, rsv, RO,  CRC, AE,  PTL, MP  */
name|XE_OUTB
argument_list|(
name|XE_TX0Msk
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* TOK, TAB, SQE, LL,  TU,  JAB, EXC, CRS */
name|XE_OUTB
argument_list|(
name|XE_TX0Msk
operator|+
literal|1
argument_list|,
literal|0xb0
argument_list|)
expr_stmt|;
comment|/* rsv, rsv, PTD, EXT, rsv, rsv, rsv, rsv */
name|XE_OUTB
argument_list|(
name|XE_RST0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* ROK, RAB, REN, RO,  CRC, AE,  PTL, MP  */
name|XE_OUTB
argument_list|(
name|XE_TXST0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* TOK, TAB, SQE, LL,  TU,  JAB, EXC, CRS */
name|XE_OUTB
argument_list|(
name|XE_TXST1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* TEN, rsv, PTD, EXT, retry_counter:4    */
comment|/*    * Check for an in-progress autonegotiation.  If one is active, just set    * IFF_RUNNING and return.  The media selection code will call us again when     * it's done.    */
if|if
condition|(
name|scp
operator|->
name|autoneg_status
condition|)
block|{
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable receiver, put MAC online */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CMD0
argument_list|,
name|XE_CMD0_RX_ENABLE
operator||
name|XE_CMD0_ONLINE
argument_list|)
expr_stmt|;
comment|/* Set up IMR, enable interrupts */
name|xe_enable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Attempt to start output */
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|xe_start
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
comment|/*    * Loop while there are packets to be sent, and space to send them.    */
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Suck a packet off the send queue */
if|if
condition|(
name|mbp
operator|==
name|NULL
condition|)
block|{
comment|/*        * We are using the !OACTIVE flag to indicate to the outside world that        * we can accept an additional packet rather than that the transmitter        * is _actually_ active. Indeed, the transmitter may be active, but if        * we haven't filled all the buffers with data then we still want to        * accept more.        */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xe_pio_write_packet
argument_list|(
name|scp
argument_list|,
name|mbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Push the packet back onto the queue */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* Tap off here if there is a bpf listener */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: sending output packet to BPF\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
comment|/* In case we don't hear from the card again */
name|scp
operator|->
name|tx_queued
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  Adapted from the ed driver.  */
end_comment

begin_function
specifier|static
name|int
name|xe_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|scp
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/*      * If the interface is marked up and stopped, then start it.  If it is      * marked down and running, then stop it.      */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|xe_hard_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/*      * Multicast list has (maybe) changed; set the hardware filter      * accordingly.  This also serves to deal with promiscuous mode if we have       * a BPF listener active.      */
name|xe_setmulti
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
comment|/*      * Someone wants to get/set media options.      */
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|scp
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Card interrupt handler: should return true if the interrupt was for us, in  * case we are sharing our IRQ line with other devices (this will probably be  * the case for multifunction cards).  *  * This function is probably more complicated than it needs to be, as it  * attempts to deal with the case where multiple packets get sent between  * interrupts.  This is especially annoying when working out the collision  * stats.  Not sure whether this case ever really happens or not (maybe on a  * slow/heavily loaded machine?) so it's probably best to leave this like it  * is.  *  * Note that the crappy PIO used to get packets on and off the card means that   * you will spend a lot of time in this routine -- I can get my P150 to spend  * 90% of its time servicing interrupts if I really hammer the network.  Could   * fix this, but then you'd start dropping/losing packets.  The moral of this  * story?  If you want good network performance _and_ some cycles left over to   * get your work done, don't buy a Xircom card.  Or convince them to tell me  * how to do memory-mapped I/O :)  */
end_comment

begin_function
specifier|static
name|int
name|xe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|result
decl_stmt|;
name|u_int16_t
name|rx_bytes
decl_stmt|,
name|rxs
decl_stmt|,
name|txs
decl_stmt|;
name|u_int8_t
name|psr
decl_stmt|,
name|isr
decl_stmt|,
name|esr
decl_stmt|,
name|rsr
decl_stmt|;
name|unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|rx_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Bytes received on this interrupt */
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Set true if the interrupt is for us */
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
block|}
name|psr
operator|=
name|XE_INB
argument_list|(
name|XE_PR
argument_list|)
expr_stmt|;
comment|/* Stash the current register page */
comment|/*    * Read ISR to see what caused this interrupt.  Note that this clears the    * ISR on CE2 type cards.    */
if|if
condition|(
operator|(
name|isr
operator|=
name|XE_INB
argument_list|(
name|XE_ISR
argument_list|)
operator|)
operator|&&
name|isr
operator|!=
literal|0xff
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
comment|/* This device did generate an int */
name|esr
operator|=
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
expr_stmt|;
comment|/* Read the other status registers */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|rxs
operator|=
name|XE_INB
argument_list|(
name|XE_RST0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_RST0
argument_list|,
operator|~
name|rxs
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|txs
operator|=
name|XE_INB
argument_list|(
name|XE_TXST0
argument_list|)
expr_stmt|;
name|txs
operator||=
name|XE_INB
argument_list|(
name|XE_TXST1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXST0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXST1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"xe%d: ISR=%#2.2x ESR=%#2.2x RST=%#2.2x TXST=%#4.4x\n"
argument_list|,
name|unit
argument_list|,
name|isr
argument_list|,
name|esr
argument_list|,
name|rxs
argument_list|,
name|txs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Handle transmit interrupts      */
if|if
condition|(
name|isr
operator|&
name|XE_ISR_TX_PACKET
condition|)
block|{
name|u_int8_t
name|new_tpr
decl_stmt|,
name|sent
decl_stmt|;
if|if
condition|(
operator|(
name|new_tpr
operator|=
name|XE_INB
argument_list|(
name|XE_TPR
argument_list|)
operator|)
operator|<
name|scp
operator|->
name|tx_tpr
condition|)
comment|/* Update packet count */
name|sent
operator|=
operator|(
literal|0xff
operator|-
name|scp
operator|->
name|tx_tpr
operator|)
operator|+
name|new_tpr
expr_stmt|;
comment|/* TPR rolled over */
else|else
name|sent
operator|=
name|new_tpr
operator|-
name|scp
operator|->
name|tx_tpr
expr_stmt|;
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
block|{
comment|/* Packets sent since last interrupt */
name|scp
operator|->
name|tx_tpr
operator|=
name|new_tpr
expr_stmt|;
name|scp
operator|->
name|tx_queued
operator|-=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|scp
operator|->
name|tx_collisions
expr_stmt|;
comment|/* 	 * Collision stats are a PITA.  If multiples frames have been sent, we  	 * distribute any outstanding collision count equally amongst them. 	 * However, if we're missing interrupts we're quite likely to also 	 * miss some collisions; thus the total count will be off anyway. 	 * Likewise, if we miss a frame dropped due to excessive collisions 	 * any outstanding collisions count will be held against the next 	 * frame to be successfully sent.  Hopefully it averages out in the 	 * end! 	 * XXX - This will screw up if tx_collisions/sent> 14. FIX IT! 	 */
switch|switch
condition|(
name|scp
operator|->
name|tx_collisions
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|sent
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Distribute across multiple frames */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|+=
name|sent
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|/
name|sent
index|]
operator|+=
name|sent
operator|-
name|scp
operator|->
name|tx_collisions
operator|%
name|sent
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|/
name|sent
operator|+
literal|1
index|]
operator|+=
name|scp
operator|->
name|tx_collisions
operator|%
name|sent
expr_stmt|;
block|}
block|}
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|txs
operator|&
literal|0x0002
condition|)
block|{
comment|/* Excessive collisions (packet dropped) */
name|ifp
operator|->
name|if_collisions
operator|+=
literal|16
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_RESTART_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txs
operator|&
literal|0x0040
condition|)
comment|/* Transmit aborted -- probably collisions */
name|scp
operator|->
name|tx_collisions
operator|++
expr_stmt|;
comment|/*      * Handle receive interrupts       */
while|while
condition|(
operator|(
name|esr
operator|=
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|)
operator|&
name|XE_ESR_FULL_PACKET_RX
condition|)
block|{
if|if
condition|(
operator|(
name|rsr
operator|=
name|XE_INB
argument_list|(
name|XE_RSR
argument_list|)
operator|)
operator|&
name|XE_RSR_RX_OK
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|ehp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|len
operator|=
name|XE_INW
argument_list|(
name|XE_RBC
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* 	 * Limit the amount of time we spend in this loop, dropping packets if  	 * necessary.  The Linux code does this with considerably more 	 * finesse, adjusting the threshold dynamically. 	 */
block|if ((rx_bytes += len)> 22000) { 	  ifp->if_iqdrops++; 	  scp->mibData.dot3StatsMissedFrames++; 	  XE_OUTW(XE_DO, 0x8000); 	  continue; 	}
endif|#
directive|endif
if|if
condition|(
name|len
operator|&
literal|0x01
condition|)
name|len
operator|++
expr_stmt|;
name|MGETHDR
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* Allocate a header mbuf */
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|mbp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 	   * If the mbuf header isn't big enough for the packet, attach an 	   * mbuf cluster to hold it.  The +2 is to allow for the nasty little  	   * alignment hack below. 	   */
if|if
condition|(
name|len
operator|+
literal|2
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mbp
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
name|mbp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
comment|/* 	   * The Ethernet header is 14 bytes long; thus the actual packet data  	   * won't be 32-bit aligned when it's dumped into the mbuf.  We 	   * offset everything by 2 bytes to fix this.  Apparently the 	   * alignment is important for NFS, damn its eyes. 	   */
name|mbp
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|ehp
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	   * Now get the packet, including the Ethernet header and trailer (?) 	   * We use programmed I/O, because we don't know how to do shared 	   * memory with these cards.  So yes, it's real slow, and heavy on 	   * the interrupts (CPU on my P150 maxed out at ~950KBps incoming). 	   */
if|if
condition|(
name|scp
operator|->
name|srev
operator|==
literal|0
condition|)
block|{
comment|/* Workaround a bug in old cards */
name|u_short
name|rhs
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XE_INW
argument_list|(
name|XE_RHSA
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|+=
literal|3
expr_stmt|;
comment|/* Skip control info */
if|if
condition|(
name|rhs
operator|>=
literal|0x8000
condition|)
name|rhs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rhs
operator|+
name|len
operator|>
literal|0x8000
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	       * XXX - This i-- seems very wrong, but it's what the Linux guys  	       * XXX - do.  Need someone with an old CE2 to test this for me. 	       * XXX - 99/3/28: Changed the first i-- to an i++, maybe that'll 	       * XXX - fix it?  It seems as though the previous version would 	       * XXX - have caused an infinite loop (what, another one?). 	       */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|rhs
operator|++
control|)
block|{
operator|(
operator|(
name|char
operator|*
operator|)
name|ehp
operator|)
index|[
name|i
index|]
operator|=
name|XE_INB
argument_list|(
name|XE_EDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
literal|0x8000
condition|)
block|{
name|rhs
operator|=
literal|0
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
name|insw
argument_list|(
name|scp
operator|->
name|dev
operator|->
name|id_iobase
operator|+
name|XE_EDP
argument_list|,
name|ehp
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|insw
argument_list|(
name|scp
operator|->
name|dev
operator|->
name|id_iobase
operator|+
name|XE_EDP
argument_list|,
name|ehp
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* 	   * Check if there's a BPF listener on this interface. If so, hand 	   * off the raw packet to bpf. 	   */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: passing input packet to BPF\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/*	 	     * Note that the interface cannot be in promiscuous mode if there 	     * are no BPF listeners.  And if we are in promiscuous mode, we 	     * have to check if this packet is really ours. 	     */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|ehp
operator|->
name|ether_dhost
argument_list|,
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ehp
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|rsr
operator|&
name|XE_RSR_PHYS_PACKET
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
name|mbp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbp
operator|->
name|m_len
operator|=
name|len
operator|-
name|ETHER_HDR_LEN
expr_stmt|;
name|mbp
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* Strip off Ethernet header */
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|ehp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Send the packet on its way */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Success! */
block|}
name|XE_OUTW
argument_list|(
name|XE_DO
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* skip_rx_packet command */
block|}
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_LONG_PACKET
condition|)
block|{
comment|/* Packet length>1518 bytes */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFrameTooLongs
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_CRC_ERROR
condition|)
block|{
comment|/* Bad checksum on packet */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_ALIGN_ERROR
condition|)
block|{
comment|/* Packet alignment error */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxs
operator|&
literal|0x10
condition|)
block|{
comment|/* Receiver overrun */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_CLEAR_OVERRUN
argument_list|)
expr_stmt|;
block|}
block|}
name|XE_SELECT_PAGE
argument_list|(
name|psr
argument_list|)
expr_stmt|;
comment|/* Restore saved page */
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts */
comment|/* Could force an int here, instead of dropping packets? */
comment|/* XE_OUTB(XE_CR, XE_CR_ENABLE_INTR|XE_CE_FORCE_INTR); */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine.  Called automatically if we queue a packet   * for transmission but don't get an interrupt within a specified timeout  * (usually 5 seconds).  When this happens we assume the worst and reset the  * card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
name|printf
argument_list|(
literal|"xe%d: watchdog timeout; resetting card\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
name|scp
operator|->
name|tx_timeouts
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|scp
operator|->
name|tx_queued
expr_stmt|;
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_hard_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change media selection.  */
end_comment

begin_function
specifier|static
name|int
name|xe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: media_change\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*    * Some card/media combos aren't always possible -- filter those out here.    */
if|if
condition|(
operator|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_AUTO
operator|||
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_100_TX
operator|)
operator|&&
operator|!
name|scp
operator|->
name|phy_ok
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return current media selection.  */
end_comment

begin_function
specifier|static
name|void
name|xe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|mrp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: media_status\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mrp
operator|->
name|ifm_active
operator|=
operator|(
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|media
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Select active media.  */
end_comment

begin_function
specifier|static
name|void
name|xe_setmedia
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|xscp
decl_stmt|;
name|u_int16_t
name|bmcr
decl_stmt|,
name|bmsr
decl_stmt|,
name|anar
decl_stmt|,
name|lpar
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: setmedia\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Cancel any pending timeout */
name|untimeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|scp
operator|->
name|chand
argument_list|)
expr_stmt|;
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Select media */
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
comment|/* Autoselect media */
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
comment|/*      * Autoselection is really awful.  It goes something like this:      *      * Wait until the transmitter goes idle (2sec timeout).      * Reset card      *   IF a 100Mbit PHY exists      *     Start NWAY autonegotiation (3.5sec timeout)      *     IF that succeeds      *       Select 100baseTX or 10baseT, whichever was detected      *     ELSE      *       Reset card      *       IF a 100Mbit PHY exists      *         Try to force a 100baseTX link (3sec timeout)      *         IF that succeeds      *           Select 100baseTX      *         ELSE      *           Disable the PHY      *         ENDIF      *       ENDIF      *     ENDIF      *   ENDIF      * IF nothing selected so far      *   IF a 100Mbit PHY exists      *     Select 10baseT      *   ELSE      *     Select 10baseT or 10base2, whichever is connected      *   ENDIF      * ENDIF      */
switch|switch
condition|(
name|scp
operator|->
name|autoneg_status
condition|)
block|{
case|case
name|XE_AUTONEG_NONE
case|:
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Waiting for idle transmitter\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_WAITING
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|XE_AUTONEG_WAITING
case|:
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Starting autonegotiation\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bmcr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
name|bmcr
operator|&=
operator|~
operator|(
name|PHY_BMCR_AUTONEGENBL
operator|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|anar
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_ANAR
argument_list|)
expr_stmt|;
name|anar
operator|&=
operator|~
operator|(
name|PHY_ANAR_100BT4
operator||
name|PHY_ANAR_100BTXFULL
operator||
name|PHY_ANAR_10BTFULL
operator|)
expr_stmt|;
name|anar
operator||=
name|PHY_ANAR_100BTXHALF
operator||
name|PHY_ANAR_10BTHALF
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_ANAR
argument_list|,
name|anar
argument_list|)
expr_stmt|;
name|bmcr
operator||=
name|PHY_BMCR_AUTONEGENBL
operator||
name|PHY_BMCR_AUTONEGRSTR
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_STARTED
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|7
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
break|break;
case|case
name|XE_AUTONEG_STARTED
case|:
name|bmsr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
name|lpar
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsr
operator|&
operator|(
name|PHY_BMSR_AUTONEGCOMP
operator||
name|PHY_BMSR_LINKSTAT
operator|)
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Autonegotiation complete!\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX - Shouldn't have to do this, but (on my hub at least) the 	 * XXX - transmitter won't work after a successful autoneg.  So we see  	 * XXX - what the negotiation result was and force that mode.  I'm 	 * XXX - sure there is an easy fix for this. 	 */
if|if
condition|(
name|lpar
operator|&
name|PHY_LPAR_100BTXHALF
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * XXX - Bit of a hack going on in here. 	   * XXX - This is derived from Ken Hughes patch to the Linux driver 	   * XXX - to make it work with 10Mbit _autonegotiated_ links on CE3B 	   * XXX - cards.  What's a CE3B and how's it differ from a plain CE3? 	   * XXX - these are the things we need to find out. 	   */
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* BEGIN HACK */
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
comment|/* END HACK */
comment|/*XE_OUTB(XE_MSR, XE_INB(XE_MSR)& ~0x08);*/
comment|/* Disable PHY? */
comment|/*scp->autoneg_status = XE_AUTONEG_FAIL;*/
block|}
block|}
else|else
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Autonegotiation failed; trying 100baseTX\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_100TX
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XE_AUTONEG_100TX
case|:
operator|(
name|void
operator|)
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
name|bmsr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_LINKSTAT
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Got 100baseTX link!\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Autonegotiation failed; disabling PHY\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Disable PHY? */
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
break|break;
block|}
comment|/*      * If we got down here _and_ autoneg_status is XE_AUTONEG_FAIL, then      * either autonegotiation failed, or never got started to begin with.  In      * either case, select a suitable 10Mbit media and hope it works.  We      * don't need to reset the card again, since it will have been done      * already by the big switch above.      */
if|if
condition|(
name|scp
operator|->
name|autoneg_status
operator|==
name|XE_AUTONEG_FAIL
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Selecting 10baseX\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
literal|0x80
else|:
literal|0xc0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
operator|(
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
name|IFM_10_T
else|:
name|IFM_10_2
operator|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
block|}
break|break;
comment|/*      * If a specific media has been requested, we just reset the card and      * select it (one small exception -- if 100baseTX is requested by there is       * no PHY, we fall back to 10baseT operation).      */
case|case
name|IFM_100_TX
case|:
comment|/* Force 100baseTX */
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Selecting 100baseTX\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|IFM_10_T
case|:
comment|/* Force 10baseT */
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Selecting 10baseT\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Disable PHY */
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
name|IFM_10_2
case|:
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Selecting 10base2\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_10_2
expr_stmt|;
break|break;
block|}
comment|/*    * Finally, the LEDs are set to match whatever media was chosen and the    * transmitter is unblocked.     */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: Setting LEDs\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|media
argument_list|)
condition|)
block|{
case|case
name|IFM_100_TX
case|:
case|case
name|IFM_10_T
case|:
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3b
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dingo
condition|)
name|XE_OUTB
argument_list|(
literal|0x0b
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* 100Mbit LED */
break|break;
case|case
name|IFM_10_2
case|:
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3a
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restart output? */
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hard reset (power cycle) the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_hard_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: hard_reset\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Power cycle the card.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Power off */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* And back on again */
else|else
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Also set AIC bit, whatever that is */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Soft reset the card.  Also makes sure that the ML6692 and 10Mbit controller   * are powered up, sets the silicon revision number in softc, disables  * interrupts and checks for the prescence of a 100Mbit PHY.  This should  * leave us in a position where we can access the PHY and do media  * selection. The function imposes a 0.5s delay while the hardware powers up.  */
end_comment

begin_function
specifier|static
name|void
name|xe_soft_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: soft_reset\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Reset the card, (again).    */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
comment|/*      * set GP1 and GP2 as outputs (bits 2& 3)      * set GP1 low to power on the ML6692 (bit 0)      * set GP2 high to power on the 10Mhz chip (bit 1)      */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
block|}
comment|/*    * Wait for everything to wake up.    */
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/*    * Get silicon revision number.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x70
operator|)
operator|>>
literal|4
expr_stmt|;
else|else
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x30
operator|)
operator|>>
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: silicon revision = %d\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|scp
operator|->
name|srev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Shut off interrupts.    */
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*    * Check for PHY.    */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|scp
operator|->
name|phy_ok
operator|=
name|xe_mii_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  This is done by powering down the device, which I  * assume means just shutting down the transceiver and Ethernet logic.  This  * requires a _hard_ reset to recover from, as we need to power up again.  */
end_comment

begin_function
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: stop\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Shut off interrupts.    */
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*    * Power down.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*    * ~IFF_RUNNING == interface down.    */
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable Ethernet interrupts from the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_enable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: enable_intr\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Unmask everything */
name|XE_OUTB
argument_list|(
name|XE_IMR1
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Unmask TX underrun detection */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
operator|!
name|scp
operator|->
name|dingo
condition|)
block|{
comment|/* This bit is just magic */
if|if
condition|(
operator|!
operator|(
name|XE_INB
argument_list|(
literal|0x10
argument_list|)
operator|&
literal|0x01
operator|)
condition|)
block|{
name|XE_OUTB
argument_list|(
literal|0x10
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* Unmask master int enable bit */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Disable all Ethernet interrupts from the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_disable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: disable_intr\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
operator|!
name|scp
operator|->
name|dingo
condition|)
block|{
comment|/* More magic (does this work?) */
name|XE_OUTB
argument_list|(
literal|0x10
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Mask the master int enable bit */
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Forbid all interrupts */
name|XE_OUTB
argument_list|(
name|XE_IMR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up multicast filter and promiscuous mode  */
end_comment

begin_function
specifier|static
name|void
name|xe_setmulti
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|maddr
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
expr_stmt|;
comment|/* Get length of multicast list */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|maddr
operator|!=
name|NULL
condition|;
name|maddr
operator|=
name|maddr
operator|->
name|ifma_link
operator|.
name|le_next
operator|,
name|count
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|||
operator|(
name|count
operator|>
literal|9
operator|)
condition|)
block|{
comment|/*      * Go into promiscuous mode if either of the PROMISC or ALLMULTI flags are      * set, or if we have been asked to deal with more than 9 multicast      * addresses.  To do this: set MPE and PME in SWC1      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/*      * Program the filters for up to 9 addresses      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CMD0
argument_list|,
name|XE_CMD0_OFFLINE
argument_list|)
expr_stmt|;
comment|/*xe_reg_dump(scp);*/
name|xe_setaddrs
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*xe_reg_dump(scp);*/
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CMD0
argument_list|,
name|XE_CMD0_RX_ENABLE
operator||
name|XE_CMD0_ONLINE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*      * No multicast operation (default)      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up all on-chip addresses (for multicast).  AFAICS, there are 10  * of these things; the first is our MAC address, the other 9 are mcast  * addresses, padded with the MAC address if there aren't enough.  * XXX - This doesn't work right, but I'm not sure why yet.  We seem to be  * XXX - doing much the same as the Linux code, which is weird enough that  * XXX - it's probably right (despite my earlier comments to the contrary).  */
end_comment

begin_function
specifier|static
name|void
name|xe_setaddrs
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|u_int8_t
modifier|*
name|addr
decl_stmt|;
name|u_int8_t
name|page
decl_stmt|,
name|slot
decl_stmt|,
name|byte
decl_stmt|,
name|i
decl_stmt|;
name|maddr
operator|=
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_multiaddrs
operator|.
name|lh_first
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
operator|=
literal|0x50
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
operator|,
name|byte
operator|=
literal|8
init|;
name|slot
operator|<
literal|10
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
name|addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|maddr
operator|!=
name|NULL
operator|&&
name|maddr
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
name|maddr
operator|=
name|maddr
operator|->
name|ifma_link
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|maddr
operator|!=
name|NULL
condition|)
name|addr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|maddr
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
operator|,
name|byte
operator|++
control|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|2
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|":%x"
argument_list|,
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"xe%d: individual addresses %d: %x"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|slot
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|byte
operator|>
literal|15
condition|)
block|{
name|page
operator|++
expr_stmt|;
name|byte
operator|=
literal|8
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|byte
argument_list|,
name|addr
index|[
literal|5
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|XE_OUTB
argument_list|(
name|byte
argument_list|,
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|XE_DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an outgoing packet to the card using programmed I/O.  */
end_comment

begin_function
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbp2
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|,
name|pad
decl_stmt|,
name|free
decl_stmt|,
name|ok
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
name|u_int8_t
name|savebyte
index|[
literal|2
index|]
decl_stmt|,
name|wantbyte
decl_stmt|;
comment|/* Get total packet length */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|mbp2
operator|=
name|mbp
init|;
name|mbp2
operator|!=
name|NULL
condition|;
name|len
operator|+=
name|mbp2
operator|->
name|m_len
operator|,
name|mbp2
operator|=
name|mbp2
operator|->
name|m_next
control|)
empty_stmt|;
comment|/* Packets< minimum length may need to be padded out */
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|pad
operator|=
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|len
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
block|}
comment|/* Check transmit buffer space */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_TRS
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
operator|=
name|XE_INW
argument_list|(
name|XE_TSO
argument_list|)
expr_stmt|;
name|ok
operator|=
name|free
operator|&
literal|0x8000
expr_stmt|;
name|free
operator|&=
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|free
operator|<=
name|len
operator|+
literal|2
condition|)
return|return
literal|1
return|;
comment|/* Send packet length to card */
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*    * Write packet to card using PIO (code stolen from the ed driver)    */
name|wantbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|mbp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantbyte
condition|)
block|{
comment|/* Finish the last word */
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
comment|/* Output contiguous words */
name|outsw
argument_list|(
name|scp
operator|->
name|dev
operator|->
name|id_iobase
operator|+
name|XE_EDP
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
comment|/* Save last byte, if necessary */
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|wantbyte
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mbp
operator|=
name|mbp
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|wantbyte
condition|)
comment|/* Last byte for odd-length packets */
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
comment|/*    * For CE3 cards, just tell 'em to send -- apparently the card will pad out    * short packets with random cruft.  Otherwise, write nonsense words to fill     * out the packet.  I guess it is then sent automatically (?)    */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_TX_PACKET
operator||
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|pad
operator|>
literal|0
condition|)
block|{
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
literal|0xdead
argument_list|)
expr_stmt|;
name|pad
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The device entry is being removed, probably because someone ejected the  * card.  The interface should have been brought down manually before calling  * this function; if not you may well lose packets.  In any case, I shut down  * the card and the interface, and hope for the best.  The 'gone' flag is set,   * so hopefully no-one else will try to access the missing card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_card_unload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: already unloaded\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the 32-bit Ethernet CRC for the given buffer.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|xe_compute_crc
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int32_t
name|crc
init|=
literal|0xffffffff
decl_stmt|;
name|u_int32_t
name|poly
init|=
literal|0x04c11db6
decl_stmt|;
name|u_int8_t
name|current
decl_stmt|,
name|crc31
decl_stmt|,
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|current
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
literal|8
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|crc
operator|&
literal|0x80000000
condition|)
block|{
name|crc31
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
name|crc31
operator|=
literal|0
expr_stmt|;
block|}
name|bit
operator|=
name|crc31
operator|^
operator|(
name|current
operator|&
literal|0x01
operator|)
expr_stmt|;
name|crc
operator|<<=
literal|1
expr_stmt|;
name|current
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bit
condition|)
block|{
name|crc
operator|=
operator|(
name|crc
operator|^
name|poly
operator|)
operator||
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a CRC into an index into the multicast hash table.  What we do is  * take the most-significant 6 bits of the CRC, reverse them, and use that as  * the bit number in the hash table.  Bits 5:3 of the result give the byte  * within the table (0-7); bits 2:0 give the bit number within that byte (also   * 0-7), ie. the number of shifts needed to get it into the lsb position.  */
end_comment

begin_function
specifier|static
name|int
name|xe_compute_hashbit
parameter_list|(
name|u_int32_t
name|crc
parameter_list|)
block|{
name|u_int8_t
name|hashbit
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|hashbit
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|crc
operator|&
literal|0x80000000
condition|)
block|{
name|hashbit
operator|&=
literal|0x80
expr_stmt|;
block|}
name|crc
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|hashbit
operator|>>
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  *                                                            *  *                  M I I  F U N C T I O N S                  *  *                                                            *  **************************************************************/
end_comment

begin_comment
comment|/*  * Alternative MII/PHY handling code adapted from the xl driver.  It doesn't  * seem to work any better than the xirc2_ps stuff, but it's cleaner code.  * XXX - this stuff shouldn't be here.  It should all be abstracted off to  * XXX - some kind of common MII-handling code, shared by all drivers.  But  * XXX - that's a whole other mission.  */
end_comment

begin_define
define|#
directive|define
name|XE_MII_SET
parameter_list|(
name|x
parameter_list|)
value|XE_OUTB(XE_GPR2, (XE_INB(XE_GPR2) | 0x04) | (x))
end_define

begin_define
define|#
directive|define
name|XE_MII_CLR
parameter_list|(
name|x
parameter_list|)
value|XE_OUTB(XE_GPR2, (XE_INB(XE_GPR2) | 0x04)& ~(x))
end_define

begin_comment
comment|/*  * Sync the PHYs by setting data bit and strobing the clock 32 times.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_sync
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
operator||
name|XE_MII_WRD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look for a MII-compliant PHY.  If we find one, reset it.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|u_int16_t
name|status
decl_stmt|;
name|status
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x7800
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: no PHY found, %0x\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
else|else
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"xe%d: PHY OK!\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset the PHY */
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
while|while
condition|(
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|)
operator|&
name|PHY_BMCR_RESET
condition|)
empty_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clock a series of bits through the MII.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_send
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int32_t
name|bits
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|0x1
operator|<<
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|)
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|bits
operator|&
name|i
condition|)
block|{
name|XE_MII_SET
argument_list|(
name|XE_MII_WRD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_WRD
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read an PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ack
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Set up frame for RX.    */
name|frame
operator|->
name|mii_stdelim
operator|=
name|XE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|XE_MII_READOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|mii_data
operator|=
literal|0
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Turn on data xmit.    */
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|xe_mii_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*	    * Send command/address info.    */
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Idle bit */
name|XE_MII_CLR
argument_list|(
operator|(
name|XE_MII_CLK
operator||
name|XE_MII_WRD
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn off xmit. */
name|XE_MII_CLR
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
comment|/* Check for ack */
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ack
operator|=
name|XE_INB
argument_list|(
name|XE_GPR2
argument_list|)
operator|&
name|XE_MII_RDD
expr_stmt|;
comment|/*    * Now try reading data bits. If the ack failed, we still    * need to clock through 16 cycles to keep the PHY(s) in sync.    */
if|if
condition|(
name|ack
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0x8000
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ack
condition|)
block|{
if|if
condition|(
name|XE_INB
argument_list|(
name|XE_GPR2
argument_list|)
operator|&
name|XE_MII_RDD
condition|)
name|frame
operator|->
name|mii_data
operator||=
name|i
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fail
label|:
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Set up frame for TX.    */
name|frame
operator|->
name|mii_stdelim
operator|=
name|XE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|XE_MII_WRITEOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
name|XE_MII_TURNAROUND
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*		    * Turn on data output.    */
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|xe_mii_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_turnaround
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Idle bit. */
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*    * Turn off xmit.    */
name|XE_MII_CLR
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a register from the PHY.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|xe_phy_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
block|{
name|struct
name|xe_mii_frame
name|frame
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|xe_mii_readreg
argument_list|(
name|scp
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|frame
operator|.
name|mii_data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a PHY register.  */
end_comment

begin_function
specifier|static
name|void
name|xe_phy_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|struct
name|xe_mii_frame
name|frame
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|frame
operator|.
name|mii_data
operator|=
name|data
expr_stmt|;
name|xe_mii_writereg
argument_list|(
name|scp
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_comment
comment|/*  * A bit of debugging code.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"xe%d: MII registers: "
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d:%04x"
argument_list|,
name|i
argument_list|,
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d:%04x"
argument_list|,
name|i
argument_list|,
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xe_reg_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|page
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"xe%d: Common registers: "
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<=
literal|8
condition|;
name|page
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"xe%d: Register page %2.2x: "
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|page
operator|=
literal|0x10
init|;
name|page
operator|<
literal|0x5f
condition|;
name|page
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|page
operator|>=
literal|0x11
operator|&&
name|page
operator|<=
literal|0x3f
operator|)
operator|||
operator|(
name|page
operator|==
literal|0x41
operator|)
operator|||
operator|(
name|page
operator|>=
literal|0x43
operator|&&
name|page
operator|<=
literal|0x4f
operator|)
operator|||
operator|(
name|page
operator|>=
literal|0x59
operator|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"xe%d: Register page %2.2x: "
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_comment
comment|/**************************************************************  *                                                            *  *                  A P M  F U N C T I O N S                  *  *                                                            *  **************************************************************/
end_comment

begin_comment
comment|/*  * This is called when we go into suspend/standby mode  */
end_comment

begin_function
specifier|static
name|int
name|xe_suspend
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|sca
index|[
operator|(
name|int
operator|)
name|xunit
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"xe%d: APM suspend\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when we wake up again  */
end_comment

begin_function
specifier|static
name|int
name|xe_resume
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|sca
index|[
operator|(
name|int
operator|)
name|xunit
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"xe%d: APM resume\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD> 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NXE> 0 */
end_comment

end_unit

