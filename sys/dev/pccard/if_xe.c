begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Scott Mitchell  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: if_xe.c,v 1.13 1999/01/24 22:14:54 root Exp $  */
end_comment

begin_comment
comment|/*  * Portions of this software were derived from Werner Koch's xirc2ps driver  * for Linux under the terms of the following license (from v1.30 of the  * xirc2ps driver):  *  * Copyright (c) 1997 by Werner Koch (dd9jn)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		  * FreeBSD device driver for Xircom CreditCard PCMCIA Ethernet adapters.  * The following cards and media are supported (Ethernet part only on the  * multifunction CEM cards):  *   CE2	10BASE-2, 10BASE-T (I think)  *   CEM28	ditto  *   CEM33	ditto  *   CE3	10BASE-T, 100BASE-TX  *   CEM56	ditto  * Certain Intel and Compaq branded cards are also rumoured to work.  *  *<Acknowledgements>  *  *<Contact details>  */
end_comment

begin_define
define|#
directive|define
name|XE_DEBUG
value|1
end_define

begin_include
include|#
directive|include
file|"xe.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NXE
operator|>
literal|0
end_if

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER> 0 */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_xereg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|xe_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|pccard_devinfo
modifier|*
name|crd
decl_stmt|;
name|struct
name|ifmib_iso_8802_3
name|mibdata
decl_stmt|;
if|#
directive|if
name|NAPM
operator|>
literal|0
name|struct
name|apmhook
name|suspend_hook
decl_stmt|;
name|struct
name|apmhook
name|resume_hook
decl_stmt|;
endif|#
directive|endif
comment|/* NAPM> 0 */
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name */
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer */
name|int
name|srev
decl_stmt|;
comment|/* Silicon revision */
name|int
name|modem
decl_stmt|;
comment|/* 1 = Multifunction card with modem */
name|int
name|ce3
decl_stmt|;
comment|/* 1 = CE3 class (100Mbit) adapter */
name|int
name|cem56
decl_stmt|;
comment|/* 1 = CEM56 class (CE3 + 56Kbps modem) adapter */
name|int
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out */
name|int
name|tx_queued
decl_stmt|;
comment|/* Packets currently waiting to transmit */
name|int
name|tx_ptr
decl_stmt|;
comment|/* Last value of PTR reg on card */
name|int
name|tx_collisions
decl_stmt|;
comment|/* Collisions since last successful send */
name|int
name|tx_timeouts
decl_stmt|;
comment|/* Count of transmit timeouts */
name|int
name|probe
decl_stmt|;
comment|/* XXX  0 = use value in port, 1 = look for a port */
name|int
name|port
decl_stmt|;
comment|/* XXX  0 = Unknown, 1 = 10Base2, 2 = 10BaseT, 4 = 100BaseTX */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|xe_softc
modifier|*
name|sca
index|[
name|MAXSLOT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For accessing card registers  */
end_comment

begin_define
define|#
directive|define
name|XE_INB
parameter_list|(
name|r
parameter_list|)
value|inb(scp->dev->id_iobase+(r))
end_define

begin_define
define|#
directive|define
name|XE_INW
parameter_list|(
name|r
parameter_list|)
value|inw(scp->dev->id_iobase+(r))
end_define

begin_define
define|#
directive|define
name|XE_OUTB
parameter_list|(
name|r
parameter_list|,
name|b
parameter_list|)
value|outb(scp->dev->id_iobase+(r), (b))
end_define

begin_define
define|#
directive|define
name|XE_OUTW
parameter_list|(
name|r
parameter_list|,
name|w
parameter_list|)
value|outw(scp->dev->id_iobase+(r), (w))
end_define

begin_define
define|#
directive|define
name|XE_SELECT_PAGE
parameter_list|(
name|p
parameter_list|)
value|XE_OUTB(XE_PSR, (p))
end_define

begin_comment
comment|/*  * PC-Card driver routines  */
end_comment

begin_function_decl
specifier|static
name|int
name|xe_card_init
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_card_unload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * isa_driver member functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|xe_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ifnet member functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Other random functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_setmulti
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_setaddrs
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|xe_reg_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Media selection functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|xe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifm
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * MII (Medium Independent Interface) functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_mii_clock
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|xe_mii_getbit
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_putbit
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_putbits
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|xe_mii_read
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int8_t
name|phy
parameter_list|,
name|u_int8_t
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_write
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int8_t
name|phy
parameter_list|,
name|u_int8_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_comment
comment|/*  * APM hook functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|xe_suspend
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_resume
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_comment
comment|/*  * PCMCIA driver hooks  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pccard_device
name|xe_info
init|=
block|{
literal|"xe"
block|,
name|xe_card_init
block|,
name|xe_card_unload
block|,
name|xe_card_intr
block|,
literal|0
block|,
operator|&
name|net_imask
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pccarddrv_set
argument_list|,
name|xe_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ISA driver hooks  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|xedriver
init|=
block|{
name|xe_probe
block|,
name|xe_attach
block|,
literal|"xe"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All of the supported devices are PCMCIA cards.  I have no idea if it's even   * possible to successfully probe/attach these at boot time (pccardd normally  * does a lot of setup work) so I don't even bother trying.  */
end_comment

begin_function
specifier|static
name|int
name|xe_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|bzero
argument_list|(
name|sca
argument_list|,
name|MAXSLOT
operator|*
sizeof|sizeof
argument_list|(
name|sca
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a device (called when xe_card_init succeeds).  Assume that the probe  * routine has set up the softc structure correctly and that we can trust the  * unit number.  */
end_comment

begin_function
specifier|static
name|int
name|xe_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
operator|(
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
operator|)
expr_stmt|;
comment|/*    * Power down the interface    */
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*    * Initialise the ifnet structure    */
if|if
condition|(
operator|!
name|ifp
operator|->
name|if_name
condition|)
block|{
name|ifp
operator|->
name|if_softc
operator|=
name|scp
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"xe"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|scp
operator|->
name|mibdata
expr_stmt|;
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
name|scp
operator|->
name|mibdata
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|xe_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|xe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|xe_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|xe_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/*    * If BPF is in the kernel, call the attach for it    */
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Print some useful information    */
name|printf
argument_list|(
literal|"\nxe%d: %s %s%s%s\n"
argument_list|,
name|unit
argument_list|,
name|scp
operator|->
name|vendor
argument_list|,
name|scp
operator|->
name|card_type
argument_list|,
name|scp
operator|->
name|ce3
condition|?
literal|", 100Mbps capable"
else|:
literal|""
argument_list|,
name|scp
operator|->
name|cem56
condition|?
literal|", with modem"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xe%d: Ethernet address %02x"
argument_list|,
name|unit
argument_list|,
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|":%02x"
argument_list|,
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt service routine.  This shouldn't ever get called, but if it does  * we just call the card interrupt handler with the appropriate arguments.  */
end_comment

begin_function
name|void
name|xeintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|xe_card_intr
argument_list|(
name|sca
index|[
name|unit
index|]
operator|->
name|crd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.  Except for the media selection stuff this is pretty  * much verbatim from the Linux code.  */
end_comment

begin_function
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|scp
operator|=
name|xscp
expr_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|unit
operator|=
name|scp
operator|->
name|crd
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Reset transmitter flags    */
name|scp
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_ptr
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/*    * Hard, then soft, reset the card.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Power off */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|ce3
condition|)
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* And back on again */
else|else
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Also set AIC bit, whatever that is */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* Software reset */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|ce3
condition|)
block|{
comment|/*      * set GP1 and GP2 as outputs (bits 2& 3)      * set GP1 low to power on the ML6692 (bit 0)      * set GP2 high to power on the 10Mhz chip (bit 1)      */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
block|}
comment|/*    * Wait for everything to wake up.    */
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/*    * Get silicon revision number    */
if|if
condition|(
name|scp
operator|->
name|ce3
condition|)
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x70
operator|)
operator|>>
literal|4
expr_stmt|;
else|else
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x30
operator|)
operator|>>
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: silicon revision %d\n"
argument_list|,
name|unit
argument_list|,
name|scp
operator|->
name|srev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
if|if
condition|(
name|scp
operator|->
name|probe
condition|)
block|{
if|if
condition|(
operator|!
name|scp
operator|->
name|ce3
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|scp
operator|->
name|probe
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|port
operator|==
literal|2
condition|)
block|{
comment|/* select 10BaseT */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: selecting 10BaseT\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|port
operator|==
literal|1
condition|)
block|{
comment|/* select 10Base2 */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: selecting 10Base2\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
comment|/*    * Setup the ECR    */
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Allow all interrupts */
name|XE_OUTB
argument_list|(
name|XE_IMR1
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Enable Tx underrun detection */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC0
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Disable source insertion (WTF is that?) */
comment|/*    * Set the 'local memory dividing line' -- splits the 32K card memory into    * 8K for transmit buffers and 24K for receive.  This is done automatically    * on newer revision cards.    */
if|if
condition|(
name|scp
operator|->
name|srev
operator|!=
literal|1
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_RBS
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
block|}
comment|/*    * Set up multicast addresses    */
name|xe_setmulti
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*    * Fix the data offset register -- reset leaves it off-by-one    */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_DOR
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
comment|/*    * Set MAC interrupt masks and clear status regs.  The bit names are direct    * from the Linux code; I have no idea what most of them do.    */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Bit 7..0 */
name|XE_OUTB
argument_list|(
name|XE_RXM0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* ROK, RAB, rsv, RO,  CRC, AE,  PTL, MP  */
name|XE_OUTB
argument_list|(
name|XE_TXM0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* TOK, TAB, SQE, LL,  TU,  JAB, EXC, CRS */
name|XE_OUTB
argument_list|(
name|XE_TXM1
argument_list|,
literal|0xb0
argument_list|)
expr_stmt|;
comment|/* rsv, rsv, PTD, EXT, rsv, rsv, rsv, rsv */
name|XE_OUTB
argument_list|(
name|XE_RXS0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* ROK, RAB, REN, RO,  CRC, AE,  PTL, MP  */
name|XE_OUTB
argument_list|(
name|XE_TXS0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* TOK, TAB, SQE, LL,  TU,  JAB, EXC, CRS */
name|XE_OUTB
argument_list|(
name|XE_TXS1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* TEN, rsv, PTD, EXT, retry_counter:4    */
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
if|if
condition|(
name|scp
operator|->
name|ce3
operator|&&
name|xe_mii_init
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|u_char
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: found an MII\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|scp
operator|->
name|port
operator|==
literal|4
operator|)
operator|||
name|scp
operator|->
name|cem56
condition|)
block|{
comment|/* use MII */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: using MII\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x08
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|port
operator|==
literal|2
condition|)
block|{
comment|/* enable 10BaseT */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: selecting 10BaseT\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* enable 10Base2 */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: selecting 10Base2\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|port
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
comment|/*    * Configure the LEDs    */
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|port
operator|>
literal|1
condition|)
block|{
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3b
argument_list|)
expr_stmt|;
comment|/* For TP: link and activity */
block|}
else|else
block|{
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3a
argument_list|)
expr_stmt|;
comment|/* For BNC: !collision and activity */
block|}
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
comment|/***** XXX XXX XXX XXX *****/
comment|/*    * Enable receiver, put MAC online    */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_OCR
argument_list|,
name|XE_OCR_RX_ENABLE
operator||
name|XE_OCR_ONLINE
argument_list|)
expr_stmt|;
comment|/*    * Set up IMR, enable interrupts    */
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable everything */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
operator|!
name|scp
operator|->
name|cem56
condition|)
block|{
comment|/* This bit is just magic */
if|if
condition|(
operator|!
operator|(
name|XE_INB
argument_list|(
literal|0x10
argument_list|)
operator|&
literal|0x01
operator|)
condition|)
block|{
name|XE_OUTB
argument_list|(
literal|0x10
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* Unmask master int enable bit */
block|}
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Attempt to start output    */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|xe_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|scp
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|unit
operator|=
name|scp
operator|->
name|crd
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
comment|/*    * Loop while there are packets to be sent, and space to send them.    */
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Suck a packet off the send queue */
if|if
condition|(
name|mbp
operator|==
name|NULL
condition|)
block|{
comment|/*        * We are using the !OACTIVE flag to indicate to the outside world that        * we can accept an additional packet rather than that the transmitter        * is _actually_ active. Indeed, the transmitter may be active, but if        * we haven't filled all the buffers with data then we still want to        * accept more.        */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xe_pio_write_packet
argument_list|(
name|scp
argument_list|,
name|mbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Push the packet back onto the queue */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/*	      * Tap off here if there is a bpf listener.      */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
comment|/* In case we don't hear from the card again */
name|scp
operator|->
name|tx_queued
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  Adapted from the ed driver.  */
end_comment

begin_function
specifier|static
name|int
name|xe_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|scp
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
block|{
name|scp
operator|->
name|port
operator|=
literal|4
expr_stmt|;
comment|/* 100BASE-TX */
name|scp
operator|->
name|probe
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK1
condition|)
block|{
name|scp
operator|->
name|port
operator|=
literal|2
expr_stmt|;
comment|/* 10BASE-T */
name|scp
operator|->
name|probe
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
condition|)
block|{
name|scp
operator|->
name|port
operator|=
literal|1
expr_stmt|;
comment|/* 10BASE-2 */
name|scp
operator|->
name|probe
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|port
operator|=
literal|0
expr_stmt|;
comment|/* Unknown */
name|scp
operator|->
name|probe
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * If the interface is marked up and stopped, then start it.  If it is      * marked down and running, then stop it.      */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/*      * Multicast list has (maybe) changed; set the hardware filter      * accordingly.  This also serves to deal with promiscuous mode if we have       * a BPF listener active.      */
name|xe_setmulti
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine.  Called automatically if we queue a packet   * for transmission but don't get an interrupt within a specified timeout  * (usually 5 seconds).  When this happens we assume the worst and reset the  * card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|scp
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|unit
operator|=
name|scp
operator|->
name|crd
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
name|printf
argument_list|(
literal|"xe%d: transmit timeout; resetting card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|scp
operator|->
name|tx_timeouts
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|scp
operator|->
name|tx_queued
expr_stmt|;
name|xe_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  This is done by powering down the device, which I  * assume means just shutting down the transceiver and Ethernet logic.  There  * is probably a more elegant method that doesn't require a full reset to  * recover from.  */
end_comment

begin_function
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Forbid all interrupts */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Power down (clear bit 0) */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware.  Power-down the card then re-initialise it.  The  * xe_stop() is redundant if xe_init() also does one, but it can't hurt.  */
end_comment

begin_function
specifier|static
name|void
name|xe_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up multicast filter and promiscuous mode  */
end_comment

begin_function
specifier|static
name|void
name|xe_setmulti
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|maddr
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
expr_stmt|;
comment|/* Get length of multicast list */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|maddr
operator|!=
name|NULL
condition|;
name|maddr
operator|=
name|maddr
operator|->
name|ifma_link
operator|.
name|le_next
operator|,
name|count
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|||
operator|(
name|count
operator|>
literal|9
operator|)
condition|)
block|{
comment|/*      * Go into promiscuous mode if either of the PROMISC or ALLMULTI flags are      * set, or if we have been asked to deal with more than 9 multicast      * addresses.  To do this: set MPE and PME in SWC1      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/*      * Program the filters for up to 9 addresses      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_OCR
argument_list|,
name|XE_OCR_OFFLINE
argument_list|)
expr_stmt|;
name|xe_setaddrs
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_OCR
argument_list|,
name|XE_OCR_RX_ENABLE
operator||
name|XE_OCR_ONLINE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*      * No multicast operation (default)      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up all on-chip addresses (for multicast).  AFAICS, there are 10  * of these things; the first is our MAC address, the other 9 are mcast  * addresses, padded with the MAC address if there aren't enough.  * XXX - I think the Linux code gets this wrong and only writes one byte for  * XXX - each address.  I *think* this code does it right, but it needs more  * XXX - intensive testing to be sure.  */
end_comment

begin_function
specifier|static
name|void
name|xe_setaddrs
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|u_int8_t
modifier|*
name|addr
decl_stmt|;
name|u_int8_t
name|page
decl_stmt|,
name|slot
decl_stmt|,
name|byte
decl_stmt|,
name|i
decl_stmt|;
name|maddr
operator|=
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_multiaddrs
operator|.
name|lh_first
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
operator|=
literal|0x50
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
operator|,
name|byte
operator|=
literal|8
init|;
name|slot
operator|<
literal|10
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
name|addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|maddr
operator|!=
name|NULL
operator|&&
name|maddr
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
name|maddr
operator|=
name|maddr
operator|->
name|ifma_link
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|maddr
operator|!=
name|NULL
condition|)
name|addr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|maddr
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
operator|,
name|byte
operator|++
control|)
block|{
if|if
condition|(
name|byte
operator|>
literal|15
condition|)
block|{
name|page
operator|++
expr_stmt|;
name|byte
operator|=
literal|8
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|ce3
condition|)
name|XE_OUTB
argument_list|(
name|byte
argument_list|,
name|addr
index|[
literal|5
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|XE_OUTB
argument_list|(
name|byte
argument_list|,
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an outgoing packet to the card using programmed I/O.  */
end_comment

begin_function
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbp2
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|,
name|pad
decl_stmt|,
name|free
decl_stmt|,
name|ok
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
name|u_int8_t
name|savebyte
index|[
literal|2
index|]
decl_stmt|,
name|wantbyte
decl_stmt|;
comment|/* Get total packet length */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|mbp2
operator|=
name|mbp
init|;
name|mbp2
operator|!=
name|NULL
condition|;
name|len
operator|+=
name|mbp2
operator|->
name|m_len
operator|,
name|mbp2
operator|=
name|mbp2
operator|->
name|m_next
control|)
empty_stmt|;
comment|/* Packets< minimum length may need to be padded out */
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|pad
operator|=
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|len
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
block|}
comment|/* Check transmit buffer space */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_TRS
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
operator|=
name|XE_INW
argument_list|(
name|XE_TSO
argument_list|)
expr_stmt|;
name|ok
operator|=
name|free
operator|&
literal|0x8000
expr_stmt|;
name|free
operator|&=
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|free
operator|<=
name|len
operator|+
literal|2
condition|)
return|return
literal|1
return|;
comment|/* Send packet length to card */
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*    * Write packet to card using PIO (code stolen from the ed driver)    */
name|wantbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|mbp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantbyte
condition|)
block|{
comment|/* Finish the last word */
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
comment|/* Output contiguous words */
name|outsw
argument_list|(
name|scp
operator|->
name|dev
operator|->
name|id_iobase
operator|+
name|XE_EDP
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
comment|/* Save last byte, if necessary */
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|wantbyte
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mbp
operator|=
name|mbp
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|wantbyte
condition|)
comment|/* Last byte for odd-length packets */
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
comment|/*    * For CE3 cards, just tell 'em to send -- apparently the card will pad out    * short packets with random cruft.  Otherwise, write nonsense words to fill     * out the packet.  I guess it is then sent automatically (?)    */
if|if
condition|(
name|scp
operator|->
name|ce3
condition|)
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_TX_PACKET
operator||
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|pad
operator|>
literal|0
condition|)
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
literal|0xfeed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  *                                                            *  *                  M I I  F U N C T I O N S                  *  *                                                            *  **************************************************************/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Alternative MII/PHY handling code adapted from the xl driver.  It doesn't  * seem to work any better than the xirc2_ps stuff, but it's cleaner code.  * Will probably use this if I can ever get the autoneg to work right :(  */
end_comment

begin_comment
unit|struct xe_mii_frame { 	u_int8_t		mii_stdelim; 	u_int8_t		mii_opcode; 	u_int8_t		mii_phyaddr; 	u_int8_t		mii_regaddr; 	u_int8_t		mii_turnaround; 	u_int16_t		mii_data; };
comment|/*  * Sync the PHYs by setting data bit and strobing the clock 32 times.  */
end_comment

begin_comment
unit|static void xe_mii_sync(struct xe_softc *scp) {   register int i;    XE_SELECT_PAGE(2);   XE_MII_SET(XE_MII_DIR|XE_MII_WRD);    for (i = 0; i< 32; i++) {     XE_MII_SET(XE_MII_CLK);     DELAY(1);     XE_MII_CLR(XE_MII_CLK);     DELAY(1);   } }
comment|/*  * Clock a series of bits through the MII.  */
end_comment

begin_comment
unit|static void xe_mii_send(struct xe_softc *scp, u_int32_t bits, int cnt) {   int i;    XE_SELECT_PAGE(2);   XE_MII_CLR(XE_MII_CLK);      for (i = (0x1<< (cnt - 1)); i; i>>= 1) {     if (bits& i) {       XE_MII_SET(XE_MII_WRD);     } else {       XE_MII_CLR(XE_MII_WRD);     }     DELAY(1);     XE_MII_CLR(XE_MII_CLK);     DELAY(1);     XE_MII_SET(XE_MII_CLK);   } }
comment|/*  * Read an PHY register through the MII.  */
end_comment

begin_comment
unit|static int xe_mii_readreg(struct xe_softc *scp, struct xe_mii_frame *frame) {   int i, ack, s;    s = splimp();
comment|/*    * Set up frame for RX.    */
end_comment

begin_comment
unit|frame->mii_stdelim = XE_MII_STARTDELIM;   frame->mii_opcode = XE_MII_READOP;   frame->mii_turnaround = 0;   frame->mii_data = 0; 	   XE_SELECT_PAGE(2);   XE_OUTB(XE_GPR2, 0);
comment|/*    * Turn on data xmit.    */
end_comment

begin_comment
unit|XE_MII_SET(XE_MII_DIR);    xe_mii_sync(scp);
comment|/*	    * Send command/address info.    */
end_comment

begin_comment
unit|xe_mii_send(scp, frame->mii_stdelim, 2);   xe_mii_send(scp, frame->mii_opcode, 2);   xe_mii_send(scp, frame->mii_phyaddr, 5);   xe_mii_send(scp, frame->mii_regaddr, 5);
comment|/* Idle bit */
end_comment

begin_comment
unit|XE_MII_CLR((XE_MII_CLK|XE_MII_WRD));   DELAY(1);   XE_MII_SET(XE_MII_CLK);   DELAY(1);
comment|/* Turn off xmit. */
end_comment

begin_comment
unit|XE_MII_CLR(XE_MII_DIR);
comment|/* Check for ack */
end_comment

begin_comment
unit|XE_MII_CLR(XE_MII_CLK);   DELAY(1);   XE_MII_SET(XE_MII_CLK);   DELAY(1);   ack = XE_INB(XE_GPR2)& XE_MII_RDD;
comment|/*    * Now try reading data bits. If the ack failed, we still    * need to clock through 16 cycles to keep the PHY(s) in sync.    */
end_comment

begin_comment
unit|if (ack) {     for(i = 0; i< 16; i++) {       XE_MII_CLR(XE_MII_CLK);       DELAY(1);       XE_MII_SET(XE_MII_CLK);       DELAY(1);     }     goto fail;   }    for (i = 0x8000; i; i>>= 1) {     XE_MII_CLR(XE_MII_CLK);     DELAY(1);     if (!ack) {       if (XE_INB(XE_GPR2)& XE_MII_RDD) 	frame->mii_data |= i;       DELAY(1);     }     XE_MII_SET(XE_MII_CLK);     DELAY(1);   }  fail:    XE_MII_CLR(XE_MII_CLK);   DELAY(1);   XE_MII_SET(XE_MII_CLK);   DELAY(1);    splx(s);    if (ack)     return(1);   return(0); }
comment|/*  * Write to a PHY register through the MII.  */
end_comment

begin_comment
unit|static int xe_mii_writereg(struct xe_softc *scp, struct xe_mii_frame *frame) {   int s;    s = splimp();
comment|/*    * Set up frame for TX.    */
end_comment

begin_comment
unit|frame->mii_stdelim = XE_MII_STARTDELIM;   frame->mii_opcode = XE_MII_WRITEOP;   frame->mii_turnaround = XE_MII_TURNAROUND; 	   XE_SELECT_PAGE(2);
comment|/*		    * Turn on data output.    */
end_comment

begin_comment
unit|XE_MII_SET(XE_MII_DIR);    xe_mii_sync(scp);    xe_mii_send(scp, frame->mii_stdelim, 2);   xe_mii_send(scp, frame->mii_opcode, 2);   xe_mii_send(scp, frame->mii_phyaddr, 5);   xe_mii_send(scp, frame->mii_regaddr, 5);   xe_mii_send(scp, frame->mii_turnaround, 2);   xe_mii_send(scp, frame->mii_data, 16);
comment|/* Idle bit. */
end_comment

begin_comment
unit|XE_MII_SET(XE_MII_CLK);   DELAY(1);   XE_MII_CLR(XE_MII_CLK);   DELAY(1);
comment|/*    * Turn off xmit.    */
end_comment

begin_comment
unit|XE_MII_CLR(XE_MII_DIR);    splx(s);    return(0); }  static u_int16_t xe_phy_readreg(struct xe_softc *scp, u_int16_t reg) {   struct xe_mii_frame frame;    bzero((char *)&frame, sizeof(frame));    frame.mii_phyaddr = 0;   frame.mii_regaddr = reg;   xe_mii_readreg(scp,&frame);    return(frame.mii_data); }  static void xe_phy_writereg(struct xe_softc *scp, u_int16_t reg, u_int16_t data) {   struct xe_mii_frame frame;    bzero((char *)&frame, sizeof(frame));    frame.mii_phyaddr = 0;   frame.mii_regaddr = reg;   frame.mii_data = data;   xe_mii_writereg(scp,&frame);    return; }
comment|/*  * Initiate an autonegotiation session.  */
end_comment

begin_comment
unit|static void xe_autoneg_xmit(struct xe_softc *scp) {   u_int16_t phy_sts;    xe_phy_writereg(scp, PHY_BMCR, PHY_BMCR_RESET);   DELAY(500);   while(xe_phy_readreg(scp, PHY_BMCR)& PHY_BMCR_RESET);    phy_sts = xe_phy_readreg(scp, PHY_BMCR);   phy_sts&= ~PHY_BMCR_AUTONEGENBL;   xe_phy_writereg(scp, PHY_BMCR, phy_sts);   DELAY(1000);   phy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;   phy_sts&= ~PHY_BMCR_ISOLATE;   xe_phy_writereg(scp, PHY_BMCR, phy_sts);   DELAY(1000);    return; }
comment|/*  * Invoke autonegotiation on a PHY. Also used with the 3Com internal  * autoneg logic which is mapped onto the MII.  */
end_comment

begin_comment
unit|static void xe_autoneg_mii(struct xe_softc *scp) {   u_int16_t phy_sts = 0, media, advert, ability;   int unit = scp->dev->id_unit;   int i;
comment|/*    * First, see if autoneg is supported. If not, there's    * no point in continuing.    */
end_comment

begin_comment
unit|phy_sts = xe_phy_readreg(scp, PHY_BMSR);   if (!(phy_sts& PHY_BMSR_CANAUTONEG)) {     printf("xe%d: autonegotiation not supported\n", unit);     media = xe_phy_readreg(scp, PHY_BMCR);     media&= ~PHY_BMCR_SPEEDSEL;     media&= ~PHY_BMCR_DUPLEX;     xe_phy_writereg(scp, PHY_BMCR, media);     return;   }    xe_autoneg_xmit(scp);   DELAY(5000000);    if (xe_phy_readreg(scp, PHY_BMSR)& PHY_BMSR_AUTONEGCOMP) {     printf("xe%d: autoneg complete, ", unit);     phy_sts = xe_phy_readreg(scp, PHY_BMSR);   } else {     printf("xe%d: autoneg not complete, ", unit);   }    media = xe_phy_readreg(scp, PHY_BMCR);
comment|/* Link is good. Report modes and set duplex mode. */
end_comment

begin_endif
unit|if (xe_phy_readreg(scp, PHY_BMSR)& PHY_BMSR_LINKSTAT) {     printf("link status good ");     advert = xe_phy_readreg(scp, XL_PHY_ANAR);     ability = xe_phy_readreg(scp, XL_PHY_LPAR);      if (advert& PHY_ANAR_100BT4&& ability& PHY_ANAR_100BT4) {       printf("(100baseT4)\n");     } else if (advert& PHY_ANAR_100BTXFULL&& ability& PHY_ANAR_100BTXFULL) {       printf("(full-duplex, 100Mbps)\n");     } else if (advert& PHY_ANAR_100BTXHALF&& ability& PHY_ANAR_100BTXHALF) {       printf("(half-duplex, 100Mbps)\n");     } else if (advert& PHY_ANAR_10BTFULL&& ability& PHY_ANAR_10BTFULL) {       printf("(full-duplex, 10Mbps)\n");     } else if (advert& PHY_ANAR_10BTHALF&& ability& PHY_ANAR_10BTHALF) {       printf("(half-duplex, 10Mbps)\n");     }   } else {     printf("no carrier (forcing half-duplex, 10Mbps)\n");     xe_phy_writereg(scp, PHY_BMCR, 0x0000);   } }  static void xe_mii_new_dump(struct xe_softc *scp) {   int i, unit = scp->dev->id_unit;    for (i = 0; i< 2; i++) {     printf(" %d:%04x", i, xe_phy_readreg(scp, i));   }   for (i = 4; i< 7; i++) {     printf(" %d:%04x", i, xe_phy_readreg(scp, i));   }   printf("\n"); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/*  * Original MII/PHY code from xirc2_ps driver.  Seems like it should work,  * according to the ML6692 and DP83840A specs, but the autonegotiation never  * completes, even on the 10/100 net at work.  It's very weird.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_clock
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* MDCK low */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* MDCK high */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|xe_mii_getbit
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|u_int16_t
name|data
decl_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|data
operator|=
name|XE_INB
argument_list|(
name|XE_GPR2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|data
operator|&
literal|0x20
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xe_mii_putbit
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
condition|)
block|{
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0x0d
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xe_mii_putbits
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int16_t
name|mask
decl_stmt|;
for|for
control|(
name|mask
operator|=
literal|1
operator|<<
operator|(
operator|--
name|len
operator|)
init|;
name|mask
operator|!=
literal|0
condition|;
name|mask
operator|>>=
literal|1
control|)
name|xe_mii_putbit
argument_list|(
name|scp
argument_list|,
name|data
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|xe_mii_read
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int8_t
name|phy
parameter_list|,
name|u_int8_t
name|reg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
name|mask
decl_stmt|,
name|data
init|=
literal|0
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|xe_mii_putbit
argument_list|(
name|scp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xe_mii_putbits
argument_list|(
name|scp
argument_list|,
literal|0x06
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xe_mii_putbits
argument_list|(
name|scp
argument_list|,
name|phy
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_putbits
argument_list|(
name|scp
argument_list|,
name|reg
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_clock
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_mii_getbit
argument_list|(
name|scp
argument_list|)
expr_stmt|;
for|for
control|(
name|mask
operator|=
literal|1
operator|<<
literal|15
init|;
name|mask
operator|!=
literal|0
condition|;
name|mask
operator|>>=
literal|1
control|)
if|if
condition|(
name|xe_mii_getbit
argument_list|(
name|scp
argument_list|)
condition|)
name|data
operator||=
name|mask
expr_stmt|;
name|xe_mii_clock
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xe_mii_write
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int8_t
name|phy
parameter_list|,
name|u_int8_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|xe_mii_putbit
argument_list|(
name|scp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xe_mii_putbits
argument_list|(
name|scp
argument_list|,
literal|0x05
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xe_mii_putbits
argument_list|(
name|scp
argument_list|,
name|phy
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_putbits
argument_list|(
name|scp
argument_list|,
name|reg
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_putbit
argument_list|(
name|scp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xe_mii_putbit
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xe_mii_putbits
argument_list|(
name|scp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xe_mii_clock
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|u_int16_t
name|control
decl_stmt|,
name|status
decl_stmt|,
name|partner
decl_stmt|;
name|int
name|unit
init|=
name|scp
operator|->
name|dev
operator|->
name|id_unit
decl_stmt|,
name|i
decl_stmt|;
name|status
operator|=
name|xe_mii_read
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x7800
condition|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: no MII found, %0x\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/*    * XXX - do proper media selection here    */
if|if
condition|(
name|scp
operator|->
name|probe
condition|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: trying auto-negotiation\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|control
operator|=
literal|0x1000
expr_stmt|;
comment|/* AutoNeg */
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|port
operator|==
literal|4
condition|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: defaulting to 100Mbps\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|control
operator|=
literal|0x2000
expr_stmt|;
comment|/* 100Mbps */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: defaulting to 10Mbps\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|control
operator|=
literal|0x0000
expr_stmt|;
comment|/* 10Mbps */
block|}
name|xe_mii_write
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|control
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|control
operator|=
name|xe_mii_read
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0400
condition|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: can't take PHY out of isolation mode\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|scp
operator|->
name|probe
condition|)
block|{
comment|/* Wait for negotiation to finish */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: waiting for auto-negotiation to complete...\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|35
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|status
operator|=
name|xe_mii_read
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0x0020
operator|)
operator|&&
operator|(
name|status
operator|&
literal|0x0004
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|0x0020
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: auto-negotiation failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|control
operator|=
literal|0x0000
expr_stmt|;
name|xe_mii_write
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|control
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|port
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
name|partner
operator|=
name|xe_mii_read
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: MII link partner = %04x\n"
argument_list|,
name|unit
argument_list|,
name|partner
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|partner
operator|&
literal|0x0080
condition|)
block|{
name|scp
operator|->
name|port
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|port
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
block|}
name|scp
operator|->
name|probe
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: auto-negotiation result: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scp
operator|->
name|port
condition|)
block|{
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"100BaseTX\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"10BaseT\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"10Base2\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|unit
init|=
name|scp
operator|->
name|dev
operator|->
name|id_unit
decl_stmt|;
name|printf
argument_list|(
literal|"xe%d: MII register dump\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %04x"
argument_list|,
name|xe_mii_read
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xe_reg_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|unit
init|=
name|scp
operator|->
name|dev
operator|->
name|id_unit
decl_stmt|;
name|int
name|page
decl_stmt|,
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"xe%d: Common registers: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
literal|8
condition|;
name|page
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"xe%d: Register page %2.2x: "
argument_list|,
name|unit
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|page
operator|=
literal|0x40
init|;
name|page
operator|<
literal|0x5f
condition|;
name|page
operator|++
control|)
block|{
if|if
condition|(
name|page
operator|==
literal|0x43
operator|||
operator|(
name|page
operator|>=
literal|0x46
operator|&&
name|page
operator|<=
literal|0x4f
operator|)
operator|||
operator|(
name|page
operator|>=
literal|0x51
operator|&&
name|page
operator|<=
literal|0x5e
operator|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"xe%d: Register page %2.2x: "
argument_list|,
name|unit
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************  *                                                            *  *               P C M C I A  F U N C T I O N S               *  *                                                            *  **************************************************************/
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_comment
comment|/*  * Horrid stuff for accessing CIS tuples  */
end_comment

begin_define
define|#
directive|define
name|CISTPL_BUFSIZE
value|512
end_define

begin_define
define|#
directive|define
name|CISTPL_TYPE
parameter_list|(
name|tpl
parameter_list|)
value|tpl[0]
end_define

begin_define
define|#
directive|define
name|CISTPL_LEN
parameter_list|(
name|tpl
parameter_list|)
value|tpl[2]
end_define

begin_define
define|#
directive|define
name|CISTPL_DATA
parameter_list|(
name|tpl
parameter_list|,
name|pos
parameter_list|)
value|tpl[4 + ((pos)<<1)]
end_define

begin_comment
comment|/*  * Probe and identify the device.  Called by the slot manager when the card is   * inserted or the machine wakes up from suspend mode.  Assmes that the slot  * structure has been initialised already.  */
end_comment

begin_function
specifier|static
name|int
name|xe_card_init
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|u_char
name|buf
index|[
name|CISTPL_BUFSIZE
index|]
decl_stmt|;
name|u_char
name|ver_str
index|[
name|CISTPL_BUFSIZE
operator|>>
literal|1
index|]
expr_stmt|;
name|off_t
name|offs
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|success
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|dev
operator|=
operator|&
name|devi
operator|->
name|isahd
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe: Probing for unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check that unit number is OK */
if|if
condition|(
name|unit
operator|>
name|MAXSLOT
condition|)
block|{
name|printf
argument_list|(
literal|"xe: bad unit (%d)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Don't attach an active device */
if|if
condition|(
name|scp
operator|&&
operator|!
name|scp
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"xe: unit already attached (%d)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Allocate per-instance storage */
if|if
condition|(
operator|!
name|scp
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: failed to allocage driver strorage\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Re-attach an existing device */
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
block|{
name|scp
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Grep through CIS looking for relevant tuples */
name|offs
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|u_int16_t
name|vendor
decl_stmt|;
name|u_int8_t
name|rev
decl_stmt|,
name|media
decl_stmt|,
name|prod
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|CISTPL_BUFSIZE
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offs
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|CISTPL_BUFSIZE
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
comment|/*      * Read tuples one at a time into buf.  Sucks, but it only happens once.      * XXX - If the stuff we need isn't in attribute memory, or (worse yet)      * XXX - attribute memory isn't mapped, we're FUBAR.  Maybe need to do an      * XXX - ioctl on the card device and follow links?      */
if|if
condition|(
operator|(
name|rc
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_read
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|devi
operator|->
name|slt
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|CISTPL_TYPE
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
literal|0x15
case|:
comment|/* Grab version string (needed to ID some weird CE2's) */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Got version string (0x15)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
condition|;
name|ver_str
index|[
name|i
index|]
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
name|i
operator|++
argument_list|)
control|)
empty_stmt|;
name|ver_str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ver_str
index|[
name|CISTPL_BUFSIZE
operator|>>
literal|1
operator|-
literal|1
index|]
operator|=
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|success
operator|++
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
comment|/* Figure out what type of card we have */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Got card ID (0x20)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vendor
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|+
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|rev
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|media
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|prod
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vendor
condition|)
block|{
comment|/* Get vendor ID */
case|case
literal|0x0105
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Xircom"
expr_stmt|;
break|break;
case|case
literal|0x0138
case|:
case|case
literal|0x0183
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Compaq"
expr_stmt|;
break|break;
case|case
literal|0x0089
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Intel"
expr_stmt|;
break|break;
default|default:
name|scp
operator|->
name|vendor
operator|=
literal|"Unknown"
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|prod
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|media
operator|&
literal|0x01
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Not a PCMCIA Ethernet card!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|ENODEV
expr_stmt|;
comment|/* Not a PCMCIA Ethernet device */
block|}
else|else
block|{
if|if
condition|(
name|media
operator|&
literal|0x10
condition|)
block|{
comment|/* Ethernet/modem cards */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Card is Ethernet/modem combo\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|modem
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|prod
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|1
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CEM"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CEM2"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CEM3"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CEM33"
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|scp
operator|->
name|ce3
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM56M"
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|scp
operator|->
name|ce3
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|cem56
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM56"
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Ethernet-only cards */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Card is Ethernet only\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|prod
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|1
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CE"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CE2"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|scp
operator|->
name|ce3
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CE3"
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
block|}
name|success
operator|++
expr_stmt|;
break|break;
case|case
literal|0x22
case|:
comment|/* Get MAC address */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Got MAC address (0x22)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|==
literal|8
operator|)
operator|&&
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0x04
operator|)
operator|&&
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
name|ETHER_ADDR_LEN
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|,
name|i
operator|++
control|)
empty_stmt|;
block|}
name|success
operator|++
expr_stmt|;
break|break;
default|default:
block|}
block|}
comment|/* Skip to next tuple */
name|offs
operator|+=
operator|(
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|+
literal|2
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|CISTPL_TYPE
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0xff
operator|)
operator|&&
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0xff
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
do|;
comment|/* Die now if something went wrong above */
if|if
condition|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|||
operator|(
name|success
operator|<
literal|3
operator|)
condition|)
block|{
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* Check for certain strange CE2's that look like CE's */
if|if
condition|(
name|strcmp
argument_list|(
name|scp
operator|->
name|card_type
argument_list|,
literal|"CE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_char
name|len
init|=
name|ver_str
index|[
name|CISTPL_BUFSIZE
operator|>>
literal|1
operator|-
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Checking for weird CE2 string\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bcmp
argument_list|(
literal|"CE2"
argument_list|,
operator|&
name|ver_str
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|scp
operator|->
name|card_type
operator|=
literal|"CE2"
expr_stmt|;
block|}
comment|/* Fill in some private data */
name|sca
index|[
name|unit
index|]
operator|=
name|scp
expr_stmt|;
name|scp
operator|->
name|dev
operator|=
operator|&
name|devi
operator|->
name|isahd
expr_stmt|;
name|scp
operator|->
name|crd
operator|=
name|devi
expr_stmt|;
name|scp
operator|->
name|probe
operator|=
literal|1
expr_stmt|;
comment|/* Do media auto-detect by default */
comment|/* Attempt to attach the device */
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: Attaching...\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xe_attach
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sca
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|#
directive|if
name|NAPM
operator|>
literal|0
comment|/* Establish APM hooks once device attached */
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_name
operator|=
literal|"xe_suspend"
expr_stmt|;
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_fun
operator|=
name|xe_suspend
expr_stmt|;
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|unit
expr_stmt|;
name|scp
operator|->
name|suspend_hook
operator|.
name|ah_order
operator|=
name|APM_MIN_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|scp
operator|->
name|suspend_hook
argument_list|)
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_name
operator|=
literal|"xe_resume"
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_fun
operator|=
name|xe_resume
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|unit
expr_stmt|;
name|scp
operator|->
name|resume_hook
operator|.
name|ah_order
operator|=
name|APM_MIN_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|scp
operator|->
name|resume_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAPM> 0 */
comment|/* Success */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The device entry is being removed, probably because someone ejected the  * card.  The interface should have been brought down manually before calling  * this function; if not you may well lose packets.  In any case, I shut down  * the card and the interface, and hope for the best.  The 'gone' flag is set,   * so hopefully no-one else will try to access the missing card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_card_unload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"xe%d: already unloaded\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Card interrupt handler: should return true if the interrupt was for us, in  * case we are sharing our IRQ line with other devices (this will probably be  * the case for multifunction cards).  *  * This function is probably more complicated than it needs to be, as it  * attempts to deal with the case where multiple packets get sent between  * interrupts.  This is especially annoying when working out the collision  * stats.  Not sure whether this case ever really happens or not (maybe on a  * slow/heavily loaded machine?) so it's probably best to leave this like it  * is.  *  * Note that the crappy PIO used to get packets on and off the card means that   * you will spend a lot of time in this routine -- I can get my P150 to spend  * 90% of its time servicing interrupts if I really hammer the network.  Could   * fix this, but then you'd start dropping/losing packets.  The moral of this  * story?  If you want good network performance _and_ some cycles left over to   * get your work done, don't buy a Xircom card.  Or convince them to tell me  * how to do memory-mapped I/O :)  */
end_comment

begin_function
specifier|static
name|int
name|xe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|result
decl_stmt|;
name|u_int16_t
name|rx_bytes
decl_stmt|,
name|rxs
decl_stmt|,
name|txs
decl_stmt|;
name|u_int8_t
name|psr
decl_stmt|,
name|isr
decl_stmt|,
name|esr
decl_stmt|,
name|rsr
decl_stmt|;
name|unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|rx_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Bytes received on this interrupt */
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Set true if the interrupt is for us */
if|if
condition|(
name|scp
operator|->
name|gone
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|scp
operator|->
name|ce3
condition|)
block|{
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
block|}
name|psr
operator|=
name|XE_INB
argument_list|(
name|XE_PSR
argument_list|)
expr_stmt|;
comment|/* Stash the current register page */
comment|/*    * Read ISR to see what caused this interrupt.  Note that this clears the    * ISR on CE2 type cards.    */
if|if
condition|(
operator|(
name|isr
operator|=
name|XE_INB
argument_list|(
name|XE_ISR
argument_list|)
operator|)
operator|&&
name|isr
operator|!=
literal|0xff
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
comment|/* This device did generate an int */
name|esr
operator|=
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
expr_stmt|;
comment|/* Read the other status registers */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|rxs
operator|=
name|XE_INB
argument_list|(
name|XE_RXS0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_RXS0
argument_list|,
operator|~
name|rxs
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|txs
operator|=
name|XE_INB
argument_list|(
name|XE_TXS0
argument_list|)
expr_stmt|;
name|txs
operator||=
name|XE_INB
argument_list|(
name|XE_TXS1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXS0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXS1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|3
name|printf
argument_list|(
literal|"xe%d: ISR=%#2.2x ESR=%#2.2x RXS=%#2.2x TXS=%#4.4x\n"
argument_list|,
name|unit
argument_list|,
name|isr
argument_list|,
name|esr
argument_list|,
name|rxs
argument_list|,
name|txs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Handle transmit interrupts      */
if|if
condition|(
name|isr
operator|&
name|XE_ISR_TX_PACKET
condition|)
block|{
name|u_int8_t
name|new_ptr
decl_stmt|,
name|sent
decl_stmt|;
if|if
condition|(
operator|(
name|new_ptr
operator|=
name|XE_INB
argument_list|(
name|XE_PTR
argument_list|)
operator|)
operator|<
name|scp
operator|->
name|tx_ptr
condition|)
comment|/* Update packet count */
name|sent
operator|=
operator|(
literal|0xff
operator|-
name|scp
operator|->
name|tx_ptr
operator|)
operator|+
name|new_ptr
expr_stmt|;
comment|/* PTR rolled over */
else|else
name|sent
operator|=
name|new_ptr
operator|-
name|scp
operator|->
name|tx_ptr
expr_stmt|;
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
block|{
comment|/* Packets sent since last interrupt */
name|scp
operator|->
name|tx_ptr
operator|=
name|new_ptr
expr_stmt|;
name|scp
operator|->
name|tx_queued
operator|-=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|scp
operator|->
name|tx_collisions
expr_stmt|;
comment|/* 	 * Collision stats are a PITA.  If multiples frames have been sent, we  	 * distribute any outstanding collision count equally amongst them. 	 * However, if we're missing interrupts we're quite likely to also 	 * miss some collisions; thus the total count will be off anyway. 	 * Likewise, if we miss a frame dropped due to excessive collisions 	 * any outstanding collisions count will be held against the next 	 * frame to be successfully sent.  Hopefully it averages out in the 	 * end! 	 * XXX - This will screw up if tx_collisions/sent> 14.  FIX IT! 	 */
switch|switch
condition|(
name|scp
operator|->
name|tx_collisions
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|sent
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Distribute across multiple frames */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|+=
name|sent
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|/
name|sent
index|]
operator|+=
name|sent
operator|-
name|scp
operator|->
name|tx_collisions
operator|%
name|sent
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|/
name|sent
operator|+
literal|1
index|]
operator|+=
name|scp
operator|->
name|tx_collisions
operator|%
name|sent
expr_stmt|;
block|}
block|}
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|txs
operator|&
literal|0x0002
condition|)
block|{
comment|/* Excessive collisions (packet dropped) */
name|ifp
operator|->
name|if_collisions
operator|+=
literal|16
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_RESTART_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txs
operator|&
literal|0x0040
condition|)
comment|/* Transmit aborted -- probably collisions */
name|scp
operator|->
name|tx_collisions
operator|++
expr_stmt|;
comment|/*      * Handle receive interrupts       */
while|while
condition|(
operator|(
name|esr
operator|=
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|)
operator|&
name|XE_ESR_FULL_PKT_RX
condition|)
block|{
if|if
condition|(
operator|(
name|rsr
operator|=
name|XE_INB
argument_list|(
name|XE_RSR
argument_list|)
operator|)
operator|&
name|XE_RSR_RX_OK
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|ehp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|len
operator|=
name|XE_INW
argument_list|(
name|XE_RBC
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* 	 * Limit the amount of time we spend in this loop, dropping packets if  	 * necessary.  The Linux code does this with considerably more 	 * finesse, adjusting the threshold dynamically. 	 */
block|if ((rx_bytes += len)> 22000) { 	  ifp->if_iqdrops++; 	  scp->mibData.dot3StatsMissedFrames++; 	  XE_OUTW(XE_DOR, 0x8000); 	  continue; 	}
endif|#
directive|endif
if|if
condition|(
name|len
operator|&
literal|0x01
condition|)
name|len
operator|++
expr_stmt|;
name|MGETHDR
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* Allocate a header mbuf */
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|mbp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 	   * If the mbuf header isn't big enough for the packet, attach an 	   * mbuf cluster to hold it.  The +2 is to allow for the nasty little  	   * alignment hack below. 	   */
if|if
condition|(
name|len
operator|+
literal|2
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mbp
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
name|mbp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
comment|/* 	   * The Ethernet header is 14 bytes long; thus the actual packet data  	   * won't be 32-bit aligned when it's dumped into the mbuf.  We 	   * offset everything by 2 bytes to fix this.  Apparently the 	   * alignment is important for NFS, damn its eyes. 	   */
name|mbp
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|ehp
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	   * Now get the packet, including the Ethernet header and trailer (?) 	   * We use programmed I/O, because we don't know how to do shared 	   * memory with these cards.  So yes, it's real slow, and heavy on 	   * the interrupts (CPU on my P150 maxed out at ~950KBps incoming). 	   */
if|if
condition|(
name|scp
operator|->
name|srev
operator|==
literal|0
condition|)
block|{
comment|/* Workaround a bug in old cards */
name|u_short
name|rhs
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XE_INW
argument_list|(
name|XE_RHS
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|+=
literal|3
expr_stmt|;
comment|/* Skip control info */
if|if
condition|(
name|rhs
operator|>=
literal|0x8000
condition|)
name|rhs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rhs
operator|+
name|len
operator|>
literal|0x8000
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	       * XXX - this i-- seems very wrong, but it's what the Linux guys  	       * XXX - do.  Need someone with an old CE2 to test this for me. 	       */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|--
operator|,
name|rhs
operator|++
control|)
block|{
operator|(
operator|(
name|char
operator|*
operator|)
name|ehp
operator|)
index|[
name|i
index|]
operator|=
name|XE_INB
argument_list|(
name|XE_EDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|=
literal|0x8000
condition|)
block|{
name|rhs
operator|=
literal|0
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
name|insw
argument_list|(
name|scp
operator|->
name|dev
operator|->
name|id_iobase
operator|+
name|XE_EDP
argument_list|,
name|ehp
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|insw
argument_list|(
name|scp
operator|->
name|dev
operator|->
name|id_iobase
operator|+
name|XE_EDP
argument_list|,
name|ehp
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	   * Check if there's a BPF listener on this interface. If so, hand 	   * off the raw packet to bpf. 	   */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/*	 	     * Note that the interface cannot be in promiscuous mode if there 	     * are no BPF listeners.  And if we are in promiscuous mode, we 	     * have to check if this packet is really ours. 	     */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|ehp
operator|->
name|ether_dhost
argument_list|,
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ehp
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|rsr
operator|&
name|XE_RSR_PHYS_PKT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
name|mbp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbp
operator|->
name|m_len
operator|=
name|len
operator|-
name|ETHER_HDR_LEN
expr_stmt|;
name|mbp
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* Strip off Ethernet header */
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|ehp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Send the packet on its way */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Success! */
name|XE_OUTW
argument_list|(
name|XE_DOR
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* skip_rx_packet command */
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_LONG_PKT
condition|)
block|{
comment|/* Packet length>1518 bytes */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFrameTooLongs
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_CRC_ERR
condition|)
block|{
comment|/* Bad checksum on packet */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_ALIGN_ERR
condition|)
block|{
comment|/* Packet alignment error */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxs
operator|&
literal|0x10
condition|)
block|{
comment|/* Receiver overrun */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_CLEAR_OVERRUN
argument_list|)
expr_stmt|;
block|}
block|}
name|XE_SELECT_PAGE
argument_list|(
name|psr
argument_list|)
expr_stmt|;
comment|/* Restore saved page */
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts */
comment|/* XXX - force an int here, instead of dropping packets?     */
comment|/* XXX - XE_OUTB(XE_CR, XE_CR_ENABLE_INTR|XE_CE_FORCE_INTR); */
return|return
name|result
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_comment
comment|/**************************************************************  *                                                            *  *                  A P M  F U N C T I O N S                  *  *                                                            *  **************************************************************/
end_comment

begin_comment
comment|/*  * This is called when we go into suspend/standby mode  */
end_comment

begin_function
specifier|static
name|int
name|xe_suspend
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
operator|(
name|int
operator|)
name|xunit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: APM suspend\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when we wake up again  */
end_comment

begin_function
specifier|static
name|int
name|xe_resume
parameter_list|(
name|void
modifier|*
name|xunit
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
operator|(
name|int
operator|)
name|xunit
expr_stmt|;
name|scp
operator|=
name|sca
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: APM resume\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD> 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NXE> 0 */
end_comment

end_unit

