begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006, 2007 Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2007, 2008 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|LINUXKPI_PARAM_PREFIX
value|mlx4_
end_define

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/inetdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_vlan.h>
end_include

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/rcupdate.h>
end_include

begin_include
include|#
directive|include
file|<linux/notifier.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|<net/ipv6.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_smi.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_user_verbs.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_addr.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_cache.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/qp.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/page.h>
end_include

begin_include
include|#
directive|include
file|<linux/printk.h>
end_include

begin_include
include|#
directive|include
file|"mlx4_ib.h"
end_include

begin_include
include|#
directive|include
file|<rdma/mlx4-abi.h>
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_define
define|#
directive|define
name|DRV_NAME
value|MLX4_IB_DRV_NAME
end_define

begin_define
define|#
directive|define
name|DRV_VERSION
value|"3.4.1-BETA"
end_define

begin_define
define|#
directive|define
name|DRV_RELDATE
value|"October 2017"
end_define

begin_define
define|#
directive|define
name|MLX4_IB_FLOW_MAX_PRIO
value|0xFFF
end_define

begin_define
define|#
directive|define
name|MLX4_IB_FLOW_QPN_MASK
value|0xFFFFFF
end_define

begin_define
define|#
directive|define
name|MLX4_IB_CARD_REV_A0
value|0xA0
end_define

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Mellanox ConnectX HCA InfiniBand driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_ib_sm_guid_assign
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|sm_guid_assign
argument_list|,
name|mlx4_ib_sm_guid_assign
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|sm_guid_assign
argument_list|,
literal|"Enable SM alias_GUID assignment if sm_guid_assign> 0 (Default: 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|mlx4_ib_version
index|[]
init|=
name|DRV_NAME
literal|": Mellanox ConnectX InfiniBand driver v"
name|DRV_VERSION
literal|" ("
name|DRV_RELDATE
literal|")\n"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|do_slave_init
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|do_init
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|workqueue_struct
modifier|*
name|wq
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_query_mad
parameter_list|(
name|struct
name|ib_smp
modifier|*
name|mad
parameter_list|)
block|{
name|mad
operator|->
name|base_version
operator|=
literal|1
expr_stmt|;
name|mad
operator|->
name|mgmt_class
operator|=
name|IB_MGMT_CLASS_SUBN_LID_ROUTED
expr_stmt|;
name|mad
operator|->
name|class_version
operator|=
literal|1
expr_stmt|;
name|mad
operator|->
name|method
operator|=
name|IB_MGMT_METHOD_GET
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_flow_steering_support
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|eth_num_ports
init|=
literal|0
decl_stmt|;
name|int
name|ib_num_ports
init|=
literal|0
decl_stmt|;
name|int
name|dmfs
init|=
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
decl_stmt|;
if|if
condition|(
name|dmfs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|mlx4_foreach_port
argument_list|(
argument|i
argument_list|,
argument|dev
argument_list|,
argument|MLX4_PORT_TYPE_ETH
argument_list|)
name|eth_num_ports
operator|++
expr_stmt|;
name|mlx4_foreach_port
argument_list|(
argument|i
argument_list|,
argument|dev
argument_list|,
argument|MLX4_PORT_TYPE_IB
argument_list|)
name|ib_num_ports
operator|++
expr_stmt|;
name|dmfs
operator|&=
operator|(
operator|!
name|ib_num_ports
operator|||
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_DMFS_IPOIB
operator|)
operator|)
operator|&&
operator|(
operator|!
name|eth_num_ports
operator|||
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_FS_EN
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ib_num_ports
operator|&&
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Device managed flow steering is unavailable for IB port in multifunction env.\n"
argument_list|)
expr_stmt|;
name|dmfs
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|dmfs
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|num_ib_ports
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ib_ports
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mlx4_foreach_port
argument_list|(
argument|i
argument_list|,
argument|dev
argument_list|,
argument|MLX4_PORT_TYPE_IB
argument_list|)
name|ib_ports
operator|++
expr_stmt|;
return|return
name|ib_ports
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|net_device
modifier|*
name|mlx4_ib_get_netdev
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
init|=
name|to_mdev
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|struct
name|net_device
modifier|*
name|dev
decl_stmt|;
name|rcu_read_lock
argument_list|()
expr_stmt|;
name|dev
operator|=
name|mlx4_get_protocol_dev
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|MLX4_PROT_ETH
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (dev) { 		if (mlx4_is_bonded(ibdev->dev)) { 			struct net_device *upper = NULL;  			upper = netdev_master_upper_dev_get_rcu(dev); 			if (upper) { 				struct net_device *active;  				active = bond_option_active_slave_get_rcu(netdev_priv(upper)); 				if (active) 					dev = active; 			} 		} 	}
endif|#
directive|endif
if|if
condition|(
name|dev
condition|)
name|dev_hold
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rcu_read_unlock
argument_list|()
expr_stmt|;
return|return
name|dev
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_update_gids_v1
parameter_list|(
name|struct
name|gid_entry
modifier|*
name|gids
parameter_list|,
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|ibdev
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|union
name|ib_gid
modifier|*
name|gid_tbl
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|gid_tbl
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORT_GIDS
condition|;
operator|++
name|i
control|)
name|memcpy
argument_list|(
operator|&
name|gid_tbl
index|[
name|i
index|]
argument_list|,
operator|&
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ib_gid
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|MLX4_SET_PORT_GID_TABLE
operator|<<
literal|8
operator||
name|port_num
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_SET_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|)
name|err
operator|+=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|MLX4_SET_PORT_GID_TABLE
operator|<<
literal|8
operator||
literal|2
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_SET_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_update_gids_v1_v2
parameter_list|(
name|struct
name|gid_entry
modifier|*
name|gids
parameter_list|,
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|ibdev
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
block|{
name|union
name|ib_gid
name|gid
decl_stmt|;
name|__be32
name|rsrvd1
index|[
literal|2
index|]
decl_stmt|;
name|__be16
name|rsrvd2
decl_stmt|;
name|u8
name|type
decl_stmt|;
name|u8
name|version
decl_stmt|;
name|__be32
name|rsrvd3
decl_stmt|;
block|}
modifier|*
name|gid_tbl
struct|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|gid_tbl
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORT_GIDS
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|gid_tbl
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
operator|&
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ib_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gids
index|[
name|i
index|]
operator|.
name|gid_type
operator|==
name|IB_GID_TYPE_ROCE_UDP_ENCAP
condition|)
block|{
name|gid_tbl
index|[
name|i
index|]
operator|.
name|version
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|ipv6_addr_v4mapped
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
operator|&
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|)
condition|)
name|gid_tbl
index|[
name|i
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|gid_tbl
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
literal|0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|MLX4_SET_PORT_ROCE_ADDR
operator|<<
literal|8
operator||
name|port_num
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_SET_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|)
name|err
operator|+=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|MLX4_SET_PORT_ROCE_ADDR
operator|<<
literal|8
operator||
literal|2
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_SET_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_update_gids
parameter_list|(
name|struct
name|gid_entry
modifier|*
name|gids
parameter_list|,
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
if|if
condition|(
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_ROCE_V1_V2
condition|)
return|return
name|mlx4_ib_update_gids_v1_v2
argument_list|(
name|gids
argument_list|,
name|ibdev
argument_list|,
name|port_num
argument_list|)
return|;
return|return
name|mlx4_ib_update_gids_v1
argument_list|(
name|gids
argument_list|,
name|ibdev
argument_list|,
name|port_num
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_add_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
specifier|const
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
specifier|const
name|struct
name|ib_gid_attr
modifier|*
name|attr
parameter_list|,
name|void
modifier|*
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
init|=
name|to_mdev
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_iboe
modifier|*
name|iboe
init|=
operator|&
name|ibdev
operator|->
name|iboe
decl_stmt|;
name|struct
name|mlx4_port_gid_table
modifier|*
name|port_gid_table
decl_stmt|;
name|int
name|free
init|=
operator|-
literal|1
decl_stmt|,
name|found
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|hw_update
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|gid_entry
modifier|*
name|gids
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|rdma_cap_roce_gid_table
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|port_num
operator|>
name|MLX4_MAX_PORTS
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
operator|-
name|EINVAL
return|;
name|port_gid_table
operator|=
operator|&
name|iboe
operator|->
name|gids
index|[
name|port_num
operator|-
literal|1
index|]
expr_stmt|;
name|spin_lock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORT_GIDS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gid
argument_list|)
argument_list|)
operator|&&
operator|(
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid_type
operator|==
name|attr
operator|->
name|gid_type
operator|)
condition|)
block|{
name|found
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|free
operator|<
literal|0
operator|&&
operator|!
name|memcmp
argument_list|(
operator|&
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
operator|&
name|zgid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gid
argument_list|)
argument_list|)
condition|)
name|free
operator|=
name|i
expr_stmt|;
comment|/* HW has space */
block|}
if|if
condition|(
name|found
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|free
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOSPC
expr_stmt|;
block|}
else|else
block|{
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|ctx
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|ctx
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|ctx
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
operator|*
name|context
operator|=
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|ctx
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|gid
argument_list|,
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gid
argument_list|)
argument_list|)
expr_stmt|;
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|gid_type
operator|=
name|attr
operator|->
name|gid_type
expr_stmt|;
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|ctx
operator|->
name|real_index
operator|=
name|free
expr_stmt|;
name|port_gid_table
operator|->
name|gids
index|[
name|free
index|]
operator|.
name|ctx
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|hw_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|gid_cache_context
modifier|*
name|ctx
init|=
name|port_gid_table
operator|->
name|gids
index|[
name|found
index|]
operator|.
name|ctx
decl_stmt|;
operator|*
name|context
operator|=
name|ctx
expr_stmt|;
name|ctx
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
operator|&&
name|hw_update
condition|)
block|{
name|gids
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gids
argument_list|)
operator|*
name|MLX4_MAX_PORT_GIDS
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gids
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORT_GIDS
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
operator|&
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ib_gid
argument_list|)
argument_list|)
expr_stmt|;
name|gids
index|[
name|i
index|]
operator|.
name|gid_type
operator|=
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid_type
expr_stmt|;
block|}
block|}
block|}
name|spin_unlock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|hw_update
condition|)
block|{
name|ret
operator|=
name|mlx4_ib_update_gids
argument_list|(
name|gids
argument_list|,
name|ibdev
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|gids
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_del_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|void
modifier|*
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|gid_cache_context
modifier|*
name|ctx
init|=
operator|*
name|context
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
init|=
name|to_mdev
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_iboe
modifier|*
name|iboe
init|=
operator|&
name|ibdev
operator|->
name|iboe
decl_stmt|;
name|struct
name|mlx4_port_gid_table
modifier|*
name|port_gid_table
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|hw_update
init|=
literal|0
decl_stmt|;
name|struct
name|gid_entry
modifier|*
name|gids
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|rdma_cap_roce_gid_table
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|port_num
operator|>
name|MLX4_MAX_PORTS
condition|)
return|return
operator|-
name|EINVAL
return|;
name|port_gid_table
operator|=
operator|&
name|iboe
operator|->
name|gids
index|[
name|port_num
operator|-
literal|1
index|]
expr_stmt|;
name|spin_lock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|refcount
condition|)
block|{
name|unsigned
name|int
name|real_index
init|=
name|ctx
operator|->
name|real_index
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|port_gid_table
operator|->
name|gids
index|[
name|real_index
index|]
operator|.
name|gid
argument_list|,
operator|&
name|zgid
argument_list|,
sizeof|sizeof
argument_list|(
name|zgid
argument_list|)
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|port_gid_table
operator|->
name|gids
index|[
name|real_index
index|]
operator|.
name|ctx
argument_list|)
expr_stmt|;
name|port_gid_table
operator|->
name|gids
index|[
name|real_index
index|]
operator|.
name|ctx
operator|=
name|NULL
expr_stmt|;
name|hw_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ret
operator|&&
name|hw_update
condition|)
block|{
name|int
name|i
decl_stmt|;
name|gids
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gids
argument_list|)
operator|*
name|MLX4_MAX_PORT_GIDS
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gids
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORT_GIDS
condition|;
name|i
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
operator|&
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ib_gid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|hw_update
condition|)
block|{
name|ret
operator|=
name|mlx4_ib_update_gids
argument_list|(
name|gids
argument_list|,
name|ibdev
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|gids
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_gid_index_to_real_index
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|mlx4_ib_iboe
modifier|*
name|iboe
init|=
operator|&
name|ibdev
operator|->
name|iboe
decl_stmt|;
name|struct
name|gid_cache_context
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|union
name|ib_gid
name|gid
decl_stmt|;
name|struct
name|mlx4_port_gid_table
modifier|*
name|port_gid_table
decl_stmt|;
name|int
name|real_index
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ib_gid_attr
name|attr
decl_stmt|;
if|if
condition|(
name|port_num
operator|>
name|MLX4_MAX_PORTS
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
name|port_num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|rdma_cap_roce_gid_table
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|port_num
argument_list|)
condition|)
return|return
name|index
return|;
name|ret
operator|=
name|ib_get_cached_gid
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|port_num
argument_list|,
name|index
argument_list|,
operator|&
name|gid
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|attr
operator|.
name|ndev
condition|)
name|dev_put
argument_list|(
name|attr
operator|.
name|ndev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|gid
argument_list|,
operator|&
name|zgid
argument_list|,
sizeof|sizeof
argument_list|(
name|gid
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|port_gid_table
operator|=
operator|&
name|iboe
operator|->
name|gids
index|[
name|port_num
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORT_GIDS
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
operator|&
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
name|gid
argument_list|)
argument_list|)
operator|&&
name|attr
operator|.
name|gid_type
operator|==
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|gid_type
condition|)
block|{
name|ctx
operator|=
name|port_gid_table
operator|->
name|gids
index|[
name|i
index|]
operator|.
name|ctx
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctx
condition|)
name|real_index
operator|=
name|ctx
operator|->
name|real_index
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|real_index
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_query_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|struct
name|ib_device_attr
modifier|*
name|props
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|uhw
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|in_mad
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|out_mad
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|int
name|have_ib_ports
decl_stmt|;
name|struct
name|mlx4_uverbs_ex_query_device
name|cmd
decl_stmt|;
name|struct
name|mlx4_uverbs_ex_query_device_resp
name|resp
init|=
block|{
operator|.
name|comp_mask
operator|=
literal|0
block|}
decl_stmt|;
name|struct
name|mlx4_clock_params
name|clock_params
decl_stmt|;
if|if
condition|(
name|uhw
operator|->
name|inlen
condition|)
block|{
if|if
condition|(
name|uhw
operator|->
name|inlen
operator|<
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|err
operator|=
name|ib_copy_from_udata
argument_list|(
operator|&
name|cmd
argument_list|,
name|uhw
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|cmd
operator|.
name|comp_mask
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|cmd
operator|.
name|reserved
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|resp
operator|.
name|response_length
operator|=
name|offsetof
argument_list|(
name|typeof
argument_list|(
name|resp
argument_list|)
argument_list|,
name|response_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|resp
operator|.
name|response_length
argument_list|)
expr_stmt|;
name|in_mad
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|in_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|out_mad
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|out_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_mad
operator|||
operator|!
name|out_mad
condition|)
goto|goto
name|out
goto|;
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_NODE_INFO
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
argument_list|,
name|MLX4_MAD_IFC_IGNORE_KEYS
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|memset
argument_list|(
name|props
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|props
argument_list|)
expr_stmt|;
name|have_ib_ports
operator|=
name|num_ib_ports
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|props
operator|->
name|fw_ver
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|fw_ver
expr_stmt|;
name|props
operator|->
name|device_cap_flags
operator|=
name|IB_DEVICE_CHANGE_PHY_PORT
operator||
name|IB_DEVICE_PORT_ACTIVE_EVENT
operator||
name|IB_DEVICE_SYS_IMAGE_GUID
operator||
name|IB_DEVICE_RC_RNR_NAK_GEN
operator||
name|IB_DEVICE_BLOCK_MULTICAST_LOOPBACK
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_BAD_PKEY_CNTR
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_BAD_PKEY_CNTR
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_BAD_QKEY_CNTR
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_BAD_QKEY_CNTR
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_APM
operator|&&
name|have_ib_ports
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_AUTO_PATH_MIG
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_UD_AV_PORT
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_UD_AV_PORT_ENFORCE
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_IPOIB_CSUM
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_UD_IP_CSUM
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_gso_sz
operator|&&
operator|(
name|dev
operator|->
name|dev
operator|->
name|rev_id
operator|!=
name|MLX4_IB_CARD_REV_A0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_BLH
operator|)
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_UD_TSO
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_RESERVED_LKEY
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_LOCAL_DMA_LKEY
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_LOCAL_INV
operator|)
operator|&&
operator|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_REMOTE_INV
operator|)
operator|&&
operator|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_FAST_REG_WR
operator|)
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_MEM_MGT_EXTENSIONS
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_XRC
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_MEM_WINDOW
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_MEM_WINDOW
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_TYPE_2_WIN
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_WIN_TYPE_2B
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_MEM_WINDOW_TYPE_2B
expr_stmt|;
else|else
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_MEM_WINDOW_TYPE_2A
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|steering_support
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_MANAGED_FLOW_STEERING
expr_stmt|;
name|props
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_RAW_IP_CSUM
expr_stmt|;
name|props
operator|->
name|vendor_id
operator|=
name|be32_to_cpup
argument_list|(
operator|(
name|__be32
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|36
operator|)
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|props
operator|->
name|vendor_part_id
operator|=
name|dev
operator|->
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|device
expr_stmt|;
name|props
operator|->
name|hw_ver
operator|=
name|be32_to_cpup
argument_list|(
operator|(
name|__be32
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|32
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|props
operator|->
name|sys_image_guid
argument_list|,
name|out_mad
operator|->
name|data
operator|+
literal|4
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|props
operator|->
name|max_mr_size
operator|=
operator|~
literal|0ull
expr_stmt|;
name|props
operator|->
name|page_size_cap
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
expr_stmt|;
name|props
operator|->
name|max_qp
operator|=
name|dev
operator|->
name|dev
operator|->
name|quotas
operator|.
name|qp
expr_stmt|;
name|props
operator|->
name|max_qp_wr
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|-
name|MLX4_IB_SQ_MAX_SPARE
expr_stmt|;
name|props
operator|->
name|max_sge
operator|=
name|min
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
argument_list|)
expr_stmt|;
name|props
operator|->
name|max_sge_rd
operator|=
name|MLX4_MAX_SGE_RD
expr_stmt|;
name|props
operator|->
name|max_cq
operator|=
name|dev
operator|->
name|dev
operator|->
name|quotas
operator|.
name|cq
expr_stmt|;
name|props
operator|->
name|max_cqe
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_cqes
expr_stmt|;
name|props
operator|->
name|max_mr
operator|=
name|dev
operator|->
name|dev
operator|->
name|quotas
operator|.
name|mpt
expr_stmt|;
name|props
operator|->
name|max_pd
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_pds
operator|-
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|reserved_pds
expr_stmt|;
name|props
operator|->
name|max_qp_rd_atom
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_qp_dest_rdma
expr_stmt|;
name|props
operator|->
name|max_qp_init_rd_atom
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_qp_init_rdma
expr_stmt|;
name|props
operator|->
name|max_res_rd_atom
operator|=
name|props
operator|->
name|max_qp_rd_atom
operator|*
name|props
operator|->
name|max_qp
expr_stmt|;
name|props
operator|->
name|max_srq
operator|=
name|dev
operator|->
name|dev
operator|->
name|quotas
operator|.
name|srq
expr_stmt|;
name|props
operator|->
name|max_srq_wr
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_srq_wqes
operator|-
literal|1
expr_stmt|;
name|props
operator|->
name|max_srq_sge
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_srq_sge
expr_stmt|;
name|props
operator|->
name|max_fast_reg_page_list_len
operator|=
name|MLX4_MAX_FAST_REG_PAGES
expr_stmt|;
name|props
operator|->
name|local_ca_ack_delay
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|local_ca_ack_delay
expr_stmt|;
name|props
operator|->
name|atomic_cap
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_ATOMIC
condition|?
name|IB_ATOMIC_HCA
else|:
name|IB_ATOMIC_NONE
expr_stmt|;
name|props
operator|->
name|masked_atomic_cap
operator|=
name|props
operator|->
name|atomic_cap
expr_stmt|;
name|props
operator|->
name|max_pkeys
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
literal|1
index|]
expr_stmt|;
name|props
operator|->
name|max_mcast_grp
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_amgms
expr_stmt|;
name|props
operator|->
name|max_mcast_qp_attach
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
expr_stmt|;
name|props
operator|->
name|max_total_mcast_qp_attach
operator|=
name|props
operator|->
name|max_mcast_qp_attach
operator|*
name|props
operator|->
name|max_mcast_grp
expr_stmt|;
name|props
operator|->
name|max_map_per_fmr
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_fmr_maps
expr_stmt|;
name|props
operator|->
name|hca_core_clock
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
operator|*
literal|1000UL
expr_stmt|;
name|props
operator|->
name|timestamp_mask
operator|=
literal|0xFFFFFFFFFFFFULL
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
name|err
operator|=
name|mlx4_get_internal_clock_params
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|clock_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhw
operator|->
name|outlen
operator|>=
name|resp
operator|.
name|response_length
operator|+
sizeof|sizeof
argument_list|(
name|resp
operator|.
name|hca_core_clock_offset
argument_list|)
condition|)
block|{
name|resp
operator|.
name|response_length
operator|+=
sizeof|sizeof
argument_list|(
name|resp
operator|.
name|hca_core_clock_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
block|{
name|resp
operator|.
name|comp_mask
operator||=
name|QUERY_DEVICE_RESP_MASK_TIMESTAMP
expr_stmt|;
name|resp
operator|.
name|hca_core_clock_offset
operator|=
name|clock_params
operator|.
name|offset
operator|%
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uhw
operator|->
name|outlen
condition|)
block|{
name|err
operator|=
name|ib_copy_to_udata
argument_list|(
name|uhw
argument_list|,
operator|&
name|resp
argument_list|,
name|resp
operator|.
name|response_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|kfree
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|out_mad
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rdma_link_layer
name|mlx4_ib_port_link_layer
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|device
argument_list|)
operator|->
name|dev
decl_stmt|;
return|return
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port_num
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|?
name|IB_LINK_LAYER_INFINIBAND
else|:
name|IB_LINK_LAYER_ETHERNET
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ib_link_query_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|props
parameter_list|,
name|int
name|netw_view
parameter_list|)
block|{
name|struct
name|ib_smp
modifier|*
name|in_mad
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|out_mad
init|=
name|NULL
decl_stmt|;
name|int
name|ext_active_speed
decl_stmt|;
name|int
name|mad_ifc_flags
init|=
name|MLX4_MAD_IFC_IGNORE_KEYS
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|in_mad
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|in_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|out_mad
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|out_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_mad
operator|||
operator|!
name|out_mad
condition|)
goto|goto
name|out
goto|;
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_PORT_INFO
expr_stmt|;
name|in_mad
operator|->
name|attr_mod
operator|=
name|cpu_to_be32
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|)
operator|&&
name|netw_view
condition|)
name|mad_ifc_flags
operator||=
name|MLX4_MAD_IFC_NET_VIEW
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
argument_list|,
name|mad_ifc_flags
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|props
operator|->
name|lid
operator|=
name|be16_to_cpup
argument_list|(
operator|(
name|__be16
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
name|props
operator|->
name|lmc
operator|=
name|out_mad
operator|->
name|data
index|[
literal|34
index|]
operator|&
literal|0x7
expr_stmt|;
name|props
operator|->
name|sm_lid
operator|=
name|be16_to_cpup
argument_list|(
operator|(
name|__be16
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|18
operator|)
argument_list|)
expr_stmt|;
name|props
operator|->
name|sm_sl
operator|=
name|out_mad
operator|->
name|data
index|[
literal|36
index|]
operator|&
literal|0xf
expr_stmt|;
name|props
operator|->
name|state
operator|=
name|out_mad
operator|->
name|data
index|[
literal|32
index|]
operator|&
literal|0xf
expr_stmt|;
name|props
operator|->
name|phys_state
operator|=
name|out_mad
operator|->
name|data
index|[
literal|33
index|]
operator|>>
literal|4
expr_stmt|;
name|props
operator|->
name|port_cap_flags
operator|=
name|be32_to_cpup
argument_list|(
operator|(
name|__be32
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|20
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|netw_view
condition|)
name|props
operator|->
name|gid_tbl_len
operator|=
name|out_mad
operator|->
name|data
index|[
literal|50
index|]
expr_stmt|;
else|else
name|props
operator|->
name|gid_tbl_len
operator|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
expr_stmt|;
name|props
operator|->
name|max_msg_sz
operator|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_msg_sz
expr_stmt|;
name|props
operator|->
name|pkey_tbl_len
operator|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
expr_stmt|;
name|props
operator|->
name|bad_pkey_cntr
operator|=
name|be16_to_cpup
argument_list|(
operator|(
name|__be16
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|46
operator|)
argument_list|)
expr_stmt|;
name|props
operator|->
name|qkey_viol_cntr
operator|=
name|be16_to_cpup
argument_list|(
operator|(
name|__be16
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|48
operator|)
argument_list|)
expr_stmt|;
name|props
operator|->
name|active_width
operator|=
name|out_mad
operator|->
name|data
index|[
literal|31
index|]
operator|&
literal|0xf
expr_stmt|;
name|props
operator|->
name|active_speed
operator|=
name|out_mad
operator|->
name|data
index|[
literal|35
index|]
operator|>>
literal|4
expr_stmt|;
name|props
operator|->
name|max_mtu
operator|=
name|out_mad
operator|->
name|data
index|[
literal|41
index|]
operator|&
literal|0xf
expr_stmt|;
name|props
operator|->
name|active_mtu
operator|=
name|out_mad
operator|->
name|data
index|[
literal|36
index|]
operator|>>
literal|4
expr_stmt|;
name|props
operator|->
name|subnet_timeout
operator|=
name|out_mad
operator|->
name|data
index|[
literal|51
index|]
operator|&
literal|0x1f
expr_stmt|;
name|props
operator|->
name|max_vl_num
operator|=
name|out_mad
operator|->
name|data
index|[
literal|37
index|]
operator|>>
literal|4
expr_stmt|;
name|props
operator|->
name|init_type_reply
operator|=
name|out_mad
operator|->
name|data
index|[
literal|41
index|]
operator|>>
literal|4
expr_stmt|;
comment|/* Check if extended speeds (EDR/FDR/...) are supported */
if|if
condition|(
name|props
operator|->
name|port_cap_flags
operator|&
name|IB_PORT_EXTENDED_SPEEDS_SUP
condition|)
block|{
name|ext_active_speed
operator|=
name|out_mad
operator|->
name|data
index|[
literal|62
index|]
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|ext_active_speed
condition|)
block|{
case|case
literal|1
case|:
name|props
operator|->
name|active_speed
operator|=
name|IB_SPEED_FDR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|props
operator|->
name|active_speed
operator|=
name|IB_SPEED_EDR
expr_stmt|;
break|break;
block|}
block|}
comment|/* If reported active speed is QDR, check if is FDR-10 */
if|if
condition|(
name|props
operator|->
name|active_speed
operator|==
name|IB_SPEED_QDR
condition|)
block|{
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|MLX4_ATTR_EXTENDED_PORT_INFO
expr_stmt|;
name|in_mad
operator|->
name|attr_mod
operator|=
name|cpu_to_be32
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
argument_list|,
name|mad_ifc_flags
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* Checking LinkSpeedActive for FDR-10 */
if|if
condition|(
name|out_mad
operator|->
name|data
index|[
literal|15
index|]
operator|&
literal|0x1
condition|)
name|props
operator|->
name|active_speed
operator|=
name|IB_SPEED_FDR10
expr_stmt|;
block|}
comment|/* Avoid wrong speed value returned by FW if the IB link is down. */
if|if
condition|(
name|props
operator|->
name|state
operator|==
name|IB_PORT_DOWN
condition|)
name|props
operator|->
name|active_speed
operator|=
name|IB_SPEED_SDR
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|out_mad
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|u8
name|state_to_phys_state
parameter_list|(
name|enum
name|ib_port_state
name|state
parameter_list|)
block|{
return|return
name|state
operator|==
name|IB_PORT_ACTIVE
condition|?
literal|5
else|:
literal|3
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eth_link_query_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|props
parameter_list|,
name|int
name|netw_view
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_iboe
modifier|*
name|iboe
init|=
operator|&
name|mdev
operator|->
name|iboe
decl_stmt|;
name|struct
name|net_device
modifier|*
name|ndev
decl_stmt|;
name|enum
name|ib_mtu
name|tmp
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|is_bonded
init|=
name|mlx4_is_bonded
argument_list|(
name|mdev
operator|->
name|dev
argument_list|)
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|mdev
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|props
operator|->
name|active_width
operator|=
operator|(
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|)
index|[
literal|5
index|]
operator|==
literal|0x40
operator|)
condition|?
name|IB_WIDTH_4X
else|:
name|IB_WIDTH_1X
expr_stmt|;
name|props
operator|->
name|active_speed
operator|=
name|IB_SPEED_QDR
expr_stmt|;
name|props
operator|->
name|port_cap_flags
operator|=
name|IB_PORT_CM_SUP
operator||
name|IB_PORT_IP_BASED_GIDS
expr_stmt|;
name|props
operator|->
name|gid_tbl_len
operator|=
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
expr_stmt|;
name|props
operator|->
name|max_msg_sz
operator|=
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_msg_sz
expr_stmt|;
name|props
operator|->
name|pkey_tbl_len
operator|=
literal|1
expr_stmt|;
name|props
operator|->
name|max_mtu
operator|=
name|IB_MTU_4096
expr_stmt|;
name|props
operator|->
name|max_vl_num
operator|=
literal|2
expr_stmt|;
name|props
operator|->
name|state
operator|=
name|IB_PORT_DOWN
expr_stmt|;
name|props
operator|->
name|phys_state
operator|=
name|state_to_phys_state
argument_list|(
name|props
operator|->
name|state
argument_list|)
expr_stmt|;
name|props
operator|->
name|active_mtu
operator|=
name|IB_MTU_256
expr_stmt|;
name|spin_lock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ndev
operator|=
name|iboe
operator|->
name|netdevs
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ndev
operator|&&
name|is_bonded
condition|)
block|{
if|#
directive|if
literal|0
block|rcu_read_lock();
comment|/* required to get upper dev */
block|ndev = netdev_master_upper_dev_get_rcu(ndev); 		rcu_read_unlock();
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|ndev
condition|)
goto|goto
name|out_unlock
goto|;
name|tmp
operator|=
name|iboe_get_mtu
argument_list|(
name|ndev
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|props
operator|->
name|active_mtu
operator|=
name|tmp
condition|?
name|min
argument_list|(
name|props
operator|->
name|max_mtu
argument_list|,
name|tmp
argument_list|)
else|:
name|IB_MTU_256
expr_stmt|;
name|props
operator|->
name|state
operator|=
operator|(
name|netif_running
argument_list|(
name|ndev
argument_list|)
operator|&&
name|netif_carrier_ok
argument_list|(
name|ndev
argument_list|)
operator|)
condition|?
name|IB_PORT_ACTIVE
else|:
name|IB_PORT_DOWN
expr_stmt|;
name|props
operator|->
name|phys_state
operator|=
name|state_to_phys_state
argument_list|(
name|props
operator|->
name|state
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|spin_unlock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|__mlx4_ib_query_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|props
parameter_list|,
name|int
name|netw_view
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|memset
argument_list|(
name|props
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|props
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_ib_port_link_layer
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|)
operator|==
name|IB_LINK_LAYER_INFINIBAND
condition|?
name|ib_link_query_port
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
name|props
argument_list|,
name|netw_view
argument_list|)
else|:
name|eth_link_query_port
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
name|props
argument_list|,
name|netw_view
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_query_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|props
parameter_list|)
block|{
comment|/* returns host view */
return|return
name|__mlx4_ib_query_port
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
name|props
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|__mlx4_ib_query_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|index
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|int
name|netw_view
parameter_list|)
block|{
name|struct
name|ib_smp
modifier|*
name|in_mad
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|out_mad
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|int
name|clear
init|=
literal|0
decl_stmt|;
name|int
name|mad_ifc_flags
init|=
name|MLX4_MAD_IFC_IGNORE_KEYS
decl_stmt|;
name|in_mad
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|in_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|out_mad
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|out_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_mad
operator|||
operator|!
name|out_mad
condition|)
goto|goto
name|out
goto|;
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_PORT_INFO
expr_stmt|;
name|in_mad
operator|->
name|attr_mod
operator|=
name|cpu_to_be32
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|&&
name|netw_view
condition|)
name|mad_ifc_flags
operator||=
name|MLX4_MAD_IFC_NET_VIEW
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|dev
argument_list|,
name|mad_ifc_flags
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
name|gid
operator|->
name|raw
argument_list|,
name|out_mad
operator|->
name|data
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|&&
operator|!
name|netw_view
condition|)
block|{
if|if
condition|(
name|index
condition|)
block|{
comment|/* For any index> 0, return the null guid */
name|err
operator|=
literal|0
expr_stmt|;
name|clear
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_GUID_INFO
expr_stmt|;
name|in_mad
operator|->
name|attr_mod
operator|=
name|cpu_to_be32
argument_list|(
name|index
operator|/
literal|8
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|dev
argument_list|,
name|mad_ifc_flags
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
name|gid
operator|->
name|raw
operator|+
literal|8
argument_list|,
name|out_mad
operator|->
name|data
operator|+
operator|(
name|index
operator|%
literal|8
operator|)
operator|*
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|clear
condition|)
name|memset
argument_list|(
name|gid
operator|->
name|raw
operator|+
literal|8
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|out_mad
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_query_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|index
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|rdma_protocol_ib
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|)
condition|)
return|return
name|__mlx4_ib_query_gid
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
name|index
argument_list|,
name|gid
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|rdma_protocol_roce
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
if|if
condition|(
operator|!
name|rdma_cap_roce_gid_table
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|ret
operator|=
name|ib_get_cached_gid
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
name|index
argument_list|,
name|gid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EAGAIN
condition|)
block|{
name|memcpy
argument_list|(
name|gid
argument_list|,
operator|&
name|zgid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gid
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_query_sl2vl
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u64
modifier|*
name|sl2vl_tbl
parameter_list|)
block|{
name|union
name|sl2vl_tbl_to_u64
name|sl2vl64
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|in_mad
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|out_mad
init|=
name|NULL
decl_stmt|;
name|int
name|mad_ifc_flags
init|=
name|MLX4_MAD_IFC_IGNORE_KEYS
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|int
name|jj
decl_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|)
condition|)
block|{
operator|*
name|sl2vl_tbl
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|in_mad
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|in_mad
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|out_mad
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|out_mad
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_mad
operator|||
operator|!
name|out_mad
condition|)
goto|goto
name|out
goto|;
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_SL_TO_VL_TABLE
expr_stmt|;
name|in_mad
operator|->
name|attr_mod
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|)
condition|)
name|mad_ifc_flags
operator||=
name|MLX4_MAD_IFC_NET_VIEW
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
argument_list|,
name|mad_ifc_flags
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
literal|8
condition|;
name|jj
operator|++
control|)
name|sl2vl64
operator|.
name|sl8
index|[
name|jj
index|]
operator|=
operator|(
operator|(
expr|struct
name|ib_smp
operator|*
operator|)
name|out_mad
operator|)
operator|->
name|data
index|[
name|jj
index|]
expr_stmt|;
operator|*
name|sl2vl_tbl
operator|=
name|sl2vl64
operator|.
name|sl64
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|out_mad
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_init_sl2vl_tbl
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|u64
name|sl2vl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
continue|continue;
name|err
operator|=
name|mlx4_ib_query_sl2vl
argument_list|(
operator|&
name|mdev
operator|->
name|ib_dev
argument_list|,
name|i
argument_list|,
operator|&
name|sl2vl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_err
argument_list|(
literal|"Unable to get default sl to vl mapping for port %d.  Using all zeroes (%d)\n"
argument_list|,
name|i
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sl2vl
operator|=
literal|0
expr_stmt|;
block|}
name|atomic64_set
argument_list|(
operator|&
name|mdev
operator|->
name|sl2vl
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|sl2vl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|__mlx4_ib_query_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|,
name|int
name|netw_view
parameter_list|)
block|{
name|struct
name|ib_smp
modifier|*
name|in_mad
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|out_mad
init|=
name|NULL
decl_stmt|;
name|int
name|mad_ifc_flags
init|=
name|MLX4_MAD_IFC_IGNORE_KEYS
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|in_mad
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|in_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|out_mad
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|out_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_mad
operator|||
operator|!
name|out_mad
condition|)
goto|goto
name|out
goto|;
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_PKEY_TABLE
expr_stmt|;
name|in_mad
operator|->
name|attr_mod
operator|=
name|cpu_to_be32
argument_list|(
name|index
operator|/
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|)
operator|&&
name|netw_view
condition|)
name|mad_ifc_flags
operator||=
name|MLX4_MAD_IFC_NET_VIEW
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
argument_list|,
name|mad_ifc_flags
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
operator|*
name|pkey
operator|=
name|be16_to_cpu
argument_list|(
operator|(
operator|(
name|__be16
operator|*
operator|)
name|out_mad
operator|->
name|data
operator|)
index|[
name|index
operator|%
literal|32
index|]
argument_list|)
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|out_mad
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_query_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|)
block|{
return|return
name|__mlx4_ib_query_pkey
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
name|index
argument_list|,
name|pkey
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_modify_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|int
name|mask
parameter_list|,
name|struct
name|ib_device_modify
modifier|*
name|props
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|mask
operator|&
operator|~
name|IB_DEVICE_MODIFY_NODE_DESC
condition|)
return|return
operator|-
name|EOPNOTSUPP
return|;
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|IB_DEVICE_MODIFY_NODE_DESC
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|)
condition|)
return|return
operator|-
name|EOPNOTSUPP
return|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|sm_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ibdev
operator|->
name|node_desc
argument_list|,
name|props
operator|->
name|node_desc
argument_list|,
name|IB_DEVICE_NODE_DESC_MAX
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|sm_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * If possible, pass node desc to FW, so it can generate 	 * a 144 trap.  If cmd fails, just ignore. 	 */
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
name|props
operator|->
name|node_desc
argument_list|,
name|IB_DEVICE_NODE_DESC_MAX
argument_list|)
expr_stmt|;
name|mlx4_cmd
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_SET_NODE
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_SET_PORT
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|reset_qkey_viols
parameter_list|,
name|u32
name|cap_mask
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_OLD_PORT_CMDS
condition|)
block|{
operator|*
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|=
operator|!
operator|!
name|reset_qkey_viols
operator|<<
literal|6
expr_stmt|;
operator|(
operator|(
name|__be32
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|)
index|[
literal|2
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|cap_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|)
index|[
literal|3
index|]
operator|=
operator|!
operator|!
name|reset_qkey_viols
expr_stmt|;
operator|(
operator|(
name|__be32
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|)
index|[
literal|1
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|cap_mask
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
name|MLX4_SET_PORT_IB_OPCODE
argument_list|,
name|MLX4_CMD_SET_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_modify_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|mask
parameter_list|,
name|struct
name|ib_port_modify
modifier|*
name|props
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|u8
name|is_eth
init|=
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
decl_stmt|;
name|struct
name|ib_port_attr
name|attr
decl_stmt|;
name|u32
name|cap_mask
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* return OK if this is RoCE. CM calls ib_modify_port() regardless 	 * of whether port link layer is ETH or IB. For ETH ports, qkey 	 * violations and port capabilities are not meaningful. 	 */
if|if
condition|(
name|is_eth
condition|)
return|return
literal|0
return|;
name|mutex_lock
argument_list|(
operator|&
name|mdev
operator|->
name|cap_mask_mutex
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_ib_query_port
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|cap_mask
operator|=
operator|(
name|attr
operator|.
name|port_cap_flags
operator||
name|props
operator|->
name|set_port_cap_mask
operator|)
operator|&
operator|~
name|props
operator|->
name|clr_port_cap_mask
expr_stmt|;
name|err
operator|=
name|mlx4_ib_SET_PORT
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|,
operator|!
operator|!
operator|(
name|mask
operator|&
name|IB_PORT_RESET_QKEY_CNTR
operator|)
argument_list|,
name|cap_mask
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|cap_mask_mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_ucontext
modifier|*
name|mlx4_ib_alloc_ucontext
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_ucontext
modifier|*
name|context
decl_stmt|;
name|struct
name|mlx4_ib_alloc_ucontext_resp_v3
name|resp_v3
decl_stmt|;
name|struct
name|mlx4_ib_alloc_ucontext_resp
name|resp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|ib_active
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EAGAIN
argument_list|)
return|;
if|if
condition|(
name|ibdev
operator|->
name|uverbs_abi_ver
operator|==
name|MLX4_IB_UVERBS_NO_DEV_CAPS_ABI_VERSION
condition|)
block|{
name|resp_v3
operator|.
name|qp_tab_size
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_qps
expr_stmt|;
name|resp_v3
operator|.
name|bf_reg_size
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
expr_stmt|;
name|resp_v3
operator|.
name|bf_regs_per_page
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bf_regs_per_page
expr_stmt|;
block|}
else|else
block|{
name|resp
operator|.
name|dev_caps
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
expr_stmt|;
name|resp
operator|.
name|qp_tab_size
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_qps
expr_stmt|;
name|resp
operator|.
name|bf_reg_size
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
expr_stmt|;
name|resp
operator|.
name|bf_regs_per_page
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bf_regs_per_page
expr_stmt|;
name|resp
operator|.
name|cqe_size
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|cqe_size
expr_stmt|;
block|}
name|context
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_uar_alloc
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|context
operator|->
name|uar
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kfree
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|context
operator|->
name|db_page_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|context
operator|->
name|db_page_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibdev
operator|->
name|uverbs_abi_ver
operator|==
name|MLX4_IB_UVERBS_NO_DEV_CAPS_ABI_VERSION
condition|)
name|err
operator|=
name|ib_copy_to_udata
argument_list|(
name|udata
argument_list|,
operator|&
name|resp_v3
argument_list|,
sizeof|sizeof
argument_list|(
name|resp_v3
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|ib_copy_to_udata
argument_list|(
name|udata
argument_list|,
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_uar_free
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|context
operator|->
name|uar
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EFAULT
argument_list|)
return|;
block|}
return|return
operator|&
name|context
operator|->
name|ibucontext
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_dealloc_ucontext
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|ibcontext
parameter_list|)
block|{
name|struct
name|mlx4_ib_ucontext
modifier|*
name|context
init|=
name|to_mucontext
argument_list|(
name|ibcontext
argument_list|)
decl_stmt|;
name|mlx4_uar_free
argument_list|(
name|to_mdev
argument_list|(
name|ibcontext
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|context
operator|->
name|uar
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_vma_open
parameter_list|(
name|struct
name|vm_area_struct
modifier|*
name|area
parameter_list|)
block|{
comment|/* vma_open is called when a new VMA is created on top of our VMA. 	 * This is done through either mremap flow or split_vma (usually due 	 * to mlock, madvise, munmap, etc.). We do not support a clone of the 	 * vma, as this VMA is strongly hardware related. Therefore we set the 	 * vm_ops of the newly created/cloned VMA to NULL, to prevent it from 	 * calling us again and trying to do incorrect actions. We assume that 	 * the original vma size is exactly a single page that there will be no 	 * "splitting" operations on. 	 */
name|area
operator|->
name|vm_ops
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_vma_close
parameter_list|(
name|struct
name|vm_area_struct
modifier|*
name|area
parameter_list|)
block|{
name|struct
name|mlx4_ib_vma_private_data
modifier|*
name|mlx4_ib_vma_priv_data
decl_stmt|;
comment|/* It's guaranteed that all VMAs opened on a FD are closed before the 	 * file itself is closed, therefore no sync is needed with the regular 	 * closing flow. (e.g. mlx4_ib_dealloc_ucontext) However need a sync 	 * with accessing the vma as part of mlx4_ib_disassociate_ucontext. 	 * The close operation is usually called under mm->mmap_sem except when 	 * process is exiting.  The exiting case is handled explicitly as part 	 * of mlx4_ib_disassociate_ucontext. 	 */
name|mlx4_ib_vma_priv_data
operator|=
operator|(
expr|struct
name|mlx4_ib_vma_private_data
operator|*
operator|)
name|area
operator|->
name|vm_private_data
expr_stmt|;
comment|/* set the vma context pointer to null in the mlx4_ib driver's private 	 * data to protect against a race condition in mlx4_ib_dissassociate_ucontext(). 	 */
name|mlx4_ib_vma_priv_data
operator|->
name|vma
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vm_operations_struct
name|mlx4_ib_vm_ops
init|=
block|{
operator|.
name|open
operator|=
name|mlx4_ib_vma_open
block|,
operator|.
name|close
operator|=
name|mlx4_ib_vma_close
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mlx4_ib_disassociate_ucontext
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|ibcontext
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|vm_area_struct
modifier|*
name|vma
decl_stmt|;
name|struct
name|mlx4_ib_ucontext
modifier|*
name|context
init|=
name|to_mucontext
argument_list|(
name|ibcontext
argument_list|)
decl_stmt|;
name|struct
name|task_struct
modifier|*
name|owning_process
init|=
name|NULL
decl_stmt|;
name|struct
name|mm_struct
modifier|*
name|owning_mm
init|=
name|NULL
decl_stmt|;
name|owning_process
operator|=
name|get_pid_task
argument_list|(
name|ibcontext
operator|->
name|tgid
argument_list|,
name|PIDTYPE_PID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owning_process
condition|)
return|return;
name|owning_mm
operator|=
name|get_task_mm
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owning_mm
condition|)
block|{
name|pr_info
argument_list|(
literal|"no mm, disassociate ucontext is pending task termination\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* make sure that task is dead before returning, it may 			 * prevent a rare case of module down in parallel to a 			 * call to mlx4_ib_vma_close. 			 */
name|put_task_struct
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|owning_process
operator|=
name|get_pid_task
argument_list|(
name|ibcontext
operator|->
name|tgid
argument_list|,
name|PIDTYPE_PID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owning_process
comment|/* || 			    owning_process->state == TASK_DEAD */
condition|)
block|{
name|pr_info
argument_list|(
literal|"disassociate ucontext done, task was terminated\n"
argument_list|)
expr_stmt|;
comment|/* in case task was dead need to release the task struct */
if|if
condition|(
name|owning_process
condition|)
name|put_task_struct
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* need to protect from a race on closing the vma as part of 	 * mlx4_ib_vma_close(). 	 */
name|down_read
argument_list|(
operator|&
name|owning_mm
operator|->
name|mmap_sem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HW_BAR_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|vma
operator|=
name|context
operator|->
name|hw_bar_info
index|[
name|i
index|]
operator|.
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|vma
condition|)
continue|continue;
name|ret
operator|=
name|zap_vma_ptes
argument_list|(
name|context
operator|->
name|hw_bar_info
index|[
name|i
index|]
operator|.
name|vma
argument_list|,
name|context
operator|->
name|hw_bar_info
index|[
name|i
index|]
operator|.
name|vma
operator|->
name|vm_start
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_err
argument_list|(
literal|"Error: zap_vma_ptes failed for index=%d, ret=%d\n"
argument_list|,
name|i
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* context going to be destroyed, should not access ops any more */
name|context
operator|->
name|hw_bar_info
index|[
name|i
index|]
operator|.
name|vma
operator|->
name|vm_ops
operator|=
name|NULL
expr_stmt|;
block|}
name|up_read
argument_list|(
operator|&
name|owning_mm
operator|->
name|mmap_sem
argument_list|)
expr_stmt|;
name|mmput
argument_list|(
name|owning_mm
argument_list|)
expr_stmt|;
name|put_task_struct
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_set_vma_data
parameter_list|(
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|,
name|struct
name|mlx4_ib_vma_private_data
modifier|*
name|vma_private_data
parameter_list|)
block|{
name|vma_private_data
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|vma
operator|->
name|vm_private_data
operator|=
name|vma_private_data
expr_stmt|;
name|vma
operator|->
name|vm_ops
operator|=
operator|&
name|mlx4_ib_vm_ops
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_mmap
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|context
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_ucontext
modifier|*
name|mucontext
init|=
name|to_mucontext
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|vma
operator|->
name|vm_end
operator|-
name|vma
operator|->
name|vm_start
operator|!=
name|PAGE_SIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|vma
operator|->
name|vm_pgoff
operator|==
literal|0
condition|)
block|{
comment|/* We prevent double mmaping on same context */
if|if
condition|(
name|mucontext
operator|->
name|hw_bar_info
index|[
name|HW_BAR_DB
index|]
operator|.
name|vma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|vma
operator|->
name|vm_page_prot
operator|=
name|pgprot_noncached
argument_list|(
name|vma
operator|->
name|vm_page_prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_remap_pfn_range
argument_list|(
name|vma
argument_list|,
name|vma
operator|->
name|vm_start
argument_list|,
name|to_mucontext
argument_list|(
name|context
argument_list|)
operator|->
name|uar
operator|.
name|pfn
argument_list|,
name|PAGE_SIZE
argument_list|,
name|vma
operator|->
name|vm_page_prot
argument_list|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
name|mlx4_ib_set_vma_data
argument_list|(
name|vma
argument_list|,
operator|&
name|mucontext
operator|->
name|hw_bar_info
index|[
name|HW_BAR_DB
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vma
operator|->
name|vm_pgoff
operator|==
literal|1
operator|&&
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
operator|!=
literal|0
condition|)
block|{
comment|/* We prevent double mmaping on same context */
if|if
condition|(
name|mucontext
operator|->
name|hw_bar_info
index|[
name|HW_BAR_BF
index|]
operator|.
name|vma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|vma
operator|->
name|vm_page_prot
operator|=
name|pgprot_writecombine
argument_list|(
name|vma
operator|->
name|vm_page_prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_remap_pfn_range
argument_list|(
name|vma
argument_list|,
name|vma
operator|->
name|vm_start
argument_list|,
name|to_mucontext
argument_list|(
name|context
argument_list|)
operator|->
name|uar
operator|.
name|pfn
operator|+
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|,
name|PAGE_SIZE
argument_list|,
name|vma
operator|->
name|vm_page_prot
argument_list|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
name|mlx4_ib_set_vma_data
argument_list|(
name|vma
argument_list|,
operator|&
name|mucontext
operator|->
name|hw_bar_info
index|[
name|HW_BAR_BF
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vma
operator|->
name|vm_pgoff
operator|==
literal|3
condition|)
block|{
name|struct
name|mlx4_clock_params
name|params
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* We prevent double mmaping on same context */
if|if
condition|(
name|mucontext
operator|->
name|hw_bar_info
index|[
name|HW_BAR_CLOCK
index|]
operator|.
name|vma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|mlx4_get_internal_clock_params
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|vma
operator|->
name|vm_page_prot
operator|=
name|pgprot_noncached
argument_list|(
name|vma
operator|->
name|vm_page_prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_remap_pfn_range
argument_list|(
name|vma
argument_list|,
name|vma
operator|->
name|vm_start
argument_list|,
operator|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
name|params
operator|.
name|bar
argument_list|)
operator|+
name|params
operator|.
name|offset
operator|)
operator|>>
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|,
name|vma
operator|->
name|vm_page_prot
argument_list|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
name|mlx4_ib_set_vma_data
argument_list|(
name|vma
argument_list|,
operator|&
name|mucontext
operator|->
name|hw_bar_info
index|[
name|HW_BAR_CLOCK
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_pd
modifier|*
name|mlx4_ib_alloc_pd
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx4_ib_pd
modifier|*
name|pd
decl_stmt|;
name|int
name|err
decl_stmt|;
name|pd
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pd
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_pd_alloc
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|pd
operator|->
name|pdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kfree
argument_list|(
name|pd
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|context
condition|)
if|if
condition|(
name|ib_copy_to_udata
argument_list|(
name|udata
argument_list|,
operator|&
name|pd
operator|->
name|pdn
argument_list|,
sizeof|sizeof
argument_list|(
name|__u32
argument_list|)
argument_list|)
condition|)
block|{
name|mlx4_pd_free
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
name|pd
operator|->
name|pdn
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pd
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EFAULT
argument_list|)
return|;
block|}
return|return
operator|&
name|pd
operator|->
name|ibpd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_dealloc_pd
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|)
block|{
name|mlx4_pd_free
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_xrcd
modifier|*
name|mlx4_ib_alloc_xrcd
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx4_ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
name|struct
name|ib_cq_init_attr
name|cq_attr
init|=
block|{}
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOSYS
argument_list|)
return|;
name|xrcd
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|xrcd
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xrcd
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_xrcd_alloc
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|xrcd
operator|->
name|xrcdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err1
goto|;
name|xrcd
operator|->
name|pd
operator|=
name|ib_alloc_pd
argument_list|(
name|ibdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|xrcd
operator|->
name|pd
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|xrcd
operator|->
name|pd
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|cq_attr
operator|.
name|cqe
operator|=
literal|1
expr_stmt|;
name|xrcd
operator|->
name|cq
operator|=
name|ib_create_cq
argument_list|(
name|ibdev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|xrcd
argument_list|,
operator|&
name|cq_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|xrcd
operator|->
name|cq
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|xrcd
operator|->
name|cq
argument_list|)
expr_stmt|;
goto|goto
name|err3
goto|;
block|}
return|return
operator|&
name|xrcd
operator|->
name|ibxrcd
return|;
name|err3
label|:
name|ib_dealloc_pd
argument_list|(
name|xrcd
operator|->
name|pd
argument_list|)
expr_stmt|;
name|err2
label|:
name|mlx4_xrcd_free
argument_list|(
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
operator|->
name|dev
argument_list|,
name|xrcd
operator|->
name|xrcdn
argument_list|)
expr_stmt|;
name|err1
label|:
name|kfree
argument_list|(
name|xrcd
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_dealloc_xrcd
parameter_list|(
name|struct
name|ib_xrcd
modifier|*
name|xrcd
parameter_list|)
block|{
name|ib_destroy_cq
argument_list|(
name|to_mxrcd
argument_list|(
name|xrcd
argument_list|)
operator|->
name|cq
argument_list|)
expr_stmt|;
name|ib_dealloc_pd
argument_list|(
name|to_mxrcd
argument_list|(
name|xrcd
argument_list|)
operator|->
name|pd
argument_list|)
expr_stmt|;
name|mlx4_xrcd_free
argument_list|(
name|to_mdev
argument_list|(
name|xrcd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
name|to_mxrcd
argument_list|(
name|xrcd
argument_list|)
operator|->
name|xrcdn
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|xrcd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_gid_entry
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|)
block|{
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|ge
decl_stmt|;
name|ge
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ge
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ge
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ge
operator|->
name|gid
operator|=
operator|*
name|gid
expr_stmt|;
if|if
condition|(
name|mlx4_ib_add_mc
argument_list|(
name|mdev
argument_list|,
name|mqp
argument_list|,
name|gid
argument_list|)
condition|)
block|{
name|ge
operator|->
name|port
operator|=
name|mqp
operator|->
name|port
expr_stmt|;
name|ge
operator|->
name|added
operator|=
literal|1
expr_stmt|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|ge
operator|->
name|list
argument_list|,
operator|&
name|mqp
operator|->
name|gid_list
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_delete_counters_table
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|struct
name|mlx4_ib_counters
modifier|*
name|ctr_table
parameter_list|)
block|{
name|struct
name|counter_index
modifier|*
name|counter
decl_stmt|,
modifier|*
name|tmp_count
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|ctr_table
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|counter
argument_list|,
argument|tmp_count
argument_list|,
argument|&ctr_table->counters_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|counter
operator|->
name|allocated
condition|)
name|mlx4_counter_free
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|counter
operator|->
name|index
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|counter
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|counter
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|ctr_table
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_add_mc
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|ndev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|mqp
operator|->
name|port
condition|)
return|return
literal|0
return|;
name|spin_lock_bh
argument_list|(
operator|&
name|mdev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ndev
operator|=
name|mdev
operator|->
name|iboe
operator|.
name|netdevs
index|[
name|mqp
operator|->
name|port
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ndev
condition|)
name|dev_hold
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|spin_unlock_bh
argument_list|(
operator|&
name|mdev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndev
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|dev_put
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_struct
struct|struct
name|mlx4_ib_steering
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|struct
name|mlx4_flow_reg_id
name|reg_id
decl_stmt|;
name|union
name|ib_gid
name|gid
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LAST_ETH_FIELD
value|vlan_tag
end_define

begin_define
define|#
directive|define
name|LAST_IB_FIELD
value|sl
end_define

begin_define
define|#
directive|define
name|LAST_IPV4_FIELD
value|dst_ip
end_define

begin_define
define|#
directive|define
name|LAST_TCP_UDP_FIELD
value|src_port
end_define

begin_comment
comment|/* Field is the last supported field */
end_comment

begin_define
define|#
directive|define
name|FIELDS_NOT_SUPPORTED
parameter_list|(
name|filter
parameter_list|,
name|field
parameter_list|)
define|\
value|memchr_inv((void *)&filter.field  +\ 		   sizeof(filter.field), 0,\ 		   sizeof(filter) -\ 		   offsetof(typeof(filter), field) -\ 		   sizeof(filter.field))
end_define

begin_function
specifier|static
name|int
name|parse_flow_attr
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qp_num
parameter_list|,
name|union
name|ib_flow_spec
modifier|*
name|ib_spec
parameter_list|,
name|struct
name|_rule_hw
modifier|*
name|mlx4_spec
parameter_list|)
block|{
name|enum
name|mlx4_net_trans_rule_id
name|type
decl_stmt|;
switch|switch
condition|(
name|ib_spec
operator|->
name|type
condition|)
block|{
case|case
name|IB_FLOW_SPEC_ETH
case|:
if|if
condition|(
name|FIELDS_NOT_SUPPORTED
argument_list|(
name|ib_spec
operator|->
name|eth
operator|.
name|mask
argument_list|,
name|LAST_ETH_FIELD
argument_list|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
name|type
operator|=
name|MLX4_NET_TRANS_RULE_ID_ETH
expr_stmt|;
name|memcpy
argument_list|(
name|mlx4_spec
operator|->
name|eth
operator|.
name|dst_mac
argument_list|,
name|ib_spec
operator|->
name|eth
operator|.
name|val
operator|.
name|dst_mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mlx4_spec
operator|->
name|eth
operator|.
name|dst_mac_msk
argument_list|,
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|mlx4_spec
operator|->
name|eth
operator|.
name|vlan_tag
operator|=
name|ib_spec
operator|->
name|eth
operator|.
name|val
operator|.
name|vlan_tag
expr_stmt|;
name|mlx4_spec
operator|->
name|eth
operator|.
name|vlan_tag_msk
operator|=
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|vlan_tag
expr_stmt|;
break|break;
case|case
name|IB_FLOW_SPEC_IB
case|:
if|if
condition|(
name|FIELDS_NOT_SUPPORTED
argument_list|(
name|ib_spec
operator|->
name|ib
operator|.
name|mask
argument_list|,
name|LAST_IB_FIELD
argument_list|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
name|type
operator|=
name|MLX4_NET_TRANS_RULE_ID_IB
expr_stmt|;
name|mlx4_spec
operator|->
name|ib
operator|.
name|l3_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|qp_num
argument_list|)
expr_stmt|;
name|mlx4_spec
operator|->
name|ib
operator|.
name|qpn_mask
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_IB_FLOW_QPN_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_FLOW_SPEC_IPV4
case|:
if|if
condition|(
name|FIELDS_NOT_SUPPORTED
argument_list|(
name|ib_spec
operator|->
name|ipv4
operator|.
name|mask
argument_list|,
name|LAST_IPV4_FIELD
argument_list|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
name|type
operator|=
name|MLX4_NET_TRANS_RULE_ID_IPV4
expr_stmt|;
name|mlx4_spec
operator|->
name|ipv4
operator|.
name|src_ip
operator|=
name|ib_spec
operator|->
name|ipv4
operator|.
name|val
operator|.
name|src_ip
expr_stmt|;
name|mlx4_spec
operator|->
name|ipv4
operator|.
name|src_ip_msk
operator|=
name|ib_spec
operator|->
name|ipv4
operator|.
name|mask
operator|.
name|src_ip
expr_stmt|;
name|mlx4_spec
operator|->
name|ipv4
operator|.
name|dst_ip
operator|=
name|ib_spec
operator|->
name|ipv4
operator|.
name|val
operator|.
name|dst_ip
expr_stmt|;
name|mlx4_spec
operator|->
name|ipv4
operator|.
name|dst_ip_msk
operator|=
name|ib_spec
operator|->
name|ipv4
operator|.
name|mask
operator|.
name|dst_ip
expr_stmt|;
break|break;
case|case
name|IB_FLOW_SPEC_TCP
case|:
case|case
name|IB_FLOW_SPEC_UDP
case|:
if|if
condition|(
name|FIELDS_NOT_SUPPORTED
argument_list|(
name|ib_spec
operator|->
name|tcp_udp
operator|.
name|mask
argument_list|,
name|LAST_TCP_UDP_FIELD
argument_list|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
name|type
operator|=
name|ib_spec
operator|->
name|type
operator|==
name|IB_FLOW_SPEC_TCP
condition|?
name|MLX4_NET_TRANS_RULE_ID_TCP
else|:
name|MLX4_NET_TRANS_RULE_ID_UDP
expr_stmt|;
name|mlx4_spec
operator|->
name|tcp_udp
operator|.
name|dst_port
operator|=
name|ib_spec
operator|->
name|tcp_udp
operator|.
name|val
operator|.
name|dst_port
expr_stmt|;
name|mlx4_spec
operator|->
name|tcp_udp
operator|.
name|dst_port_msk
operator|=
name|ib_spec
operator|->
name|tcp_udp
operator|.
name|mask
operator|.
name|dst_port
expr_stmt|;
name|mlx4_spec
operator|->
name|tcp_udp
operator|.
name|src_port
operator|=
name|ib_spec
operator|->
name|tcp_udp
operator|.
name|val
operator|.
name|src_port
expr_stmt|;
name|mlx4_spec
operator|->
name|tcp_udp
operator|.
name|src_port_msk
operator|=
name|ib_spec
operator|->
name|tcp_udp
operator|.
name|mask
operator|.
name|src_port
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|mlx4_map_sw_to_hw_steering_id
argument_list|(
name|dev
argument_list|,
name|type
argument_list|)
operator|<
literal|0
operator|||
name|mlx4_hw_rule_sz
argument_list|(
name|dev
argument_list|,
name|type
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mlx4_spec
operator|->
name|id
operator|=
name|cpu_to_be16
argument_list|(
name|mlx4_map_sw_to_hw_steering_id
argument_list|(
name|dev
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_spec
operator|->
name|size
operator|=
name|mlx4_hw_rule_sz
argument_list|(
name|dev
argument_list|,
name|type
argument_list|)
operator|>>
literal|2
expr_stmt|;
return|return
name|mlx4_hw_rule_sz
argument_list|(
name|dev
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|default_rules
block|{
name|__u32
name|mandatory_fields
index|[
name|IB_FLOW_SPEC_SUPPORT_LAYERS
index|]
decl_stmt|;
name|__u32
name|mandatory_not_fields
index|[
name|IB_FLOW_SPEC_SUPPORT_LAYERS
index|]
decl_stmt|;
name|__u32
name|rules_create_list
index|[
name|IB_FLOW_SPEC_SUPPORT_LAYERS
index|]
decl_stmt|;
name|__u8
name|link_layer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|default_rules
name|default_table
index|[]
init|=
block|{
block|{
operator|.
name|mandatory_fields
operator|=
block|{
name|IB_FLOW_SPEC_IPV4
block|}
block|,
operator|.
name|mandatory_not_fields
operator|=
block|{
name|IB_FLOW_SPEC_ETH
block|}
block|,
operator|.
name|rules_create_list
operator|=
block|{
name|IB_FLOW_SPEC_IB
block|}
block|,
operator|.
name|link_layer
operator|=
name|IB_LINK_LAYER_INFINIBAND
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__mlx4_ib_default_rules_match
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|void
modifier|*
name|ib_flow
decl_stmt|;
specifier|const
name|struct
name|default_rules
modifier|*
name|pdefault_rules
init|=
name|default_table
decl_stmt|;
name|u8
name|link_layer
init|=
name|rdma_port_get_link_layer
argument_list|(
name|qp
operator|->
name|device
argument_list|,
name|flow_attr
operator|->
name|port
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|default_table
argument_list|)
condition|;
name|i
operator|++
operator|,
name|pdefault_rules
operator|++
control|)
block|{
name|__u32
name|field_types
index|[
name|IB_FLOW_SPEC_SUPPORT_LAYERS
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|field_types
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|field_types
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_layer
operator|!=
name|pdefault_rules
operator|->
name|link_layer
condition|)
continue|continue;
name|ib_flow
operator|=
name|flow_attr
operator|+
literal|1
expr_stmt|;
comment|/* we assume the specs are sorted */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IB_FLOW_SPEC_SUPPORT_LAYERS
operator|&&
name|j
operator|<
name|flow_attr
operator|->
name|num_of_specs
condition|;
name|k
operator|++
control|)
block|{
name|union
name|ib_flow_spec
modifier|*
name|current_flow
init|=
operator|(
expr|union
name|ib_flow_spec
operator|*
operator|)
name|ib_flow
decl_stmt|;
comment|/* same layer but different type */
if|if
condition|(
operator|(
operator|(
name|current_flow
operator|->
name|type
operator|&
name|IB_FLOW_SPEC_LAYER_MASK
operator|)
operator|==
operator|(
name|pdefault_rules
operator|->
name|mandatory_fields
index|[
name|k
index|]
operator|&
name|IB_FLOW_SPEC_LAYER_MASK
operator|)
operator|)
operator|&&
operator|(
name|current_flow
operator|->
name|type
operator|!=
name|pdefault_rules
operator|->
name|mandatory_fields
index|[
name|k
index|]
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* same layer, try match next one */
if|if
condition|(
name|current_flow
operator|->
name|type
operator|==
name|pdefault_rules
operator|->
name|mandatory_fields
index|[
name|k
index|]
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|ib_flow
operator|+=
operator|(
operator|(
expr|union
name|ib_flow_spec
operator|*
operator|)
name|ib_flow
operator|)
operator|->
name|size
expr_stmt|;
block|}
block|}
name|ib_flow
operator|=
name|flow_attr
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|flow_attr
operator|->
name|num_of_specs
condition|;
name|j
operator|++
operator|,
name|ib_flow
operator|+=
operator|(
operator|(
expr|union
name|ib_flow_spec
operator|*
operator|)
name|ib_flow
operator|)
operator|->
name|size
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IB_FLOW_SPEC_SUPPORT_LAYERS
condition|;
name|k
operator|++
control|)
comment|/* same layer and same type */
if|if
condition|(
operator|(
operator|(
expr|union
name|ib_flow_spec
operator|*
operator|)
name|ib_flow
operator|)
operator|->
name|type
operator|==
name|pdefault_rules
operator|->
name|mandatory_not_fields
index|[
name|k
index|]
condition|)
goto|goto
name|out
goto|;
return|return
name|i
return|;
block|}
name|out
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_ib_create_default_rules
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
parameter_list|,
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
specifier|const
name|struct
name|default_rules
modifier|*
name|pdefault_rules
parameter_list|,
name|struct
name|_rule_hw
modifier|*
name|mlx4_spec
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|pdefault_rules
operator|->
name|rules_create_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ret
decl_stmt|;
name|union
name|ib_flow_spec
name|ib_spec
decl_stmt|;
switch|switch
condition|(
name|pdefault_rules
operator|->
name|rules_create_list
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* no rule */
continue|continue;
case|case
name|IB_FLOW_SPEC_IB
case|:
name|ib_spec
operator|.
name|type
operator|=
name|IB_FLOW_SPEC_IB
expr_stmt|;
name|ib_spec
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_flow_spec_ib
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* invalid rule */
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* We must put empty rule, qpn is being ignored */
name|ret
operator|=
name|parse_flow_attr
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|ib_spec
argument_list|,
name|mlx4_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|pr_info
argument_list|(
literal|"invalid parsing\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mlx4_spec
operator|=
operator|(
name|void
operator|*
operator|)
name|mlx4_spec
operator|+
name|ret
expr_stmt|;
name|size
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_ib_create_flow
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|int
name|domain
parameter_list|,
name|enum
name|mlx4_net_trans_promisc_mode
name|flow_type
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ib_flow
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|qp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_net_trans_rule_hw_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|int
name|default_flow
decl_stmt|;
specifier|static
specifier|const
name|u16
name|__mlx4_domain
index|[]
init|=
block|{
index|[
name|IB_FLOW_DOMAIN_USER
index|]
operator|=
name|MLX4_DOMAIN_UVERBS
block|,
index|[
name|IB_FLOW_DOMAIN_ETHTOOL
index|]
operator|=
name|MLX4_DOMAIN_ETHTOOL
block|,
index|[
name|IB_FLOW_DOMAIN_RFS
index|]
operator|=
name|MLX4_DOMAIN_RFS
block|,
index|[
name|IB_FLOW_DOMAIN_NIC
index|]
operator|=
name|MLX4_DOMAIN_NIC
block|, 	}
decl_stmt|;
if|if
condition|(
name|flow_attr
operator|->
name|priority
operator|>
name|MLX4_IB_FLOW_MAX_PRIO
condition|)
block|{
name|pr_err
argument_list|(
literal|"Invalid priority value %d\n"
argument_list|,
name|flow_attr
operator|->
name|priority
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|domain
operator|>=
name|IB_FLOW_DOMAIN_NUM
condition|)
block|{
name|pr_err
argument_list|(
literal|"Invalid domain value %d\n"
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|mlx4_map_sw_to_hw_steering_mode
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|flow_type
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|mdev
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|ctrl
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|ctrl
operator|->
name|prio
operator|=
name|cpu_to_be16
argument_list|(
name|__mlx4_domain
index|[
name|domain
index|]
operator||
name|flow_attr
operator|->
name|priority
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|type
operator|=
name|mlx4_map_sw_to_hw_steering_mode
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|flow_type
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|port
operator|=
name|flow_attr
operator|->
name|port
expr_stmt|;
name|ctrl
operator|->
name|qpn
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
name|ib_flow
operator|=
name|flow_attr
operator|+
literal|1
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_ctrl
argument_list|)
expr_stmt|;
comment|/* Add default flows */
name|default_flow
operator|=
name|__mlx4_ib_default_rules_match
argument_list|(
name|qp
argument_list|,
name|flow_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_flow
operator|>=
literal|0
condition|)
block|{
name|ret
operator|=
name|__mlx4_ib_create_default_rules
argument_list|(
name|mdev
argument_list|,
name|qp
argument_list|,
name|default_table
operator|+
name|default_flow
argument_list|,
name|mailbox
operator|->
name|buf
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|mlx4_free_cmd_mailbox
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|size
operator|+=
name|ret
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|flow_attr
operator|->
name|num_of_specs
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|parse_flow_attr
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|qp_num
argument_list|,
name|ib_flow
argument_list|,
name|mailbox
operator|->
name|buf
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|mlx4_free_cmd_mailbox
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ib_flow
operator|+=
operator|(
operator|(
expr|union
name|ib_flow_spec
operator|*
operator|)
name|ib_flow
operator|)
operator|->
name|size
expr_stmt|;
name|size
operator|+=
name|ret
expr_stmt|;
block|}
name|ret
operator|=
name|mlx4_cmd_imm
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|reg_id
argument_list|,
name|size
operator|>>
literal|2
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_ATTACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ENOMEM
condition|)
name|pr_err
argument_list|(
literal|"mcg table is full. Fail to register network rule.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
name|ENXIO
condition|)
name|pr_err
argument_list|(
literal|"Device managed flow steering is disabled. Fail to register network rule.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
condition|)
name|pr_err
argument_list|(
literal|"Invalid argument. Fail to register network rule.\n"
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_ib_destroy_flow
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|reg_id
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|reg_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_DETACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_err
argument_list|(
literal|"Fail to detach network rule. registration id = 0x%llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|reg_id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_tunnel_steer_add
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
name|void
modifier|*
name|ib_flow
decl_stmt|;
name|union
name|ib_flow_spec
modifier|*
name|ib_spec
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|qp
operator|->
name|device
argument_list|)
operator|->
name|dev
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|tunnel_offload_mode
operator|!=
name|MLX4_TUNNEL_OFFLOAD_MODE_VXLAN
operator|||
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|==
name|MLX4_STEERING_DMFS_A0_STATIC
condition|)
return|return
literal|0
return|;
comment|/* do nothing */
name|ib_flow
operator|=
name|flow_attr
operator|+
literal|1
expr_stmt|;
name|ib_spec
operator|=
operator|(
expr|union
name|ib_flow_spec
operator|*
operator|)
name|ib_flow
expr_stmt|;
if|if
condition|(
name|ib_spec
operator|->
name|type
operator|!=
name|IB_FLOW_SPEC_ETH
operator|||
name|flow_attr
operator|->
name|num_of_specs
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* do nothing */
name|err
operator|=
name|mlx4_tunnel_steer_add
argument_list|(
name|to_mdev
argument_list|(
name|qp
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
name|ib_spec
operator|->
name|eth
operator|.
name|val
operator|.
name|dst_mac
argument_list|,
name|flow_attr
operator|->
name|port
argument_list|,
name|qp
operator|->
name|qp_num
argument_list|,
name|MLX4_DOMAIN_UVERBS
operator||
operator|(
name|flow_attr
operator|->
name|priority
operator|&
literal|0xff
operator|)
argument_list|,
name|reg_id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_add_dont_trap_rule
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|enum
name|mlx4_net_trans_promisc_mode
modifier|*
name|type
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_DMFS_UC_MC_SNIFFER
operator|)
operator|||
operator|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|==
name|MLX4_STEERING_DMFS_A0_STATIC
operator|)
operator|||
operator|(
name|flow_attr
operator|->
name|num_of_specs
operator|>
literal|1
operator|)
operator|||
operator|(
name|flow_attr
operator|->
name|priority
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|-
name|EOPNOTSUPP
return|;
block|}
if|if
condition|(
name|flow_attr
operator|->
name|num_of_specs
operator|==
literal|0
condition|)
block|{
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_MC_SNIFFER
expr_stmt|;
name|type
index|[
literal|1
index|]
operator|=
name|MLX4_FS_UC_SNIFFER
expr_stmt|;
block|}
else|else
block|{
name|union
name|ib_flow_spec
modifier|*
name|ib_spec
decl_stmt|;
name|ib_spec
operator|=
operator|(
expr|union
name|ib_flow_spec
operator|*
operator|)
operator|(
name|flow_attr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ib_spec
operator|->
name|type
operator|!=
name|IB_FLOW_SPEC_ETH
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* if all is zero than MC and UC */
if|if
condition|(
name|is_zero_ether_addr
argument_list|(
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
argument_list|)
condition|)
block|{
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_MC_SNIFFER
expr_stmt|;
name|type
index|[
literal|1
index|]
operator|=
name|MLX4_FS_UC_SNIFFER
expr_stmt|;
block|}
else|else
block|{
name|u8
name|mac
index|[
name|ETH_ALEN
index|]
init|=
block|{
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
index|[
literal|0
index|]
operator|^
literal|0x01
block|,
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
index|[
literal|1
index|]
block|,
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
index|[
literal|2
index|]
block|,
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
index|[
literal|3
index|]
block|,
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
index|[
literal|4
index|]
block|,
name|ib_spec
operator|->
name|eth
operator|.
name|mask
operator|.
name|dst_mac
index|[
literal|5
index|]
block|}
decl_stmt|;
comment|/* Above xor was only on MC bit, non empty mask is valid 			 * only if this bit is set and rest are zero. 			 */
if|if
condition|(
operator|!
name|is_zero_ether_addr
argument_list|(
operator|&
name|mac
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|is_multicast_ether_addr
argument_list|(
name|ib_spec
operator|->
name|eth
operator|.
name|val
operator|.
name|dst_mac
argument_list|)
condition|)
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_MC_SNIFFER
expr_stmt|;
else|else
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_UC_SNIFFER
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_flow
modifier|*
name|mlx4_ib_create_flow
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|int
name|domain
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_ib_flow
modifier|*
name|mflow
decl_stmt|;
name|enum
name|mlx4_net_trans_promisc_mode
name|type
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
operator|(
name|to_mdev
argument_list|(
name|qp
operator|->
name|device
argument_list|)
operator|)
operator|->
name|dev
decl_stmt|;
name|int
name|is_bonded
init|=
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|flow_attr
operator|->
name|port
operator|<
literal|1
operator|||
name|flow_attr
operator|->
name|port
operator|>
name|qp
operator|->
name|device
operator|->
name|phys_port_cnt
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
if|if
condition|(
operator|(
name|flow_attr
operator|->
name|flags
operator|&
name|IB_FLOW_ATTR_FLAGS_DONT_TRAP
operator|)
operator|&&
operator|(
name|flow_attr
operator|->
name|type
operator|!=
name|IB_FLOW_ATTR_NORMAL
operator|)
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EOPNOTSUPP
argument_list|)
return|;
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|mflow
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mflow
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mflow
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
switch|switch
condition|(
name|flow_attr
operator|->
name|type
condition|)
block|{
case|case
name|IB_FLOW_ATTR_NORMAL
case|:
comment|/* If dont trap flag (continue match) is set, under specific 		 * condition traffic be replicated to given qp, 		 * without stealing it 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|flow_attr
operator|->
name|flags
operator|&
name|IB_FLOW_ATTR_FLAGS_DONT_TRAP
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_ib_add_dont_trap_rule
argument_list|(
name|dev
argument_list|,
name|flow_attr
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
block|}
else|else
block|{
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_REGULAR
expr_stmt|;
block|}
break|break;
case|case
name|IB_FLOW_ATTR_ALL_DEFAULT
case|:
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_ALL_DEFAULT
expr_stmt|;
break|break;
case|case
name|IB_FLOW_ATTR_MC_DEFAULT
case|:
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_MC_DEFAULT
expr_stmt|;
break|break;
case|case
name|IB_FLOW_ATTR_SNIFFER
case|:
name|type
index|[
literal|0
index|]
operator|=
name|MLX4_FS_MIRROR_RX_PORT
expr_stmt|;
name|type
index|[
literal|1
index|]
operator|=
name|MLX4_FS_MIRROR_SX_PORT
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
while|while
condition|(
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|type
index|[
name|i
index|]
condition|)
block|{
name|err
operator|=
name|__mlx4_ib_create_flow
argument_list|(
name|qp
argument_list|,
name|flow_attr
argument_list|,
name|domain
argument_list|,
name|type
index|[
name|i
index|]
argument_list|,
operator|&
name|mflow
operator|->
name|reg_id
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_create_flow
goto|;
if|if
condition|(
name|is_bonded
condition|)
block|{
comment|/* Application always sees one port so the mirror rule 			 * must be on port #2 			 */
name|flow_attr
operator|->
name|port
operator|=
literal|2
expr_stmt|;
name|err
operator|=
name|__mlx4_ib_create_flow
argument_list|(
name|qp
argument_list|,
name|flow_attr
argument_list|,
name|domain
argument_list|,
name|type
index|[
name|j
index|]
argument_list|,
operator|&
name|mflow
operator|->
name|reg_id
index|[
name|j
index|]
operator|.
name|mirror
argument_list|)
expr_stmt|;
name|flow_attr
operator|->
name|port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_create_flow
goto|;
name|j
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|flow_attr
operator|->
name|type
operator|==
name|IB_FLOW_ATTR_NORMAL
condition|)
block|{
name|err
operator|=
name|mlx4_ib_tunnel_steer_add
argument_list|(
name|qp
argument_list|,
name|flow_attr
argument_list|,
operator|&
name|mflow
operator|->
name|reg_id
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_create_flow
goto|;
if|if
condition|(
name|is_bonded
condition|)
block|{
name|flow_attr
operator|->
name|port
operator|=
literal|2
expr_stmt|;
name|err
operator|=
name|mlx4_ib_tunnel_steer_add
argument_list|(
name|qp
argument_list|,
name|flow_attr
argument_list|,
operator|&
name|mflow
operator|->
name|reg_id
index|[
name|j
index|]
operator|.
name|mirror
argument_list|)
expr_stmt|;
name|flow_attr
operator|->
name|port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_create_flow
goto|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* function to create mirror rule */
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|&
name|mflow
operator|->
name|ibflow
return|;
name|err_create_flow
label|:
while|while
condition|(
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|__mlx4_ib_destroy_flow
argument_list|(
name|to_mdev
argument_list|(
name|qp
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
name|mflow
operator|->
name|reg_id
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|j
condition|)
block|{
operator|(
name|void
operator|)
name|__mlx4_ib_destroy_flow
argument_list|(
name|to_mdev
argument_list|(
name|qp
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
name|mflow
operator|->
name|reg_id
index|[
name|j
index|]
operator|.
name|mirror
argument_list|)
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|err_free
label|:
name|kfree
argument_list|(
name|mflow
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_destroy_flow
parameter_list|(
name|struct
name|ib_flow
modifier|*
name|flow_id
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|flow_id
operator|->
name|qp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_flow
modifier|*
name|mflow
init|=
name|to_mflow
argument_list|(
name|flow_id
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mflow
operator|->
name|reg_id
argument_list|)
operator|&&
name|mflow
operator|->
name|reg_id
index|[
name|i
index|]
operator|.
name|id
condition|)
block|{
name|err
operator|=
name|__mlx4_ib_destroy_flow
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mflow
operator|->
name|reg_id
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|ret
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|mflow
operator|->
name|reg_id
index|[
name|i
index|]
operator|.
name|mirror
condition|)
block|{
name|err
operator|=
name|__mlx4_ib_destroy_flow
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mflow
operator|->
name|reg_id
index|[
name|i
index|]
operator|.
name|mirror
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|ret
operator|=
name|err
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|kfree
argument_list|(
name|mflow
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_mcg_attach
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|mdev
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_steering
modifier|*
name|ib_steering
init|=
name|NULL
decl_stmt|;
name|enum
name|mlx4_protocol
name|prot
init|=
name|MLX4_PROT_IB_IPV6
decl_stmt|;
name|struct
name|mlx4_flow_reg_id
name|reg_id
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|ib_steering
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ib_steering
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_steering
condition|)
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_multicast_attach
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|mqp
operator|->
name|mqp
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
name|mqp
operator|->
name|port
argument_list|,
operator|!
operator|!
operator|(
name|mqp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK
operator|)
argument_list|,
name|prot
argument_list|,
operator|&
name|reg_id
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_err
argument_list|(
literal|"multicast attach op failed, err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_malloc
goto|;
block|}
name|reg_id
operator|.
name|mirror
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_multicast_attach
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|mqp
operator|->
name|mqp
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
operator|(
name|mqp
operator|->
name|port
operator|==
literal|1
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|,
operator|!
operator|!
operator|(
name|mqp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK
operator|)
argument_list|,
name|prot
argument_list|,
operator|&
name|reg_id
operator|.
name|mirror
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_add
goto|;
block|}
name|err
operator|=
name|add_gid_entry
argument_list|(
name|ibqp
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_add
goto|;
if|if
condition|(
name|ib_steering
condition|)
block|{
name|memcpy
argument_list|(
name|ib_steering
operator|->
name|gid
operator|.
name|raw
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ib_steering
operator|->
name|reg_id
operator|=
name|reg_id
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|ib_steering
operator|->
name|list
argument_list|,
operator|&
name|mqp
operator|->
name|steering_rules
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err_add
label|:
name|mlx4_multicast_detach
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|mqp
operator|->
name|mqp
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
name|prot
argument_list|,
name|reg_id
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_id
operator|.
name|mirror
condition|)
name|mlx4_multicast_detach
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|mqp
operator|->
name|mqp
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
name|prot
argument_list|,
name|reg_id
operator|.
name|mirror
argument_list|)
expr_stmt|;
name|err_malloc
label|:
name|kfree
argument_list|(
name|ib_steering
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|find_gid_entry
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|u8
modifier|*
name|raw
parameter_list|)
block|{
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|ge
decl_stmt|;
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|tmp
decl_stmt|;
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|ge
argument_list|,
argument|tmp
argument_list|,
argument|&qp->gid_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|raw
argument_list|,
name|ge
operator|->
name|gid
operator|.
name|raw
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|ret
operator|=
name|ge
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_mcg_detach
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|mdev
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|struct
name|net_device
modifier|*
name|ndev
decl_stmt|;
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|ge
decl_stmt|;
name|struct
name|mlx4_flow_reg_id
name|reg_id
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|enum
name|mlx4_protocol
name|prot
init|=
name|MLX4_PROT_IB_IPV6
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|struct
name|mlx4_ib_steering
modifier|*
name|ib_steering
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|ib_steering
argument_list|,
argument|&mqp->steering_rules
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ib_steering
operator|->
name|gid
operator|.
name|raw
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|ib_steering
operator|->
name|list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|ib_steering
operator|->
name|list
operator|==
operator|&
name|mqp
operator|->
name|steering_rules
condition|)
block|{
name|pr_err
argument_list|(
literal|"Couldn't find reg_id for mgid. Steering rule is left attached\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|reg_id
operator|=
name|ib_steering
operator|->
name|reg_id
expr_stmt|;
name|kfree
argument_list|(
name|ib_steering
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|mlx4_multicast_detach
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|mqp
operator|->
name|mqp
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
name|prot
argument_list|,
name|reg_id
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_multicast_detach
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|mqp
operator|->
name|mqp
argument_list|,
name|gid
operator|->
name|raw
argument_list|,
name|prot
argument_list|,
name|reg_id
operator|.
name|mirror
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|ge
operator|=
name|find_gid_entry
argument_list|(
name|mqp
argument_list|,
name|gid
operator|->
name|raw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ge
condition|)
block|{
name|spin_lock_bh
argument_list|(
operator|&
name|mdev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ndev
operator|=
name|ge
operator|->
name|added
condition|?
name|mdev
operator|->
name|iboe
operator|.
name|netdevs
index|[
name|ge
operator|->
name|port
operator|-
literal|1
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|ndev
condition|)
name|dev_hold
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|spin_unlock_bh
argument_list|(
operator|&
name|mdev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndev
condition|)
name|dev_put
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|ge
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ge
argument_list|)
expr_stmt|;
block|}
else|else
name|pr_warn
argument_list|(
literal|"could not find mgid entry\n"
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|mqp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_node_data
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|ib_smp
modifier|*
name|in_mad
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|out_mad
init|=
name|NULL
decl_stmt|;
name|int
name|mad_ifc_flags
init|=
name|MLX4_MAD_IFC_IGNORE_KEYS
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|in_mad
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|in_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|out_mad
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|out_mad
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_mad
operator|||
operator|!
name|out_mad
condition|)
goto|goto
name|out
goto|;
name|init_query_mad
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_NODE_DESC
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
name|mad_ifc_flags
operator||=
name|MLX4_MAD_IFC_NET_VIEW
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|dev
argument_list|,
name|mad_ifc_flags
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
name|dev
operator|->
name|ib_dev
operator|.
name|node_desc
argument_list|,
name|out_mad
operator|->
name|data
argument_list|,
name|IB_DEVICE_NODE_DESC_MAX
argument_list|)
expr_stmt|;
name|in_mad
operator|->
name|attr_id
operator|=
name|IB_SMP_ATTR_NODE_INFO
expr_stmt|;
name|err
operator|=
name|mlx4_MAD_IFC
argument_list|(
name|dev
argument_list|,
name|mad_ifc_flags
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|in_mad
argument_list|,
name|out_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|dev
operator|->
name|dev
operator|->
name|rev_id
operator|=
name|be32_to_cpup
argument_list|(
operator|(
name|__be32
operator|*
operator|)
operator|(
name|out_mad
operator|->
name|data
operator|+
literal|32
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
operator|.
name|node_guid
argument_list|,
name|out_mad
operator|->
name|data
operator|+
literal|12
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|in_mad
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|out_mad
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_hca
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|container_of
argument_list|(
name|device
argument_list|,
expr|struct
name|mlx4_ib_dev
argument_list|,
name|ib_dev
operator|.
name|dev
argument_list|)
decl_stmt|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"MT%d\n"
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|device
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_rev
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|container_of
argument_list|(
name|device
argument_list|,
expr|struct
name|mlx4_ib_dev
argument_list|,
name|ib_dev
operator|.
name|dev
argument_list|)
decl_stmt|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%x\n"
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|rev_id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_board
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|container_of
argument_list|(
name|device
argument_list|,
expr|struct
name|mlx4_ib_dev
argument_list|,
name|ib_dev
operator|.
name|dev
argument_list|)
decl_stmt|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*s\n"
argument_list|,
name|MLX4_BOARD_ID_LEN
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|board_id
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|hw_rev
argument_list|,
name|S_IRUGO
argument_list|,
name|show_rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|hca_type
argument_list|,
name|S_IRUGO
argument_list|,
name|show_hca
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|board_id
argument_list|,
name|S_IRUGO
argument_list|,
name|show_board
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|device_attribute
modifier|*
name|mlx4_class_attributes
index|[]
init|=
block|{
operator|&
name|dev_attr_hw_rev
block|,
operator|&
name|dev_attr_hca_type
block|,
operator|&
name|dev_attr_board_id
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|diag_counter
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|u32
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DIAG_COUNTER
parameter_list|(
name|_name
parameter_list|,
name|_offset
parameter_list|)
define|\
value|{ .name = #_name, .offset = _offset }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|diag_counter
name|diag_basic
index|[]
init|=
block|{
name|DIAG_COUNTER
argument_list|(
name|rq_num_lle
argument_list|,
literal|0x00
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_lle
argument_list|,
literal|0x04
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_lqpoe
argument_list|,
literal|0x08
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_lqpoe
argument_list|,
literal|0x0C
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_lpe
argument_list|,
literal|0x18
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_lpe
argument_list|,
literal|0x1C
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_wrfe
argument_list|,
literal|0x20
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_wrfe
argument_list|,
literal|0x24
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_mwbe
argument_list|,
literal|0x2C
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_bre
argument_list|,
literal|0x34
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_rire
argument_list|,
literal|0x44
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_rire
argument_list|,
literal|0x48
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_rae
argument_list|,
literal|0x4C
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_rae
argument_list|,
literal|0x50
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_roe
argument_list|,
literal|0x54
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_tree
argument_list|,
literal|0x5C
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_rree
argument_list|,
literal|0x64
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_rnr
argument_list|,
literal|0x68
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_rnr
argument_list|,
literal|0x6C
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_oos
argument_list|,
literal|0x100
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_oos
argument_list|,
literal|0x104
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|diag_counter
name|diag_ext
index|[]
init|=
block|{
name|DIAG_COUNTER
argument_list|(
name|rq_num_dup
argument_list|,
literal|0x130
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|sq_num_to
argument_list|,
literal|0x134
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|diag_counter
name|diag_device_only
index|[]
init|=
block|{
name|DIAG_COUNTER
argument_list|(
name|num_cqovf
argument_list|,
literal|0x1A0
argument_list|)
block|,
name|DIAG_COUNTER
argument_list|(
name|rq_num_udsdprd
argument_list|,
literal|0x118
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|rdma_hw_stats
modifier|*
name|mlx4_ib_alloc_hw_stats
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_diag_counters
modifier|*
name|diag
init|=
name|dev
operator|->
name|diag_counters
decl_stmt|;
if|if
condition|(
operator|!
name|diag
index|[
operator|!
operator|!
name|port_num
index|]
operator|.
name|name
condition|)
return|return
name|NULL
return|;
return|return
name|rdma_alloc_hw_stats_struct
argument_list|(
name|diag
index|[
operator|!
operator|!
name|port_num
index|]
operator|.
name|name
argument_list|,
name|diag
index|[
operator|!
operator|!
name|port_num
index|]
operator|.
name|num_counters
argument_list|,
name|RDMA_HW_STATS_DEFAULT_LIFESPAN
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_get_hw_stats
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|struct
name|rdma_hw_stats
modifier|*
name|stats
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_diag_counters
modifier|*
name|diag
init|=
name|dev
operator|->
name|diag_counters
decl_stmt|;
name|u32
name|hw_value
index|[
name|ARRAY_SIZE
argument_list|(
name|diag_device_only
argument_list|)
operator|+
name|ARRAY_SIZE
argument_list|(
name|diag_ext
argument_list|)
operator|+
name|ARRAY_SIZE
argument_list|(
name|diag_basic
argument_list|)
index|]
init|=
block|{}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ret
operator|=
name|mlx4_query_diag_counters
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|MLX4_OP_MOD_QUERY_TRANSPORT_CI_ERRORS
argument_list|,
name|diag
index|[
operator|!
operator|!
name|port
index|]
operator|.
name|offset
argument_list|,
name|hw_value
argument_list|,
name|diag
index|[
operator|!
operator|!
name|port
index|]
operator|.
name|num_counters
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diag
index|[
operator|!
operator|!
name|port
index|]
operator|.
name|num_counters
condition|;
name|i
operator|++
control|)
name|stats
operator|->
name|value
index|[
name|i
index|]
operator|=
name|hw_value
index|[
name|i
index|]
expr_stmt|;
return|return
name|diag
index|[
operator|!
operator|!
name|port
index|]
operator|.
name|num_counters
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_ib_alloc_diag_counters
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|name
parameter_list|,
name|u32
modifier|*
modifier|*
name|offset
parameter_list|,
name|u32
modifier|*
name|num
parameter_list|,
name|bool
name|port
parameter_list|)
block|{
name|u32
name|num_counters
decl_stmt|;
name|num_counters
operator|=
name|ARRAY_SIZE
argument_list|(
name|diag_basic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_DIAG_PER_PORT
condition|)
name|num_counters
operator|+=
name|ARRAY_SIZE
argument_list|(
name|diag_ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
name|num_counters
operator|+=
name|ARRAY_SIZE
argument_list|(
name|diag_device_only
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|kcalloc
argument_list|(
name|num_counters
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|name
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
return|return
operator|-
name|ENOMEM
return|;
operator|*
name|offset
operator|=
name|kcalloc
argument_list|(
name|num_counters
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|offset
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|offset
condition|)
goto|goto
name|err_name
goto|;
operator|*
name|num
operator|=
name|num_counters
expr_stmt|;
return|return
literal|0
return|;
name|err_name
label|:
name|kfree
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_fill_diag_counters
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|u32
modifier|*
name|offset
parameter_list|,
name|bool
name|port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|diag_basic
argument_list|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|name
index|[
name|i
index|]
operator|=
name|diag_basic
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|offset
index|[
name|i
index|]
operator|=
name|diag_basic
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_DIAG_PER_PORT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|diag_ext
argument_list|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|name
index|[
name|j
index|]
operator|=
name|diag_ext
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|offset
index|[
name|j
index|]
operator|=
name|diag_ext
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|port
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|diag_device_only
argument_list|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|name
index|[
name|j
index|]
operator|=
name|diag_device_only
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|offset
index|[
name|j
index|]
operator|=
name|diag_device_only
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_alloc_diag_counters
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|)
block|{
name|struct
name|mlx4_ib_diag_counters
modifier|*
name|diag
init|=
name|ibdev
operator|->
name|diag_counters
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|bool
name|per_port
init|=
operator|!
operator|!
operator|(
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_DIAG_PER_PORT
operator|)
decl_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_DIAG_COUNTERS_TYPES
condition|;
name|i
operator|++
control|)
block|{
comment|/* i == 1 means we are building port counters */
if|if
condition|(
name|i
operator|&&
operator|!
name|per_port
condition|)
continue|continue;
name|ret
operator|=
name|__mlx4_ib_alloc_diag_counters
argument_list|(
name|ibdev
argument_list|,
operator|&
name|diag
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|diag
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
operator|&
name|diag
index|[
name|i
index|]
operator|.
name|num_counters
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_alloc
goto|;
name|mlx4_ib_fill_diag_counters
argument_list|(
name|ibdev
argument_list|,
name|diag
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|diag
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|ibdev
operator|->
name|ib_dev
operator|.
name|get_hw_stats
operator|=
name|mlx4_ib_get_hw_stats
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|alloc_hw_stats
operator|=
name|mlx4_ib_alloc_hw_stats
expr_stmt|;
return|return
literal|0
return|;
name|err_alloc
label|:
if|if
condition|(
name|i
condition|)
block|{
name|kfree
argument_list|(
name|diag
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|diag
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_diag_cleanup
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_DIAG_COUNTERS_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|kfree
argument_list|(
name|ibdev
operator|->
name|diag_counters
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ibdev
operator|->
name|diag_counters
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_IB_INVALID_MAC
value|((u64)-1)
end_define

begin_function
specifier|static
name|void
name|mlx4_ib_update_qps
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|struct
name|net_device
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u64
name|new_smac
init|=
literal|0
decl_stmt|;
name|u64
name|release_mac
init|=
name|MLX4_IB_INVALID_MAC
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
decl_stmt|;
name|new_smac
operator|=
name|mlx4_mac_to_u64
argument_list|(
name|IF_LLADDR
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|atomic64_set
argument_list|(
operator|&
name|ibdev
operator|->
name|iboe
operator|.
name|mac
index|[
name|port
operator|-
literal|1
index|]
argument_list|,
name|new_smac
argument_list|)
expr_stmt|;
comment|/* no need for update QP1 and mac registration in non-SRIOV */
if|if
condition|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
return|return;
name|mutex_lock
argument_list|(
operator|&
name|ibdev
operator|->
name|qp1_proxy_lock
index|[
name|port
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|qp
operator|=
name|ibdev
operator|->
name|qp1_proxy
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|qp
condition|)
block|{
name|int
name|new_smac_index
decl_stmt|;
name|u64
name|old_smac
decl_stmt|;
name|struct
name|mlx4_update_qp_params
name|update_params
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|old_smac
operator|=
name|qp
operator|->
name|pri
operator|.
name|smac
expr_stmt|;
if|if
condition|(
name|new_smac
operator|==
name|old_smac
condition|)
goto|goto
name|unlock
goto|;
name|new_smac_index
operator|=
name|mlx4_register_mac
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|new_smac
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_smac_index
operator|<
literal|0
condition|)
goto|goto
name|unlock
goto|;
name|update_params
operator|.
name|smac_index
operator|=
name|new_smac_index
expr_stmt|;
if|if
condition|(
name|mlx4_update_qp
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|mqp
operator|.
name|qpn
argument_list|,
name|MLX4_UPDATE_QP_SMAC
argument_list|,
operator|&
name|update_params
argument_list|)
condition|)
block|{
name|release_mac
operator|=
name|new_smac
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* if old port was zero, no mac was yet registered for this QP */
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|smac_port
condition|)
name|release_mac
operator|=
name|old_smac
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|smac
operator|=
name|new_smac
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|smac_port
operator|=
name|port
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|smac_index
operator|=
name|new_smac_index
expr_stmt|;
block|}
name|unlock
label|:
if|if
condition|(
name|release_mac
operator|!=
name|MLX4_IB_INVALID_MAC
condition|)
name|mlx4_unregister_mac
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|release_mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
condition|)
name|mutex_unlock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|ibdev
operator|->
name|qp1_proxy_lock
index|[
name|port
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_scan_netdevs
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|struct
name|net_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|event
parameter_list|)
block|{
name|struct
name|mlx4_ib_iboe
modifier|*
name|iboe
decl_stmt|;
name|int
name|update_qps_port
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|port
decl_stmt|;
name|iboe
operator|=
operator|&
name|ibdev
operator|->
name|iboe
expr_stmt|;
name|spin_lock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mlx4_foreach_ib_transport_port
argument_list|(
argument|port
argument_list|,
argument|ibdev->dev
argument_list|)
block|{
name|iboe
operator|->
name|netdevs
index|[
name|port
operator|-
literal|1
index|]
operator|=
name|mlx4_get_protocol_dev
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|MLX4_PROT_ETH
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|iboe
operator|->
name|netdevs
index|[
name|port
operator|-
literal|1
index|]
operator|&&
operator|(
name|event
operator|==
name|NETDEV_CHANGEADDR
operator|||
name|event
operator|==
name|NETDEV_REGISTER
operator|||
name|event
operator|==
name|NETDEV_UP
operator|||
name|event
operator|==
name|NETDEV_CHANGE
operator|)
condition|)
name|update_qps_port
operator|=
name|port
expr_stmt|;
block|}
name|spin_unlock_bh
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_qps_port
operator|>
literal|0
condition|)
name|mlx4_ib_update_qps
argument_list|(
name|ibdev
argument_list|,
name|dev
argument_list|,
name|update_qps_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_netdev_event
parameter_list|(
name|struct
name|notifier_block
modifier|*
name|this
parameter_list|,
name|unsigned
name|long
name|event
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|dev
init|=
name|netdev_notifier_info_to_dev
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
decl_stmt|;
if|if
condition|(
operator|!
name|net_eq
argument_list|(
name|dev_net
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|init_net
argument_list|)
condition|)
return|return
name|NOTIFY_DONE
return|;
name|ibdev
operator|=
name|container_of
argument_list|(
name|this
argument_list|,
expr|struct
name|mlx4_ib_dev
argument_list|,
name|iboe
operator|.
name|nb
argument_list|)
expr_stmt|;
name|mlx4_ib_scan_netdevs
argument_list|(
name|ibdev
argument_list|,
name|dev
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
name|NOTIFY_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_pkeys
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|int
name|slave
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|slave
operator|=
literal|0
init|;
name|slave
operator|<=
name|ibdev
operator|->
name|dev
operator|->
name|persist
operator|->
name|num_vfs
condition|;
operator|++
name|slave
control|)
block|{
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|port
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ibdev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|port
index|]
condition|;
operator|++
name|i
control|)
block|{
name|ibdev
operator|->
name|pkeys
operator|.
name|virt2phys_pkey
index|[
name|slave
index|]
index|[
name|port
operator|-
literal|1
index|]
index|[
name|i
index|]
operator|=
comment|/* master has the identity virt2phys pkey mapping */
operator|(
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
operator|||
operator|!
name|i
operator|)
condition|?
name|i
else|:
name|ibdev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|port
index|]
operator|-
literal|1
expr_stmt|;
name|mlx4_sync_pkey_table
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|,
name|i
argument_list|,
name|ibdev
operator|->
name|pkeys
operator|.
name|virt2phys_pkey
index|[
name|slave
index|]
index|[
name|port
operator|-
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* initialize pkey cache */
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|port
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ibdev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|port
index|]
condition|;
operator|++
name|i
control|)
name|ibdev
operator|->
name|pkeys
operator|.
name|phys_pkey_cache
index|[
name|port
operator|-
literal|1
index|]
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|)
condition|?
literal|0
else|:
literal|0xFFFF
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_alloc_eqs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|eq
init|=
literal|0
decl_stmt|,
name|total_eqs
init|=
literal|0
decl_stmt|;
name|ibdev
operator|->
name|eq_table
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
argument_list|,
sizeof|sizeof
argument_list|(
name|ibdev
operator|->
name|eq_table
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibdev
operator|->
name|eq_table
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mlx4_get_eqs_per_port
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
operator|,
name|total_eqs
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|mlx4_is_eq_shared
argument_list|(
name|dev
argument_list|,
name|total_eqs
argument_list|)
condition|)
continue|continue;
name|ibdev
operator|->
name|eq_table
index|[
name|eq
index|]
operator|=
name|total_eqs
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_assign_eq
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|ibdev
operator|->
name|eq_table
index|[
name|eq
index|]
argument_list|)
condition|)
name|eq
operator|++
expr_stmt|;
else|else
name|ibdev
operator|->
name|eq_table
index|[
name|eq
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|eq
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
condition|;
name|ibdev
operator|->
name|eq_table
index|[
name|i
operator|++
index|]
operator|=
operator|-
literal|1
control|)
empty_stmt|;
comment|/* Advertise the new number of EQs to clients */
name|ibdev
operator|->
name|ib_dev
operator|.
name|num_comp_vectors
operator|=
name|eq
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_free_eqs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|total_eqs
init|=
name|ibdev
operator|->
name|ib_dev
operator|.
name|num_comp_vectors
decl_stmt|;
comment|/* no eqs were allocated */
if|if
condition|(
operator|!
name|ibdev
operator|->
name|eq_table
condition|)
return|return;
comment|/* Reset the advertised EQ number */
name|ibdev
operator|->
name|ib_dev
operator|.
name|num_comp_vectors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_eqs
condition|;
name|i
operator|++
control|)
name|mlx4_release_eq
argument_list|(
name|dev
argument_list|,
name|ibdev
operator|->
name|eq_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ibdev
operator|->
name|eq_table
argument_list|)
expr_stmt|;
name|ibdev
operator|->
name|eq_table
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_port_immutable
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_port_immutable
modifier|*
name|immutable
parameter_list|)
block|{
name|struct
name|ib_port_attr
name|attr
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_ib_query_port
argument_list|(
name|ibdev
argument_list|,
name|port_num
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|immutable
operator|->
name|pkey_tbl_len
operator|=
name|attr
operator|.
name|pkey_tbl_len
expr_stmt|;
name|immutable
operator|->
name|gid_tbl_len
operator|=
name|attr
operator|.
name|gid_tbl_len
expr_stmt|;
if|if
condition|(
name|mlx4_ib_port_link_layer
argument_list|(
name|ibdev
argument_list|,
name|port_num
argument_list|)
operator|==
name|IB_LINK_LAYER_INFINIBAND
condition|)
block|{
name|immutable
operator|->
name|core_cap_flags
operator|=
name|RDMA_CORE_PORT_IBA_IB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_IBOE
condition|)
name|immutable
operator|->
name|core_cap_flags
operator|=
name|RDMA_CORE_PORT_IBA_ROCE
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_ROCE_V1_V2
condition|)
name|immutable
operator|->
name|core_cap_flags
operator|=
name|RDMA_CORE_PORT_IBA_ROCE
operator||
name|RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP
expr_stmt|;
block|}
name|immutable
operator|->
name|max_mad_size
operator|=
name|IB_MGMT_MAD_SIZE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_fw_ver_str
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|str_len
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|container_of
argument_list|(
name|device
argument_list|,
expr|struct
name|mlx4_ib_dev
argument_list|,
name|ib_dev
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
name|str_len
argument_list|,
literal|"%d.%d.%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|mlx4_ib_add
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
decl_stmt|;
name|int
name|num_ports
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_ib_iboe
modifier|*
name|iboe
decl_stmt|;
name|int
name|ib_num_ports
init|=
literal|0
decl_stmt|;
name|int
name|num_req_counters
decl_stmt|;
name|int
name|allocated
decl_stmt|;
name|u32
name|counter_index
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|new_counter_index
init|=
name|NULL
decl_stmt|;
name|pr_info_once
argument_list|(
literal|"%s"
argument_list|,
name|mlx4_ib_version
argument_list|)
expr_stmt|;
name|num_ports
operator|=
literal|0
expr_stmt|;
name|mlx4_foreach_ib_transport_port
argument_list|(
argument|i
argument_list|,
argument|dev
argument_list|)
name|num_ports
operator|++
expr_stmt|;
comment|/* No point in registering a device with no ports... */
if|if
condition|(
name|num_ports
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|ibdev
operator|=
operator|(
expr|struct
name|mlx4_ib_dev
operator|*
operator|)
name|ib_alloc_device
argument_list|(
sizeof|sizeof
expr|*
name|ibdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibdev
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"Device struct alloc failed\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|iboe
operator|=
operator|&
name|ibdev
operator|->
name|iboe
expr_stmt|;
if|if
condition|(
name|mlx4_pd_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|ibdev
operator|->
name|priv_pdn
argument_list|)
condition|)
goto|goto
name|err_dealloc
goto|;
if|if
condition|(
name|mlx4_uar_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|ibdev
operator|->
name|priv_uar
argument_list|)
condition|)
goto|goto
name|err_pd
goto|;
name|ibdev
operator|->
name|uar_map
operator|=
name|ioremap
argument_list|(
operator|(
name|phys_addr_t
operator|)
name|ibdev
operator|->
name|priv_uar
operator|.
name|pfn
operator|<<
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibdev
operator|->
name|uar_map
condition|)
goto|goto
name|err_uar
goto|;
name|MLX4_INIT_DOORBELL_LOCK
argument_list|(
operator|&
name|ibdev
operator|->
name|uar_lock
argument_list|)
expr_stmt|;
name|ibdev
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ibdev
operator|->
name|bond_next_port
operator|=
literal|0
expr_stmt|;
name|strlcpy
argument_list|(
name|ibdev
operator|->
name|ib_dev
operator|.
name|name
argument_list|,
literal|"mlx4_%d"
argument_list|,
name|IB_DEVICE_NAME_MAX
argument_list|)
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|owner
operator|=
name|THIS_MODULE
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|node_type
operator|=
name|RDMA_NODE_IB_CA
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|local_dma_lkey
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_lkey
expr_stmt|;
name|ibdev
operator|->
name|num_ports
operator|=
name|num_ports
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|phys_port_cnt
operator|=
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|?
literal|1
else|:
name|ibdev
operator|->
name|num_ports
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|num_comp_vectors
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|dma_device
operator|=
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|get_netdev
operator|=
name|mlx4_ib_get_netdev
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|add_gid
operator|=
name|mlx4_ib_add_gid
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|del_gid
operator|=
name|mlx4_ib_del_gid
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
condition|)
name|ibdev
operator|->
name|ib_dev
operator|.
name|uverbs_abi_ver
operator|=
name|MLX4_IB_UVERBS_ABI_VERSION
expr_stmt|;
else|else
name|ibdev
operator|->
name|ib_dev
operator|.
name|uverbs_abi_ver
operator|=
name|MLX4_IB_UVERBS_NO_DEV_CAPS_ABI_VERSION
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|uverbs_cmd_mask
operator|=
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_GET_CONTEXT
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_QUERY_DEVICE
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_QUERY_PORT
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_ALLOC_PD
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_DEALLOC_PD
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_REG_MR
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_REREG_MR
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_DEREG_MR
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_CREATE_CQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_RESIZE_CQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_DESTROY_CQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_CREATE_QP
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_MODIFY_QP
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_QUERY_QP
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_DESTROY_QP
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_ATTACH_MCAST
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_DETACH_MCAST
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_CREATE_SRQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_MODIFY_SRQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_QUERY_SRQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_DESTROY_SRQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_CREATE_XSRQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_OPEN_QP
operator|)
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|query_device
operator|=
name|mlx4_ib_query_device
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|query_port
operator|=
name|mlx4_ib_query_port
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|get_link_layer
operator|=
name|mlx4_ib_port_link_layer
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|query_gid
operator|=
name|mlx4_ib_query_gid
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|query_pkey
operator|=
name|mlx4_ib_query_pkey
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|modify_device
operator|=
name|mlx4_ib_modify_device
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|modify_port
operator|=
name|mlx4_ib_modify_port
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|alloc_ucontext
operator|=
name|mlx4_ib_alloc_ucontext
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|dealloc_ucontext
operator|=
name|mlx4_ib_dealloc_ucontext
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|mmap
operator|=
name|mlx4_ib_mmap
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|alloc_pd
operator|=
name|mlx4_ib_alloc_pd
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|dealloc_pd
operator|=
name|mlx4_ib_dealloc_pd
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|create_ah
operator|=
name|mlx4_ib_create_ah
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|query_ah
operator|=
name|mlx4_ib_query_ah
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|destroy_ah
operator|=
name|mlx4_ib_destroy_ah
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|create_srq
operator|=
name|mlx4_ib_create_srq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|modify_srq
operator|=
name|mlx4_ib_modify_srq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|query_srq
operator|=
name|mlx4_ib_query_srq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|destroy_srq
operator|=
name|mlx4_ib_destroy_srq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|post_srq_recv
operator|=
name|mlx4_ib_post_srq_recv
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|create_qp
operator|=
name|mlx4_ib_create_qp
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|modify_qp
operator|=
name|mlx4_ib_modify_qp
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|query_qp
operator|=
name|mlx4_ib_query_qp
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|destroy_qp
operator|=
name|mlx4_ib_destroy_qp
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|post_send
operator|=
name|mlx4_ib_post_send
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|post_recv
operator|=
name|mlx4_ib_post_recv
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|create_cq
operator|=
name|mlx4_ib_create_cq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|modify_cq
operator|=
name|mlx4_ib_modify_cq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|resize_cq
operator|=
name|mlx4_ib_resize_cq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|destroy_cq
operator|=
name|mlx4_ib_destroy_cq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|poll_cq
operator|=
name|mlx4_ib_poll_cq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|req_notify_cq
operator|=
name|mlx4_ib_arm_cq
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|get_dma_mr
operator|=
name|mlx4_ib_get_dma_mr
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|reg_user_mr
operator|=
name|mlx4_ib_reg_user_mr
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|rereg_user_mr
operator|=
name|mlx4_ib_rereg_user_mr
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|dereg_mr
operator|=
name|mlx4_ib_dereg_mr
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|alloc_mr
operator|=
name|mlx4_ib_alloc_mr
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|map_mr_sg
operator|=
name|mlx4_ib_map_mr_sg
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|attach_mcast
operator|=
name|mlx4_ib_mcg_attach
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|detach_mcast
operator|=
name|mlx4_ib_mcg_detach
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|process_mad
operator|=
name|mlx4_ib_process_mad
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|get_port_immutable
operator|=
name|mlx4_port_immutable
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|get_dev_fw_str
operator|=
name|get_fw_ver_str
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|disassociate_ucontext
operator|=
name|mlx4_ib_disassociate_ucontext
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
block|{
name|ibdev
operator|->
name|ib_dev
operator|.
name|alloc_fmr
operator|=
name|mlx4_ib_fmr_alloc
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|map_phys_fmr
operator|=
name|mlx4_ib_map_phys_fmr
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|unmap_fmr
operator|=
name|mlx4_ib_unmap_fmr
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|dealloc_fmr
operator|=
name|mlx4_ib_fmr_dealloc
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_MEM_WINDOW
operator|||
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_TYPE_2_WIN
condition|)
block|{
name|ibdev
operator|->
name|ib_dev
operator|.
name|alloc_mw
operator|=
name|mlx4_ib_alloc_mw
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|dealloc_mw
operator|=
name|mlx4_ib_dealloc_mw
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|uverbs_cmd_mask
operator||=
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_ALLOC_MW
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_DEALLOC_MW
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
condition|)
block|{
name|ibdev
operator|->
name|ib_dev
operator|.
name|alloc_xrcd
operator|=
name|mlx4_ib_alloc_xrcd
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|dealloc_xrcd
operator|=
name|mlx4_ib_dealloc_xrcd
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|uverbs_cmd_mask
operator||=
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_OPEN_XRCD
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_CMD_CLOSE_XRCD
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|check_flow_steering_support
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ibdev
operator|->
name|steering_support
operator|=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|create_flow
operator|=
name|mlx4_ib_create_flow
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|destroy_flow
operator|=
name|mlx4_ib_destroy_flow
expr_stmt|;
name|ibdev
operator|->
name|ib_dev
operator|.
name|uverbs_ex_cmd_mask
operator||=
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_EX_CMD_CREATE_FLOW
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_EX_CMD_DESTROY_FLOW
operator|)
expr_stmt|;
block|}
name|ibdev
operator|->
name|ib_dev
operator|.
name|uverbs_ex_cmd_mask
operator||=
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_EX_CMD_QUERY_DEVICE
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_EX_CMD_CREATE_CQ
operator|)
operator||
operator|(
literal|1ull
operator|<<
name|IB_USER_VERBS_EX_CMD_CREATE_QP
operator|)
expr_stmt|;
name|mlx4_ib_alloc_eqs
argument_list|(
name|dev
argument_list|,
name|ibdev
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|iboe
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_node_data
argument_list|(
name|ibdev
argument_list|)
condition|)
goto|goto
name|err_map
goto|;
name|mlx4_init_sl2vl_tbl
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ibdev
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|mutex_init
argument_list|(
operator|&
name|ibdev
operator|->
name|counters_table
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ibdev
operator|->
name|counters_table
index|[
name|i
index|]
operator|.
name|counters_list
argument_list|)
expr_stmt|;
block|}
name|num_req_counters
operator|=
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|?
literal|1
else|:
name|ibdev
operator|->
name|num_ports
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_req_counters
condition|;
operator|++
name|i
control|)
block|{
name|mutex_init
argument_list|(
operator|&
name|ibdev
operator|->
name|qp1_proxy_lock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|allocated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mlx4_ib_port_link_layer
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|==
name|IB_LINK_LAYER_ETHERNET
condition|)
block|{
name|err
operator|=
name|mlx4_counter_alloc
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
operator|&
name|counter_index
argument_list|)
expr_stmt|;
comment|/* if failed to allocate a new counter, use default */
if|if
condition|(
name|err
condition|)
name|counter_index
operator|=
name|mlx4_get_default_counter_index
argument_list|(
name|dev
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|allocated
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* IB_LINK_LAYER_INFINIBAND use the default counter */
name|counter_index
operator|=
name|mlx4_get_default_counter_index
argument_list|(
name|dev
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
block|{
if|if
condition|(
name|allocated
condition|)
name|mlx4_counter_free
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|counter_index
argument_list|)
expr_stmt|;
goto|goto
name|err_counter
goto|;
block|}
name|new_counter_index
operator|->
name|index
operator|=
name|counter_index
expr_stmt|;
name|new_counter_index
operator|->
name|allocated
operator|=
name|allocated
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|ibdev
operator|->
name|counters_table
index|[
name|i
index|]
operator|.
name|counters_list
argument_list|)
expr_stmt|;
name|ibdev
operator|->
name|counters_table
index|[
name|i
index|]
operator|.
name|default_counter
operator|=
name|counter_index
expr_stmt|;
name|pr_info
argument_list|(
literal|"counter index %d for port %d allocated %d\n"
argument_list|,
name|counter_index
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|allocated
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ibdev
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
goto|goto
name|err_counter
goto|;
name|new_counter_index
operator|->
name|index
operator|=
name|counter_index
expr_stmt|;
name|new_counter_index
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|ibdev
operator|->
name|counters_table
index|[
name|i
index|]
operator|.
name|counters_list
argument_list|)
expr_stmt|;
name|ibdev
operator|->
name|counters_table
index|[
name|i
index|]
operator|.
name|default_counter
operator|=
name|counter_index
expr_stmt|;
block|}
name|mlx4_foreach_port
argument_list|(
argument|i
argument_list|,
argument|dev
argument_list|,
argument|MLX4_PORT_TYPE_IB
argument_list|)
name|ib_num_ports
operator|++
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|ibdev
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ibdev
operator|->
name|cap_mask_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ibdev
operator|->
name|qp_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|ibdev
operator|->
name|reset_flow_resource_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibdev
operator|->
name|steering_support
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
operator|&&
name|ib_num_ports
condition|)
block|{
name|ibdev
operator|->
name|steer_qpn_count
operator|=
name|MLX4_IB_UC_MAX_NUM_QPS
expr_stmt|;
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|dev
argument_list|,
name|ibdev
operator|->
name|steer_qpn_count
argument_list|,
name|MLX4_IB_UC_STEER_QPN_ALIGN
argument_list|,
operator|&
name|ibdev
operator|->
name|steer_qpn_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_counter
goto|;
name|ibdev
operator|->
name|ib_uc_qpns_bitmap
operator|=
name|kmalloc
argument_list|(
name|BITS_TO_LONGS
argument_list|(
name|ibdev
operator|->
name|steer_qpn_count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibdev
operator|->
name|ib_uc_qpns_bitmap
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"bit map alloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_steer_qp_release
goto|;
block|}
name|bitmap_zero
argument_list|(
name|ibdev
operator|->
name|ib_uc_qpns_bitmap
argument_list|,
name|ibdev
operator|->
name|steer_qpn_count
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_FLOW_STEERING_IB_UC_QP_RANGE
argument_list|(
name|dev
argument_list|,
name|ibdev
operator|->
name|steer_qpn_base
argument_list|,
name|ibdev
operator|->
name|steer_qpn_base
operator|+
name|ibdev
operator|->
name|steer_qpn_count
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_steer_free_bitmap
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|j
operator|++
control|)
name|atomic64_set
argument_list|(
operator|&
name|iboe
operator|->
name|mac
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_ib_alloc_diag_counters
argument_list|(
name|ibdev
argument_list|)
condition|)
goto|goto
name|err_steer_free_bitmap
goto|;
if|if
condition|(
name|ib_register_device
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|err_diag_counters
goto|;
if|if
condition|(
name|mlx4_ib_mad_init
argument_list|(
name|ibdev
argument_list|)
condition|)
goto|goto
name|err_reg
goto|;
if|if
condition|(
name|mlx4_ib_init_sriov
argument_list|(
name|ibdev
argument_list|)
condition|)
goto|goto
name|err_mad
goto|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_IBOE
operator|||
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_ROCE_V1_V2
condition|)
block|{
if|if
condition|(
operator|!
name|iboe
operator|->
name|nb
operator|.
name|notifier_call
condition|)
block|{
name|iboe
operator|->
name|nb
operator|.
name|notifier_call
operator|=
name|mlx4_ib_netdev_event
expr_stmt|;
name|err
operator|=
name|register_netdevice_notifier
argument_list|(
operator|&
name|iboe
operator|->
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|iboe
operator|->
name|nb
operator|.
name|notifier_call
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err_notif
goto|;
block|}
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_ROCE_V1_V2
condition|)
block|{
name|err
operator|=
name|mlx4_config_roce_v2_port
argument_list|(
name|dev
argument_list|,
name|ROCE_V2_UDP_DPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|err_notif
goto|;
block|}
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|mlx4_class_attributes
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|device_create_file
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
operator|.
name|dev
argument_list|,
name|mlx4_class_attributes
index|[
name|j
index|]
argument_list|)
condition|)
goto|goto
name|err_notif
goto|;
block|}
name|ibdev
operator|->
name|ib_active
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
name|init_pkeys
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
comment|/* create paravirt contexts for any VFs which are active */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_MFUNC_MAX
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|mlx4_master_func_num
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|mlx4_is_slave_active
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|,
name|j
argument_list|)
condition|)
name|do_slave_init
argument_list|(
name|ibdev
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ibdev
return|;
name|err_notif
label|:
if|if
condition|(
name|ibdev
operator|->
name|iboe
operator|.
name|nb
operator|.
name|notifier_call
condition|)
block|{
if|if
condition|(
name|unregister_netdevice_notifier
argument_list|(
operator|&
name|ibdev
operator|->
name|iboe
operator|.
name|nb
argument_list|)
condition|)
name|pr_warn
argument_list|(
literal|"failure unregistering notifier\n"
argument_list|)
expr_stmt|;
name|ibdev
operator|->
name|iboe
operator|.
name|nb
operator|.
name|notifier_call
operator|=
name|NULL
expr_stmt|;
block|}
name|flush_workqueue
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|mlx4_ib_close_sriov
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
name|err_mad
label|:
name|mlx4_ib_mad_cleanup
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
name|err_reg
label|:
name|ib_unregister_device
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|)
expr_stmt|;
name|err_diag_counters
label|:
name|mlx4_ib_diag_cleanup
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
name|err_steer_free_bitmap
label|:
name|kfree
argument_list|(
name|ibdev
operator|->
name|ib_uc_qpns_bitmap
argument_list|)
expr_stmt|;
name|err_steer_qp_release
label|:
if|if
condition|(
name|ibdev
operator|->
name|steering_support
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|mlx4_qp_release_range
argument_list|(
name|dev
argument_list|,
name|ibdev
operator|->
name|steer_qpn_base
argument_list|,
name|ibdev
operator|->
name|steer_qpn_count
argument_list|)
expr_stmt|;
name|err_counter
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ibdev
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
name|mlx4_ib_delete_counters_table
argument_list|(
name|ibdev
argument_list|,
operator|&
name|ibdev
operator|->
name|counters_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|err_map
label|:
name|iounmap
argument_list|(
name|ibdev
operator|->
name|uar_map
argument_list|)
expr_stmt|;
name|err_uar
label|:
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|ibdev
operator|->
name|priv_uar
argument_list|)
expr_stmt|;
name|err_pd
label|:
name|mlx4_pd_free
argument_list|(
name|dev
argument_list|,
name|ibdev
operator|->
name|priv_pdn
argument_list|)
expr_stmt|;
name|err_dealloc
label|:
name|ib_dealloc_device
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_steer_qp_alloc
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|qpn
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|dev
operator|->
name|ib_uc_qpns_bitmap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|bitmap_find_free_region
argument_list|(
name|dev
operator|->
name|ib_uc_qpns_bitmap
argument_list|,
name|dev
operator|->
name|steer_qpn_count
argument_list|,
name|get_count_order
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
name|offset
return|;
operator|*
name|qpn
operator|=
name|dev
operator|->
name|steer_qpn_base
operator|+
name|offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mlx4_ib_steer_qp_free
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qpn
operator|||
name|dev
operator|->
name|steering_support
operator|!=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
return|return;
name|BUG_ON
argument_list|(
name|qpn
operator|<
name|dev
operator|->
name|steer_qpn_base
argument_list|)
expr_stmt|;
name|bitmap_release_region
argument_list|(
name|dev
operator|->
name|ib_uc_qpns_bitmap
argument_list|,
name|qpn
operator|-
name|dev
operator|->
name|steer_qpn_base
argument_list|,
name|get_count_order
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_steer_qp_reg
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
parameter_list|,
name|int
name|is_attach
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|size_t
name|flow_size
decl_stmt|;
name|struct
name|ib_flow_attr
modifier|*
name|flow
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_flow_spec_ib
modifier|*
name|ib_spec
decl_stmt|;
if|if
condition|(
name|is_attach
condition|)
block|{
name|flow_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_flow_attr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ib_flow_spec_ib
argument_list|)
expr_stmt|;
name|flow
operator|=
name|kzalloc
argument_list|(
name|flow_size
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flow
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|flow
operator|->
name|port
operator|=
name|mqp
operator|->
name|port
expr_stmt|;
name|flow
operator|->
name|num_of_specs
operator|=
literal|1
expr_stmt|;
name|flow
operator|->
name|size
operator|=
name|flow_size
expr_stmt|;
name|ib_spec
operator|=
operator|(
expr|struct
name|ib_flow_spec_ib
operator|*
operator|)
operator|(
name|flow
operator|+
literal|1
operator|)
expr_stmt|;
name|ib_spec
operator|->
name|type
operator|=
name|IB_FLOW_SPEC_IB
expr_stmt|;
name|ib_spec
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_flow_spec_ib
argument_list|)
expr_stmt|;
comment|/* Add an empty rule for IB L2 */
name|memset
argument_list|(
operator|&
name|ib_spec
operator|->
name|mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_spec
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|__mlx4_ib_create_flow
argument_list|(
operator|&
name|mqp
operator|->
name|ibqp
argument_list|,
name|flow
argument_list|,
name|IB_FLOW_DOMAIN_NIC
argument_list|,
name|MLX4_FS_REGULAR
argument_list|,
operator|&
name|mqp
operator|->
name|reg_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|__mlx4_ib_destroy_flow
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|mqp
operator|->
name|reg_id
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|flow
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_remove
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|ibdev_ptr
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
init|=
name|ibdev_ptr
decl_stmt|;
name|int
name|p
decl_stmt|;
name|ibdev
operator|->
name|ib_active
operator|=
name|false
expr_stmt|;
name|flush_workqueue
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|mlx4_ib_close_sriov
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
name|mlx4_ib_mad_cleanup
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
name|ib_unregister_device
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|)
expr_stmt|;
name|mlx4_ib_diag_cleanup
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibdev
operator|->
name|iboe
operator|.
name|nb
operator|.
name|notifier_call
condition|)
block|{
if|if
condition|(
name|unregister_netdevice_notifier
argument_list|(
operator|&
name|ibdev
operator|->
name|iboe
operator|.
name|nb
argument_list|)
condition|)
name|pr_warn
argument_list|(
literal|"failure unregistering notifier\n"
argument_list|)
expr_stmt|;
name|ibdev
operator|->
name|iboe
operator|.
name|nb
operator|.
name|notifier_call
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ibdev
operator|->
name|steering_support
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|mlx4_qp_release_range
argument_list|(
name|dev
argument_list|,
name|ibdev
operator|->
name|steer_qpn_base
argument_list|,
name|ibdev
operator|->
name|steer_qpn_count
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ibdev
operator|->
name|ib_uc_qpns_bitmap
argument_list|)
expr_stmt|;
block|}
name|iounmap
argument_list|(
name|ibdev
operator|->
name|uar_map
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ibdev
operator|->
name|num_ports
condition|;
operator|++
name|p
control|)
name|mlx4_ib_delete_counters_table
argument_list|(
name|ibdev
argument_list|,
operator|&
name|ibdev
operator|->
name|counters_table
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|mlx4_foreach_port
argument_list|(
argument|p
argument_list|,
argument|dev
argument_list|,
argument|MLX4_PORT_TYPE_IB
argument_list|)
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|mlx4_ib_free_eqs
argument_list|(
name|dev
argument_list|,
name|ibdev
argument_list|)
expr_stmt|;
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|ibdev
operator|->
name|priv_uar
argument_list|)
expr_stmt|;
name|mlx4_pd_free
argument_list|(
name|dev
argument_list|,
name|ibdev
operator|->
name|priv_pdn
argument_list|)
expr_stmt|;
name|ib_dealloc_device
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_slave_init
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|do_init
parameter_list|)
block|{
name|struct
name|mlx4_ib_demux_work
modifier|*
modifier|*
name|dm
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|ibdev
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|mlx4_active_ports
name|actv_ports
decl_stmt|;
name|unsigned
name|int
name|ports
decl_stmt|;
name|unsigned
name|int
name|first_port
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|actv_ports
operator|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|ports
operator|=
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
name|first_port
operator|=
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
name|dm
operator|=
name|kcalloc
argument_list|(
name|ports
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dm
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dm
condition|)
block|{
name|pr_err
argument_list|(
literal|"failed to allocate memory for tunneling qp update\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ports
condition|;
name|i
operator|++
control|)
block|{
name|dm
index|[
name|i
index|]
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_demux_work
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dm
index|[
name|i
index|]
condition|)
block|{
name|pr_err
argument_list|(
literal|"failed to allocate memory for tunneling qp update work struct\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|kfree
argument_list|(
name|dm
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|INIT_WORK
argument_list|(
operator|&
name|dm
index|[
name|i
index|]
operator|->
name|work
argument_list|,
name|mlx4_ib_tunnels_update_work
argument_list|)
expr_stmt|;
name|dm
index|[
name|i
index|]
operator|->
name|port
operator|=
name|first_port
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|dm
index|[
name|i
index|]
operator|->
name|slave
operator|=
name|slave
expr_stmt|;
name|dm
index|[
name|i
index|]
operator|->
name|do_init
operator|=
name|do_init
expr_stmt|;
name|dm
index|[
name|i
index|]
operator|->
name|dev
operator|=
name|ibdev
expr_stmt|;
block|}
comment|/* initialize or tear down tunnel QPs for the slave */
name|spin_lock_irqsave
argument_list|(
operator|&
name|ibdev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibdev
operator|->
name|sriov
operator|.
name|is_going_down
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ports
condition|;
name|i
operator|++
control|)
name|queue_work
argument_list|(
name|ibdev
operator|->
name|sriov
operator|.
name|demux
index|[
name|i
index|]
operator|.
name|ud_wq
argument_list|,
operator|&
name|dm
index|[
name|i
index|]
operator|->
name|work
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ibdev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ibdev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ports
condition|;
name|i
operator|++
control|)
name|kfree
argument_list|(
name|dm
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|kfree
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_handle_catas_error
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|)
block|{
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
decl_stmt|;
name|unsigned
name|long
name|flags_qp
decl_stmt|;
name|unsigned
name|long
name|flags_cq
decl_stmt|;
name|struct
name|mlx4_ib_cq
modifier|*
name|send_mcq
decl_stmt|,
modifier|*
name|recv_mcq
decl_stmt|;
name|struct
name|list_head
name|cq_notify_list
decl_stmt|;
name|struct
name|mlx4_cq
modifier|*
name|mcq
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|pr_warn
argument_list|(
literal|"mlx4_ib_handle_catas_error was started\n"
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|cq_notify_list
argument_list|)
expr_stmt|;
comment|/* Go over qp list reside on that ibdev, sync with create/destroy qp.*/
name|spin_lock_irqsave
argument_list|(
operator|&
name|ibdev
operator|->
name|reset_flow_resource_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|mqp
argument_list|,
argument|&ibdev->qp_list
argument_list|,
argument|qps_list
argument_list|)
block|{
name|spin_lock_irqsave
argument_list|(
operator|&
name|mqp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags_qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mqp
operator|->
name|sq
operator|.
name|tail
operator|!=
name|mqp
operator|->
name|sq
operator|.
name|head
condition|)
block|{
name|send_mcq
operator|=
name|to_mcq
argument_list|(
name|mqp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|send_mcq
operator|->
name|lock
argument_list|,
name|flags_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_mcq
operator|->
name|mcq
operator|.
name|comp
operator|&&
name|mqp
operator|->
name|ibqp
operator|.
name|send_cq
operator|->
name|comp_handler
condition|)
block|{
if|if
condition|(
operator|!
name|send_mcq
operator|->
name|mcq
operator|.
name|reset_notify_added
condition|)
block|{
name|send_mcq
operator|->
name|mcq
operator|.
name|reset_notify_added
operator|=
literal|1
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|send_mcq
operator|->
name|mcq
operator|.
name|reset_notify
argument_list|,
operator|&
name|cq_notify_list
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|send_mcq
operator|->
name|lock
argument_list|,
name|flags_cq
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mqp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags_qp
argument_list|)
expr_stmt|;
comment|/* Now, handle the QP's receive queue */
name|spin_lock_irqsave
argument_list|(
operator|&
name|mqp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags_qp
argument_list|)
expr_stmt|;
comment|/* no handling is needed for SRQ */
if|if
condition|(
operator|!
name|mqp
operator|->
name|ibqp
operator|.
name|srq
condition|)
block|{
if|if
condition|(
name|mqp
operator|->
name|rq
operator|.
name|tail
operator|!=
name|mqp
operator|->
name|rq
operator|.
name|head
condition|)
block|{
name|recv_mcq
operator|=
name|to_mcq
argument_list|(
name|mqp
operator|->
name|ibqp
operator|.
name|recv_cq
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|recv_mcq
operator|->
name|lock
argument_list|,
name|flags_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|recv_mcq
operator|->
name|mcq
operator|.
name|comp
operator|&&
name|mqp
operator|->
name|ibqp
operator|.
name|recv_cq
operator|->
name|comp_handler
condition|)
block|{
if|if
condition|(
operator|!
name|recv_mcq
operator|->
name|mcq
operator|.
name|reset_notify_added
condition|)
block|{
name|recv_mcq
operator|->
name|mcq
operator|.
name|reset_notify_added
operator|=
literal|1
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|recv_mcq
operator|->
name|mcq
operator|.
name|reset_notify
argument_list|,
operator|&
name|cq_notify_list
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|recv_mcq
operator|->
name|lock
argument_list|,
name|flags_cq
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mqp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags_qp
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|mcq
argument_list|,
argument|&cq_notify_list
argument_list|,
argument|reset_notify
argument_list|)
block|{
name|mcq
operator|->
name|comp
argument_list|(
name|mcq
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ibdev
operator|->
name|reset_flow_resource_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pr_warn
argument_list|(
literal|"mlx4_ib_handle_catas_error ended\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_bonded_port_state_event
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|ib_event_work
modifier|*
name|ew
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|ib_event_work
argument_list|,
name|work
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
init|=
name|ew
operator|->
name|ib_dev
decl_stmt|;
name|enum
name|ib_port_state
name|bonded_port_state
init|=
name|IB_PORT_NOP
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ib_event
name|ibev
decl_stmt|;
name|kfree
argument_list|(
name|ew
argument_list|)
expr_stmt|;
name|spin_lock_bh
argument_list|(
operator|&
name|ibdev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORTS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|net_device
modifier|*
name|curr_netdev
init|=
name|ibdev
operator|->
name|iboe
operator|.
name|netdevs
index|[
name|i
index|]
decl_stmt|;
name|enum
name|ib_port_state
name|curr_port_state
decl_stmt|;
if|if
condition|(
operator|!
name|curr_netdev
condition|)
continue|continue;
name|curr_port_state
operator|=
operator|(
name|netif_running
argument_list|(
name|curr_netdev
argument_list|)
operator|&&
name|netif_carrier_ok
argument_list|(
name|curr_netdev
argument_list|)
operator|)
condition|?
name|IB_PORT_ACTIVE
else|:
name|IB_PORT_DOWN
expr_stmt|;
name|bonded_port_state
operator|=
operator|(
name|bonded_port_state
operator|!=
name|IB_PORT_ACTIVE
operator|)
condition|?
name|curr_port_state
else|:
name|IB_PORT_ACTIVE
expr_stmt|;
block|}
name|spin_unlock_bh
argument_list|(
operator|&
name|ibdev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ibev
operator|.
name|device
operator|=
operator|&
name|ibdev
operator|->
name|ib_dev
expr_stmt|;
name|ibev
operator|.
name|element
operator|.
name|port_num
operator|=
literal|1
expr_stmt|;
name|ibev
operator|.
name|event
operator|=
operator|(
name|bonded_port_state
operator|==
name|IB_PORT_ACTIVE
operator|)
condition|?
name|IB_EVENT_PORT_ACTIVE
else|:
name|IB_EVENT_PORT_ERR
expr_stmt|;
name|ib_dispatch_event
argument_list|(
operator|&
name|ibev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_ib_sl2vl_update
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u64
name|sl2vl
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_ib_query_sl2vl
argument_list|(
operator|&
name|mdev
operator|->
name|ib_dev
argument_list|,
name|port
argument_list|,
operator|&
name|sl2vl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_err
argument_list|(
literal|"Unable to get current sl to vl mapping for port %d.  Using all zeroes (%d)\n"
argument_list|,
name|port
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sl2vl
operator|=
literal|0
expr_stmt|;
block|}
name|atomic64_set
argument_list|(
operator|&
name|mdev
operator|->
name|sl2vl
index|[
name|port
operator|-
literal|1
index|]
argument_list|,
name|sl2vl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_sl2vl_update_work
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|ib_event_work
modifier|*
name|ew
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|ib_event_work
argument_list|,
name|work
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|ew
operator|->
name|ib_dev
decl_stmt|;
name|int
name|port
init|=
name|ew
operator|->
name|port
decl_stmt|;
name|mlx4_ib_sl2vl_update
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ew
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_sched_ib_sl2vl_update_work
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|ib_event_work
modifier|*
name|ew
decl_stmt|;
name|ew
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ew
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ew
condition|)
block|{
name|INIT_WORK
argument_list|(
operator|&
name|ew
operator|->
name|work
argument_list|,
name|ib_sl2vl_update_work
argument_list|)
expr_stmt|;
name|ew
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|ew
operator|->
name|ib_dev
operator|=
name|ibdev
expr_stmt|;
name|queue_work
argument_list|(
name|wq
argument_list|,
operator|&
name|ew
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr_err
argument_list|(
literal|"failed to allocate memory for sl2vl update work\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_event
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|ibdev_ptr
parameter_list|,
name|enum
name|mlx4_dev_event
name|event
parameter_list|,
name|unsigned
name|long
name|param
parameter_list|)
block|{
name|struct
name|ib_event
name|ibev
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
init|=
name|to_mdev
argument_list|(
operator|(
expr|struct
name|ib_device
operator|*
operator|)
name|ibdev_ptr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_eqe
modifier|*
name|eqe
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_event_work
modifier|*
name|ew
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
operator|(
name|event
operator|==
name|MLX4_DEV_EVENT_PORT_UP
operator|)
operator|||
operator|(
name|event
operator|==
name|MLX4_DEV_EVENT_PORT_DOWN
operator|)
operator|)
condition|)
block|{
name|ew
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ew
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ew
condition|)
return|return;
name|INIT_WORK
argument_list|(
operator|&
name|ew
operator|->
name|work
argument_list|,
name|handle_bonded_port_state_event
argument_list|)
expr_stmt|;
name|ew
operator|->
name|ib_dev
operator|=
name|ibdev
expr_stmt|;
name|queue_work
argument_list|(
name|wq
argument_list|,
operator|&
name|ew
operator|->
name|work
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|event
operator|==
name|MLX4_DEV_EVENT_PORT_MGMT_CHANGE
condition|)
name|eqe
operator|=
operator|(
expr|struct
name|mlx4_eqe
operator|*
operator|)
name|param
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|int
operator|)
name|param
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MLX4_DEV_EVENT_PORT_UP
case|:
if|if
condition|(
name|p
operator|>
name|ibdev
operator|->
name|num_ports
condition|)
return|return;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
operator|&&
name|rdma_port_get_link_layer
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|p
argument_list|)
operator|==
name|IB_LINK_LAYER_INFINIBAND
condition|)
block|{
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_ib_invalidate_all_guid_record
argument_list|(
name|ibdev
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibdev
operator|->
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SECURE_HOST
operator|&&
operator|!
operator|(
name|ibdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SL_TO_VL_CHANGE_EVENT
operator|)
condition|)
name|mlx4_sched_ib_sl2vl_update_work
argument_list|(
name|ibdev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|ibev
operator|.
name|event
operator|=
name|IB_EVENT_PORT_ACTIVE
expr_stmt|;
break|break;
case|case
name|MLX4_DEV_EVENT_PORT_DOWN
case|:
if|if
condition|(
name|p
operator|>
name|ibdev
operator|->
name|num_ports
condition|)
return|return;
name|ibev
operator|.
name|event
operator|=
name|IB_EVENT_PORT_ERR
expr_stmt|;
break|break;
case|case
name|MLX4_DEV_EVENT_CATASTROPHIC_ERROR
case|:
name|ibdev
operator|->
name|ib_active
operator|=
name|false
expr_stmt|;
name|ibev
operator|.
name|event
operator|=
name|IB_EVENT_DEVICE_FATAL
expr_stmt|;
name|mlx4_ib_handle_catas_error
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_DEV_EVENT_PORT_MGMT_CHANGE
case|:
name|ew
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ew
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ew
condition|)
block|{
name|pr_err
argument_list|(
literal|"failed to allocate memory for events work\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|INIT_WORK
argument_list|(
operator|&
name|ew
operator|->
name|work
argument_list|,
name|handle_port_mgmt_change_event
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ew
operator|->
name|ib_eqe
argument_list|,
name|eqe
argument_list|,
sizeof|sizeof
expr|*
name|eqe
argument_list|)
expr_stmt|;
name|ew
operator|->
name|ib_dev
operator|=
name|ibdev
expr_stmt|;
comment|/* need to queue only for port owner, which uses GEN_EQE */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|queue_work
argument_list|(
name|wq
argument_list|,
operator|&
name|ew
operator|->
name|work
argument_list|)
expr_stmt|;
else|else
name|handle_port_mgmt_change_event
argument_list|(
operator|&
name|ew
operator|->
name|work
argument_list|)
expr_stmt|;
return|return;
case|case
name|MLX4_DEV_EVENT_SLAVE_INIT
case|:
comment|/* here, p is the slave id */
name|do_slave_init
argument_list|(
name|ibdev
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ibdev
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdma_port_get_link_layer
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|i
argument_list|)
operator|==
name|IB_LINK_LAYER_INFINIBAND
condition|)
name|mlx4_ib_slave_alias_guid_event
argument_list|(
name|ibdev
argument_list|,
name|p
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|MLX4_DEV_EVENT_SLAVE_SHUTDOWN
case|:
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ibdev
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdma_port_get_link_layer
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|i
argument_list|)
operator|==
name|IB_LINK_LAYER_INFINIBAND
condition|)
name|mlx4_ib_slave_alias_guid_event
argument_list|(
name|ibdev
argument_list|,
name|p
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* here, p is the slave id */
name|do_slave_init
argument_list|(
name|ibdev
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
name|ibev
operator|.
name|device
operator|=
name|ibdev_ptr
expr_stmt|;
name|ibev
operator|.
name|element
operator|.
name|port_num
operator|=
name|mlx4_is_bonded
argument_list|(
name|ibdev
operator|->
name|dev
argument_list|)
condition|?
literal|1
else|:
operator|(
name|u8
operator|)
name|p
expr_stmt|;
name|ib_dispatch_event
argument_list|(
operator|&
name|ibev
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mlx4_interface
name|mlx4_ib_interface
init|=
block|{
operator|.
name|add
operator|=
name|mlx4_ib_add
block|,
operator|.
name|remove
operator|=
name|mlx4_ib_remove
block|,
operator|.
name|event
operator|=
name|mlx4_ib_event
block|,
operator|.
name|protocol
operator|=
name|MLX4_PROT_IB_IPV6
block|,
operator|.
name|flags
operator|=
name|MLX4_INTFF_BONDING
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|mlx4_ib_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|wq
operator|=
name|alloc_ordered_workqueue
argument_list|(
literal|"mlx4_ib"
argument_list|,
name|WQ_MEM_RECLAIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|err
operator|=
name|mlx4_ib_mcg_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|clean_wq
goto|;
name|err
operator|=
name|mlx4_register_interface
argument_list|(
operator|&
name|mlx4_ib_interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|clean_mcg
goto|;
return|return
literal|0
return|;
name|clean_mcg
label|:
name|mlx4_ib_mcg_destroy
argument_list|()
expr_stmt|;
name|clean_wq
label|:
name|destroy_workqueue
argument_list|(
name|wq
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|mlx4_ib_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|mlx4_unregister_interface
argument_list|(
operator|&
name|mlx4_ib_interface
argument_list|)
expr_stmt|;
name|mlx4_ib_mcg_destroy
argument_list|()
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init_order
argument_list|(
name|mlx4_ib_init
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|mlx4_ib_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4ib_evhand
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mlx4ib_mod
init|=
block|{
operator|.
name|name
operator|=
literal|"mlx4ib"
block|,
operator|.
name|evhand
operator|=
name|mlx4ib_evhand
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|mlx4ib
argument_list|,
name|mlx4ib_mod
argument_list|,
name|SI_SUB_LAST
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mlx4ib
argument_list|,
name|mlx4
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mlx4ib
argument_list|,
name|ibcore
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mlx4ib
argument_list|,
name|linuxkpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

