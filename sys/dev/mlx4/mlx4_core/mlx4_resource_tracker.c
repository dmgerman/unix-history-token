begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008, 2014 Mellanox Technologies.  * All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/io.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/qp.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_define
define|#
directive|define
name|MLX4_MAC_VALID
value|(1ull<< 63)
end_define

begin_struct
struct|struct
name|mac_res
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|u64
name|mac
decl_stmt|;
name|int
name|ref_count
decl_stmt|;
name|u8
name|smac_index
decl_stmt|;
name|u8
name|port
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vlan_res
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|u16
name|vlan
decl_stmt|;
name|int
name|ref_count
decl_stmt|;
name|int
name|vlan_index
decl_stmt|;
name|u8
name|port
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|res_common
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|struct
name|rb_node
name|node
decl_stmt|;
name|u64
name|res_id
decl_stmt|;
name|int
name|owner
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|from_state
decl_stmt|;
name|int
name|to_state
decl_stmt|;
name|int
name|removing
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|RES_ANY_BUSY
init|=
literal|1
block|}
enum|;
end_enum

begin_struct
struct|struct
name|res_gid
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|u8
name|gid
index|[
literal|16
index|]
decl_stmt|;
name|enum
name|mlx4_protocol
name|prot
decl_stmt|;
name|enum
name|mlx4_steer_type
name|steer
decl_stmt|;
name|u64
name|reg_id
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_qp_states
block|{
name|RES_QP_BUSY
init|=
name|RES_ANY_BUSY
block|,
comment|/* QP number was allocated */
name|RES_QP_RESERVED
block|,
comment|/* ICM memory for QP context was mapped */
name|RES_QP_MAPPED
block|,
comment|/* QP is in hw ownership */
name|RES_QP_HW
block|}
enum|;
end_enum

begin_struct
struct|struct
name|res_qp
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|rcq
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|scq
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|list_head
name|mcg_list
decl_stmt|;
name|spinlock_t
name|mcg_spl
decl_stmt|;
name|int
name|local_qpn
decl_stmt|;
name|atomic_t
name|ref_count
decl_stmt|;
name|u32
name|qpc_flags
decl_stmt|;
comment|/* saved qp params before VST enforcement in order to restore on VGT */
name|u8
name|sched_queue
decl_stmt|;
name|__be32
name|param3
decl_stmt|;
name|u8
name|vlan_control
decl_stmt|;
name|u8
name|fvl_rx
decl_stmt|;
name|u8
name|pri_path_fl
decl_stmt|;
name|u8
name|vlan_index
decl_stmt|;
name|u8
name|feup
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_mtt_states
block|{
name|RES_MTT_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_MTT_ALLOCATED
block|, }
enum|;
end_enum

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|mtt_states_str
parameter_list|(
name|enum
name|res_mtt_states
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_MTT_BUSY
case|:
return|return
literal|"RES_MTT_BUSY"
return|;
case|case
name|RES_MTT_ALLOCATED
case|:
return|return
literal|"RES_MTT_ALLOCATED"
return|;
default|default:
return|return
literal|"Unknown"
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|res_mtt
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|int
name|order
decl_stmt|;
name|atomic_t
name|ref_count
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_mpt_states
block|{
name|RES_MPT_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_MPT_RESERVED
block|,
name|RES_MPT_MAPPED
block|,
name|RES_MPT_HW
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|res_mpt
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|int
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_eq_states
block|{
name|RES_EQ_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_EQ_RESERVED
block|,
name|RES_EQ_HW
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|res_eq
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_cq_states
block|{
name|RES_CQ_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_CQ_ALLOCATED
block|,
name|RES_CQ_HW
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|res_cq
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|atomic_t
name|ref_count
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_srq_states
block|{
name|RES_SRQ_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_SRQ_ALLOCATED
block|,
name|RES_SRQ_HW
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|res_srq
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|cq
decl_stmt|;
name|atomic_t
name|ref_count
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_counter_states
block|{
name|RES_COUNTER_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_COUNTER_ALLOCATED
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|res_counter
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|int
name|port
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_xrcdn_states
block|{
name|RES_XRCD_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_XRCD_ALLOCATED
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|res_xrcdn
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|int
name|port
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|res_fs_rule_states
block|{
name|RES_FS_RULE_BUSY
init|=
name|RES_ANY_BUSY
block|,
name|RES_FS_RULE_ALLOCATED
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|res_fs_rule
block|{
name|struct
name|res_common
name|com
decl_stmt|;
name|int
name|qpn
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|mlx4_is_eth
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
return|return
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|res_tracker_lookup
parameter_list|(
name|struct
name|rb_root
modifier|*
name|root
parameter_list|,
name|u64
name|res_id
parameter_list|)
block|{
name|struct
name|rb_node
modifier|*
name|node
init|=
name|root
operator|->
name|rb_node
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|struct
name|res_common
modifier|*
name|res
init|=
name|container_of
argument_list|(
name|node
argument_list|,
expr|struct
name|res_common
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|res_id
operator|<
name|res
operator|->
name|res_id
condition|)
name|node
operator|=
name|node
operator|->
name|rb_left
expr_stmt|;
elseif|else
if|if
condition|(
name|res_id
operator|>
name|res
operator|->
name|res_id
condition|)
name|node
operator|=
name|node
operator|->
name|rb_right
expr_stmt|;
else|else
return|return
name|res
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|res_tracker_insert
parameter_list|(
name|struct
name|rb_root
modifier|*
name|root
parameter_list|,
name|struct
name|res_common
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|rb_node
modifier|*
modifier|*
name|new
init|=
operator|&
operator|(
name|root
operator|->
name|rb_node
operator|)
decl_stmt|,
modifier|*
name|parent
init|=
name|NULL
decl_stmt|;
comment|/* Figure out where to put new node */
while|while
condition|(
operator|*
name|new
condition|)
block|{
name|struct
name|res_common
modifier|*
name|this
init|=
name|container_of
argument_list|(
operator|*
name|new
argument_list|,
expr|struct
name|res_common
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|parent
operator|=
operator|*
name|new
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|res_id
operator|<
name|this
operator|->
name|res_id
condition|)
name|new
operator|=
operator|&
operator|(
operator|(
operator|*
name|new
operator|)
operator|->
name|rb_left
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|->
name|res_id
operator|>
name|this
operator|->
name|res_id
condition|)
name|new
operator|=
operator|&
operator|(
operator|(
operator|*
name|new
operator|)
operator|->
name|rb_right
operator|)
expr_stmt|;
else|else
return|return
operator|-
name|EEXIST
return|;
block|}
comment|/* Add new node and rebalance tree. */
name|rb_link_node
argument_list|(
operator|&
name|res
operator|->
name|node
argument_list|,
name|parent
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|rb_insert_color
argument_list|(
operator|&
name|res
operator|->
name|node
argument_list|,
name|root
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_enum
enum|enum
name|qp_transition
block|{
name|QP_TRANS_INIT2RTR
block|,
name|QP_TRANS_RTR2RTS
block|,
name|QP_TRANS_RTS2RTS
block|,
name|QP_TRANS_SQERR2RTS
block|,
name|QP_TRANS_SQD2SQD
block|,
name|QP_TRANS_SQD2RTS
block|}
enum|;
end_enum

begin_comment
comment|/* For Debug uses */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ResourceType
parameter_list|(
name|enum
name|mlx4_resource
name|rt
parameter_list|)
block|{
switch|switch
condition|(
name|rt
condition|)
block|{
case|case
name|RES_QP
case|:
return|return
literal|"RES_QP"
return|;
case|case
name|RES_CQ
case|:
return|return
literal|"RES_CQ"
return|;
case|case
name|RES_SRQ
case|:
return|return
literal|"RES_SRQ"
return|;
case|case
name|RES_MPT
case|:
return|return
literal|"RES_MPT"
return|;
case|case
name|RES_MTT
case|:
return|return
literal|"RES_MTT"
return|;
case|case
name|RES_MAC
case|:
return|return
literal|"RES_MAC"
return|;
case|case
name|RES_VLAN
case|:
return|return
literal|"RES_VLAN"
return|;
case|case
name|RES_EQ
case|:
return|return
literal|"RES_EQ"
return|;
case|case
name|RES_COUNTER
case|:
return|return
literal|"RES_COUNTER"
return|;
case|case
name|RES_FS_RULE
case|:
return|return
literal|"RES_FS_RULE"
return|;
case|case
name|RES_XRCD
case|:
return|return
literal|"RES_XRCD"
return|;
default|default:
return|return
literal|"Unknown resource type !!!"
return|;
block|}
empty_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|rem_slave_vlans
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|mlx4_grant_resource
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|enum
name|mlx4_resource
name|res_type
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource_allocator
modifier|*
name|res_alloc
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|res_type
index|]
decl_stmt|;
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|allocated
decl_stmt|,
name|free
decl_stmt|,
name|reserved
decl_stmt|,
name|guaranteed
decl_stmt|,
name|from_free
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|res_alloc
operator|->
name|alloc_lock
argument_list|)
expr_stmt|;
name|allocated
operator|=
operator|(
name|port
operator|>
literal|0
operator|)
condition|?
name|res_alloc
operator|->
name|allocated
index|[
operator|(
name|port
operator|-
literal|1
operator|)
operator|*
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|+
name|slave
index|]
else|:
name|res_alloc
operator|->
name|allocated
index|[
name|slave
index|]
expr_stmt|;
name|free
operator|=
operator|(
name|port
operator|>
literal|0
operator|)
condition|?
name|res_alloc
operator|->
name|res_port_free
index|[
name|port
operator|-
literal|1
index|]
else|:
name|res_alloc
operator|->
name|res_free
expr_stmt|;
name|reserved
operator|=
operator|(
name|port
operator|>
literal|0
operator|)
condition|?
name|res_alloc
operator|->
name|res_port_rsvd
index|[
name|port
operator|-
literal|1
index|]
else|:
name|res_alloc
operator|->
name|res_reserved
expr_stmt|;
name|guaranteed
operator|=
name|res_alloc
operator|->
name|guaranteed
index|[
name|slave
index|]
expr_stmt|;
if|if
condition|(
name|allocated
operator|+
name|count
operator|>
name|res_alloc
operator|->
name|quota
index|[
name|slave
index|]
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|allocated
operator|+
name|count
operator|<=
name|guaranteed
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* portion may need to be obtained from free area */
if|if
condition|(
name|guaranteed
operator|-
name|allocated
operator|>
literal|0
condition|)
name|from_free
operator|=
name|count
operator|-
operator|(
name|guaranteed
operator|-
name|allocated
operator|)
expr_stmt|;
else|else
name|from_free
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|free
operator|-
name|from_free
operator|>
name|reserved
condition|)
name|err
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
comment|/* grant the request */
if|if
condition|(
name|port
operator|>
literal|0
condition|)
block|{
name|res_alloc
operator|->
name|allocated
index|[
operator|(
name|port
operator|-
literal|1
operator|)
operator|*
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|+
name|slave
index|]
operator|+=
name|count
expr_stmt|;
name|res_alloc
operator|->
name|res_port_free
index|[
name|port
operator|-
literal|1
index|]
operator|-=
name|count
expr_stmt|;
block|}
else|else
block|{
name|res_alloc
operator|->
name|allocated
index|[
name|slave
index|]
operator|+=
name|count
expr_stmt|;
name|res_alloc
operator|->
name|res_free
operator|-=
name|count
expr_stmt|;
block|}
block|}
name|out
label|:
name|spin_unlock
argument_list|(
operator|&
name|res_alloc
operator|->
name|alloc_lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mlx4_release_resource
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|enum
name|mlx4_resource
name|res_type
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource_allocator
modifier|*
name|res_alloc
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|res_type
index|]
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|res_alloc
operator|->
name|alloc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|>
literal|0
condition|)
block|{
name|res_alloc
operator|->
name|allocated
index|[
operator|(
name|port
operator|-
literal|1
operator|)
operator|*
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|+
name|slave
index|]
operator|-=
name|count
expr_stmt|;
name|res_alloc
operator|->
name|res_port_free
index|[
name|port
operator|-
literal|1
index|]
operator|+=
name|count
expr_stmt|;
block|}
else|else
block|{
name|res_alloc
operator|->
name|allocated
index|[
name|slave
index|]
operator|-=
name|count
expr_stmt|;
name|res_alloc
operator|->
name|res_free
operator|+=
name|count
expr_stmt|;
block|}
name|spin_unlock
argument_list|(
operator|&
name|res_alloc
operator|->
name|alloc_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|initialize_res_quotas
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|resource_allocator
modifier|*
name|res_alloc
parameter_list|,
name|enum
name|mlx4_resource
name|res_type
parameter_list|,
name|int
name|vf
parameter_list|,
name|int
name|num_instances
parameter_list|)
block|{
name|res_alloc
operator|->
name|guaranteed
index|[
name|vf
index|]
operator|=
name|num_instances
operator|/
operator|(
literal|2
operator|*
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|res_alloc
operator|->
name|quota
index|[
name|vf
index|]
operator|=
operator|(
name|num_instances
operator|/
literal|2
operator|)
operator|+
name|res_alloc
operator|->
name|guaranteed
index|[
name|vf
index|]
expr_stmt|;
if|if
condition|(
name|vf
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|res_alloc
operator|->
name|res_free
operator|=
name|num_instances
expr_stmt|;
if|if
condition|(
name|res_type
operator|==
name|RES_MTT
condition|)
block|{
comment|/* reserved mtts will be taken out of the PF allocation */
name|res_alloc
operator|->
name|res_free
operator|+=
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
expr_stmt|;
name|res_alloc
operator|->
name|guaranteed
index|[
name|vf
index|]
operator|+=
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
expr_stmt|;
name|res_alloc
operator|->
name|quota
index|[
name|vf
index|]
operator|+=
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|mlx4_init_quotas
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|pf
decl_stmt|;
comment|/* quotas for VFs are initialized in mlx4_slave_cap */
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|quotas
operator|.
name|qp
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_qps
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_qps
operator|-
name|mlx4_num_reserved_sqps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|cq
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_cqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|srq
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_srqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mtt
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mtts
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mpt
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mpts
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
expr_stmt|;
return|return;
block|}
name|pf
operator|=
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|qp
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_QP
index|]
operator|.
name|quota
index|[
name|pf
index|]
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|cq
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_CQ
index|]
operator|.
name|quota
index|[
name|pf
index|]
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|srq
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_SRQ
index|]
operator|.
name|quota
index|[
name|pf
index|]
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mtt
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_MTT
index|]
operator|.
name|quota
index|[
name|pf
index|]
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mpt
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_MPT
index|]
operator|.
name|quota
index|[
name|pf
index|]
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_init_resource_tracker
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|t
decl_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
operator|=
name|kzalloc
argument_list|(
name|dev
operator|->
name|num_slaves
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|slave_list
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|MLX4_NUM_OF_RESOURCE_TYPE
condition|;
operator|++
name|t
control|)
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
index|[
name|i
index|]
operator|.
name|res_list
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Started init_resource_tracker: %ld slaves\n"
argument_list|,
name|dev
operator|->
name|num_slaves
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_NUM_OF_RESOURCE_TYPE
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_tree
index|[
name|i
index|]
operator|=
name|RB_ROOT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_NUM_OF_RESOURCE_TYPE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|resource_allocator
modifier|*
name|res_alloc
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
decl_stmt|;
name|res_alloc
operator|->
name|quota
operator|=
name|kmalloc
argument_list|(
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|res_alloc
operator|->
name|guaranteed
operator|=
name|kmalloc
argument_list|(
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|RES_MAC
operator|||
name|i
operator|==
name|RES_VLAN
condition|)
name|res_alloc
operator|->
name|allocated
operator|=
name|kzalloc
argument_list|(
name|MLX4_MAX_PORTS
operator|*
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
else|else
name|res_alloc
operator|->
name|allocated
operator|=
name|kzalloc
argument_list|(
operator|(
name|dev
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res_alloc
operator|->
name|quota
operator|||
operator|!
name|res_alloc
operator|->
name|guaranteed
operator|||
operator|!
name|res_alloc
operator|->
name|allocated
condition|)
goto|goto
name|no_mem_err
goto|;
name|spin_lock_init
argument_list|(
operator|&
name|res_alloc
operator|->
name|alloc_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|dev
operator|->
name|num_vfs
operator|+
literal|1
condition|;
name|t
operator|++
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|RES_QP
case|:
name|initialize_res_quotas
argument_list|(
name|dev
argument_list|,
name|res_alloc
argument_list|,
name|RES_QP
argument_list|,
name|t
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_qps
operator|-
name|mlx4_num_reserved_sqps
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_CQ
case|:
name|initialize_res_quotas
argument_list|(
name|dev
argument_list|,
name|res_alloc
argument_list|,
name|RES_CQ
argument_list|,
name|t
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_SRQ
case|:
name|initialize_res_quotas
argument_list|(
name|dev
argument_list|,
name|res_alloc
argument_list|,
name|RES_SRQ
argument_list|,
name|t
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MPT
case|:
name|initialize_res_quotas
argument_list|(
name|dev
argument_list|,
name|res_alloc
argument_list|,
name|RES_MPT
argument_list|,
name|t
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mpts
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MTT
case|:
name|initialize_res_quotas
argument_list|(
name|dev
argument_list|,
name|res_alloc
argument_list|,
name|RES_MTT
argument_list|,
name|t
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mtts
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MAC
case|:
if|if
condition|(
name|t
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
operator|=
name|MLX4_MAX_MAC_NUM
operator|-
literal|2
operator|*
name|dev
operator|->
name|num_vfs
expr_stmt|;
name|res_alloc
operator|->
name|guaranteed
index|[
name|t
index|]
operator|=
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_MAX_PORTS
condition|;
name|j
operator|++
control|)
name|res_alloc
operator|->
name|res_port_free
index|[
name|j
index|]
operator|=
name|MLX4_MAX_MAC_NUM
expr_stmt|;
block|}
else|else
block|{
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
operator|=
literal|2
expr_stmt|;
name|res_alloc
operator|->
name|guaranteed
index|[
name|t
index|]
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|RES_VLAN
case|:
if|if
condition|(
name|t
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
operator|=
name|MLX4_MAX_VLAN_NUM
expr_stmt|;
name|res_alloc
operator|->
name|guaranteed
index|[
name|t
index|]
operator|=
name|MLX4_MAX_VLAN_NUM
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_MAX_PORTS
condition|;
name|j
operator|++
control|)
name|res_alloc
operator|->
name|res_port_free
index|[
name|j
index|]
operator|=
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
expr_stmt|;
block|}
else|else
block|{
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
operator|=
name|MLX4_MAX_VLAN_NUM
operator|/
literal|2
expr_stmt|;
name|res_alloc
operator|->
name|guaranteed
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|RES_COUNTER
case|:
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|max_counters
expr_stmt|;
name|res_alloc
operator|->
name|guaranteed
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
name|res_alloc
operator|->
name|res_free
operator|=
name|res_alloc
operator|->
name|quota
index|[
name|t
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|RES_MAC
operator|||
name|i
operator|==
name|RES_VLAN
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_MAX_PORTS
condition|;
name|j
operator|++
control|)
name|res_alloc
operator|->
name|res_port_rsvd
index|[
name|j
index|]
operator|+=
name|res_alloc
operator|->
name|guaranteed
index|[
name|t
index|]
expr_stmt|;
block|}
else|else
block|{
name|res_alloc
operator|->
name|res_reserved
operator|+=
name|res_alloc
operator|->
name|guaranteed
index|[
name|t
index|]
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|no_mem_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_NUM_OF_RESOURCE_TYPE
condition|;
name|i
operator|++
control|)
block|{
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|allocated
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|guaranteed
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|guaranteed
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|quota
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|quota
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
name|void
name|mlx4_free_resource_tracker
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_res_tracker_free_type
name|type
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|RES_TR_FREE_STRUCTS_ONLY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
name|RES_TR_FREE_ALL
operator|||
name|dev
operator|->
name|caps
operator|.
name|function
operator|!=
name|i
condition|)
name|mlx4_delete_all_resources_for_slave
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* free master's vlans */
name|i
operator|=
name|dev
operator|->
name|caps
operator|.
name|function
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rem_slave_vlans
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|RES_TR_FREE_SLAVES_ONLY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_NUM_OF_RESOURCE_TYPE
condition|;
name|i
operator|++
control|)
block|{
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|allocated
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|guaranteed
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|guaranteed
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|quota
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|i
index|]
operator|.
name|quota
operator|=
name|NULL
expr_stmt|;
block|}
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_pkey_index
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|)
block|{
name|u8
name|sched
init|=
operator|*
operator|(
name|u8
operator|*
operator|)
operator|(
name|inbox
operator|->
name|buf
operator|+
literal|64
operator|)
decl_stmt|;
name|u8
name|orig_index
init|=
operator|*
operator|(
name|u8
operator|*
operator|)
operator|(
name|inbox
operator|->
name|buf
operator|+
literal|35
operator|)
decl_stmt|;
name|u8
name|new_index
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
decl_stmt|;
name|port
operator|=
operator|(
name|sched
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|new_index
operator|=
name|priv
operator|->
name|virt2phys_pkey
index|[
name|slave
index|]
index|[
name|port
operator|-
literal|1
index|]
index|[
name|orig_index
index|]
expr_stmt|;
operator|*
operator|(
name|u8
operator|*
operator|)
operator|(
name|inbox
operator|->
name|buf
operator|+
literal|35
operator|)
operator|=
name|new_index
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_gid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|u8
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_qp_context
modifier|*
name|qp_ctx
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|enum
name|mlx4_qp_optpar
name|optpar
init|=
name|be32_to_cpu
argument_list|(
operator|*
operator|(
name|__be32
operator|*
operator|)
name|inbox
operator|->
name|buf
argument_list|)
decl_stmt|;
name|u32
name|ts
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|qp_ctx
operator|->
name|flags
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
decl_stmt|;
name|int
name|port
decl_stmt|;
if|if
condition|(
name|MLX4_QP_ST_UD
operator|==
name|ts
condition|)
block|{
name|port
operator|=
operator|(
name|qp_ctx
operator|->
name|pri_path
operator|.
name|sched_queue
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mlx4_is_eth
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
condition|)
name|qp_ctx
operator|->
name|pri_path
operator|.
name|mgid_index
operator|=
name|mlx4_get_base_gid_ix
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
operator||
literal|0x80
expr_stmt|;
else|else
name|qp_ctx
operator|->
name|pri_path
operator|.
name|mgid_index
operator|=
literal|0x80
operator||
name|slave
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MLX4_QP_ST_RC
operator|==
name|ts
operator|||
name|MLX4_QP_ST_UC
operator|==
name|ts
condition|)
block|{
if|if
condition|(
name|optpar
operator|&
name|MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH
condition|)
block|{
name|port
operator|=
operator|(
name|qp_ctx
operator|->
name|pri_path
operator|.
name|sched_queue
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mlx4_is_eth
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|qp_ctx
operator|->
name|pri_path
operator|.
name|mgid_index
operator|+=
name|mlx4_get_base_gid_ix
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|qp_ctx
operator|->
name|pri_path
operator|.
name|mgid_index
operator|&=
literal|0x7f
expr_stmt|;
block|}
else|else
block|{
name|qp_ctx
operator|->
name|pri_path
operator|.
name|mgid_index
operator|=
name|slave
operator|&
literal|0x7F
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optpar
operator|&
name|MLX4_QP_OPTPAR_ALT_ADDR_PATH
condition|)
block|{
name|port
operator|=
operator|(
name|qp_ctx
operator|->
name|alt_path
operator|.
name|sched_queue
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mlx4_is_eth
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|qp_ctx
operator|->
name|alt_path
operator|.
name|mgid_index
operator|+=
name|mlx4_get_base_gid_ix
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|qp_ctx
operator|->
name|alt_path
operator|.
name|mgid_index
operator|&=
literal|0x7f
expr_stmt|;
block|}
else|else
block|{
name|qp_ctx
operator|->
name|alt_path
operator|.
name|mgid_index
operator|=
name|slave
operator|&
literal|0x7F
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|check_counter_index_validity
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|counter
decl_stmt|,
modifier|*
name|tmp_counter
decl_stmt|;
if|if
condition|(
name|slave
operator|==
literal|0
condition|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|counter
argument_list|,
argument|tmp_counter
argument_list|,
argument|&priv->counters_table.global_port_list[port -
literal|1
argument|]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|counter
operator|->
name|index
operator|==
name|idx
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
block|{
name|list_for_each_entry_safe
argument_list|(
argument|counter
argument_list|,
argument|tmp_counter
argument_list|,
argument|&priv->counters_table.vf_list[slave -
literal|1
argument|][port -
literal|1
argument|]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|counter
operator|->
name|index
operator|==
name|idx
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|update_vport_qp_param
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|u8
name|slave
parameter_list|,
name|u32
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
decl_stmt|;
name|u32
name|qp_type
decl_stmt|;
name|int
name|port
decl_stmt|;
name|port
operator|=
operator|(
name|qpc
operator|->
name|pri_path
operator|.
name|sched_queue
operator|&
literal|0x40
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|priv
operator|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|qp_type
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|flags
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
operator|&&
name|qpc
operator|->
name|pri_path
operator|.
name|counter_index
operator|!=
name|MLX4_SINK_COUNTER_INDEX
condition|)
block|{
if|if
condition|(
name|check_counter_index_validity
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|,
name|qpc
operator|->
name|pri_path
operator|.
name|counter_index
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: QP counter_index %d for slave %d port %d\n"
argument_list|,
name|__func__
argument_list|,
name|qpc
operator|->
name|pri_path
operator|.
name|counter_index
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_LB_SRC_CHK
operator|)
operator|&&
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
operator|&&
operator|!
name|mlx4_is_qp_reserved
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
operator|&&
name|qp_type
operator|==
name|MLX4_QP_ST_MLX
operator|&&
name|qpc
operator|->
name|pri_path
operator|.
name|counter_index
operator|!=
literal|0xFF
condition|)
block|{
comment|/* disable multicast loopback to qp with same counter */
name|qpc
operator|->
name|pri_path
operator|.
name|fl
operator||=
name|MLX4_FL_ETH_SRC_CHECK_MC_LB
expr_stmt|;
name|qpc
operator|->
name|pri_path
operator|.
name|vlan_control
operator||=
name|MLX4_VLAN_CTRL_ETH_SRC_CHECK_IF_COUNTER
expr_stmt|;
block|}
if|if
condition|(
name|MLX4_VGT
operator|!=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
condition|)
block|{
comment|/* the reserved QPs (special, proxy, tunnel) 		 * do not operate over vlans 		 */
if|if
condition|(
name|mlx4_is_qp_reserved
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* force strip vlan by clear vsd */
name|qpc
operator|->
name|param3
operator|&=
operator|~
name|cpu_to_be32
argument_list|(
name|MLX4_STRIP_VLAN
argument_list|)
expr_stmt|;
comment|/* preserve IF_COUNTER flag */
name|qpc
operator|->
name|pri_path
operator|.
name|vlan_control
operator|&=
name|MLX4_VLAN_CTRL_ETH_SRC_CHECK_IF_COUNTER
expr_stmt|;
if|if
condition|(
name|MLX4_QP_ST_RC
operator|!=
name|qp_type
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
condition|)
block|{
name|qpc
operator|->
name|pri_path
operator|.
name|vlan_control
operator||=
name|MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED
operator||
name|MLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED
operator||
name|MLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED
expr_stmt|;
block|}
else|else
block|{
comment|/* priority tagged */
name|qpc
operator|->
name|pri_path
operator|.
name|vlan_control
operator||=
name|MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED
operator||
name|MLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED
expr_stmt|;
block|}
block|}
name|qpc
operator|->
name|pri_path
operator|.
name|fvl_rx
operator||=
name|MLX4_FVL_RX_FORCE_ETH_VLAN
expr_stmt|;
name|qpc
operator|->
name|pri_path
operator|.
name|vlan_index
operator|=
name|vp_oper
operator|->
name|vlan_idx
expr_stmt|;
name|qpc
operator|->
name|pri_path
operator|.
name|fl
operator||=
name|MLX4_FL_CV
operator||
name|MLX4_FL_ETH_HIDE_CQE_VLAN
expr_stmt|;
name|qpc
operator|->
name|pri_path
operator|.
name|feup
operator||=
name|MLX4_FEUP_FORCE_ETH_UP
operator||
name|MLX4_FVL_FORCE_ETH_VLAN
expr_stmt|;
name|qpc
operator|->
name|pri_path
operator|.
name|sched_queue
operator|&=
literal|0xC7
expr_stmt|;
name|qpc
operator|->
name|pri_path
operator|.
name|sched_queue
operator||=
operator|(
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|vp_oper
operator|->
name|state
operator|.
name|spoofchk
condition|)
block|{
name|qpc
operator|->
name|pri_path
operator|.
name|feup
operator||=
name|MLX4_FSM_FORCE_ETH_SRC_MAC
expr_stmt|;
name|qpc
operator|->
name|pri_path
operator|.
name|grh_mylmc
operator|=
operator|(
literal|0x80
operator|&
name|qpc
operator|->
name|pri_path
operator|.
name|grh_mylmc
operator|)
operator|+
name|vp_oper
operator|->
name|mac_idx
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_mask
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|dev
operator|->
name|caps
operator|.
name|num_mpts
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|find_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|res_id
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|res_tracker_lookup
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_tree
index|[
name|type
index|]
argument_list|,
name|res_id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u64
name|res_id
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|void
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|res_common
modifier|*
name|r
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|find_res
argument_list|(
name|dev
argument_list|,
name|res_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|err
operator|=
operator|-
name|ENONET
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|state
operator|==
name|RES_ANY_BUSY
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|owner
operator|!=
name|slave
condition|)
block|{
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|r
operator|->
name|from_state
operator|=
name|r
operator|->
name|state
expr_stmt|;
name|r
operator|->
name|state
operator|=
name|RES_ANY_BUSY
expr_stmt|;
if|if
condition|(
name|res
condition|)
operator|*
operator|(
operator|(
expr|struct
name|res_common
operator|*
operator|*
operator|)
name|res
operator|)
operator|=
name|r
expr_stmt|;
name|exit
label|:
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_slave_from_resource_id
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|u64
name|res_id
parameter_list|,
name|int
modifier|*
name|slave
parameter_list|)
block|{
name|struct
name|res_common
modifier|*
name|r
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOENT
decl_stmt|;
name|int
name|id
init|=
name|res_id
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|RES_QP
condition|)
name|id
operator|&=
literal|0x7fffff
expr_stmt|;
name|spin_lock
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|find_res
argument_list|(
name|dev
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
operator|*
name|slave
operator|=
name|r
operator|->
name|owner
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|spin_unlock
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u64
name|res_id
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|)
block|{
name|struct
name|res_common
modifier|*
name|r
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|find_res
argument_list|(
name|dev
argument_list|,
name|res_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|r
operator|->
name|state
operator|=
name|r
operator|->
name|from_state
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_qp_tr
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|res_qp
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_QP_RESERVED
expr_stmt|;
name|ret
operator|->
name|local_qpn
operator|=
name|id
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ret
operator|->
name|mcg_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|ret
operator|->
name|mcg_spl
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|ret
operator|->
name|ref_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_mtt_tr
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|order
parameter_list|)
block|{
name|struct
name|res_mtt
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_MTT_ALLOCATED
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|ret
operator|->
name|ref_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_mpt_tr
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|struct
name|res_mpt
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_MPT_RESERVED
expr_stmt|;
name|ret
operator|->
name|key
operator|=
name|key
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_eq_tr
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|res_eq
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_EQ_RESERVED
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_cq_tr
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|res_cq
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_CQ_ALLOCATED
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|ret
operator|->
name|ref_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_srq_tr
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|res_srq
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_SRQ_ALLOCATED
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|ret
operator|->
name|ref_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_counter_tr
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|res_counter
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_COUNTER_ALLOCATED
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_xrcdn_tr
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|res_xrcdn
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_XRCD_ALLOCATED
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_fs_rule_tr
parameter_list|(
name|u64
name|id
parameter_list|,
name|int
name|qpn
parameter_list|)
block|{
name|struct
name|res_fs_rule
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|com
operator|.
name|res_id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|com
operator|.
name|state
operator|=
name|RES_FS_RULE_ALLOCATED
expr_stmt|;
name|ret
operator|->
name|qpn
operator|=
name|qpn
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|com
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_common
modifier|*
name|alloc_tr
parameter_list|(
name|u64
name|id
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|extra
parameter_list|)
block|{
name|struct
name|res_common
modifier|*
name|ret
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RES_QP
case|:
name|ret
operator|=
name|alloc_qp_tr
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MPT
case|:
name|ret
operator|=
name|alloc_mpt_tr
argument_list|(
name|id
argument_list|,
name|extra
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MTT
case|:
name|ret
operator|=
name|alloc_mtt_tr
argument_list|(
name|id
argument_list|,
name|extra
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_EQ
case|:
name|ret
operator|=
name|alloc_eq_tr
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_CQ
case|:
name|ret
operator|=
name|alloc_cq_tr
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_SRQ
case|:
name|ret
operator|=
name|alloc_srq_tr
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MAC
case|:
name|printk
argument_list|(
name|KERN_ERR
literal|"implementation missing\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|RES_COUNTER
case|:
name|ret
operator|=
name|alloc_counter_tr
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_XRCD
case|:
name|ret
operator|=
name|alloc_xrcdn_tr
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_FS_RULE
case|:
name|ret
operator|=
name|alloc_fs_rule_tr
argument_list|(
name|id
argument_list|,
name|extra
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ret
condition|)
name|ret
operator|->
name|owner
operator|=
name|slave
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_res_range
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u64
name|base
parameter_list|,
name|int
name|count
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|int
name|extra
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|res_common
modifier|*
modifier|*
name|res_arr
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|rb_root
modifier|*
name|root
init|=
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|type
index|]
decl_stmt|;
name|res_arr
operator|=
name|kzalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
expr|*
name|res_arr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res_arr
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|res_arr
index|[
name|i
index|]
operator|=
name|alloc_tr
argument_list|(
name|base
operator|+
name|i
argument_list|,
name|type
argument_list|,
name|slave
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res_arr
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|kfree
argument_list|(
name|res_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res_arr
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|find_res
argument_list|(
name|dev
argument_list|,
name|base
operator|+
name|i
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EEXIST
expr_stmt|;
goto|goto
name|undo
goto|;
block|}
name|err
operator|=
name|res_tracker_insert
argument_list|(
name|root
argument_list|,
name|res_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|undo
goto|;
name|list_add_tail
argument_list|(
operator|&
name|res_arr
index|[
name|i
index|]
operator|->
name|list
argument_list|,
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res_arr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|undo
label|:
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rb_erase
argument_list|(
operator|&
name|res_arr
index|[
name|i
index|]
operator|->
name|node
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|res_arr
index|[
name|i
index|]
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|kfree
argument_list|(
name|res_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res_arr
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_qp_ok
parameter_list|(
name|struct
name|res_qp
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_QP_BUSY
operator|||
name|atomic_read
argument_list|(
operator|&
name|res
operator|->
name|ref_count
argument_list|)
operator|||
operator|!
name|list_empty
argument_list|(
operator|&
name|res
operator|->
name|mcg_list
argument_list|)
condition|)
block|{
name|pr_err
argument_list|(
literal|"resource tracker: fail to remove qp, state %d, ref_count %d\n"
argument_list|,
name|res
operator|->
name|com
operator|.
name|state
argument_list|,
name|atomic_read
argument_list|(
operator|&
name|res
operator|->
name|ref_count
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_QP_RESERVED
condition|)
block|{
return|return
operator|-
name|EPERM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_mtt_ok
parameter_list|(
name|struct
name|res_mtt
modifier|*
name|res
parameter_list|,
name|int
name|order
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_MTT_BUSY
operator|||
name|atomic_read
argument_list|(
operator|&
name|res
operator|->
name|ref_count
argument_list|)
condition|)
block|{
name|printk
argument_list|(
name|KERN_DEBUG
literal|"%s-%d: state %s, ref_count %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|mtt_states_str
argument_list|(
name|res
operator|->
name|com
operator|.
name|state
argument_list|)
argument_list|,
name|atomic_read
argument_list|(
operator|&
name|res
operator|->
name|ref_count
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_MTT_ALLOCATED
condition|)
return|return
operator|-
name|EPERM
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|order
operator|!=
name|order
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_mpt_ok
parameter_list|(
name|struct
name|res_mpt
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_MPT_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_MPT_RESERVED
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_eq_ok
parameter_list|(
name|struct
name|res_eq
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_MPT_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_MPT_RESERVED
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_counter_ok
parameter_list|(
name|struct
name|res_counter
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_COUNTER_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_COUNTER_ALLOCATED
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_xrcdn_ok
parameter_list|(
name|struct
name|res_xrcdn
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_XRCD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_XRCD_ALLOCATED
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_fs_rule_ok
parameter_list|(
name|struct
name|res_fs_rule
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_FS_RULE_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_FS_RULE_ALLOCATED
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_cq_ok
parameter_list|(
name|struct
name|res_cq
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_CQ_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_CQ_ALLOCATED
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_srq_ok
parameter_list|(
name|struct
name|res_srq
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|==
name|RES_SRQ_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
elseif|else
if|if
condition|(
name|res
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_SRQ_ALLOCATED
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_ok
parameter_list|(
name|struct
name|res_common
modifier|*
name|res
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|int
name|extra
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RES_QP
case|:
return|return
name|remove_qp_ok
argument_list|(
operator|(
expr|struct
name|res_qp
operator|*
operator|)
name|res
argument_list|)
return|;
case|case
name|RES_CQ
case|:
return|return
name|remove_cq_ok
argument_list|(
operator|(
expr|struct
name|res_cq
operator|*
operator|)
name|res
argument_list|)
return|;
case|case
name|RES_SRQ
case|:
return|return
name|remove_srq_ok
argument_list|(
operator|(
expr|struct
name|res_srq
operator|*
operator|)
name|res
argument_list|)
return|;
case|case
name|RES_MPT
case|:
return|return
name|remove_mpt_ok
argument_list|(
operator|(
expr|struct
name|res_mpt
operator|*
operator|)
name|res
argument_list|)
return|;
case|case
name|RES_MTT
case|:
return|return
name|remove_mtt_ok
argument_list|(
operator|(
expr|struct
name|res_mtt
operator|*
operator|)
name|res
argument_list|,
name|extra
argument_list|)
return|;
case|case
name|RES_MAC
case|:
return|return
operator|-
name|ENOSYS
return|;
case|case
name|RES_EQ
case|:
return|return
name|remove_eq_ok
argument_list|(
operator|(
expr|struct
name|res_eq
operator|*
operator|)
name|res
argument_list|)
return|;
case|case
name|RES_COUNTER
case|:
return|return
name|remove_counter_ok
argument_list|(
operator|(
expr|struct
name|res_counter
operator|*
operator|)
name|res
argument_list|)
return|;
case|case
name|RES_XRCD
case|:
return|return
name|remove_xrcdn_ok
argument_list|(
operator|(
expr|struct
name|res_xrcdn
operator|*
operator|)
name|res
argument_list|)
return|;
case|case
name|RES_FS_RULE
case|:
return|return
name|remove_fs_rule_ok
argument_list|(
operator|(
expr|struct
name|res_fs_rule
operator|*
operator|)
name|res
argument_list|)
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rem_res_range
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u64
name|base
parameter_list|,
name|int
name|count
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|int
name|extra
parameter_list|)
block|{
name|u64
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_common
modifier|*
name|r
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
name|base
operator|+
name|count
condition|;
operator|++
name|i
control|)
block|{
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|type
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|err
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|owner
operator|!=
name|slave
condition|)
block|{
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|remove_ok
argument_list|(
name|r
argument_list|,
name|type
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
name|base
operator|+
name|count
condition|;
operator|++
name|i
control|)
block|{
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|type
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|r
operator|->
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|r
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_res_start_move_to
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|qpn
parameter_list|,
name|enum
name|res_qp_states
name|state
parameter_list|,
name|struct
name|res_qp
modifier|*
modifier|*
name|qp
parameter_list|,
name|int
name|alloc
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|r
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_QP
index|]
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|err
operator|=
operator|-
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|owner
operator|!=
name|slave
condition|)
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_QP_BUSY
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: failed RES_QP, 0x%llx\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r
operator|->
name|com
operator|.
name|res_id
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
break|break;
case|case
name|RES_QP_RESERVED
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|==
name|RES_QP_MAPPED
operator|&&
operator|!
name|alloc
condition|)
break|break;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"failed RES_QP, 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r
operator|->
name|com
operator|.
name|res_id
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|RES_QP_MAPPED
case|:
if|if
condition|(
operator|(
name|r
operator|->
name|com
operator|.
name|state
operator|==
name|RES_QP_RESERVED
operator|&&
name|alloc
operator|)
operator|||
name|r
operator|->
name|com
operator|.
name|state
operator|==
name|RES_QP_HW
condition|)
break|break;
else|else
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"failed RES_QP, 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r
operator|->
name|com
operator|.
name|res_id
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|RES_QP_HW
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_QP_MAPPED
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|r
operator|->
name|com
operator|.
name|from_state
operator|=
name|r
operator|->
name|com
operator|.
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|to_state
operator|=
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|state
operator|=
name|RES_QP_BUSY
expr_stmt|;
if|if
condition|(
name|qp
condition|)
operator|*
name|qp
operator|=
name|r
expr_stmt|;
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mr_res_start_move_to
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|index
parameter_list|,
name|enum
name|res_mpt_states
name|state
parameter_list|,
name|struct
name|res_mpt
modifier|*
modifier|*
name|mpt
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|r
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_MPT
index|]
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|err
operator|=
operator|-
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|owner
operator|!=
name|slave
condition|)
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_MPT_BUSY
case|:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|RES_MPT_RESERVED
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_MPT_MAPPED
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|RES_MPT_MAPPED
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_MPT_RESERVED
operator|&&
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_MPT_HW
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|RES_MPT_HW
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_MPT_MAPPED
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|r
operator|->
name|com
operator|.
name|from_state
operator|=
name|r
operator|->
name|com
operator|.
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|to_state
operator|=
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|state
operator|=
name|RES_MPT_BUSY
expr_stmt|;
if|if
condition|(
name|mpt
condition|)
operator|*
name|mpt
operator|=
name|r
expr_stmt|;
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eq_res_start_move_to
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|index
parameter_list|,
name|enum
name|res_eq_states
name|state
parameter_list|,
name|struct
name|res_eq
modifier|*
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_eq
modifier|*
name|r
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_EQ
index|]
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|err
operator|=
operator|-
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|owner
operator|!=
name|slave
condition|)
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_EQ_BUSY
case|:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|RES_EQ_RESERVED
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_EQ_HW
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|RES_EQ_HW
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_EQ_RESERVED
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|r
operator|->
name|com
operator|.
name|from_state
operator|=
name|r
operator|->
name|com
operator|.
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|to_state
operator|=
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|state
operator|=
name|RES_EQ_BUSY
expr_stmt|;
if|if
condition|(
name|eq
condition|)
operator|*
name|eq
operator|=
name|r
expr_stmt|;
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cq_res_start_move_to
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|cqn
parameter_list|,
name|enum
name|res_cq_states
name|state
parameter_list|,
name|struct
name|res_cq
modifier|*
modifier|*
name|cq
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|r
decl_stmt|;
name|int
name|err
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_CQ
index|]
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|err
operator|=
operator|-
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|owner
operator|!=
name|slave
condition|)
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_CQ_BUSY
case|:
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
break|break;
case|case
name|RES_CQ_ALLOCATED
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_CQ_HW
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|r
operator|->
name|ref_count
argument_list|)
condition|)
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
else|else
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_CQ_HW
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_CQ_ALLOCATED
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
else|else
name|err
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|r
operator|->
name|com
operator|.
name|from_state
operator|=
name|r
operator|->
name|com
operator|.
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|to_state
operator|=
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|state
operator|=
name|RES_CQ_BUSY
expr_stmt|;
if|if
condition|(
name|cq
condition|)
operator|*
name|cq
operator|=
name|r
expr_stmt|;
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|srq_res_start_move_to
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|index
parameter_list|,
name|enum
name|res_srq_states
name|state
parameter_list|,
name|struct
name|res_srq
modifier|*
modifier|*
name|srq
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|r
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_SRQ
index|]
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|err
operator|=
operator|-
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|owner
operator|!=
name|slave
condition|)
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_SRQ_BUSY
case|:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|RES_SRQ_ALLOCATED
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_SRQ_HW
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|r
operator|->
name|ref_count
argument_list|)
condition|)
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
break|break;
case|case
name|RES_SRQ_HW
case|:
if|if
condition|(
name|r
operator|->
name|com
operator|.
name|state
operator|!=
name|RES_SRQ_ALLOCATED
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|r
operator|->
name|com
operator|.
name|from_state
operator|=
name|r
operator|->
name|com
operator|.
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|to_state
operator|=
name|state
expr_stmt|;
name|r
operator|->
name|com
operator|.
name|state
operator|=
name|RES_SRQ_BUSY
expr_stmt|;
if|if
condition|(
name|srq
condition|)
operator|*
name|srq
operator|=
name|r
expr_stmt|;
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|res_abort_move
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_common
modifier|*
name|r
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|type
index|]
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
operator|(
name|r
operator|->
name|owner
operator|==
name|slave
operator|)
condition|)
name|r
operator|->
name|state
operator|=
name|r
operator|->
name|from_state
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|res_end_move
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_common
modifier|*
name|r
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_tracker_lookup
argument_list|(
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|type
index|]
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
operator|(
name|r
operator|->
name|owner
operator|==
name|slave
operator|)
condition|)
name|r
operator|->
name|state
operator|=
name|r
operator|->
name|to_state
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|valid_reserved
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|qpn
parameter_list|)
block|{
return|return
name|mlx4_is_qp_reserved
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
operator|&&
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|||
name|mlx4_is_guest_proxy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_reserved
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|qpn
parameter_list|)
block|{
return|return
name|qpn
operator|<
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|qpn
decl_stmt|;
name|u8
name|flags
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE
case|:
name|count
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
comment|/* Turn off all unsupported QP allocation flags that the 		 * slave tries to set. 		 */
name|flags
operator|=
operator|(
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
operator|>>
literal|24
operator|)
operator|&
name|dev
operator|->
name|caps
operator|.
name|alloc_res_qp_mask
expr_stmt|;
name|align
operator|=
name|get_param_h
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_grant_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|__mlx4_qp_reserve_range
argument_list|(
name|dev
argument_list|,
name|count
argument_list|,
name|align
argument_list|,
operator|&
name|base
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|base
argument_list|,
name|count
argument_list|,
name|RES_QP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_qp_release_range
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_OP_MAP_ICM
case|:
name|qpn
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
operator|&
literal|0x7fffff
expr_stmt|;
if|if
condition|(
name|valid_reserved
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|)
condition|)
block|{
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|,
name|RES_QP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|err
operator|=
name|qp_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP_MAPPED
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|fw_reserved
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
condition|)
block|{
name|err
operator|=
name|__mlx4_qp_alloc_icm
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtt_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|order
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE_AND_MAP
condition|)
return|return
name|err
return|;
name|order
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_grant_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MTT
argument_list|,
literal|1
operator|<<
name|order
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|base
operator|=
name|__mlx4_alloc_mtt_range
argument_list|(
name|dev
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
operator|-
literal|1
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MTT
argument_list|,
literal|1
operator|<<
name|order
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|base
argument_list|,
literal|1
argument_list|,
name|RES_MTT
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MTT
argument_list|,
literal|1
operator|<<
name|order
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_free_mtt_range
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
else|else
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|id
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|mpt
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE
case|:
name|err
operator|=
name|mlx4_grant_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|index
operator|=
name|__mlx4_mpt_reserve
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|index
operator|&
name|mpt_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
literal|1
argument_list|,
name|RES_MPT
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_mpt_release
argument_list|(
name|dev
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_OP_MAP_ICM
case|:
name|index
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|id
operator|=
name|index
operator|&
name|mpt_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mr_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT_MAPPED
argument_list|,
operator|&
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|__mlx4_mpt_alloc_icm
argument_list|(
name|dev
argument_list|,
name|mpt
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cq_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|cqn
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE_AND_MAP
case|:
name|err
operator|=
name|mlx4_grant_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|__mlx4_cq_alloc_icm
argument_list|(
name|dev
argument_list|,
operator|&
name|cqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
literal|1
argument_list|,
name|RES_CQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_cq_free_icm
argument_list|(
name|dev
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
break|break;
block|}
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|srq_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|srqn
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE_AND_MAP
case|:
name|err
operator|=
name|mlx4_grant_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|__mlx4_srq_alloc_icm
argument_list|(
name|dev
argument_list|,
operator|&
name|srqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
literal|1
argument_list|,
name|RES_SRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_srq_free_icm
argument_list|(
name|dev
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
break|break;
block|}
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mac_find_smac_ix_in_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|u8
name|smac_index
parameter_list|,
name|u64
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|mac_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MAC
index|]
decl_stmt|;
name|struct
name|mac_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|mac_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|res
operator|->
name|smac_index
operator|==
name|smac_index
operator|&&
name|res
operator|->
name|port
operator|==
operator|(
name|u8
operator|)
name|port
condition|)
block|{
operator|*
name|mac
operator|=
name|res
operator|->
name|mac
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mac_add_to_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u64
name|mac
parameter_list|,
name|int
name|port
parameter_list|,
name|u8
name|smac_index
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|mac_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MAC
index|]
decl_stmt|;
name|struct
name|mac_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|mac_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|res
operator|->
name|mac
operator|==
name|mac
operator|&&
name|res
operator|->
name|port
operator|==
operator|(
name|u8
operator|)
name|port
condition|)
block|{
comment|/* mac found. update ref count */
operator|++
name|res
operator|->
name|ref_count
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|mlx4_grant_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MAC
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|res
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|res
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MAC
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|res
operator|->
name|mac
operator|=
name|mac
expr_stmt|;
name|res
operator|->
name|port
operator|=
operator|(
name|u8
operator|)
name|port
expr_stmt|;
name|res
operator|->
name|smac_index
operator|=
name|smac_index
expr_stmt|;
name|res
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|,
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MAC
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mac_del_from_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u64
name|mac
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|mac_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MAC
index|]
decl_stmt|;
name|struct
name|mac_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|mac_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|res
operator|->
name|mac
operator|==
name|mac
operator|&&
name|res
operator|->
name|port
operator|==
operator|(
name|u8
operator|)
name|port
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|res
operator|->
name|ref_count
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MAC
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_macs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|mac_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MAC
index|]
decl_stmt|;
name|struct
name|mac_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|mac_list
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* dereference the mac the num times the slave referenced it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|ref_count
condition|;
name|i
operator|++
control|)
name|__mlx4_unregister_mac
argument_list|(
name|dev
argument_list|,
name|res
operator|->
name|port
argument_list|,
name|res
operator|->
name|mac
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MAC
argument_list|,
literal|1
argument_list|,
name|res
operator|->
name|port
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mac_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|in_port
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|port
decl_stmt|;
name|u64
name|mac
decl_stmt|;
name|u8
name|smac_index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE_AND_MAP
condition|)
return|return
name|err
return|;
name|port
operator|=
operator|!
name|in_port
condition|?
name|get_param_l
argument_list|(
name|out_param
argument_list|)
else|:
name|in_port
expr_stmt|;
name|mac
operator|=
name|in_param
expr_stmt|;
name|err
operator|=
name|__mlx4_register_mac
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|>=
literal|0
condition|)
block|{
name|smac_index
operator|=
name|err
expr_stmt|;
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|mac_add_to_slave
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mac
argument_list|,
name|port
argument_list|,
name|smac_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|__mlx4_unregister_mac
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlan_add_to_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u16
name|vlan
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|vlan_index
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|vlan_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_VLAN
index|]
decl_stmt|;
name|struct
name|vlan_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|vlan_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|res
operator|->
name|vlan
operator|==
name|vlan
operator|&&
name|res
operator|->
name|port
operator|==
operator|(
name|u8
operator|)
name|port
condition|)
block|{
comment|/* vlan found. update ref count */
operator|++
name|res
operator|->
name|ref_count
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|mlx4_grant_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_VLAN
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|res
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_VLAN
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|res
operator|->
name|vlan
operator|=
name|vlan
expr_stmt|;
name|res
operator|->
name|port
operator|=
operator|(
name|u8
operator|)
name|port
expr_stmt|;
name|res
operator|->
name|vlan_index
operator|=
name|vlan_index
expr_stmt|;
name|res
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|,
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_VLAN
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlan_del_from_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u16
name|vlan
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|vlan_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_VLAN
index|]
decl_stmt|;
name|struct
name|vlan_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|vlan_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|res
operator|->
name|vlan
operator|==
name|vlan
operator|&&
name|res
operator|->
name|port
operator|==
operator|(
name|u8
operator|)
name|port
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|res
operator|->
name|ref_count
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_VLAN
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_vlans
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|vlan_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_VLAN
index|]
decl_stmt|;
name|struct
name|vlan_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|vlan_list
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* dereference the vlan the num times the slave referenced it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|ref_count
condition|;
name|i
operator|++
control|)
name|__mlx4_unregister_vlan
argument_list|(
name|dev
argument_list|,
name|res
operator|->
name|port
argument_list|,
name|res
operator|->
name|vlan
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_VLAN
argument_list|,
literal|1
argument_list|,
name|res
operator|->
name|port
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vlan_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|in_port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|slave_state
init|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
decl_stmt|;
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|u16
name|vlan
decl_stmt|;
name|int
name|vlan_index
decl_stmt|;
name|int
name|port
decl_stmt|;
name|port
operator|=
operator|!
name|in_port
condition|?
name|get_param_l
argument_list|(
name|out_param
argument_list|)
else|:
name|in_port
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
return|return
name|err
return|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE_AND_MAP
condition|)
return|return
name|err
return|;
comment|/* upstream kernels had NOP for reg/unreg vlan. Continue this. */
if|if
condition|(
operator|!
name|in_port
operator|&&
name|port
operator|>
literal|0
operator|&&
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
block|{
name|slave_state
index|[
name|slave
index|]
operator|.
name|old_vlan_api
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vlan
operator|=
operator|(
name|u16
operator|)
name|in_param
expr_stmt|;
name|err
operator|=
name|__mlx4_register_vlan
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|vlan
argument_list|,
operator|&
name|vlan_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|set_param_l
argument_list|(
name|out_param
argument_list|,
operator|(
name|u32
operator|)
name|vlan_index
argument_list|)
expr_stmt|;
name|err
operator|=
name|vlan_add_to_slave
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vlan
argument_list|,
name|port
argument_list|,
name|vlan_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|__mlx4_unregister_vlan
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|index
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|err
operator|=
name|__mlx4_counter_alloc
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xrcdn_alloc_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|u32
name|xrcdn
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|err
operator|=
name|__mlx4_xrcd_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|xrcdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|xrcdn
argument_list|,
literal|1
argument_list|,
name|RES_XRCD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|__mlx4_xrcd_free
argument_list|(
name|dev
argument_list|,
name|xrcdn
argument_list|)
expr_stmt|;
else|else
name|set_param_l
argument_list|(
name|out_param
argument_list|,
name|xrcdn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ALLOC_RES_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|alop
init|=
name|vhcr
operator|->
name|op_modifier
decl_stmt|;
switch|switch
condition|(
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0xFF
condition|)
block|{
case|case
name|RES_QP
case|:
name|err
operator|=
name|qp_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MTT
case|:
name|err
operator|=
name|mtt_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MPT
case|:
name|err
operator|=
name|mpt_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_CQ
case|:
name|err
operator|=
name|cq_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_SRQ
case|:
name|err
operator|=
name|srq_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MAC
case|:
name|err
operator|=
name|mac_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|,
operator|(
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_VLAN
case|:
name|err
operator|=
name|vlan_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|,
operator|(
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_COUNTER
case|:
name|err
operator|=
name|counter_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|,
operator|(
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_XRCD
case|:
name|err
operator|=
name|xrcdn_alloc_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|qpn
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE
case|:
name|base
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
operator|&
literal|0x7fffff
expr_stmt|;
name|count
operator|=
name|get_param_h
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|base
argument_list|,
name|count
argument_list|,
name|RES_QP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_qp_release_range
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_OP_MAP_ICM
case|:
name|qpn
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
operator|&
literal|0x7fffff
expr_stmt|;
name|err
operator|=
name|qp_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP_RESERVED
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|fw_reserved
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
condition|)
name|__mlx4_qp_free_icm
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_reserved
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|)
condition|)
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|,
name|RES_QP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtt_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|order
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE_AND_MAP
condition|)
return|return
name|err
return|;
name|base
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|order
operator|=
name|get_param_h
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|base
argument_list|,
literal|1
argument_list|,
name|RES_MTT
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MTT
argument_list|,
literal|1
operator|<<
name|order
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_free_mtt_range
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|id
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|mpt
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE
case|:
name|index
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|id
operator|=
name|index
operator|&
name|mpt_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT
argument_list|,
operator|&
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|index
operator|=
name|mpt
operator|->
name|key
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT
argument_list|)
expr_stmt|;
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
literal|1
argument_list|,
name|RES_MPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_mpt_release
argument_list|(
name|dev
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_OP_MAP_ICM
case|:
name|index
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|id
operator|=
name|index
operator|&
name|mpt_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mr_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT_RESERVED
argument_list|,
operator|&
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|__mlx4_mpt_free_icm
argument_list|(
name|dev
argument_list|,
name|mpt
operator|->
name|key
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cq_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|cqn
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE_AND_MAP
case|:
name|cqn
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
literal|1
argument_list|,
name|RES_CQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_cq_free_icm
argument_list|(
name|dev
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|srq_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|srqn
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE_AND_MAP
case|:
name|srqn
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
literal|1
argument_list|,
name|RES_SRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__mlx4_srq_free_icm
argument_list|(
name|dev
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mac_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|in_port
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE_AND_MAP
case|:
name|port
operator|=
operator|!
name|in_port
condition|?
name|get_param_l
argument_list|(
name|out_param
argument_list|)
else|:
name|in_port
expr_stmt|;
name|mac_del_from_slave
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|in_param
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|__mlx4_unregister_mac
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|in_param
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlan_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|slave_state
init|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RES_OP_RESERVE_AND_MAP
case|:
if|if
condition|(
name|slave_state
index|[
name|slave
index|]
operator|.
name|old_vlan_api
operator|==
name|true
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|port
condition|)
return|return
operator|-
name|EINVAL
return|;
name|vlan_del_from_slave
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|in_param
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|__mlx4_unregister_vlan
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|in_param
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|index
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|__mlx4_counter_free
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xrcdn_free_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|cmd
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|)
block|{
name|int
name|xrcdn
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|RES_OP_RESERVE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|xrcdn
operator|=
name|get_param_l
argument_list|(
operator|&
name|in_param
argument_list|)
expr_stmt|;
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|xrcdn
argument_list|,
literal|1
argument_list|,
name|RES_XRCD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|__mlx4_xrcd_free
argument_list|(
name|dev
argument_list|,
name|xrcdn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_FREE_RES_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|alop
init|=
name|vhcr
operator|->
name|op_modifier
decl_stmt|;
switch|switch
condition|(
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0xFF
condition|)
block|{
case|case
name|RES_QP
case|:
name|err
operator|=
name|qp_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MTT
case|:
name|err
operator|=
name|mtt_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MPT
case|:
name|err
operator|=
name|mpt_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_CQ
case|:
name|err
operator|=
name|cq_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_SRQ
case|:
name|err
operator|=
name|srq_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_MAC
case|:
name|err
operator|=
name|mac_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|,
operator|(
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_VLAN
case|:
name|err
operator|=
name|vlan_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|,
operator|(
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_COUNTER
case|:
name|err
operator|=
name|counter_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|,
operator|(
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_XRCD
case|:
name|err
operator|=
name|xrcdn_free_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|alop
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ugly but other choices are uglier */
end_comment

begin_function
specifier|static
name|int
name|mr_phys_mpt
parameter_list|(
name|struct
name|mlx4_mpt_entry
modifier|*
name|mpt
parameter_list|)
block|{
return|return
operator|(
name|be32_to_cpu
argument_list|(
name|mpt
operator|->
name|flags
argument_list|)
operator|>>
literal|9
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mr_get_mtt_addr
parameter_list|(
name|struct
name|mlx4_mpt_entry
modifier|*
name|mpt
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|be64_to_cpu
argument_list|(
name|mpt
operator|->
name|mtt_addr
argument_list|)
operator|&
literal|0xfffffff8
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mr_get_mtt_size
parameter_list|(
name|struct
name|mlx4_mpt_entry
modifier|*
name|mpt
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|mpt
operator|->
name|mtt_sz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|mr_get_pd
parameter_list|(
name|struct
name|mlx4_mpt_entry
modifier|*
name|mpt
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|mpt
operator|->
name|pd_flags
argument_list|)
operator|&
literal|0x00ffffff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mr_is_fmr
parameter_list|(
name|struct
name|mlx4_mpt_entry
modifier|*
name|mpt
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|mpt
operator|->
name|pd_flags
argument_list|)
operator|&
name|MLX4_MPT_PD_FLAG_FAST_REG
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mr_is_bind_enabled
parameter_list|(
name|struct
name|mlx4_mpt_entry
modifier|*
name|mpt
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|mpt
operator|->
name|flags
argument_list|)
operator|&
name|MLX4_MPT_FLAG_BIND_ENABLE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mr_is_region
parameter_list|(
name|struct
name|mlx4_mpt_entry
modifier|*
name|mpt
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|mpt
operator|->
name|flags
argument_list|)
operator|&
name|MLX4_MPT_FLAG_REGION
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_get_mtt_addr
parameter_list|(
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|mtt_base_addr_l
argument_list|)
operator|&
literal|0xfffffff8
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|srq_get_mtt_addr
parameter_list|(
name|struct
name|mlx4_srq_context
modifier|*
name|srqc
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|srqc
operator|->
name|mtt_base_addr_l
argument_list|)
operator|&
literal|0xfffffff8
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_get_mtt_size
parameter_list|(
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
parameter_list|)
block|{
name|int
name|page_shift
init|=
operator|(
name|qpc
operator|->
name|log_page_size
operator|&
literal|0x3f
operator|)
operator|+
literal|12
decl_stmt|;
name|int
name|log_sq_size
init|=
operator|(
name|qpc
operator|->
name|sq_size_stride
operator|>>
literal|3
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|log_sq_sride
init|=
name|qpc
operator|->
name|sq_size_stride
operator|&
literal|7
decl_stmt|;
name|int
name|log_rq_size
init|=
operator|(
name|qpc
operator|->
name|rq_size_stride
operator|>>
literal|3
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|log_rq_stride
init|=
name|qpc
operator|->
name|rq_size_stride
operator|&
literal|7
decl_stmt|;
name|int
name|srq
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|srqn
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|1
decl_stmt|;
name|int
name|rss
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|flags
argument_list|)
operator|>>
literal|13
operator|)
operator|&
literal|1
decl_stmt|;
name|u32
name|ts
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|flags
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
decl_stmt|;
name|int
name|xrc
init|=
operator|(
name|ts
operator|==
name|MLX4_QP_ST_XRC
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|sq_size
decl_stmt|;
name|int
name|rq_size
decl_stmt|;
name|int
name|total_pages
decl_stmt|;
name|int
name|total_mem
decl_stmt|;
name|int
name|page_offset
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|params2
argument_list|)
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|sq_size
operator|=
literal|1
operator|<<
operator|(
name|log_sq_size
operator|+
name|log_sq_sride
operator|+
literal|4
operator|)
expr_stmt|;
name|rq_size
operator|=
operator|(
name|srq
operator||
name|rss
operator||
name|xrc
operator|)
condition|?
literal|0
else|:
operator|(
literal|1
operator|<<
operator|(
name|log_rq_size
operator|+
name|log_rq_stride
operator|+
literal|4
operator|)
operator|)
expr_stmt|;
name|total_mem
operator|=
name|sq_size
operator|+
name|rq_size
expr_stmt|;
name|total_pages
operator|=
name|roundup_pow_of_two
argument_list|(
operator|(
name|total_mem
operator|+
operator|(
name|page_offset
operator|<<
literal|6
operator|)
operator|)
operator|>>
name|page_shift
argument_list|)
expr_stmt|;
return|return
name|total_pages
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_mtt_range
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|res_mtt
modifier|*
name|mtt
parameter_list|)
block|{
name|int
name|res_start
init|=
name|mtt
operator|->
name|com
operator|.
name|res_id
decl_stmt|;
name|int
name|res_size
init|=
operator|(
literal|1
operator|<<
name|mtt
operator|->
name|order
operator|)
decl_stmt|;
if|if
condition|(
name|start
operator|<
name|res_start
operator|||
name|start
operator|+
name|size
operator|>
name|res_start
operator|+
name|res_size
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SW2HW_MPT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|index
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|mpt
decl_stmt|;
name|int
name|mtt_base
init|=
name|mr_get_mtt_addr
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
decl_stmt|;
name|int
name|phys
decl_stmt|;
name|int
name|id
decl_stmt|;
name|u32
name|pd
decl_stmt|;
name|int
name|pd_slave
decl_stmt|;
name|id
operator|=
name|index
operator|&
name|mpt_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mr_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT_HW
argument_list|,
operator|&
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Currently disable memory windows since this feature isn't tested yet 	* under virtualization. 	*/
if|if
condition|(
operator|!
name|mr_is_region
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
goto|goto
name|ex_abort
goto|;
block|}
comment|/* Make sure that the PD bits related to the slave id are zeros. */
name|pd
operator|=
name|mr_get_pd
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
expr_stmt|;
name|pd_slave
operator|=
operator|(
name|pd
operator|>>
literal|17
operator|)
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|pd_slave
operator|!=
literal|0
operator|&&
name|pd_slave
operator|!=
name|slave
condition|)
block|{
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|ex_abort
goto|;
block|}
if|if
condition|(
name|mr_is_fmr
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
condition|)
block|{
comment|/* FMR and Bind Enable are forbidden in slave devices. */
if|if
condition|(
name|mr_is_bind_enabled
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|ex_abort
goto|;
block|}
comment|/* FMR and Memory Windows are also forbidden. */
if|if
condition|(
operator|!
name|mr_is_region
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|ex_abort
goto|;
block|}
block|}
name|phys
operator|=
name|mr_phys_mpt
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phys
condition|)
block|{
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|,
operator|&
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_abort
goto|;
name|err
operator|=
name|check_mtt_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|mr_get_mtt_size
argument_list|(
name|inbox
operator|->
name|buf
argument_list|)
argument_list|,
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put
goto|;
name|mpt
operator|->
name|mtt
operator|=
name|mtt
expr_stmt|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put
goto|;
if|if
condition|(
operator|!
name|phys
condition|)
block|{
name|atomic_inc
argument_list|(
operator|&
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
block|}
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_put
label|:
if|if
condition|(
operator|!
name|phys
condition|)
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|ex_abort
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_HW2SW_MPT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|index
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|mpt
decl_stmt|;
name|int
name|id
decl_stmt|;
name|id
operator|=
name|index
operator|&
name|mpt_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mr_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT_MAPPED
argument_list|,
operator|&
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_abort
goto|;
if|if
condition|(
name|mpt
operator|->
name|mtt
condition|)
name|atomic_dec
argument_list|(
operator|&
name|mpt
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_abort
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_MPT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|index
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|mpt
decl_stmt|;
name|int
name|id
decl_stmt|;
name|id
operator|=
name|index
operator|&
name|mpt_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT
argument_list|,
operator|&
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|mpt
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_MPT_HW
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|out
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|id
argument_list|,
name|RES_MPT
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_get_rcqn
parameter_list|(
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|cqn_recv
argument_list|)
operator|&
literal|0xffffff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_get_scqn
parameter_list|(
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|cqn_send
argument_list|)
operator|&
literal|0xffffff
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|qp_get_srqn
parameter_list|(
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|srqn
argument_list|)
operator|&
literal|0x1ffffff
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_proxy_tun_qkey
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_qp_context
modifier|*
name|context
parameter_list|)
block|{
name|u32
name|qpn
init|=
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0xffffff
decl_stmt|;
name|u32
name|qkey
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mlx4_get_parav_qkey
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|,
operator|&
name|qkey
argument_list|)
condition|)
return|return;
comment|/* adjust qkey in qp context */
name|context
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|qkey
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_RST2INIT_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|qpn
init|=
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0x7fffff
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|int
name|mtt_base
init|=
name|qp_get_mtt_addr
argument_list|(
name|qpc
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
decl_stmt|;
name|int
name|mtt_size
init|=
name|qp_get_mtt_size
argument_list|(
name|qpc
argument_list|)
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|rcq
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|scq
decl_stmt|;
name|int
name|rcqn
init|=
name|qp_get_rcqn
argument_list|(
name|qpc
argument_list|)
decl_stmt|;
name|int
name|scqn
init|=
name|qp_get_scqn
argument_list|(
name|qpc
argument_list|)
decl_stmt|;
name|u32
name|srqn
init|=
name|qp_get_srqn
argument_list|(
name|qpc
argument_list|)
operator|&
literal|0xffffff
decl_stmt|;
name|int
name|use_srq
init|=
operator|(
name|qp_get_srqn
argument_list|(
name|qpc
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|1
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|srq
decl_stmt|;
name|int
name|local_qpn
init|=
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|local_qpn
argument_list|)
operator|&
literal|0xffffff
decl_stmt|;
name|err
operator|=
name|qp_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP_HW
argument_list|,
operator|&
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|qp
operator|->
name|local_qpn
operator|=
name|local_qpn
expr_stmt|;
name|qp
operator|->
name|sched_queue
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|param3
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|vlan_control
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|fvl_rx
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|pri_path_fl
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|vlan_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|feup
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|qpc_flags
operator|=
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|,
operator|&
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_abort
goto|;
name|err
operator|=
name|check_mtt_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|mtt_size
argument_list|,
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put_mtt
goto|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rcqn
argument_list|,
name|RES_CQ
argument_list|,
operator|&
name|rcq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put_mtt
goto|;
if|if
condition|(
name|scqn
operator|!=
name|rcqn
condition|)
block|{
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|scqn
argument_list|,
name|RES_CQ
argument_list|,
operator|&
name|scq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put_rcq
goto|;
block|}
else|else
name|scq
operator|=
name|rcq
expr_stmt|;
if|if
condition|(
name|use_srq
condition|)
block|{
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ
argument_list|,
operator|&
name|srq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put_scq
goto|;
block|}
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|qpc
argument_list|)
expr_stmt|;
name|update_pkey_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put_srq
goto|;
name|atomic_inc
argument_list|(
operator|&
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|qp
operator|->
name|mtt
operator|=
name|mtt
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|rcq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rcq
operator|=
name|rcq
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|scq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|qp
operator|->
name|scq
operator|=
name|scq
expr_stmt|;
if|if
condition|(
name|scqn
operator|!=
name|rcqn
condition|)
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|scqn
argument_list|,
name|RES_CQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_srq
condition|)
block|{
name|atomic_inc
argument_list|(
operator|&
name|srq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ
argument_list|)
expr_stmt|;
name|qp
operator|->
name|srq
operator|=
name|srq
expr_stmt|;
block|}
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rcqn
argument_list|,
name|RES_CQ
argument_list|)
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_put_srq
label|:
if|if
condition|(
name|use_srq
condition|)
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ
argument_list|)
expr_stmt|;
name|ex_put_scq
label|:
if|if
condition|(
name|scqn
operator|!=
name|rcqn
condition|)
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|scqn
argument_list|,
name|RES_CQ
argument_list|)
expr_stmt|;
name|ex_put_rcq
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rcqn
argument_list|,
name|RES_CQ
argument_list|)
expr_stmt|;
name|ex_put_mtt
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|ex_abort
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eq_get_mtt_addr
parameter_list|(
name|struct
name|mlx4_eq_context
modifier|*
name|eqc
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|eqc
operator|->
name|mtt_base_addr_l
argument_list|)
operator|&
literal|0xfffffff8
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eq_get_mtt_size
parameter_list|(
name|struct
name|mlx4_eq_context
modifier|*
name|eqc
parameter_list|)
block|{
name|int
name|log_eq_size
init|=
name|eqc
operator|->
name|log_eq_size
operator|&
literal|0x1f
decl_stmt|;
name|int
name|page_shift
init|=
operator|(
name|eqc
operator|->
name|log_page_size
operator|&
literal|0x3f
operator|)
operator|+
literal|12
decl_stmt|;
if|if
condition|(
name|log_eq_size
operator|+
literal|5
operator|<
name|page_shift
condition|)
return|return
literal|1
return|;
return|return
literal|1
operator|<<
operator|(
name|log_eq_size
operator|+
literal|5
operator|-
name|page_shift
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cq_get_mtt_addr
parameter_list|(
name|struct
name|mlx4_cq_context
modifier|*
name|cqc
parameter_list|)
block|{
return|return
name|be32_to_cpu
argument_list|(
name|cqc
operator|->
name|mtt_base_addr_l
argument_list|)
operator|&
literal|0xfffffff8
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cq_get_mtt_size
parameter_list|(
name|struct
name|mlx4_cq_context
modifier|*
name|cqc
parameter_list|)
block|{
name|int
name|log_cq_size
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|cqc
operator|->
name|logsize_usrpage
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0x1f
decl_stmt|;
name|int
name|page_shift
init|=
operator|(
name|cqc
operator|->
name|log_page_size
operator|&
literal|0x3f
operator|)
operator|+
literal|12
decl_stmt|;
if|if
condition|(
name|log_cq_size
operator|+
literal|5
operator|<
name|page_shift
condition|)
return|return
literal|1
return|;
return|return
literal|1
operator|<<
operator|(
name|log_cq_size
operator|+
literal|5
operator|-
name|page_shift
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SW2HW_EQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|eqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|int
name|res_id
init|=
operator|(
name|slave
operator|<<
literal|8
operator|)
operator||
name|eqn
decl_stmt|;
name|struct
name|mlx4_eq_context
modifier|*
name|eqc
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|int
name|mtt_base
init|=
name|eq_get_mtt_addr
argument_list|(
name|eqc
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
decl_stmt|;
name|int
name|mtt_size
init|=
name|eq_get_mtt_size
argument_list|(
name|eqc
argument_list|)
decl_stmt|;
name|struct
name|res_eq
modifier|*
name|eq
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
literal|1
argument_list|,
name|RES_EQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|eq_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
name|RES_EQ_HW
argument_list|,
operator|&
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_add
goto|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|,
operator|&
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_move
goto|;
name|err
operator|=
name|check_mtt_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|mtt_size
argument_list|,
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_put
goto|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_put
goto|;
name|atomic_inc
argument_list|(
operator|&
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|eq
operator|->
name|mtt
operator|=
name|mtt
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_EQ
argument_list|,
name|res_id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|out_move
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_EQ
argument_list|,
name|res_id
argument_list|)
expr_stmt|;
name|out_add
label|:
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
literal|1
argument_list|,
name|RES_EQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_containing_mtt
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|res_mtt
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|mtt
argument_list|,
argument|&tracker->slave_list[slave].res_list[RES_MTT]
argument_list|,
argument|com.list
argument_list|)
block|{
if|if
condition|(
operator|!
name|check_mtt_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
name|mtt
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|mtt
expr_stmt|;
name|mtt
operator|->
name|com
operator|.
name|from_state
operator|=
name|mtt
operator|->
name|com
operator|.
name|state
expr_stmt|;
name|mtt
operator|->
name|com
operator|.
name|state
operator|=
name|RES_MTT_BUSY
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|verify_qp_parameters
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|enum
name|qp_transition
name|transition
parameter_list|,
name|u8
name|slave
parameter_list|)
block|{
name|u32
name|qp_type
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|qp_ctx
decl_stmt|;
name|enum
name|mlx4_qp_optpar
name|optpar
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|num_gids
decl_stmt|;
name|qp_ctx
operator|=
name|inbox
operator|->
name|buf
operator|+
literal|8
expr_stmt|;
name|qp_type
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|qp_ctx
operator|->
name|flags
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|optpar
operator|=
name|be32_to_cpu
argument_list|(
operator|*
operator|(
name|__be32
operator|*
operator|)
name|inbox
operator|->
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|qp_type
condition|)
block|{
case|case
name|MLX4_QP_ST_RC
case|:
case|case
name|MLX4_QP_ST_UC
case|:
switch|switch
condition|(
name|transition
condition|)
block|{
case|case
name|QP_TRANS_INIT2RTR
case|:
case|case
name|QP_TRANS_RTR2RTS
case|:
case|case
name|QP_TRANS_RTS2RTS
case|:
case|case
name|QP_TRANS_SQD2SQD
case|:
case|case
name|QP_TRANS_SQD2RTS
case|:
if|if
condition|(
name|slave
operator|!=
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
if|if
condition|(
name|optpar
operator|&
name|MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH
condition|)
block|{
name|port
operator|=
operator|(
name|qp_ctx
operator|->
name|pri_path
operator|.
name|sched_queue
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port
index|]
operator|!=
name|MLX4_PORT_TYPE_IB
condition|)
name|num_gids
operator|=
name|mlx4_get_slave_num_gids
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
else|else
name|num_gids
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|qp_ctx
operator|->
name|pri_path
operator|.
name|mgid_index
operator|>=
name|num_gids
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|optpar
operator|&
name|MLX4_QP_OPTPAR_ALT_ADDR_PATH
condition|)
block|{
name|port
operator|=
operator|(
name|qp_ctx
operator|->
name|alt_path
operator|.
name|sched_queue
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port
index|]
operator|!=
name|MLX4_PORT_TYPE_IB
condition|)
name|num_gids
operator|=
name|mlx4_get_slave_num_gids
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
else|else
name|num_gids
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|qp_ctx
operator|->
name|alt_path
operator|.
name|mgid_index
operator|>=
name|num_gids
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_WRITE_MTT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_mtt
name|mtt
decl_stmt|;
name|__be64
modifier|*
name|page_list
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|u64
modifier|*
name|pg_list
init|=
operator|(
name|u64
operator|*
operator|)
name|page_list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|rmtt
init|=
name|NULL
decl_stmt|;
name|int
name|start
init|=
name|be64_to_cpu
argument_list|(
name|page_list
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|npages
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|get_containing_mtt
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|start
argument_list|,
name|npages
argument_list|,
operator|&
name|rmtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Call the SW implementation of write_mtt: 	 * - Prepare a dummy mtt struct 	 * - Translate inbox contents to simple addresses in host endianness */
name|mtt
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* TBD this is broken but I don't handle it since 			    we don't really use it */
name|mtt
operator|.
name|order
operator|=
literal|0
expr_stmt|;
name|mtt
operator|.
name|page_shift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
operator|++
name|i
control|)
name|pg_list
index|[
name|i
operator|+
literal|2
index|]
operator|=
operator|(
name|be64_to_cpu
argument_list|(
name|page_list
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
operator|&
operator|~
literal|1ULL
operator|)
expr_stmt|;
name|err
operator|=
name|__mlx4_write_mtt
argument_list|(
name|dev
argument_list|,
operator|&
name|mtt
argument_list|,
name|be64_to_cpu
argument_list|(
name|page_list
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|npages
argument_list|,
operator|(
operator|(
name|u64
operator|*
operator|)
name|page_list
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmtt
condition|)
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rmtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_HW2SW_EQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|eqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|int
name|res_id
init|=
name|eqn
operator||
operator|(
name|slave
operator|<<
literal|8
operator|)
decl_stmt|;
name|struct
name|res_eq
modifier|*
name|eq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|eq_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
name|RES_EQ_RESERVED
argument_list|,
operator|&
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|eq
operator|->
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_abort
goto|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put
goto|;
name|atomic_dec
argument_list|(
operator|&
name|eq
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|eq
operator|->
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_EQ
argument_list|,
name|res_id
argument_list|)
expr_stmt|;
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
literal|1
argument_list|,
name|RES_EQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|eq
operator|->
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|ex_abort
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_EQ
argument_list|,
name|res_id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_GEN_EQE
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_eqe
modifier|*
name|eqe
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_event_eq_info
modifier|*
name|event_eq
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
name|in_modifier
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|res_id
decl_stmt|;
name|struct
name|res_eq
modifier|*
name|req
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* check for slave valid, slave not PF, and slave active */
if|if
condition|(
name|slave
operator|<
literal|0
operator|||
name|slave
operator|>=
name|dev
operator|->
name|num_slaves
operator|||
name|slave
operator|==
name|dev
operator|->
name|caps
operator|.
name|function
operator|||
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|active
condition|)
return|return
literal|0
return|;
name|event_eq
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|event_eq
index|[
name|eqe
operator|->
name|type
index|]
expr_stmt|;
comment|/* Create the event only if the slave is registered */
if|if
condition|(
name|event_eq
operator|->
name|eqn
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|gen_eqe_mutex
index|[
name|slave
index|]
argument_list|)
expr_stmt|;
name|res_id
operator|=
operator|(
name|slave
operator|<<
literal|8
operator|)
operator||
name|event_eq
operator|->
name|eqn
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
name|RES_EQ
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|unlock
goto|;
if|if
condition|(
name|req
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_EQ_HW
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|put
goto|;
block|}
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
goto|goto
name|put
goto|;
block|}
if|if
condition|(
name|eqe
operator|->
name|type
operator|==
name|MLX4_EVENT_TYPE_CMD
condition|)
block|{
operator|++
name|event_eq
operator|->
name|token
expr_stmt|;
name|eqe
operator|->
name|event
operator|.
name|cmd
operator|.
name|token
operator|=
name|cpu_to_be16
argument_list|(
name|event_eq
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|eqe
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|in_modifier
operator|=
operator|(
name|slave
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|event_eq
operator|->
name|eqn
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_modifier
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_GEN_EQE
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
name|RES_EQ
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|gen_eqe_mutex
index|[
name|slave
index|]
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
name|put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
name|RES_EQ
argument_list|)
expr_stmt|;
name|unlock
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|gen_eqe_mutex
index|[
name|slave
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_EQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|eqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|int
name|res_id
init|=
name|eqn
operator||
operator|(
name|slave
operator|<<
literal|8
operator|)
decl_stmt|;
name|struct
name|res_eq
modifier|*
name|eq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
name|RES_EQ
argument_list|,
operator|&
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|eq
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_EQ_HW
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|ex_put
goto|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ex_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|res_id
argument_list|,
name|RES_EQ
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SW2HW_CQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|cqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|mlx4_cq_context
modifier|*
name|cqc
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|int
name|mtt_base
init|=
name|cq_get_mtt_addr
argument_list|(
name|cqc
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|cq
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|err
operator|=
name|cq_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
name|RES_CQ_HW
argument_list|,
operator|&
name|cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|,
operator|&
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_move
goto|;
name|err
operator|=
name|check_mtt_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|cq_get_mtt_size
argument_list|(
name|cqc
argument_list|)
argument_list|,
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_put
goto|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_put
goto|;
name|atomic_inc
argument_list|(
operator|&
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|cq
operator|->
name|mtt
operator|=
name|mtt
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|out_move
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_HW2SW_CQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|cqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|cq
decl_stmt|;
name|err
operator|=
name|cq_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
name|RES_CQ_ALLOCATED
argument_list|,
operator|&
name|cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_move
goto|;
name|atomic_dec
argument_list|(
operator|&
name|cq
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_move
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_CQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|cqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|cq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
name|RES_CQ
argument_list|,
operator|&
name|cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|cq
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_CQ_HW
condition|)
goto|goto
name|ex_put
goto|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ex_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
name|RES_CQ
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|handle_resize
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|,
name|struct
name|res_cq
modifier|*
name|cq
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|orig_mtt
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|struct
name|mlx4_cq_context
modifier|*
name|cqc
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|int
name|mtt_base
init|=
name|cq_get_mtt_addr
argument_list|(
name|cqc
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
decl_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cq
operator|->
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|,
operator|&
name|orig_mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|orig_mtt
operator|!=
name|cq
operator|->
name|mtt
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|ex_put
goto|;
block|}
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|,
operator|&
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put
goto|;
name|err
operator|=
name|check_mtt_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|cq_get_mtt_size
argument_list|(
name|cqc
argument_list|)
argument_list|,
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put1
goto|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put1
goto|;
name|atomic_dec
argument_list|(
operator|&
name|orig_mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|orig_mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|cq
operator|->
name|mtt
operator|=
name|mtt
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_put1
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|ex_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|orig_mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_MODIFY_CQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|cqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|cq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
name|RES_CQ
argument_list|,
operator|&
name|cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|cq
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_CQ_HW
condition|)
goto|goto
name|ex_put
goto|;
if|if
condition|(
name|vhcr
operator|->
name|op_modifier
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|handle_resize
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|,
name|cq
argument_list|)
expr_stmt|;
goto|goto
name|ex_put
goto|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ex_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|,
name|RES_CQ
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|srq_get_mtt_size
parameter_list|(
name|struct
name|mlx4_srq_context
modifier|*
name|srqc
parameter_list|)
block|{
name|int
name|log_srq_size
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|srqc
operator|->
name|state_logsize_srqn
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|log_rq_stride
init|=
name|srqc
operator|->
name|logstride
operator|&
literal|7
decl_stmt|;
name|int
name|page_shift
init|=
operator|(
name|srqc
operator|->
name|log_page_size
operator|&
literal|0x3f
operator|)
operator|+
literal|12
decl_stmt|;
if|if
condition|(
name|log_srq_size
operator|+
name|log_rq_stride
operator|+
literal|4
operator|<
name|page_shift
condition|)
return|return
literal|1
return|;
return|return
literal|1
operator|<<
operator|(
name|log_srq_size
operator|+
name|log_rq_stride
operator|+
literal|4
operator|-
name|page_shift
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SW2HW_SRQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|srqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|mlx4_srq_context
modifier|*
name|srqc
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|int
name|mtt_base
init|=
name|srq_get_mtt_addr
argument_list|(
name|srqc
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
decl_stmt|;
if|if
condition|(
name|srqn
operator|!=
operator|(
name|be32_to_cpu
argument_list|(
name|srqc
operator|->
name|state_logsize_srqn
argument_list|)
operator|&
literal|0xffffff
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|err
operator|=
name|srq_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ_HW
argument_list|,
operator|&
name|srq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|RES_MTT
argument_list|,
operator|&
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_abort
goto|;
name|err
operator|=
name|check_mtt_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt_base
argument_list|,
name|srq_get_mtt_size
argument_list|(
name|srqc
argument_list|)
argument_list|,
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put_mtt
goto|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put_mtt
goto|;
name|atomic_inc
argument_list|(
operator|&
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|srq
operator|->
name|mtt
operator|=
name|mtt
expr_stmt|;
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_put_mtt
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|mtt
operator|->
name|com
operator|.
name|res_id
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
name|ex_abort
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_HW2SW_SRQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|srqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|srq
decl_stmt|;
name|err
operator|=
name|srq_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ_ALLOCATED
argument_list|,
operator|&
name|srq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_abort
goto|;
name|atomic_dec
argument_list|(
operator|&
name|srq
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|srq
operator|->
name|cq
condition|)
name|atomic_dec
argument_list|(
operator|&
name|srq
operator|->
name|cq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_abort
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_SRQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|srqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|srq
decl_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ
argument_list|,
operator|&
name|srq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|srq
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_SRQ_HW
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|out
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ARM_SRQ_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|srqn
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|srq
decl_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ
argument_list|,
operator|&
name|srq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|srq
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_SRQ_HW
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|out
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|,
name|RES_SRQ
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_GEN_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|qpn
init|=
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0x7fffff
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|qp
decl_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|,
operator|&
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|qp
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_QP_HW
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|out
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT2INIT_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_qp_context
modifier|*
name|context
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|update_pkey_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
return|return
name|mlx4_GEN_QP_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|roce_verify_mac
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|)
block|{
name|u64
name|mac
decl_stmt|;
name|int
name|port
decl_stmt|;
name|u32
name|ts
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|qpc
operator|->
name|flags
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
decl_stmt|;
name|u8
name|sched
init|=
operator|*
operator|(
name|u8
operator|*
operator|)
operator|(
name|inbox
operator|->
name|buf
operator|+
literal|64
operator|)
decl_stmt|;
name|u8
name|smac_ix
decl_stmt|;
name|port
operator|=
operator|(
name|sched
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mlx4_is_eth
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
operator|&&
operator|(
name|ts
operator|!=
name|MLX4_QP_ST_MLX
operator|)
condition|)
block|{
name|smac_ix
operator|=
name|qpc
operator|->
name|pri_path
operator|.
name|grh_mylmc
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|mac_find_smac_ix_in_slave
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|,
name|smac_ix
argument_list|,
operator|&
name|mac
argument_list|)
condition|)
return|return
operator|-
name|ENOENT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT2RTR_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|qpc
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|int
name|qpn
init|=
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0x7fffff
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|qp
decl_stmt|;
name|u8
name|orig_sched_queue
decl_stmt|;
name|__be32
name|orig_param3
init|=
name|qpc
operator|->
name|param3
decl_stmt|;
name|u8
name|orig_vlan_control
init|=
name|qpc
operator|->
name|pri_path
operator|.
name|vlan_control
decl_stmt|;
name|u8
name|orig_fvl_rx
init|=
name|qpc
operator|->
name|pri_path
operator|.
name|fvl_rx
decl_stmt|;
name|u8
name|orig_pri_path_fl
init|=
name|qpc
operator|->
name|pri_path
operator|.
name|fl
decl_stmt|;
name|u8
name|orig_vlan_index
init|=
name|qpc
operator|->
name|pri_path
operator|.
name|vlan_index
decl_stmt|;
name|u8
name|orig_feup
init|=
name|qpc
operator|->
name|pri_path
operator|.
name|feup
decl_stmt|;
name|err
operator|=
name|verify_qp_parameters
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
name|QP_TRANS_INIT2RTR
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|roce_verify_mac
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpc
argument_list|,
name|inbox
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|update_pkey_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
name|update_gid
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
operator|(
name|u8
operator|)
name|slave
argument_list|)
expr_stmt|;
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|qpc
argument_list|)
expr_stmt|;
name|orig_sched_queue
operator|=
name|qpc
operator|->
name|pri_path
operator|.
name|sched_queue
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|,
operator|&
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|qp
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_QP_HW
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* do not modify vport QP params for RSS QPs */
if|if
condition|(
operator|!
operator|(
name|qp
operator|->
name|qpc_flags
operator|&
operator|(
literal|1
operator|<<
name|MLX4_RSS_QPC_FLAG_OFFSET
operator|)
operator|)
condition|)
block|{
name|err
operator|=
name|update_vport_qp_param
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* if no error, save sched queue value passed in by VF. This is 	 * essentially the QOS value provided by the VF. This will be useful 	 * if we allow dynamic changes from VST back to VGT 	 */
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|qp
operator|->
name|sched_queue
operator|=
name|orig_sched_queue
expr_stmt|;
name|qp
operator|->
name|param3
operator|=
name|orig_param3
expr_stmt|;
name|qp
operator|->
name|vlan_control
operator|=
name|orig_vlan_control
expr_stmt|;
name|qp
operator|->
name|fvl_rx
operator|=
name|orig_fvl_rx
expr_stmt|;
name|qp
operator|->
name|pri_path_fl
operator|=
name|orig_pri_path_fl
expr_stmt|;
name|qp
operator|->
name|vlan_index
operator|=
name|orig_vlan_index
expr_stmt|;
name|qp
operator|->
name|feup
operator|=
name|orig_feup
expr_stmt|;
block|}
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_RTR2RTS_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|context
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|err
operator|=
name|verify_qp_parameters
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
name|QP_TRANS_RTR2RTS
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|update_pkey_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
name|update_gid
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
operator|(
name|u8
operator|)
name|slave
argument_list|)
expr_stmt|;
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|mlx4_GEN_QP_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_RTS2RTS_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|context
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|err
operator|=
name|verify_qp_parameters
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
name|QP_TRANS_RTS2RTS
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|update_pkey_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
name|update_gid
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
operator|(
name|u8
operator|)
name|slave
argument_list|)
expr_stmt|;
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|mlx4_GEN_QP_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SQERR2RTS_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_qp_context
modifier|*
name|context
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|mlx4_GEN_QP_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SQD2SQD_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|context
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|err
operator|=
name|verify_qp_parameters
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
name|QP_TRANS_SQD2SQD
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|update_gid
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
operator|(
name|u8
operator|)
name|slave
argument_list|)
expr_stmt|;
name|update_pkey_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
return|return
name|mlx4_GEN_QP_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SQD2RTS_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|context
init|=
name|inbox
operator|->
name|buf
operator|+
literal|8
decl_stmt|;
name|err
operator|=
name|verify_qp_parameters
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
name|QP_TRANS_SQD2RTS
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|adjust_proxy_tun_qkey
argument_list|(
name|dev
argument_list|,
name|vhcr
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|update_gid
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|,
operator|(
name|u8
operator|)
name|slave
argument_list|)
expr_stmt|;
name|update_pkey_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
return|return
name|mlx4_GEN_QP_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_2RST_QP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|qpn
init|=
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0x7fffff
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|qp
decl_stmt|;
name|err
operator|=
name|qp_res_start_move_to
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP_MAPPED
argument_list|,
operator|&
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_abort
goto|;
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|rcq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|scq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|srq
condition|)
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|srq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|res_end_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ex_abort
label|:
name|res_abort_move
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|res_gid
modifier|*
name|find_gid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|res_qp
modifier|*
name|rqp
parameter_list|,
name|u8
modifier|*
name|gid
parameter_list|)
block|{
name|struct
name|res_gid
modifier|*
name|res
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|res
argument_list|,
argument|&rqp->mcg_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|res
operator|->
name|gid
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|res
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_mcg_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|res_qp
modifier|*
name|rqp
parameter_list|,
name|u8
modifier|*
name|gid
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|u64
name|reg_id
parameter_list|)
block|{
name|struct
name|res_gid
modifier|*
name|res
decl_stmt|;
name|int
name|err
decl_stmt|;
name|res
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|res
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|spin_lock_irq
argument_list|(
operator|&
name|rqp
operator|->
name|mcg_spl
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_gid
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rqp
argument_list|,
name|gid
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EEXIST
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|res
operator|->
name|gid
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|res
operator|->
name|prot
operator|=
name|prot
expr_stmt|;
name|res
operator|->
name|steer
operator|=
name|steer
expr_stmt|;
name|res
operator|->
name|reg_id
operator|=
name|reg_id
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|,
operator|&
name|rqp
operator|->
name|mcg_list
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|rqp
operator|->
name|mcg_spl
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rem_mcg_res
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|res_qp
modifier|*
name|rqp
parameter_list|,
name|u8
modifier|*
name|gid
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
name|struct
name|res_gid
modifier|*
name|res
decl_stmt|;
name|int
name|err
decl_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|rqp
operator|->
name|mcg_spl
argument_list|)
expr_stmt|;
name|res
operator|=
name|find_gid
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rqp
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|||
name|res
operator|->
name|prot
operator|!=
name|prot
operator|||
name|res
operator|->
name|steer
operator|!=
name|steer
condition|)
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
else|else
block|{
operator|*
name|reg_id
operator|=
name|res
operator|->
name|reg_id
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|res
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|rqp
operator|->
name|mcg_spl
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_attach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|int
name|block_loopback
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|enum
name|mlx4_steer_type
name|type
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
condition|)
block|{
case|case
name|MLX4_STEERING_MODE_DEVICE_MANAGED
case|:
return|return
name|mlx4_trans_to_dmfs_attach
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|gid
index|[
literal|5
index|]
argument_list|,
name|block_loopback
argument_list|,
name|prot
argument_list|,
name|reg_id
argument_list|)
return|;
case|case
name|MLX4_STEERING_MODE_B0
case|:
return|return
name|mlx4_qp_attach_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|block_loopback
argument_list|,
name|prot
argument_list|,
name|type
argument_list|)
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|qp_detach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|enum
name|mlx4_steer_type
name|type
parameter_list|,
name|u64
name|reg_id
parameter_list|)
block|{
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
condition|)
block|{
case|case
name|MLX4_STEERING_MODE_DEVICE_MANAGED
case|:
return|return
name|mlx4_flow_detach
argument_list|(
name|dev
argument_list|,
name|reg_id
argument_list|)
return|;
case|case
name|MLX4_STEERING_MODE_B0
case|:
return|return
name|mlx4_qp_detach_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|type
argument_list|)
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_QP_ATTACH_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_qp
name|qp
decl_stmt|;
comment|/* dummy for calling attach/detach */
name|u8
modifier|*
name|gid
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|enum
name|mlx4_protocol
name|prot
init|=
operator|(
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|28
operator|)
operator|&
literal|0x7
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|qpn
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|rqp
decl_stmt|;
name|u64
name|reg_id
init|=
literal|0
decl_stmt|;
name|int
name|attach
init|=
name|vhcr
operator|->
name|op_modifier
decl_stmt|;
name|int
name|block_loopback
init|=
name|vhcr
operator|->
name|in_modifier
operator|>>
literal|31
decl_stmt|;
name|u8
name|steer_type_mask
init|=
literal|2
decl_stmt|;
name|enum
name|mlx4_steer_type
name|type
init|=
operator|(
name|gid
index|[
literal|7
index|]
operator|&
name|steer_type_mask
operator|)
operator|>>
literal|1
decl_stmt|;
name|qpn
operator|=
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0xffffff
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|,
operator|&
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|qp
operator|.
name|qpn
operator|=
name|qpn
expr_stmt|;
if|if
condition|(
name|attach
condition|)
block|{
name|err
operator|=
name|qp_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|gid
argument_list|,
name|block_loopback
argument_list|,
name|prot
argument_list|,
name|type
argument_list|,
operator|&
name|reg_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_err
argument_list|(
literal|"Fail to attach rule to qp 0x%x\n"
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
goto|goto
name|ex_put
goto|;
block|}
name|err
operator|=
name|add_mcg_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rqp
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|type
argument_list|,
name|reg_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_detach
goto|;
block|}
else|else
block|{
name|err
operator|=
name|rem_mcg_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rqp
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|type
argument_list|,
operator|&
name|reg_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ex_put
goto|;
name|err
operator|=
name|qp_detach
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|type
argument_list|,
name|reg_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_err
argument_list|(
literal|"Fail to detach rule from qp 0x%x reg_id = 0x%llx\n"
argument_list|,
name|qpn
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|reg_id
argument_list|)
expr_stmt|;
block|}
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
name|ex_detach
label|:
name|qp_detach
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|type
argument_list|,
name|reg_id
argument_list|)
expr_stmt|;
name|ex_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * MAC validation for Flow Steering rules.  * VF can attach rules only with a mac address which is assigned to it.  */
end_comment

begin_function
specifier|static
name|int
name|validate_eth_header_mac
parameter_list|(
name|int
name|slave
parameter_list|,
name|struct
name|_rule_hw
modifier|*
name|eth_header
parameter_list|,
name|struct
name|list_head
modifier|*
name|rlist
parameter_list|)
block|{
name|struct
name|mac_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|__be64
name|be_mac
decl_stmt|;
comment|/* make sure it isn't multicast or broadcast mac*/
if|if
condition|(
operator|!
name|is_multicast_ether_addr
argument_list|(
name|eth_header
operator|->
name|eth
operator|.
name|dst_mac
argument_list|)
operator|&&
operator|!
name|is_broadcast_ether_addr
argument_list|(
name|eth_header
operator|->
name|eth
operator|.
name|dst_mac
argument_list|)
condition|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|rlist
argument_list|,
argument|list
argument_list|)
block|{
name|be_mac
operator|=
name|cpu_to_be64
argument_list|(
name|res
operator|->
name|mac
operator|<<
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|be_mac
argument_list|,
name|eth_header
operator|->
name|eth
operator|.
name|dst_mac
argument_list|,
name|ETH_ALEN
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|pr_err
argument_list|(
literal|"MAC %pM doesn't belong to VF %d, Steering rule rejected\n"
argument_list|,
name|eth_header
operator|->
name|eth
operator|.
name|dst_mac
argument_list|,
name|slave
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * In case of missing eth header, append eth header with a MAC address  * assigned to the VF.  */
end_comment

begin_function
specifier|static
name|int
name|add_eth_header
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|list_head
modifier|*
name|rlist
parameter_list|,
name|int
name|header_id
parameter_list|)
block|{
name|struct
name|mac_res
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u8
name|port
decl_stmt|;
name|struct
name|mlx4_net_trans_rule_hw_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|mlx4_net_trans_rule_hw_eth
modifier|*
name|eth_header
decl_stmt|;
name|struct
name|mlx4_net_trans_rule_hw_ipv4
modifier|*
name|ip_header
decl_stmt|;
name|struct
name|mlx4_net_trans_rule_hw_tcp_udp
modifier|*
name|l4_header
decl_stmt|;
name|__be64
name|be_mac
init|=
literal|0
decl_stmt|;
name|__be64
name|mac_msk
init|=
name|cpu_to_be64
argument_list|(
name|MLX4_MAC_MASK
operator|<<
literal|16
argument_list|)
decl_stmt|;
name|ctrl
operator|=
operator|(
expr|struct
name|mlx4_net_trans_rule_hw_ctrl
operator|*
operator|)
name|inbox
operator|->
name|buf
expr_stmt|;
name|port
operator|=
name|ctrl
operator|->
name|port
expr_stmt|;
name|eth_header
operator|=
operator|(
expr|struct
name|mlx4_net_trans_rule_hw_eth
operator|*
operator|)
operator|(
name|ctrl
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Clear a space in the inbox for eth header */
switch|switch
condition|(
name|header_id
condition|)
block|{
case|case
name|MLX4_NET_TRANS_RULE_ID_IPV4
case|:
name|ip_header
operator|=
operator|(
expr|struct
name|mlx4_net_trans_rule_hw_ipv4
operator|*
operator|)
operator|(
name|eth_header
operator|+
literal|1
operator|)
expr_stmt|;
name|memmove
argument_list|(
name|ip_header
argument_list|,
name|eth_header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|l4_header
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_TCP
case|:
case|case
name|MLX4_NET_TRANS_RULE_ID_UDP
case|:
name|l4_header
operator|=
operator|(
expr|struct
name|mlx4_net_trans_rule_hw_tcp_udp
operator|*
operator|)
operator|(
name|eth_header
operator|+
literal|1
operator|)
expr_stmt|;
name|memmove
argument_list|(
name|l4_header
argument_list|,
name|eth_header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l4_header
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|res
argument_list|,
argument|tmp
argument_list|,
argument|rlist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|port
operator|==
name|res
operator|->
name|port
condition|)
block|{
name|be_mac
operator|=
name|cpu_to_be64
argument_list|(
name|res
operator|->
name|mac
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|be_mac
condition|)
block|{
name|pr_err
argument_list|(
literal|"Failed adding eth header to FS rule, Can't find matching MAC for port %d .\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|memset
argument_list|(
name|eth_header
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eth_header
argument_list|)
argument_list|)
expr_stmt|;
name|eth_header
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eth_header
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|eth_header
operator|->
name|id
operator|=
name|cpu_to_be16
argument_list|(
name|__sw_id_hw
index|[
name|MLX4_NET_TRANS_RULE_ID_ETH
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|eth_header
operator|->
name|dst_mac
argument_list|,
operator|&
name|be_mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|eth_header
operator|->
name|dst_mac_msk
argument_list|,
operator|&
name|mac_msk
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QP_FLOW_STEERING_ATTACH_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|rlist
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MAC
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|qpn
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|rqp
decl_stmt|;
name|struct
name|mlx4_net_trans_rule_hw_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|_rule_hw
modifier|*
name|rule_header
decl_stmt|;
name|int
name|header_id
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|!=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
return|return
operator|-
name|EOPNOTSUPP
return|;
name|ctrl
operator|=
operator|(
expr|struct
name|mlx4_net_trans_rule_hw_ctrl
operator|*
operator|)
name|inbox
operator|->
name|buf
expr_stmt|;
name|qpn
operator|=
name|be32_to_cpu
argument_list|(
name|ctrl
operator|->
name|qpn
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|,
operator|&
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_err
argument_list|(
literal|"Steering rule with qpn 0x%x rejected.\n"
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|rule_header
operator|=
operator|(
expr|struct
name|_rule_hw
operator|*
operator|)
operator|(
name|ctrl
operator|+
literal|1
operator|)
expr_stmt|;
name|header_id
operator|=
name|map_hw_to_sw_id
argument_list|(
name|be16_to_cpu
argument_list|(
name|rule_header
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header_id
condition|)
block|{
case|case
name|MLX4_NET_TRANS_RULE_ID_ETH
case|:
if|if
condition|(
name|validate_eth_header_mac
argument_list|(
name|slave
argument_list|,
name|rule_header
argument_list|,
name|rlist
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_put
goto|;
block|}
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_IB
case|:
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_IPV4
case|:
case|case
name|MLX4_NET_TRANS_RULE_ID_TCP
case|:
case|case
name|MLX4_NET_TRANS_RULE_ID_UDP
case|:
name|pr_warn
argument_list|(
literal|"Can't attach FS rule without L2 headers, adding L2 header.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_eth_header
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|inbox
argument_list|,
name|rlist
argument_list|,
name|header_id
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_put
goto|;
block|}
name|vhcr
operator|->
name|in_modifier
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_eth
argument_list|)
operator|>>
literal|2
expr_stmt|;
break|break;
default|default:
name|pr_err
argument_list|(
literal|"Corrupted mailbox.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_put
goto|;
block|}
name|err
operator|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
operator|&
name|vhcr
operator|->
name|out_param
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_ATTACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_put
goto|;
name|err
operator|=
name|add_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|out_param
argument_list|,
literal|1
argument_list|,
name|RES_FS_RULE
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Fail to add flow steering resources.\n "
argument_list|)
expr_stmt|;
comment|/* detach rule*/
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|vhcr
operator|->
name|out_param
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_DETACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
goto|goto
name|err_put
goto|;
block|}
name|atomic_inc
argument_list|(
operator|&
name|rqp
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|err_put
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|,
name|RES_QP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QP_FLOW_STEERING_DETACH_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|rqp
decl_stmt|;
name|struct
name|res_fs_rule
modifier|*
name|rrule
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|!=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
return|return
operator|-
name|EOPNOTSUPP
return|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
name|RES_FS_RULE
argument_list|,
operator|&
name|rrule
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Release the rule form busy state before removal */
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
name|RES_FS_RULE
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rrule
operator|->
name|qpn
argument_list|,
name|RES_QP
argument_list|,
operator|&
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_DETACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|rem_res_range
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
literal|1
argument_list|,
name|RES_FS_RULE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|rqp
operator|->
name|ref_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Fail to remove flow steering resources.\n "
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|put_res
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|rrule
operator|->
name|qpn
argument_list|,
name|RES_QP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|BUSY_MAX_RETRIES
init|=
literal|10
block|}
enum|;
end_enum

begin_function
name|int
name|mlx4_QUERY_IF_STAT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_DMA_wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|detach_qp
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|res_qp
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|res_gid
modifier|*
name|rgid
decl_stmt|;
name|struct
name|res_gid
modifier|*
name|tmp
decl_stmt|;
name|struct
name|mlx4_qp
name|qp
decl_stmt|;
comment|/* dummy for calling attach/detach */
name|list_for_each_entry_safe
argument_list|(
argument|rgid
argument_list|,
argument|tmp
argument_list|,
argument|&rqp->mcg_list
argument_list|,
argument|list
argument_list|)
block|{
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
condition|)
block|{
case|case
name|MLX4_STEERING_MODE_DEVICE_MANAGED
case|:
name|mlx4_flow_detach
argument_list|(
name|dev
argument_list|,
name|rgid
operator|->
name|reg_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_STEERING_MODE_B0
case|:
name|qp
operator|.
name|qpn
operator|=
name|rqp
operator|->
name|local_qpn
expr_stmt|;
operator|(
name|void
operator|)
name|mlx4_qp_detach_common
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|rgid
operator|->
name|gid
argument_list|,
name|rgid
operator|->
name|prot
argument_list|,
name|rgid
operator|->
name|steer
argument_list|)
expr_stmt|;
break|break;
block|}
name|list_del
argument_list|(
operator|&
name|rgid
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|rgid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_move_all_busy
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|,
name|int
name|print
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|rlist
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|type
index|]
decl_stmt|;
name|struct
name|res_common
modifier|*
name|r
decl_stmt|;
name|struct
name|res_common
modifier|*
name|tmp
decl_stmt|;
name|int
name|busy
decl_stmt|;
name|busy
operator|=
literal|0
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|r
argument_list|,
argument|tmp
argument_list|,
argument|rlist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|r
operator|->
name|owner
operator|==
name|slave
condition|)
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|removing
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|state
operator|==
name|RES_ANY_BUSY
condition|)
block|{
if|if
condition|(
name|print
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s id 0x%llx is busy\n"
argument_list|,
name|ResourceType
argument_list|(
name|type
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r
operator|->
name|res_id
argument_list|)
expr_stmt|;
operator|++
name|busy
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|from_state
operator|=
name|r
operator|->
name|state
expr_stmt|;
name|r
operator|->
name|state
operator|=
name|RES_ANY_BUSY
expr_stmt|;
name|r
operator|->
name|removing
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|busy
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|move_all_busy
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|enum
name|mlx4_resource
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|begin
decl_stmt|;
name|int
name|busy
decl_stmt|;
name|begin
operator|=
name|jiffies
expr_stmt|;
do|do
block|{
name|busy
operator|=
name|_move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|jiffies
argument_list|,
name|begin
operator|+
literal|5
operator|*
name|HZ
argument_list|)
condition|)
break|break;
if|if
condition|(
name|busy
condition|)
name|cond_resched
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|busy
condition|)
do|;
if|if
condition|(
name|busy
condition|)
name|busy
operator|=
name|_move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|busy
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_qps
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|qp_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_QP
index|]
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|tmp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|u64
name|in_param
decl_stmt|;
name|int
name|qpn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_qps: Could not move all qps to busy"
literal|"for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|qp
argument_list|,
argument|tmp
argument_list|,
argument|qp_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
condition|)
block|{
name|qpn
operator|=
name|qp
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|detach_qp
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|state
operator|=
name|qp
operator|->
name|com
operator|.
name|from_state
expr_stmt|;
while|while
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_QP_RESERVED
case|:
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|qp
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_QP
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|qp
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_reserved
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|)
condition|)
block|{
name|__mlx4_qp_release_range
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_QP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_QP_MAPPED
case|:
if|if
condition|(
operator|!
name|valid_reserved
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|qpn
argument_list|)
condition|)
name|__mlx4_qp_free_icm
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
name|state
operator|=
name|RES_QP_RESERVED
expr_stmt|;
break|break;
case|case
name|RES_QP_HW
case|:
name|in_param
operator|=
name|slave
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|qp
operator|->
name|local_qpn
argument_list|,
literal|2
argument_list|,
name|MLX4_CMD_2RST_QP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_qps: failed"
literal|" to move slave %d qpn %d to"
literal|" reset\n"
argument_list|,
name|slave
argument_list|,
name|qp
operator|->
name|local_qpn
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|rcq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|scq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|srq
condition|)
name|atomic_dec
argument_list|(
operator|&
name|qp
operator|->
name|srq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|state
operator|=
name|RES_QP_MAPPED
expr_stmt|;
break|break;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_srqs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|srq_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_SRQ
index|]
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|res_srq
modifier|*
name|tmp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|u64
name|in_param
decl_stmt|;
name|LIST_HEAD
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|int
name|srqn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_srqs: Could not move all srqs to "
literal|"busy for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|srq
argument_list|,
argument|tmp
argument_list|,
argument|srq_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srq
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
condition|)
block|{
name|srqn
operator|=
name|srq
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|state
operator|=
name|srq
operator|->
name|com
operator|.
name|from_state
expr_stmt|;
while|while
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_SRQ_ALLOCATED
case|:
name|__mlx4_srq_free_icm
argument_list|(
name|dev
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|srq
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_SRQ
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|srq
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_SRQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|srq
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_SRQ_HW
case|:
name|in_param
operator|=
name|slave
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|srqn
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_HW2SW_SRQ
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_srqs: failed"
literal|" to move slave %d srq %d to"
literal|" SW ownership\n"
argument_list|,
name|slave
argument_list|,
name|srqn
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|srq
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|srq
operator|->
name|cq
condition|)
name|atomic_dec
argument_list|(
operator|&
name|srq
operator|->
name|cq
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|state
operator|=
name|RES_SRQ_ALLOCATED
expr_stmt|;
break|break;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_cqs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|cq_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_CQ
index|]
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|cq
decl_stmt|;
name|struct
name|res_cq
modifier|*
name|tmp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|u64
name|in_param
decl_stmt|;
name|LIST_HEAD
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|int
name|cqn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_cqs: Could not move all cqs to "
literal|"busy for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|cq
argument_list|,
argument|tmp
argument_list|,
argument|cq_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cq
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
operator|&&
operator|!
name|atomic_read
argument_list|(
operator|&
name|cq
operator|->
name|ref_count
argument_list|)
condition|)
block|{
name|cqn
operator|=
name|cq
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|state
operator|=
name|cq
operator|->
name|com
operator|.
name|from_state
expr_stmt|;
while|while
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_CQ_ALLOCATED
case|:
name|__mlx4_cq_free_icm
argument_list|(
name|dev
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|cq
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_CQ
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|cq
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_CQ
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|cq
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_CQ_HW
case|:
name|in_param
operator|=
name|slave
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|cqn
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_HW2SW_CQ
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_cqs: failed"
literal|" to move slave %d cq %d to"
literal|" SW ownership\n"
argument_list|,
name|slave
argument_list|,
name|cqn
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|cq
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|state
operator|=
name|RES_CQ_ALLOCATED
expr_stmt|;
break|break;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_mrs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|mpt_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MPT
index|]
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|mpt
decl_stmt|;
name|struct
name|res_mpt
modifier|*
name|tmp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|u64
name|in_param
decl_stmt|;
name|LIST_HEAD
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|int
name|mptn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_mrs: Could not move all mpts to "
literal|"busy for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mpt
argument_list|,
argument|tmp
argument_list|,
argument|mpt_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
condition|)
block|{
name|mptn
operator|=
name|mpt
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|state
operator|=
name|mpt
operator|->
name|com
operator|.
name|from_state
expr_stmt|;
while|while
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_MPT_RESERVED
case|:
name|__mlx4_mpt_release
argument_list|(
name|dev
argument_list|,
name|mpt
operator|->
name|key
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|mpt
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_MPT
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mpt
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MPT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_MPT_MAPPED
case|:
name|__mlx4_mpt_free_icm
argument_list|(
name|dev
argument_list|,
name|mpt
operator|->
name|key
argument_list|)
expr_stmt|;
name|state
operator|=
name|RES_MPT_RESERVED
expr_stmt|;
break|break;
case|case
name|RES_MPT_HW
case|:
name|in_param
operator|=
name|slave
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|mptn
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_HW2SW_MPT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_mrs: failed"
literal|" to move slave %d mpt %d to"
literal|" SW ownership\n"
argument_list|,
name|slave
argument_list|,
name|mptn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|mtt
condition|)
name|atomic_dec
argument_list|(
operator|&
name|mpt
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|state
operator|=
name|RES_MPT_MAPPED
expr_stmt|;
break|break;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_mtts
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|mtt_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_MTT
index|]
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|mtt
decl_stmt|;
name|struct
name|res_mtt
modifier|*
name|tmp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|LIST_HEAD
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MTT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_mtts: Could not move all mtts to "
literal|"busy for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mtt
argument_list|,
argument|tmp
argument_list|,
argument|mtt_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtt
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
condition|)
block|{
name|base
operator|=
name|mtt
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|state
operator|=
name|mtt
operator|->
name|com
operator|.
name|from_state
expr_stmt|;
while|while
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_MTT_ALLOCATED
case|:
name|__mlx4_free_mtt_range
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|mtt
operator|->
name|order
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|mtt
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_MTT
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mtt
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_release_resource
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_MTT
argument_list|,
literal|1
operator|<<
name|mtt
operator|->
name|order
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mtt
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_fs_rule
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|fs_rule_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_FS_RULE
index|]
decl_stmt|;
name|struct
name|res_fs_rule
modifier|*
name|fs_rule
decl_stmt|;
name|struct
name|res_fs_rule
modifier|*
name|tmp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|u64
name|base
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_FS_RULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_fs_rule: Could not move all mtts to busy for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|fs_rule
argument_list|,
argument|tmp
argument_list|,
argument|fs_rule_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_rule
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
condition|)
block|{
name|base
operator|=
name|fs_rule
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|state
operator|=
name|fs_rule
operator|->
name|com
operator|.
name|from_state
expr_stmt|;
while|while
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_FS_RULE_ALLOCATED
case|:
comment|/* detach rule */
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_DETACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|fs_rule
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_FS_RULE
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|fs_rule
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|fs_rule
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_eqs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|eq_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_EQ
index|]
decl_stmt|;
name|struct
name|res_eq
modifier|*
name|eq
decl_stmt|;
name|struct
name|res_eq
modifier|*
name|tmp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|state
decl_stmt|;
name|LIST_HEAD
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|int
name|eqn
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_EQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_eqs: Could not move all eqs to "
literal|"busy for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|eq
argument_list|,
argument|tmp
argument_list|,
argument|eq_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
condition|)
block|{
name|eqn
operator|=
name|eq
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|state
operator|=
name|eq
operator|->
name|com
operator|.
name|from_state
expr_stmt|;
while|while
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RES_EQ_RESERVED
case|:
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|eq
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_EQ
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|eq
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_EQ_HW
case|:
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|cond_resched
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|eqn
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_HW2SW_EQ
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_eqs: failed"
literal|" to move slave %d eqs %d to"
literal|" SW ownership\n"
argument_list|,
name|slave
argument_list|,
name|eqn
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|eq
operator|->
name|mtt
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|state
operator|=
name|RES_EQ_RESERVED
expr_stmt|;
break|break;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_counters
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|__mlx4_slave_counters_free
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_slave_xrcdns
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|xrcdn_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_XRCD
index|]
decl_stmt|;
name|struct
name|res_xrcdn
modifier|*
name|xrcd
decl_stmt|;
name|struct
name|res_xrcdn
modifier|*
name|tmp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|xrcdn
decl_stmt|;
name|err
operator|=
name|move_all_busy
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|RES_XRCD
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"rem_slave_xrcdns: Could not move all xrcdns to "
literal|"busy for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|xrcd
argument_list|,
argument|tmp
argument_list|,
argument|xrcdn_list
argument_list|,
argument|com.list
argument_list|)
block|{
if|if
condition|(
name|xrcd
operator|->
name|com
operator|.
name|owner
operator|==
name|slave
condition|)
block|{
name|xrcdn
operator|=
name|xrcd
operator|->
name|com
operator|.
name|res_id
expr_stmt|;
name|rb_erase
argument_list|(
operator|&
name|xrcd
operator|->
name|com
operator|.
name|node
argument_list|,
operator|&
name|tracker
operator|->
name|res_tree
index|[
name|RES_XRCD
index|]
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|xrcd
operator|->
name|com
operator|.
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|xrcd
argument_list|)
expr_stmt|;
name|__mlx4_xrcd_free
argument_list|(
name|dev
argument_list|,
name|xrcdn
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_delete_all_resources_for_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
index|[
name|slave
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rem_slave_macs
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_vlans
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_fs_rule
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_qps
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_srqs
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_cqs
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_mrs
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_eqs
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_mtts
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_counters
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|rem_slave_xrcdns
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|slave_list
index|[
name|slave
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_vf_immed_vlan_work_handler
parameter_list|(
name|struct
name|work_struct
modifier|*
name|_work
parameter_list|)
block|{
name|struct
name|mlx4_vf_immed_vlan_work
modifier|*
name|work
init|=
name|container_of
argument_list|(
name|_work
argument_list|,
expr|struct
name|mlx4_vf_immed_vlan_work
argument_list|,
name|work
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_update_qp_context
modifier|*
name|upd_context
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
operator|&
name|work
operator|->
name|priv
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_resource_tracker
modifier|*
name|tracker
init|=
operator|&
name|work
operator|->
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
decl_stmt|;
name|struct
name|list_head
modifier|*
name|qp_list
init|=
operator|&
name|tracker
operator|->
name|slave_list
index|[
name|work
operator|->
name|slave
index|]
operator|.
name|res_list
index|[
name|RES_QP
index|]
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|res_qp
modifier|*
name|tmp
decl_stmt|;
name|u64
name|qp_path_mask_vlan_ctrl
init|=
operator|(
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_UNTAGGED
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_1P
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_TAGGED
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_UNTAGGED
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_1P
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_TAGGED
operator|)
operator|)
decl_stmt|;
name|u64
name|qp_path_mask
init|=
operator|(
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_VLAN_INDEX
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_FVL
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_CV
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_ETH_HIDE_CQE_VLAN
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_FEUP
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_FVL_RX
operator|)
operator||
operator|(
literal|1ULL
operator|<<
name|MLX4_UPD_QP_PATH_MASK_SCHED_QUEUE
operator|)
operator|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|,
name|errors
init|=
literal|0
decl_stmt|;
name|u8
name|vlan_control
decl_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Trying to update-qp in slave %d\n"
argument_list|,
name|work
operator|->
name|slave
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|work
operator|->
name|vlan_id
condition|)
name|vlan_control
operator|=
name|MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED
operator||
name|MLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED
expr_stmt|;
else|else
name|vlan_control
operator|=
name|MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED
operator||
name|MLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED
operator||
name|MLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED
expr_stmt|;
name|upd_context
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|upd_context
operator|->
name|qp_mask
operator|=
name|cpu_to_be64
argument_list|(
name|MLX4_UPD_QP_MASK_VSD
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|qp
argument_list|,
argument|tmp
argument_list|,
argument|qp_list
argument_list|,
argument|com.list
argument_list|)
block|{
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|com
operator|.
name|owner
operator|==
name|work
operator|->
name|slave
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|com
operator|.
name|from_state
operator|!=
name|RES_QP_HW
operator|||
operator|!
name|qp
operator|->
name|sched_queue
operator|||
comment|/* no INIT2RTR trans yet */
name|mlx4_is_qp_reserved
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|local_qpn
argument_list|)
operator|||
name|qp
operator|->
name|qpc_flags
operator|&
operator|(
literal|1
operator|<<
name|MLX4_RSS_QPC_FLAG_OFFSET
operator|)
condition|)
block|{
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|port
operator|=
operator|(
name|qp
operator|->
name|sched_queue
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|work
operator|->
name|port
condition|)
block|{
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|MLX4_QP_ST_RC
operator|==
operator|(
operator|(
name|qp
operator|->
name|qpc_flags
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
condition|)
name|upd_context
operator|->
name|primary_addr_path_mask
operator|=
name|cpu_to_be64
argument_list|(
name|qp_path_mask
argument_list|)
expr_stmt|;
else|else
name|upd_context
operator|->
name|primary_addr_path_mask
operator|=
name|cpu_to_be64
argument_list|(
name|qp_path_mask
operator||
name|qp_path_mask_vlan_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|vlan_id
operator|==
name|MLX4_VGT
condition|)
block|{
name|upd_context
operator|->
name|qp_context
operator|.
name|param3
operator|=
name|qp
operator|->
name|param3
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|vlan_control
operator|=
name|qp
operator|->
name|vlan_control
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|fvl_rx
operator|=
name|qp
operator|->
name|fvl_rx
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|vlan_index
operator|=
name|qp
operator|->
name|vlan_index
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|fl
operator|=
name|qp
operator|->
name|pri_path_fl
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|feup
operator|=
name|qp
operator|->
name|feup
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|sched_queue
operator|=
name|qp
operator|->
name|sched_queue
expr_stmt|;
block|}
else|else
block|{
name|upd_context
operator|->
name|qp_context
operator|.
name|param3
operator|=
name|qp
operator|->
name|param3
operator|&
operator|~
name|cpu_to_be32
argument_list|(
name|MLX4_STRIP_VLAN
argument_list|)
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|vlan_control
operator|=
name|vlan_control
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|vlan_index
operator|=
name|work
operator|->
name|vlan_ix
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|fvl_rx
operator|=
name|qp
operator|->
name|fvl_rx
operator||
name|MLX4_FVL_RX_FORCE_ETH_VLAN
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|fl
operator|=
name|qp
operator|->
name|pri_path_fl
operator||
name|MLX4_FL_CV
operator||
name|MLX4_FL_ETH_HIDE_CQE_VLAN
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|feup
operator|=
name|qp
operator|->
name|feup
operator||
name|MLX4_FEUP_FORCE_ETH_UP
operator||
name|MLX4_FVL_FORCE_ETH_VLAN
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|sched_queue
operator|=
name|qp
operator|->
name|sched_queue
operator|&
literal|0xC7
expr_stmt|;
name|upd_context
operator|->
name|qp_context
operator|.
name|pri_path
operator|.
name|sched_queue
operator||=
operator|(
operator|(
name|work
operator|->
name|qos
operator|&
literal|0x7
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|qp
operator|->
name|local_qpn
operator|&
literal|0xffffff
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_UPDATE_QP
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"UPDATE_QP failed for slave %d, "
literal|"port %d, qpn %d (%d)\n"
argument_list|,
name|work
operator|->
name|slave
argument_list|,
name|port
argument_list|,
name|qp
operator|->
name|local_qpn
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
block|}
name|spin_lock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
name|mlx4_tlock
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%d UPDATE_QP failures for slave %d, port %d\n"
argument_list|,
name|errors
argument_list|,
name|work
operator|->
name|slave
argument_list|,
name|work
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* unregister previous vlan_id if needed and we had no errors 	 * while updating the QPs 	 */
if|if
condition|(
name|work
operator|->
name|flags
operator|&
name|MLX4_VF_IMMED_VLAN_FLAG_VLAN
operator|&&
operator|!
name|errors
operator|&&
name|NO_INDX
operator|!=
name|work
operator|->
name|orig_vlan_ix
condition|)
name|__mlx4_unregister_vlan
argument_list|(
operator|&
name|work
operator|->
name|priv
operator|->
name|dev
argument_list|,
name|work
operator|->
name|port
argument_list|,
name|work
operator|->
name|orig_vlan_id
argument_list|)
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

