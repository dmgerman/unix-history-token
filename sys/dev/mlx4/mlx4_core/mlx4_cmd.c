begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008, 2014 Mellanox Technologies. All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/device.h>
end_include

begin_include
include|#
directive|include
file|<linux/semaphore.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_smi.h>
end_include

begin_include
include|#
directive|include
file|<asm/io.h>
end_include

begin_include
include|#
directive|include
file|<linux/ktime.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"fw_qos.h"
end_include

begin_define
define|#
directive|define
name|CMD_POLL_TOKEN
value|0xffff
end_define

begin_define
define|#
directive|define
name|INBOX_MASK
value|0xffffffffffffff00ULL
end_define

begin_define
define|#
directive|define
name|CMD_CHAN_VER
value|1
end_define

begin_define
define|#
directive|define
name|CMD_CHAN_IF_REV
value|1
end_define

begin_enum
enum|enum
block|{
comment|/* command completed successfully: */
name|CMD_STAT_OK
init|=
literal|0x00
block|,
comment|/* Internal error (such as a bus error) occurred while processing command: */
name|CMD_STAT_INTERNAL_ERR
init|=
literal|0x01
block|,
comment|/* Operation/command not supported or opcode modifier not supported: */
name|CMD_STAT_BAD_OP
init|=
literal|0x02
block|,
comment|/* Parameter not supported or parameter out of range: */
name|CMD_STAT_BAD_PARAM
init|=
literal|0x03
block|,
comment|/* System not enabled or bad system state: */
name|CMD_STAT_BAD_SYS_STATE
init|=
literal|0x04
block|,
comment|/* Attempt to access reserved or unallocaterd resource: */
name|CMD_STAT_BAD_RESOURCE
init|=
literal|0x05
block|,
comment|/* Requested resource is currently executing a command, or is otherwise busy: */
name|CMD_STAT_RESOURCE_BUSY
init|=
literal|0x06
block|,
comment|/* Required capability exceeds device limits: */
name|CMD_STAT_EXCEED_LIM
init|=
literal|0x08
block|,
comment|/* Resource is not in the appropriate state or ownership: */
name|CMD_STAT_BAD_RES_STATE
init|=
literal|0x09
block|,
comment|/* Index out of range: */
name|CMD_STAT_BAD_INDEX
init|=
literal|0x0a
block|,
comment|/* FW image corrupted: */
name|CMD_STAT_BAD_NVMEM
init|=
literal|0x0b
block|,
comment|/* Error in ICM mapping (e.g. not enough auxiliary ICM pages to execute command): */
name|CMD_STAT_ICM_ERROR
init|=
literal|0x0c
block|,
comment|/* Attempt to modify a QP/EE which is not in the presumed state: */
name|CMD_STAT_BAD_QP_STATE
init|=
literal|0x10
block|,
comment|/* Bad segment parameters (Address/Size): */
name|CMD_STAT_BAD_SEG_PARAM
init|=
literal|0x20
block|,
comment|/* Memory Region has Memory Windows bound to: */
name|CMD_STAT_REG_BOUND
init|=
literal|0x21
block|,
comment|/* HCA local attached memory not present: */
name|CMD_STAT_LAM_NOT_PRE
init|=
literal|0x22
block|,
comment|/* Bad management packet (silently discarded): */
name|CMD_STAT_BAD_PKT
init|=
literal|0x30
block|,
comment|/* More outstanding CQEs in CQ than new CQ size: */
name|CMD_STAT_BAD_SIZE
init|=
literal|0x40
block|,
comment|/* Multi Function device support required: */
name|CMD_STAT_MULTI_FUNC_REQ
init|=
literal|0x50
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|HCR_IN_PARAM_OFFSET
init|=
literal|0x00
block|,
name|HCR_IN_MODIFIER_OFFSET
init|=
literal|0x08
block|,
name|HCR_OUT_PARAM_OFFSET
init|=
literal|0x0c
block|,
name|HCR_TOKEN_OFFSET
init|=
literal|0x14
block|,
name|HCR_STATUS_OFFSET
init|=
literal|0x18
block|,
name|HCR_OPMOD_SHIFT
init|=
literal|12
block|,
name|HCR_T_BIT
init|=
literal|21
block|,
name|HCR_E_BIT
init|=
literal|22
block|,
name|HCR_GO_BIT
init|=
literal|23
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|GO_BIT_TIMEOUT_MSECS
init|=
literal|10000
block|}
enum|;
end_enum

begin_enum
enum|enum
name|mlx4_vlan_transition
block|{
name|MLX4_VLAN_TRANSITION_VST_VST
init|=
literal|0
block|,
name|MLX4_VLAN_TRANSITION_VST_VGT
init|=
literal|1
block|,
name|MLX4_VLAN_TRANSITION_VGT_VST
init|=
literal|2
block|,
name|MLX4_VLAN_TRANSITION_VGT_VGT
init|=
literal|3
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|mlx4_cmd_context
block|{
name|struct
name|completion
name|done
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|next
decl_stmt|;
name|u64
name|out_param
decl_stmt|;
name|u16
name|token
decl_stmt|;
name|u8
name|fw_status
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|mlx4_master_process_vhcr
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr_cmd
modifier|*
name|in_vhcr
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mlx4_status_to_errno
parameter_list|(
name|u8
name|status
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|trans_table
index|[]
init|=
block|{
index|[
name|CMD_STAT_INTERNAL_ERR
index|]
operator|=
operator|-
name|EIO
block|,
index|[
name|CMD_STAT_BAD_OP
index|]
operator|=
operator|-
name|EPERM
block|,
index|[
name|CMD_STAT_BAD_PARAM
index|]
operator|=
operator|-
name|EINVAL
block|,
index|[
name|CMD_STAT_BAD_SYS_STATE
index|]
operator|=
operator|-
name|ENXIO
block|,
index|[
name|CMD_STAT_BAD_RESOURCE
index|]
operator|=
operator|-
name|EBADF
block|,
index|[
name|CMD_STAT_RESOURCE_BUSY
index|]
operator|=
operator|-
name|EBUSY
block|,
index|[
name|CMD_STAT_EXCEED_LIM
index|]
operator|=
operator|-
name|ENOMEM
block|,
index|[
name|CMD_STAT_BAD_RES_STATE
index|]
operator|=
operator|-
name|EBADF
block|,
index|[
name|CMD_STAT_BAD_INDEX
index|]
operator|=
operator|-
name|EBADF
block|,
index|[
name|CMD_STAT_BAD_NVMEM
index|]
operator|=
operator|-
name|EFAULT
block|,
index|[
name|CMD_STAT_ICM_ERROR
index|]
operator|=
operator|-
name|ENFILE
block|,
index|[
name|CMD_STAT_BAD_QP_STATE
index|]
operator|=
operator|-
name|EINVAL
block|,
index|[
name|CMD_STAT_BAD_SEG_PARAM
index|]
operator|=
operator|-
name|EFAULT
block|,
index|[
name|CMD_STAT_REG_BOUND
index|]
operator|=
operator|-
name|EBUSY
block|,
index|[
name|CMD_STAT_LAM_NOT_PRE
index|]
operator|=
operator|-
name|EAGAIN
block|,
index|[
name|CMD_STAT_BAD_PKT
index|]
operator|=
operator|-
name|EINVAL
block|,
index|[
name|CMD_STAT_BAD_SIZE
index|]
operator|=
operator|-
name|ENOMEM
block|,
index|[
name|CMD_STAT_MULTI_FUNC_REQ
index|]
operator|=
operator|-
name|EACCES
block|, 	}
decl_stmt|;
if|if
condition|(
name|status
operator|>=
name|ARRAY_SIZE
argument_list|(
name|trans_table
argument_list|)
operator|||
operator|(
name|status
operator|!=
name|CMD_STAT_OK
operator|&&
name|trans_table
index|[
name|status
index|]
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
name|EIO
return|;
return|return
name|trans_table
index|[
name|status
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|u8
name|mlx4_errno_to_status
parameter_list|(
name|int
name|errno
parameter_list|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
operator|-
name|EPERM
case|:
return|return
name|CMD_STAT_BAD_OP
return|;
case|case
operator|-
name|EINVAL
case|:
return|return
name|CMD_STAT_BAD_PARAM
return|;
case|case
operator|-
name|ENXIO
case|:
return|return
name|CMD_STAT_BAD_SYS_STATE
return|;
case|case
operator|-
name|EBUSY
case|:
return|return
name|CMD_STAT_RESOURCE_BUSY
return|;
case|case
operator|-
name|ENOMEM
case|:
return|return
name|CMD_STAT_EXCEED_LIM
return|;
case|case
operator|-
name|ENFILE
case|:
return|return
name|CMD_STAT_ICM_ERROR
return|;
default|default:
return|return
name|CMD_STAT_INTERNAL_ERR
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_internal_err_ret_value
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|op
parameter_list|,
name|u8
name|op_modifier
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|MLX4_CMD_UNMAP_ICM
case|:
case|case
name|MLX4_CMD_UNMAP_ICM_AUX
case|:
case|case
name|MLX4_CMD_UNMAP_FA
case|:
case|case
name|MLX4_CMD_2RST_QP
case|:
case|case
name|MLX4_CMD_HW2SW_EQ
case|:
case|case
name|MLX4_CMD_HW2SW_CQ
case|:
case|case
name|MLX4_CMD_HW2SW_SRQ
case|:
case|case
name|MLX4_CMD_HW2SW_MPT
case|:
case|case
name|MLX4_CMD_CLOSE_HCA
case|:
case|case
name|MLX4_QP_FLOW_STEERING_DETACH
case|:
case|case
name|MLX4_CMD_FREE_RES
case|:
case|case
name|MLX4_CMD_CLOSE_PORT
case|:
return|return
name|CMD_STAT_OK
return|;
case|case
name|MLX4_CMD_QP_ATTACH
case|:
comment|/* On Detach case return success */
if|if
condition|(
name|op_modifier
operator|==
literal|0
condition|)
return|return
name|CMD_STAT_OK
return|;
return|return
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
return|;
default|default:
return|return
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_closing_cmd_fatal_error
parameter_list|(
name|u16
name|op
parameter_list|,
name|u8
name|fw_status
parameter_list|)
block|{
comment|/* Any error during the closing commands below is considered fatal */
if|if
condition|(
name|op
operator|==
name|MLX4_CMD_CLOSE_HCA
operator|||
name|op
operator|==
name|MLX4_CMD_HW2SW_EQ
operator|||
name|op
operator|==
name|MLX4_CMD_HW2SW_CQ
operator|||
name|op
operator|==
name|MLX4_CMD_2RST_QP
operator|||
name|op
operator|==
name|MLX4_CMD_HW2SW_SRQ
operator|||
name|op
operator|==
name|MLX4_CMD_SYNC_TPT
operator|||
name|op
operator|==
name|MLX4_CMD_UNMAP_ICM
operator|||
name|op
operator|==
name|MLX4_CMD_UNMAP_ICM_AUX
operator|||
name|op
operator|==
name|MLX4_CMD_UNMAP_FA
condition|)
return|return
literal|1
return|;
comment|/* Error on MLX4_CMD_HW2SW_MPT is fatal except when fw status equals 	  * CMD_STAT_REG_BOUND. 	  * This status indicates that memory region has memory windows bound to it 	  * which may result from invalid user space usage and is not fatal. 	  */
if|if
condition|(
name|op
operator|==
name|MLX4_CMD_HW2SW_MPT
operator|&&
name|fw_status
operator|!=
name|CMD_STAT_REG_BOUND
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_cmd_reset_flow
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|op
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|int
name|err
parameter_list|)
block|{
comment|/* Only if reset flow is really active return code is based on 	  * command, otherwise current error code is returned. 	  */
if|if
condition|(
name|mlx4_internal_err_reset
condition|)
block|{
name|mlx4_enter_error_state
argument_list|(
name|dev
operator|->
name|persist
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_internal_err_ret_value
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|comm_pending
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|status
init|=
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_read
argument_list|)
decl_stmt|;
return|return
operator|(
name|swab32
argument_list|(
name|status
argument_list|)
operator|>>
literal|31
operator|)
operator|!=
name|priv
operator|->
name|cmd
operator|.
name|comm_toggle
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_comm_cmd_post
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|cmd
parameter_list|,
name|u16
name|param
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* To avoid writing to unknown addresses after the device state was 	 * changed to internal error and the function was rest, 	 * check the INTERNAL_ERROR flag which is updated under 	 * device_state_mutex lock. 	 */
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|device_state_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
block|{
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|device_state_mutex
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
name|priv
operator|->
name|cmd
operator|.
name|comm_toggle
operator|^=
literal|1
expr_stmt|;
name|val
operator|=
name|param
operator||
operator|(
name|cmd
operator|<<
literal|16
operator|)
operator||
operator|(
name|priv
operator|->
name|cmd
operator|.
name|comm_toggle
operator|<<
literal|31
operator|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_write
argument_list|)
expr_stmt|;
name|mmiowb
argument_list|()
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|device_state_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_comm_cmd_poll
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|cmd
parameter_list|,
name|u16
name|param
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|ret_from_pending
init|=
literal|0
decl_stmt|;
comment|/* First, verify that the master reports correct status */
if|if
condition|(
name|comm_pending
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Communication channel is not idle - my toggle is %d (cmd:0x%x)\n"
argument_list|,
name|priv
operator|->
name|cmd
operator|.
name|comm_toggle
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
comment|/* Write command */
name|down
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd_post
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|param
argument_list|)
condition|)
block|{
comment|/* Only in case the device state is INTERNAL_ERROR, 		 * mlx4_comm_cmd_post returns with an error 		 */
name|err
operator|=
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|end
operator|=
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
operator|+
name|jiffies
expr_stmt|;
while|while
condition|(
name|comm_pending
argument_list|(
name|dev
argument_list|)
operator|&&
name|time_before
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
name|cond_resched
argument_list|()
expr_stmt|;
name|ret_from_pending
operator|=
name|comm_pending
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_from_pending
condition|)
block|{
comment|/* check if the slave is trying to boot in the middle of 		 * FLR process. The only non-zero result in the RESET command 		 * is MLX4_DELAY_RESET_SLAVE*/
if|if
condition|(
operator|(
name|MLX4_COMM_CMD_RESET
operator|==
name|cmd
operator|)
condition|)
block|{
name|err
operator|=
name|MLX4_DELAY_RESET_SLAVE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Communication channel command 0x%x timed out\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
condition|)
name|mlx4_enter_error_state
argument_list|(
name|dev
operator|->
name|persist
argument_list|)
expr_stmt|;
name|out
label|:
name|up
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_comm_cmd_wait
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|vhcr_cmd
parameter_list|,
name|u16
name|param
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|struct
name|mlx4_cmd_context
modifier|*
name|context
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|down
argument_list|(
operator|&
name|cmd
operator|->
name|event_sem
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|cmd
operator|->
name|free_head
operator|<
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
operator|&
name|cmd
operator|->
name|context
index|[
name|cmd
operator|->
name|free_head
index|]
expr_stmt|;
name|context
operator|->
name|token
operator|+=
name|cmd
operator|->
name|token_mask
operator|+
literal|1
expr_stmt|;
name|cmd
operator|->
name|free_head
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|reinit_completion
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd_post
argument_list|(
name|dev
argument_list|,
name|vhcr_cmd
argument_list|,
name|param
argument_list|)
condition|)
block|{
comment|/* Only in case the device state is INTERNAL_ERROR, 		 * mlx4_comm_cmd_post returns with an error 		 */
name|err
operator|=
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|wait_for_completion_timeout
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"communication channel command 0x%x (op=0x%x) timed out\n"
argument_list|,
name|vhcr_cmd
argument_list|,
name|op
argument_list|)
expr_stmt|;
goto|goto
name|out_reset
goto|;
block|}
name|err
operator|=
name|context
operator|->
name|result
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|context
operator|->
name|fw_status
operator|!=
name|CMD_STAT_MULTI_FUNC_REQ
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x failed: fw status = 0x%x\n"
argument_list|,
name|vhcr_cmd
argument_list|,
name|context
operator|->
name|fw_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_closing_cmd_fatal_error
argument_list|(
name|op
argument_list|,
name|context
operator|->
name|fw_status
argument_list|)
condition|)
goto|goto
name|out_reset
goto|;
block|}
comment|/* wait for comm channel ready 	 * this is necessary for prevention the race 	 * when switching between event to polling mode 	 * Skipping this section in case the device is in FATAL_ERROR state, 	 * In this state, no commands are sent via the comm channel until 	 * the device has returned from reset. 	 */
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
operator|)
condition|)
block|{
name|end
operator|=
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
operator|+
name|jiffies
expr_stmt|;
while|while
condition|(
name|comm_pending
argument_list|(
name|dev
argument_list|)
operator|&&
name|time_before
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
name|cond_resched
argument_list|()
expr_stmt|;
block|}
goto|goto
name|out
goto|;
name|out_reset
label|:
name|err
operator|=
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
expr_stmt|;
name|mlx4_enter_error_state
argument_list|(
name|dev
operator|->
name|persist
argument_list|)
expr_stmt|;
name|out
label|:
name|spin_lock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|context
operator|->
name|next
operator|=
name|cmd
operator|->
name|free_head
expr_stmt|;
name|cmd
operator|->
name|free_head
operator|=
name|context
operator|-
name|cmd
operator|->
name|context
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|cmd
operator|->
name|event_sem
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_comm_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|cmd
parameter_list|,
name|u16
name|param
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
return|return
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
return|;
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|use_events
condition|)
return|return
name|mlx4_comm_cmd_wait
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|param
argument_list|,
name|op
argument_list|,
name|timeout
argument_list|)
return|;
return|return
name|mlx4_comm_cmd_poll
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|param
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmd_pending
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|status
operator|=
name|readl
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|hcr
operator|+
name|HCR_STATUS_OFFSET
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|&
name|swab32
argument_list|(
literal|1
operator|<<
name|HCR_GO_BIT
argument_list|)
operator|)
operator|||
operator|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|toggle
operator|==
operator|!
operator|!
operator|(
name|status
operator|&
name|swab32
argument_list|(
literal|1
operator|<<
name|HCR_T_BIT
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_cmd_post
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
name|out_param
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|u16
name|token
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|u32
name|__iomem
modifier|*
name|hcr
init|=
name|cmd
operator|->
name|hcr
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|EIO
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|device_state_mutex
argument_list|)
expr_stmt|;
comment|/* To avoid writing to unknown addresses after the device state was 	  * changed to internal error and the chip was reset, 	  * check the INTERNAL_ERROR flag which is updated under 	  * device_state_mutex lock. 	  */
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|)
operator|||
operator|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
operator|)
condition|)
block|{
comment|/* 		 * Device is going through error recovery 		 * and cannot accept commands. 		 */
goto|goto
name|out
goto|;
block|}
name|end
operator|=
name|jiffies
expr_stmt|;
if|if
condition|(
name|event
condition|)
name|end
operator|+=
name|msecs_to_jiffies
argument_list|(
name|GO_BIT_TIMEOUT_MSECS
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd_pending
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|)
condition|)
block|{
comment|/* 			 * Device is going through error recovery 			 * and cannot accept commands. 			 */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|time_after_eq
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s:cmd_pending failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cond_resched
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * We use writel (instead of something like memcpy_toio) 	 * because writes of less than 32 bits to the HCR don't work 	 * (and some architectures such as ia64 implement memcpy_toio 	 * in terms of writeb). 	 */
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|in_param
operator|>>
literal|32
argument_list|)
argument_list|,
name|hcr
operator|+
literal|0
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|in_param
operator|&
literal|0xfffffffful
argument_list|)
argument_list|,
name|hcr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|in_modifier
argument_list|)
argument_list|,
name|hcr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|out_param
operator|>>
literal|32
argument_list|)
argument_list|,
name|hcr
operator|+
literal|3
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|out_param
operator|&
literal|0xfffffffful
argument_list|)
argument_list|,
name|hcr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|token
operator|<<
literal|16
argument_list|)
argument_list|,
name|hcr
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* __raw_writel may not order writes. */
name|wmb
argument_list|()
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
operator|(
literal|1
operator|<<
name|HCR_GO_BIT
operator|)
operator||
operator|(
name|cmd
operator|->
name|toggle
operator|<<
name|HCR_T_BIT
operator|)
operator||
operator|(
name|event
condition|?
operator|(
literal|1
operator|<<
name|HCR_E_BIT
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|op_modifier
operator|<<
name|HCR_OPMOD_SHIFT
operator|)
operator||
name|op
argument_list|)
argument_list|,
name|hcr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that our HCR writes don't get mixed in with 	 * writes from another CPU starting a FW command. 	 */
name|mmiowb
argument_list|()
expr_stmt|;
name|cmd
operator|->
name|toggle
operator|=
name|cmd
operator|->
name|toggle
operator|^
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Could not post command 0x%x: ret=%d, in_param=0x%llx, in_mod=0x%x, op_mod=0x%x\n"
argument_list|,
name|op
argument_list|,
name|ret
argument_list|,
operator|(
name|long
name|long
operator|)
name|in_param
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|device_state_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_slave_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|out_is_imm
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_vhcr_cmd
modifier|*
name|vhcr
init|=
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|in_param
operator|=
name|cpu_to_be64
argument_list|(
name|in_param
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|out_param
operator|=
name|out_param
condition|?
name|cpu_to_be64
argument_list|(
operator|*
name|out_param
argument_list|)
else|:
literal|0
expr_stmt|;
name|vhcr
operator|->
name|in_modifier
operator|=
name|cpu_to_be32
argument_list|(
name|in_modifier
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|opcode
operator|=
name|cpu_to_be16
argument_list|(
operator|(
operator|(
operator|(
name|u16
operator|)
name|op_modifier
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|op
operator|&
literal|0xfff
operator|)
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|token
operator|=
name|cpu_to_be16
argument_list|(
name|CMD_POLL_TOKEN
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|vhcr
operator|->
name|flags
operator|=
operator|!
operator|!
operator|(
name|priv
operator|->
name|cmd
operator|.
name|use_events
operator|)
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mlx4_master_process_vhcr
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|function
argument_list|,
name|vhcr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
if|if
condition|(
name|out_is_imm
condition|)
block|{
if|if
condition|(
name|out_param
condition|)
operator|*
name|out_param
operator|=
name|be64_to_cpu
argument_list|(
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"response expected while output mailbox is NULL for command 0x%x\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|status
operator|=
name|CMD_STAT_BAD_PARAM
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|mlx4_status_to_errno
argument_list|(
name|vhcr
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|&&
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
name|ret
operator|=
name|mlx4_internal_err_ret_value
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR_POST
argument_list|,
literal|0
argument_list|,
name|op
argument_list|,
name|MLX4_COMM_TIME
operator|+
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
if|if
condition|(
name|out_is_imm
condition|)
block|{
if|if
condition|(
name|out_param
condition|)
operator|*
name|out_param
operator|=
name|be64_to_cpu
argument_list|(
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"response expected while output mailbox is NULL for command 0x%x\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|status
operator|=
name|CMD_STAT_BAD_PARAM
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|mlx4_status_to_errno
argument_list|(
name|vhcr
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
name|ret
operator|=
name|mlx4_internal_err_ret_value
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|)
expr_stmt|;
else|else
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"failed execution of VHCR_POST command opcode 0x%x\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_cmd_poll
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|out_is_imm
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|void
name|__iomem
modifier|*
name|hcr
init|=
name|priv
operator|->
name|cmd
operator|.
name|hcr
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|u32
name|stat
decl_stmt|;
name|down
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
block|{
comment|/* 		 * Device is going through error recovery 		 * and cannot accept commands. 		 */
name|err
operator|=
name|mlx4_internal_err_ret_value
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|out_is_imm
operator|&&
operator|!
name|out_param
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"response expected while output mailbox is NULL for command 0x%x\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|mlx4_cmd_post
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
condition|?
operator|*
name|out_param
else|:
literal|0
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|CMD_POLL_TOKEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_reset
goto|;
name|end
operator|=
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
operator|+
name|jiffies
expr_stmt|;
while|while
condition|(
name|cmd_pending
argument_list|(
name|dev
argument_list|)
operator|&&
name|time_before
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|)
condition|)
block|{
comment|/* 			 * Device is going through error recovery 			 * and cannot accept commands. 			 */
name|err
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|out_reset
goto|;
block|}
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
block|{
name|err
operator|=
name|mlx4_internal_err_ret_value
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cond_resched
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cmd_pending
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x timed out (go bit not cleared)\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|out_reset
goto|;
block|}
if|if
condition|(
name|out_is_imm
condition|)
operator|*
name|out_param
operator|=
operator|(
name|u64
operator|)
name|be32_to_cpu
argument_list|(
operator|(
name|__force
name|__be32
operator|)
name|__raw_readl
argument_list|(
name|hcr
operator|+
name|HCR_OUT_PARAM_OFFSET
argument_list|)
argument_list|)
operator|<<
literal|32
operator||
operator|(
name|u64
operator|)
name|be32_to_cpu
argument_list|(
operator|(
name|__force
name|__be32
operator|)
name|__raw_readl
argument_list|(
name|hcr
operator|+
name|HCR_OUT_PARAM_OFFSET
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|be32_to_cpu
argument_list|(
operator|(
name|__force
name|__be32
operator|)
name|__raw_readl
argument_list|(
name|hcr
operator|+
name|HCR_STATUS_OFFSET
argument_list|)
argument_list|)
operator|>>
literal|24
expr_stmt|;
name|err
operator|=
name|mlx4_status_to_errno
argument_list|(
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x failed: fw status = 0x%x\n"
argument_list|,
name|op
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_closing_cmd_fatal_error
argument_list|(
name|op
argument_list|,
name|stat
argument_list|)
condition|)
goto|goto
name|out_reset
goto|;
goto|goto
name|out
goto|;
block|}
name|out_reset
label|:
if|if
condition|(
name|err
condition|)
name|err
operator|=
name|mlx4_cmd_reset_flow
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|out
label|:
name|up
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_cmd_event
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|token
parameter_list|,
name|u8
name|status
parameter_list|,
name|u64
name|out_param
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_context
modifier|*
name|context
init|=
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|token
operator|&
name|priv
operator|->
name|cmd
operator|.
name|token_mask
index|]
decl_stmt|;
comment|/* previously timed out command completing at long last */
if|if
condition|(
name|token
operator|!=
name|context
operator|->
name|token
condition|)
return|return;
name|context
operator|->
name|fw_status
operator|=
name|status
expr_stmt|;
name|context
operator|->
name|result
operator|=
name|mlx4_status_to_errno
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|context
operator|->
name|out_param
operator|=
name|out_param
expr_stmt|;
name|complete
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_cmd_wait
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|out_is_imm
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|struct
name|mlx4_cmd_context
modifier|*
name|context
decl_stmt|;
name|long
name|ret_wait
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|down
argument_list|(
operator|&
name|cmd
operator|->
name|event_sem
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|cmd
operator|->
name|free_head
operator|<
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
operator|&
name|cmd
operator|->
name|context
index|[
name|cmd
operator|->
name|free_head
index|]
expr_stmt|;
name|context
operator|->
name|token
operator|+=
name|cmd
operator|->
name|token_mask
operator|+
literal|1
expr_stmt|;
name|cmd
operator|->
name|free_head
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_is_imm
operator|&&
operator|!
name|out_param
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"response expected while output mailbox is NULL for command 0x%x\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|reinit_completion
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_post
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
condition|?
operator|*
name|out_param
else|:
literal|0
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|context
operator|->
name|token
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_reset
goto|;
if|if
condition|(
name|op
operator|==
name|MLX4_CMD_SENSE_PORT
condition|)
block|{
name|ret_wait
operator|=
name|wait_for_completion_interruptible_timeout
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_wait
operator|<
literal|0
condition|)
block|{
name|context
operator|->
name|fw_status
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|out_param
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret_wait
operator|=
operator|(
name|long
operator|)
name|wait_for_completion_timeout
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret_wait
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x timed out (go bit not cleared)\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|MLX4_CMD_NOP
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|err
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|out_reset
goto|;
block|}
block|}
name|err
operator|=
name|context
operator|->
name|result
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Since we do not want to have this error message always 		 * displayed at driver start when there are ConnectX2 HCAs 		 * on the host, we deprecate the error message for this 		 * specific command/input_mod/opcode_mod/fw-status to be debug. 		 */
if|if
condition|(
name|op
operator|==
name|MLX4_CMD_SET_PORT
operator|&&
operator|(
name|in_modifier
operator|==
literal|1
operator|||
name|in_modifier
operator|==
literal|2
operator|)
operator|&&
name|op_modifier
operator|==
name|MLX4_SET_PORT_IB_OPCODE
operator|&&
name|context
operator|->
name|fw_status
operator|==
name|CMD_STAT_BAD_SIZE
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x failed: fw status = 0x%x\n"
argument_list|,
name|op
argument_list|,
name|context
operator|->
name|fw_status
argument_list|)
expr_stmt|;
else|else
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x failed: fw status = 0x%x\n"
argument_list|,
name|op
argument_list|,
name|context
operator|->
name|fw_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
name|err
operator|=
name|mlx4_internal_err_ret_value
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mlx4_closing_cmd_fatal_error
argument_list|(
name|op
argument_list|,
name|context
operator|->
name|fw_status
argument_list|)
condition|)
goto|goto
name|out_reset
goto|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|out_is_imm
condition|)
operator|*
name|out_param
operator|=
name|context
operator|->
name|out_param
expr_stmt|;
name|out_reset
label|:
if|if
condition|(
name|err
condition|)
name|err
operator|=
name|mlx4_cmd_reset_flow
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|out
label|:
name|spin_lock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|context
operator|->
name|next
operator|=
name|cmd
operator|->
name|free_head
expr_stmt|;
name|cmd
operator|->
name|free_head
operator|=
name|context
operator|-
name|cmd
operator|->
name|context
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|cmd
operator|->
name|event_sem
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|__mlx4_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|out_is_imm
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|,
name|int
name|native
parameter_list|)
block|{
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|)
condition|)
return|return
name|mlx4_cmd_reset_flow
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|,
operator|-
name|EIO
argument_list|)
return|;
if|if
condition|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|native
operator|&&
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
condition|)
return|return
name|mlx4_internal_err_ret_value
argument_list|(
name|dev
argument_list|,
name|op
argument_list|,
name|op_modifier
argument_list|)
return|;
name|down_read
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|switch_sem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|use_events
condition|)
name|ret
operator|=
name|mlx4_cmd_wait
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
argument_list|,
name|out_is_imm
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|mlx4_cmd_poll
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
argument_list|,
name|out_is_imm
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|switch_sem
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|mlx4_slave_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
argument_list|,
name|out_is_imm
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|__mlx4_cmd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_ARM_COMM_CHANNEL
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_ARM_COMM_CHANNEL
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ACCESS_MEM
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|master_addr
parameter_list|,
name|int
name|slave
parameter_list|,
name|u64
name|slave_addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|is_read
parameter_list|)
block|{
name|u64
name|in_param
decl_stmt|;
name|u64
name|out_param
decl_stmt|;
if|if
condition|(
operator|(
name|slave_addr
operator|&
literal|0xfff
operator|)
operator||
operator|(
name|master_addr
operator|&
literal|0xfff
operator|)
operator||
operator|(
name|slave
operator|&
operator|~
literal|0x7f
operator|)
operator||
operator|(
name|size
operator|&
literal|0xff
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Bad access mem params - slave_addr:0x%llx "
literal|"master_addr:0x%llx slave_id:%d size:%d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|slave_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|master_addr
argument_list|,
name|slave
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|is_read
condition|)
block|{
name|in_param
operator|=
operator|(
name|u64
operator|)
name|slave
operator||
name|slave_addr
expr_stmt|;
name|out_param
operator|=
operator|(
name|u64
operator|)
name|dev
operator|->
name|caps
operator|.
name|function
operator||
name|master_addr
expr_stmt|;
block|}
else|else
block|{
name|in_param
operator|=
operator|(
name|u64
operator|)
name|dev
operator|->
name|caps
operator|.
name|function
operator||
name|master_addr
expr_stmt|;
name|out_param
operator|=
operator|(
name|u64
operator|)
name|slave
operator||
name|slave_addr
expr_stmt|;
block|}
return|return
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
operator|&
name|out_param
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_ACCESS_MEM
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|query_pkey_block
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|)
block|{
name|struct
name|ib_smp
modifier|*
name|in_mad
init|=
operator|(
expr|struct
name|ib_smp
operator|*
operator|)
operator|(
name|inbox
operator|->
name|buf
operator|)
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|out_mad
init|=
operator|(
expr|struct
name|ib_smp
operator|*
operator|)
operator|(
name|outbox
operator|->
name|buf
operator|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|index
operator|&
literal|0x1f
condition|)
return|return
operator|-
name|EINVAL
return|;
name|in_mad
operator|->
name|attr_mod
operator|=
name|cpu_to_be32
argument_list|(
name|index
operator|/
literal|32
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|3
argument_list|,
name|MLX4_CMD_MAD_IFC
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
name|pkey
index|[
name|i
index|]
operator|=
name|be16_to_cpu
argument_list|(
operator|(
operator|(
name|__be16
operator|*
operator|)
name|out_mad
operator|->
name|data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_full_pkey_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u16
modifier|*
name|table
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|err
operator|=
name|query_pkey_block
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|i
argument_list|,
name|table
operator|+
name|i
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PORT_CAPABILITY_LOCATION_IN_SMP
value|20
end_define

begin_define
define|#
directive|define
name|PORT_STATE_OFFSET
value|32
end_define

begin_function
specifier|static
name|enum
name|ib_port_state
name|vf_port_state
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
if|if
condition|(
name|mlx4_get_slave_port_state
argument_list|(
name|dev
argument_list|,
name|vf
argument_list|,
name|port
argument_list|)
operator|==
name|SLAVE_PORT_UP
condition|)
return|return
name|IB_PORT_ACTIVE
return|;
else|else
return|return
name|IB_PORT_DOWN
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_MAD_IFC_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|ib_smp
modifier|*
name|smp
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|u32
name|index
decl_stmt|;
name|u8
name|port
decl_stmt|,
name|slave_port
decl_stmt|;
name|u8
name|opcode_modifier
decl_stmt|;
name|u16
modifier|*
name|table
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|vidx
decl_stmt|,
name|pidx
decl_stmt|;
name|int
name|network_view
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|outsmp
init|=
name|outbox
operator|->
name|buf
decl_stmt|;
name|__be16
modifier|*
name|outtab
init|=
operator|(
name|__be16
operator|*
operator|)
operator|(
name|outsmp
operator|->
name|data
operator|)
decl_stmt|;
name|__be32
name|slave_cap_mask
decl_stmt|;
name|__be64
name|slave_node_guid
decl_stmt|;
name|slave_port
operator|=
name|vhcr
operator|->
name|in_modifier
expr_stmt|;
name|port
operator|=
name|mlx4_slave_convert_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|slave_port
argument_list|)
expr_stmt|;
comment|/* network-view bit is for driver use only, and should not be passed to FW */
name|opcode_modifier
operator|=
name|vhcr
operator|->
name|op_modifier
operator|&
operator|~
literal|0x8
expr_stmt|;
comment|/* clear netw view bit */
name|network_view
operator|=
operator|!
operator|!
operator|(
name|vhcr
operator|->
name|op_modifier
operator|&
literal|0x8
operator|)
expr_stmt|;
if|if
condition|(
name|smp
operator|->
name|base_version
operator|==
literal|1
operator|&&
name|smp
operator|->
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_LID_ROUTED
operator|&&
name|smp
operator|->
name|class_version
operator|==
literal|1
condition|)
block|{
comment|/* host view is paravirtualized */
if|if
condition|(
operator|!
name|network_view
operator|&&
name|smp
operator|->
name|method
operator|==
name|IB_MGMT_METHOD_GET
condition|)
block|{
if|if
condition|(
name|smp
operator|->
name|attr_id
operator|==
name|IB_SMP_ATTR_PKEY_TABLE
condition|)
block|{
name|index
operator|=
name|be32_to_cpu
argument_list|(
name|smp
operator|->
name|attr_mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
operator|-
name|EINVAL
return|;
name|table
operator|=
name|kcalloc
argument_list|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
operator|/
literal|32
operator|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
operator|*
literal|32
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* need to get the full pkey table because the paravirtualized 				 * pkeys may be scattered among several pkey blocks. 				 */
name|err
operator|=
name|get_full_pkey_table
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|table
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
for|for
control|(
name|vidx
operator|=
name|index
operator|*
literal|32
init|;
name|vidx
operator|<
operator|(
name|index
operator|+
literal|1
operator|)
operator|*
literal|32
condition|;
operator|++
name|vidx
control|)
block|{
name|pidx
operator|=
name|priv
operator|->
name|virt2phys_pkey
index|[
name|slave
index|]
index|[
name|port
operator|-
literal|1
index|]
index|[
name|vidx
index|]
expr_stmt|;
name|outtab
index|[
name|vidx
operator|%
literal|32
index|]
operator|=
name|cpu_to_be16
argument_list|(
name|table
index|[
name|pidx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|kfree
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|smp
operator|->
name|attr_id
operator|==
name|IB_SMP_ATTR_PORT_INFO
condition|)
block|{
comment|/*get the slave specific caps:*/
comment|/*do the command */
name|smp
operator|->
name|attr_mod
operator|=
name|cpu_to_be32
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
name|opcode_modifier
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
comment|/* modify the response for slaves */
if|if
condition|(
operator|!
name|err
operator|&&
name|slave
operator|!=
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u8
modifier|*
name|state
init|=
name|outsmp
operator|->
name|data
operator|+
name|PORT_STATE_OFFSET
decl_stmt|;
operator|*
name|state
operator|=
operator|(
operator|*
name|state
operator|&
literal|0xf0
operator|)
operator||
name|vf_port_state
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|slave_cap_mask
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|ib_cap_mask
index|[
name|port
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|outsmp
operator|->
name|data
operator|+
name|PORT_CAPABILITY_LOCATION_IN_SMP
argument_list|,
operator|&
name|slave_cap_mask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
if|if
condition|(
name|smp
operator|->
name|attr_id
operator|==
name|IB_SMP_ATTR_GUID_INFO
condition|)
block|{
name|__be64
name|guid
init|=
name|mlx4_get_admin_guid
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
decl_stmt|;
comment|/* set the PF admin guid to the FW/HW burned 				 * GUID, if it wasn't yet set 				 */
if|if
condition|(
name|slave
operator|==
literal|0
operator|&&
name|guid
operator|==
literal|0
condition|)
block|{
name|smp
operator|->
name|attr_mod
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
name|opcode_modifier
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|mlx4_set_admin_guid
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|__be64
operator|*
operator|)
name|outsmp
operator|->
name|data
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|outsmp
operator|->
name|data
argument_list|,
operator|&
name|guid
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* clean all other gids */
name|memset
argument_list|(
name|outsmp
operator|->
name|data
operator|+
literal|8
argument_list|,
literal|0
argument_list|,
literal|56
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|smp
operator|->
name|attr_id
operator|==
name|IB_SMP_ATTR_NODE_INFO
condition|)
block|{
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
name|opcode_modifier
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|slave_node_guid
operator|=
name|mlx4_get_slave_node_guid
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|outsmp
operator|->
name|data
operator|+
literal|12
argument_list|,
operator|&
name|slave_node_guid
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
block|}
block|}
comment|/* Non-privileged VFs are only allowed "host" view LID-routed 'Get' MADs. 	 * These are the MADs used by ib verbs (such as ib_query_gids). 	 */
if|if
condition|(
name|slave
operator|!=
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|mlx4_vf_smi_enabled
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|smp
operator|->
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_LID_ROUTED
operator|&&
name|smp
operator|->
name|method
operator|==
name|IB_MGMT_METHOD_GET
operator|)
operator|||
name|network_view
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unprivileged slave %d is trying to execute a Subnet MGMT MAD, class 0x%x, method 0x%x, view=%s for attr 0x%x. Rejecting\n"
argument_list|,
name|slave
argument_list|,
name|smp
operator|->
name|mgmt_class
argument_list|,
name|smp
operator|->
name|method
argument_list|,
name|network_view
condition|?
literal|"Network"
else|:
literal|"Host"
argument_list|,
name|be16_to_cpu
argument_list|(
name|smp
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|EPERM
return|;
block|}
block|}
return|return
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
name|opcode_modifier
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_CMD_EPERM_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
return|return
operator|-
name|EPERM
return|;
block|}
end_function

begin_function
name|int
name|mlx4_DMA_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|u64
name|in_param
decl_stmt|;
name|u64
name|out_param
decl_stmt|;
name|int
name|err
decl_stmt|;
name|in_param
operator|=
name|cmd
operator|->
name|has_inbox
condition|?
operator|(
name|u64
operator|)
name|inbox
operator|->
name|dma
else|:
name|vhcr
operator|->
name|in_param
expr_stmt|;
name|out_param
operator|=
name|cmd
operator|->
name|has_outbox
condition|?
operator|(
name|u64
operator|)
name|outbox
operator|->
name|dma
else|:
name|vhcr
operator|->
name|out_param
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|encode_slave_id
condition|)
block|{
name|in_param
operator|&=
literal|0xffffffffffffff00ll
expr_stmt|;
name|in_param
operator||=
name|slave
expr_stmt|;
block|}
name|err
operator|=
name|__mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
operator|&
name|out_param
argument_list|,
name|cmd
operator|->
name|out_is_imm
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|out_is_imm
condition|)
name|vhcr
operator|->
name|out_param
operator|=
name|out_param
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mlx4_cmd_info
name|cmd_info
index|[]
init|=
block|{
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_FW
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_FW_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_HCA
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_DEV_CAP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_DEV_CAP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_FUNC_CAP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_FUNC_CAP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_ADAPTER
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_INIT_PORT
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_INIT_PORT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_CLOSE_PORT
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CLOSE_PORT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_PORT
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_PORT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SET_PORT
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SET_PORT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_MAP_EQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_MAP_EQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SW2HW_EQ
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|true
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SW2HW_EQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_HW_HEALTH_CHECK
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_NOP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_CONFIG_DEV
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CONFIG_DEV_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_ALLOC_RES
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|true
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_ALLOC_RES_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_FREE_RES
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_FREE_RES_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SW2HW_MPT
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|true
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SW2HW_MPT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_MPT
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_MPT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_HW2SW_MPT
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_HW2SW_MPT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_READ_MTT
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_WRITE_MTT
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_WRITE_MTT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SYNC_TPT
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_HW2SW_EQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|true
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_HW2SW_EQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_EQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|true
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_EQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SW2HW_CQ
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|true
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SW2HW_CQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_HW2SW_CQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_HW2SW_CQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_CQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_CQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_MODIFY_CQ
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|true
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_MODIFY_CQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SW2HW_SRQ
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|true
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SW2HW_SRQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_HW2SW_SRQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_HW2SW_SRQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_SRQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_SRQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_ARM_SRQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_ARM_SRQ_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_RST2INIT_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|true
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_RST2INIT_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_INIT2INIT_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_INIT2INIT_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_INIT2RTR_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_INIT2RTR_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_RTR2RTS_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_RTR2RTS_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_RTS2RTS_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_RTS2RTS_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SQERR2RTS_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SQERR2RTS_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_2ERR_QP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_GEN_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_RTS2SQD_QP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_GEN_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SQD2SQD_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SQD2SQD_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SQD2RTS_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SQD2RTS_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_2RST_QP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_2RST_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_QP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_GEN_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SUSPEND_QP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_GEN_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_UNSUSPEND_QP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_GEN_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_UPDATE_QP
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_UPDATE_QP_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_GET_OP_REQ
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CMD_EPERM_wrapper
block|, 	}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_ALLOCATE_VPP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CMD_EPERM_wrapper
block|, 	}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SET_VPORT_QOS
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CMD_EPERM_wrapper
block|, 	}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_CONF_SPECIAL_QP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
comment|/* XXX verify: only demux can do this */
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_MAD_IFC
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_MAD_IFC_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_MAD_DEMUX
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CMD_EPERM_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QUERY_IF_STAT
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QUERY_IF_STAT_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_ACCESS_REG
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_ACCESS_REG_wrapper
block|, 	}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_CONGESTION_CTRL_OPCODE
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CMD_EPERM_wrapper
block|, 	}
block|,
comment|/* Native multicast commands are not available for guests */
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_QP_ATTACH
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QP_ATTACH_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_PROMISC
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_PROMISC_wrapper
block|}
block|,
comment|/* Ethernet specific commands */
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SET_VLAN_FLTR
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SET_VLAN_FLTR_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_SET_MCAST_FLTR
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_SET_MCAST_FLTR_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_DUMP_ETH_STATS
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|true
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_DUMP_ETH_STATS_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_INFORM_FLR_DONE
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|NULL
block|}
block|,
comment|/* flow steering commands */
block|{
operator|.
name|opcode
operator|=
name|MLX4_QP_FLOW_STEERING_ATTACH
block|,
operator|.
name|has_inbox
operator|=
name|true
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|true
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QP_FLOW_STEERING_ATTACH_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_QP_FLOW_STEERING_DETACH
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_QP_FLOW_STEERING_DETACH_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_FLOW_STEERING_IB_UC_QP_RANGE
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CMD_EPERM_wrapper
block|}
block|,
block|{
operator|.
name|opcode
operator|=
name|MLX4_CMD_VIRT_PORT_MAP
block|,
operator|.
name|has_inbox
operator|=
name|false
block|,
operator|.
name|has_outbox
operator|=
name|false
block|,
operator|.
name|out_is_imm
operator|=
name|false
block|,
operator|.
name|encode_slave_id
operator|=
name|false
block|,
operator|.
name|verify
operator|=
name|NULL
block|,
operator|.
name|wrapper
operator|=
name|mlx4_CMD_EPERM_wrapper
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mlx4_master_process_vhcr
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr_cmd
modifier|*
name|in_vhcr
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_vhcr_cmd
modifier|*
name|vhcr_cmd
init|=
name|in_vhcr
condition|?
name|in_vhcr
else|:
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
decl_stmt|;
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
init|=
name|NULL
decl_stmt|;
name|u64
name|in_param
decl_stmt|;
name|u64
name|out_param
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Create sw representation of Virtual HCR */
name|vhcr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_vhcr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vhcr
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* DMA in the vHCR */
if|if
condition|(
operator|!
name|in_vhcr
condition|)
block|{
name|ret
operator|=
name|mlx4_ACCESS_MEM
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
argument_list|,
name|slave
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|vhcr_dma
argument_list|,
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_vhcr_cmd
argument_list|)
argument_list|,
name|MLX4_ACCESS_MEM_ALIGN
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
operator|)
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s: Failed reading vhcr ret: 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|vhcr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/* Fill SW VHCR fields */
name|vhcr
operator|->
name|in_param
operator|=
name|be64_to_cpu
argument_list|(
name|vhcr_cmd
operator|->
name|in_param
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|out_param
operator|=
name|be64_to_cpu
argument_list|(
name|vhcr_cmd
operator|->
name|out_param
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|in_modifier
operator|=
name|be32_to_cpu
argument_list|(
name|vhcr_cmd
operator|->
name|in_modifier
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|token
operator|=
name|be16_to_cpu
argument_list|(
name|vhcr_cmd
operator|->
name|token
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|op
operator|=
name|be16_to_cpu
argument_list|(
name|vhcr_cmd
operator|->
name|opcode
argument_list|)
operator|&
literal|0xfff
expr_stmt|;
name|vhcr
operator|->
name|op_modifier
operator|=
call|(
name|u8
call|)
argument_list|(
name|be16_to_cpu
argument_list|(
name|vhcr_cmd
operator|->
name|opcode
argument_list|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|vhcr
operator|->
name|e_bit
operator|=
name|vhcr_cmd
operator|->
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* Lookup command */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cmd_info
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vhcr
operator|->
name|op
operator|==
name|cmd_info
index|[
name|i
index|]
operator|.
name|opcode
condition|)
block|{
name|cmd
operator|=
operator|&
name|cmd_info
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unknown command:0x%x accepted from slave:%d\n"
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|vhcr_cmd
operator|->
name|status
operator|=
name|CMD_STAT_BAD_PARAM
expr_stmt|;
goto|goto
name|out_status
goto|;
block|}
comment|/* Read inbox */
if|if
condition|(
name|cmd
operator|->
name|has_inbox
condition|)
block|{
name|vhcr
operator|->
name|in_param
operator|&=
name|INBOX_MASK
expr_stmt|;
name|inbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|inbox
argument_list|)
condition|)
block|{
name|vhcr_cmd
operator|->
name|status
operator|=
name|CMD_STAT_BAD_SIZE
expr_stmt|;
name|inbox
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_status
goto|;
block|}
name|ret
operator|=
name|mlx4_ACCESS_MEM
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_param
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
operator|)
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s: Failed reading inbox (cmd:0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|vhcr_cmd
operator|->
name|status
operator|=
name|CMD_STAT_INTERNAL_ERR
expr_stmt|;
goto|goto
name|out_status
goto|;
block|}
block|}
comment|/* Apply permission and bound checks if applicable */
if|if
condition|(
name|cmd
operator|->
name|verify
operator|&&
name|cmd
operator|->
name|verify
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Command:0x%x from slave: %d failed protection checks for resource_id:%d\n"
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|)
expr_stmt|;
name|vhcr_cmd
operator|->
name|status
operator|=
name|CMD_STAT_BAD_OP
expr_stmt|;
goto|goto
name|out_status
goto|;
block|}
comment|/* Allocate outbox */
if|if
condition|(
name|cmd
operator|->
name|has_outbox
condition|)
block|{
name|outbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|outbox
argument_list|)
condition|)
block|{
name|vhcr_cmd
operator|->
name|status
operator|=
name|CMD_STAT_BAD_SIZE
expr_stmt|;
name|outbox
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_status
goto|;
block|}
block|}
comment|/* Execute the command! */
if|if
condition|(
name|cmd
operator|->
name|wrapper
condition|)
block|{
name|err
operator|=
name|cmd
operator|->
name|wrapper
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
argument_list|,
name|inbox
argument_list|,
name|outbox
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|out_is_imm
condition|)
name|vhcr_cmd
operator|->
name|out_param
operator|=
name|cpu_to_be64
argument_list|(
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in_param
operator|=
name|cmd
operator|->
name|has_inbox
condition|?
operator|(
name|u64
operator|)
name|inbox
operator|->
name|dma
else|:
name|vhcr
operator|->
name|in_param
expr_stmt|;
name|out_param
operator|=
name|cmd
operator|->
name|has_outbox
condition|?
operator|(
name|u64
operator|)
name|outbox
operator|->
name|dma
else|:
name|vhcr
operator|->
name|out_param
expr_stmt|;
name|err
operator|=
name|__mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
operator|&
name|out_param
argument_list|,
name|cmd
operator|->
name|out_is_imm
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
name|vhcr
operator|->
name|op_modifier
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|out_is_imm
condition|)
block|{
name|vhcr
operator|->
name|out_param
operator|=
name|out_param
expr_stmt|;
name|vhcr_cmd
operator|->
name|out_param
operator|=
name|cpu_to_be64
argument_list|(
name|vhcr
operator|->
name|out_param
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
operator|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"vhcr command:0x%x slave:%d failed with error:%d, status %d\n"
argument_list|,
name|vhcr
operator|->
name|op
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|errno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|vhcr_cmd
operator|->
name|status
operator|=
name|mlx4_errno_to_status
argument_list|(
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out_status
goto|;
block|}
comment|/* Write outbox if command completed successfully */
if|if
condition|(
name|cmd
operator|->
name|has_outbox
operator|&&
operator|!
name|vhcr_cmd
operator|->
name|status
condition|)
block|{
name|ret
operator|=
name|mlx4_ACCESS_MEM
argument_list|(
name|dev
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|out_param
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* If we failed to write back the outbox after the 			 *command was successfully executed, we must fail this 			 * slave, as it is now in undefined state */
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|persist
operator|->
name|state
operator|&
name|MLX4_DEVICE_STATE_INTERNAL_ERROR
operator|)
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s:Failed writing outbox\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out_status
label|:
comment|/* DMA back vhcr result */
if|if
condition|(
operator|!
name|in_vhcr
condition|)
block|{
name|ret
operator|=
name|mlx4_ACCESS_MEM
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
argument_list|,
name|slave
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|vhcr_dma
argument_list|,
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_vhcr
argument_list|)
argument_list|,
name|MLX4_ACCESS_MEM_ALIGN
argument_list|)
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s:Failed writing vhcr result\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vhcr
operator|->
name|e_bit
operator|&&
name|mlx4_GEN_EQE
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|cmd_eqe
argument_list|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to generate command completion eqe for slave %d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|kfree
argument_list|(
name|vhcr
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|outbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_master_immediate_activate_vlan_qos
parameter_list|(
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|vp_admin
decl_stmt|;
name|struct
name|mlx4_vf_immed_vlan_work
modifier|*
name|work
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
operator|&
name|priv
operator|->
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|admin_vlan_ix
init|=
name|NO_INDX
decl_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|vp_admin
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
operator|==
name|vp_admin
operator|->
name|default_vlan
operator|&&
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
operator|==
name|vp_admin
operator|->
name|default_qos
operator|&&
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|==
name|vp_admin
operator|->
name|vlan_proto
operator|&&
name|vp_oper
operator|->
name|state
operator|.
name|qos_vport
operator|==
name|vp_admin
operator|->
name|qos_vport
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|active
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_UPDATE_QP
operator|)
condition|)
block|{
comment|/* even if the UPDATE_QP command isn't supported, we still want 		 * to set this VF link according to the admin directive 		 */
return|return
operator|-
literal|1
return|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"updating immediately admin params slave %d port %d\n"
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"vlan %d QoS %d link down\n"
argument_list|,
name|vp_admin
operator|->
name|default_vlan
argument_list|,
name|vp_admin
operator|->
name|default_qos
argument_list|)
expr_stmt|;
name|work
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|work
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|work
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
operator|!=
name|vp_admin
operator|->
name|default_vlan
condition|)
block|{
if|if
condition|(
name|MLX4_VGT
operator|!=
name|vp_admin
operator|->
name|default_vlan
condition|)
block|{
name|err
operator|=
name|__mlx4_register_vlan
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vp_admin
operator|->
name|default_vlan
argument_list|,
operator|&
name|admin_vlan_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kfree
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"No vlan resources slave %d, port %d\n"
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
else|else
block|{
name|admin_vlan_ix
operator|=
name|NO_INDX
expr_stmt|;
block|}
name|work
operator|->
name|flags
operator||=
name|MLX4_VF_IMMED_VLAN_FLAG_VLAN
expr_stmt|;
name|mlx4_dbg
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"alloc vlan %d idx  %d slave %d port %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|vp_admin
operator|->
name|default_vlan
argument_list|)
argument_list|,
name|admin_vlan_ix
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* save original vlan ix and vlan id */
name|work
operator|->
name|orig_vlan_id
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
expr_stmt|;
name|work
operator|->
name|orig_vlan_ix
operator|=
name|vp_oper
operator|->
name|vlan_idx
expr_stmt|;
comment|/* handle new qos */
if|if
condition|(
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
operator|!=
name|vp_admin
operator|->
name|default_qos
condition|)
name|work
operator|->
name|flags
operator||=
name|MLX4_VF_IMMED_VLAN_FLAG_QOS
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|flags
operator|&
name|MLX4_VF_IMMED_VLAN_FLAG_VLAN
condition|)
name|vp_oper
operator|->
name|vlan_idx
operator|=
name|admin_vlan_ix
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
operator|=
name|vp_admin
operator|->
name|default_vlan
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
operator|=
name|vp_admin
operator|->
name|default_qos
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|=
name|vp_admin
operator|->
name|vlan_proto
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|qos_vport
operator|=
name|vp_admin
operator|->
name|qos_vport
expr_stmt|;
if|if
condition|(
literal|1
comment|/* vp_admin->link_state == IFLA_VF_LINK_STATE_DISABLE */
condition|)
name|work
operator|->
name|flags
operator||=
name|MLX4_VF_IMMED_VLAN_FLAG_LINK_DISABLE
expr_stmt|;
comment|/* iterate over QPs owned by this slave, using UPDATE_QP */
name|work
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|work
operator|->
name|slave
operator|=
name|slave
expr_stmt|;
name|work
operator|->
name|qos
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
expr_stmt|;
name|work
operator|->
name|qos_vport
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|qos_vport
expr_stmt|;
name|work
operator|->
name|vlan_id
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
expr_stmt|;
name|work
operator|->
name|vlan_ix
operator|=
name|vp_oper
operator|->
name|vlan_idx
expr_stmt|;
name|work
operator|->
name|vlan_proto
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
expr_stmt|;
name|work
operator|->
name|priv
operator|=
name|priv
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|work
operator|->
name|work
argument_list|,
name|mlx4_vf_immed_vlan_work_handler
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_set_default_port_qos
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_qos_manager
modifier|*
name|port_qos_ctl
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|port_qos_ctl
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qos_ctl
index|[
name|port
index|]
expr_stmt|;
name|bitmap_zero
argument_list|(
name|port_qos_ctl
operator|->
name|priority_bm
argument_list|,
name|MLX4_NUM_UP
argument_list|)
expr_stmt|;
comment|/* Enable only default prio at PF init routine */
name|set_bit
argument_list|(
name|MLX4_DEFAULT_QOS_PRIO
argument_list|,
name|port_qos_ctl
operator|->
name|priority_bm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_allocate_port_vpps
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|num_vfs
decl_stmt|;
name|u16
name|availible_vpp
decl_stmt|;
name|u8
name|vpp_param
index|[
name|MLX4_NUM_UP
index|]
decl_stmt|;
name|struct
name|mlx4_qos_manager
modifier|*
name|port_qos
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|err
operator|=
name|mlx4_ALLOCATE_VPP_get
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|availible_vpp
argument_list|,
name|vpp_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Failed query availible VPPs\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|port_qos
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qos_ctl
index|[
name|port
index|]
expr_stmt|;
name|num_vfs
operator|=
operator|(
name|availible_vpp
operator|/
name|bitmap_weight
argument_list|(
name|port_qos
operator|->
name|priority_bm
argument_list|,
name|MLX4_NUM_UP
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_NUM_UP
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|test_bit
argument_list|(
name|i
argument_list|,
name|port_qos
operator|->
name|priority_bm
argument_list|)
condition|)
name|vpp_param
index|[
name|i
index|]
operator|=
name|num_vfs
expr_stmt|;
block|}
name|err
operator|=
name|mlx4_ALLOCATE_VPP_set
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|vpp_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Failed allocating VPPs\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Query actual allocated VPP, just to make sure */
name|err
operator|=
name|mlx4_ALLOCATE_VPP_get
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|availible_vpp
argument_list|,
name|vpp_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Failed query availible VPPs\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|port_qos
operator|->
name|num_of_qos_vfs
operator|=
name|num_vfs
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Port %d Availible VPPs %d\n"
argument_list|,
name|port
argument_list|,
name|availible_vpp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_NUM_UP
condition|;
name|i
operator|++
control|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Port %d UP %d Allocated %d VPPs\n"
argument_list|,
name|port
argument_list|,
name|i
argument_list|,
name|vpp_param
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_master_activate_admin_state
parameter_list|(
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|int
name|port
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|vp_admin
decl_stmt|;
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|slave_state
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
decl_stmt|;
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
name|int
name|min_port
init|=
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|priv
operator|->
name|dev
operator|.
name|caps
operator|.
name|num_ports
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|max_port
init|=
name|min_port
operator|-
literal|1
operator|+
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|priv
operator|->
name|dev
operator|.
name|caps
operator|.
name|num_ports
argument_list|)
decl_stmt|;
for|for
control|(
name|port
operator|=
name|min_port
init|;
name|port
operator|<=
name|max_port
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|test_bit
argument_list|(
name|port
operator|-
literal|1
argument_list|,
name|actv_ports
operator|.
name|ports
argument_list|)
condition|)
continue|continue;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|smi_enabled
index|[
name|port
index|]
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|enable_smi
index|[
name|port
index|]
expr_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|vp_admin
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|vp_admin
operator|->
name|vlan_proto
operator|!=
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
operator|||
name|slave_state
operator|->
name|vst_qinq_supported
condition|)
block|{
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|=
name|vp_admin
operator|->
name|vlan_proto
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
operator|=
name|vp_admin
operator|->
name|default_vlan
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
operator|=
name|vp_admin
operator|->
name|default_qos
expr_stmt|;
block|}
name|vp_oper
operator|->
name|state
operator|.
name|mac
operator|=
name|vp_admin
operator|->
name|mac
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|spoofchk
operator|=
name|vp_admin
operator|->
name|spoofchk
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|tx_rate
operator|=
name|vp_admin
operator|->
name|tx_rate
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|qos_vport
operator|=
name|vp_admin
operator|->
name|qos_vport
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|guid
operator|=
name|vp_admin
operator|->
name|guid
expr_stmt|;
if|if
condition|(
name|MLX4_VGT
operator|!=
name|vp_admin
operator|->
name|default_vlan
condition|)
block|{
name|err
operator|=
name|__mlx4_register_vlan
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vp_admin
operator|->
name|default_vlan
argument_list|,
operator|&
operator|(
name|vp_oper
operator|->
name|vlan_idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|vp_oper
operator|->
name|vlan_idx
operator|=
name|NO_INDX
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
operator|=
name|MLX4_VGT
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|=
name|htons
argument_list|(
name|ETH_P_8021Q
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"No vlan resources slave %d, port %d\n"
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"alloc vlan %d idx  %d slave %d port %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
argument_list|)
argument_list|,
name|vp_oper
operator|->
name|vlan_idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp_admin
operator|->
name|spoofchk
condition|)
block|{
name|vp_oper
operator|->
name|mac_idx
operator|=
name|__mlx4_register_mac
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vp_admin
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|vp_oper
operator|->
name|mac_idx
condition|)
block|{
name|err
operator|=
name|vp_oper
operator|->
name|mac_idx
expr_stmt|;
name|vp_oper
operator|->
name|mac_idx
operator|=
name|NO_INDX
expr_stmt|;
name|mlx4_warn
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"No mac resources slave %d, port %d\n"
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"alloc mac %llx idx  %d slave %d port %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|vp_oper
operator|->
name|state
operator|.
name|mac
argument_list|,
name|vp_oper
operator|->
name|mac_idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_master_deactivate_admin_state
parameter_list|(
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
name|int
name|min_port
init|=
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|priv
operator|->
name|dev
operator|.
name|caps
operator|.
name|num_ports
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|max_port
init|=
name|min_port
operator|-
literal|1
operator|+
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|priv
operator|->
name|dev
operator|.
name|caps
operator|.
name|num_ports
argument_list|)
decl_stmt|;
for|for
control|(
name|port
operator|=
name|min_port
init|;
name|port
operator|<=
name|max_port
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|test_bit
argument_list|(
name|port
operator|-
literal|1
argument_list|,
name|actv_ports
operator|.
name|ports
argument_list|)
condition|)
continue|continue;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|smi_enabled
index|[
name|port
index|]
operator|=
name|MLX4_VF_SMI_DISABLED
expr_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|NO_INDX
operator|!=
name|vp_oper
operator|->
name|vlan_idx
condition|)
block|{
name|__mlx4_unregister_vlan
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
argument_list|)
expr_stmt|;
name|vp_oper
operator|->
name|vlan_idx
operator|=
name|NO_INDX
expr_stmt|;
block|}
if|if
condition|(
name|NO_INDX
operator|!=
name|vp_oper
operator|->
name|mac_idx
condition|)
block|{
name|__mlx4_unregister_mac
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vp_oper
operator|->
name|state
operator|.
name|mac
argument_list|)
expr_stmt|;
name|vp_oper
operator|->
name|mac_idx
operator|=
name|NO_INDX
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_master_do_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|u8
name|cmd
parameter_list|,
name|u16
name|param
parameter_list|,
name|u8
name|toggle
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|slave_state
init|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
decl_stmt|;
name|u32
name|reply
decl_stmt|;
name|u8
name|is_going_down
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|comm_toggle
operator|^=
literal|1
expr_stmt|;
name|reply
operator|=
operator|(
name|u32
operator|)
name|slave_state
index|[
name|slave
index|]
operator|.
name|comm_toggle
operator|<<
literal|31
expr_stmt|;
if|if
condition|(
name|toggle
operator|!=
name|slave_state
index|[
name|slave
index|]
operator|.
name|comm_toggle
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Incorrect toggle %d from slave %d. *** MASTER STATE COMPROMISED ***\n"
argument_list|,
name|toggle
argument_list|,
name|slave
argument_list|)
expr_stmt|;
goto|goto
name|reset_slave
goto|;
block|}
if|if
condition|(
name|cmd
operator|==
name|MLX4_COMM_CMD_RESET
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Received reset from slave:%d\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|active
operator|=
name|false
expr_stmt|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|old_vlan_api
operator|=
name|false
expr_stmt|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|vst_qinq_supported
operator|=
name|false
expr_stmt|;
name|mlx4_master_deactivate_admin_state
argument_list|(
name|priv
argument_list|,
name|slave
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_EVENT_TYPES_NUM
condition|;
operator|++
name|i
control|)
block|{
name|slave_state
index|[
name|slave
index|]
operator|.
name|event_eq
index|[
name|i
index|]
operator|.
name|eqn
operator|=
operator|-
literal|1
expr_stmt|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|event_eq
index|[
name|i
index|]
operator|.
name|token
operator|=
literal|0
expr_stmt|;
block|}
comment|/*check if we are in the middle of FLR process, 		if so return "retry" status to the slave*/
if|if
condition|(
name|MLX4_COMM_CMD_FLR
operator|==
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
condition|)
goto|goto
name|inform_slave_state
goto|;
name|mlx4_dispatch_event
argument_list|(
name|dev
argument_list|,
name|MLX4_DEV_EVENT_SLAVE_SHUTDOWN
argument_list|,
name|slave
argument_list|)
expr_stmt|;
comment|/* write the version in the event field */
name|reply
operator||=
name|mlx4_comm_get_version
argument_list|()
expr_stmt|;
goto|goto
name|reset_slave
goto|;
block|}
comment|/*command from slave in the middle of FLR*/
if|if
condition|(
name|cmd
operator|!=
name|MLX4_COMM_CMD_RESET
operator|&&
name|MLX4_COMM_CMD_FLR
operator|==
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"slave:%d is Trying to run cmd(0x%x) in the middle of FLR\n"
argument_list|,
name|slave
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MLX4_COMM_CMD_VHCR0
case|:
if|if
condition|(
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_RESET
condition|)
goto|goto
name|reset_slave
goto|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|vhcr_dma
operator|=
operator|(
operator|(
name|u64
operator|)
name|param
operator|)
operator|<<
literal|48
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|cookie
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MLX4_COMM_CMD_VHCR1
case|:
if|if
condition|(
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_VHCR0
condition|)
goto|goto
name|reset_slave
goto|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|vhcr_dma
operator||=
operator|(
operator|(
name|u64
operator|)
name|param
operator|)
operator|<<
literal|32
expr_stmt|;
break|break;
case|case
name|MLX4_COMM_CMD_VHCR2
case|:
if|if
condition|(
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_VHCR1
condition|)
goto|goto
name|reset_slave
goto|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|vhcr_dma
operator||=
operator|(
operator|(
name|u64
operator|)
name|param
operator|)
operator|<<
literal|16
expr_stmt|;
break|break;
case|case
name|MLX4_COMM_CMD_VHCR_EN
case|:
if|if
condition|(
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_VHCR2
condition|)
goto|goto
name|reset_slave
goto|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|vhcr_dma
operator||=
name|param
expr_stmt|;
if|if
condition|(
name|mlx4_master_activate_admin_state
argument_list|(
name|priv
argument_list|,
name|slave
argument_list|)
condition|)
goto|goto
name|reset_slave
goto|;
name|slave_state
index|[
name|slave
index|]
operator|.
name|active
operator|=
name|true
expr_stmt|;
name|mlx4_dispatch_event
argument_list|(
name|dev
argument_list|,
name|MLX4_DEV_EVENT_SLAVE_INIT
argument_list|,
name|slave
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_COMM_CMD_VHCR_POST
case|:
if|if
condition|(
operator|(
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_VHCR_EN
operator|)
operator|&&
operator|(
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_VHCR_POST
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"slave:%d is out of sync, cmd=0x%x, last command=0x%x, reset is needed\n"
argument_list|,
name|slave
argument_list|,
name|cmd
argument_list|,
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
argument_list|)
expr_stmt|;
goto|goto
name|reset_slave
goto|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_master_process_vhcr
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed processing vhcr for slave:%d, resetting slave\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
goto|goto
name|reset_slave
goto|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Bad comm cmd:%d from slave:%d\n"
argument_list|,
name|cmd
argument_list|,
name|slave
argument_list|)
expr_stmt|;
goto|goto
name|reset_slave
goto|;
block|}
name|spin_lock_irqsave
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slave_state
index|[
name|slave
index|]
operator|.
name|is_slave_going_down
condition|)
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|=
name|cmd
expr_stmt|;
else|else
name|is_going_down
operator|=
literal|1
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_going_down
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Slave is going down aborting command(%d) executing from slave:%d\n"
argument_list|,
name|cmd
argument_list|,
name|slave
argument_list|)
expr_stmt|;
return|return;
block|}
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|reply
argument_list|)
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
index|[
name|slave
index|]
operator|.
name|slave_read
argument_list|)
expr_stmt|;
name|mmiowb
argument_list|()
expr_stmt|;
return|return;
name|reset_slave
label|:
comment|/* cleanup any slave resources */
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|interface_state
operator|&
name|MLX4_INTERFACE_STATE_UP
condition|)
name|mlx4_delete_all_resources_for_slave
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|MLX4_COMM_CMD_RESET
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Turn on internal error to force reset, slave=%d, cmd=0x%x\n"
argument_list|,
name|slave
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Turn on internal error letting slave reset itself immeditaly, 		 * otherwise it might take till timeout on command is passed 		 */
name|reply
operator||=
operator|(
operator|(
name|u32
operator|)
name|COMM_CHAN_EVENT_INTERNAL_ERR
operator|)
expr_stmt|;
block|}
name|spin_lock_irqsave
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slave_state
index|[
name|slave
index|]
operator|.
name|is_slave_going_down
condition|)
name|slave_state
index|[
name|slave
index|]
operator|.
name|last_cmd
operator|=
name|MLX4_COMM_CMD_RESET
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/*with slave in the middle of flr, no need to clean resources again.*/
name|inform_slave_state
label|:
name|memset
argument_list|(
operator|&
name|slave_state
index|[
name|slave
index|]
operator|.
name|event_eq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_slave_event_eq_info
argument_list|)
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|reply
argument_list|)
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
index|[
name|slave
index|]
operator|.
name|slave_read
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* master command processing */
end_comment

begin_function
name|void
name|mlx4_master_comm_channel
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|mlx4_mfunc_master_ctx
modifier|*
name|master
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|mlx4_mfunc_master_ctx
argument_list|,
name|comm_work
argument_list|)
decl_stmt|;
name|struct
name|mlx4_mfunc
modifier|*
name|mfunc
init|=
name|container_of
argument_list|(
name|master
argument_list|,
expr|struct
name|mlx4_mfunc
argument_list|,
name|master
argument_list|)
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|mfunc
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|mfunc
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
operator|&
name|priv
operator|->
name|dev
decl_stmt|;
name|__be32
modifier|*
name|bit_vec
decl_stmt|;
name|u32
name|comm_cmd
decl_stmt|;
name|u32
name|vec
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|slave
decl_stmt|;
name|int
name|toggle
decl_stmt|;
name|int
name|served
init|=
literal|0
decl_stmt|;
name|int
name|reported
init|=
literal|0
decl_stmt|;
name|u32
name|slt
decl_stmt|;
name|bit_vec
operator|=
name|master
operator|->
name|comm_arm_bit_vector
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COMM_CHANNEL_BIT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|vec
operator|=
name|be32_to_cpu
argument_list|(
name|bit_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|vec
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
condition|)
continue|continue;
operator|++
name|reported
expr_stmt|;
name|slave
operator|=
operator|(
name|i
operator|*
literal|32
operator|)
operator|+
name|j
expr_stmt|;
name|comm_cmd
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|mfunc
operator|->
name|comm
index|[
name|slave
index|]
operator|.
name|slave_write
argument_list|)
argument_list|)
expr_stmt|;
name|slt
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|mfunc
operator|->
name|comm
index|[
name|slave
index|]
operator|.
name|slave_read
argument_list|)
argument_list|)
operator|>>
literal|31
expr_stmt|;
name|toggle
operator|=
name|comm_cmd
operator|>>
literal|31
expr_stmt|;
if|if
condition|(
name|toggle
operator|!=
name|slt
condition|)
block|{
if|if
condition|(
name|master
operator|->
name|slave_state
index|[
name|slave
index|]
operator|.
name|comm_toggle
operator|!=
name|slt
condition|)
block|{
name|pr_info
argument_list|(
literal|"slave %d out of sync. read toggle %d, state toggle %d. Resynching.\n"
argument_list|,
name|slave
argument_list|,
name|slt
argument_list|,
name|master
operator|->
name|slave_state
index|[
name|slave
index|]
operator|.
name|comm_toggle
argument_list|)
expr_stmt|;
name|master
operator|->
name|slave_state
index|[
name|slave
index|]
operator|.
name|comm_toggle
operator|=
name|slt
expr_stmt|;
block|}
name|mlx4_master_do_cmd
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|comm_cmd
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|comm_cmd
operator|&
literal|0xffff
argument_list|,
name|toggle
argument_list|)
expr_stmt|;
operator|++
name|served
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reported
operator|&&
name|reported
operator|!=
name|served
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Got command event with bitmask from %d slaves but %d were served\n"
argument_list|,
name|reported
argument_list|,
name|served
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_ARM_COMM_CHANNEL
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to arm comm channel events\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sync_toggles
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|wr_toggle
decl_stmt|;
name|u32
name|rd_toggle
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|wr_toggle
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_write
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_toggle
operator|==
literal|0xffffffff
condition|)
name|end
operator|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
else|else
name|end
operator|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
while|while
condition|(
name|time_before
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
block|{
name|rd_toggle
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_read
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_toggle
operator|==
literal|0xffffffff
operator|||
name|rd_toggle
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* PCI might be offline */
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|wr_toggle
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_write
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rd_toggle
operator|>>
literal|31
operator|==
name|wr_toggle
operator|>>
literal|31
condition|)
block|{
name|priv
operator|->
name|cmd
operator|.
name|comm_toggle
operator|=
name|rd_toggle
operator|>>
literal|31
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cond_resched
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * we could reach here if for example the previous VM using this 	 * function misbehaved and left the channel with unsynced state. We 	 * should fix this here and give this VM a chance to use a properly 	 * synced channel 	 */
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"recovering from previously mis-behaved VM\n"
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
literal|0
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_read
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
literal|0
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_write
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|comm_toggle
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_multi_func_init
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|s_state
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|port
decl_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|comm_bar
argument_list|)
operator|+
name|priv
operator|->
name|fw
operator|.
name|comm_base
argument_list|,
name|MLX4_COMM_PAGESIZE
argument_list|)
expr_stmt|;
else|else
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|+
name|MLX4_SLAVE_COMM_BASE
argument_list|,
name|MLX4_COMM_PAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|comm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map communication vector\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_vhcr
goto|;
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|struct
name|mlx4_vf_oper_state
modifier|*
name|vf_oper
decl_stmt|;
name|struct
name|mlx4_vf_admin_state
modifier|*
name|vf_admin
decl_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
operator|=
name|kzalloc
argument_list|(
name|dev
operator|->
name|num_slaves
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_slave_state
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
condition|)
goto|goto
name|err_comm
goto|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
operator|=
name|kzalloc
argument_list|(
name|dev
operator|->
name|num_slaves
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_vf_admin_state
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
condition|)
goto|goto
name|err_comm_admin
goto|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
operator|=
name|kzalloc
argument_list|(
name|dev
operator|->
name|num_slaves
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_vf_oper_state
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
condition|)
goto|goto
name|err_comm_oper
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
operator|++
name|i
control|)
block|{
name|vf_admin
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|i
index|]
expr_stmt|;
name|vf_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|i
index|]
expr_stmt|;
name|s_state
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
expr_stmt|;
name|s_state
operator|->
name|last_cmd
operator|=
name|MLX4_COMM_CMD_RESET
expr_stmt|;
name|s_state
operator|->
name|vst_qinq_supported
operator|=
name|false
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|gen_eqe_mutex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_EVENT_TYPES_NUM
condition|;
operator|++
name|j
control|)
name|s_state
operator|->
name|event_eq
index|[
name|j
index|]
operator|.
name|eqn
operator|=
operator|-
literal|1
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
literal|0
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
index|[
name|i
index|]
operator|.
name|slave_write
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
literal|0
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
index|[
name|i
index|]
operator|.
name|slave_read
argument_list|)
expr_stmt|;
name|mmiowb
argument_list|()
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|MLX4_MAX_PORTS
condition|;
name|port
operator|++
control|)
block|{
name|struct
name|mlx4_vport_state
modifier|*
name|admin_vport
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|oper_vport
decl_stmt|;
name|s_state
operator|->
name|vlan_filter
index|[
name|port
index|]
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_vlan_fltr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s_state
operator|->
name|vlan_filter
index|[
name|port
index|]
condition|)
block|{
if|if
condition|(
operator|--
name|port
condition|)
name|kfree
argument_list|(
name|s_state
operator|->
name|vlan_filter
index|[
name|port
index|]
argument_list|)
expr_stmt|;
goto|goto
name|err_slaves
goto|;
block|}
name|admin_vport
operator|=
operator|&
name|vf_admin
operator|->
name|vport
index|[
name|port
index|]
expr_stmt|;
name|oper_vport
operator|=
operator|&
name|vf_oper
operator|->
name|vport
index|[
name|port
index|]
operator|.
name|state
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|s_state
operator|->
name|mcast_filters
index|[
name|port
index|]
argument_list|)
expr_stmt|;
name|admin_vport
operator|->
name|default_vlan
operator|=
name|MLX4_VGT
expr_stmt|;
name|oper_vport
operator|->
name|default_vlan
operator|=
name|MLX4_VGT
expr_stmt|;
name|admin_vport
operator|->
name|qos_vport
operator|=
name|MLX4_VPP_DEFAULT_VPORT
expr_stmt|;
name|oper_vport
operator|->
name|qos_vport
operator|=
name|MLX4_VPP_DEFAULT_VPORT
expr_stmt|;
name|admin_vport
operator|->
name|vlan_proto
operator|=
name|htons
argument_list|(
name|ETH_P_8021Q
argument_list|)
expr_stmt|;
name|oper_vport
operator|->
name|vlan_proto
operator|=
name|htons
argument_list|(
name|ETH_P_8021Q
argument_list|)
expr_stmt|;
name|vf_oper
operator|->
name|vport
index|[
name|port
index|]
operator|.
name|vlan_idx
operator|=
name|NO_INDX
expr_stmt|;
name|vf_oper
operator|->
name|vport
index|[
name|port
index|]
operator|.
name|mac_idx
operator|=
name|NO_INDX
expr_stmt|;
name|mlx4_set_random_admin_guid
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|spin_lock_init
argument_list|(
operator|&
name|s_state
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_QOS_VPP
condition|)
block|{
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|mlx4_is_eth
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|mlx4_set_default_port_qos
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mlx4_allocate_port_vpps
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|memset
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|cmd_eqe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_eqe
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|cmd_eqe
operator|.
name|type
operator|=
name|MLX4_EVENT_TYPE_CMD
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_work
argument_list|,
name|mlx4_master_comm_channel
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_event_work
argument_list|,
name|mlx4_gen_slave_eqe
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_flr_event_work
argument_list|,
name|mlx4_master_handle_slave_flr
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state_lock
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_eq
operator|.
name|event_lock
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"mlx4_comm"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_wq
condition|)
goto|goto
name|err_slaves
goto|;
if|if
condition|(
name|mlx4_init_resource_tracker
argument_list|(
name|dev
argument_list|)
condition|)
goto|goto
name|err_thread
goto|;
block|}
else|else
block|{
name|err
operator|=
name|sync_toggles
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't sync toggles\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_comm
goto|;
block|}
block|}
return|return
literal|0
return|;
name|err_thread
label|:
name|flush_workqueue
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_wq
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_wq
argument_list|)
expr_stmt|;
name|err_slaves
label|:
while|while
condition|(
name|i
operator|--
condition|)
block|{
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|MLX4_MAX_PORTS
condition|;
name|port
operator|++
control|)
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
operator|.
name|vlan_filter
index|[
name|port
index|]
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
argument_list|)
expr_stmt|;
name|err_comm_oper
label|:
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
argument_list|)
expr_stmt|;
name|err_comm_admin
label|:
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
argument_list|)
expr_stmt|;
name|err_comm
label|:
name|iounmap
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|comm
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|=
name|NULL
expr_stmt|;
name|err_vhcr
label|:
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|PAGE_SIZE
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
name|int
name|mlx4_cmd_init
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|initialized
condition|)
block|{
name|init_rwsem
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|switch_sem
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|use_events
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|toggle
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|initialized
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|MLX4_CMD_CLEANUP_STRUCT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|priv
operator|->
name|cmd
operator|.
name|hcr
condition|)
block|{
name|priv
operator|->
name|cmd
operator|.
name|hcr
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_HCR_BASE
argument_list|,
name|MLX4_HCR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|hcr
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map command register\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|flags
operator||=
name|MLX4_CMD_CLEANUP_HCR
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
condition|)
block|{
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
operator|=
name|dma_alloc_coherent
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|PAGE_SIZE
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
condition|)
goto|goto
name|err
goto|;
name|flags
operator||=
name|MLX4_CMD_CLEANUP_VHCR
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|pool
condition|)
block|{
name|priv
operator|->
name|cmd
operator|.
name|pool
operator|=
name|pci_pool_create
argument_list|(
literal|"mlx4_cmd"
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|pool
condition|)
goto|goto
name|err
goto|;
name|flags
operator||=
name|MLX4_CMD_CLEANUP_POOL
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err
label|:
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
name|void
name|mlx4_report_internal_err_comm_event
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|slave
decl_stmt|;
name|u32
name|slave_read
decl_stmt|;
comment|/* If the comm channel has not yet been initialized, 	 * skip reporting the internal error event to all 	 * the communication channels. 	 */
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|comm
condition|)
return|return;
comment|/* Report an internal error event to all 	 * communication channels. 	 */
for|for
control|(
name|slave
operator|=
literal|0
init|;
name|slave
operator|<
name|dev
operator|->
name|num_slaves
condition|;
name|slave
operator|++
control|)
block|{
name|slave_read
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
index|[
name|slave
index|]
operator|.
name|slave_read
argument_list|)
argument_list|)
expr_stmt|;
name|slave_read
operator||=
operator|(
name|u32
operator|)
name|COMM_CHAN_EVENT_INTERNAL_ERR
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|slave_read
argument_list|)
argument_list|,
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
index|[
name|slave
index|]
operator|.
name|slave_read
argument_list|)
expr_stmt|;
comment|/* Make sure that our comm channel write doesn't 		 * get mixed in with writes from another CPU. 		 */
name|mmiowb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mlx4_multi_func_cleanup
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|flush_workqueue
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_wq
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|comm_wq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|MLX4_MAX_PORTS
condition|;
name|port
operator|++
control|)
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
operator|.
name|vlan_filter
index|[
name|port
index|]
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_slaves
operator|=
literal|0
expr_stmt|;
block|}
name|iounmap
argument_list|(
name|priv
operator|->
name|mfunc
operator|.
name|comm
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_cmd_cleanup
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|cleanup_mask
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|cmd
operator|.
name|pool
operator|&&
operator|(
name|cleanup_mask
operator|&
name|MLX4_CMD_CLEANUP_POOL
operator|)
condition|)
block|{
name|pci_pool_destroy
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|pool
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|pool
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
operator|&&
name|priv
operator|->
name|cmd
operator|.
name|hcr
operator|&&
operator|(
name|cleanup_mask
operator|&
name|MLX4_CMD_CLEANUP_HCR
operator|)
condition|)
block|{
name|iounmap
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|hcr
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|hcr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|&&
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
operator|&&
operator|(
name|cleanup_mask
operator|&
name|MLX4_CMD_CLEANUP_VHCR
operator|)
condition|)
block|{
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|PAGE_SIZE
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
argument_list|,
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|vhcr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|priv
operator|->
name|cmd
operator|.
name|initialized
operator|&&
operator|(
name|cleanup_mask
operator|&
name|MLX4_CMD_CLEANUP_STRUCT
operator|)
condition|)
name|priv
operator|->
name|cmd
operator|.
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Switch to using events to issue FW commands (can only be called  * after event queue for command events has been initialized).  */
end_comment

begin_function
name|int
name|mlx4_cmd_use_events
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|context
operator|=
name|kmalloc
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_cmd_context
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|context
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|down_write
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|switch_sem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
condition|;
operator|++
name|i
control|)
block|{
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|i
index|]
operator|.
name|token
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|i
index|]
operator|.
name|next
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* To support fatal error flow, initialize all 		 * cmd contexts to allow simulating completions 		 * with complete() at any time. 		 */
name|init_completion
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|i
index|]
operator|.
name|done
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|-
literal|1
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|free_head
operator|=
literal|0
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|event_sem
argument_list|,
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
argument_list|)
expr_stmt|;
for|for
control|(
name|priv
operator|->
name|cmd
operator|.
name|token_mask
operator|=
literal|1
init|;
name|priv
operator|->
name|cmd
operator|.
name|token_mask
operator|<
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
condition|;
name|priv
operator|->
name|cmd
operator|.
name|token_mask
operator|<<=
literal|1
control|)
empty_stmt|;
comment|/* nothing */
operator|--
name|priv
operator|->
name|cmd
operator|.
name|token_mask
expr_stmt|;
name|down
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|use_events
operator|=
literal|1
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|switch_sem
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Switch back to polling (used when shutting down the device)  */
end_comment

begin_function
name|void
name|mlx4_cmd_use_polling
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|down_write
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|switch_sem
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|use_events
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
condition|;
operator|++
name|i
control|)
name|down
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|event_sem
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|context
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|switch_sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mlx4_alloc_cmd_mailbox
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|mailbox
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|mailbox
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mailbox
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mailbox
operator|->
name|buf
operator|=
name|pci_pool_alloc
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|pool
argument_list|,
name|GFP_KERNEL
argument_list|,
operator|&
name|mailbox
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mailbox
operator|->
name|buf
condition|)
block|{
name|kfree
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|)
expr_stmt|;
return|return
name|mailbox
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_alloc_cmd_mailbox
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_free_cmd_mailbox
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mailbox
condition|)
return|return;
name|pci_pool_free
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|pool
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_free_cmd_mailbox
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|u32
name|mlx4_comm_get_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u32
operator|)
name|CMD_CHAN_IF_REV
operator|<<
literal|8
operator|)
operator||
operator|(
name|u32
operator|)
name|CMD_CHAN_VER
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_get_slave_indx
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|vf
operator|<
literal|0
operator|)
operator|||
operator|(
name|vf
operator|>=
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Bad vf number:%d (number of activated vf: %d)\n"
argument_list|,
name|vf
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|num_vfs
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|vf
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_vf_indx
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
if|if
condition|(
name|slave
operator|<
literal|1
operator|||
name|slave
operator|>
name|dev
operator|->
name|persist
operator|->
name|num_vfs
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Bad slave number:%d (number of activated slaves: %lu)\n"
argument_list|,
name|slave
argument_list|,
name|dev
operator|->
name|num_slaves
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|slave
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|mlx4_cmd_wake_completions
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_context
modifier|*
name|context
decl_stmt|;
name|int
name|i
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|cmd
operator|.
name|context
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
condition|;
operator|++
name|i
control|)
block|{
name|context
operator|=
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|i
index|]
expr_stmt|;
name|context
operator|->
name|fw_status
operator|=
name|CMD_STAT_INTERNAL_ERR
expr_stmt|;
name|context
operator|->
name|result
operator|=
name|mlx4_status_to_errno
argument_list|(
name|CMD_STAT_INTERNAL_ERR
argument_list|)
expr_stmt|;
name|complete
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mlx4_active_ports
name|mlx4_get_active_ports
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_active_ports
name|actv_ports
decl_stmt|;
name|int
name|vf
decl_stmt|;
name|bitmap_zero
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|==
literal|0
condition|)
block|{
name|bitmap_fill
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
return|return
name|actv_ports
return|;
block|}
name|vf
operator|=
name|mlx4_get_vf_indx
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
operator|<
literal|0
condition|)
return|return
name|actv_ports
return|;
name|bitmap_set
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|dev_vfs
index|[
name|vf
index|]
operator|.
name|min_port
operator|-
literal|1
argument_list|,
name|min
argument_list|(
operator|(
name|int
operator|)
name|dev
operator|->
name|dev_vfs
index|[
name|mlx4_get_vf_indx
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
index|]
operator|.
name|n_ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|actv_ports
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_active_ports
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_slave_convert_port
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
name|unsigned
name|m
init|=
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|<=
literal|0
operator|||
name|port
operator|>
name|m
condition|)
return|return
operator|-
name|EINVAL
return|;
name|n
operator|=
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<=
name|n
condition|)
name|port
operator|=
name|n
operator|+
literal|1
expr_stmt|;
return|return
name|port
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_slave_convert_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_phys_to_slave_port
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|port
operator|-
literal|1
argument_list|,
name|actv_ports
operator|.
name|ports
argument_list|)
condition|)
return|return
name|port
operator|-
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_phys_to_slave_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|mlx4_slaves_pport
name|mlx4_phys_to_slaves_pport
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|mlx4_slaves_pport
name|slaves_pport
decl_stmt|;
name|bitmap_zero
argument_list|(
name|slaves_pport
operator|.
name|slaves
argument_list|,
name|MLX4_MFUNC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<=
literal|0
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
name|slaves_pport
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|port
operator|-
literal|1
argument_list|,
name|actv_ports
operator|.
name|ports
argument_list|)
condition|)
name|set_bit
argument_list|(
name|i
argument_list|,
name|slaves_pport
operator|.
name|slaves
argument_list|)
expr_stmt|;
block|}
return|return
name|slaves_pport
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_phys_to_slaves_pport
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|mlx4_slaves_pport
name|mlx4_phys_to_slaves_pport_actv
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|mlx4_active_ports
modifier|*
name|crit_ports
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|mlx4_slaves_pport
name|slaves_pport
decl_stmt|;
name|bitmap_zero
argument_list|(
name|slaves_pport
operator|.
name|slaves
argument_list|,
name|MLX4_MFUNC_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitmap_equal
argument_list|(
name|crit_ports
operator|->
name|ports
argument_list|,
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
condition|)
name|set_bit
argument_list|(
name|i
argument_list|,
name|slaves_pport
operator|.
name|slaves
argument_list|)
expr_stmt|;
block|}
return|return
name|slaves_pport
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_phys_to_slaves_pport_actv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_slaves_closest_port
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
name|int
name|min_port
init|=
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|max_port
init|=
name|min_port
operator|+
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|<
name|min_port
condition|)
name|port
operator|=
name|min_port
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|>=
name|max_port
condition|)
name|port
operator|=
name|max_port
operator|-
literal|1
expr_stmt|;
return|return
name|port
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_set_vport_qos
parameter_list|(
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|max_tx_rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_qos_manager
modifier|*
name|port_qos
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
operator|&
name|priv
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_vport_qos_param
name|vpp_qos
index|[
name|MLX4_NUM_UP
index|]
decl_stmt|;
name|port_qos
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qos_ctl
index|[
name|port
index|]
expr_stmt|;
name|memset
argument_list|(
name|vpp_qos
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_vport_qos_param
argument_list|)
operator|*
name|MLX4_NUM_UP
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|>
name|port_qos
operator|->
name|num_of_qos_vfs
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"No availible VPP resources for this VF\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Query for default QoS values from Vport 0 is needed */
name|err
operator|=
name|mlx4_SET_VPORT_QOS_get
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|vpp_qos
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Failed to query Vport 0 QoS values\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_NUM_UP
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|test_bit
argument_list|(
name|i
argument_list|,
name|port_qos
operator|->
name|priority_bm
argument_list|)
operator|&&
name|max_tx_rate
condition|)
block|{
name|vpp_qos
index|[
name|i
index|]
operator|.
name|max_avg_bw
operator|=
name|max_tx_rate
expr_stmt|;
name|vpp_qos
index|[
name|i
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* if user supplied tx_rate == 0, meaning no rate limit 			 * configuration is required. so we are leaving the 			 * value of max_avg_bw as queried from Vport 0. 			 */
name|vpp_qos
index|[
name|i
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|err
operator|=
name|mlx4_SET_VPORT_QOS_set
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|slave
argument_list|,
name|vpp_qos
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Failed to set Vport %d QoS values\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mlx4_is_vf_vst_and_prio_qos
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|mlx4_vport_state
modifier|*
name|vf_admin
parameter_list|)
block|{
name|struct
name|mlx4_qos_manager
modifier|*
name|info
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_QOS_VPP
operator|)
condition|)
return|return
name|false
return|;
name|info
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qos_ctl
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|vf_admin
operator|->
name|default_vlan
operator|!=
name|MLX4_VGT
operator|&&
name|test_bit
argument_list|(
name|vf_admin
operator|->
name|default_qos
argument_list|,
name|info
operator|->
name|priority_bm
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mlx4_valid_vf_state_change
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|mlx4_vport_state
modifier|*
name|vf_admin
parameter_list|,
name|int
name|vlan
parameter_list|,
name|int
name|qos
parameter_list|)
block|{
name|struct
name|mlx4_vport_state
name|dummy_admin
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_vf_vst_and_prio_qos
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|vf_admin
argument_list|)
operator|||
operator|!
name|vf_admin
operator|->
name|tx_rate
condition|)
return|return
name|true
return|;
name|dummy_admin
operator|.
name|default_qos
operator|=
name|qos
expr_stmt|;
name|dummy_admin
operator|.
name|default_vlan
operator|=
name|vlan
expr_stmt|;
comment|/* VF wants to move to other VST state which is valid with current 	 * rate limit. Either differnt default vlan in VST or other 	 * supported QoS priority. Otherwise we don't allow this change when 	 * the TX rate is still configured. 	 */
if|if
condition|(
name|mlx4_is_vf_vst_and_prio_qos
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|dummy_admin
argument_list|)
condition|)
return|return
name|true
return|;
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Cannot change VF state to %s while rate is set\n"
argument_list|,
operator|(
name|vlan
operator|==
name|MLX4_VGT
operator|)
condition|?
literal|"VGT"
else|:
literal|"VST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|!=
name|MLX4_VGT
condition|)
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"VST priority %d not supported for QoS\n"
argument_list|,
name|qos
argument_list|)
expr_stmt|;
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Please set rate to 0 prior to this VF state change\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|int
name|mlx4_set_vf_mac
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|vf
parameter_list|,
name|u64
name|mac
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|s_info
decl_stmt|;
name|int
name|slave
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|EPROTONOSUPPORT
return|;
name|slave
operator|=
name|mlx4_get_slave_indx
argument_list|(
name|dev
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|port
operator|=
name|mlx4_slaves_closest_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|s_info
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|s_info
operator|->
name|mac
operator|=
name|mac
expr_stmt|;
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"default mac on vf %d port %d to %llX will take effect only after vf restart\n"
argument_list|,
name|vf
argument_list|,
name|port
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|s_info
operator|->
name|mac
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_set_vf_mac
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_set_vf_vlan
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|vf
parameter_list|,
name|u16
name|vlan
parameter_list|,
name|u8
name|qos
parameter_list|,
name|__be16
name|proto
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|vf_admin
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|slave_state
decl_stmt|;
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vf_oper
decl_stmt|;
name|int
name|slave
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_VLAN_CONTROL
operator|)
condition|)
return|return
operator|-
name|EPROTONOSUPPORT
return|;
if|if
condition|(
operator|(
name|vlan
operator|>
literal|4095
operator|)
operator|||
operator|(
name|qos
operator|>
literal|7
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|proto
operator|==
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
operator|&&
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SVLAN_BY_QP
operator|)
condition|)
return|return
operator|-
name|EPROTONOSUPPORT
return|;
if|if
condition|(
name|proto
operator|!=
name|htons
argument_list|(
name|ETH_P_8021Q
argument_list|)
operator|&&
name|proto
operator|!=
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|(
name|proto
operator|==
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|vlan
operator|==
literal|0
operator|)
operator|||
operator|(
name|vlan
operator|==
name|MLX4_VGT
operator|)
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|slave
operator|=
name|mlx4_get_slave_indx
argument_list|(
name|dev
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|slave_state
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|proto
operator|==
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
operator|)
operator|&&
operator|(
name|slave_state
operator|->
name|active
operator|)
operator|&&
operator|(
operator|!
name|slave_state
operator|->
name|vst_qinq_supported
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"vf %d does not support VST QinQ mode\n"
argument_list|,
name|vf
argument_list|)
expr_stmt|;
return|return
operator|-
name|EPROTONOSUPPORT
return|;
block|}
name|port
operator|=
name|mlx4_slaves_closest_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|vf_admin
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|vf_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_valid_vf_state_change
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|vf_admin
argument_list|,
name|vlan
argument_list|,
name|qos
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
operator|(
literal|0
operator|==
name|vlan
operator|)
operator|&&
operator|(
literal|0
operator|==
name|qos
operator|)
condition|)
name|vf_admin
operator|->
name|default_vlan
operator|=
name|MLX4_VGT
expr_stmt|;
else|else
name|vf_admin
operator|->
name|default_vlan
operator|=
name|vlan
expr_stmt|;
name|vf_admin
operator|->
name|default_qos
operator|=
name|qos
expr_stmt|;
name|vf_admin
operator|->
name|vlan_proto
operator|=
name|proto
expr_stmt|;
comment|/* If rate was configured prior to VST, we saved the configured rate 	 * in vf_admin->rate and now, if priority supported we enforce the QoS 	 */
if|if
condition|(
name|mlx4_is_vf_vst_and_prio_qos
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|vf_admin
argument_list|)
operator|&&
name|vf_admin
operator|->
name|tx_rate
condition|)
name|vf_admin
operator|->
name|qos_vport
operator|=
name|slave
expr_stmt|;
comment|/* Try to activate new vf state without restart, 	 * this option is not supported while moving to VST QinQ mode. 	 */
if|if
condition|(
operator|(
name|proto
operator|==
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
operator|&&
name|vf_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|!=
name|proto
operator|)
operator|||
name|mlx4_master_immediate_activate_vlan_qos
argument_list|(
name|priv
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
condition|)
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"updating vf %d port %d config will take effect on next VF restart\n"
argument_list|,
name|vf
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_set_vf_vlan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_set_vf_rate
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|vf
parameter_list|,
name|int
name|min_tx_rate
parameter_list|,
name|int
name|max_tx_rate
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|slave
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|vf_admin
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_QOS_VPP
operator|)
condition|)
return|return
operator|-
name|EPROTONOSUPPORT
return|;
if|if
condition|(
name|min_tx_rate
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Minimum BW share not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EPROTONOSUPPORT
return|;
block|}
name|slave
operator|=
name|mlx4_get_slave_indx
argument_list|(
name|dev
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|port
operator|=
name|mlx4_slaves_closest_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|vf_admin
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_set_vport_qos
argument_list|(
name|priv
argument_list|,
name|slave
argument_list|,
name|port
argument_list|,
name|max_tx_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"vf %d failed to set rate %d\n"
argument_list|,
name|vf
argument_list|,
name|max_tx_rate
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|vf_admin
operator|->
name|tx_rate
operator|=
name|max_tx_rate
expr_stmt|;
comment|/* if VF is not in supported mode (VST with supported prio), 	 * we do not change vport configuration for its QPs, but save 	 * the rate, so it will be enforced when it moves to supported 	 * mode next time. 	 */
if|if
condition|(
operator|!
name|mlx4_is_vf_vst_and_prio_qos
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|vf_admin
argument_list|)
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"rate set for VF %d when not in valid state\n"
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf_admin
operator|->
name|default_vlan
operator|!=
name|MLX4_VGT
condition|)
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"VST priority not supported by QoS\n"
argument_list|)
expr_stmt|;
else|else
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"VF in VGT mode (needed VST)\n"
argument_list|)
expr_stmt|;
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"rate %d take affect when VF moves to valid state\n"
argument_list|,
name|max_tx_rate
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If user sets rate 0 assigning default vport for its QPs */
name|vf_admin
operator|->
name|qos_vport
operator|=
name|max_tx_rate
condition|?
name|slave
else|:
name|MLX4_VPP_DEFAULT_VPORT
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|active
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_UPDATE_QP
condition|)
name|mlx4_master_immediate_activate_vlan_qos
argument_list|(
name|priv
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_set_vf_rate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* mlx4_get_slave_default_vlan -  * return true if VST ( default vlan)  * if VST, will return vlan& qos (if not NULL)  */
end_comment

begin_function
name|bool
name|mlx4_get_slave_default_vlan
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|slave
parameter_list|,
name|u16
modifier|*
name|vlan
parameter_list|,
name|u8
modifier|*
name|qos
parameter_list|)
block|{
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
decl_stmt|;
name|priv
operator|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|port
operator|=
name|mlx4_slaves_closest_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|MLX4_VGT
operator|!=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
condition|)
block|{
if|if
condition|(
name|vlan
condition|)
operator|*
name|vlan
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
expr_stmt|;
if|if
condition|(
name|qos
condition|)
operator|*
name|qos
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_slave_default_vlan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_set_vf_spoofchk
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|vf
parameter_list|,
name|bool
name|setting
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|s_info
decl_stmt|;
name|int
name|slave
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_FSM
operator|)
condition|)
return|return
operator|-
name|EPROTONOSUPPORT
return|;
name|slave
operator|=
name|mlx4_get_slave_indx
argument_list|(
name|dev
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|port
operator|=
name|mlx4_slaves_closest_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|s_info
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|s_info
operator|->
name|spoofchk
operator|=
name|setting
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_set_vf_spoofchk
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_get_counter_stats
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|counter_index
parameter_list|,
name|struct
name|mlx4_counter
modifier|*
name|counter_stats
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_counter
modifier|*
name|tmp_counter
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|if_stat_in_mod
decl_stmt|;
if|if
condition|(
operator|!
name|counter_stats
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|counter_index
operator|==
name|MLX4_SINK_COUNTER_INDEX
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|memset
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_counter
argument_list|)
argument_list|)
expr_stmt|;
name|if_stat_in_mod
operator|=
name|counter_index
expr_stmt|;
if|if
condition|(
name|reset
condition|)
name|if_stat_in_mod
operator||=
name|MLX4_QUERY_IF_STAT_RESET
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|if_stat_in_mod
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_IF_STAT
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: failed to read statistics for counter index %d\n"
argument_list|,
name|__func__
argument_list|,
name|counter_index
argument_list|)
expr_stmt|;
goto|goto
name|if_stat_out
goto|;
block|}
name|tmp_counter
operator|=
operator|(
expr|struct
name|mlx4_counter
operator|*
operator|)
name|mailbox
operator|->
name|buf
expr_stmt|;
name|counter_stats
operator|->
name|counter_mode
operator|=
name|tmp_counter
operator|->
name|counter_mode
expr_stmt|;
if|if
condition|(
name|counter_stats
operator|->
name|counter_mode
operator|==
literal|0
condition|)
block|{
name|counter_stats
operator|->
name|rx_frames
operator|=
name|cpu_to_be64
argument_list|(
name|be64_to_cpu
argument_list|(
name|counter_stats
operator|->
name|rx_frames
argument_list|)
operator|+
name|be64_to_cpu
argument_list|(
name|tmp_counter
operator|->
name|rx_frames
argument_list|)
argument_list|)
expr_stmt|;
name|counter_stats
operator|->
name|tx_frames
operator|=
name|cpu_to_be64
argument_list|(
name|be64_to_cpu
argument_list|(
name|counter_stats
operator|->
name|tx_frames
argument_list|)
operator|+
name|be64_to_cpu
argument_list|(
name|tmp_counter
operator|->
name|tx_frames
argument_list|)
argument_list|)
expr_stmt|;
name|counter_stats
operator|->
name|rx_bytes
operator|=
name|cpu_to_be64
argument_list|(
name|be64_to_cpu
argument_list|(
name|counter_stats
operator|->
name|rx_bytes
argument_list|)
operator|+
name|be64_to_cpu
argument_list|(
name|tmp_counter
operator|->
name|rx_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|counter_stats
operator|->
name|tx_bytes
operator|=
name|cpu_to_be64
argument_list|(
name|be64_to_cpu
argument_list|(
name|counter_stats
operator|->
name|tx_bytes
argument_list|)
operator|+
name|be64_to_cpu
argument_list|(
name|tmp_counter
operator|->
name|tx_bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|if_stat_out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_counter_stats
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_vf_smi_enabled
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|slave
operator|<
literal|1
operator|||
name|slave
operator|>=
name|dev
operator|->
name|num_slaves
operator|||
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|MLX4_MAX_PORTS
condition|)
return|return
literal|0
return|;
return|return
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|smi_enabled
index|[
name|port
index|]
operator|==
name|MLX4_VF_SMI_ENABLED
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_vf_smi_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_vf_get_enable_smi_admin
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|slave
operator|<
literal|1
operator|||
name|slave
operator|>=
name|dev
operator|->
name|num_slaves
operator|||
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|MLX4_MAX_PORTS
condition|)
return|return
literal|0
return|;
return|return
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|enable_smi
index|[
name|port
index|]
operator|==
name|MLX4_VF_SMI_ENABLED
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_vf_get_enable_smi_admin
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_vf_set_enable_smi_admin
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
name|int
name|min_port
init|=
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|priv
operator|->
name|dev
operator|.
name|caps
operator|.
name|num_ports
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|max_port
init|=
name|min_port
operator|-
literal|1
operator|+
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|priv
operator|->
name|dev
operator|.
name|caps
operator|.
name|num_ports
argument_list|)
decl_stmt|;
if|if
condition|(
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|slave
operator|<
literal|1
operator|||
name|slave
operator|>=
name|dev
operator|->
name|num_slaves
operator|||
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|MLX4_MAX_PORTS
operator|||
name|enabled
operator|<
literal|0
operator|||
name|enabled
operator|>
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|min_port
operator|==
name|max_port
operator|&&
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|>
literal|1
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"SMI access disallowed for single ported VFs\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EPROTONOSUPPORT
return|;
block|}
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|enable_smi
index|[
name|port
index|]
operator|=
name|enabled
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_vf_set_enable_smi_admin
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

