begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008, 2014 Mellanox Technologies. All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|LINUXKPI_PARAM_PREFIX
value|mlx4_
end_define

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/cache.h>
end_include

begin_include
include|#
directive|include
file|<net/ipv6.h>
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_enum
enum|enum
block|{
name|MLX4_COMMAND_INTERFACE_MIN_REV
init|=
literal|2
block|,
name|MLX4_COMMAND_INTERFACE_MAX_REV
init|=
literal|3
block|,
name|MLX4_COMMAND_INTERFACE_NEW_PORT_CMDS
init|=
literal|3
block|, }
enum|;
end_enum

begin_function_decl
specifier|extern
name|void
name|__buggy_use_of_MLX4_GET
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__buggy_use_of_MLX4_PUT
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bool
name|enable_qos
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|enable_qos
argument_list|,
name|bool
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_qos
argument_list|,
literal|"Enable Enhanced QoS support (default: off)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MLX4_GET
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|offset
parameter_list|)
define|\
value|do {							      \ 		void *__p = (char *) (source) + (offset);	      \ 		typedef struct { u64 value; } __packed u64_p_t;	      \ 		u64 val;                                              \ 		switch (sizeof (dest)) {			      \ 		case 1: (dest) = *(u8 *) __p;	    break;	      \ 		case 2: (dest) = be16_to_cpup(__p); break;	      \ 		case 4: (dest) = be32_to_cpup(__p); break;	      \ 		case 8: val = ((u64_p_t *)__p)->value;                \ 			(dest) = be64_to_cpu(val);  break;            \ 		default: __buggy_use_of_MLX4_GET();		      \ 		}						      \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|MLX4_PUT
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|offset
parameter_list|)
define|\
value|do {							      \ 		void *__d = ((char *) (dest) + (offset));	      \ 		switch (sizeof(source)) {			      \ 		case 1: *(u8 *) __d = (source);		       break; \ 		case 2:	*(__be16 *) __d = cpu_to_be16(source); break; \ 		case 4:	*(__be32 *) __d = cpu_to_be32(source); break; \ 		case 8:	*(__be64 *) __d = cpu_to_be64(source); break; \ 		default: __buggy_use_of_MLX4_PUT();		      \ 		}						      \ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|dump_dev_cap_flags
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|flags
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|fname
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
literal|"RC transport"
block|,
index|[
literal|1
index|]
operator|=
literal|"UC transport"
block|,
index|[
literal|2
index|]
operator|=
literal|"UD transport"
block|,
index|[
literal|3
index|]
operator|=
literal|"XRC transport"
block|,
index|[
literal|6
index|]
operator|=
literal|"SRQ support"
block|,
index|[
literal|7
index|]
operator|=
literal|"IPoIB checksum offload"
block|,
index|[
literal|8
index|]
operator|=
literal|"P_Key violation counter"
block|,
index|[
literal|9
index|]
operator|=
literal|"Q_Key violation counter"
block|,
index|[
literal|12
index|]
operator|=
literal|"Dual Port Different Protocol (DPDP) support"
block|,
index|[
literal|15
index|]
operator|=
literal|"Big LSO headers"
block|,
index|[
literal|16
index|]
operator|=
literal|"MW support"
block|,
index|[
literal|17
index|]
operator|=
literal|"APM support"
block|,
index|[
literal|18
index|]
operator|=
literal|"Atomic ops support"
block|,
index|[
literal|19
index|]
operator|=
literal|"Raw multicast support"
block|,
index|[
literal|20
index|]
operator|=
literal|"Address vector port checking support"
block|,
index|[
literal|21
index|]
operator|=
literal|"UD multicast support"
block|,
index|[
literal|30
index|]
operator|=
literal|"IBoE support"
block|,
index|[
literal|32
index|]
operator|=
literal|"Unicast loopback support"
block|,
index|[
literal|34
index|]
operator|=
literal|"FCS header control"
block|,
index|[
literal|37
index|]
operator|=
literal|"Wake On LAN (port1) support"
block|,
index|[
literal|38
index|]
operator|=
literal|"Wake On LAN (port2) support"
block|,
index|[
literal|40
index|]
operator|=
literal|"UDP RSS support"
block|,
index|[
literal|41
index|]
operator|=
literal|"Unicast VEP steering support"
block|,
index|[
literal|42
index|]
operator|=
literal|"Multicast VEP steering support"
block|,
index|[
literal|48
index|]
operator|=
literal|"Counters support"
block|,
index|[
literal|52
index|]
operator|=
literal|"RSS IP fragments support"
block|,
index|[
literal|53
index|]
operator|=
literal|"Port ETS Scheduler support"
block|,
index|[
literal|55
index|]
operator|=
literal|"Port link type sensing support"
block|,
index|[
literal|59
index|]
operator|=
literal|"Port management change event support"
block|,
index|[
literal|61
index|]
operator|=
literal|"64 byte EQE support"
block|,
index|[
literal|62
index|]
operator|=
literal|"64 byte CQE support"
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"DEV_CAP flags:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|fname
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fname
index|[
name|i
index|]
operator|&&
operator|(
name|flags
operator|&
operator|(
literal|1LL
operator|<<
name|i
operator|)
operator|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"    %s\n"
argument_list|,
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dev_cap_flags2
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|flags
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|fname
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
literal|"RSS support"
block|,
index|[
literal|1
index|]
operator|=
literal|"RSS Toeplitz Hash Function support"
block|,
index|[
literal|2
index|]
operator|=
literal|"RSS XOR Hash Function support"
block|,
index|[
literal|3
index|]
operator|=
literal|"Device managed flow steering support"
block|,
index|[
literal|4
index|]
operator|=
literal|"Automatic MAC reassignment support"
block|,
index|[
literal|5
index|]
operator|=
literal|"Time stamping support"
block|,
index|[
literal|6
index|]
operator|=
literal|"VST (control vlan insertion/stripping) support"
block|,
index|[
literal|7
index|]
operator|=
literal|"FSM (MAC anti-spoofing) support"
block|,
index|[
literal|8
index|]
operator|=
literal|"Dynamic QP updates support"
block|,
index|[
literal|9
index|]
operator|=
literal|"Device managed flow steering IPoIB support"
block|,
index|[
literal|10
index|]
operator|=
literal|"TCP/IP offloads/flow-steering for VXLAN support"
block|,
index|[
literal|11
index|]
operator|=
literal|"MAD DEMUX (Secure-Host) support"
block|,
index|[
literal|12
index|]
operator|=
literal|"Large cache line (>64B) CQE stride support"
block|,
index|[
literal|13
index|]
operator|=
literal|"Large cache line (>64B) EQE stride support"
block|,
index|[
literal|14
index|]
operator|=
literal|"Ethernet protocol control support"
block|,
index|[
literal|15
index|]
operator|=
literal|"Ethernet Backplane autoneg support"
block|,
index|[
literal|16
index|]
operator|=
literal|"CONFIG DEV support"
block|,
index|[
literal|17
index|]
operator|=
literal|"Asymmetric EQs support"
block|,
index|[
literal|18
index|]
operator|=
literal|"More than 80 VFs support"
block|,
index|[
literal|19
index|]
operator|=
literal|"Performance optimized for limited rule configuration flow steering support"
block|,
index|[
literal|20
index|]
operator|=
literal|"Recoverable error events support"
block|,
index|[
literal|21
index|]
operator|=
literal|"Port Remap support"
block|,
index|[
literal|22
index|]
operator|=
literal|"QCN support"
block|,
index|[
literal|23
index|]
operator|=
literal|"QP rate limiting support"
block|,
index|[
literal|24
index|]
operator|=
literal|"Ethernet Flow control statistics support"
block|,
index|[
literal|25
index|]
operator|=
literal|"Granular QoS per VF support"
block|,
index|[
literal|26
index|]
operator|=
literal|"Port ETS Scheduler support"
block|,
index|[
literal|27
index|]
operator|=
literal|"Port beacon support"
block|,
index|[
literal|28
index|]
operator|=
literal|"RX-ALL support"
block|,
index|[
literal|29
index|]
operator|=
literal|"802.1ad offload support"
block|,
index|[
literal|31
index|]
operator|=
literal|"Modifying loopback source checks using UPDATE_QP support"
block|,
index|[
literal|32
index|]
operator|=
literal|"Loopback source checks support"
block|,
index|[
literal|33
index|]
operator|=
literal|"RoCEv2 support"
block|,
index|[
literal|34
index|]
operator|=
literal|"DMFS Sniffer support (UC& MC)"
block|,
index|[
literal|35
index|]
operator|=
literal|"QinQ VST mode support"
block|,
index|[
literal|36
index|]
operator|=
literal|"sl to vl mapping table change event support"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|fname
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fname
index|[
name|i
index|]
operator|&&
operator|(
name|flags
operator|&
operator|(
literal|1LL
operator|<<
name|i
operator|)
operator|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"    %s\n"
argument_list|,
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_MOD_STAT_CFG
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_mod_stat_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MOD_STAT_CFG_IN_SIZE
value|0x100
define|#
directive|define
name|MOD_STAT_CFG_PG_SZ_M_OFFSET
value|0x002
define|#
directive|define
name|MOD_STAT_CFG_PG_SZ_OFFSET
value|0x003
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|cfg
operator|->
name|log_pg_sz
argument_list|,
name|MOD_STAT_CFG_PG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|cfg
operator|->
name|log_pg_sz_m
argument_list|,
name|MOD_STAT_CFG_PG_SZ_M_OFFSET
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FUNC
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_func
modifier|*
name|func
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|in_modifier
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|u16
name|field16
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|QUERY_FUNC_BUS_OFFSET
value|0x00
define|#
directive|define
name|QUERY_FUNC_DEVICE_OFFSET
value|0x01
define|#
directive|define
name|QUERY_FUNC_FUNCTION_OFFSET
value|0x01
define|#
directive|define
name|QUERY_FUNC_PHYSICAL_FUNCTION_OFFSET
value|0x03
define|#
directive|define
name|QUERY_FUNC_RSVD_EQS_OFFSET
value|0x04
define|#
directive|define
name|QUERY_FUNC_MAX_EQ_OFFSET
value|0x06
define|#
directive|define
name|QUERY_FUNC_RSVD_UARS_OFFSET
value|0x0b
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|in_modifier
operator|=
name|slave
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_modifier
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_FUNC
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_BUS_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|bus
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_DEVICE_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|device
operator|=
name|field
operator|&
literal|0xf1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_FUNCTION_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|function
operator|=
name|field
operator|&
literal|0x7
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_PHYSICAL_FUNCTION_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|physical_function
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field16
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_RSVD_EQS_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|rsvd_eqs
operator|=
name|field16
operator|&
literal|0xffff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field16
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|max_eq
operator|=
name|field16
operator|&
literal|0xffff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_RSVD_UARS_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|rsvd_uars
operator|=
name|field
operator|&
literal|0x0f
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Bus: %d, Device: %d, Function: %d, Physical function: %d, Max EQs: %d, Reserved EQs: %d, Reserved UARs: %d\n"
argument_list|,
name|func
operator|->
name|bus
argument_list|,
name|func
operator|->
name|device
argument_list|,
name|func
operator|->
name|function
argument_list|,
name|func
operator|->
name|physical_function
argument_list|,
name|func
operator|->
name|max_eq
argument_list|,
name|func
operator|->
name|rsvd_eqs
argument_list|,
name|func
operator|->
name|rsvd_uars
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_activate_vst_qinq
parameter_list|(
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|vp_admin
decl_stmt|;
name|int
name|err
decl_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|vp_admin
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|vp_admin
operator|->
name|default_vlan
operator|!=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
condition|)
block|{
name|err
operator|=
name|__mlx4_register_vlan
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vp_admin
operator|->
name|default_vlan
argument_list|,
operator|&
name|vp_oper
operator|->
name|vlan_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|vp_oper
operator|->
name|vlan_idx
operator|=
name|NO_INDX
expr_stmt|;
name|mlx4_warn
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"No vlan resources slave %d, port %d\n"
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"alloc vlan %d idx  %d slave %d port %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
argument_list|)
argument_list|,
name|vp_oper
operator|->
name|vlan_idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|=
name|vp_admin
operator|->
name|vlan_proto
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
operator|=
name|vp_admin
operator|->
name|default_vlan
expr_stmt|;
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
operator|=
name|vp_admin
operator|->
name|default_qos
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_handle_vst_qinq
parameter_list|(
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|slave_state
decl_stmt|;
name|struct
name|mlx4_vport_state
modifier|*
name|vp_admin
decl_stmt|;
name|int
name|err
decl_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|vp_admin
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|slave_state
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|vp_admin
operator|->
name|vlan_proto
operator|!=
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|slave_state
operator|->
name|active
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|==
name|vp_admin
operator|->
name|vlan_proto
operator|&&
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
operator|==
name|vp_admin
operator|->
name|default_vlan
operator|&&
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
operator|==
name|vp_admin
operator|->
name|default_qos
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|slave_state
operator|->
name|vst_qinq_supported
condition|)
block|{
comment|/* Warn and revert the request to set vst QinQ mode */
name|vp_admin
operator|->
name|vlan_proto
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
expr_stmt|;
name|vp_admin
operator|->
name|default_vlan
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|default_vlan
expr_stmt|;
name|vp_admin
operator|->
name|default_qos
operator|=
name|vp_oper
operator|->
name|state
operator|.
name|default_qos
expr_stmt|;
name|mlx4_warn
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|,
literal|"Slave %d does not support VST QinQ mode\n"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|err
operator|=
name|mlx4_activate_vst_qinq
argument_list|(
name|priv
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FUNC_CAP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u8
name|field
decl_stmt|,
name|port
decl_stmt|;
name|u32
name|size
decl_stmt|,
name|proxy_qp
decl_stmt|,
name|qkey
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_func
name|func
decl_stmt|;
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS_OFFSET
value|0x0
define|#
directive|define
name|QUERY_FUNC_CAP_NUM_PORTS_OFFSET
value|0x1
define|#
directive|define
name|QUERY_FUNC_CAP_PF_BHVR_OFFSET
value|0x4
define|#
directive|define
name|QUERY_FUNC_CAP_FMR_OFFSET
value|0x8
define|#
directive|define
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET_DEP
value|0x10
define|#
directive|define
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET_DEP
value|0x14
define|#
directive|define
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET_DEP
value|0x18
define|#
directive|define
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET_DEP
value|0x20
define|#
directive|define
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET_DEP
value|0x24
define|#
directive|define
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET_DEP
value|0x28
define|#
directive|define
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
value|0x2c
define|#
directive|define
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
value|0x30
define|#
directive|define
name|QUERY_FUNC_CAP_QP_RESD_LKEY_OFFSET
value|0x48
define|#
directive|define
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET
value|0x50
define|#
directive|define
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET
value|0x54
define|#
directive|define
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET
value|0x58
define|#
directive|define
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET
value|0x60
define|#
directive|define
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET
value|0x64
define|#
directive|define
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET
value|0x68
define|#
directive|define
name|QUERY_FUNC_CAP_EXTRA_FLAGS_OFFSET
value|0x6c
define|#
directive|define
name|QUERY_FUNC_CAP_FMR_FLAG
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_RDMA
value|0x40
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_ETH
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_QUOTAS
value|0x10
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_RESD_LKEY
value|0x08
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_VALID_MAILBOX
value|0x04
define|#
directive|define
name|QUERY_FUNC_CAP_EXTRA_FLAGS_BF_QP_ALLOC_FLAG
value|(1UL<< 31)
define|#
directive|define
name|QUERY_FUNC_CAP_EXTRA_FLAGS_A0_QP_ALLOC_FLAG
value|(1UL<< 30)
comment|/* when opcode modifier = 1 */
define|#
directive|define
name|QUERY_FUNC_CAP_PHYS_PORT_OFFSET
value|0x3
define|#
directive|define
name|QUERY_FUNC_CAP_PRIV_VF_QKEY_OFFSET
value|0x4
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS0_OFFSET
value|0x8
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS1_OFFSET
value|0xc
define|#
directive|define
name|QUERY_FUNC_CAP_QP0_TUNNEL
value|0x10
define|#
directive|define
name|QUERY_FUNC_CAP_QP0_PROXY
value|0x14
define|#
directive|define
name|QUERY_FUNC_CAP_QP1_TUNNEL
value|0x18
define|#
directive|define
name|QUERY_FUNC_CAP_QP1_PROXY
value|0x1c
define|#
directive|define
name|QUERY_FUNC_CAP_PHYS_PORT_ID
value|0x28
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS1_FORCE_MAC
value|0x40
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS1_FORCE_VLAN
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS1_NIC_INFO
value|0x10
define|#
directive|define
name|QUERY_FUNC_CAP_VF_ENABLE_QP0
value|0x08
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS0_FORCE_PHY_WQE_GID
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_PHV_BIT
value|0x40
define|#
directive|define
name|QUERY_FUNC_CAP_VLAN_OFFLOAD_DISABLE
value|0x20
define|#
directive|define
name|QUERY_FUNC_CAP_SUPPORTS_VST_QINQ
value|BIT(30)
define|#
directive|define
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
value|BIT(31)
if|if
condition|(
name|vhcr
operator|->
name|op_modifier
operator|==
literal|1
condition|)
block|{
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
name|int
name|converted_port
init|=
name|mlx4_slave_convert_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|)
decl_stmt|;
name|struct
name|mlx4_vport_oper_state
modifier|*
name|vp_oper
decl_stmt|;
if|if
condition|(
name|converted_port
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|vhcr
operator|->
name|in_modifier
operator|=
name|converted_port
expr_stmt|;
comment|/* phys-port = logical-port */
name|field
operator|=
name|vhcr
operator|->
name|in_modifier
operator|-
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_PHYS_PORT_OFFSET
argument_list|)
expr_stmt|;
name|port
operator|=
name|vhcr
operator|->
name|in_modifier
expr_stmt|;
name|proxy_qp
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
operator|+
literal|8
operator|*
name|slave
operator|+
name|port
operator|-
literal|1
expr_stmt|;
comment|/* Set nic_info bit to mark new fields support */
name|field
operator|=
name|QUERY_FUNC_CAP_FLAGS1_NIC_INFO
expr_stmt|;
if|if
condition|(
name|mlx4_vf_smi_enabled
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
operator|&&
operator|!
name|mlx4_get_parav_qkey
argument_list|(
name|dev
argument_list|,
name|proxy_qp
argument_list|,
operator|&
name|qkey
argument_list|)
condition|)
block|{
name|field
operator||=
name|QUERY_FUNC_CAP_VF_ENABLE_QP0
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|qkey
argument_list|,
name|QUERY_FUNC_CAP_PRIV_VF_QKEY_OFFSET
argument_list|)
expr_stmt|;
block|}
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FLAGS1_OFFSET
argument_list|)
expr_stmt|;
comment|/* size is now the QP number */
name|size
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|+
literal|8
operator|*
name|slave
operator|+
name|port
operator|-
literal|1
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP0_TUNNEL
argument_list|)
expr_stmt|;
name|size
operator|+=
literal|2
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP1_TUNNEL
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|proxy_qp
argument_list|,
name|QUERY_FUNC_CAP_QP0_PROXY
argument_list|)
expr_stmt|;
name|proxy_qp
operator|+=
literal|2
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|proxy_qp
argument_list|,
name|QUERY_FUNC_CAP_QP1_PROXY
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|phys_port_id
index|[
name|vhcr
operator|->
name|in_modifier
index|]
argument_list|,
name|QUERY_FUNC_CAP_PHYS_PORT_ID
argument_list|)
expr_stmt|;
name|vp_oper
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|port
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_handle_vst_qinq
argument_list|(
name|priv
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|field
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|phv_bit
index|[
name|port
index|]
condition|)
name|field
operator||=
name|QUERY_FUNC_CAP_PHV_BIT
expr_stmt|;
if|if
condition|(
name|vp_oper
operator|->
name|state
operator|.
name|vlan_proto
operator|==
name|htons
argument_list|(
name|ETH_P_8021AD
argument_list|)
condition|)
name|field
operator||=
name|QUERY_FUNC_CAP_VLAN_OFFLOAD_DISABLE
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FLAGS0_OFFSET
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vhcr
operator|->
name|op_modifier
operator|==
literal|0
condition|)
block|{
name|struct
name|mlx4_active_ports
name|actv_ports
init|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|slave_state
init|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
decl_stmt|;
comment|/* enable rdma and ethernet interfaces, new quota locations, 		 * and reserved lkey 		 */
name|field
operator|=
operator|(
name|QUERY_FUNC_CAP_FLAG_ETH
operator||
name|QUERY_FUNC_CAP_FLAG_RDMA
operator||
name|QUERY_FUNC_CAP_FLAG_QUOTAS
operator||
name|QUERY_FUNC_CAP_FLAG_VALID_MAILBOX
operator||
name|QUERY_FUNC_CAP_FLAG_RESD_LKEY
operator|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|min
argument_list|(
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_NUM_PORTS_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|function_caps
expr_stmt|;
comment|/* set PF behaviours */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_PF_BHVR_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
literal|0
expr_stmt|;
comment|/* protected FMR support not available as yet */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FMR_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_QP
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_qps
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_SRQ
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_srqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_CQ
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_cqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
operator|)
operator|||
name|mlx4_QUERY_FUNC
argument_list|(
name|dev
argument_list|,
operator|&
name|func
argument_list|,
name|slave
argument_list|)
condition|)
block|{
name|size
operator|=
name|vhcr
operator|->
name|in_modifier
operator|&
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
condition|?
name|dev
operator|->
name|caps
operator|.
name|num_eqs
else|:
name|rounddown_pow_of_two
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_eqs
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|vhcr
operator|->
name|in_modifier
operator|&
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
condition|?
name|func
operator|.
name|max_eq
else|:
name|rounddown_pow_of_two
argument_list|(
name|func
operator|.
name|max_eq
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|func
operator|.
name|rsvd_eqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_MPT
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mpts
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_MTT
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mtts
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|QUERY_FUNC_CAP_EXTRA_FLAGS_BF_QP_ALLOC_FLAG
operator||
name|QUERY_FUNC_CAP_EXTRA_FLAGS_A0_QP_ALLOC_FLAG
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_EXTRA_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_lkey
operator|+
operator|(
operator|(
name|slave
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP_RESD_LKEY_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhcr
operator|->
name|in_modifier
operator|&
name|QUERY_FUNC_CAP_SUPPORTS_VST_QINQ
condition|)
name|slave_state
operator|->
name|vst_qinq_supported
operator|=
name|true
expr_stmt|;
block|}
else|else
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FUNC_CAP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|gen_or_port
parameter_list|,
name|struct
name|mlx4_func_cap
modifier|*
name|func_cap
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|field
decl_stmt|,
name|op_modifier
decl_stmt|;
name|u32
name|size
decl_stmt|,
name|qkey
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|quotas
init|=
literal|0
decl_stmt|;
name|u32
name|in_modifier
decl_stmt|;
name|u32
name|slave_caps
decl_stmt|;
name|op_modifier
operator|=
operator|!
operator|!
name|gen_or_port
expr_stmt|;
comment|/* 0 = general, 1 = logical port */
name|slave_caps
operator|=
name|QUERY_FUNC_CAP_SUPPORTS_VST_QINQ
operator||
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
expr_stmt|;
name|in_modifier
operator|=
name|op_modifier
condition|?
name|gen_or_port
else|:
name|slave_caps
expr_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|MLX4_CMD_QUERY_FUNC_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|op_modifier
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|field
operator|&
operator|(
name|QUERY_FUNC_CAP_FLAG_ETH
operator||
name|QUERY_FUNC_CAP_FLAG_RDMA
operator|)
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"The host supports neither eth nor rdma interfaces\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|func_cap
operator|->
name|flags
operator|=
name|field
expr_stmt|;
name|quotas
operator|=
operator|!
operator|!
operator|(
name|func_cap
operator|->
name|flags
operator|&
name|QUERY_FUNC_CAP_FLAG_QUOTAS
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_NUM_PORTS_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|num_ports
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_PF_BHVR_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|pf_context_behaviour
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|quotas
condition|)
block|{
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|srq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|cq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mpt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mtt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mcg_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
block|}
else|else
block|{
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|srq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|cq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mpt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mtt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mcg_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|max_eq
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|reserved_eq
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
if|if
condition|(
name|func_cap
operator|->
name|flags
operator|&
name|QUERY_FUNC_CAP_FLAG_RESD_LKEY
condition|)
block|{
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP_RESD_LKEY_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|reserved_lkey
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|func_cap
operator|->
name|reserved_lkey
operator|=
literal|0
expr_stmt|;
block|}
name|func_cap
operator|->
name|extra_flags
operator|=
literal|0
expr_stmt|;
comment|/* Mailbox data from 0x6c and onward should only be treated if 		 * QUERY_FUNC_CAP_FLAG_VALID_MAILBOX is set in func_cap->flags 		 */
if|if
condition|(
name|func_cap
operator|->
name|flags
operator|&
name|QUERY_FUNC_CAP_FLAG_VALID_MAILBOX
condition|)
block|{
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_EXTRA_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&
name|QUERY_FUNC_CAP_EXTRA_FLAGS_BF_QP_ALLOC_FLAG
condition|)
name|func_cap
operator|->
name|extra_flags
operator||=
name|MLX4_QUERY_FUNC_FLAGS_BF_RES_QP
expr_stmt|;
if|if
condition|(
name|size
operator|&
name|QUERY_FUNC_CAP_EXTRA_FLAGS_A0_QP_ALLOC_FLAG
condition|)
name|func_cap
operator|->
name|extra_flags
operator||=
name|MLX4_QUERY_FUNC_FLAGS_A0_RES_QP
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* logical port query */
if|if
condition|(
name|gen_or_port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MLX4_GET
argument_list|(
name|func_cap
operator|->
name|flags1
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS1_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|gen_or_port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
block|{
if|if
condition|(
name|func_cap
operator|->
name|flags1
operator|&
name|QUERY_FUNC_CAP_FLAGS1_FORCE_VLAN
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"VLAN is enforced on this port\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|func_cap
operator|->
name|flags1
operator|&
name|QUERY_FUNC_CAP_FLAGS1_FORCE_MAC
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Force mac is enabled on this port\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|gen_or_port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS0_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
name|QUERY_FUNC_CAP_FLAGS0_FORCE_PHY_WQE_GID
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"phy_wqe_gid is enforced on this ib port\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_PHYS_PORT_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|physical_port
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|func_cap
operator|->
name|physical_port
operator|!=
name|gen_or_port
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|func_cap
operator|->
name|flags1
operator|&
name|QUERY_FUNC_CAP_VF_ENABLE_QP0
condition|)
block|{
name|MLX4_GET
argument_list|(
name|qkey
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_PRIV_VF_QKEY_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp0_qkey
operator|=
name|qkey
expr_stmt|;
block|}
else|else
block|{
name|func_cap
operator|->
name|qp0_qkey
operator|=
literal|0
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP0_TUNNEL
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp0_tunnel_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP0_PROXY
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp0_proxy_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP1_TUNNEL
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp1_tunnel_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP1_PROXY
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp1_proxy_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
if|if
condition|(
name|func_cap
operator|->
name|flags1
operator|&
name|QUERY_FUNC_CAP_FLAGS1_NIC_INFO
condition|)
name|MLX4_GET
argument_list|(
name|func_cap
operator|->
name|phys_port_id
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_PHYS_PORT_ID
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|func_cap
operator|->
name|flags0
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS0_OFFSET
argument_list|)
expr_stmt|;
comment|/* All other resources are allocated by the master, but we still report 	 * 'num' and 'reserved' capabilities as follows: 	 * - num remains the maximum resource index 	 * - 'num - reserved' is the total available objects of a resource, but 	 *   resource indices may be less than 'reserved' 	 * TODO: set per-resource quotas */
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|disable_unsupported_roce_caps
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|mlx4_QUERY_DEV_CAP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|u32
name|field32
decl_stmt|,
name|flags
decl_stmt|,
name|ext_flags
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|u16
name|stat_rate
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|QUERY_DEV_CAP_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SRQ_SZ_OFFSET
value|0x10
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_SZ_OFFSET
value|0x11
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_QP_OFFSET
value|0x12
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_OFFSET
value|0x13
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_SRQ_OFFSET
value|0x14
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SRQ_OFFSET
value|0x15
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_EEC_OFFSET
value|0x16
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EEC_OFFSET
value|0x17
define|#
directive|define
name|QUERY_DEV_CAP_MAX_CQ_SZ_OFFSET
value|0x19
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_CQ_OFFSET
value|0x1a
define|#
directive|define
name|QUERY_DEV_CAP_MAX_CQ_OFFSET
value|0x1b
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MPT_OFFSET
value|0x1d
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_EQ_OFFSET
value|0x1e
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EQ_OFFSET
value|0x1f
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MTT_OFFSET
value|0x20
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MRW_SZ_OFFSET
value|0x21
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MRW_OFFSET
value|0x22
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MTT_SEG_OFFSET
value|0x23
define|#
directive|define
name|QUERY_DEV_CAP_NUM_SYS_EQ_OFFSET
value|0x26
define|#
directive|define
name|QUERY_DEV_CAP_MAX_AV_OFFSET
value|0x27
define|#
directive|define
name|QUERY_DEV_CAP_MAX_REQ_QP_OFFSET
value|0x29
define|#
directive|define
name|QUERY_DEV_CAP_MAX_RES_QP_OFFSET
value|0x2b
define|#
directive|define
name|QUERY_DEV_CAP_MAX_GSO_OFFSET
value|0x2d
define|#
directive|define
name|QUERY_DEV_CAP_RSS_OFFSET
value|0x2e
define|#
directive|define
name|QUERY_DEV_CAP_MAX_RDMA_OFFSET
value|0x2f
define|#
directive|define
name|QUERY_DEV_CAP_RSZ_SRQ_OFFSET
value|0x33
define|#
directive|define
name|QUERY_DEV_CAP_PORT_BEACON_OFFSET
value|0x34
define|#
directive|define
name|QUERY_DEV_CAP_ACK_DELAY_OFFSET
value|0x35
define|#
directive|define
name|QUERY_DEV_CAP_MTU_WIDTH_OFFSET
value|0x36
define|#
directive|define
name|QUERY_DEV_CAP_VL_PORT_OFFSET
value|0x37
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MSG_SZ_OFFSET
value|0x38
define|#
directive|define
name|QUERY_DEV_CAP_MAX_GID_OFFSET
value|0x3b
define|#
directive|define
name|QUERY_DEV_CAP_RATE_SUPPORT_OFFSET
value|0x3c
define|#
directive|define
name|QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET
value|0x3e
define|#
directive|define
name|QUERY_DEV_CAP_MAX_PKEY_OFFSET
value|0x3f
define|#
directive|define
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
value|0x40
define|#
directive|define
name|QUERY_DEV_CAP_FLAGS_OFFSET
value|0x44
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_UAR_OFFSET
value|0x48
define|#
directive|define
name|QUERY_DEV_CAP_UAR_SZ_OFFSET
value|0x49
define|#
directive|define
name|QUERY_DEV_CAP_PAGE_SZ_OFFSET
value|0x4b
define|#
directive|define
name|QUERY_DEV_CAP_BF_OFFSET
value|0x4c
define|#
directive|define
name|QUERY_DEV_CAP_LOG_BF_REG_SZ_OFFSET
value|0x4d
define|#
directive|define
name|QUERY_DEV_CAP_LOG_MAX_BF_REGS_PER_PAGE_OFFSET
value|0x4e
define|#
directive|define
name|QUERY_DEV_CAP_LOG_MAX_BF_PAGES_OFFSET
value|0x4f
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SG_SQ_OFFSET
value|0x51
define|#
directive|define
name|QUERY_DEV_CAP_MAX_DESC_SZ_SQ_OFFSET
value|0x52
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SG_RQ_OFFSET
value|0x55
define|#
directive|define
name|QUERY_DEV_CAP_MAX_DESC_SZ_RQ_OFFSET
value|0x56
define|#
directive|define
name|QUERY_DEV_CAP_SVLAN_BY_QP_OFFSET
value|0x5D
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_MCG_OFFSET
value|0x61
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MCG_OFFSET
value|0x62
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MCG_OFFSET
value|0x63
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_PD_OFFSET
value|0x64
define|#
directive|define
name|QUERY_DEV_CAP_MAX_PD_OFFSET
value|0x65
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_XRC_OFFSET
value|0x66
define|#
directive|define
name|QUERY_DEV_CAP_MAX_XRC_OFFSET
value|0x67
define|#
directive|define
name|QUERY_DEV_CAP_MAX_COUNTERS_OFFSET
value|0x68
define|#
directive|define
name|QUERY_DEV_CAP_PORT_FLOWSTATS_COUNTERS_OFFSET
value|0x70
define|#
directive|define
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
value|0x70
define|#
directive|define
name|QUERY_DEV_CAP_FLOW_STEERING_IPOIB_OFFSET
value|0x74
define|#
directive|define
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
value|0x76
define|#
directive|define
name|QUERY_DEV_CAP_FLOW_STEERING_MAX_QP_OFFSET
value|0x77
define|#
directive|define
name|QUERY_DEV_CAP_SL2VL_EVENT_OFFSET
value|0x78
define|#
directive|define
name|QUERY_DEV_CAP_CQ_EQ_CACHE_LINE_STRIDE
value|0x7a
define|#
directive|define
name|QUERY_DEV_CAP_ECN_QCN_VER_OFFSET
value|0x7b
define|#
directive|define
name|QUERY_DEV_CAP_RDMARC_ENTRY_SZ_OFFSET
value|0x80
define|#
directive|define
name|QUERY_DEV_CAP_QPC_ENTRY_SZ_OFFSET
value|0x82
define|#
directive|define
name|QUERY_DEV_CAP_AUX_ENTRY_SZ_OFFSET
value|0x84
define|#
directive|define
name|QUERY_DEV_CAP_ALTC_ENTRY_SZ_OFFSET
value|0x86
define|#
directive|define
name|QUERY_DEV_CAP_EQC_ENTRY_SZ_OFFSET
value|0x88
define|#
directive|define
name|QUERY_DEV_CAP_CQC_ENTRY_SZ_OFFSET
value|0x8a
define|#
directive|define
name|QUERY_DEV_CAP_SRQ_ENTRY_SZ_OFFSET
value|0x8c
define|#
directive|define
name|QUERY_DEV_CAP_C_MPT_ENTRY_SZ_OFFSET
value|0x8e
define|#
directive|define
name|QUERY_DEV_CAP_MTT_ENTRY_SZ_OFFSET
value|0x90
define|#
directive|define
name|QUERY_DEV_CAP_D_MPT_ENTRY_SZ_OFFSET
value|0x92
define|#
directive|define
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
value|0x94
define|#
directive|define
name|QUERY_DEV_CAP_CONFIG_DEV_OFFSET
value|0x94
define|#
directive|define
name|QUERY_DEV_CAP_PHV_EN_OFFSET
value|0x96
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_LKEY_OFFSET
value|0x98
define|#
directive|define
name|QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET
value|0xa0
define|#
directive|define
name|QUERY_DEV_CAP_ETH_BACKPL_OFFSET
value|0x9c
define|#
directive|define
name|QUERY_DEV_CAP_DIAG_RPRT_PER_PORT
value|0x9c
define|#
directive|define
name|QUERY_DEV_CAP_FW_REASSIGN_MAC
value|0x9d
define|#
directive|define
name|QUERY_DEV_CAP_VXLAN
value|0x9e
define|#
directive|define
name|QUERY_DEV_CAP_MAD_DEMUX_OFFSET
value|0xb0
define|#
directive|define
name|QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_BASE_OFFSET
value|0xa8
define|#
directive|define
name|QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_RANGE_OFFSET
value|0xac
define|#
directive|define
name|QUERY_DEV_CAP_QP_RATE_LIMIT_NUM_OFFSET
value|0xcc
define|#
directive|define
name|QUERY_DEV_CAP_QP_RATE_LIMIT_MAX_OFFSET
value|0xd0
define|#
directive|define
name|QUERY_DEV_CAP_QP_RATE_LIMIT_MIN_OFFSET
value|0xd2
name|dev_cap
operator|->
name|flags2
operator|=
literal|0
expr_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_DEV_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|disable_unsupported_roce_caps
argument_list|(
name|outbox
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_qps
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qps
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_srqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_srqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_CQ_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_cq_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_CQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_cqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_CQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_cqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MPT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mpts
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_eqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_eqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MTT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mtts
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MRW_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mrws
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_NUM_SYS_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|num_sys_eqs
operator|=
name|size
operator|&
literal|0xfff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_REQ_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_requester_per_qp
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_RES_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_responder_per_qp
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_GSO_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x1f
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
name|dev_cap
operator|->
name|max_gso_sz
operator|=
literal|0
expr_stmt|;
else|else
name|dev_cap
operator|->
name|max_gso_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x20
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RSS_XOR
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x10
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RSS_TOP
expr_stmt|;
name|field
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RSS
expr_stmt|;
name|dev_cap
operator|->
name|max_rss_tbl_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
block|}
else|else
name|dev_cap
operator|->
name|max_rss_tbl_sz
operator|=
literal|0
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_RDMA_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rdma_global
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ACK_DELAY_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|local_ca_ack_delay
operator|=
name|field
operator|&
literal|0x1f
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|num_ports
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MSG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_msg_sz
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_PORT_FLOWSTATS_COUNTERS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x10
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_FS_EN
expr_stmt|;
name|dev_cap
operator|->
name|fs_log_max_ucast_qp_range_size
operator|=
name|field
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x20
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_DMFS_UC_MC_SNIFFER
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_PORT_BEACON_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_PORT_BEACON
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_IPOIB_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_DMFS_IPOIB
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_MAX_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_SL2VL_EVENT_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_SL_TO_VL_CHANGE_EVENT
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ECN_QCN_VER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x1
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_QCN
expr_stmt|;
name|MLX4_GET
argument_list|(
name|stat_rate
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RATE_SUPPORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|stat_rate_support
operator|=
name|stat_rate
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|MLX4_GET
argument_list|(
name|ext_flags
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|flags
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|flags
operator|=
name|flags
operator||
operator|(
name|u64
operator|)
name|ext_flags
operator|<<
literal|32
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_UAR_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_uars
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|uar_size
operator|=
literal|1
operator|<<
operator|(
operator|(
name|field
operator|&
literal|0x3f
operator|)
operator|+
literal|20
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|min_page_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_BF_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_LOG_BF_REG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|bf_reg_size
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_LOG_MAX_BF_REGS_PER_PAGE_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
operator|)
operator|>
operator|(
name|PAGE_SIZE
operator|/
name|dev_cap
operator|->
name|bf_reg_size
operator|)
condition|)
name|field
operator|=
literal|3
expr_stmt|;
name|dev_cap
operator|->
name|bf_regs_per_page
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dev_cap
operator|->
name|bf_reg_size
operator|=
literal|0
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SG_SQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_sq_sg
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_DESC_SZ_SQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_sq_desc_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_SVLAN_BY_QP_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x1
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_SVLAN_BY_QP
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qp_per_mcg
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mgms
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mcgs
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_PD_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_pds
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_PD_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_pds
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_XRC_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_xrcds
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_XRC_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_xrcds
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RDMARC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|rdmarc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_QPC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|qpc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_AUX_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|aux_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ALTC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|altc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EQC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|eqc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_CQC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|cqc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_SRQ_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|srq_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_C_MPT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|cmpt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MTT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|mtt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_D_MPT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|dmpt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SRQ_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_srq_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qp_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSZ_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|resize_srq
operator|=
name|field
operator|&
literal|1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SG_RQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rq_sg
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_DESC_SZ_RQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rq_desc_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_CQ_EQ_CACHE_LINE_STRIDE
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_QOS_VPP
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_CQE_STRIDE
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_EQE_STRIDE
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|bmme_flags
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|bmme_flags
operator|&
name|MLX4_FLAG_ROCE_V1_V2
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_ROCE_V1_V2
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|bmme_flags
operator|&
name|MLX4_FLAG_PORT_REMAP
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_PORT_REMAP
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_CONFIG_DEV_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x20
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_CONFIG_DEV
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_IGNORE_FCS
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_PHV_EN_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_PHV_EN
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x40
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_SKIP_OUTER_VLAN
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|reserved_lkey
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_LKEY_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ETH_BACKPL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_DIAG_RPRT_PER_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_DIAG_PER_PORT
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FW_REASSIGN_MAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_REASSIGN_MAC_EN
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_VXLAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_VXLAN_OFFLOADS
expr_stmt|;
if|if
condition|(
name|field
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_ETS_CFG
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_icm_sz
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
condition|)
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_counters
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_COUNTERS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAD_DEMUX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_MAD_DEMUX
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_base
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_BASE_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_base
operator|&=
name|MGM_QPN_MASK
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_range
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_RANGE_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_range
operator|&=
name|MGM_QPN_MASK
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_QP_RATE_LIMIT_NUM_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|rl_caps
operator|.
name|num_rates
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|rl_caps
operator|.
name|num_rates
condition|)
block|{
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_QP_RATE_LIMIT_MAX_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|rl_caps
operator|.
name|max_val
operator|=
name|size
operator|&
literal|0xfff
expr_stmt|;
name|dev_cap
operator|->
name|rl_caps
operator|.
name|max_unit
operator|=
name|size
operator|>>
literal|14
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_QP_RATE_LIMIT_MIN_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|rl_caps
operator|.
name|min_val
operator|=
name|size
operator|&
literal|0xfff
expr_stmt|;
name|dev_cap
operator|->
name|rl_caps
operator|.
name|min_unit
operator|=
name|size
operator|>>
literal|14
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_UPDATE_QP
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_UPDATE_QP_SRC_CHECK_LB
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|19
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_LB_SRC_CHK
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|26
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_VLAN_CONTROL
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_FSM
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|21
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_80_VFS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev_cap
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|mlx4_QUERY_PORT
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|dev_cap
operator|->
name|port_cap
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Each UAR has 4 EQ doorbells; so if a UAR is reserved, then 	 * we can't use any EQs whose doorbell falls on that page, 	 * even if the EQ itself isn't reserved. 	 */
if|if
condition|(
name|dev_cap
operator|->
name|num_sys_eqs
operator|==
literal|0
condition|)
name|dev_cap
operator|->
name|reserved_eqs
operator|=
name|max
argument_list|(
name|dev_cap
operator|->
name|reserved_uars
operator|*
literal|4
argument_list|,
name|dev_cap
operator|->
name|reserved_eqs
argument_list|)
expr_stmt|;
else|else
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_dev_cap_dump
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
if|if
condition|(
name|dev_cap
operator|->
name|bf_reg_size
operator|>
literal|0
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"BlueFlame available (reg size %d, regs/page %d)\n"
argument_list|,
name|dev_cap
operator|->
name|bf_reg_size
argument_list|,
name|dev_cap
operator|->
name|bf_regs_per_page
argument_list|)
expr_stmt|;
else|else
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"BlueFlame not available\n"
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Base MM extensions: flags %08x, rsvd L_Key %08x\n"
argument_list|,
name|dev_cap
operator|->
name|bmme_flags
argument_list|,
name|dev_cap
operator|->
name|reserved_lkey
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max ICM size %lld MB\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|dev_cap
operator|->
name|max_icm_sz
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max QPs: %d, reserved QPs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_qps
argument_list|,
name|dev_cap
operator|->
name|reserved_qps
argument_list|,
name|dev_cap
operator|->
name|qpc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max SRQs: %d, reserved SRQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_srqs
argument_list|,
name|dev_cap
operator|->
name|reserved_srqs
argument_list|,
name|dev_cap
operator|->
name|srq_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max CQs: %d, reserved CQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_cqs
argument_list|,
name|dev_cap
operator|->
name|reserved_cqs
argument_list|,
name|dev_cap
operator|->
name|cqc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Num sys EQs: %d, max EQs: %d, reserved EQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|num_sys_eqs
argument_list|,
name|dev_cap
operator|->
name|max_eqs
argument_list|,
name|dev_cap
operator|->
name|reserved_eqs
argument_list|,
name|dev_cap
operator|->
name|eqc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"reserved MPTs: %d, reserved MTTs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|reserved_mrws
argument_list|,
name|dev_cap
operator|->
name|reserved_mtts
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max PDs: %d, reserved PDs: %d, reserved UARs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_uars
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max QP/MCG: %d, reserved MGMs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_mgms
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max CQEs: %d, max WQEs: %d, max SRQ WQEs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_cq_sz
argument_list|,
name|dev_cap
operator|->
name|max_qp_sz
argument_list|,
name|dev_cap
operator|->
name|max_srq_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Local CA ACK delay: %d, max MTU: %d, port width cap: %d\n"
argument_list|,
name|dev_cap
operator|->
name|local_ca_ack_delay
argument_list|,
literal|128
operator|<<
name|dev_cap
operator|->
name|port_cap
index|[
literal|1
index|]
operator|.
name|ib_mtu
argument_list|,
name|dev_cap
operator|->
name|port_cap
index|[
literal|1
index|]
operator|.
name|max_port_width
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max SQ desc size: %d, max SQ S/G: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_sq_desc_sz
argument_list|,
name|dev_cap
operator|->
name|max_sq_sg
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max RQ desc size: %d, max RQ S/G: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_rq_desc_sz
argument_list|,
name|dev_cap
operator|->
name|max_rq_sg
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max GSO size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_gso_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max counters: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_counters
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max RSS Table size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_rss_tbl_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"DMFS high rate steer QPn base: %d\n"
argument_list|,
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_base
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"DMFS high rate steer QPn range: %d\n"
argument_list|,
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_range
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT
condition|)
block|{
name|struct
name|mlx4_rate_limit_caps
modifier|*
name|rl_caps
init|=
operator|&
name|dev_cap
operator|->
name|rl_caps
decl_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"QP Rate-Limit: #rates %d, unit/val max %d/%d, min %d/%d\n"
argument_list|,
name|rl_caps
operator|->
name|num_rates
argument_list|,
name|rl_caps
operator|->
name|max_unit
argument_list|,
name|rl_caps
operator|->
name|max_val
argument_list|,
name|rl_caps
operator|->
name|min_unit
argument_list|,
name|rl_caps
operator|->
name|min_val
argument_list|)
expr_stmt|;
block|}
name|dump_dev_cap_flags
argument_list|(
name|dev
argument_list|,
name|dev_cap
operator|->
name|flags
argument_list|)
expr_stmt|;
name|dump_dev_cap_flags2
argument_list|(
name|dev
argument_list|,
name|dev_cap
operator|->
name|flags2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_PORT
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|mlx4_port_cap
modifier|*
name|port_cap
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|u32
name|field32
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_OLD_PORT_CMDS
condition|)
block|{
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_DEV_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|max_vl
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MTU_WIDTH_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|ib_mtu
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|port_cap
operator|->
name|max_port_width
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|max_gids
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|max_pkeys
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
else|else
block|{
define|#
directive|define
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
value|0x00
define|#
directive|define
name|QUERY_PORT_MTU_OFFSET
value|0x01
define|#
directive|define
name|QUERY_PORT_ETH_MTU_OFFSET
value|0x02
define|#
directive|define
name|QUERY_PORT_WIDTH_OFFSET
value|0x06
define|#
directive|define
name|QUERY_PORT_MAX_GID_PKEY_OFFSET
value|0x07
define|#
directive|define
name|QUERY_PORT_MAX_MACVLAN_OFFSET
value|0x0a
define|#
directive|define
name|QUERY_PORT_MAX_VL_OFFSET
value|0x0b
define|#
directive|define
name|QUERY_PORT_MAC_OFFSET
value|0x10
define|#
directive|define
name|QUERY_PORT_TRANS_VENDOR_OFFSET
value|0x18
define|#
directive|define
name|QUERY_PORT_WAVELENGTH_OFFSET
value|0x1c
define|#
directive|define
name|QUERY_PORT_TRANS_CODE_OFFSET
value|0x20
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|link_state
operator|=
operator|(
name|field
operator|&
literal|0x80
operator|)
operator|>>
literal|7
expr_stmt|;
name|port_cap
operator|->
name|supported_port_types
operator|=
name|field
operator|&
literal|3
expr_stmt|;
name|port_cap
operator|->
name|suggested_type
operator|=
operator|(
name|field
operator|>>
literal|3
operator|)
operator|&
literal|1
expr_stmt|;
name|port_cap
operator|->
name|default_sense
operator|=
operator|(
name|field
operator|>>
literal|4
operator|)
operator|&
literal|1
expr_stmt|;
name|port_cap
operator|->
name|dmfs_optimized_state
operator|=
operator|(
name|field
operator|>>
literal|5
operator|)
operator|&
literal|1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MTU_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|ib_mtu
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_WIDTH_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|max_port_width
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_GID_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|max_gids
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|port_cap
operator|->
name|max_pkeys
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_VL_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|max_vl
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|port_cap
operator|->
name|max_tc_eth
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_MACVLAN_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|log_max_macs
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|port_cap
operator|->
name|log_max_vlans
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|port_cap
operator|->
name|eth_mtu
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_ETH_MTU_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|port_cap
operator|->
name|def_mac
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAC_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_TRANS_VENDOR_OFFSET
argument_list|)
expr_stmt|;
name|port_cap
operator|->
name|trans_type
operator|=
name|field32
operator|>>
literal|24
expr_stmt|;
name|port_cap
operator|->
name|vendor_oui
operator|=
name|field32
operator|&
literal|0xffffff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|port_cap
operator|->
name|wavelength
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_WAVELENGTH_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|port_cap
operator|->
name|trans_code
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_TRANS_CODE_OFFSET
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DEV_CAP_EXT_2_FLAG_PFC_COUNTERS
value|(1<< 28)
end_define

begin_define
define|#
directive|define
name|DEV_CAP_EXT_2_FLAG_VLAN_CONTROL
value|(1<< 26)
end_define

begin_define
define|#
directive|define
name|DEV_CAP_EXT_2_FLAG_80_VFS
value|(1<< 21)
end_define

begin_define
define|#
directive|define
name|DEV_CAP_EXT_2_FLAG_FSM
value|(1<< 20)
end_define

begin_function
name|int
name|mlx4_QUERY_DEV_CAP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|u64
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|u16
name|field16
decl_stmt|;
name|u32
name|bmme_flags
decl_stmt|,
name|field32
decl_stmt|;
name|int
name|real_port
decl_stmt|;
name|int
name|slave_port
decl_stmt|;
name|int
name|first_port
decl_stmt|;
name|struct
name|mlx4_active_ports
name|actv_ports
decl_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_DEV_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|disable_unsupported_roce_caps
argument_list|(
name|outbox
operator|->
name|buf
argument_list|)
expr_stmt|;
comment|/* add port mng change event capability and disable mw type 1 	 * unconditionally to slaves 	 */
name|MLX4_GET
argument_list|(
name|flags
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|flags
operator||=
name|MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV
expr_stmt|;
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_MEM_WINDOW
expr_stmt|;
name|actv_ports
operator|=
name|mlx4_get_active_ports
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|first_port
operator|=
name|find_first_bit
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|slave_port
operator|=
literal|0
operator|,
name|real_port
operator|=
name|first_port
init|;
name|real_port
operator|<
name|first_port
operator|+
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
condition|;
operator|++
name|real_port
operator|,
operator|++
name|slave_port
control|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG_WOL_PORT1
operator|<<
name|real_port
operator|)
condition|)
name|flags
operator||=
name|MLX4_DEV_CAP_FLAG_WOL_PORT1
operator|<<
name|slave_port
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
operator|(
name|MLX4_DEV_CAP_FLAG_WOL_PORT1
operator|<<
name|slave_port
operator|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|slave_port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|slave_port
control|)
name|flags
operator|&=
operator|~
operator|(
name|MLX4_DEV_CAP_FLAG_WOL_PORT1
operator|<<
name|slave_port
operator|)
expr_stmt|;
comment|/* Not exposing RSS IP fragments to guests */
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_RSS_IP_FRAG
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|flags
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
operator|~
literal|0x0F
expr_stmt|;
name|field
operator||=
name|bitmap_weight
argument_list|(
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
operator|&
literal|0x0F
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
comment|/* For guests, disable timestamp */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x7f
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET
argument_list|)
expr_stmt|;
comment|/* For guests, disable vxlan tunneling and QoS support */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_VXLAN
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0xd7
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_VXLAN
argument_list|)
expr_stmt|;
comment|/* For guests, disable port BEACON */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_PORT_BEACON_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x7f
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_PORT_BEACON_OFFSET
argument_list|)
expr_stmt|;
comment|/* For guests, report Blueflame disabled */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_BF_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x7f
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_BF_OFFSET
argument_list|)
expr_stmt|;
comment|/* For guests, disable mw type 2 and port remap*/
name|MLX4_GET
argument_list|(
name|bmme_flags
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|bmme_flags
operator|&=
operator|~
name|MLX4_BMME_FLAG_TYPE_2_WIN
expr_stmt|;
name|bmme_flags
operator|&=
operator|~
name|MLX4_FLAG_PORT_REMAP
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|bmme_flags
argument_list|,
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
argument_list|)
expr_stmt|;
comment|/* turn off device-managed steering capability if not enabled */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|!=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x7f
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
argument_list|)
expr_stmt|;
block|}
comment|/* turn off ipoib managed steering for guests */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_IPOIB_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
operator|~
literal|0x80
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_IPOIB_OFFSET
argument_list|)
expr_stmt|;
comment|/* turn off host side virt features (VST, FSM, etc) for guests */
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|field32
operator|&=
operator|~
operator|(
name|DEV_CAP_EXT_2_FLAG_VLAN_CONTROL
operator||
name|DEV_CAP_EXT_2_FLAG_80_VFS
operator||
name|DEV_CAP_EXT_2_FLAG_FSM
operator||
name|DEV_CAP_EXT_2_FLAG_PFC_COUNTERS
operator|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field32
argument_list|,
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
argument_list|)
expr_stmt|;
comment|/* turn off QCN for guests */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_ECN_QCN_VER_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0xfe
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_ECN_QCN_VER_OFFSET
argument_list|)
expr_stmt|;
comment|/* turn off QP max-rate limiting for guests */
name|field16
operator|=
literal|0
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field16
argument_list|,
name|QUERY_DEV_CAP_QP_RATE_LIMIT_NUM_OFFSET
argument_list|)
expr_stmt|;
comment|/* turn off QoS per VF support for guests */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_CQ_EQ_CACHE_LINE_STRIDE
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0xef
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_CQ_EQ_CACHE_LINE_STRIDE
argument_list|)
expr_stmt|;
comment|/* turn off ignore FCS feature for guests */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_CONFIG_DEV_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0xfb
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_CONFIG_DEV_OFFSET
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_unsupported_roce_caps
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|flags
decl_stmt|;
name|MLX4_GET
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
literal|31
operator|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|buf
argument_list|,
name|flags
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
literal|24
operator|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|buf
argument_list|,
name|flags
argument_list|,
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|MLX4_FLAG_ROCE_V1_V2
operator|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|buf
argument_list|,
name|flags
argument_list|,
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_PORT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|def_mac
decl_stmt|;
name|u8
name|port_type
decl_stmt|;
name|u16
name|short_field
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
init|=
name|mlx4_slave_convert_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_modifier
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
define|#
directive|define
name|MLX4_VF_PORT_NO_LINK_SENSE_MASK
value|0xE0
define|#
directive|define
name|MLX4_PORT_LINK_UP_MASK
value|0x80
define|#
directive|define
name|QUERY_PORT_CUR_MAX_PKEY_OFFSET
value|0x0c
define|#
directive|define
name|QUERY_PORT_CUR_MAX_GID_OFFSET
value|0x0e
if|if
condition|(
name|port
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Protect against untrusted guests: enforce that this is the 	 * QUERY_PORT general query. 	 */
if|if
condition|(
name|vhcr
operator|->
name|op_modifier
operator|||
name|vhcr
operator|->
name|in_modifier
operator|&
operator|~
literal|0xFF
condition|)
return|return
operator|-
name|EINVAL
return|;
name|vhcr
operator|->
name|in_modifier
operator|=
name|port
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|dev
operator|->
name|caps
operator|.
name|function
operator|!=
name|slave
condition|)
block|{
name|def_mac
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|vhcr
operator|->
name|in_modifier
index|]
operator|.
name|state
operator|.
name|mac
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|def_mac
argument_list|,
name|QUERY_PORT_MAC_OFFSET
argument_list|)
expr_stmt|;
comment|/* get port type - currently only eth is enabled */
name|MLX4_GET
argument_list|(
name|port_type
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
argument_list|)
expr_stmt|;
comment|/* No link sensing allowed */
name|port_type
operator|&=
name|MLX4_VF_PORT_NO_LINK_SENSE_MASK
expr_stmt|;
comment|/* set port type to currently operating port type */
name|port_type
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|vhcr
operator|->
name|in_modifier
index|]
operator|&
literal|0x3
operator|)
expr_stmt|;
if|if
condition|(
literal|0
comment|/* IFLA_VF_LINK_STATE_ENABLE == admin_link_state */
condition|)
name|port_type
operator||=
name|MLX4_PORT_LINK_UP_MASK
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
comment|/* IFLA_VF_LINK_STATE_DISABLE == admin_link_state */
condition|)
name|port_type
operator|&=
operator|~
name|MLX4_PORT_LINK_UP_MASK
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
comment|/* IFLA_VF_LINK_STATE_AUTO == admin_link_state&& mlx4_is_bonded(dev) */
condition|)
block|{
name|int
name|other_port
init|=
operator|(
name|port
operator|==
literal|1
operator|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|struct
name|mlx4_port_cap
name|port_cap
decl_stmt|;
name|err
operator|=
name|mlx4_QUERY_PORT
argument_list|(
name|dev
argument_list|,
name|other_port
argument_list|,
operator|&
name|port_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|port_type
operator||=
operator|(
name|port_cap
operator|.
name|link_state
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|port_type
argument_list|,
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|vhcr
operator|->
name|in_modifier
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|short_field
operator|=
name|mlx4_get_slave_num_gids
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
else|else
name|short_field
operator|=
literal|1
expr_stmt|;
comment|/* slave max gids */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|short_field
argument_list|,
name|QUERY_PORT_CUR_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|short_field
operator|=
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|vhcr
operator|->
name|in_modifier
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|short_field
argument_list|,
name|QUERY_PORT_CUR_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_slave_pkey_gid_tbl_len
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
modifier|*
name|gid_tbl_len
parameter_list|,
name|int
modifier|*
name|pkey_tbl_len
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u16
name|field
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_CUR_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
operator|*
name|gid_tbl_len
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_CUR_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
operator|*
name|pkey_tbl_len
operator|=
name|field
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_slave_pkey_gid_tbl_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_map_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|op
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|,
name|u64
name|virt
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_icm_iter
name|iter
decl_stmt|;
name|__be64
modifier|*
name|pages
decl_stmt|;
name|int
name|lg
decl_stmt|;
name|int
name|nent
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|ts
init|=
literal|0
decl_stmt|,
name|tc
init|=
literal|0
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|pages
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|mlx4_icm_first
argument_list|(
name|icm
argument_list|,
operator|&
name|iter
argument_list|)
init|;
operator|!
name|mlx4_icm_last
argument_list|(
operator|&
name|iter
argument_list|)
condition|;
name|mlx4_icm_next
argument_list|(
operator|&
name|iter
argument_list|)
control|)
block|{
comment|/* 		 * We have to pass pages that are aligned to their 		 * size, so find the least significant 1 in the 		 * address or size and use that as our log2 size. 		 */
name|lg
operator|=
name|ffs
argument_list|(
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
operator||
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lg
operator|<
name|MLX4_ICM_PAGE_SHIFT
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Got FW area not aligned to %d (%llx/%lx)\n"
argument_list|,
name|MLX4_ICM_PAGE_SIZE
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|,
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
operator|>>
name|lg
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|virt
operator|!=
operator|-
literal|1
condition|)
block|{
name|pages
index|[
name|nent
operator|*
literal|2
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|virt
argument_list|)
expr_stmt|;
name|virt
operator|+=
literal|1
operator|<<
name|lg
expr_stmt|;
block|}
name|pages
index|[
name|nent
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|cpu_to_be64
argument_list|(
operator|(
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|lg
operator|)
operator|)
operator||
operator|(
name|lg
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ts
operator|+=
literal|1
operator|<<
operator|(
name|lg
operator|-
literal|10
operator|)
expr_stmt|;
operator|++
name|tc
expr_stmt|;
if|if
condition|(
operator|++
name|nent
operator|==
name|MLX4_MAILBOX_SIZE
operator|/
literal|16
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|nent
argument_list|,
literal|0
argument_list|,
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|nent
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nent
condition|)
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|nent
argument_list|,
literal|0
argument_list|,
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|MLX4_CMD_MAP_FA
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB for FW\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_CMD_MAP_ICM_AUX
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB for ICM aux\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_CMD_MAP_ICM
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB at %llx for ICM\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|virt
operator|-
operator|(
name|ts
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_MAP_FA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|)
block|{
return|return
name|mlx4_map_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_MAP_FA
argument_list|,
name|icm
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_UNMAP_FA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_UNMAP_FA
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_RUN_FW
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_RUN_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FW
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_fw
modifier|*
name|fw
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|fw
decl_stmt|;
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u64
name|fw_ver
decl_stmt|;
name|u16
name|cmd_if_rev
decl_stmt|;
name|u8
name|lg
decl_stmt|;
define|#
directive|define
name|QUERY_FW_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_FW_VER_OFFSET
value|0x00
define|#
directive|define
name|QUERY_FW_PPF_ID
value|0x09
define|#
directive|define
name|QUERY_FW_CMD_IF_REV_OFFSET
value|0x0a
define|#
directive|define
name|QUERY_FW_MAX_CMD_OFFSET
value|0x0f
define|#
directive|define
name|QUERY_FW_ERR_START_OFFSET
value|0x30
define|#
directive|define
name|QUERY_FW_ERR_SIZE_OFFSET
value|0x38
define|#
directive|define
name|QUERY_FW_ERR_BAR_OFFSET
value|0x3c
define|#
directive|define
name|QUERY_FW_SIZE_OFFSET
value|0x00
define|#
directive|define
name|QUERY_FW_CLR_INT_BASE_OFFSET
value|0x20
define|#
directive|define
name|QUERY_FW_CLR_INT_BAR_OFFSET
value|0x28
define|#
directive|define
name|QUERY_FW_COMM_BASE_OFFSET
value|0x40
define|#
directive|define
name|QUERY_FW_COMM_BAR_OFFSET
value|0x48
define|#
directive|define
name|QUERY_FW_CLOCK_OFFSET
value|0x50
define|#
directive|define
name|QUERY_FW_CLOCK_BAR
value|0x58
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|fw_ver
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_VER_OFFSET
argument_list|)
expr_stmt|;
comment|/* 	 * FW subminor version is at more significant bits than minor 	 * version, so swap here. 	 */
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|=
operator|(
name|fw_ver
operator|&
literal|0xffff00000000ull
operator|)
operator||
operator|(
operator|(
name|fw_ver
operator|&
literal|0xffff0000ull
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|fw_ver
operator|&
literal|0x0000ffffull
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|lg
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_PPF_ID
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|function
operator|=
name|lg
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|cmd_if_rev
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CMD_IF_REV_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_if_rev
operator|<
name|MLX4_COMMAND_INTERFACE_MIN_REV
operator|||
name|cmd_if_rev
operator|>
name|MLX4_COMMAND_INTERFACE_MAX_REV
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Installed FW has unsupported command interface revision %d\n"
argument_list|,
name|cmd_if_rev
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"(Installed FW version is %d.%d.%03d)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"This driver version supports only revisions %d to %d\n"
argument_list|,
name|MLX4_COMMAND_INTERFACE_MIN_REV
argument_list|,
name|MLX4_COMMAND_INTERFACE_MAX_REV
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cmd_if_rev
operator|<
name|MLX4_COMMAND_INTERFACE_NEW_PORT_CMDS
condition|)
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_OLD_PORT_CMDS
expr_stmt|;
name|MLX4_GET
argument_list|(
name|lg
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_MAX_CMD_OFFSET
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|max_cmds
operator|=
literal|1
operator|<<
name|lg
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"FW version %d.%d.%03d (cmd intf rev %d), max commands %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|&
literal|0xffff
argument_list|,
name|cmd_if_rev
argument_list|,
name|cmd
operator|->
name|max_cmds
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_offset
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_START_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|catas_bar
operator|=
operator|(
name|fw
operator|->
name|catas_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Catastrophic error buffer at 0x%llx, size 0x%x, BAR %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|catas_offset
argument_list|,
name|fw
operator|->
name|catas_size
argument_list|,
name|fw
operator|->
name|catas_bar
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|fw_pages
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clr_int_base
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLR_INT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clr_int_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLR_INT_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|clr_int_bar
operator|=
operator|(
name|fw
operator|->
name|clr_int_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|comm_base
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_COMM_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|comm_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_COMM_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|comm_bar
operator|=
operator|(
name|fw
operator|->
name|comm_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Communication vector bar:%d offset:0x%llx\n"
argument_list|,
name|fw
operator|->
name|comm_bar
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|comm_base
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"FW size %d KB\n"
argument_list|,
name|fw
operator|->
name|fw_pages
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clock_offset
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLOCK_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clock_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLOCK_BAR
argument_list|)
expr_stmt|;
name|fw
operator|->
name|clock_bar
operator|=
operator|(
name|fw
operator|->
name|clock_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Internal clock bar:%d offset:0x%llx\n"
argument_list|,
name|fw
operator|->
name|clock_bar
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|clock_offset
argument_list|)
expr_stmt|;
comment|/* 	 * Round up number of system pages needed in case 	 * MLX4_ICM_PAGE_SIZE< PAGE_SIZE. 	 */
name|fw
operator|->
name|fw_pages
operator|=
name|ALIGN
argument_list|(
name|fw
operator|->
name|fw_pages
argument_list|,
name|PAGE_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Clear int @ %llx, BAR %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|clr_int_base
argument_list|,
name|fw
operator|->
name|clr_int_bar
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FW_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|u8
modifier|*
name|outbuf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|outbuf
operator|=
name|outbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* for slaves, set pci PPF ID to invalid and zero out everything 	 * else except FW version */
name|outbuf
index|[
literal|0
index|]
operator|=
name|outbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|outbuf
index|[
literal|8
index|]
argument_list|,
literal|0
argument_list|,
name|QUERY_FW_OUT_SIZE
operator|-
literal|8
argument_list|)
expr_stmt|;
name|outbuf
index|[
name|QUERY_FW_PPF_ID
index|]
operator|=
name|MLX4_INVALID_SLAVE_ID
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_board_id
parameter_list|(
name|void
modifier|*
name|vsd
parameter_list|,
name|char
modifier|*
name|board_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|VSD_OFFSET_SIG1
value|0x00
define|#
directive|define
name|VSD_OFFSET_SIG2
value|0xde
define|#
directive|define
name|VSD_OFFSET_MLX_BOARD_ID
value|0xd0
define|#
directive|define
name|VSD_OFFSET_TS_BOARD_ID
value|0x20
define|#
directive|define
name|VSD_SIGNATURE_TOPSPIN
value|0x5ad
name|memset
argument_list|(
name|board_id
argument_list|,
literal|0
argument_list|,
name|MLX4_BOARD_ID_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpup
argument_list|(
name|vsd
operator|+
name|VSD_OFFSET_SIG1
argument_list|)
operator|==
name|VSD_SIGNATURE_TOPSPIN
operator|&&
name|be16_to_cpup
argument_list|(
name|vsd
operator|+
name|VSD_OFFSET_SIG2
argument_list|)
operator|==
name|VSD_SIGNATURE_TOPSPIN
condition|)
block|{
name|strlcpy
argument_list|(
name|board_id
argument_list|,
name|vsd
operator|+
name|VSD_OFFSET_TS_BOARD_ID
argument_list|,
name|MLX4_BOARD_ID_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The board ID is a string but the firmware byte 		 * swaps each 4-byte word before passing it back to 		 * us.  Therefore we need to swab it before printing. 		 */
name|u32
modifier|*
name|bid_u32
init|=
operator|(
name|u32
operator|*
operator|)
name|board_id
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
typedef|typedef
struct|struct
block|{
name|u32
name|value
decl_stmt|;
block|}
name|__packed
name|u64_p_t
typedef|;
name|u32
modifier|*
name|addr
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|addr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|vsd
operator|+
name|VSD_OFFSET_MLX_BOARD_ID
operator|+
name|i
operator|*
literal|4
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|u64_p_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|value
expr_stmt|;
name|val
operator|=
name|swab32
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u64_p_t
operator|*
operator|)
operator|&
name|bid_u32
index|[
name|i
index|]
operator|)
operator|->
name|value
operator|=
name|val
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_ADAPTER
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|QUERY_ADAPTER_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_ADAPTER_INTA_PIN_OFFSET
value|0x10
define|#
directive|define
name|QUERY_ADAPTER_VSD_OFFSET
value|0x20
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_ADAPTER
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|adapter
operator|->
name|inta_pin
argument_list|,
name|outbox
argument_list|,
name|QUERY_ADAPTER_INTA_PIN_OFFSET
argument_list|)
expr_stmt|;
name|get_board_id
argument_list|(
name|outbox
operator|+
name|QUERY_ADAPTER_VSD_OFFSET
operator|/
literal|4
argument_list|,
name|adapter
operator|->
name|board_id
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|__be32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|static
specifier|const
name|u8
name|a0_dmfs_hw_steering
index|[]
init|=
block|{
index|[
name|MLX4_STEERING_DMFS_A0_DEFAULT
index|]
operator|=
literal|0
block|,
index|[
name|MLX4_STEERING_DMFS_A0_DYNAMIC
index|]
operator|=
literal|1
block|,
index|[
name|MLX4_STEERING_DMFS_A0_STATIC
index|]
operator|=
literal|2
block|,
index|[
name|MLX4_STEERING_DMFS_A0_DISABLE
index|]
operator|=
literal|3
block|}
decl_stmt|;
define|#
directive|define
name|INIT_HCA_IN_SIZE
value|0x200
define|#
directive|define
name|INIT_HCA_VERSION_OFFSET
value|0x000
define|#
directive|define
name|INIT_HCA_VERSION
value|2
define|#
directive|define
name|INIT_HCA_VXLAN_OFFSET
value|0x0c
define|#
directive|define
name|INIT_HCA_CACHELINE_SZ_OFFSET
value|0x0e
define|#
directive|define
name|INIT_HCA_FLAGS_OFFSET
value|0x014
define|#
directive|define
name|INIT_HCA_RECOVERABLE_ERROR_EVENT_OFFSET
value|0x018
define|#
directive|define
name|INIT_HCA_QPC_OFFSET
value|0x020
define|#
directive|define
name|INIT_HCA_QPC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x10)
define|#
directive|define
name|INIT_HCA_LOG_QP_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x17)
define|#
directive|define
name|INIT_HCA_SRQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x28)
define|#
directive|define
name|INIT_HCA_LOG_SRQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x2f)
define|#
directive|define
name|INIT_HCA_CQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x30)
define|#
directive|define
name|INIT_HCA_LOG_CQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x37)
define|#
directive|define
name|INIT_HCA_EQE_CQE_OFFSETS
value|(INIT_HCA_QPC_OFFSET + 0x38)
define|#
directive|define
name|INIT_HCA_EQE_CQE_STRIDE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x3b)
define|#
directive|define
name|INIT_HCA_ALTC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x40)
define|#
directive|define
name|INIT_HCA_AUXC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x50)
define|#
directive|define
name|INIT_HCA_EQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x60)
define|#
directive|define
name|INIT_HCA_LOG_EQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x67)
define|#
directive|define
name|INIT_HCA_NUM_SYS_EQS_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x6a)
define|#
directive|define
name|INIT_HCA_RDMARC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x70)
define|#
directive|define
name|INIT_HCA_LOG_RD_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x77)
define|#
directive|define
name|INIT_HCA_MCAST_OFFSET
value|0x0c0
define|#
directive|define
name|INIT_HCA_MC_BASE_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x12)
define|#
directive|define
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x16)
define|#
directive|define
name|INIT_HCA_UC_STEERING_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x18)
define|#
directive|define
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x1b)
define|#
directive|define
name|INIT_HCA_DEVICE_MANAGED_FLOW_STEERING_EN
value|0x6
define|#
directive|define
name|INIT_HCA_FS_PARAM_OFFSET
value|0x1d0
define|#
directive|define
name|INIT_HCA_FS_BASE_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_FS_LOG_ENTRY_SZ_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x12)
define|#
directive|define
name|INIT_HCA_FS_A0_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x18)
define|#
directive|define
name|INIT_HCA_FS_LOG_TABLE_SZ_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x1b)
define|#
directive|define
name|INIT_HCA_FS_ETH_BITS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x21)
define|#
directive|define
name|INIT_HCA_FS_ETH_NUM_ADDRS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x22)
define|#
directive|define
name|INIT_HCA_FS_IB_BITS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x25)
define|#
directive|define
name|INIT_HCA_FS_IB_NUM_ADDRS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x26)
define|#
directive|define
name|INIT_HCA_TPT_OFFSET
value|0x0f0
define|#
directive|define
name|INIT_HCA_DMPT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_TPT_MW_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x08)
define|#
directive|define
name|INIT_HCA_LOG_MPT_SZ_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x0b)
define|#
directive|define
name|INIT_HCA_MTT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x10)
define|#
directive|define
name|INIT_HCA_CMPT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x18)
define|#
directive|define
name|INIT_HCA_UAR_OFFSET
value|0x120
define|#
directive|define
name|INIT_HCA_LOG_UAR_SZ_OFFSET
value|(INIT_HCA_UAR_OFFSET + 0x0a)
define|#
directive|define
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
value|(INIT_HCA_UAR_OFFSET + 0x0b)
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_VERSION_OFFSET
operator|)
operator|=
name|INIT_HCA_VERSION
expr_stmt|;
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_CACHELINE_SZ_OFFSET
operator|)
operator|=
operator|(
name|ilog2
argument_list|(
name|cache_line_size
argument_list|()
argument_list|)
operator|-
literal|4
operator|)
operator|<<
literal|5
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__LITTLE_ENDIAN
argument_list|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator|&=
operator|~
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__BIG_ENDIAN
argument_list|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Host endianness not defined
endif|#
directive|endif
comment|/* Check port for UD address vector: */
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable IPoIB checksumming if we can: */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_IPOIB_CSUM
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|3
argument_list|)
expr_stmt|;
comment|/* Enable QoS support if module parameter set */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_ETS_CFG
operator|&&
name|enable_qos
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* enable counters */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable RSS spread to fragmented IP packets when supported */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_RSS_IP_FRAG
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|13
argument_list|)
expr_stmt|;
comment|/* CX3 is capable of extending CQEs/EQEs from 32 to 64 bytes */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_64B_EQE
condition|)
block|{
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_EQE_CQE_OFFSETS
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|29
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|32
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_64B_CQE
condition|)
block|{
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_EQE_CQE_OFFSETS
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|30
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
operator||=
name|MLX4_USER_DEV_CAP_LARGE_CQE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|32
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX not currently supported by the FreeBSD's mlxen */
comment|/* CX3 is capable of extending CQEs\EQEs to strides larger than 64B */
block|if ((dev->caps.flags2& MLX4_DEV_CAP_FLAG2_EQE_STRIDE)&& 	    (dev->caps.flags2& MLX4_DEV_CAP_FLAG2_CQE_STRIDE)) { 		dev->caps.eqe_size = cache_line_size(); 		dev->caps.cqe_size = cache_line_size(); 		dev->caps.eqe_factor = 0; 		MLX4_PUT(inbox, (u8)((ilog2(dev->caps.eqe_size) - 5)<< 4 | 				      (ilog2(dev->caps.eqe_size) - 5)), 			 INIT_HCA_EQE_CQE_STRIDE_OFFSET);
comment|/* User still need to know to support CQE> 32B */
block|dev->caps.userspace_caps |= MLX4_USER_DEV_CAP_LARGE_CQE; 	}
endif|#
directive|endif
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_RECOVERABLE_ERROR_EVENT_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* QPC/EEC/CQC/EQC/RDMARC attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|qpc_base
argument_list|,
name|INIT_HCA_QPC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_qps
argument_list|,
name|INIT_HCA_LOG_QP_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|srqc_base
argument_list|,
name|INIT_HCA_SRQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_srqs
argument_list|,
name|INIT_HCA_LOG_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|cqc_base
argument_list|,
name|INIT_HCA_CQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_cqs
argument_list|,
name|INIT_HCA_LOG_CQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|altc_base
argument_list|,
name|INIT_HCA_ALTC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|auxc_base
argument_list|,
name|INIT_HCA_AUXC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|eqc_base
argument_list|,
name|INIT_HCA_EQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_eqs
argument_list|,
name|INIT_HCA_LOG_EQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|num_sys_eqs
argument_list|,
name|INIT_HCA_NUM_SYS_EQS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|rdmarc_base
argument_list|,
name|INIT_HCA_RDMARC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_rd_per_qp
argument_list|,
name|INIT_HCA_LOG_RD_OFFSET
argument_list|)
expr_stmt|;
comment|/* steering attributes */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
name|INIT_HCA_DEVICE_MANAGED_FLOW_STEERING_EN
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mc_base
argument_list|,
name|INIT_HCA_FS_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|INIT_HCA_FS_LOG_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|INIT_HCA_FS_LOG_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
comment|/* Enable Ethernet flow steering 		 * with udp unicast and tcp unicast 		 */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|!=
name|MLX4_STEERING_DMFS_A0_STATIC
condition|)
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|MLX4_FS_UDP_UC_EN
operator||
name|MLX4_FS_TCP_UC_EN
argument_list|)
argument_list|,
name|INIT_HCA_FS_ETH_BITS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
operator|(
name|u16
operator|)
name|MLX4_FS_NUM_OF_L2_ADDR
argument_list|,
name|INIT_HCA_FS_ETH_NUM_ADDRS_OFFSET
argument_list|)
expr_stmt|;
comment|/* Enable IPoIB flow steering 		 * with udp unicast and tcp unicast 		 */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|MLX4_FS_UDP_UC_EN
operator||
name|MLX4_FS_TCP_UC_EN
argument_list|)
argument_list|,
name|INIT_HCA_FS_IB_BITS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
operator|(
name|u16
operator|)
name|MLX4_FS_NUM_OF_L2_ADDR
argument_list|,
name|INIT_HCA_FS_IB_NUM_ADDRS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|!=
name|MLX4_STEERING_DMFS_A0_NOT_SUPPORTED
condition|)
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
operator|(
call|(
name|u8
call|)
argument_list|(
name|a0_dmfs_hw_steering
index|[
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
index|]
operator|<<
literal|6
argument_list|)
operator|)
argument_list|,
name|INIT_HCA_FS_A0_OFFSET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mc_base
argument_list|,
name|INIT_HCA_MC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_hash_sz
argument_list|,
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_B0
condition|)
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
call|(
name|u8
call|)
argument_list|(
literal|1
operator|<<
literal|3
argument_list|)
argument_list|,
name|INIT_HCA_UC_STEERING_OFFSET
argument_list|)
expr_stmt|;
block|}
comment|/* TPT attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|dmpt_base
argument_list|,
name|INIT_HCA_DMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mw_enabled
argument_list|,
name|INIT_HCA_TPT_MW_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mpt_sz
argument_list|,
name|INIT_HCA_LOG_MPT_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mtt_base
argument_list|,
name|INIT_HCA_MTT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|cmpt_base
argument_list|,
name|INIT_HCA_CMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
comment|/* UAR attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|uar_page_sz
argument_list|,
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_uar_sz
argument_list|,
name|INIT_HCA_LOG_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
comment|/* set parser VXLAN attributes */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_VXLAN_OFFLOADS
condition|)
block|{
name|u8
name|parser_params
init|=
literal|0
decl_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|parser_params
argument_list|,
name|INIT_HCA_VXLAN_OFFSET
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_HCA
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INIT_HCA returns %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|__be32
modifier|*
name|outbox
decl_stmt|;
name|u32
name|dword_field
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u8
name|byte_field
decl_stmt|;
specifier|static
specifier|const
name|u8
name|a0_dmfs_query_hw_steering
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
name|MLX4_STEERING_DMFS_A0_DEFAULT
block|,
index|[
literal|1
index|]
operator|=
name|MLX4_STEERING_DMFS_A0_DYNAMIC
block|,
index|[
literal|2
index|]
operator|=
name|MLX4_STEERING_DMFS_A0_STATIC
block|,
index|[
literal|3
index|]
operator|=
name|MLX4_STEERING_DMFS_A0_DISABLE
block|}
decl_stmt|;
define|#
directive|define
name|QUERY_HCA_GLOBAL_CAPS_OFFSET
value|0x04
define|#
directive|define
name|QUERY_HCA_CORE_CLOCK_OFFSET
value|0x0c
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_HCA
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|global_caps
argument_list|,
name|outbox
argument_list|,
name|QUERY_HCA_GLOBAL_CAPS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|hca_core_clock
argument_list|,
name|outbox
argument_list|,
name|QUERY_HCA_CORE_CLOCK_OFFSET
argument_list|)
expr_stmt|;
comment|/* QPC/EEC/CQC/EQC/RDMARC attributes */
name|MLX4_GET
argument_list|(
name|param
operator|->
name|qpc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_QPC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_qps
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_QP_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|srqc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_SRQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_srqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|cqc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_CQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_cqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_CQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|altc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_ALTC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|auxc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_AUXC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|eqc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_EQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_eqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_EQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|num_sys_eqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_NUM_SYS_EQS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|rdmarc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_RDMARC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_rd_per_qp
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_RD_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dword_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dword_field
operator|&
operator|(
literal|1
operator|<<
name|INIT_HCA_DEVICE_MANAGED_FLOW_STEERING_EN
operator|)
condition|)
block|{
name|param
operator|->
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
expr_stmt|;
block|}
else|else
block|{
name|MLX4_GET
argument_list|(
name|byte_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_UC_STEERING_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_field
operator|&
literal|0x8
condition|)
name|param
operator|->
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_B0
expr_stmt|;
else|else
name|param
operator|->
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_A0
expr_stmt|;
block|}
if|if
condition|(
name|dword_field
operator|&
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
name|param
operator|->
name|rss_ip_frags
operator|=
literal|1
expr_stmt|;
comment|/* steering attributes */
if|if
condition|(
name|param
operator|->
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|MLX4_GET
argument_list|(
name|param
operator|->
name|mc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FS_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FS_LOG_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FS_LOG_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|byte_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FS_A0_OFFSET
argument_list|)
expr_stmt|;
name|param
operator|->
name|dmfs_high_steer_mode
operator|=
name|a0_dmfs_query_hw_steering
index|[
operator|(
name|byte_field
operator|>>
literal|6
operator|)
operator|&
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|MLX4_GET
argument_list|(
name|param
operator|->
name|mc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_MC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_hash_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
block|}
comment|/* CX3 is capable of extending CQEs/EQEs from 32 to 64 bytes */
name|MLX4_GET
argument_list|(
name|byte_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_EQE_CQE_OFFSETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_field
operator|&
literal|0x20
condition|)
comment|/* 64-bytes eqe enabled */
name|param
operator|->
name|dev_cap_enabled
operator||=
name|MLX4_DEV_CAP_64B_EQE_ENABLED
expr_stmt|;
if|if
condition|(
name|byte_field
operator|&
literal|0x40
condition|)
comment|/* 64-bytes cqe enabled */
name|param
operator|->
name|dev_cap_enabled
operator||=
name|MLX4_DEV_CAP_64B_CQE_ENABLED
expr_stmt|;
comment|/* CX3 is capable of extending CQEs\EQEs to strides larger than 64B */
name|MLX4_GET
argument_list|(
name|byte_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_EQE_CQE_STRIDE_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_field
condition|)
block|{
name|param
operator|->
name|dev_cap_enabled
operator||=
name|MLX4_DEV_CAP_EQE_STRIDE_ENABLED
expr_stmt|;
name|param
operator|->
name|dev_cap_enabled
operator||=
name|MLX4_DEV_CAP_CQE_STRIDE_ENABLED
expr_stmt|;
name|param
operator|->
name|cqe_size
operator|=
literal|1
operator|<<
operator|(
operator|(
name|byte_field
operator|&
name|MLX4_CQE_SIZE_MASK_STRIDE
operator|)
operator|+
literal|5
operator|)
expr_stmt|;
name|param
operator|->
name|eqe_size
operator|=
literal|1
operator|<<
operator|(
operator|(
operator|(
name|byte_field
operator|&
name|MLX4_EQE_SIZE_MASK_STRIDE
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|5
operator|)
expr_stmt|;
block|}
comment|/* TPT attributes */
name|MLX4_GET
argument_list|(
name|param
operator|->
name|dmpt_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_DMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|mw_enabled
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_TPT_MW_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mpt_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MPT_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|mtt_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_MTT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|cmpt_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_CMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
comment|/* UAR attributes */
name|MLX4_GET
argument_list|(
name|param
operator|->
name|uar_page_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_uar_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
comment|/* phv_check enable */
name|MLX4_GET
argument_list|(
name|byte_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_CACHELINE_SZ_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_field
operator|&
literal|0x2
condition|)
name|param
operator|->
name|phv_check_en
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_hca_core_clock_update
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|__be32
modifier|*
name|outbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"hca_core_clock mailbox allocation failed\n"
argument_list|)
expr_stmt|;
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
block|}
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_HCA
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"hca_core_clock update failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MLX4_GET
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
argument_list|,
name|outbox
argument_list|,
name|QUERY_HCA_CORE_CLOCK_OFFSET
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* for IB-type ports only in SRIOV mode. Checks that both proxy QP0  * and real QP0 are active, so that the paravirtualized QP0 is ready  * to operate */
end_comment

begin_function
specifier|static
name|int
name|check_qp0_state
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|function
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* irrelevant if not infiniband */
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|proxy_qp0_active
operator|&&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|qp0_active
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_PORT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|mlx4_slave_convert_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port
index|]
operator|!=
name|MLX4_PORT_TYPE_IB
condition|)
block|{
comment|/* Enable port only if it was previously disabled */
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|check_qp0_state
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
operator|&&
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
block|}
else|else
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
operator|++
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_PORT
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|flags
decl_stmt|;
name|u16
name|field
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_OLD_PORT_CMDS
condition|)
block|{
define|#
directive|define
name|INIT_PORT_IN_SIZE
value|256
define|#
directive|define
name|INIT_PORT_FLAGS_OFFSET
value|0x00
define|#
directive|define
name|INIT_PORT_FLAG_SIG
value|(1<< 18)
define|#
directive|define
name|INIT_PORT_FLAG_NG
value|(1<< 17)
define|#
directive|define
name|INIT_PORT_FLAG_G0
value|(1<< 16)
define|#
directive|define
name|INIT_PORT_VL_SHIFT
value|4
define|#
directive|define
name|INIT_PORT_PORT_WIDTH_SHIFT
value|8
define|#
directive|define
name|INIT_PORT_MTU_OFFSET
value|0x04
define|#
directive|define
name|INIT_PORT_MAX_GID_OFFSET
value|0x06
define|#
directive|define
name|INIT_PORT_MAX_PKEY_OFFSET
value|0x0a
define|#
directive|define
name|INIT_PORT_GUID0_OFFSET
value|0x10
define|#
directive|define
name|INIT_PORT_NODE_GUID_OFFSET
value|0x18
define|#
directive|define
name|INIT_PORT_SI_GUID_OFFSET
value|0x20
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|vl_cap
index|[
name|port
index|]
operator|&
literal|0xf
operator|)
operator|<<
name|INIT_PORT_VL_SHIFT
expr_stmt|;
name|flags
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|port_width_cap
index|[
name|port
index|]
operator|&
literal|0xf
operator|)
operator|<<
name|INIT_PORT_PORT_WIDTH_SHIFT
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|flags
argument_list|,
name|INIT_PORT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
literal|128
operator|<<
name|dev
operator|->
name|caps
operator|.
name|ib_mtu_cap
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MTU_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|mlx4_hca_core_clock_update
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_INIT_PORT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_CLOSE_PORT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|mlx4_slave_convert_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port
index|]
operator|!=
name|MLX4_PORT_TYPE_IB
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CLOSE_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* infiniband port */
if|if
condition|(
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|qp0_active
operator|&&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CLOSE_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
operator|--
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_CLOSE_PORT
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CLOSE_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_CLOSE_PORT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_CLOSE_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|panic
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|panic
argument_list|,
name|MLX4_CMD_CLOSE_HCA
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|mlx4_config_dev
block|{
name|__be32
name|update_flags
decl_stmt|;
name|__be32
name|rsvd1
index|[
literal|3
index|]
decl_stmt|;
name|__be16
name|vxlan_udp_dport
decl_stmt|;
name|__be16
name|rsvd2
decl_stmt|;
name|__be16
name|roce_v2_entropy
decl_stmt|;
name|__be16
name|roce_v2_udp_dport
decl_stmt|;
name|__be32
name|roce_flags
decl_stmt|;
name|__be32
name|rsvd4
index|[
literal|25
index|]
decl_stmt|;
name|__be16
name|rsvd5
decl_stmt|;
name|u8
name|rsvd6
decl_stmt|;
name|u8
name|rx_checksum_val
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MLX4_VXLAN_UDP_DPORT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|MLX4_ROCE_V2_UDP_DPORT
value|BIT(3)
end_define

begin_define
define|#
directive|define
name|MLX4_DISABLE_RX_PORT
value|BIT(18)
end_define

begin_function
specifier|static
name|int
name|mlx4_CONFIG_DEV_set
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_config_dev
modifier|*
name|config_dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|memcpy
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
name|config_dev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config_dev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CONFIG_DEV
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_CONFIG_DEV_get
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_config_dev
modifier|*
name|config_dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_CONFIG_DEV
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|memcpy
argument_list|(
name|config_dev
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config_dev
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Conversion between the HW values and the actual functionality.  * The value represented by the array index,  * and the functionality determined by the flags.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|config_dev_csum_flags
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
literal|0
block|,
index|[
literal|1
index|]
operator|=
name|MLX4_RX_CSUM_MODE_VAL_NON_TCP_UDP
block|,
index|[
literal|2
index|]
operator|=
name|MLX4_RX_CSUM_MODE_VAL_NON_TCP_UDP
operator||
name|MLX4_RX_CSUM_MODE_L4
block|,
index|[
literal|3
index|]
operator|=
name|MLX4_RX_CSUM_MODE_L4
operator||
name|MLX4_RX_CSUM_MODE_IP_OK_IP_NON_TCP_UDP
operator||
name|MLX4_RX_CSUM_MODE_MULTI_VLAN
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mlx4_config_dev_retrieval
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_config_dev_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|mlx4_config_dev
name|config_dev
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u8
name|csum_mask
decl_stmt|;
define|#
directive|define
name|CONFIG_DEV_RX_CSUM_MODE_MASK
value|0x7
define|#
directive|define
name|CONFIG_DEV_RX_CSUM_MODE_PORT1_BIT_OFFSET
value|0
define|#
directive|define
name|CONFIG_DEV_RX_CSUM_MODE_PORT2_BIT_OFFSET
value|4
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_CONFIG_DEV
operator|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
name|err
operator|=
name|mlx4_CONFIG_DEV_get
argument_list|(
name|dev
argument_list|,
operator|&
name|config_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|csum_mask
operator|=
operator|(
name|config_dev
operator|.
name|rx_checksum_val
operator|>>
name|CONFIG_DEV_RX_CSUM_MODE_PORT1_BIT_OFFSET
operator|)
operator|&
name|CONFIG_DEV_RX_CSUM_MODE_MASK
expr_stmt|;
if|if
condition|(
name|csum_mask
operator|>=
sizeof|sizeof
argument_list|(
name|config_dev_csum_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|config_dev_csum_flags
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|params
operator|->
name|rx_csum_flags_port_1
operator|=
name|config_dev_csum_flags
index|[
name|csum_mask
index|]
expr_stmt|;
name|csum_mask
operator|=
operator|(
name|config_dev
operator|.
name|rx_checksum_val
operator|>>
name|CONFIG_DEV_RX_CSUM_MODE_PORT2_BIT_OFFSET
operator|)
operator|&
name|CONFIG_DEV_RX_CSUM_MODE_MASK
expr_stmt|;
if|if
condition|(
name|csum_mask
operator|>=
sizeof|sizeof
argument_list|(
name|config_dev_csum_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|config_dev_csum_flags
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|params
operator|->
name|rx_csum_flags_port_2
operator|=
name|config_dev_csum_flags
index|[
name|csum_mask
index|]
expr_stmt|;
name|params
operator|->
name|vxlan_udp_dport
operator|=
name|be16_to_cpu
argument_list|(
name|config_dev
operator|.
name|vxlan_udp_dport
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_config_dev_retrieval
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_config_vxlan_port
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|__be16
name|udp_port
parameter_list|)
block|{
name|struct
name|mlx4_config_dev
name|config_dev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|config_dev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|config_dev
argument_list|)
argument_list|)
expr_stmt|;
name|config_dev
operator|.
name|update_flags
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_VXLAN_UDP_DPORT
argument_list|)
expr_stmt|;
name|config_dev
operator|.
name|vxlan_udp_dport
operator|=
name|udp_port
expr_stmt|;
return|return
name|mlx4_CONFIG_DEV_set
argument_list|(
name|dev
argument_list|,
operator|&
name|config_dev
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_config_vxlan_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CONFIG_DISABLE_RX_PORT
value|BIT(15)
end_define

begin_function
name|int
name|mlx4_disable_rx_port_check
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|bool
name|dis
parameter_list|)
block|{
name|struct
name|mlx4_config_dev
name|config_dev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|config_dev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|config_dev
argument_list|)
argument_list|)
expr_stmt|;
name|config_dev
operator|.
name|update_flags
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_DISABLE_RX_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dis
condition|)
name|config_dev
operator|.
name|roce_flags
operator|=
name|cpu_to_be32
argument_list|(
name|CONFIG_DISABLE_RX_PORT
argument_list|)
expr_stmt|;
return|return
name|mlx4_CONFIG_DEV_set
argument_list|(
name|dev
argument_list|,
operator|&
name|config_dev
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_config_roce_v2_port
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|udp_port
parameter_list|)
block|{
name|struct
name|mlx4_config_dev
name|config_dev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|config_dev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|config_dev
argument_list|)
argument_list|)
expr_stmt|;
name|config_dev
operator|.
name|update_flags
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_ROCE_V2_UDP_DPORT
argument_list|)
expr_stmt|;
name|config_dev
operator|.
name|roce_v2_udp_dport
operator|=
name|cpu_to_be16
argument_list|(
name|udp_port
argument_list|)
expr_stmt|;
return|return
name|mlx4_CONFIG_DEV_set
argument_list|(
name|dev
argument_list|,
operator|&
name|config_dev
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_config_roce_v2_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_virt2phy_port_map
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|port1
parameter_list|,
name|u32
name|port2
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
struct|struct
block|{
name|__be32
name|v_port1
decl_stmt|;
name|__be32
name|v_port2
decl_stmt|;
block|}
modifier|*
name|v2p
struct|;
name|int
name|err
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|v2p
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|v2p
operator|->
name|v_port1
operator|=
name|cpu_to_be32
argument_list|(
name|port1
argument_list|)
expr_stmt|;
name|v2p
operator|->
name|v_port2
operator|=
name|cpu_to_be32
argument_list|(
name|port2
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
name|MLX4_SET_PORT_VIRT2PHY
argument_list|,
name|MLX4_CMD_VIRT_PORT_MAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SET_ICM_SIZE
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|icm_size
parameter_list|,
name|u64
modifier|*
name|aux_pages
parameter_list|)
block|{
name|int
name|ret
init|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
name|icm_size
argument_list|,
name|aux_pages
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_SET_ICM_SIZE
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* 	 * Round up number of system pages needed in case 	 * MLX4_ICM_PAGE_SIZE< PAGE_SIZE. 	 */
operator|*
name|aux_pages
operator|=
name|ALIGN
argument_list|(
operator|*
name|aux_pages
argument_list|,
name|PAGE_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_NOP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
comment|/* Input modifier of 0x1f means "finish as soon as possible." */
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_NOP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_query_diag_counters
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
specifier|const
name|u32
name|offset
index|[]
parameter_list|,
name|u32
name|value
index|[]
parameter_list|,
name|size_t
name|array_len
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|ret
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
name|op_modifier
argument_list|,
name|MLX4_CMD_DIAG_RPRT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
index|[
name|i
index|]
operator|>
name|MLX4_MAILBOX_SIZE
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MLX4_GET
argument_list|(
name|value
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|offset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_query_diag_counters
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_get_phys_port_id
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|u8
name|port
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
name|in_mod
decl_stmt|;
name|u32
name|guid_hi
decl_stmt|,
name|guid_lo
decl_stmt|;
name|int
name|err
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MOD_STAT_CFG_PORT_OFFSET
value|8
define|#
directive|define
name|MOD_STAT_CFG_GUID_H
value|0X14
define|#
directive|define
name|MOD_STAT_CFG_GUID_L
value|0X1c
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|in_mod
operator|=
name|port
operator|<<
name|MOD_STAT_CFG_PORT_OFFSET
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_mod
argument_list|,
literal|0x2
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Fail to get port %d uplink guid\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ret
operator|=
name|err
expr_stmt|;
block|}
else|else
block|{
name|MLX4_GET
argument_list|(
name|guid_hi
argument_list|,
name|outbox
argument_list|,
name|MOD_STAT_CFG_GUID_H
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|guid_lo
argument_list|,
name|outbox
argument_list|,
name|MOD_STAT_CFG_GUID_L
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|phys_port_id
index|[
name|port
index|]
operator|=
operator|(
name|u64
operator|)
name|guid_lo
operator||
operator|(
name|u64
operator|)
name|guid_hi
operator|<<
literal|32
expr_stmt|;
block|}
block|}
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_WOL_SETUP_MODE
value|(5<< 28)
end_define

begin_function
name|int
name|mlx4_wol_read
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
modifier|*
name|config
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|in_mod
init|=
name|MLX4_WOL_SETUP_MODE
operator||
name|port
operator|<<
literal|8
decl_stmt|;
return|return
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|config
argument_list|,
name|in_mod
argument_list|,
literal|0x3
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_wol_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_wol_write
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|config
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|in_mod
init|=
name|MLX4_WOL_SETUP_MODE
operator||
name|port
operator|<<
literal|8
decl_stmt|;
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|config
argument_list|,
name|in_mod
argument_list|,
literal|0x1
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_wol_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|ADD_TO_MCG
init|=
literal|0x26
block|, }
enum|;
end_enum

begin_function
name|void
name|mlx4_opreq_action
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|opreq_task
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
operator|&
name|priv
operator|->
name|dev
decl_stmt|;
name|int
name|num_tasks
init|=
name|atomic_read
argument_list|(
operator|&
name|priv
operator|->
name|opreq_count
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u32
name|modifier
decl_stmt|;
name|u16
name|token
decl_stmt|;
name|u16
name|type
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|num_qps
decl_stmt|;
name|struct
name|mlx4_qp
name|qp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u8
name|rem_mcg
decl_stmt|;
name|u8
name|prot
decl_stmt|;
define|#
directive|define
name|GET_OP_REQ_MODIFIER_OFFSET
value|0x08
define|#
directive|define
name|GET_OP_REQ_TOKEN_OFFSET
value|0x14
define|#
directive|define
name|GET_OP_REQ_TYPE_OFFSET
value|0x1a
define|#
directive|define
name|GET_OP_REQ_DATA_OFFSET
value|0x20
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate mailbox for GET_OP_REQ\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|num_tasks
condition|)
block|{
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_GET_OP_REQ
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to retrieve required operation: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|MLX4_GET
argument_list|(
name|modifier
argument_list|,
name|outbox
argument_list|,
name|GET_OP_REQ_MODIFIER_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|token
argument_list|,
name|outbox
argument_list|,
name|GET_OP_REQ_TOKEN_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|type
argument_list|,
name|outbox
argument_list|,
name|GET_OP_REQ_TYPE_OFFSET
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xfff
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ADD_TO_MCG
case|:
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"ADD MCG operation is not supported in DEVICE_MANAGED steering mode\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
name|mgm
operator|=
operator|(
expr|struct
name|mlx4_mgm
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|outbox
operator|)
operator|+
name|GET_OP_REQ_DATA_OFFSET
operator|)
expr_stmt|;
name|num_qps
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
name|MGM_QPN_MASK
expr_stmt|;
name|rem_mcg
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
operator|&
name|mgm
operator|->
name|members_count
operator|)
operator|)
index|[
literal|0
index|]
operator|&
literal|1
expr_stmt|;
name|prot
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
operator|&
name|mgm
operator|->
name|members_count
operator|)
operator|)
index|[
literal|0
index|]
operator|>>
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_qps
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|.
name|qpn
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|qp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem_mcg
condition|)
name|err
operator|=
name|mlx4_multicast_detach
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|mgm
operator|->
name|gid
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|mlx4_multicast_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|mgm
operator|->
name|gid
argument_list|,
name|mgm
operator|->
name|gid
index|[
literal|5
index|]
argument_list|,
literal|0
argument_list|,
name|prot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
break|break;
default|default:
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Bad type for required operation\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|u32
operator|)
name|err
operator||
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|token
argument_list|)
operator|<<
literal|16
operator|)
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_GET_OP_REQ
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to acknowledge required request: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
name|outbox
argument_list|,
literal|0
argument_list|,
literal|0xffc
argument_list|)
expr_stmt|;
name|num_tasks
operator|=
name|atomic_dec_return
argument_list|(
operator|&
name|priv
operator|->
name|opreq_count
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_check_smp_firewall_active
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|)
block|{
define|#
directive|define
name|MLX4_CMD_MAD_DEMUX_SET_ATTR_OFFSET
value|0x10
define|#
directive|define
name|MLX4_CMD_MAD_DEMUX_GETRESP_ATTR_OFFSET
value|0x20
define|#
directive|define
name|MLX4_CMD_MAD_DEMUX_TRAP_ATTR_OFFSET
value|0x40
define|#
directive|define
name|MLX4_CMD_MAD_DEMUX_TRAP_REPRESS_ATTR_OFFSET
value|0x70
name|u32
name|set_attr_mask
decl_stmt|,
name|getresp_attr_mask
decl_stmt|;
name|u32
name|trap_attr_mask
decl_stmt|,
name|traprepress_attr_mask
decl_stmt|;
name|MLX4_GET
argument_list|(
name|set_attr_mask
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|,
name|MLX4_CMD_MAD_DEMUX_SET_ATTR_OFFSET
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"SMP firewall set_attribute_mask = 0x%x\n"
argument_list|,
name|set_attr_mask
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|getresp_attr_mask
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|,
name|MLX4_CMD_MAD_DEMUX_GETRESP_ATTR_OFFSET
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"SMP firewall getresp_attribute_mask = 0x%x\n"
argument_list|,
name|getresp_attr_mask
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|trap_attr_mask
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|,
name|MLX4_CMD_MAD_DEMUX_TRAP_ATTR_OFFSET
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"SMP firewall trap_attribute_mask = 0x%x\n"
argument_list|,
name|trap_attr_mask
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|traprepress_attr_mask
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|,
name|MLX4_CMD_MAD_DEMUX_TRAP_REPRESS_ATTR_OFFSET
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"SMP firewall traprepress_attribute_mask = 0x%x\n"
argument_list|,
name|traprepress_attr_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_attr_mask
operator|&&
name|getresp_attr_mask
operator|&&
name|trap_attr_mask
operator|&&
name|traprepress_attr_mask
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_config_mad_demux
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Check if mad_demux is supported */
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_MAD_DEMUX
operator|)
condition|)
return|return
literal|0
return|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate mailbox for cmd MAD_DEMUX"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
comment|/* Query mad_demux to find out which MADs are handled by internal sma */
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0x01
comment|/* subn mgmt class */
argument_list|,
name|MLX4_CMD_MAD_DEMUX_QUERY_RESTR
argument_list|,
name|MLX4_CMD_MAD_DEMUX
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"MLX4_CMD_MAD_DEMUX: query restrictions failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mlx4_check_smp_firewall_active
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
condition|)
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SECURE_HOST
expr_stmt|;
comment|/* Config mad_demux to handle all MADs returned by the query above */
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0x01
comment|/* subn mgmt class */
argument_list|,
name|MLX4_CMD_MAD_DEMUX_CONFIG
argument_list|,
name|MLX4_CMD_MAD_DEMUX
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"MLX4_CMD_MAD_DEMUX: configure failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SECURE_HOST
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"HCA operating in secure-host mode. SMP firewall activated.\n"
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Access Reg commands */
end_comment

begin_enum
enum|enum
name|mlx4_access_reg_masks
block|{
name|MLX4_ACCESS_REG_STATUS_MASK
init|=
literal|0x7f
block|,
name|MLX4_ACCESS_REG_METHOD_MASK
init|=
literal|0x7f
block|,
name|MLX4_ACCESS_REG_LEN_MASK
init|=
literal|0x7ff
block|}
enum|;
end_enum

begin_struct
struct|struct
name|mlx4_access_reg
block|{
name|__be16
name|constant1
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|u8
name|resrvd1
decl_stmt|;
name|__be16
name|reg_id
decl_stmt|;
name|u8
name|method
decl_stmt|;
name|u8
name|constant2
decl_stmt|;
name|__be32
name|resrvd2
index|[
literal|2
index|]
decl_stmt|;
name|__be16
name|len_const
decl_stmt|;
name|__be16
name|resrvd3
decl_stmt|;
define|#
directive|define
name|MLX4_ACCESS_REG_HEADER_SIZE
value|(20)
name|u8
name|reg_data
index|[
name|MLX4_MAILBOX_SIZE
operator|-
name|MLX4_ACCESS_REG_HEADER_SIZE
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|__packed__
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/**  * mlx4_ACCESS_REG - Generic access reg command.  * @dev: mlx4_dev.  * @reg_id: register ID to access.  * @method: Access method Read/Write.  * @reg_len: register length to Read/Write in bytes.  * @reg_data: reg_data pointer to Read/Write From/To.  *  * Access ConnectX registers FW command.  * Returns 0 on success and copies outbox mlx4_access_reg data  * field into reg_data or a negative error code.  */
end_comment

begin_function
specifier|static
name|int
name|mlx4_ACCESS_REG
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|reg_id
parameter_list|,
name|enum
name|mlx4_access_reg_method
name|method
parameter_list|,
name|u16
name|reg_len
parameter_list|,
name|void
modifier|*
name|reg_data
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
decl_stmt|,
modifier|*
name|outbox
decl_stmt|;
name|struct
name|mlx4_access_reg
modifier|*
name|inbuf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|inbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|inbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|inbox
argument_list|)
return|;
name|outbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|outbox
argument_list|)
condition|)
block|{
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
return|return
name|PTR_ERR
argument_list|(
name|outbox
argument_list|)
return|;
block|}
name|inbuf
operator|=
name|inbox
operator|->
name|buf
expr_stmt|;
name|outbuf
operator|=
name|outbox
operator|->
name|buf
expr_stmt|;
name|inbuf
operator|->
name|constant1
operator|=
name|cpu_to_be16
argument_list|(
literal|0x1
operator|<<
literal|11
operator||
literal|0x4
argument_list|)
expr_stmt|;
name|inbuf
operator|->
name|constant2
operator|=
literal|0x1
expr_stmt|;
name|inbuf
operator|->
name|reg_id
operator|=
name|cpu_to_be16
argument_list|(
name|reg_id
argument_list|)
expr_stmt|;
name|inbuf
operator|->
name|method
operator|=
name|method
operator|&
name|MLX4_ACCESS_REG_METHOD_MASK
expr_stmt|;
name|reg_len
operator|=
name|min
argument_list|(
name|reg_len
argument_list|,
call|(
name|u16
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|inbuf
operator|->
name|reg_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|inbuf
operator|->
name|len_const
operator|=
name|cpu_to_be16
argument_list|(
operator|(
operator|(
name|reg_len
operator|/
literal|4
operator|+
literal|1
operator|)
operator|&
name|MLX4_ACCESS_REG_LEN_MASK
operator|)
operator||
operator|(
operator|(
literal|0x3
operator|)
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|inbuf
operator|->
name|reg_data
argument_list|,
name|reg_data
argument_list|,
name|reg_len
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_ACCESS_REG
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|outbuf
operator|->
name|status
operator|&
name|MLX4_ACCESS_REG_STATUS_MASK
condition|)
block|{
name|err
operator|=
name|outbuf
operator|->
name|status
operator|&
name|MLX4_ACCESS_REG_STATUS_MASK
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MLX4_CMD_ACCESS_REG(%x) returned REG status (%x)\n"
argument_list|,
name|reg_id
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memcpy
argument_list|(
name|reg_data
argument_list|,
name|outbuf
operator|->
name|reg_data
argument_list|,
name|reg_len
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|inbox
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|outbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ConnectX registers IDs */
end_comment

begin_enum
enum|enum
name|mlx4_reg_id
block|{
name|MLX4_REG_ID_PTYS
init|=
literal|0x5004
block|, }
enum|;
end_enum

begin_comment
comment|/**  * mlx4_ACCESS_PTYS_REG - Access PTYs (Port Type and Speed)  * register  * @dev: mlx4_dev.  * @method: Access method Read/Write.  * @ptys_reg: PTYS register data pointer.  *  * Access ConnectX PTYS register, to Read/Write Port Type/Speed  * configuration  * Returns 0 on success or a negative error code.  */
end_comment

begin_function
name|int
name|mlx4_ACCESS_PTYS_REG
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_access_reg_method
name|method
parameter_list|,
name|struct
name|mlx4_ptys_reg
modifier|*
name|ptys_reg
parameter_list|)
block|{
return|return
name|mlx4_ACCESS_REG
argument_list|(
name|dev
argument_list|,
name|MLX4_REG_ID_PTYS
argument_list|,
name|method
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptys_reg
argument_list|)
argument_list|,
name|ptys_reg
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_ACCESS_PTYS_REG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_ACCESS_REG_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_access_reg
modifier|*
name|inbuf
init|=
name|inbox
operator|->
name|buf
decl_stmt|;
name|u8
name|method
init|=
name|inbuf
operator|->
name|method
operator|&
name|MLX4_ACCESS_REG_METHOD_MASK
decl_stmt|;
name|u16
name|reg_id
init|=
name|be16_to_cpu
argument_list|(
name|inbuf
operator|->
name|reg_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|slave
operator|!=
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
operator|&&
name|method
operator|==
name|MLX4_ACCESS_REG_WRITE
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|reg_id
operator|==
name|MLX4_REG_ID_PTYS
condition|)
block|{
name|struct
name|mlx4_ptys_reg
modifier|*
name|ptys_reg
init|=
operator|(
expr|struct
name|mlx4_ptys_reg
operator|*
operator|)
name|inbuf
operator|->
name|reg_data
decl_stmt|;
name|ptys_reg
operator|->
name|local_port
operator|=
name|mlx4_slave_convert_port
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|ptys_reg
operator|->
name|local_port
argument_list|)
expr_stmt|;
block|}
return|return
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
name|inbox
operator|->
name|dma
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_ACCESS_REG
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_SET_PORT_phv_bit
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u8
name|phv_bit
parameter_list|)
block|{
define|#
directive|define
name|SET_PORT_GEN_PHV_VALID
value|0x10
define|#
directive|define
name|SET_PORT_GEN_PHV_EN
value|0x80
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_set_port_general_context
modifier|*
name|context
decl_stmt|;
name|u32
name|in_mod
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|context
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|context
operator|->
name|v_ignore_fcs
operator||=
name|SET_PORT_GEN_PHV_VALID
expr_stmt|;
if|if
condition|(
name|phv_bit
condition|)
name|context
operator|->
name|phv_en
operator||=
name|SET_PORT_GEN_PHV_EN
expr_stmt|;
name|in_mod
operator|=
name|MLX4_SET_PORT_GENERAL
operator|<<
literal|8
operator||
name|port
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_mod
argument_list|,
name|MLX4_SET_PORT_ETH_OPCODE
argument_list|,
name|MLX4_CMD_SET_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|get_phv_bit
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
modifier|*
name|phv
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_func_cap
name|func_cap
decl_stmt|;
name|memset
argument_list|(
operator|&
name|func_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|func_cap
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_FUNC_CAP
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|func_cap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|phv
operator|=
name|func_cap
operator|.
name|flags0
operator|&
name|QUERY_FUNC_CAP_PHV_BIT
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|get_phv_bit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|set_phv_bit
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|new_val
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_PHV_EN
operator|&&
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SKIP_OUTER_VLAN
operator|)
condition|)
block|{
name|ret
operator|=
name|mlx4_SET_PORT_phv_bit
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|new_val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|dev
operator|->
name|caps
operator|.
name|phv_bit
index|[
name|port
index|]
operator|=
name|new_val
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
operator|-
name|EOPNOTSUPP
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|set_phv_bit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_replace_zero_macs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
name|mac_addr
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|dev
operator|->
name|port_random_macs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|i
index|]
operator|&&
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
block|{
name|random_ether_addr
argument_list|(
name|mac_addr
argument_list|)
expr_stmt|;
name|dev
operator|->
name|port_random_macs
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|i
index|]
operator|=
name|mlx4_mac_to_u64
argument_list|(
name|mac_addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_replace_zero_macs
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

