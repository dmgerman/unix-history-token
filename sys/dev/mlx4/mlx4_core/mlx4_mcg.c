begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006, 2007 Cisco Systems, Inc.  All rights reserved.  * Copyright (c) 2007, 2008, 2014 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/printk.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_function
name|int
name|mlx4_get_mgm_entry_size
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|1
operator|<<
name|dev
operator|->
name|oper_log_mgm_entry_size
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_qp_per_mgm
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|4
operator|*
operator|(
name|mlx4_get_mgm_entry_size
argument_list|(
name|dev
argument_list|)
operator|/
literal|16
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_QP_FLOW_STEERING_ATTACH
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|,
name|u32
name|size
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
name|u64
name|imm
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
operator|&
name|imm
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_ATTACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|*
name|reg_id
operator|=
name|imm
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_QP_FLOW_STEERING_DETACH
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|regid
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|regid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_QP_FLOW_STEERING_DETACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_READ_ENTRY
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|)
block|{
return|return
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|index
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_READ_MCG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_WRITE_ENTRY
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|index
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_WRITE_MCG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_WRITE_PROMISC
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u8
name|steer
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|)
block|{
name|u32
name|in_mod
decl_stmt|;
name|in_mod
operator|=
operator|(
name|u32
operator|)
name|port
operator|<<
literal|16
operator||
name|steer
operator|<<
literal|1
expr_stmt|;
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_mod
argument_list|,
literal|0x1
argument_list|,
name|MLX4_CMD_WRITE_MCG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_GID_HASH
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|,
name|u16
modifier|*
name|hash
parameter_list|,
name|u8
name|op_mod
parameter_list|)
block|{
name|u64
name|imm
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
operator|&
name|imm
argument_list|,
literal|0
argument_list|,
name|op_mod
argument_list|,
name|MLX4_CMD_MGID_HASH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|hash
operator|=
name|imm
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mlx4_promisc_qp
modifier|*
name|get_promisc_qp
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|u32
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
name|NULL
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|pqp
argument_list|,
argument|&s_steer->promisc_qps[steer]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|pqp
operator|->
name|qpn
operator|==
name|qpn
condition|)
return|return
name|pqp
return|;
block|}
comment|/* not found */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Add new entry to steering data structure.  * All promisc QPs should be added as well  */
end_comment

begin_function
specifier|static
name|int
name|new_steering_entry
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|u32
name|members_count
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|new_entry
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|dqp
init|=
name|NULL
decl_stmt|;
name|u32
name|prot
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
operator|-
name|EINVAL
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|new_entry
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|new_entry
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_entry
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|new_entry
operator|->
name|duplicates
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_entry
operator|->
name|list
argument_list|,
operator|&
name|s_steer
operator|->
name|steer_entries
index|[
name|steer
index|]
argument_list|)
expr_stmt|;
comment|/* If the given qpn is also a promisc qp, 	 * it should be inserted to duplicates list 	 */
name|pqp
operator|=
name|get_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pqp
condition|)
block|{
name|dqp
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|dqp
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dqp
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_alloc
goto|;
block|}
name|dqp
operator|->
name|qpn
operator|=
name|qpn
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|dqp
operator|->
name|list
argument_list|,
operator|&
name|new_entry
operator|->
name|duplicates
argument_list|)
expr_stmt|;
block|}
comment|/* if no promisc qps for this vep, we are done */
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|s_steer
operator|->
name|promisc_qps
index|[
name|steer
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* now need to add all the promisc qps to the new 	 * steering entry, as they should also receive the packets 	 * destined to this address */
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_alloc
goto|;
block|}
name|mgm
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
name|members_count
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|prot
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|>>
literal|30
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|pqp
argument_list|,
argument|&s_steer->promisc_qps[steer]
argument_list|,
argument|list
argument_list|)
block|{
comment|/* don't add already existing qpn */
if|if
condition|(
name|pqp
operator|->
name|qpn
operator|==
name|qpn
condition|)
continue|continue;
if|if
condition|(
name|members_count
operator|==
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
condition|)
block|{
comment|/* out of space */
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
comment|/* add the qpn */
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|++
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|pqp
operator|->
name|qpn
operator|&
name|MGM_QPN_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* update the qps count and update the entry with all the promisc qps*/
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
name|members_count
operator||
operator|(
name|prot
operator|<<
literal|30
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|out_mailbox
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
literal|0
return|;
name|out_alloc
label|:
if|if
condition|(
name|dqp
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|dqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dqp
argument_list|)
expr_stmt|;
block|}
name|list_del
argument_list|(
operator|&
name|new_entry
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|new_entry
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* update the data structures with existing steering entry */
end_comment

begin_function
specifier|static
name|int
name|existing_steering_entry
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|tmp_entry
decl_stmt|,
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|dqp
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
operator|-
name|EINVAL
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|pqp
operator|=
name|get_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pqp
condition|)
return|return
literal|0
return|;
comment|/* nothing to do */
name|list_for_each_entry
argument_list|(
argument|tmp_entry
argument_list|,
argument|&s_steer->steer_entries[steer]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|tmp_entry
operator|->
name|index
operator|==
name|index
condition|)
block|{
name|entry
operator|=
name|tmp_entry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|entry
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Steering entry at index %x is not registered\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* the given qpn is listed as a promisc qpn 	 * we need to add it as a duplicate to this entry 	 * for future references */
name|list_for_each_entry
argument_list|(
argument|dqp
argument_list|,
argument|&entry->duplicates
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|qpn
operator|==
name|dqp
operator|->
name|qpn
condition|)
return|return
literal|0
return|;
comment|/* qp is already duplicated */
block|}
comment|/* add the qp as a duplicate on this index */
name|dqp
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|dqp
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dqp
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|dqp
operator|->
name|qpn
operator|=
name|qpn
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|dqp
operator|->
name|list
argument_list|,
operator|&
name|entry
operator|->
name|duplicates
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether a qpn is a duplicate on steering entry  * If so, it should not be removed from mgm */
end_comment

begin_function
specifier|static
name|bool
name|check_duplicate_entry
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|tmp_entry
decl_stmt|,
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|dqp
decl_stmt|,
modifier|*
name|tmp_dqp
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
name|NULL
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
comment|/* if qp is not promisc, it cannot be duplicated */
if|if
condition|(
operator|!
name|get_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The qp is promisc qp so it is a duplicate on this index 	 * Find the index entry, and remove the duplicate */
name|list_for_each_entry
argument_list|(
argument|tmp_entry
argument_list|,
argument|&s_steer->steer_entries[steer]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|tmp_entry
operator|->
name|index
operator|==
name|index
condition|)
block|{
name|entry
operator|=
name|tmp_entry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|entry
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Steering entry for index %x is not registered\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|dqp
argument_list|,
argument|tmp_dqp
argument_list|,
argument|&entry->duplicates
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|dqp
operator|->
name|qpn
operator|==
name|qpn
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|dqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dqp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * returns true if all the QPs != tqpn contained in this entry  * are Promisc QPs. return false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|promisc_steering_entry
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|tqpn
parameter_list|,
name|u32
modifier|*
name|members_count
parameter_list|)
block|{
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|u32
name|m_count
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
name|false
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|false
return|;
name|mgm
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
name|mailbox
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|m_count
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
if|if
condition|(
name|members_count
condition|)
operator|*
name|members_count
operator|=
name|m_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m_count
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|qpn
init|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|qp
index|[
name|i
index|]
argument_list|)
operator|&
name|MGM_QPN_MASK
decl_stmt|;
if|if
condition|(
operator|!
name|get_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
operator|&&
name|qpn
operator|!=
name|tqpn
condition|)
block|{
comment|/* the qp is not promisc, the entry can't be removed */
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
name|true
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* IF a steering entry contains only promisc QPs, it can be removed. */
end_comment

begin_function
specifier|static
name|bool
name|can_remove_steering_entry
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|u32
name|tqpn
parameter_list|)
block|{
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|entry
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp_entry
decl_stmt|;
name|u32
name|members_count
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
name|NULL
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|promisc_steering_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|index
argument_list|,
name|tqpn
argument_list|,
operator|&
name|members_count
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* All the qps currently registered for this entry are promiscuous, 	  * Checking for duplicates */
name|ret
operator|=
name|true
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|entry
argument_list|,
argument|tmp_entry
argument_list|,
argument|&s_steer->steer_entries[steer]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|index
operator|==
name|index
condition|)
block|{
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|entry
operator|->
name|duplicates
argument_list|)
operator|||
name|members_count
operator|==
literal|1
condition|)
block|{
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|,
modifier|*
name|tmp_pqp
decl_stmt|;
comment|/* 				 * If there is only 1 entry in duplicates than 				 * this is the QP we want to delete, going over 				 * the list and deleting the entry. 				 */
name|list_del
argument_list|(
operator|&
name|entry
operator|->
name|list
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|pqp
argument_list|,
argument|tmp_pqp
argument_list|,
argument|&entry->duplicates
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This entry contains duplicates so it shouldn't be removed */
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_promisc_qp
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|u32
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|entry
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|dqp
decl_stmt|;
name|u32
name|members_count
decl_stmt|;
name|u32
name|prot
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
operator|-
name|EINVAL
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
comment|/* Noting to do, already exists */
goto|goto
name|out_mutex
goto|;
block|}
name|pqp
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pqp
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pqp
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_mutex
goto|;
block|}
name|pqp
operator|->
name|qpn
operator|=
name|qpn
expr_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_alloc
goto|;
block|}
name|mgm
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|&&
name|steer
operator|==
name|MLX4_UC_STEER
operator|)
condition|)
block|{
comment|/* the promisc qp needs to be added for each one of the steering 		 * entries, if it already exists, needs to be added as a duplicate 		 * for this entry */
name|list_for_each_entry
argument_list|(
argument|entry
argument_list|,
argument|&s_steer->steer_entries[steer]
argument_list|,
argument|list
argument_list|)
block|{
name|err
operator|=
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
name|entry
operator|->
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
name|members_count
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|prot
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|>>
literal|30
expr_stmt|;
name|found
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|members_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|qp
index|[
name|i
index|]
argument_list|)
operator|&
name|MGM_QPN_MASK
operator|)
operator|==
name|qpn
condition|)
block|{
comment|/* Entry already exists, add to duplicates */
name|dqp
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|dqp
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dqp
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
name|dqp
operator|->
name|qpn
operator|=
name|qpn
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|dqp
operator|->
name|list
argument_list|,
operator|&
name|entry
operator|->
name|duplicates
argument_list|)
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* Need to add the qpn to mgm */
if|if
condition|(
name|members_count
operator|==
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
condition|)
block|{
comment|/* entry is full */
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|++
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|qpn
operator|&
name|MGM_QPN_MASK
argument_list|)
expr_stmt|;
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
name|members_count
operator||
operator|(
name|prot
operator|<<
literal|30
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|entry
operator|->
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
block|}
block|}
block|}
comment|/* add the new qpn to list of promisc qps */
name|list_add_tail
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|,
operator|&
name|s_steer
operator|->
name|promisc_qps
index|[
name|steer
index|]
argument_list|)
expr_stmt|;
comment|/* now need to add all the promisc qps to default entry */
name|memset
argument_list|(
name|mgm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|mgm
argument_list|)
expr_stmt|;
name|members_count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|dqp
argument_list|,
argument|&s_steer->promisc_qps[steer]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|members_count
operator|==
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
condition|)
block|{
comment|/* entry is full */
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_list
goto|;
block|}
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|++
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|dqp
operator|->
name|qpn
operator|&
name|MGM_QPN_MASK
argument_list|)
expr_stmt|;
block|}
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
name|members_count
operator||
name|MLX4_PROT_ETH
operator|<<
literal|30
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_PROMISC
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_list
goto|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_list
label|:
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|out_mailbox
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|out_alloc
label|:
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
name|out_mutex
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_promisc_qp
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|u32
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_steer
modifier|*
name|s_steer
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tmp_entry
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|dqp
decl_stmt|;
name|u32
name|members_count
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|bool
name|back_to_list
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|,
name|loc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return
operator|-
name|EINVAL
return|;
name|s_steer
operator|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|steer
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|pqp
operator|=
name|get_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|pqp
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"QP %x is not promiscuous QP\n"
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
comment|/* nothing to do */
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_mutex
goto|;
block|}
comment|/*remove from list of promisc qps */
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* set the default entry not to include the removed one */
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|back_to_list
operator|=
name|true
expr_stmt|;
goto|goto
name|out_list
goto|;
block|}
name|mgm
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memset
argument_list|(
name|mgm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|mgm
argument_list|)
expr_stmt|;
name|members_count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|dqp
argument_list|,
argument|&s_steer->promisc_qps[steer]
argument_list|,
argument|list
argument_list|)
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|++
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|dqp
operator|->
name|qpn
operator|&
name|MGM_QPN_MASK
argument_list|)
expr_stmt|;
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
name|members_count
operator||
name|MLX4_PROT_ETH
operator|<<
literal|30
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_PROMISC
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
if|if
condition|(
operator|!
operator|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|&&
name|steer
operator|==
name|MLX4_UC_STEER
operator|)
condition|)
block|{
comment|/* remove the qp from all the steering entries*/
name|list_for_each_entry_safe
argument_list|(
argument|entry
argument_list|,
argument|tmp_entry
argument_list|,
argument|&s_steer->steer_entries[steer]
argument_list|,
argument|list
argument_list|)
block|{
name|found
operator|=
name|false
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|dqp
argument_list|,
argument|&entry->duplicates
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|dqp
operator|->
name|qpn
operator|==
name|qpn
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|/* a duplicate, no need to change the mgm, 				 * only update the duplicates list */
name|list_del
argument_list|(
operator|&
name|dqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dqp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
name|entry
operator|->
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
name|members_count
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
if|if
condition|(
operator|!
name|members_count
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"QP %06x wasn't found in entry %x mcount=0."
literal|" deleting entry...\n"
argument_list|,
name|qpn
argument_list|,
name|entry
operator|->
name|index
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|entry
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|members_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|qp
index|[
name|i
index|]
argument_list|)
operator|&
name|MGM_QPN_MASK
operator|)
operator|==
name|qpn
condition|)
block|{
name|loc
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|loc
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QP %06x wasn't found in entry %d\n"
argument_list|,
name|qpn
argument_list|,
name|entry
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
comment|/* copy the last QP in this MGM over removed QP */
name|mgm
operator|->
name|qp
index|[
name|loc
index|]
operator|=
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|-
literal|1
index|]
expr_stmt|;
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
operator|--
name|members_count
operator||
operator|(
name|MLX4_PROT_ETH
operator|<<
literal|30
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|entry
operator|->
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
block|}
block|}
block|}
name|out_mailbox
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|out_list
label|:
if|if
condition|(
name|back_to_list
condition|)
name|list_add_tail
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|,
operator|&
name|s_steer
operator|->
name|promisc_qps
index|[
name|steer
index|]
argument_list|)
expr_stmt|;
else|else
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
name|out_mutex
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Caller must hold MCG table semaphore.  gid and mgm parameters must  * be properly aligned for command interface.  *  *  Returns 0 unless a firmware command error occurs.  *  * If GID is found in MGM or MGM is empty, *index = *hash, *prev = -1  * and *mgm holds MGM entry.  *  * if GID is found in AMGM, *index = index in AMGM, *prev = index of  * previous entry in hash chain and *mgm holds AMGM entry.  *  * If no AMGM exists for given gid, *index = -1, *prev = index of last  * entry in hash chain and *mgm holds end of hash chain.  */
end_comment

begin_function
specifier|static
name|int
name|find_entry
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u8
modifier|*
name|gid
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mgm_mailbox
parameter_list|,
name|int
modifier|*
name|prev
parameter_list|,
name|int
modifier|*
name|index
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
init|=
name|mgm_mailbox
operator|->
name|buf
decl_stmt|;
name|u8
modifier|*
name|mgid
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u16
name|hash
decl_stmt|;
name|u8
name|op_mod
init|=
operator|(
name|prot
operator|==
name|MLX4_PROT_ETH
operator|)
condition|?
operator|!
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
operator|)
else|:
literal|0
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mgid
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memcpy
argument_list|(
name|mgid
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_GID_HASH
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|,
operator|&
name|hash
argument_list|,
name|op_mod
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
literal|0
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Hash for "
name|GID_PRINT_FMT
literal|" is %04x\n"
argument_list|,
name|GID_PRINT_ARGS
argument_list|(
name|gid
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
operator|*
name|index
operator|=
name|hash
expr_stmt|;
operator|*
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|err
operator|=
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
operator|*
name|index
argument_list|,
name|mgm_mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
operator|(
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|index
operator|!=
name|hash
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Found zero MGID in AMGM.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|mgm
operator|->
name|gid
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|>>
literal|30
operator|==
name|prot
condition|)
return|return
name|err
return|;
operator|*
name|prev
operator|=
operator|*
name|index
expr_stmt|;
operator|*
name|index
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|next_gid_index
argument_list|)
operator|>>
literal|6
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|index
condition|)
do|;
operator|*
name|index
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|__promisc_mode
index|[]
init|=
block|{
index|[
name|MLX4_FS_REGULAR
index|]
operator|=
literal|0x0
block|,
index|[
name|MLX4_FS_ALL_DEFAULT
index|]
operator|=
literal|0x1
block|,
index|[
name|MLX4_FS_MC_DEFAULT
index|]
operator|=
literal|0x3
block|,
index|[
name|MLX4_FS_UC_SNIFFER
index|]
operator|=
literal|0x4
block|,
index|[
name|MLX4_FS_MC_SNIFFER
index|]
operator|=
literal|0x5
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|map_sw_to_hw_steering_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_net_trans_promisc_mode
name|flow_type
parameter_list|)
block|{
if|if
condition|(
name|flow_type
operator|>=
name|MLX4_FS_MODE_NUM
operator|||
name|flow_type
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Invalid flow type. type = %d\n"
argument_list|,
name|flow_type
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|__promisc_mode
index|[
name|flow_type
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|map_sw_to_hw_steering_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|trans_rule_ctrl_to_hw
parameter_list|(
name|struct
name|mlx4_net_trans_rule
modifier|*
name|ctrl
parameter_list|,
name|struct
name|mlx4_net_trans_rule_hw_ctrl
modifier|*
name|hw
parameter_list|)
block|{
name|u8
name|flags
init|=
literal|0
decl_stmt|;
name|flags
operator|=
name|ctrl
operator|->
name|queue_mode
operator|==
name|MLX4_NET_TRANS_Q_LIFO
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|flags
operator||=
name|ctrl
operator|->
name|exclusive
condition|?
operator|(
literal|1
operator|<<
literal|2
operator|)
else|:
literal|0
expr_stmt|;
name|flags
operator||=
name|ctrl
operator|->
name|allow_loopback
condition|?
operator|(
literal|1
operator|<<
literal|3
operator|)
else|:
literal|0
expr_stmt|;
name|hw
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|hw
operator|->
name|type
operator|=
name|__promisc_mode
index|[
name|ctrl
operator|->
name|promisc_mode
index|]
expr_stmt|;
name|hw
operator|->
name|prio
operator|=
name|cpu_to_be16
argument_list|(
name|ctrl
operator|->
name|priority
argument_list|)
expr_stmt|;
name|hw
operator|->
name|port
operator|=
name|ctrl
operator|->
name|port
expr_stmt|;
name|hw
operator|->
name|qpn
operator|=
name|cpu_to_be32
argument_list|(
name|ctrl
operator|->
name|qpn
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|u16
name|__sw_id_hw
index|[]
init|=
block|{
index|[
name|MLX4_NET_TRANS_RULE_ID_ETH
index|]
operator|=
literal|0xE001
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_IB
index|]
operator|=
literal|0xE005
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_IPV6
index|]
operator|=
literal|0xE003
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_IPV4
index|]
operator|=
literal|0xE002
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_TCP
index|]
operator|=
literal|0xE004
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_UDP
index|]
operator|=
literal|0xE006
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|map_sw_to_hw_steering_id
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_net_trans_rule_id
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
name|MLX4_NET_TRANS_RULE_NUM
operator|||
name|id
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Invalid network rule id. id = %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|__sw_id_hw
index|[
name|id
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|map_sw_to_hw_steering_id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|__rule_hw_sz
index|[]
init|=
block|{
index|[
name|MLX4_NET_TRANS_RULE_ID_ETH
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_eth
argument_list|)
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_IB
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_ib
argument_list|)
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_IPV6
index|]
operator|=
literal|0
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_IPV4
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_ipv4
argument_list|)
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_TCP
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_tcp_udp
argument_list|)
block|,
index|[
name|MLX4_NET_TRANS_RULE_ID_UDP
index|]
operator|=
expr|sizeof
operator|(
expr|struct
name|mlx4_net_trans_rule_hw_tcp_udp
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|hw_rule_sz
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_net_trans_rule_id
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
name|MLX4_NET_TRANS_RULE_NUM
operator|||
name|id
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Invalid network rule id. id = %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|__rule_hw_sz
index|[
name|id
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|hw_rule_sz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|parse_trans_rule
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_spec_list
modifier|*
name|spec
parameter_list|,
name|struct
name|_rule_hw
modifier|*
name|rule_hw
parameter_list|)
block|{
if|if
condition|(
name|hw_rule_sz
argument_list|(
name|dev
argument_list|,
name|spec
operator|->
name|id
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
name|rule_hw
argument_list|,
literal|0
argument_list|,
name|hw_rule_sz
argument_list|(
name|dev
argument_list|,
name|spec
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|rule_hw
operator|->
name|id
operator|=
name|cpu_to_be16
argument_list|(
name|__sw_id_hw
index|[
name|spec
operator|->
name|id
index|]
argument_list|)
expr_stmt|;
name|rule_hw
operator|->
name|size
operator|=
name|hw_rule_sz
argument_list|(
name|dev
argument_list|,
name|spec
operator|->
name|id
argument_list|)
operator|>>
literal|2
expr_stmt|;
switch|switch
condition|(
name|spec
operator|->
name|id
condition|)
block|{
case|case
name|MLX4_NET_TRANS_RULE_ID_ETH
case|:
name|memcpy
argument_list|(
name|rule_hw
operator|->
name|eth
operator|.
name|dst_mac
argument_list|,
name|spec
operator|->
name|eth
operator|.
name|dst_mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rule_hw
operator|->
name|eth
operator|.
name|dst_mac_msk
argument_list|,
name|spec
operator|->
name|eth
operator|.
name|dst_mac_msk
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rule_hw
operator|->
name|eth
operator|.
name|src_mac
argument_list|,
name|spec
operator|->
name|eth
operator|.
name|src_mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rule_hw
operator|->
name|eth
operator|.
name|src_mac_msk
argument_list|,
name|spec
operator|->
name|eth
operator|.
name|src_mac_msk
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|eth
operator|.
name|ether_type_enable
condition|)
block|{
name|rule_hw
operator|->
name|eth
operator|.
name|ether_type_enable
operator|=
literal|1
expr_stmt|;
name|rule_hw
operator|->
name|eth
operator|.
name|ether_type
operator|=
name|spec
operator|->
name|eth
operator|.
name|ether_type
expr_stmt|;
block|}
name|rule_hw
operator|->
name|eth
operator|.
name|vlan_tag
operator|=
name|spec
operator|->
name|eth
operator|.
name|vlan_id
expr_stmt|;
name|rule_hw
operator|->
name|eth
operator|.
name|vlan_tag_msk
operator|=
name|spec
operator|->
name|eth
operator|.
name|vlan_id_msk
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_IB
case|:
name|rule_hw
operator|->
name|ib
operator|.
name|l3_qpn
operator|=
name|spec
operator|->
name|ib
operator|.
name|l3_qpn
expr_stmt|;
name|rule_hw
operator|->
name|ib
operator|.
name|qpn_mask
operator|=
name|spec
operator|->
name|ib
operator|.
name|qpn_msk
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rule_hw
operator|->
name|ib
operator|.
name|dst_gid
argument_list|,
operator|&
name|spec
operator|->
name|ib
operator|.
name|dst_gid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rule_hw
operator|->
name|ib
operator|.
name|dst_gid_msk
argument_list|,
operator|&
name|spec
operator|->
name|ib
operator|.
name|dst_gid_msk
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_IPV6
case|:
return|return
operator|-
name|EOPNOTSUPP
return|;
case|case
name|MLX4_NET_TRANS_RULE_ID_IPV4
case|:
name|rule_hw
operator|->
name|ipv4
operator|.
name|src_ip
operator|=
name|spec
operator|->
name|ipv4
operator|.
name|src_ip
expr_stmt|;
name|rule_hw
operator|->
name|ipv4
operator|.
name|src_ip_msk
operator|=
name|spec
operator|->
name|ipv4
operator|.
name|src_ip_msk
expr_stmt|;
name|rule_hw
operator|->
name|ipv4
operator|.
name|dst_ip
operator|=
name|spec
operator|->
name|ipv4
operator|.
name|dst_ip
expr_stmt|;
name|rule_hw
operator|->
name|ipv4
operator|.
name|dst_ip_msk
operator|=
name|spec
operator|->
name|ipv4
operator|.
name|dst_ip_msk
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_TCP
case|:
case|case
name|MLX4_NET_TRANS_RULE_ID_UDP
case|:
name|rule_hw
operator|->
name|tcp_udp
operator|.
name|dst_port
operator|=
name|spec
operator|->
name|tcp_udp
operator|.
name|dst_port
expr_stmt|;
name|rule_hw
operator|->
name|tcp_udp
operator|.
name|dst_port_msk
operator|=
name|spec
operator|->
name|tcp_udp
operator|.
name|dst_port_msk
expr_stmt|;
name|rule_hw
operator|->
name|tcp_udp
operator|.
name|src_port
operator|=
name|spec
operator|->
name|tcp_udp
operator|.
name|src_port
expr_stmt|;
name|rule_hw
operator|->
name|tcp_udp
operator|.
name|src_port_msk
operator|=
name|spec
operator|->
name|tcp_udp
operator|.
name|src_port_msk
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|__rule_hw_sz
index|[
name|spec
operator|->
name|id
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_err_rule
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mlx4_net_trans_rule
modifier|*
name|rule
parameter_list|)
block|{
define|#
directive|define
name|BUF_SIZE
value|256
name|struct
name|mlx4_spec_list
modifier|*
name|cur
decl_stmt|;
name|char
name|buf
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"port = %d prio = 0x%x qp = 0x%x "
argument_list|,
name|rule
operator|->
name|port
argument_list|,
name|rule
operator|->
name|priority
argument_list|,
name|rule
operator|->
name|qpn
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|cur
argument_list|,
argument|&rule->list
argument_list|,
argument|list
argument_list|)
block|{
switch|switch
condition|(
name|cur
operator|->
name|id
condition|)
block|{
case|case
name|MLX4_NET_TRANS_RULE_ID_ETH
case|:
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"dmac = %pM "
argument_list|,
operator|&
name|cur
operator|->
name|eth
operator|.
name|dst_mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|eth
operator|.
name|ether_type
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"ethertype = 0x%x "
argument_list|,
name|be16_to_cpu
argument_list|(
name|cur
operator|->
name|eth
operator|.
name|ether_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|eth
operator|.
name|vlan_id
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"vlan-id = %d "
argument_list|,
name|be16_to_cpu
argument_list|(
name|cur
operator|->
name|eth
operator|.
name|vlan_id
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_IPV4
case|:
if|if
condition|(
name|cur
operator|->
name|ipv4
operator|.
name|src_ip
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"src-ip = %pI4 "
argument_list|,
operator|&
name|cur
operator|->
name|ipv4
operator|.
name|src_ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|ipv4
operator|.
name|dst_ip
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"dst-ip = %pI4 "
argument_list|,
operator|&
name|cur
operator|->
name|ipv4
operator|.
name|dst_ip
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_TCP
case|:
case|case
name|MLX4_NET_TRANS_RULE_ID_UDP
case|:
if|if
condition|(
name|cur
operator|->
name|tcp_udp
operator|.
name|src_port
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"src-port = %d "
argument_list|,
name|be16_to_cpu
argument_list|(
name|cur
operator|->
name|tcp_udp
operator|.
name|src_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|tcp_udp
operator|.
name|dst_port
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"dst-port = %d "
argument_list|,
name|be16_to_cpu
argument_list|(
name|cur
operator|->
name|tcp_udp
operator|.
name|dst_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_IB
case|:
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"dst-gid = "
name|GID_PRINT_FMT
literal|"\n"
argument_list|,
name|GID_PRINT_ARGS
argument_list|(
name|cur
operator|->
name|ib
operator|.
name|dst_gid
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"dst-gid-mask = "
name|GID_PRINT_FMT
literal|"\n"
argument_list|,
name|GID_PRINT_ARGS
argument_list|(
name|cur
operator|->
name|ib
operator|.
name|dst_gid_msk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_NET_TRANS_RULE_ID_IPV6
case|:
break|break;
default|default:
break|break;
block|}
block|}
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUF_SIZE
operator|-
name|len
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|BUF_SIZE
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Network rule error message was truncated, print buffer is too small.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_flow_attach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_net_trans_rule
modifier|*
name|rule
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_spec_list
modifier|*
name|cur
decl_stmt|;
name|u32
name|size
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|memset
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|trans_rule_ctrl_to_hw
argument_list|(
name|rule
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_net_trans_rule_hw_ctrl
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|cur
argument_list|,
argument|&rule->list
argument_list|,
argument|list
argument_list|)
block|{
name|ret
operator|=
name|parse_trans_rule
argument_list|(
name|dev
argument_list|,
name|cur
argument_list|,
name|mailbox
operator|->
name|buf
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|size
operator|+=
name|ret
expr_stmt|;
block|}
name|ret
operator|=
name|mlx4_QP_FLOW_STEERING_ATTACH
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|,
name|size
operator|>>
literal|2
argument_list|,
name|reg_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ENOMEM
condition|)
name|mlx4_err_rule
argument_list|(
name|dev
argument_list|,
literal|"mcg table is full. Fail to register network rule.\n"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
condition|)
name|mlx4_err_rule
argument_list|(
name|dev
argument_list|,
literal|"Fail to register network rule.\n"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_flow_attach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_flow_detach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|reg_id
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_QP_FLOW_STEERING_DETACH
argument_list|(
name|dev
argument_list|,
name|reg_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Fail to detach network rule. registration id = 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|reg_id
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_flow_detach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_FLOW_STEERING_IB_UC_QP_RANGE
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|min_range_qpn
parameter_list|,
name|u32
name|max_range_qpn
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u64
name|in_param
decl_stmt|;
name|in_param
operator|=
operator|(
operator|(
name|u64
operator|)
name|min_range_qpn
operator|)
operator|<<
literal|32
expr_stmt|;
name|in_param
operator||=
operator|(
operator|(
name|u64
operator|)
name|max_range_qpn
operator|)
operator|&
literal|0xFFFFFFFF
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_FLOW_STEERING_IB_UC_QP_RANGE
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_FLOW_STEERING_IB_UC_QP_RANGE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_qp_attach_common
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|int
name|block_mcast_loopback
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|u32
name|members_count
decl_stmt|;
name|int
name|index
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|link
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u8
name|port
init|=
name|gid
index|[
literal|5
index|]
decl_stmt|;
name|u8
name|new_entry
init|=
literal|0
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|mgm
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|err
operator|=
name|find_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|mailbox
argument_list|,
operator|&
name|prev
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
operator|)
condition|)
block|{
name|new_entry
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|mgm
operator|->
name|gid
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|link
operator|=
literal|1
expr_stmt|;
name|index
operator|=
name|mlx4_bitmap_alloc
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"No AMGM entries left\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|index
operator|+=
name|dev
operator|->
name|caps
operator|.
name|num_mgms
expr_stmt|;
name|new_entry
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|mgm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|mgm
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mgm
operator|->
name|gid
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|members_count
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
if|if
condition|(
name|members_count
operator|==
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MGM at index %x is full.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|members_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|qp
index|[
name|i
index|]
argument_list|)
operator|&
name|MGM_QPN_MASK
operator|)
operator|==
name|qp
operator|->
name|qpn
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"QP %06x already a member of MGM\n"
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|++
index|]
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|qp
operator|->
name|qpn
operator|&
name|MGM_QPN_MASK
operator|)
operator||
operator|(
operator|!
operator|!
name|mlx4_blck_lb
operator|<<
name|MGM_BLCK_LB_BIT
operator|)
argument_list|)
expr_stmt|;
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
name|members_count
operator||
operator|(
name|u32
operator|)
name|prot
operator|<<
literal|30
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* if !link, still add the new entry. */
if|if
condition|(
operator|!
name|link
condition|)
goto|goto
name|skip_link
goto|;
name|err
operator|=
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
name|prev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|mgm
operator|->
name|next_gid_index
operator|=
name|cpu_to_be32
argument_list|(
name|index
operator|<<
literal|6
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|prev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|skip_link
label|:
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
block|{
comment|/* manage the steering entry for promisc mode */
if|if
condition|(
name|new_entry
condition|)
name|new_steering_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|index
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
else|else
name|existing_steering_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|index
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|err
operator|&&
name|link
operator|&&
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|index
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_mgms
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Got AMGM index %d< %d"
argument_list|,
name|index
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
argument_list|)
expr_stmt|;
else|else
name|mlx4_bitmap_free
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|bitmap
argument_list|,
name|index
operator|-
name|dev
operator|->
name|caps
operator|.
name|num_mgms
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_qp_detach_common
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|u32
name|members_count
decl_stmt|;
name|int
name|prev
decl_stmt|,
name|index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|loc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u8
name|port
init|=
name|gid
index|[
literal|5
index|]
decl_stmt|;
name|bool
name|removed_entry
init|=
name|false
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|mgm
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|err
operator|=
name|find_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|mailbox
argument_list|,
operator|&
name|prev
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MGID "
name|GID_PRINT_FMT
literal|" not found\n"
argument_list|,
name|GID_PRINT_ARGS
argument_list|(
name|gid
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	  if this QP is also a promisc QP, it shouldn't be removed only if 	  at least one none promisc QP is also attached to this MCG 	*/
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
operator|&&
name|check_duplicate_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|index
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
operator|&&
operator|!
name|promisc_steering_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|index
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|members_count
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|members_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|qp
index|[
name|i
index|]
argument_list|)
operator|&
name|MGM_QPN_MASK
operator|)
operator|==
name|qp
operator|->
name|qpn
condition|)
block|{
name|loc
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|loc
operator|==
operator|-
literal|1
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QP %06x not found in MGM\n"
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* copy the last QP in this MGM over removed QP */
name|mgm
operator|->
name|qp
index|[
name|loc
index|]
operator|=
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|-
literal|1
index|]
expr_stmt|;
name|mgm
operator|->
name|qp
index|[
name|members_count
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
operator|--
name|members_count
operator||
operator|(
name|u32
operator|)
name|prot
operator|<<
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
name|removed_entry
operator|=
name|can_remove_steering_entry
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|index
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|members_count
operator|&&
operator|(
name|prot
operator|!=
name|MLX4_PROT_ETH
operator|||
operator|!
name|removed_entry
operator|)
condition|)
block|{
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We are going to delete the entry, members count should be 0 */
name|mgm
operator|->
name|members_count
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|u32
operator|)
name|prot
operator|<<
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Remove entry from MGM */
name|int
name|amgm_index
init|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|next_gid_index
argument_list|)
operator|>>
literal|6
decl_stmt|;
if|if
condition|(
name|amgm_index
condition|)
block|{
name|err
operator|=
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
name|amgm_index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
else|else
name|memset
argument_list|(
name|mgm
operator|->
name|gid
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|amgm_index
condition|)
block|{
if|if
condition|(
name|amgm_index
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_mgms
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"MGM entry %d had AMGM index %d< %d"
argument_list|,
name|index
argument_list|,
name|amgm_index
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
argument_list|)
expr_stmt|;
else|else
name|mlx4_bitmap_free
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|bitmap
argument_list|,
name|amgm_index
operator|-
name|dev
operator|->
name|caps
operator|.
name|num_mgms
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Remove entry from AMGM */
name|int
name|cur_next_index
init|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|next_gid_index
argument_list|)
operator|>>
literal|6
decl_stmt|;
name|err
operator|=
name|mlx4_READ_ENTRY
argument_list|(
name|dev
argument_list|,
name|prev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|mgm
operator|->
name|next_gid_index
operator|=
name|cpu_to_be32
argument_list|(
name|cur_next_index
operator|<<
literal|6
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_WRITE_ENTRY
argument_list|(
name|dev
argument_list|,
name|prev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|index
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_mgms
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"entry %d had next AMGM index %d< %d"
argument_list|,
name|prev
argument_list|,
name|index
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
argument_list|)
expr_stmt|;
else|else
name|mlx4_bitmap_free
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|bitmap
argument_list|,
name|index
operator|-
name|dev
operator|->
name|caps
operator|.
name|num_mgms
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_QP_ATTACH
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|u8
name|attach
parameter_list|,
name|u8
name|block_loopback
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|qpn
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|EBADF
return|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|memcpy
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|qpn
operator|=
name|qp
operator|->
name|qpn
expr_stmt|;
name|qpn
operator||=
operator|(
name|prot
operator|<<
literal|28
operator|)
expr_stmt|;
if|if
condition|(
name|attach
operator|&&
name|block_loopback
condition|)
name|qpn
operator||=
operator|(
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|qpn
argument_list|,
name|attach
argument_list|,
name|MLX4_CMD_QP_ATTACH
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_trans_to_dmfs_attach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|block_mcast_loopback
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
name|struct
name|mlx4_spec_list
name|spec
init|=
block|{
block|{
name|NULL
block|}
block|}
decl_stmt|;
name|__be64
name|mac_mask
init|=
name|cpu_to_be64
argument_list|(
name|MLX4_MAC_MASK
operator|<<
literal|16
argument_list|)
decl_stmt|;
name|struct
name|mlx4_net_trans_rule
name|rule
init|=
block|{
operator|.
name|queue_mode
operator|=
name|MLX4_NET_TRANS_Q_FIFO
block|,
operator|.
name|exclusive
operator|=
literal|0
block|,
operator|.
name|promisc_mode
operator|=
name|MLX4_FS_REGULAR
block|,
operator|.
name|priority
operator|=
name|MLX4_DOMAIN_NIC
block|, 		}
decl_stmt|;
name|rule
operator|.
name|allow_loopback
operator|=
operator|!
name|block_mcast_loopback
expr_stmt|;
name|rule
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|rule
operator|.
name|qpn
operator|=
name|qp
operator|->
name|qpn
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|rule
operator|.
name|list
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|MLX4_PROT_ETH
case|:
name|spec
operator|.
name|id
operator|=
name|MLX4_NET_TRANS_RULE_ID_ETH
expr_stmt|;
name|memcpy
argument_list|(
name|spec
operator|.
name|eth
operator|.
name|dst_mac
argument_list|,
operator|&
name|gid
index|[
literal|10
index|]
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|spec
operator|.
name|eth
operator|.
name|dst_mac_msk
argument_list|,
operator|&
name|mac_mask
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_PROT_IB_IPV6
case|:
name|spec
operator|.
name|id
operator|=
name|MLX4_NET_TRANS_RULE_ID_IB
expr_stmt|;
name|memcpy
argument_list|(
name|spec
operator|.
name|ib
operator|.
name|dst_gid
argument_list|,
name|gid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|spec
operator|.
name|ib
operator|.
name|dst_gid_msk
argument_list|,
literal|0xff
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|spec
operator|.
name|list
argument_list|,
operator|&
name|rule
operator|.
name|list
argument_list|)
expr_stmt|;
return|return
name|mlx4_flow_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|rule
argument_list|,
name|reg_id
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_multicast_attach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|block_mcast_loopback
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|u64
modifier|*
name|reg_id
parameter_list|)
block|{
name|enum
name|mlx4_steer_type
name|steer
decl_stmt|;
name|steer
operator|=
operator|(
name|is_valid_ether_addr
argument_list|(
operator|&
name|gid
index|[
literal|10
index|]
argument_list|)
operator|)
condition|?
name|MLX4_UC_STEER
else|:
name|MLX4_MC_STEER
expr_stmt|;
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
condition|)
block|{
case|case
name|MLX4_STEERING_MODE_A0
case|:
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
return|return
literal|0
return|;
case|case
name|MLX4_STEERING_MODE_B0
case|:
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
name|gid
index|[
literal|7
index|]
operator||=
operator|(
name|steer
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_QP_ATTACH
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
literal|1
argument_list|,
name|block_mcast_loopback
argument_list|,
name|prot
argument_list|)
return|;
return|return
name|mlx4_qp_attach_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|block_mcast_loopback
argument_list|,
name|prot
argument_list|,
name|MLX4_MC_STEER
argument_list|)
return|;
case|case
name|MLX4_STEERING_MODE_DEVICE_MANAGED
case|:
return|return
name|mlx4_trans_to_dmfs_attach
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|port
argument_list|,
name|block_mcast_loopback
argument_list|,
name|prot
argument_list|,
name|reg_id
argument_list|)
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_multicast_attach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_multicast_detach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|,
name|u64
name|reg_id
parameter_list|)
block|{
name|enum
name|mlx4_steer_type
name|steer
decl_stmt|;
name|steer
operator|=
operator|(
name|is_valid_ether_addr
argument_list|(
operator|&
name|gid
index|[
literal|10
index|]
argument_list|)
operator|)
condition|?
name|MLX4_UC_STEER
else|:
name|MLX4_MC_STEER
expr_stmt|;
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
condition|)
block|{
case|case
name|MLX4_STEERING_MODE_A0
case|:
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
return|return
literal|0
return|;
case|case
name|MLX4_STEERING_MODE_B0
case|:
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
name|gid
index|[
literal|7
index|]
operator||=
operator|(
name|steer
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_QP_ATTACH
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|prot
argument_list|)
return|;
return|return
name|mlx4_qp_detach_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|MLX4_MC_STEER
argument_list|)
return|;
case|case
name|MLX4_STEERING_MODE_DEVICE_MANAGED
case|:
return|return
name|mlx4_flow_detach
argument_list|(
name|dev
argument_list|,
name|reg_id
argument_list|)
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_multicast_detach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_flow_steer_promisc_add
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|enum
name|mlx4_net_trans_promisc_mode
name|mode
parameter_list|)
block|{
name|struct
name|mlx4_net_trans_rule
name|rule
decl_stmt|;
name|u64
modifier|*
name|regid_p
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MLX4_FS_ALL_DEFAULT
case|:
name|regid_p
operator|=
operator|&
name|dev
operator|->
name|regid_promisc_array
index|[
name|port
index|]
expr_stmt|;
break|break;
case|case
name|MLX4_FS_MC_DEFAULT
case|:
name|regid_p
operator|=
operator|&
name|dev
operator|->
name|regid_allmulti_array
index|[
name|port
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|regid_p
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|rule
operator|.
name|promisc_mode
operator|=
name|mode
expr_stmt|;
name|rule
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|rule
operator|.
name|qpn
operator|=
name|qpn
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|rule
operator|.
name|list
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"going promisc on %x\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|mlx4_flow_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|rule
argument_list|,
name|regid_p
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_flow_steer_promisc_add
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_flow_steer_promisc_remove
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|enum
name|mlx4_net_trans_promisc_mode
name|mode
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u64
modifier|*
name|regid_p
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MLX4_FS_ALL_DEFAULT
case|:
name|regid_p
operator|=
operator|&
name|dev
operator|->
name|regid_promisc_array
index|[
name|port
index|]
expr_stmt|;
break|break;
case|case
name|MLX4_FS_MC_DEFAULT
case|:
name|regid_p
operator|=
operator|&
name|dev
operator|->
name|regid_allmulti_array
index|[
name|port
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|regid_p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
name|mlx4_flow_detach
argument_list|(
name|dev
argument_list|,
operator|*
name|regid_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|*
name|regid_p
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_flow_steer_promisc_remove
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_unicast_attach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|int
name|block_mcast_loopback
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|)
block|{
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
name|gid
index|[
literal|7
index|]
operator||=
operator|(
name|MLX4_UC_STEER
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_QP_ATTACH
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
literal|1
argument_list|,
name|block_mcast_loopback
argument_list|,
name|prot
argument_list|)
return|;
return|return
name|mlx4_qp_attach_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|block_mcast_loopback
argument_list|,
name|prot
argument_list|,
name|MLX4_UC_STEER
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_unicast_attach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_unicast_detach
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|gid
index|[
literal|16
index|]
parameter_list|,
name|enum
name|mlx4_protocol
name|prot
parameter_list|)
block|{
if|if
condition|(
name|prot
operator|==
name|MLX4_PROT_ETH
condition|)
name|gid
index|[
literal|7
index|]
operator||=
operator|(
name|MLX4_UC_STEER
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_QP_ATTACH
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|prot
argument_list|)
return|;
return|return
name|mlx4_qp_detach_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|gid
argument_list|,
name|prot
argument_list|,
name|MLX4_UC_STEER
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_unicast_detach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_PROMISC_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|u32
name|qpn
init|=
operator|(
name|u32
operator|)
name|vhcr
operator|->
name|in_param
operator|&
literal|0xffffffff
decl_stmt|;
name|u8
name|port
init|=
name|vhcr
operator|->
name|in_param
operator|>>
literal|62
decl_stmt|;
name|enum
name|mlx4_steer_type
name|steer
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
comment|/* Promiscuous unicast is not allowed in mfunc for VFs */
if|if
condition|(
operator|(
name|slave
operator|!=
name|dev
operator|->
name|caps
operator|.
name|function
operator|)
operator|&&
operator|(
name|steer
operator|==
name|MLX4_UC_STEER
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vhcr
operator|->
name|op_modifier
condition|)
return|return
name|add_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
return|;
else|else
return|return
name|remove_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|steer
argument_list|,
name|qpn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_PROMISC
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|enum
name|mlx4_steer_type
name|steer
parameter_list|,
name|u8
name|add
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
operator|(
name|u64
operator|)
name|qpn
operator||
operator|(
name|u64
operator|)
name|port
operator|<<
literal|62
argument_list|,
operator|(
name|u32
operator|)
name|steer
argument_list|,
name|add
argument_list|,
name|MLX4_CMD_PROMISC
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_multicast_promisc_add
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_PROMISC
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|,
name|MLX4_MC_STEER
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
return|;
return|return
name|add_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|MLX4_MC_STEER
argument_list|,
name|qpn
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_multicast_promisc_add
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_multicast_promisc_remove
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_PROMISC
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|,
name|MLX4_MC_STEER
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
return|;
return|return
name|remove_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|MLX4_MC_STEER
argument_list|,
name|qpn
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_multicast_promisc_remove
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_unicast_promisc_add
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_PROMISC
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|,
name|MLX4_UC_STEER
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
return|;
return|return
name|add_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|MLX4_UC_STEER
argument_list|,
name|qpn
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_unicast_promisc_add
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_unicast_promisc_remove
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|mlx4_PROMISC
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|,
name|MLX4_UC_STEER
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
return|;
return|return
name|remove_promisc_qp
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|MLX4_UC_STEER
argument_list|,
name|qpn
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_unicast_promisc_remove
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_init_mcg_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* No need for mcg_table when fw managed the mcg table*/
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|mlx4_bitmap_init
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|bitmap
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_amgms
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mlx4_cleanup_mcg_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|!=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|mlx4_bitmap_cleanup
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|mcg_table
operator|.
name|bitmap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

