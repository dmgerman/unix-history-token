begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008, 2014 Mellanox Technologies. All rights reserved.  * Copyright (c) 2006, 2007 Cisco Systems, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|LINUXKPI_PARAM_PREFIX
value|mlx4_
end_define

begin_include
include|#
directive|include
file|<linux/kmod.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/io-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/cache.h>
end_include

begin_include
include|#
directive|include
file|<linux/random.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/device.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/doorbell.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_include
include|#
directive|include
file|<dev/mlx4/stats.h>
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Mellanox ConnectX HCA low-level driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|workqueue_struct
modifier|*
name|mlx4_wq
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_MLX4_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mlx4_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|debug_level
argument_list|,
name|mlx4_debug_level
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|debug_level
argument_list|,
literal|"Enable debug tracing if> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_MLX4_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PCI_MSI
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|msi_x
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|msi_x
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|msi_x
argument_list|,
literal|"attempt to use MSI-X if nonzero"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_define
define|#
directive|define
name|msi_x
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|num_vfs
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_vfs_argc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_array
argument_list|(
name|num_vfs
argument_list|,
name|byte
argument_list|,
operator|&
name|num_vfs_argc
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_vfs
argument_list|,
literal|"enable #num_vfs functions if num_vfs> 0\n"
literal|"num_vfs=port1,port2,port1+2"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|probe_vf
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|probe_vfs_argc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_array
argument_list|(
name|probe_vf
argument_list|,
name|byte
argument_list|,
operator|&
name|probe_vfs_argc
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|probe_vf
argument_list|,
literal|"number of vfs to probe by pf driver (num_vfs> 0)\n"
literal|"probe_vf=port1,port2,port1+2"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_log_num_mgm_entry_size
init|=
name|MLX4_DEFAULT_MGM_LOG_ENTRY_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mgm_entry_size
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mgm_entry_size
argument_list|,
literal|"log mgm size, that defines the num"
literal|" of qp per mcg, for example:"
literal|" 10 gives 248.range: 7<="
literal|" log_num_mgm_entry_size<= 12."
literal|" To activate device managed"
literal|" flow steering when available, set to -1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|bool
name|enable_64b_cqe_eqe
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|enable_64b_cqe_eqe
argument_list|,
name|bool
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_64b_cqe_eqe
argument_list|,
literal|"Enable 64 byte CQEs/EQEs when the FW supports this (default: True)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|bool
name|enable_4k_uar
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|enable_4k_uar
argument_list|,
name|bool
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_4k_uar
argument_list|,
literal|"Enable using 4K UAR. Should not be enabled if have VFs which do not support 4K UARs (default: false)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PF_CONTEXT_BEHAVIOUR_MASK
value|(MLX4_FUNC_CAP_64B_EQE_CQE | \ 					 MLX4_FUNC_CAP_EQE_CQE_STRIDE | \ 					 MLX4_FUNC_CAP_DMFS_A0_STATIC)
end_define

begin_define
define|#
directive|define
name|RESET_PERSIST_MASK_FLAGS
value|(MLX4_FLAG_SRIOV)
end_define

begin_decl_stmt
specifier|static
name|char
name|mlx4_version
index|[]
init|=
name|DRV_NAME
literal|": Mellanox ConnectX core driver v"
name|DRV_VERSION
literal|" ("
name|DRV_RELDATE
literal|")\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mlx4_profile
name|default_profile
init|=
block|{
operator|.
name|num_qp
operator|=
literal|1
operator|<<
literal|18
block|,
operator|.
name|num_srq
operator|=
literal|1
operator|<<
literal|16
block|,
operator|.
name|rdmarc_per_qp
operator|=
literal|1
operator|<<
literal|4
block|,
operator|.
name|num_cq
operator|=
literal|1
operator|<<
literal|16
block|,
operator|.
name|num_mcg
operator|=
literal|1
operator|<<
literal|13
block|,
operator|.
name|num_mpt
operator|=
literal|1
operator|<<
literal|19
block|,
operator|.
name|num_mtt
operator|=
literal|1
operator|<<
literal|20
block|,
comment|/* It is really num mtt segements */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mlx4_profile
name|low_mem_profile
init|=
block|{
operator|.
name|num_qp
operator|=
literal|1
operator|<<
literal|17
block|,
operator|.
name|num_srq
operator|=
literal|1
operator|<<
literal|6
block|,
operator|.
name|rdmarc_per_qp
operator|=
literal|1
operator|<<
literal|4
block|,
operator|.
name|num_cq
operator|=
literal|1
operator|<<
literal|8
block|,
operator|.
name|num_mcg
operator|=
literal|1
operator|<<
literal|8
block|,
operator|.
name|num_mpt
operator|=
literal|1
operator|<<
literal|9
block|,
operator|.
name|num_mtt
operator|=
literal|1
operator|<<
literal|7
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_num_mac
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mac
argument_list|,
name|log_num_mac
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mac
argument_list|,
literal|"Log2 max number of MACs per ETH port (1-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|log_num_vlan
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_vlan
argument_list|,
name|log_num_vlan
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_vlan
argument_list|,
literal|"Log2 max number of VLANs per ETH port (0-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Log2 max number of VLANs per ETH port (0-7) */
end_comment

begin_define
define|#
directive|define
name|MLX4_LOG_NUM_VLANS
value|7
end_define

begin_define
define|#
directive|define
name|MLX4_MIN_LOG_NUM_VLANS
value|0
end_define

begin_define
define|#
directive|define
name|MLX4_MIN_LOG_NUM_MAC
value|1
end_define

begin_decl_stmt
specifier|static
name|bool
name|use_prio
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|use_prio
argument_list|,
name|use_prio
argument_list|,
name|bool
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|use_prio
argument_list|,
literal|"Enable steering by VLAN priority on ETH ports (deprecated)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|log_mtts_per_seg
init|=
name|ilog2
argument_list|(
name|MLX4_MTT_ENTRY_PER_SEG
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_mtts_per_seg
argument_list|,
name|log_mtts_per_seg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_mtts_per_seg
argument_list|,
literal|"Log2 number of MTT entries per segment (1-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|port_type_array
index|[
literal|2
index|]
init|=
block|{
name|MLX4_PORT_TYPE_NONE
block|,
name|MLX4_PORT_TYPE_NONE
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mlx4_port_config
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|enum
name|mlx4_port_type
name|port_type
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|atomic_t
name|pf_loading
init|=
name|ATOMIC_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|mlx4_set_num_reserved_uars
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
comment|/* The reserved_uars is calculated by system page size unit. 	 * Therefore, adjustment is added when the uar page size is less 	 * than the system page size 	 */
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|=
name|max_t
argument_list|(
name|int
argument_list|,
name|mlx4_get_num_reserved_uar
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev_cap
operator|->
name|reserved_uars
operator|/
operator|(
literal|1
operator|<<
operator|(
name|PAGE_SHIFT
operator|-
name|dev
operator|->
name|uar_page_shift
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_check_port_params
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port_type
index|[
name|i
index|]
operator|!=
name|port_type
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Only same port types supported on this HCA, aborting\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|port_type
index|[
name|i
index|]
operator|&
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Requested port type for port %d is not supported on this HCA\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_set_port_mask
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
block|{
name|MLX4_QUERY_FUNC_NUM_SYS_EQS
init|=
literal|1
operator|<<
literal|0
block|, }
enum|;
end_enum

begin_function
specifier|static
name|int
name|mlx4_query_func
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_func
name|func
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
condition|)
block|{
name|err
operator|=
name|mlx4_QUERY_FUNC
argument_list|(
name|dev
argument_list|,
operator|&
name|func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|dev_cap
operator|->
name|max_eqs
operator|=
name|func
operator|.
name|max_eq
expr_stmt|;
name|dev_cap
operator|->
name|reserved_eqs
operator|=
name|func
operator|.
name|rsvd_eqs
expr_stmt|;
name|dev_cap
operator|->
name|reserved_uars
operator|=
name|func
operator|.
name|rsvd_uars
expr_stmt|;
name|err
operator||=
name|MLX4_QUERY_FUNC_NUM_SYS_EQS
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_enable_cqe_eqe_stride
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_caps
modifier|*
name|dev_cap
init|=
operator|&
name|dev
operator|->
name|caps
decl_stmt|;
comment|/* FW not supporting or cancelled by user */
if|if
condition|(
operator|!
operator|(
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_EQE_STRIDE
operator|)
operator|||
operator|!
operator|(
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_CQE_STRIDE
operator|)
condition|)
return|return;
comment|/* Must have 64B CQE_EQE enabled by FW to use bigger stride 	 * When FW has NCSI it may decide not to report 64B CQE/EQEs 	 */
if|if
condition|(
operator|!
operator|(
name|dev_cap
operator|->
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_64B_EQE
operator|)
operator|||
operator|!
operator|(
name|dev_cap
operator|->
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_64B_CQE
operator|)
condition|)
block|{
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_CQE_STRIDE
expr_stmt|;
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_EQE_STRIDE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cache_line_size
argument_list|()
operator|==
literal|128
operator|||
name|cache_line_size
argument_list|()
operator|==
literal|256
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Enabling CQE stride cacheLine supported\n"
argument_list|)
expr_stmt|;
comment|/* Changing the real data inside CQE size to 32B */
name|dev_cap
operator|->
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_CQE
expr_stmt|;
name|dev_cap
operator|->
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_EQE
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_cap
operator|->
name|function_caps
operator||=
name|MLX4_FUNC_CAP_EQE_CQE_STRIDE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cache_line_size
argument_list|()
operator|!=
literal|32
operator|&&
name|cache_line_size
argument_list|()
operator|!=
literal|64
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Disabling CQE stride, cacheLine size unsupported\n"
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_CQE_STRIDE
expr_stmt|;
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_EQE_STRIDE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_mlx4_dev_port
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|mlx4_port_cap
modifier|*
name|port_cap
parameter_list|)
block|{
name|dev
operator|->
name|caps
operator|.
name|vl_cap
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|max_vl
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_mtu_cap
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|ib_mtu
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|gid_phys_table_len
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|max_gids
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|max_pkeys
expr_stmt|;
comment|/* set gid and pkey table operating lengths by default 	 * to non-sriov values 	 */
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|max_gids
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|max_pkeys
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_width_cap
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|max_port_width
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eth_mtu_cap
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|eth_mtu
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_tc_eth
operator|=
name|port_cap
operator|->
name|max_tc_eth
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|def_mac
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|supported_port_types
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|suggested_type
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|suggested_type
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|default_sense
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|default_sense
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_type
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|trans_type
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|vendor_oui
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|vendor_oui
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|wavelength
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|wavelength
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_code
index|[
name|port
index|]
operator|=
name|port_cap
operator|->
name|trans_code
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_dev_port
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|mlx4_port_cap
modifier|*
name|port_cap
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mlx4_QUERY_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|port_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_PORT command failed.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mlx4_enable_ignore_fcs
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_IGNORE_FCS
operator|)
condition|)
return|return;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"SRIOV mode - Disabling Ignore FCS"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_IGNORE_FCS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_FCS_KEEP
operator|)
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Keep FCS is not supported - Disabling Ignore FCS"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_IGNORE_FCS
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_A0_STEERING_TABLE_SIZE
value|256
end_define

begin_function
specifier|static
name|int
name|mlx4_dev_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|err
operator|=
name|mlx4_QUERY_DEV_CAP
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dev_cap_dump
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|min_page_sz
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size of %d bigger than kernel PAGE_SIZE of %ld, aborting\n"
argument_list|,
name|dev_cap
operator|->
name|min_page_sz
argument_list|,
operator|(
name|long
operator|)
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|num_ports
operator|>
name|MLX4_MAX_PORTS
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA has %d ports, but we only support %d, aborting\n"
argument_list|,
name|dev_cap
operator|->
name|num_ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|uar_size
operator|>
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA reported UAR size of 0x%x bigger than PCI resource 2 size of 0x%llx, aborting\n"
argument_list|,
name|dev_cap
operator|->
name|uar_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|=
name|dev_cap
operator|->
name|num_ports
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_sys_eqs
operator|=
name|dev_cap
operator|->
name|num_sys_eqs
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
operator|=
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
condition|?
name|dev
operator|->
name|caps
operator|.
name|num_sys_eqs
else|:
name|MLX4_MAX_EQ_NUM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|_mlx4_dev_port
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|dev_cap
operator|->
name|port_cap
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_PORT command failed, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|=
name|dev_cap
operator|->
name|uar_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|local_ca_ack_delay
operator|=
name|dev_cap
operator|->
name|local_ca_ack_delay
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
operator|=
name|dev_cap
operator|->
name|bf_reg_size
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_regs_per_page
operator|=
name|dev_cap
operator|->
name|bf_regs_per_page
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
operator|=
name|dev_cap
operator|->
name|max_sq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
operator|=
name|dev_cap
operator|->
name|max_rq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|=
name|dev_cap
operator|->
name|max_qp_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_qp_init_rdma
operator|=
name|dev_cap
operator|->
name|max_requester_per_qp
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_wqes
operator|=
name|dev_cap
operator|->
name|max_srq_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_sge
operator|=
name|dev_cap
operator|->
name|max_rq_sg
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
operator|=
name|dev_cap
operator|->
name|reserved_srqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_sq_desc_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_rq_desc_sz
expr_stmt|;
comment|/* 	 * Subtract 1 from the limit because we need to allocate a 	 * spare CQE so the HCA HW can tell the difference between an 	 * empty CQ and a full CQ. 	 */
name|dev
operator|->
name|caps
operator|.
name|max_cqes
operator|=
name|dev_cap
operator|->
name|max_cq_sz
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
operator|=
name|dev_cap
operator|->
name|reserved_cqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|dev_cap
operator|->
name|reserved_eqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|dev_cap
operator|->
name|reserved_mtts
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
operator|=
name|dev_cap
operator|->
name|reserved_mrws
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_pds
operator|=
name|dev_cap
operator|->
name|reserved_pds
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|reserved_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|max_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
operator|=
name|dev_cap
operator|->
name|mtt_entry_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_msg_sz
operator|=
name|dev_cap
operator|->
name|max_msg_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
operator|=
operator|~
call|(
name|u32
call|)
argument_list|(
name|dev_cap
operator|->
name|min_page_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|=
name|dev_cap
operator|->
name|flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|=
name|dev_cap
operator|->
name|flags2
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|=
name|dev_cap
operator|->
name|bmme_flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_lkey
operator|=
name|dev_cap
operator|->
name|reserved_lkey
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|stat_rate_support
operator|=
name|dev_cap
operator|->
name|stat_rate_support
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_gso_sz
operator|=
name|dev_cap
operator|->
name|max_gso_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rss_tbl_sz
operator|=
name|dev_cap
operator|->
name|max_rss_tbl_sz
expr_stmt|;
comment|/* Save uar page shift */
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Virtual PCI function needs to determine UAR page size from 		 * firmware. Only master PCI function can set the uar page size 		 */
if|if
condition|(
name|enable_4k_uar
condition|)
name|dev
operator|->
name|uar_page_shift
operator|=
name|DEFAULT_UAR_PAGE_SHIFT
expr_stmt|;
else|else
name|dev
operator|->
name|uar_page_shift
operator|=
name|PAGE_SHIFT
expr_stmt|;
name|mlx4_set_num_reserved_uars
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_PHV_EN
condition|)
block|{
name|struct
name|mlx4_init_hca_param
name|hca_param
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hca_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hca_param
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|hca_param
argument_list|)
expr_stmt|;
comment|/* Turn off PHV_EN flag in case phv_check_en is set. 		 * phv_check_en is a HW check that parse the packet and verify 		 * phv bit was reported correctly in the wqe. To allow QinQ 		 * PHV_EN flag should be set and phv_check_en must be cleared 		 * otherwise QinQ packets will be drop by the HW. 		 */
if|if
condition|(
name|err
operator|||
name|hca_param
operator|.
name|phv_check_en
condition|)
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_PHV_EN
expr_stmt|;
block|}
comment|/* Sense port always allowed on supported devices for ConnectX-1 and -2 */
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
condition|)
name|dev
operator|->
name|caps
operator|.
name|flags
operator||=
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
expr_stmt|;
comment|/* Don't do sense port on multifunction devices (for now at least) */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
expr_stmt|;
if|if
condition|(
name|mlx4_low_memory_profile
argument_list|()
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|MLX4_MIN_LOG_NUM_MAC
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|MLX4_MIN_LOG_NUM_VLANS
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|log_num_mac
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|MLX4_LOG_NUM_VLANS
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
condition|)
block|{
comment|/* if only ETH is supported - assign ETH */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
comment|/* if only IB is supported, assign IB */
elseif|else
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
else|else
block|{
comment|/* if IB and ETH are supported, we set the port 				 * type according to user selection of port type; 				 * if user selected none, take the FW hint */
if|if
condition|(
name|port_type_array
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|MLX4_PORT_TYPE_NONE
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|suggested_type
index|[
name|i
index|]
condition|?
name|MLX4_PORT_TYPE_ETH
else|:
name|MLX4_PORT_TYPE_IB
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|port_type_array
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* 		 * Link sensing is allowed on the port if 3 conditions are true: 		 * 1. Both protocols are supported on the port. 		 * 2. Different types are supported on the port 		 * 3. FW declared that it supports link sensing 		 */
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
operator|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
operator|)
operator|)
expr_stmt|;
comment|/* 		 * If "default_sense" bit is set, we move the port to "AUTO" mode 		 * and perform sense_port FW command to try and set the correct 		 * port type from beginning 		 */
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|&&
name|dev
operator|->
name|caps
operator|.
name|default_sense
index|[
name|i
index|]
condition|)
block|{
name|enum
name|mlx4_port_type
name|sensed_port
init|=
name|MLX4_PORT_TYPE_NONE
decl_stmt|;
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
name|mlx4_SENSE_PORT
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|sensed_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sensed_port
operator|!=
name|MLX4_PORT_TYPE_NONE
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|sensed_port
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|>
name|dev_cap
operator|->
name|port_cap
index|[
name|i
index|]
operator|.
name|log_max_macs
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|dev_cap
operator|->
name|port_cap
index|[
name|i
index|]
operator|.
name|log_max_macs
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Requested number of MACs is too much for port %d, reducing to %d\n"
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|>
name|dev_cap
operator|->
name|port_cap
index|[
name|i
index|]
operator|.
name|log_max_vlans
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|dev_cap
operator|->
name|port_cap
index|[
name|i
index|]
operator|.
name|log_max_vlans
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Requested number of VLANs is too much for port %d, reducing to %d\n"
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|==
literal|2
operator|)
operator|&&
operator|(
name|port_type_array
index|[
literal|0
index|]
operator|==
name|MLX4_PORT_TYPE_IB
operator|)
operator|&&
operator|(
name|port_type_array
index|[
literal|1
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Granular QoS per VF not supported with IB/Eth configuration\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_QOS_VPP
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|=
name|dev_cap
operator|->
name|max_counters
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|=
name|dev_cap
operator|->
name|reserved_qps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
operator|=
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|)
operator|*
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|)
operator|*
name|dev
operator|->
name|caps
operator|.
name|num_ports
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_EXCH
index|]
operator|=
name|MLX4_NUM_FEXCH
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_base
operator|>
literal|0
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_FS_EN
condition|)
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_base
operator|=
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_base
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_base
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_range
operator|>
literal|0
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_FS_EN
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_range
operator|=
name|dev_cap
operator|->
name|dmfs_high_rate_qpn_range
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|=
name|MLX4_STEERING_DMFS_A0_DEFAULT
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_FS_A0
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|=
name|MLX4_STEERING_DMFS_A0_NOT_SUPPORTED
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_base
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_range
operator|=
name|MLX4_A0_STEERING_TABLE_SIZE
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|rl_caps
operator|=
name|dev_cap
operator|->
name|rl_caps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_RSS_RAW_ETH
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_range
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_EXCH
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|sqp_demux
operator|=
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|?
name|MLX4_MAX_NUM_SLAVES
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|enable_64b_cqe_eqe
operator|&&
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|dev_cap
operator|->
name|flags
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG_64B_CQE
operator||
name|MLX4_DEV_CAP_FLAG_64B_EQE
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"64B EQEs/CQEs supported by the device but not enabled\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_CQE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_EQE
expr_stmt|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|flags2
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG2_CQE_STRIDE
operator||
name|MLX4_DEV_CAP_FLAG2_EQE_STRIDE
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Disabling EQE/CQE stride per user request\n"
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_CQE_STRIDE
expr_stmt|;
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_EQE_STRIDE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG_64B_CQE
operator||
name|MLX4_DEV_CAP_FLAG_64B_EQE
operator|)
operator|)
operator|&&
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|function_caps
operator||=
name|MLX4_FUNC_CAP_64B_EQE_CQE
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_enable_cqe_eqe_stride
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|alloc_res_qp_mask
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
condition|?
name|MLX4_RESERVE_ETH_BF_QP
else|:
literal|0
operator|)
operator||
name|MLX4_RESERVE_A0_QP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_ETS_CFG
operator|)
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_SET_ETH_SCHED
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Old device ETS support detected\n"
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Consider upgrading device FW.\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_ETS_CFG
expr_stmt|;
block|}
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|alloc_res_qp_mask
operator|=
literal|0
expr_stmt|;
block|}
name|mlx4_enable_ignore_fcs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_get_pcie_dev_link_caps
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|pci_bus_speed
modifier|*
name|speed
parameter_list|,
name|enum
name|pcie_link_width
modifier|*
name|width
parameter_list|)
block|{
name|u32
name|lnkcap1
decl_stmt|,
name|lnkcap2
decl_stmt|;
name|int
name|err1
decl_stmt|,
name|err2
decl_stmt|;
define|#
directive|define
name|PCIE_MLW_CAP_SHIFT
value|4
comment|/* start of MLW mask in link capabilities */
operator|*
name|speed
operator|=
name|PCI_SPEED_UNKNOWN
expr_stmt|;
operator|*
name|width
operator|=
name|PCIE_LNK_WIDTH_UNKNOWN
expr_stmt|;
name|err1
operator|=
name|pcie_capability_read_dword
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
name|PCI_EXP_LNKCAP
argument_list|,
operator|&
name|lnkcap1
argument_list|)
expr_stmt|;
name|err2
operator|=
name|pcie_capability_read_dword
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
name|PCI_EXP_LNKCAP2
argument_list|,
operator|&
name|lnkcap2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err2
operator|&&
name|lnkcap2
condition|)
block|{
comment|/* PCIe r3.0-compliant */
if|if
condition|(
name|lnkcap2
operator|&
name|PCI_EXP_LNKCAP2_SLS_8_0GB
condition|)
operator|*
name|speed
operator|=
name|PCIE_SPEED_8_0GT
expr_stmt|;
elseif|else
if|if
condition|(
name|lnkcap2
operator|&
name|PCI_EXP_LNKCAP2_SLS_5_0GB
condition|)
operator|*
name|speed
operator|=
name|PCIE_SPEED_5_0GT
expr_stmt|;
elseif|else
if|if
condition|(
name|lnkcap2
operator|&
name|PCI_EXP_LNKCAP2_SLS_2_5GB
condition|)
operator|*
name|speed
operator|=
name|PCIE_SPEED_2_5GT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err1
condition|)
block|{
operator|*
name|width
operator|=
operator|(
name|lnkcap1
operator|&
name|PCI_EXP_LNKCAP_MLW
operator|)
operator|>>
name|PCIE_MLW_CAP_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|lnkcap2
condition|)
block|{
comment|/* pre-r3.0 */
if|if
condition|(
name|lnkcap1
operator|&
name|PCI_EXP_LNKCAP_SLS_5_0GB
condition|)
operator|*
name|speed
operator|=
name|PCIE_SPEED_5_0GT
expr_stmt|;
elseif|else
if|if
condition|(
name|lnkcap1
operator|&
name|PCI_EXP_LNKCAP_SLS_2_5GB
condition|)
operator|*
name|speed
operator|=
name|PCIE_SPEED_2_5GT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|speed
operator|==
name|PCI_SPEED_UNKNOWN
operator|||
operator|*
name|width
operator|==
name|PCIE_LNK_WIDTH_UNKNOWN
condition|)
block|{
return|return
name|err1
condition|?
name|err1
else|:
name|err2
condition|?
name|err2
else|:
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_check_pcie_caps
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|enum
name|pcie_link_width
name|width
decl_stmt|,
name|width_cap
decl_stmt|;
name|enum
name|pci_bus_speed
name|speed
decl_stmt|,
name|speed_cap
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|PCIE_SPEED_STR
parameter_list|(
name|speed
parameter_list|)
define|\
value|(speed == PCIE_SPEED_8_0GT ? "8.0GT/s" : \ 	 speed == PCIE_SPEED_5_0GT ? "5.0GT/s" : \ 	 speed == PCIE_SPEED_2_5GT ? "2.5GT/s" : \ 	 "Unknown")
name|err
operator|=
name|mlx4_get_pcie_dev_link_caps
argument_list|(
name|dev
argument_list|,
operator|&
name|speed_cap
argument_list|,
operator|&
name|width_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Unable to determine PCIe device BW capabilities\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|pcie_get_minimum_link
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|speed
operator|==
name|PCI_SPEED_UNKNOWN
operator|||
name|width
operator|==
name|PCIE_LNK_WIDTH_UNKNOWN
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Unable to determine PCI device chain minimum BW\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|width
operator|!=
name|width_cap
operator|||
name|speed
operator|!=
name|speed_cap
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"PCIe BW is different than device's capability\n"
argument_list|)
expr_stmt|;
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"PCIe link speed is %s, device supports %s\n"
argument_list|,
name|PCIE_SPEED_STR
argument_list|(
name|speed
argument_list|)
argument_list|,
name|PCIE_SPEED_STR
argument_list|(
name|speed_cap
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"PCIe link width is x%d, device supports x%d\n"
argument_list|,
name|width
argument_list|,
name|width_cap
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*The function checks if there are live vf, return the num of them*/
end_comment

begin_function
specifier|static
name|int
name|mlx4_how_many_lives_vf
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|s_state
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
comment|/*the ppf is 0*/
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
operator|++
name|i
control|)
block|{
name|s_state
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s_state
operator|->
name|active
operator|&&
name|s_state
operator|->
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_RESET
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"%s: slave: %d is still active\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_parav_qkey
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|u32
modifier|*
name|qkey
parameter_list|)
block|{
name|u32
name|qk
init|=
name|MLX4_RESERVED_QKEY_BASE
decl_stmt|;
if|if
condition|(
name|qpn
operator|>=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|+
literal|8
operator|*
name|MLX4_MFUNC_MAX
operator|||
name|qpn
operator|<
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|qpn
operator|>=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
condition|)
comment|/* tunnel qp */
name|qk
operator|+=
name|qpn
operator|-
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
expr_stmt|;
else|else
name|qk
operator|+=
name|qpn
operator|-
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
expr_stmt|;
operator|*
name|qkey
operator|=
name|qk
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_parav_qkey
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_sync_pkey_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|priv
operator|->
name|virt2phys_pkey
index|[
name|slave
index|]
index|[
name|port
operator|-
literal|1
index|]
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_sync_pkey_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_put_slave_node_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|__be64
name|guid
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|priv
operator|->
name|slave_node_guids
index|[
name|slave
index|]
operator|=
name|guid
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_put_slave_node_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|__be64
name|mlx4_get_slave_node_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|priv
operator|->
name|slave_node_guids
index|[
name|slave
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_slave_node_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_is_slave_active
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|s_slave
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
name|s_slave
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
expr_stmt|;
return|return
operator|!
operator|!
name|s_slave
operator|->
name|active
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_is_slave_active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|slave_adjust_steering_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|hca_param
parameter_list|)
block|{
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|hca_param
operator|->
name|steering_mode
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|fs_log_max_ucast_qp_range_size
operator|=
name|dev_cap
operator|->
name|fs_log_max_ucast_qp_range_size
expr_stmt|;
block|}
else|else
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
literal|4
operator|*
operator|(
operator|(
literal|1
operator|<<
name|hca_param
operator|->
name|log_mc_entry_sz
operator|)
operator|/
literal|16
operator|-
literal|2
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Steering mode is: %s\n"
argument_list|,
name|mlx4_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_slave_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u32
name|page_size
decl_stmt|;
name|struct
name|mlx4_dev_cap
name|dev_cap
decl_stmt|;
name|struct
name|mlx4_func_cap
name|func_cap
decl_stmt|;
name|struct
name|mlx4_init_hca_param
name|hca_param
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hca_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hca_param
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|hca_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_HCA command failed, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* fail if the hca has an unknown global capability 	 * at this time global_caps should be always zeroed 	 */
if|if
condition|(
name|hca_param
operator|.
name|global_caps
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unknown hca global capabilities\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSYS
return|;
block|}
name|mlx4_log_num_mgm_entry_size
operator|=
name|hca_param
operator|.
name|log_mc_entry_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
operator|=
name|hca_param
operator|.
name|hca_core_clock
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dev_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_cap
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_qp_dest_rdma
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_rd_per_qp
expr_stmt|;
name|err
operator|=
name|mlx4_dev_cap
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_QUERY_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FW command failed: could not get FW version\n"
argument_list|)
expr_stmt|;
name|page_size
operator|=
operator|~
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
operator|+
literal|1
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size:%d\n"
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size of %d bigger than kernel PAGE_SIZE of %ld, aborting\n"
argument_list|,
name|page_size
argument_list|,
operator|(
name|long
operator|)
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
comment|/* Set uar_page_shift for VF */
name|dev
operator|->
name|uar_page_shift
operator|=
name|hca_param
operator|.
name|uar_page_sz
operator|+
literal|12
expr_stmt|;
comment|/* Make sure the master uar page size is valid */
if|if
condition|(
name|dev
operator|->
name|uar_page_shift
operator|>
name|PAGE_SHIFT
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Invalid configuration: uar page size is larger than system page size\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
comment|/* Set reserved_uars based on the uar_page_shift */
name|mlx4_set_num_reserved_uars
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
comment|/* Although uar page size in FW differs from system page size, 	 * upper software layers (mlx4_ib, mlx4_en and part of mlx4_core) 	 * still works with assumption that uar page size == system page size 	 */
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|func_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|func_cap
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_FUNC_CAP
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|func_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FUNC_CAP general command failed, aborting (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
operator|(
name|func_cap
operator|.
name|pf_context_behaviour
operator||
name|PF_CONTEXT_BEHAVIOUR_MASK
operator|)
operator|!=
name|PF_CONTEXT_BEHAVIOUR_MASK
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unknown pf context behaviour %x known flags %x\n"
argument_list|,
name|func_cap
operator|.
name|pf_context_behaviour
argument_list|,
name|PF_CONTEXT_BEHAVIOUR_MASK
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSYS
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|=
name|func_cap
operator|.
name|num_ports
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|qp
operator|=
name|func_cap
operator|.
name|qp_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|srq
operator|=
name|func_cap
operator|.
name|srq_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|cq
operator|=
name|func_cap
operator|.
name|cq_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mpt
operator|=
name|func_cap
operator|.
name|mpt_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mtt
operator|=
name|func_cap
operator|.
name|mtt_quota
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qps
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_qps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_srqs
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_srqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_cqs
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_cqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_mpts
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_mpt_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|=
name|func_cap
operator|.
name|max_eq
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|func_cap
operator|.
name|reserved_eq
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_lkey
operator|=
name|func_cap
operator|.
name|reserved_lkey
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_pds
operator|=
name|MLX4_NUM_PDS
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_amgms
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|>
name|MLX4_MAX_PORTS
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA has %d ports, but we only support %d, aborting\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|mlx4_replace_zero_macs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|mlx4_QUERY_FUNC_CAP
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|func_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FUNC_CAP port command failed for port %d, aborting (%d)\n"
argument_list|,
name|i
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp0_qkey
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp0_tunnel_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp0_proxy_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp1_tunnel_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp1_proxy_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|phys_port_id
index|[
name|i
index|]
operator|=
name|func_cap
operator|.
name|phys_port_id
expr_stmt|;
name|err
operator|=
name|mlx4_get_slave_pkey_gid_tbl_len
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
argument_list|,
operator|&
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mem
goto|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|*
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|)
operator|>
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA reported UAR region size of 0x%x bigger than PCI resource 2 size of 0x%llx, aborting\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|*
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_64B_EQE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|32
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_64B_CQE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
operator||=
name|MLX4_USER_DEV_CAP_LARGE_CQE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_EQE_STRIDE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
name|hca_param
operator|.
name|eqe_size
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_CQE_STRIDE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
name|hca_param
operator|.
name|cqe_size
expr_stmt|;
comment|/* User still need to know when CQE> 32B */
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
operator||=
name|MLX4_USER_DEV_CAP_LARGE_CQE
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Timestamping is not supported in slave mode\n"
argument_list|)
expr_stmt|;
name|slave_adjust_steering_mode
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|,
operator|&
name|hca_param
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"RSS support for IP fragments is %s\n"
argument_list|,
name|hca_param
operator|.
name|rss_ip_frags
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_cap
operator|.
name|extra_flags
operator|&
name|MLX4_QUERY_FUNC_FLAGS_BF_RES_QP
operator|&&
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
condition|)
name|dev
operator|->
name|caps
operator|.
name|alloc_res_qp_mask
operator||=
name|MLX4_RESERVE_ETH_BF_QP
expr_stmt|;
if|if
condition|(
name|func_cap
operator|.
name|extra_flags
operator|&
name|MLX4_QUERY_FUNC_FLAGS_A0_RES_QP
condition|)
name|dev
operator|->
name|caps
operator|.
name|alloc_res_qp_mask
operator||=
name|MLX4_RESERVE_A0_QP
expr_stmt|;
return|return
literal|0
return|;
name|err_mem
label|:
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_request_modules
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|int
name|has_ib_port
init|=
name|false
decl_stmt|;
name|int
name|has_eth_port
init|=
name|false
decl_stmt|;
define|#
directive|define
name|EN_DRV_NAME
value|"mlx4_en"
define|#
directive|define
name|IB_DRV_NAME
value|"mlx4_ib"
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
name|has_ib_port
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|has_eth_port
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|has_eth_port
condition|)
name|request_module_nowait
argument_list|(
name|EN_DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_ib_port
operator|||
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_IBOE
operator|)
condition|)
name|request_module_nowait
argument_list|(
name|IB_DRV_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the port configuration of the device.  * Every user of this function must hold the port mutex.  */
end_comment

begin_function
name|int
name|mlx4_change_port_types
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_types
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|change
init|=
literal|0
decl_stmt|;
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* Change the port type only if the new type is different 		 * from the current, and not set to Auto */
if|if
condition|(
name|port_types
index|[
name|port
index|]
operator|!=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
operator|+
literal|1
index|]
condition|)
name|change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|change
condition|)
block|{
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|=
name|port_types
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d, aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to register device\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlx4_request_modules
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|char
name|type
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
operator|)
condition|?
literal|"ib"
else|:
literal|"eth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"auto (%s)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__set_port_type
parameter_list|(
name|struct
name|mlx4_port_info
modifier|*
name|info
parameter_list|,
name|enum
name|mlx4_port_type
name|port_type
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|mdev
argument_list|)
decl_stmt|;
name|enum
name|mlx4_port_type
name|types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|enum
name|mlx4_port_type
name|new_types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|port_type
operator|&
name|mdev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|info
operator|->
name|port
index|]
operator|)
operator|!=
name|port_type
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Requested port type for port %d is not supported on this HCA\n"
argument_list|,
name|info
operator|->
name|port
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_sup
goto|;
block|}
name|mlx4_stop_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|info
operator|->
name|tmp_type
operator|=
name|port_type
expr_stmt|;
comment|/* Possible type is always the one that was delivered */
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|=
name|info
operator|->
name|tmp_type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
condition|?
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
else|:
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|types
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mdev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
operator|&&
operator|!
operator|(
name|mdev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
block|{
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Auto sensing is not supported on this HCA. Set only 'eth' or 'ib' for both ports (should be the same)\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlx4_do_sense_ports
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_check_port_params
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* We are about to apply the changes after the configuration 	 * was verified, no need to remember the temporary types 	 * any more */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_change_port_types
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_sup
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|set_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|enum
name|mlx4_port_type
name|port_type
decl_stmt|;
specifier|static
name|DEFINE_MUTEX
argument_list|(
name|set_port_type_mutex
argument_list|)
expr_stmt|;
name|int
name|err
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|set_port_type_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"ib\n"
argument_list|)
condition|)
block|{
name|port_type
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"eth\n"
argument_list|)
condition|)
block|{
name|port_type
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"auto\n"
argument_list|)
condition|)
block|{
name|port_type
operator|=
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
block|}
else|else
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"%s is not supported port type\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|err
operator|=
name|__set_port_type
argument_list|(
name|info
argument_list|,
name|port_type
argument_list|)
expr_stmt|;
name|err_out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|set_port_type_mutex
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|err
else|:
name|count
return|;
block|}
end_function

begin_enum
enum|enum
name|ibta_mtu
block|{
name|IB_MTU_256
init|=
literal|1
block|,
name|IB_MTU_512
init|=
literal|2
block|,
name|IB_MTU_1024
init|=
literal|3
block|,
name|IB_MTU_2048
init|=
literal|4
block|,
name|IB_MTU_4096
init|=
literal|5
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|int
name|int_to_ibta_mtu
parameter_list|(
name|int
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
literal|256
case|:
return|return
name|IB_MTU_256
return|;
case|case
literal|512
case|:
return|return
name|IB_MTU_512
return|;
case|case
literal|1024
case|:
return|return
name|IB_MTU_1024
return|;
case|case
literal|2048
case|:
return|return
name|IB_MTU_2048
return|;
case|case
literal|4096
case|:
return|return
name|IB_MTU_4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ibta_mtu_to_int
parameter_list|(
name|enum
name|ibta_mtu
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
name|IB_MTU_256
case|:
return|return
literal|256
return|;
case|case
name|IB_MTU_512
case|:
return|return
literal|512
return|;
case|case
name|IB_MTU_1024
case|:
return|return
literal|1024
return|;
case|case
name|IB_MTU_2048
case|:
return|return
literal|2048
return|;
case|case
name|IB_MTU_4096
case|:
return|return
literal|4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_port_ib_mtu
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_mtu_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|mlx4_warn
argument_list|(
name|mdev
argument_list|,
literal|"port level mtu is only used for IB ports\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|ibta_mtu_to_int
argument_list|(
name|mdev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|info
operator|->
name|port
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|set_port_ib_mtu
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_mtu_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|mdev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|,
name|port
decl_stmt|,
name|mtu
decl_stmt|,
name|ibta_mtu
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
block|{
name|mlx4_warn
argument_list|(
name|mdev
argument_list|,
literal|"port level mtu is only used for IB ports\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|err
operator|=
name|kstrtoint
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|&
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|ibta_mtu
operator|=
name|int_to_ibta_mtu
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|ibta_mtu
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"%s is invalid IBTA mtu\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mdev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|info
operator|->
name|port
index|]
operator|=
name|ibta_mtu
expr_stmt|;
name|mlx4_stop_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_unregister_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|mlx4_CLOSE_PORT
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to set port %d, aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|err_set_port
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_set_port
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|err
else|:
name|count
return|;
block|}
end_function

begin_comment
comment|/* bond for multi-function device */
end_comment

begin_define
define|#
directive|define
name|MAX_MF_BOND_ALLOWED_SLAVES
value|63
end_define

begin_function
specifier|static
name|int
name|mlx4_mf_bond
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|nvfs
decl_stmt|;
name|struct
name|mlx4_slaves_pport
name|slaves_port1
decl_stmt|;
name|struct
name|mlx4_slaves_pport
name|slaves_port2
decl_stmt|;
name|DECLARE_BITMAP
argument_list|(
name|slaves_port_1_2
argument_list|,
name|MLX4_MFUNC_MAX
argument_list|)
expr_stmt|;
name|slaves_port1
operator|=
name|mlx4_phys_to_slaves_pport
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|slaves_port2
operator|=
name|mlx4_phys_to_slaves_pport
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bitmap_and
argument_list|(
name|slaves_port_1_2
argument_list|,
name|slaves_port1
operator|.
name|slaves
argument_list|,
name|slaves_port2
operator|.
name|slaves
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* only single port vfs are allowed */
if|if
condition|(
name|bitmap_weight
argument_list|(
name|slaves_port_1_2
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|+
literal|1
argument_list|)
operator|>
literal|1
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"HA mode unsupported for dual ported VFs\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* number of virtual functions is number of total functions minus one 	 * physical function for each port. 	 */
name|nvfs
operator|=
name|bitmap_weight
argument_list|(
name|slaves_port1
operator|.
name|slaves
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|+
literal|1
argument_list|)
operator|+
name|bitmap_weight
argument_list|(
name|slaves_port2
operator|.
name|slaves
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|+
literal|1
argument_list|)
operator|-
literal|2
expr_stmt|;
comment|/* limit on maximum allowed VFs */
if|if
condition|(
name|nvfs
operator|>
name|MAX_MF_BOND_ALLOWED_SLAVES
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"HA mode is not supported for %d VFs (max %d are allowed)\n"
argument_list|,
name|nvfs
argument_list|,
name|MAX_MF_BOND_ALLOWED_SLAVES
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|!=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"HA mode unsupported for NON DMFS steering\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|err
operator|=
name|mlx4_bond_mac_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mlx4_bond_vlan_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err1
goto|;
name|err
operator|=
name|mlx4_bond_fs_rules
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err2
goto|;
return|return
literal|0
return|;
name|err2
label|:
operator|(
name|void
operator|)
name|mlx4_unbond_vlan_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err1
label|:
operator|(
name|void
operator|)
name|mlx4_unbond_mac_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_mf_unbond
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|ret1
decl_stmt|;
name|ret
operator|=
name|mlx4_unbond_fs_rules
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"multifunction unbond for flow rules failedi (%d)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret1
operator|=
name|mlx4_unbond_mac_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret1
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"multifunction unbond for MAC table failed (%d)\n"
argument_list|,
name|ret1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ret1
expr_stmt|;
block|}
name|ret1
operator|=
name|mlx4_unbond_vlan_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret1
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"multifunction unbond for VLAN table failed (%d)\n"
argument_list|,
name|ret1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ret1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mlx4_bond
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|bond_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mlx4_do_bond
argument_list|(
name|dev
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to bond device: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mlx4_mf_bond
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"bond for multifunction failed\n"
argument_list|)
expr_stmt|;
name|mlx4_do_bond
argument_list|(
name|dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|bond_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Device is bonded\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_bond
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_unbond
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|bond_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_bonded
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|ret2
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|mlx4_do_bond
argument_list|(
name|dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to unbond device: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|ret2
operator|=
name|mlx4_mf_unbond
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret2
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to unbond device for multifunction (%d)\n"
argument_list|,
name|ret2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ret2
expr_stmt|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|bond_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Device is unbonded\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_unbond
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_port_map_set
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_port_map
modifier|*
name|v2p
parameter_list|)
block|{
name|u8
name|port1
init|=
name|v2p
operator|->
name|port1
decl_stmt|;
name|u8
name|port2
init|=
name|v2p
operator|->
name|port2
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_PORT_REMAP
operator|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|bond_mutex
argument_list|)
expr_stmt|;
comment|/* zero means keep current mapping for this port */
if|if
condition|(
name|port1
operator|==
literal|0
condition|)
name|port1
operator|=
name|priv
operator|->
name|v2p
operator|.
name|port1
expr_stmt|;
if|if
condition|(
name|port2
operator|==
literal|0
condition|)
name|port2
operator|=
name|priv
operator|->
name|v2p
operator|.
name|port2
expr_stmt|;
if|if
condition|(
operator|(
name|port1
operator|<
literal|1
operator|)
operator|||
operator|(
name|port1
operator|>
name|MLX4_MAX_PORTS
operator|)
operator|||
operator|(
name|port2
operator|<
literal|1
operator|)
operator|||
operator|(
name|port2
operator|>
name|MLX4_MAX_PORTS
operator|)
operator|||
operator|(
name|port1
operator|==
literal|2
operator|&&
name|port2
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* besides boundary checks cross mapping makes 		 * no sense and therefore not allowed */
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|port1
operator|==
name|priv
operator|->
name|v2p
operator|.
name|port1
operator|)
operator|&&
operator|(
name|port2
operator|==
name|priv
operator|->
name|v2p
operator|.
name|port2
operator|)
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|mlx4_virt2phy_port_map
argument_list|(
name|dev
argument_list|,
name|port1
argument_list|,
name|port2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"port map changed: [%d][%d]\n"
argument_list|,
name|port1
argument_list|,
name|port2
argument_list|)
expr_stmt|;
name|priv
operator|->
name|v2p
operator|.
name|port1
operator|=
name|port1
expr_stmt|;
name|priv
operator|->
name|v2p
operator|.
name|port2
operator|=
name|port2
expr_stmt|;
block|}
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to change port mape: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|bond_mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_port_map_set
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_load_fw
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|priv
operator|->
name|fw
operator|.
name|fw_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|fw_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate FW area, aborting\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_FA
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_FA command failed, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|err
operator|=
name|mlx4_RUN_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"RUN_FW command failed, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_fa
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_fa
label|:
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free
label|:
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_cmpt_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|cmpt_base
parameter_list|,
name|int
name|cmpt_entry_sz
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|num_eqs
decl_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_QP
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_SRQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_qp
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_CQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_srq
goto|;
name|num_eqs
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_EQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|num_eqs
argument_list|,
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cq
goto|;
return|return
literal|0
return|;
name|err_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_icm
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|init_hca
parameter_list|,
name|u64
name|icm_size
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|aux_pages
decl_stmt|;
name|int
name|num_eqs
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_SET_ICM_SIZE
argument_list|(
name|dev
argument_list|,
name|icm_size
argument_list|,
operator|&
name|aux_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"SET_ICM_SIZE command failed, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%lld KB of HCA context requires %lld KB aux memory\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|icm_size
operator|>>
literal|10
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|aux_pages
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|priv
operator|->
name|fw
operator|.
name|aux_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|aux_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|aux_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate aux memory, aborting\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_ICM_AUX
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_ICM_AUX command failed, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_aux
goto|;
block|}
name|err
operator|=
name|mlx4_init_cmpt_table
argument_list|(
name|dev
argument_list|,
name|init_hca
operator|->
name|cmpt_base
argument_list|,
name|dev_cap
operator|->
name|cmpt_entry_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map cMPT context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_aux
goto|;
block|}
name|num_eqs
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|eqc_base
argument_list|,
name|dev_cap
operator|->
name|eqc_entry_sz
argument_list|,
name|num_eqs
argument_list|,
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map EQ context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cmpt
goto|;
block|}
comment|/* 	 * Reserved MTT entries must be aligned up to a cacheline 	 * boundary, since the FW will write to them, while the driver 	 * writes to all other MTT entries. (The variable 	 * dev->caps.mtt_entry_sz below is really the MTT segment 	 * size, not the raw entry size) 	 */
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|ALIGN
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|*
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dma_get_cache_alignment
argument_list|()
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|init_hca
operator|->
name|mtt_base
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mtts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MTT context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_eq
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|,
name|init_hca
operator|->
name|dmpt_base
argument_list|,
name|dev_cap
operator|->
name|dmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mpts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map dMPT context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_mtt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|,
name|init_hca
operator|->
name|qpc_base
argument_list|,
name|dev_cap
operator|->
name|qpc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map QP context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_dmpt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|,
name|init_hca
operator|->
name|auxc_base
argument_list|,
name|dev_cap
operator|->
name|aux_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map AUXC context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_qp
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|,
name|init_hca
operator|->
name|altc_base
argument_list|,
name|dev_cap
operator|->
name|altc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map ALTC context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_auxc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|,
name|init_hca
operator|->
name|rdmarc_base
argument_list|,
name|dev_cap
operator|->
name|rdmarc_entry_sz
operator|<<
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_shift
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map RDMARC context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_altc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|cqc_base
argument_list|,
name|dev_cap
operator|->
name|cqc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map CQ context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_rdmarc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|srqc_base
argument_list|,
name|dev_cap
operator|->
name|srq_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map SRQ context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cq
goto|;
block|}
comment|/* 	 * For flow steering device managed mode it is required to use 	 * mlx4_init_icm_table. For B0 steering mode it's not strictly 	 * required, but for simplicity just map the whole multicast 	 * group table now.  The table isn't very big and it's a lot 	 * easier than trying to track ref counts. 	 */
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|mc_base
argument_list|,
name|mlx4_get_mgm_entry_size
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MCG context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_srq
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_rdmarc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|err_unmap_altc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|err_unmap_auxc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|err_unmap_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|err_unmap_dmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_mtt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|err_unmap_eq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_aux
label|:
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_aux
label|:
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_icms
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_slave_exit
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_CMD_NA_OP
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to close slave function\n"
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|resource_size_t
name|bf_start
decl_stmt|;
name|resource_size_t
name|bf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
condition|)
return|return
operator|-
name|ENXIO
return|;
name|bf_start
operator|=
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|+
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|bf_len
operator|=
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|-
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|priv
operator|->
name|bf_mapping
operator|=
name|io_mapping_create_wc
argument_list|(
name|bf_start
argument_list|,
name|bf_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|bf_mapping
condition|)
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmap_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
condition|)
name|io_mapping_free
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|s64
name|mlx4_read_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|u32
name|clockhi
decl_stmt|,
name|clocklo
decl_stmt|,
name|clockhi1
decl_stmt|;
name|s64
name|cycles
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|clock_mapping
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|clockhi
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
argument_list|)
expr_stmt|;
name|clocklo
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|clockhi1
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockhi
operator|==
name|clockhi1
condition|)
break|break;
block|}
name|cycles
operator|=
operator|(
name|u64
operator|)
name|clockhi
operator|<<
literal|32
operator||
operator|(
name|u64
operator|)
name|clocklo
expr_stmt|;
return|return
name|cycles
operator|&
name|CORE_CLOCK_MASK
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_read_clock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|map_internal_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|priv
operator|->
name|clock_mapping
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|clock_bar
argument_list|)
operator|+
name|priv
operator|->
name|fw
operator|.
name|clock_offset
argument_list|,
name|MLX4_CLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|clock_mapping
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_internal_clock_params
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_clock_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
operator|-
name|EINVAL
return|;
name|params
operator|->
name|bar
operator|=
name|priv
operator|->
name|fw
operator|.
name|clock_bar
expr_stmt|;
name|params
operator|->
name|offset
operator|=
name|priv
operator|->
name|fw
operator|.
name|clock_offset
expr_stmt|;
name|params
operator|->
name|size
operator|=
name|MLX4_CLOCK_SIZE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_internal_clock_params
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unmap_internal_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|clock_mapping
condition|)
name|iounmap
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_close_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|unmap_internal_clock
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_slave_exit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
block|{
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_close_fw
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_comm_check_offline
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
define|#
directive|define
name|COMM_CHAN_OFFLINE_OFFSET
value|0x09
name|u32
name|comm_flags
decl_stmt|;
name|u32
name|offline_bit
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|end
operator|=
name|msecs_to_jiffies
argument_list|(
name|MLX4_COMM_OFFLINE_TIME_OUT
argument_list|)
operator|+
name|jiffies
expr_stmt|;
while|while
condition|(
name|time_before
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
block|{
name|comm_flags
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|(
name|__iomem
name|char
operator|*
operator|)
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|+
name|MLX4_COMM_CHAN_FLAGS
argument_list|)
argument_list|)
expr_stmt|;
name|offline_bit
operator|=
operator|(
name|comm_flags
operator|&
call|(
name|u32
call|)
argument_list|(
literal|1
operator|<<
name|COMM_CHAN_OFFLINE_OFFSET
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|offline_bit
condition|)
return|return
literal|0
return|;
comment|/* There are cases as part of AER/Reset flow that PF needs 		 * around 100 msec to load. We therefore sleep for 100 msec 		 * to allow other tasks to make use of that CPU during this 		 * time interval. 		 */
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Communication channel is offline.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_reset_vf_support
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
define|#
directive|define
name|COMM_CHAN_RST_OFFSET
value|0x1e
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|comm_rst
decl_stmt|;
name|u32
name|comm_caps
decl_stmt|;
name|comm_caps
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|(
name|__iomem
name|char
operator|*
operator|)
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|+
name|MLX4_COMM_CHAN_CAPS
argument_list|)
argument_list|)
expr_stmt|;
name|comm_rst
operator|=
operator|(
name|comm_caps
operator|&
call|(
name|u32
call|)
argument_list|(
literal|1
operator|<<
name|COMM_CHAN_RST_OFFSET
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|comm_rst
condition|)
name|dev
operator|->
name|caps
operator|.
name|vf_caps
operator||=
name|MLX4_VF_CAP_FLAG_RESET
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|dma
init|=
operator|(
name|u64
operator|)
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
decl_stmt|;
name|int
name|ret_from_reset
init|=
literal|0
decl_stmt|;
name|u32
name|slave_read
decl_stmt|;
name|u32
name|cmd_channel_ver
decl_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|pf_loading
argument_list|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"PF is not ready - Deferring probe\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mlx4_comm_check_offline
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"PF is not responsive, skipping initialization\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_offline
goto|;
block|}
name|mlx4_reset_vf_support
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Sending reset\n"
argument_list|)
expr_stmt|;
name|ret_from_reset
operator|=
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_CMD_NA_OP
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
expr_stmt|;
comment|/* if we are in the middle of flr the slave will try 	 * NUM_OF_RESET_RETRIES times before leaving.*/
if|if
condition|(
name|ret_from_reset
condition|)
block|{
if|if
condition|(
name|MLX4_DELAY_RESET_SLAVE
operator|==
name|ret_from_reset
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"slave is currently in the middle of FLR - Deferring probe\n"
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
else|else
goto|goto
name|err
goto|;
block|}
comment|/* check the driver version - the slave I/F revision 	 * must match the master's */
name|slave_read
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_read
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_channel_ver
operator|=
name|mlx4_comm_get_version
argument_list|()
expr_stmt|;
if|if
condition|(
name|MLX4_COMM_GET_IF_REV
argument_list|(
name|cmd_channel_ver
argument_list|)
operator|!=
name|MLX4_COMM_GET_IF_REV
argument_list|(
name|slave_read
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"slave driver version is not supported by the master\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Sending vhcr0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR0
argument_list|,
name|dma
operator|>>
literal|48
argument_list|,
name|MLX4_COMM_CMD_NA_OP
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR1
argument_list|,
name|dma
operator|>>
literal|32
argument_list|,
name|MLX4_COMM_CMD_NA_OP
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR2
argument_list|,
name|dma
operator|>>
literal|16
argument_list|,
name|MLX4_COMM_CMD_NA_OP
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR_EN
argument_list|,
name|dma
argument_list|,
name|MLX4_COMM_CMD_NA_OP
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_CMD_NA_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err_offline
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_parav_master_pf_caps
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
name|mlx4_get_slave_num_gids
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|i
index|]
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|choose_log_fs_mgm_entry_size
parameter_list|(
name|int
name|qp_per_entry
parameter_list|)
block|{
name|int
name|i
init|=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
decl_stmt|;
for|for
control|(
name|i
operator|=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
init|;
name|i
operator|<=
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_per_entry
operator|<=
literal|4
operator|*
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|/
literal|16
operator|-
literal|2
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|<=
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
operator|)
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dmfs_high_rate_steering_mode_str
parameter_list|(
name|int
name|dmfs_high_steer_mode
parameter_list|)
block|{
switch|switch
condition|(
name|dmfs_high_steer_mode
condition|)
block|{
case|case
name|MLX4_STEERING_DMFS_A0_DEFAULT
case|:
return|return
literal|"default performance"
return|;
case|case
name|MLX4_STEERING_DMFS_A0_DYNAMIC
case|:
return|return
literal|"dynamic hybrid mode"
return|;
case|case
name|MLX4_STEERING_DMFS_A0_STATIC
case|:
return|return
literal|"performance optimized for limited rule configuration (static)"
return|;
case|case
name|MLX4_STEERING_DMFS_A0_DISABLE
case|:
return|return
literal|"disabled performance optimized steering"
return|;
case|case
name|MLX4_STEERING_DMFS_A0_NOT_SUPPORTED
case|:
return|return
literal|"performance optimized steering not supported"
return|;
default|default:
return|return
literal|"Unrecognized mode"
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_DMFS_A0_STEERING
value|(1UL<< 2)
end_define

begin_function
specifier|static
name|void
name|choose_steering_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|-
name|mlx4_log_num_mgm_entry_size
operator|)
operator|&
name|MLX4_DMFS_A0_STEERING
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|==
name|MLX4_STEERING_DMFS_A0_NOT_SUPPORTED
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"DMFS high rate mode not supported\n"
argument_list|)
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|=
name|MLX4_STEERING_DMFS_A0_STATIC
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|<=
literal|0
operator|&&
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_FS_EN
operator|&&
operator|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
operator|>=
operator|(
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|+
literal|1
operator|)
operator|)
operator|)
operator|&&
name|choose_log_fs_mgm_entry_size
argument_list|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
argument_list|)
operator|>=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
condition|)
block|{
name|dev
operator|->
name|oper_log_mgm_entry_size
operator|=
name|choose_log_fs_mgm_entry_size
argument_list|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|fs_log_max_ucast_qp_range_size
operator|=
name|dev_cap
operator|->
name|fs_log_max_ucast_qp_range_size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|!=
name|MLX4_STEERING_DMFS_A0_NOT_SUPPORTED
condition|)
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|=
name|MLX4_STEERING_DMFS_A0_DISABLE
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
condition|)
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_B0
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_A0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|||
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Must have both UC_STEER and MC_STEER flags set to use B0 steering - falling back to A0 steering mode\n"
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|oper_log_mgm_entry_size
operator|=
name|mlx4_log_num_mgm_entry_size
operator|>
literal|0
condition|?
name|mlx4_log_num_mgm_entry_size
else|:
name|MLX4_DEFAULT_MGM_LOG_ENTRY_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|mlx4_get_qp_per_mgm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Steering mode is: %s, oper_log_mgm_entry_size = %d, modparam log_num_mgm_entry_size = %d\n"
argument_list|,
name|mlx4_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
argument_list|)
argument_list|,
name|dev
operator|->
name|oper_log_mgm_entry_size
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|choose_tunnel_offload_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
operator|&&
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_VXLAN_OFFLOADS
condition|)
name|dev
operator|->
name|caps
operator|.
name|tunnel_offload_mode
operator|=
name|MLX4_TUNNEL_OFFLOAD_MODE_VXLAN
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|tunnel_offload_mode
operator|=
name|MLX4_TUNNEL_OFFLOAD_MODE_NONE
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Tunneling offload mode is: %s\n"
argument_list|,
operator|(
name|dev
operator|->
name|caps
operator|.
name|tunnel_offload_mode
operator|==
name|MLX4_TUNNEL_OFFLOAD_MODE_VXLAN
operator|)
condition|?
literal|"vxlan"
else|:
literal|"none"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_validate_optimized_steering
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mlx4_port_cap
name|port_cap
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|==
name|MLX4_STEERING_DMFS_A0_NOT_SUPPORTED
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mlx4_dev_port
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|port_cap
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, can't veify DMFS high rate steering.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|!=
name|MLX4_STEERING_DMFS_A0_DEFAULT
operator|)
operator|&&
operator|(
name|port_cap
operator|.
name|dmfs_optimized_state
operator|==
operator|!
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|==
name|MLX4_STEERING_DMFS_A0_DISABLE
operator|)
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"DMFS high rate steer mode differ, driver requested %s but %s in FW.\n"
argument_list|,
name|dmfs_high_rate_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
argument_list|)
argument_list|,
operator|(
name|port_cap
operator|.
name|dmfs_optimized_state
condition|?
literal|"enabled"
else|:
literal|"disabled"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_fw
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_mod_stat_cfg
name|mlx4_cfg
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_QUERY_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EACCES
condition|)
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"non-primary physical function, skipping\n"
argument_list|)
expr_stmt|;
else|else
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FW command failed, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_load_fw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to start FW, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_cfg
operator|.
name|log_pg_sz_m
operator|=
literal|1
expr_stmt|;
name|mlx4_cfg
operator|.
name|log_pg_sz
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_MOD_STAT_CFG
argument_list|(
name|dev
argument_list|,
operator|&
name|mlx4_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to override log_pg_sz parameter\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_adapter
name|adapter
decl_stmt|;
name|struct
name|mlx4_dev_cap
name|dev_cap
decl_stmt|;
name|struct
name|mlx4_profile
name|profile
decl_stmt|;
name|struct
name|mlx4_init_hca_param
name|init_hca
decl_stmt|;
name|u64
name|icm_size
decl_stmt|;
name|struct
name|mlx4_config_dev_params
name|params
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_dev_cap
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|choose_steering_mode
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
name|choose_tunnel_offload_mode
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|==
name|MLX4_STEERING_DMFS_A0_STATIC
operator|&&
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|function_caps
operator||=
name|MLX4_FUNC_CAP_DMFS_A0_STATIC
expr_stmt|;
name|err
operator|=
name|mlx4_get_phys_port_id
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Fail to get physical port id\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_parav_master_pf_caps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_low_memory_profile
argument_list|()
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Running from within kdump kernel. Using low memory profile\n"
argument_list|)
expr_stmt|;
name|profile
operator|=
name|low_mem_profile
expr_stmt|;
block|}
else|else
block|{
name|profile
operator|=
name|default_profile
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|profile
operator|.
name|num_mcg
operator|=
name|MLX4_FS_NUM_MCG
expr_stmt|;
name|icm_size
operator|=
name|mlx4_make_profile
argument_list|(
name|dev
argument_list|,
operator|&
name|profile
argument_list|,
operator|&
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
name|long
operator|)
name|icm_size
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|icm_size
expr_stmt|;
return|return
name|err
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|max_fmr_maps
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_mpts
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|enable_4k_uar
condition|)
block|{
name|init_hca
operator|.
name|log_uar_sz
operator|=
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|)
operator|+
name|PAGE_SHIFT
operator|-
name|DEFAULT_UAR_PAGE_SHIFT
expr_stmt|;
name|init_hca
operator|.
name|uar_page_sz
operator|=
name|DEFAULT_UAR_PAGE_SHIFT
operator|-
literal|12
expr_stmt|;
block|}
else|else
block|{
name|init_hca
operator|.
name|log_uar_sz
operator|=
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|)
expr_stmt|;
name|init_hca
operator|.
name|uar_page_sz
operator|=
name|PAGE_SHIFT
operator|-
literal|12
expr_stmt|;
block|}
name|init_hca
operator|.
name|mw_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_MEM_WINDOW
operator|||
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&
name|MLX4_BMME_FLAG_TYPE_2_WIN
condition|)
name|init_hca
operator|.
name|mw_enabled
operator|=
name|INIT_HCA_TPT_MW_ENABLE
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|,
name|icm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mlx4_INIT_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INIT_HCA command failed, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_icm
goto|;
block|}
if|if
condition|(
name|dev_cap
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
condition|)
block|{
name|err
operator|=
name|mlx4_query_func
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FUNC command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
name|MLX4_QUERY_FUNC_NUM_SYS_EQS
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|=
name|dev_cap
operator|.
name|max_eqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|dev_cap
operator|.
name|reserved_eqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|=
name|dev_cap
operator|.
name|reserved_uars
expr_stmt|;
block|}
block|}
comment|/* 		 * If TS is supported by FW 		 * read HCA frequency by QUERY_HCA command 		 */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_TS
condition|)
block|{
name|memset
argument_list|(
operator|&
name|init_hca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|init_hca
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_HCA command failed, disable timestamp\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
operator|=
name|init_hca
operator|.
name|hca_core_clock
expr_stmt|;
block|}
comment|/* In case we got HCA frequency 0 - disable timestamping 			 * to avoid dividing by zero 			 */
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA frequency is 0 - timestamping is not supported\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map_internal_clock
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* 				 * Map internal clock, 				 * in case of failure disable timestamping 				 */
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map internal clock. Timestamping is not supported\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|!=
name|MLX4_STEERING_DMFS_A0_NOT_SUPPORTED
condition|)
block|{
if|if
condition|(
name|mlx4_validate_optimized_steering
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Optimized steering validation failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
operator|==
name|MLX4_STEERING_DMFS_A0_DISABLE
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_base
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_rate_qpn_range
operator|=
name|MLX4_A0_STEERING_TABLE_SIZE
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"DMFS high rate steer mode is: %s\n"
argument_list|,
name|dmfs_high_rate_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|dmfs_high_steer_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|mlx4_init_slave
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|!=
operator|-
name|EAGAIN
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize slave\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_slave_cap
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain slave caps\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
if|if
condition|(
name|map_bf_area
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Failed to map blue flame area\n"
argument_list|)
expr_stmt|;
comment|/*Only the master set the ports, all the rest got it from it.*/
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_ADAPTER
argument_list|(
name|dev
argument_list|,
operator|&
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_ADAPTER command failed, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|unmap_bf
goto|;
block|}
comment|/* Query CONFIG_DEV parameters */
name|err
operator|=
name|mlx4_config_dev_retrieval
argument_list|(
name|dev
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
operator|-
name|ENOTSUPP
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to query CONFIG_DEV parameters\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|rx_checksum_flags_port
index|[
literal|1
index|]
operator|=
name|params
operator|.
name|rx_csum_flags_port_1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|rx_checksum_flags_port
index|[
literal|2
index|]
operator|=
name|params
operator|.
name|rx_csum_flags_port_2
expr_stmt|;
block|}
name|priv
operator|->
name|eq_table
operator|.
name|inta_pin
operator|=
name|adapter
operator|.
name|inta_pin
expr_stmt|;
name|memcpy
argument_list|(
name|dev
operator|->
name|board_id
argument_list|,
name|adapter
operator|.
name|board_id
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|board_id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|unmap_bf
label|:
name|unmap_internal_clock
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_slave_exit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err_free_icm
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|nent_pow2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|max_counters
condition|)
return|return
operator|-
name|ENOSPC
return|;
name|nent_pow2
operator|=
name|roundup_pow_of_two
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|max_counters
argument_list|)
expr_stmt|;
comment|/* reserve last counter index for sink counter */
return|return
name|mlx4_bitmap_init
argument_list|(
operator|&
name|priv
operator|->
name|counters_bitmap
argument_list|,
name|nent_pow2
argument_list|,
name|nent_pow2
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|nent_pow2
operator|-
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|max_counters
condition|)
return|return;
name|mlx4_bitmap_cleanup
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|counters_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_default_counters
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
if|if
condition|(
name|priv
operator|->
name|def_counter
index|[
name|port
index|]
operator|!=
operator|-
literal|1
condition|)
name|mlx4_counter_free
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|def_counter
index|[
name|port
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_allocate_default_counters
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|u32
name|idx
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
name|priv
operator|->
name|def_counter
index|[
name|port
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|err
operator|=
name|mlx4_counter_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|||
name|err
operator|==
operator|-
name|ENOSPC
condition|)
block|{
name|priv
operator|->
name|def_counter
index|[
name|port
index|]
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
operator|-
name|ENOENT
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
operator|&&
name|err
operator|==
operator|-
name|EINVAL
condition|)
block|{
name|priv
operator|->
name|def_counter
index|[
name|port
index|]
operator|=
name|MLX4_SINK_COUNTER_INDEX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"can't allocate counter from old PF driver, using index %d\n"
argument_list|,
name|MLX4_SINK_COUNTER_INDEX
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s: failed to allocate default counter port %d err %d\n"
argument_list|,
name|__func__
argument_list|,
name|port
operator|+
literal|1
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|mlx4_cleanup_default_counters
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: default counter index %d for port %d\n"
argument_list|,
name|__func__
argument_list|,
name|priv
operator|->
name|def_counter
index|[
name|port
index|]
argument_list|,
name|port
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|__mlx4_counter_alloc
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
modifier|*
name|idx
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return
operator|-
name|ENOENT
return|;
operator|*
name|idx
operator|=
name|mlx4_bitmap_alloc
argument_list|(
operator|&
name|priv
operator|->
name|counters_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|idx
operator|=
name|MLX4_SINK_COUNTER_INDEX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSPC
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_counter_alloc
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
modifier|*
name|idx
parameter_list|)
block|{
name|u64
name|out_param
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|out_param
argument_list|,
name|RES_COUNTER
argument_list|,
name|RES_OP_RESERVE
argument_list|,
name|MLX4_CMD_ALLOC_RES
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|idx
operator|=
name|get_param_l
argument_list|(
operator|&
name|out_param
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
name|__mlx4_counter_alloc
argument_list|(
name|dev
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|__mlx4_clear_if_stat
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|counter_index
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|if_stat_mailbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|if_stat_in_mod
init|=
operator|(
name|counter_index
operator|&
literal|0xff
operator|)
operator||
name|MLX4_QUERY_IF_STAT_RESET
decl_stmt|;
name|if_stat_mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|if_stat_mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|if_stat_mailbox
argument_list|)
return|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|if_stat_mailbox
operator|->
name|dma
argument_list|,
name|if_stat_in_mod
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_IF_STAT
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|if_stat_mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|__mlx4_counter_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return;
if|if
condition|(
name|idx
operator|==
name|MLX4_SINK_COUNTER_INDEX
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|__mlx4_clear_if_stat
argument_list|(
name|dev
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mlx4_bitmap_free
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|counters_bitmap
argument_list|,
name|idx
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|mlx4_counter_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|u64
name|in_param
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|set_param_l
argument_list|(
operator|&
name|in_param
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|RES_COUNTER
argument_list|,
name|RES_OP_RESERVE
argument_list|,
name|MLX4_CMD_FREE_RES
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
return|return;
block|}
name|__mlx4_counter_free
argument_list|(
name|dev
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_get_default_counter_index
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|priv
operator|->
name|def_counter
index|[
name|port
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_default_counter_index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_set_admin_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|__be64
name|guid
parameter_list|,
name|int
name|entry
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|entry
index|]
operator|.
name|vport
index|[
name|port
index|]
operator|.
name|guid
operator|=
name|guid
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_set_admin_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|__be64
name|mlx4_get_admin_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|entry
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|entry
index|]
operator|.
name|vport
index|[
name|port
index|]
operator|.
name|guid
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_admin_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_set_random_admin_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|entry
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|__be64
name|guid
decl_stmt|;
comment|/* hw GUID */
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
return|return;
name|get_random_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|guid
argument_list|,
sizeof|sizeof
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|guid
operator|&=
operator|~
operator|(
name|cpu_to_be64
argument_list|(
literal|1ULL
operator|<<
literal|56
argument_list|)
operator|)
expr_stmt|;
name|guid
operator||=
name|cpu_to_be64
argument_list|(
literal|1ULL
operator|<<
literal|57
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_admin
index|[
name|entry
index|]
operator|.
name|vport
index|[
name|port
index|]
operator|.
name|guid
operator|=
name|guid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_setup_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|__be32
name|ib_port_default_caps
decl_stmt|;
name|err
operator|=
name|mlx4_init_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize user access region table, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_uar_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate driver access region, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_uar_table_free
goto|;
block|}
name|priv
operator|->
name|kar
operator|=
name|ioremap
argument_list|(
operator|(
name|phys_addr_t
operator|)
name|priv
operator|->
name|driver_uar
operator|.
name|pfn
operator|<<
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|kar
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map kernel access region, aborting\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_uar_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize protection domain table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_kar_unmap
goto|;
block|}
name|err
operator|=
name|mlx4_init_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize reliable connection domain table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_pd_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize memory region table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_xrcd_table_free
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_init_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize multicast group table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mr_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_config_mad_demux
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed in config_mad_demux, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mcg_table_free
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_init_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize event queue table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mcg_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_cmd_use_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to switch to event-driven firmware commands, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_eq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_NOP
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate MSI-X interrupt IRQ %d)\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MLX4_EQ_ASYNC
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Trying again without MSI-X\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate interrupt (IRQ %d), aborting\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MLX4_EQ_ASYNC
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"BIOS or ACPI interrupt routing problem?\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err_cmd_poll
goto|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"NOP command IRQ test passed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_init_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize completion queue table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd_poll
goto|;
block|}
name|err
operator|=
name|mlx4_init_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize shared receive queue table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize queue pair table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_srq_table_free
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_init_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
operator|-
name|ENOENT
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize counters table, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_qp_table_free
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_allocate_default_counters
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate default counters, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_counters_table_free
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|ib_port_default_caps
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_get_port_ib_caps
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|ib_port_default_caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to get port %d default ib capabilities (%d). Continuing with caps = 0\n"
argument_list|,
name|port
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_port_def_cap
index|[
name|port
index|]
operator|=
name|ib_port_default_caps
expr_stmt|;
comment|/* initialize per-slave default ib port capabilities */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
continue|continue;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
operator|.
name|ib_cap_mask
index|[
name|port
index|]
operator|=
name|ib_port_default_caps
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|port
index|]
operator|=
name|IB_MTU_2048
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|port
index|]
operator|=
name|IB_MTU_4096
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|?
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d, aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|err_default_countes_free
goto|;
block|}
block|}
block|}
return|return
literal|0
return|;
name|err_default_countes_free
label|:
name|mlx4_cleanup_default_counters
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_counters_table_free
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_qp_table_free
label|:
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_srq_table_free
label|:
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cq_table_free
label|:
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd_poll
label|:
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_eq_table_free
label|:
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mcg_table_free
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mr_table_free
label|:
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_xrcd_table_free
label|:
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_pd_table_free
label|:
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_kar_unmap
label|:
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|err_uar_free
label|:
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|err_uar_table_free
label|:
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_affinity_hint
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|eqn
parameter_list|)
block|{
name|int
name|requested_cpu
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_eq
modifier|*
name|eq
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|eqn
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|port
condition|;
name|i
operator|++
control|)
name|off
operator|+=
name|mlx4_get_eqs_per_port
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|requested_cpu
operator|=
name|eqn
operator|-
name|off
operator|-
operator|!
operator|!
operator|(
name|eqn
operator|>
name|MLX4_EQ_ASYNC
operator|)
expr_stmt|;
comment|/* Meaning EQs are shared, and this call comes from the second port */
if|if
condition|(
name|requested_cpu
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|eq
operator|=
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|eqn
index|]
expr_stmt|;
name|eq
operator|->
name|affinity_cpu_id
operator|=
name|requested_cpu
operator|%
name|num_online_cpus
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_enable_msi_x
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|msix_entry
modifier|*
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|port
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|msi_x
condition|)
block|{
name|int
name|nreq
init|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|*
name|num_online_cpus
argument_list|()
operator|+
literal|1
decl_stmt|;
name|nreq
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nreq
operator|>
name|MAX_MSIX
condition|)
name|nreq
operator|=
name|MAX_MSIX
expr_stmt|;
name|entries
operator|=
name|kcalloc
argument_list|(
name|nreq
argument_list|,
sizeof|sizeof
expr|*
name|entries
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entries
condition|)
goto|goto
name|no_msi
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
operator|++
name|i
control|)
name|entries
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|i
expr_stmt|;
name|nreq
operator|=
name|pci_enable_msix_range
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
name|entries
argument_list|,
literal|2
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nreq
operator|<
literal|0
operator|||
name|nreq
operator|<
name|MLX4_EQ_ASYNC
condition|)
block|{
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
goto|goto
name|no_msi
goto|;
block|}
comment|/* 1 is reserved for events (asyncrounous EQ) */
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
name|nreq
operator|-
literal|1
expr_stmt|;
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MLX4_EQ_ASYNC
index|]
operator|.
name|irq
operator|=
name|entries
index|[
literal|0
index|]
operator|.
name|vector
expr_stmt|;
name|bitmap_zero
argument_list|(
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MLX4_EQ_ASYNC
index|]
operator|.
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|MLX4_EQ_ASYNC
condition|)
continue|continue;
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|entries
index|[
name|i
operator|+
literal|1
operator|-
operator|!
operator|!
operator|(
name|i
operator|>
name|MLX4_EQ_ASYNC
operator|)
index|]
operator|.
name|vector
expr_stmt|;
if|if
condition|(
name|MLX4_IS_LEGACY_EQ_MODE
argument_list|(
name|dev
operator|->
name|caps
argument_list|)
condition|)
block|{
name|bitmap_fill
argument_list|(
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
comment|/* We don't set affinity hint when there 				 * aren't enough EQs 				 */
block|}
else|else
block|{
name|set_bit
argument_list|(
name|port
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|actv_ports
operator|.
name|ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_init_affinity_hint
argument_list|(
name|dev
argument_list|,
name|port
operator|+
literal|1
argument_list|,
name|i
argument_list|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Couldn't init hint cpumask for EQ %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* We divide the Eqs evenly between the two ports. 			 * (dev->caps.num_comp_vectors / dev->caps.num_ports) 			 * refers to the number of Eqs per port 			 * (i.e eqs_per_port). Theoretically, we would like to 			 * write something like (i + 1) % eqs_per_port == 0. 			 * However, since there's an asynchronous Eq, we have 			 * to skip over it by comparing this condition to 			 * !!((i + 1)> MLX4_EQ_ASYNC). 			 */
if|if
condition|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|)
operator|&&
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|/
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|)
operator|)
operator|==
operator|!
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|>
name|MLX4_EQ_ASYNC
operator|)
condition|)
comment|/* If dev->caps.num_comp_vectors< dev->caps.num_ports, 				 * everything is shared anyway. 				 */
name|port
operator|++
expr_stmt|;
block|}
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
return|return;
block|}
name|no_msi
label|:
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|1
expr_stmt|;
name|BUG_ON
argument_list|(
name|MLX4_EQ_ASYNC
operator|>=
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|irq
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|MLX4_EQ_ASYNC
condition|)
block|{
name|bitmap_fill
argument_list|(
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|actv_ports
operator|.
name|ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_port_info
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|port
index|[
name|port
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|info
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|info
operator|->
name|port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_init_mac_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|mac_table
argument_list|)
expr_stmt|;
name|mlx4_init_vlan_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|vlan_table
argument_list|)
expr_stmt|;
name|mlx4_init_roce_gid_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|gid_table
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_qpn
operator|=
name|mlx4_get_base_qpn
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|info
operator|->
name|dev_name
argument_list|,
literal|"mlx4_port%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|name
operator|=
name|info
operator|->
name|dev_name
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
expr_stmt|;
else|else
block|{
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
operator||
name|S_IWUSR
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|store
operator|=
name|set_port_type
expr_stmt|;
block|}
name|info
operator|->
name|port_attr
operator|.
name|show
operator|=
name|show_port_type
expr_stmt|;
name|sysfs_attr_init
argument_list|(
operator|&
name|info
operator|->
name|port_attr
operator|.
name|attr
argument_list|)
expr_stmt|;
name|err
operator|=
name|device_create_file
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create file for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|info
operator|->
name|dev_mtu_name
argument_list|,
literal|"mlx4_port%d_mtu"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|name
operator|=
name|info
operator|->
name|dev_mtu_name
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
expr_stmt|;
else|else
block|{
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
operator||
name|S_IWUSR
expr_stmt|;
name|info
operator|->
name|port_mtu_attr
operator|.
name|store
operator|=
name|set_port_ib_mtu
expr_stmt|;
block|}
name|info
operator|->
name|port_mtu_attr
operator|.
name|show
operator|=
name|show_port_ib_mtu
expr_stmt|;
name|sysfs_attr_init
argument_list|(
operator|&
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
argument_list|)
expr_stmt|;
name|err
operator|=
name|device_create_file
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_mtu_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create mtu file for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
name|info
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_port_info
parameter_list|(
name|struct
name|mlx4_port_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|port
operator|<
literal|0
condition|)
return|return;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_mtu_attr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_RFS_ACCEL
name|free_irq_cpu_rmap
argument_list|(
name|info
operator|->
name|rmap
argument_list|)
expr_stmt|;
name|info
operator|->
name|rmap
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_steering
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|num_entries
init|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|priv
operator|->
name|steer
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_steer
argument_list|)
operator|*
name|num_entries
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|steer
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_NUM_STEERS
condition|;
name|j
operator|++
control|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|steer
index|[
name|i
index|]
operator|.
name|promisc_qps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|steer
index|[
name|i
index|]
operator|.
name|steer_entries
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_clear_steering
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tmp_entry
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|,
modifier|*
name|tmp_pqp
decl_stmt|;
name|int
name|num_entries
init|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_NUM_STEERS
condition|;
name|j
operator|++
control|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|pqp
argument_list|,
argument|tmp_pqp
argument_list|,
argument|&priv->steer[i].promisc_qps[j]
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|entry
argument_list|,
argument|tmp_entry
argument_list|,
argument|&priv->steer[i].steer_entries[j]
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|entry
operator|->
name|list
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|pqp
argument_list|,
argument|tmp_pqp
argument_list|,
argument|&entry->duplicates
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|kfree
argument_list|(
name|priv
operator|->
name|steer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|extended_func_num
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|PCI_SLOT
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
operator|*
literal|8
operator|+
name|PCI_FUNC
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_OWNER_BASE
value|0x8069c
end_define

begin_define
define|#
directive|define
name|MLX4_OWNER_SIZE
value|4
end_define

begin_function
specifier|static
name|int
name|mlx4_get_ownership
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|owner
decl_stmt|;
name|u32
name|ret
decl_stmt|;
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|owner
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_OWNER_BASE
argument_list|,
name|MLX4_OWNER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owner
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain ownership bit\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|readl
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|owner
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
operator|!
operator|!
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_ownership
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|owner
decl_stmt|;
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|)
condition|)
return|return;
name|owner
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_OWNER_BASE
argument_list|,
name|MLX4_OWNER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owner
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain ownership bit\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|writel
argument_list|(
literal|0
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SRIOV_VALID_STATE
parameter_list|(
name|flags
parameter_list|)
value|(!!((flags)& MLX4_FLAG_SRIOV)	==\ 				  !!((flags)& MLX4_FLAG_MASTER))
end_define

begin_function
specifier|static
name|u64
name|mlx4_enable_sriov
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|u8
name|total_vfs
parameter_list|,
name|int
name|existing_vfs
parameter_list|,
name|int
name|reset_flow
parameter_list|)
block|{
name|u64
name|dev_flags
init|=
name|dev
operator|->
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reset_flow
condition|)
block|{
name|dev
operator|->
name|dev_vfs
operator|=
name|kcalloc
argument_list|(
name|total_vfs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
operator|->
name|dev_vfs
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|dev_vfs
condition|)
goto|goto
name|free_mem
goto|;
return|return
name|dev_flags
return|;
block|}
name|atomic_inc
argument_list|(
operator|&
name|pf_loading
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
condition|)
block|{
if|if
condition|(
name|existing_vfs
operator|!=
name|total_vfs
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"SR-IOV was already enabled, but with num_vfs (%d) different than requested (%d)\n"
argument_list|,
name|existing_vfs
argument_list|,
name|total_vfs
argument_list|)
expr_stmt|;
name|total_vfs
operator|=
name|existing_vfs
expr_stmt|;
block|}
block|}
name|dev
operator|->
name|dev_vfs
operator|=
name|kzalloc
argument_list|(
name|total_vfs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dev
operator|->
name|dev_vfs
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|dev
operator|->
name|dev_vfs
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate memory for VFs\n"
argument_list|)
expr_stmt|;
goto|goto
name|disable_sriov
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Enabling SR-IOV with %d VFs\n"
argument_list|,
name|total_vfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_enable_sriov
argument_list|(
name|pdev
argument_list|,
name|total_vfs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to enable SR-IOV, continuing without SR-IOV (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|disable_sriov
goto|;
block|}
else|else
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Running in master mode\n"
argument_list|)
expr_stmt|;
name|dev_flags
operator||=
name|MLX4_FLAG_SRIOV
operator||
name|MLX4_FLAG_MASTER
expr_stmt|;
name|dev_flags
operator|&=
operator|~
name|MLX4_FLAG_SLAVE
expr_stmt|;
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|=
name|total_vfs
expr_stmt|;
block|}
return|return
name|dev_flags
return|;
name|disable_sriov
label|:
name|atomic_dec
argument_list|(
operator|&
name|pf_loading
argument_list|)
expr_stmt|;
name|free_mem
label|:
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|=
literal|0
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|dev_vfs
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_vfs
operator|=
name|NULL
expr_stmt|;
return|return
name|dev_flags
operator|&
operator|~
name|MLX4_FLAG_MASTER
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|MLX4_DEV_CAP_CHECK_NUM_VFS_ABOVE_64
init|=
operator|-
literal|1
block|, }
enum|;
end_enum

begin_function
specifier|static
name|int
name|mlx4_check_dev_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|int
modifier|*
name|nvfs
parameter_list|)
block|{
name|int
name|requested_vfs
init|=
name|nvfs
index|[
literal|0
index|]
operator|+
name|nvfs
index|[
literal|1
index|]
operator|+
name|nvfs
index|[
literal|2
index|]
decl_stmt|;
comment|/* Checking for 64 VFs as a limitation of CX2 */
if|if
condition|(
operator|!
operator|(
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_80_VFS
operator|)
operator|&&
name|requested_vfs
operator|>=
literal|64
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Requested %d VFs, but FW does not support more than 64\n"
argument_list|,
name|requested_vfs
argument_list|)
expr_stmt|;
return|return
name|MLX4_DEV_CAP_CHECK_NUM_VFS_ABOVE_64
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_pci_enable_device
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|dev
operator|->
name|persist
operator|->
name|pdev
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pci_status_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|pci_status
operator|==
name|MLX4_PCI_STATUS_DISABLED
condition|)
block|{
name|err
operator|=
name|pci_enable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|dev
operator|->
name|persist
operator|->
name|pci_status
operator|=
name|MLX4_PCI_STATUS_ENABLED
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pci_status_mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_pci_disable_device
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|dev
operator|->
name|persist
operator|->
name|pdev
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pci_status_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|persist
operator|->
name|pci_status
operator|==
name|MLX4_PCI_STATUS_ENABLED
condition|)
block|{
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|persist
operator|->
name|pci_status
operator|=
name|MLX4_PCI_STATUS_DISABLED
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pci_status_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_load_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|pci_dev_data
parameter_list|,
name|int
name|total_vfs
parameter_list|,
name|int
modifier|*
name|nvfs
parameter_list|,
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|,
name|int
name|reset_flow
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
decl_stmt|;
name|unsigned
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
init|=
name|NULL
decl_stmt|;
name|int
name|existing_vfs
init|=
literal|0
decl_stmt|;
name|dev
operator|=
operator|&
name|priv
operator|->
name|dev
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|ctx_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|ctx_lock
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|bond_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_mutex
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context_lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|bf_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|bf_mutex
argument_list|)
expr_stmt|;
name|dev
operator|->
name|rev_id
operator|=
name|pdev
operator|->
name|revision
expr_stmt|;
name|dev
operator|->
name|numa_node
operator|=
name|dev_to_node
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Detect if this device is a virtual function */
if|if
condition|(
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_IS_VF
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Detected virtual function - running in slave mode\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SLAVE
expr_stmt|;
block|}
else|else
block|{
comment|/* We reset the device and enable SRIOV only for physical 		 * devices.  Try to claim ownership on the device; 		 * if already taken, skip -- do not allow multiple PFs */
name|err
operator|=
name|mlx4_get_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
else|else
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Multiple PFs not yet supported - Skipping PF\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|atomic_set
argument_list|(
operator|&
name|priv
operator|->
name|opreq_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|priv
operator|->
name|opreq_task
argument_list|,
name|mlx4_opreq_action
argument_list|)
expr_stmt|;
comment|/* 		 * Now reset the HCA before we touch the PCI capabilities or 		 * attempt a firmware command, since a boot ROM may have left 		 * the HCA in an undefined state. 		 */
name|err
operator|=
name|mlx4_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to reset HCA, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
if|if
condition|(
name|total_vfs
condition|)
block|{
name|dev
operator|->
name|flags
operator|=
name|MLX4_FLAG_MASTER
expr_stmt|;
name|existing_vfs
operator|=
name|pci_num_vf
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|existing_vfs
condition|)
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SRIOV
expr_stmt|;
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|=
name|total_vfs
expr_stmt|;
block|}
block|}
comment|/* on load remove any previous indication of internal error, 	 * device is up. 	 */
name|dev
operator|->
name|persist
operator|->
name|state
operator|=
name|MLX4_DEVICE_STATE_UP
expr_stmt|;
name|slave_start
label|:
name|err
operator|=
name|mlx4_cmd_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init command interface, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
comment|/* In slave functions, the communication channel must be initialized 	 * before posting commands. Also, init num_slaves before calling 	 * mlx4_init_hca */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|num_slaves
operator|=
name|MLX4_MAX_NUM_SLAVES
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|num_slaves
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_multi_func_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init slave mfunc interface, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd
goto|;
block|}
block|}
block|}
name|err
operator|=
name|mlx4_init_fw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init fw, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mfunc
goto|;
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* when we hit the goto slave_start below, dev_cap already initialized */
if|if
condition|(
operator|!
name|dev_cap
condition|)
block|{
name|dev_cap
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dev_cap
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_cap
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_fw
goto|;
block|}
name|err
operator|=
name|mlx4_QUERY_DEV_CAP
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_fw
goto|;
block|}
if|if
condition|(
name|mlx4_check_dev_cap
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|,
name|nvfs
argument_list|)
condition|)
goto|goto
name|err_fw
goto|;
if|if
condition|(
operator|!
operator|(
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
operator|)
condition|)
block|{
name|u64
name|dev_flags
init|=
name|mlx4_enable_sriov
argument_list|(
name|dev
argument_list|,
name|pdev
argument_list|,
name|total_vfs
argument_list|,
name|existing_vfs
argument_list|,
name|reset_flow
argument_list|)
decl_stmt|;
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_CLEANUP_ALL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|=
name|dev_flags
expr_stmt|;
if|if
condition|(
operator|!
name|SRIOV_VALID_STATE
argument_list|(
name|dev
operator|->
name|flags
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Invalid SRIOV state\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
name|err
operator|=
name|mlx4_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to reset HCA, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
goto|goto
name|slave_start
goto|;
block|}
block|}
else|else
block|{
comment|/* Legacy mode FW requires SRIOV to be enabled before 			 * doing QUERY_DEV_CAP, since max_eq's value is different if 			 * SRIOV is enabled. 			 */
name|memset
argument_list|(
name|dev_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev_cap
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_DEV_CAP
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_fw
goto|;
block|}
if|if
condition|(
name|mlx4_check_dev_cap
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|,
name|nvfs
argument_list|)
condition|)
goto|goto
name|err_fw
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_init_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EACCES
condition|)
block|{
comment|/* Not primary Physical function 			 * Running in slave mode */
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_CLEANUP_ALL
argument_list|)
expr_stmt|;
comment|/* We're not a PF */
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
condition|)
block|{
if|if
condition|(
operator|!
name|existing_vfs
condition|)
name|pci_disable_sriov
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|reset_flow
condition|)
name|atomic_dec
argument_list|(
operator|&
name|pf_loading
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_SRIOV
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SLAVE
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_MASTER
expr_stmt|;
goto|goto
name|slave_start
goto|;
block|}
else|else
goto|goto
name|err_fw
goto|;
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
operator|)
condition|)
block|{
name|u64
name|dev_flags
init|=
name|mlx4_enable_sriov
argument_list|(
name|dev
argument_list|,
name|pdev
argument_list|,
name|total_vfs
argument_list|,
name|existing_vfs
argument_list|,
name|reset_flow
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|^
name|dev_flags
operator|)
operator|&
operator|(
name|MLX4_FLAG_MASTER
operator||
name|MLX4_FLAG_SLAVE
operator|)
condition|)
block|{
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_CLEANUP_VHCR
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|=
name|dev_flags
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Only VHCR is cleaned up, so could still 				 * send FW commands 				 */
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init VHCR command interface, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
else|else
block|{
name|dev
operator|->
name|flags
operator|=
name|dev_flags
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SRIOV_VALID_STATE
argument_list|(
name|dev
operator|->
name|flags
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Invalid SRIOV state\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
comment|/* check if the device is functioning at its maximum possible speed. 	 * No return code for this call, just warn the user in case of PCI 	 * express device capabilities are under-satisfied by the bus. 	 */
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_check_pcie_caps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* In master functions, the communication channel must be initialized 	 * after obtaining its address from fw */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|<
literal|2
operator|&&
name|num_vfs_argc
operator|>
literal|1
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Error: Trying to configure VFs on port 2, but HCA has only %d physical ports\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
name|memcpy
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|nvfs
argument_list|,
name|nvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|nvfs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|nvfs
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dev
operator|->
name|persist
operator|->
name|nvfs
index|[
name|i
index|]
condition|;
operator|++
name|sum
operator|,
operator|++
name|j
control|)
block|{
name|dev
operator|->
name|dev_vfs
index|[
name|sum
index|]
operator|.
name|min_port
operator|=
name|i
operator|<
literal|2
condition|?
name|i
operator|+
literal|1
else|:
literal|1
expr_stmt|;
name|dev
operator|->
name|dev_vfs
index|[
name|sum
index|]
operator|.
name|n_ports
operator|=
name|i
operator|<
literal|2
condition|?
literal|1
else|:
name|dev
operator|->
name|caps
operator|.
name|num_ports
expr_stmt|;
block|}
block|}
comment|/* In master functions, the communication channel 		 * must be initialized after obtaining its address from fw 		 */
name|err
operator|=
name|mlx4_multi_func_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init master mfunc interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_alloc_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_master_mfunc
goto|;
name|bitmap_zero
argument_list|(
name|priv
operator|->
name|msix_ctl
operator|.
name|pool_bm
argument_list|,
name|MAX_MSIX
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|msix_ctl
operator|.
name|pool_lock
argument_list|)
expr_stmt|;
name|mlx4_enable_msi_x
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
operator|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INTx is not supported in multi-function mode, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_eq
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_init_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_disable_msix
goto|;
block|}
name|mlx4_init_quotas
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|EBUSY
operator|&&
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
operator|)
operator|&&
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|1
expr_stmt|;
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|err_steer
goto|;
comment|/* When PF resources are ready arm its comm channel to enable 	 * getting commands 	 */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_ARM_COMM_CHANNEL
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|" Failed to arm comm channel eq: %x\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_steer
goto|;
block|}
block|}
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|err
operator|=
name|mlx4_init_port_info
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
block|}
name|priv
operator|->
name|v2p
operator|.
name|port1
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|v2p
operator|.
name|port2
operator|=
literal|2
expr_stmt|;
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
name|mlx4_request_modules
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_sense_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|priv
operator|->
name|removed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|&&
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|&&
operator|!
name|reset_flow
condition|)
name|atomic_dec
argument_list|(
operator|&
name|pf_loading
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev_cap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_port
label|:
for|for
control|(
operator|--
name|port
init|;
name|port
operator|>=
literal|1
condition|;
operator|--
name|port
control|)
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|port
index|]
argument_list|)
expr_stmt|;
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_steer
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_clear_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_disable_msix
label|:
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err_free_eq
label|:
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_master_mfunc
label|:
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_STRUCTS_ONLY
argument_list|)
expr_stmt|;
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_fw
label|:
name|mlx4_close_fw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mfunc
label|:
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd
label|:
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_CLEANUP_ALL
argument_list|)
expr_stmt|;
name|err_sriov
label|:
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
operator|&&
operator|!
name|existing_vfs
condition|)
block|{
name|pci_disable_sriov
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_SRIOV
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|&&
name|dev
operator|->
name|persist
operator|->
name|num_vfs
operator|&&
operator|!
name|reset_flow
condition|)
name|atomic_dec
argument_list|(
operator|&
name|pf_loading
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|dev
operator|.
name|dev_vfs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev_cap
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|pci_dev_data
parameter_list|,
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|nvfs
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|prb_vf
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|int
name|param_map
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|unsigned
name|total_vfs
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|pr_info
argument_list|(
name|DRV_NAME
literal|": Initializing %s\n"
argument_list|,
name|pci_name
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_pci_enable_device
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot enable PCI device, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Due to requirement that all VFs and the PF are *guaranteed* 2 MACS 	 * per port, we must limit the number of VFs to 63 (since their are 	 * 128 MACs) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|nvfs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|nvfs
index|[
literal|0
index|]
argument_list|)
operator|&&
name|i
operator|<
name|num_vfs_argc
condition|;
name|total_vfs
operator|+=
name|nvfs
index|[
name|param_map
index|[
name|num_vfs_argc
operator|-
literal|1
index|]
index|[
name|i
index|]
index|]
operator|,
name|i
operator|++
control|)
block|{
name|nvfs
index|[
name|param_map
index|[
name|num_vfs_argc
operator|-
literal|1
index|]
index|[
name|i
index|]
index|]
operator|=
name|num_vfs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nvfs
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"num_vfs module parameter cannot be negative\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prb_vf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|prb_vf
index|[
literal|0
index|]
argument_list|)
operator|&&
name|i
operator|<
name|probe_vfs_argc
condition|;
name|i
operator|++
control|)
block|{
name|prb_vf
index|[
name|param_map
index|[
name|probe_vfs_argc
operator|-
literal|1
index|]
index|[
name|i
index|]
index|]
operator|=
name|probe_vf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|prb_vf
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|prb_vf
index|[
name|i
index|]
operator|>
name|nvfs
index|[
name|i
index|]
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"probe_vf module parameter cannot be negative or greater than num_vfs\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
block|}
if|if
condition|(
name|total_vfs
operator|>
name|MLX4_MAX_NUM_VF
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Requested more VF's (%d) than allowed by hw (%d)\n"
argument_list|,
name|total_vfs
argument_list|,
name|MLX4_MAX_NUM_VF
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvfs
index|[
name|i
index|]
operator|+
name|nvfs
index|[
literal|2
index|]
operator|>
name|MLX4_MAX_NUM_VF_P_PORT
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Requested more VF's (%d) for port (%d) than allowed by driver (%d)\n"
argument_list|,
name|nvfs
index|[
name|i
index|]
operator|+
name|nvfs
index|[
literal|2
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|MLX4_MAX_NUM_VF_P_PORT
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
block|}
comment|/* Check for BARs. */
if|if
condition|(
operator|!
operator|(
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_IS_VF
operator|)
operator|&&
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing DCS, aborting (driver_data: 0x%x, pci_resource_flags(pdev, 0):0x%lx)\n"
argument_list|,
name|pci_dev_data
argument_list|,
operator|(
name|long
operator|)
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing UAR, aborting\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|err
operator|=
name|pci_request_regions
argument_list|(
name|pdev
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Couldn't get PCI resources, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|pci_set_master
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit PCI DMA mask\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set PCI DMA mask, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
block|}
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit consistent PCI DMA mask\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set consistent PCI DMA mask, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
block|}
comment|/* Allow large DMA segments, up to the firmware limit of 1 GB */
name|dma_set_max_seg_size
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|1024
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* Detect if this device is a virtual function */
if|if
condition|(
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_IS_VF
condition|)
block|{
comment|/* When acting as pf, we normally skip vfs unless explicitly 		 * requested to probe them. 		 */
if|if
condition|(
name|total_vfs
condition|)
block|{
name|unsigned
name|vfs_offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|nvfs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|nvfs
index|[
literal|0
index|]
argument_list|)
operator|&&
name|vfs_offset
operator|+
name|nvfs
index|[
name|i
index|]
operator|<
name|extended_func_num
argument_list|(
name|pdev
argument_list|)
condition|;
name|vfs_offset
operator|+=
name|nvfs
index|[
name|i
index|]
operator|,
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|nvfs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|nvfs
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
if|if
condition|(
operator|(
name|extended_func_num
argument_list|(
name|pdev
argument_list|)
operator|-
name|vfs_offset
operator|)
operator|>
name|prb_vf
index|[
name|i
index|]
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Skipping virtual function:%d\n"
argument_list|,
name|extended_func_num
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
block|}
block|}
name|err
operator|=
name|mlx4_catas_init
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_release_regions
goto|;
name|err
operator|=
name|mlx4_load_one
argument_list|(
name|pdev
argument_list|,
name|pci_dev_data
argument_list|,
name|total_vfs
argument_list|,
name|nvfs
argument_list|,
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_catas
goto|;
return|return
literal|0
return|;
name|err_catas
label|:
name|mlx4_catas_end
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|)
expr_stmt|;
name|err_release_regions
label|:
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err_disable_pdev
label|:
name|mlx4_pci_disable_device
argument_list|(
operator|&
name|priv
operator|->
name|dev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|printk_once
argument_list|(
name|KERN_INFO
literal|"%s"
argument_list|,
name|mlx4_version
argument_list|)
expr_stmt|;
name|priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|dev
operator|=
operator|&
name|priv
operator|->
name|dev
expr_stmt|;
name|dev
operator|->
name|persist
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dev
operator|->
name|persist
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|persist
condition|)
block|{
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev
operator|->
name|persist
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|dev
operator|->
name|persist
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|dev
operator|->
name|persist
argument_list|)
expr_stmt|;
name|priv
operator|->
name|pci_dev_data
operator|=
name|id
operator|->
name|driver_data
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|device_state_mutex
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dev
operator|->
name|persist
operator|->
name|pci_status_mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
name|id
operator|->
name|driver_data
argument_list|,
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|persist
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_save_state
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_clean_dev
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|dev
operator|->
name|persist
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|flags
init|=
operator|(
name|dev
operator|->
name|flags
operator|&
name|RESET_PERSIST_MASK_FLAGS
operator|)
decl_stmt|;
name|memset
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|dev
operator|.
name|persist
operator|=
name|persist
expr_stmt|;
name|priv
operator|->
name|dev
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_unload_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|persist
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|pci_dev_data
decl_stmt|;
name|int
name|p
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|removed
condition|)
return|return;
comment|/* saving current ports type for further use */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|dev
operator|->
name|persist
operator|->
name|curr_port_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|dev
operator|->
name|persist
operator|->
name|curr_port_poss_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|pci_dev_data
operator|=
name|priv
operator|->
name|pci_dev_data
expr_stmt|;
name|mlx4_stop_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|p
operator|++
control|)
block|{
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_SLAVES_ONLY
argument_list|)
expr_stmt|;
name|mlx4_cleanup_default_counters
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_STRUCTS_ONLY
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_clear_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_close_fw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_CLEANUP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_qkey
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|dev_vfs
argument_list|)
expr_stmt|;
name|mlx4_clean_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|priv
operator|->
name|pci_dev_data
operator|=
name|pci_dev_data
expr_stmt|;
name|priv
operator|->
name|removed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_remove_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|persist
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|active_vfs
init|=
literal|0
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
name|persist
operator|->
name|interface_state
operator||=
name|MLX4_INTERFACE_STATE_DELETION
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
comment|/* Disabling SR-IOV is not allowed while there are active vf's */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|&&
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
condition|)
block|{
name|active_vfs
operator|=
name|mlx4_how_many_lives_vf
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_vfs
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Removing PF when there are active VF's !!\n"
argument_list|)
expr_stmt|;
name|pr_warn
argument_list|(
literal|"Will not disable SR-IOV.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* device marked to be under deletion running now without the lock 	 * letting other tasks to be terminated 	 */
if|if
condition|(
name|persist
operator|->
name|interface_state
operator|&
name|MLX4_INTERFACE_STATE_UP
condition|)
name|mlx4_unload_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
else|else
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"%s: interface is down\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mlx4_catas_end
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
operator|&&
operator|!
name|active_vfs
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Disabling SR-IOV\n"
argument_list|)
expr_stmt|;
name|pci_disable_sriov
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
block|}
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|persist
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|restore_current_port_types
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|types
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|poss_types
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|mlx4_stop_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|poss_types
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_change_port_types
argument_list|(
name|dev
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_restart_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|persist
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|nvfs
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|pci_dev_data
decl_stmt|,
name|err
decl_stmt|,
name|total_vfs
decl_stmt|;
name|pci_dev_data
operator|=
name|priv
operator|->
name|pci_dev_data
expr_stmt|;
name|total_vfs
operator|=
name|dev
operator|->
name|persist
operator|->
name|num_vfs
expr_stmt|;
name|memcpy
argument_list|(
name|nvfs
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|nvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|mlx4_unload_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_load_one
argument_list|(
name|pdev
argument_list|,
name|pci_dev_data
argument_list|,
name|total_vfs
argument_list|,
name|nvfs
argument_list|,
name|priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s: ERROR: mlx4_load_one failed, pci_name=%s, err=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pci_name
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|restore_current_port_types
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|curr_port_type
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|curr_port_poss_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"could not restore original port types (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEFINE_PCI_DEVICE_TABLE
argument_list|(
name|mlx4_pci_table
argument_list|)
operator|=
block|{
comment|/* MT25408 "Hermon" SDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6340
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" DDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x634a
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" QDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6354
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" DDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6732
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" QDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x673c
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6368
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6750
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6372
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T+Gen2 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x675a
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26468 ConnectX EN 10GigE PCIe gen2*/
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6764
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26438 ConnectX EN 40GigE PCIe gen2 5GT/s */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6746
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26478 ConnectX2 40GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x676e
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25400 Family [ConnectX-2 Virtual Function] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1002
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_IS_VF
block|}
block|,
comment|/* MT27500 Family [ConnectX-3] */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1003
argument_list|)
block|}
block|,
comment|/* MT27500 Family [ConnectX-3 Virtual Function] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1004
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|MLX4_PCI_DEV_IS_VF
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1005
argument_list|)
block|}
block|,
comment|/* MT27510 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1006
argument_list|)
block|}
block|,
comment|/* MT27511 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1007
argument_list|)
block|}
block|,
comment|/* MT27520 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1008
argument_list|)
block|}
block|,
comment|/* MT27521 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1009
argument_list|)
block|}
block|,
comment|/* MT27530 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100a
argument_list|)
block|}
block|,
comment|/* MT27531 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100b
argument_list|)
block|}
block|,
comment|/* MT27540 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100c
argument_list|)
block|}
block|,
comment|/* MT27541 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100d
argument_list|)
block|}
block|,
comment|/* MT27550 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100e
argument_list|)
block|}
block|,
comment|/* MT27551 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100f
argument_list|)
block|}
block|,
comment|/* MT27560 Family */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1010
argument_list|)
block|}
block|,
comment|/* MT27561 Family */
block|{
literal|0
block|, }
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|mlx4_pci_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|pci_ers_result_t
name|mlx4_pci_err_detected
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|pci_channel_state_t
name|state
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|mlx4_err
argument_list|(
name|persist
operator|->
name|dev
argument_list|,
literal|"mlx4_pci_err_detected was called\n"
argument_list|)
expr_stmt|;
name|mlx4_enter_error_state
argument_list|(
name|persist
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|persist
operator|->
name|interface_state
operator|&
name|MLX4_INTERFACE_STATE_UP
condition|)
name|mlx4_unload_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|pci_channel_io_perm_failure
condition|)
return|return
name|PCI_ERS_RESULT_DISCONNECT
return|;
name|mlx4_pci_disable_device
argument_list|(
name|persist
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
name|PCI_ERS_RESULT_NEED_RESET
return|;
block|}
end_function

begin_function
specifier|static
name|pci_ers_result_t
name|mlx4_pci_slot_reset
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|persist
operator|->
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"mlx4_pci_slot_reset was called\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_pci_enable_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Can not re-enable device, err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|PCI_ERS_RESULT_DISCONNECT
return|;
block|}
name|pci_set_master
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
name|PCI_ERS_RESULT_RECOVERED
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_pci_resume
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|persist
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|nvfs
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|total_vfs
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s was called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|total_vfs
operator|=
name|dev
operator|->
name|persist
operator|->
name|num_vfs
expr_stmt|;
name|memcpy
argument_list|(
name|nvfs
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|nvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|persist
operator|->
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|persist
operator|->
name|interface_state
operator|&
name|MLX4_INTERFACE_STATE_UP
operator|)
condition|)
block|{
name|err
operator|=
name|mlx4_load_one
argument_list|(
name|pdev
argument_list|,
name|priv
operator|->
name|pci_dev_data
argument_list|,
name|total_vfs
argument_list|,
name|nvfs
argument_list|,
name|priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"%s: mlx4_load_one failed, err=%d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|err
operator|=
name|restore_current_port_types
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|curr_port_type
argument_list|,
name|dev
operator|->
name|persist
operator|->
name|curr_port_poss_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"could not restore original port types (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|mutex_unlock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_shutdown
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev_persistent
modifier|*
name|persist
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|mlx4_info
argument_list|(
name|persist
operator|->
name|dev
argument_list|,
literal|"mlx4_shutdown was called\n"
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|persist
operator|->
name|interface_state
operator|&
name|MLX4_INTERFACE_STATE_UP
condition|)
name|mlx4_unload_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|persist
operator|->
name|interface_state_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pci_error_handlers
name|mlx4_err_handler
init|=
block|{
operator|.
name|error_detected
operator|=
name|mlx4_pci_err_detected
block|,
operator|.
name|slot_reset
operator|=
name|mlx4_pci_slot_reset
block|,
operator|.
name|resume
operator|=
name|mlx4_pci_resume
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|mlx4_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRV_NAME
block|,
operator|.
name|id_table
operator|=
name|mlx4_pci_table
block|,
operator|.
name|probe
operator|=
name|mlx4_init_one
block|,
operator|.
name|shutdown
operator|=
name|mlx4_shutdown
block|,
operator|.
name|remove
operator|=
name|mlx4_remove_one
block|,
operator|.
name|err_handler
operator|=
operator|&
name|mlx4_err_handler
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|mlx4_verify_params
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|log_num_mac
operator|<
literal|0
operator|)
operator|||
operator|(
name|log_num_mac
operator|>
literal|7
operator|)
condition|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: bad num_mac: %d\n"
argument_list|,
name|log_num_mac
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|log_num_vlan
operator|!=
literal|0
condition|)
name|pr_warn
argument_list|(
literal|"mlx4_core: log_num_vlan - obsolete module param, using %d\n"
argument_list|,
name|MLX4_LOG_NUM_VLANS
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_prio
operator|!=
literal|0
condition|)
name|pr_warn
argument_list|(
literal|"mlx4_core: use_prio - obsolete module param, ignored\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|log_mtts_per_seg
operator|<
literal|1
operator|)
operator|||
operator|(
name|log_mtts_per_seg
operator|>
literal|7
operator|)
condition|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: bad log_mtts_per_seg: %d\n"
argument_list|,
name|log_mtts_per_seg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if module param for ports type has legal combination */
if|if
condition|(
name|port_type_array
index|[
literal|0
index|]
operator|==
name|false
operator|&&
name|port_type_array
index|[
literal|1
index|]
operator|==
name|true
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Module parameter configuration ETH/IB is not supported. Switching to default configuration IB/IB\n"
argument_list|)
expr_stmt|;
name|port_type_array
index|[
literal|0
index|]
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|<
operator|-
literal|7
operator|||
operator|(
name|mlx4_log_num_mgm_entry_size
operator|>
literal|0
operator|&&
operator|(
name|mlx4_log_num_mgm_entry_size
operator|<
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
operator|||
name|mlx4_log_num_mgm_entry_size
operator|>
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
operator|)
operator|)
condition|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_log_num_mgm_entry_size (%d) not in legal range (-7..0 or %d..%d)\n"
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|,
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
argument_list|,
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__init
name|mlx4_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|mlx4_verify_params
argument_list|()
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mlx4_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"mlx4"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ret
operator|=
name|pci_register_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|destroy_workqueue
argument_list|(
name|mlx4_wq
argument_list|)
expr_stmt|;
return|return
name|ret
operator|<
literal|0
condition|?
name|ret
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|mlx4_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|pci_unregister_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|mlx4_wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|mlx4_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|mlx4_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_evhand
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mlx4_mod
init|=
block|{
operator|.
name|name
operator|=
literal|"mlx4"
block|,
operator|.
name|evhand
operator|=
name|mlx4_evhand
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|mlx4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|mlx4
argument_list|,
name|mlx4_mod
argument_list|,
name|SI_SUB_OFED_PREINIT
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mlx4
argument_list|,
name|linuxkpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

