begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (C) 2013 Emulex  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Emulex Corporation nor the names of its  *    contributors may be used to endorse or promote products derived from  *    this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Contact Information:  * freebsd-drivers@emulex.com  *  * Emulex  * 3333 Susan Street  * Costa Mesa, CA 92626  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"oce_if.h"
end_include

begin_comment
comment|/*****************************************************  * local queue functions  *****************************************************/
end_comment

begin_function_decl
specifier|static
name|struct
name|oce_wq
modifier|*
name|oce_wq_init
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|wq_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oce_wq_create
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oce_wq_free
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oce_wq_del
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|oce_rq
modifier|*
name|oce_rq_init
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|frag_size
parameter_list|,
name|uint32_t
name|mtu
parameter_list|,
name|uint32_t
name|rss
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oce_rq_create
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|,
name|uint32_t
name|if_id
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oce_rq_free
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oce_rq_del
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|oce_eq
modifier|*
name|oce_eq_create
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|item_size
parameter_list|,
name|uint32_t
name|eq_delay
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oce_eq_del
parameter_list|(
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|oce_mq
modifier|*
name|oce_mq_create
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|,
name|uint32_t
name|q_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oce_mq_free
parameter_list|(
name|struct
name|oce_mq
modifier|*
name|mq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oce_destroy_q
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_mbx
modifier|*
name|mbx
parameter_list|,
name|size_t
name|req_size
parameter_list|,
name|enum
name|qtype
name|qtype
parameter_list|,
name|int
name|version
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|oce_cq
modifier|*
name|oce_cq_create
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|item_size
parameter_list|,
name|uint32_t
name|sol_event
parameter_list|,
name|uint32_t
name|is_eventable
parameter_list|,
name|uint32_t
name|nodelay
parameter_list|,
name|uint32_t
name|ncoalesce
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oce_cq_del
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_cq
modifier|*
name|cq
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * @brief	Create and initialize all the queues on the board  * @param sc	software handle to the device  * @returns 0	if successful, or error  **/
end_comment

begin_function
name|int
name|oce_queue_init_all
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|vector
decl_stmt|;
name|struct
name|oce_wq
modifier|*
name|wq
decl_stmt|;
name|struct
name|oce_rq
modifier|*
name|rq
decl_stmt|;
name|struct
name|oce_aic_obj
modifier|*
name|aic
decl_stmt|;
comment|/* alloc TX/RX queues */
name|for_all_wq_queues
argument_list|(
argument|sc
argument_list|,
argument|wq
argument_list|,
argument|i
argument_list|)
block|{
name|sc
operator|->
name|wq
index|[
name|i
index|]
operator|=
name|oce_wq_init
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx_ring_size
argument_list|,
name|NIC_WQ_TYPE_STANDARD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|wq
index|[
name|i
index|]
condition|)
goto|goto
name|error
goto|;
block|}
name|for_all_rq_queues
argument_list|(
argument|sc
argument_list|,
argument|rq
argument_list|,
argument|i
argument_list|)
block|{
name|sc
operator|->
name|rq
index|[
name|i
index|]
operator|=
name|oce_rq_init
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_ring_size
argument_list|,
name|sc
operator|->
name|rq_frag_size
argument_list|,
name|OCE_MAX_JUMBO_FRAME_SIZE
argument_list|,
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|is_rss_enabled
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|rq
index|[
name|i
index|]
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Create network interface on card */
if|if
condition|(
name|oce_create_nw_interface
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* create all of the event queues */
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|vector
operator|++
control|)
block|{
comment|/* setup aic defaults for each event queue */
name|aic
operator|=
operator|&
name|sc
operator|->
name|aic_obj
index|[
name|vector
index|]
expr_stmt|;
name|aic
operator|->
name|max_eqd
operator|=
name|OCE_MAX_EQD
expr_stmt|;
name|aic
operator|->
name|min_eqd
operator|=
name|OCE_MIN_EQD
expr_stmt|;
name|aic
operator|->
name|et_eqd
operator|=
name|OCE_MIN_EQD
expr_stmt|;
name|aic
operator|->
name|enable
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|eq
index|[
name|vector
index|]
operator|=
name|oce_eq_create
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|enable_hwlro
condition|?
name|EQ_LEN_2048
else|:
name|EQ_LEN_1024
argument_list|,
name|EQE_SIZE_4
argument_list|,
literal|0
argument_list|,
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|eq
index|[
name|vector
index|]
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* create Tx, Rx and mcc queues */
name|for_all_wq_queues
argument_list|(
argument|sc
argument_list|,
argument|wq
argument_list|,
argument|i
argument_list|)
block|{
name|rc
operator|=
name|oce_wq_create
argument_list|(
name|wq
argument_list|,
name|sc
operator|->
name|eq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
name|wq
operator|->
name|queue_index
operator|=
name|i
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|wq
operator|->
name|txtask
argument_list|,
literal|1
argument_list|,
name|oce_tx_task
argument_list|,
name|wq
argument_list|)
expr_stmt|;
block|}
name|for_all_rq_queues
argument_list|(
argument|sc
argument_list|,
argument|rq
argument_list|,
argument|i
argument_list|)
block|{
name|rc
operator|=
name|oce_rq_create
argument_list|(
name|rq
argument_list|,
name|sc
operator|->
name|if_id
argument_list|,
name|sc
operator|->
name|eq
index|[
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|i
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
name|rq
operator|->
name|queue_index
operator|=
name|i
expr_stmt|;
block|}
name|sc
operator|->
name|mq
operator|=
name|oce_mq_create
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|eq
index|[
literal|0
index|]
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mq
condition|)
goto|goto
name|error
goto|;
return|return
name|rc
return|;
name|error
label|:
name|oce_queue_release_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Releases all mailbox queues created  * @param sc		software handle to the device  */
end_comment

begin_function
name|void
name|oce_queue_release_all
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|oce_wq
modifier|*
name|wq
decl_stmt|;
name|struct
name|oce_rq
modifier|*
name|rq
decl_stmt|;
name|struct
name|oce_eq
modifier|*
name|eq
decl_stmt|;
comment|/* before deleting lro queues, we have to disable hwlro	*/
if|if
condition|(
name|sc
operator|->
name|enable_hwlro
condition|)
name|oce_mbox_nic_set_iface_lro_config
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|for_all_rq_queues
argument_list|(
argument|sc
argument_list|,
argument|rq
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|rq
condition|)
block|{
name|oce_rq_del
argument_list|(
name|sc
operator|->
name|rq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|oce_rq_free
argument_list|(
name|sc
operator|->
name|rq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|for_all_wq_queues
argument_list|(
argument|sc
argument_list|,
argument|wq
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|wq
condition|)
block|{
name|oce_wq_del
argument_list|(
name|sc
operator|->
name|wq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|oce_wq_free
argument_list|(
name|sc
operator|->
name|wq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|mq
condition|)
name|oce_mq_free
argument_list|(
name|sc
operator|->
name|mq
argument_list|)
expr_stmt|;
name|for_all_evnt_queues
argument_list|(
argument|sc
argument_list|,
argument|eq
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|eq
condition|)
name|oce_eq_del
argument_list|(
name|sc
operator|->
name|eq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief 		Function to create a WQ for NIC Tx  * @param sc 		software handle to the device  * @param qlen		number of entries in the queue  * @param wq_type	work queue type  * @returns		the pointer to the WQ created or NULL on failure  */
end_comment

begin_function
specifier|static
name|struct
name|oce_wq
modifier|*
name|oce_wq_init
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|wq_type
parameter_list|)
block|{
name|struct
name|oce_wq
modifier|*
name|wq
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
comment|/* q_len must be min 256 and max 2k */
if|if
condition|(
name|q_len
operator|<
literal|256
operator|||
name|q_len
operator|>
literal|2048
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Invalid q length. Must be "
literal|"[256, 2000]: 0x%x\n"
argument_list|,
name|q_len
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* allocate wq */
name|wq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|oce_wq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wq
condition|)
return|return
name|NULL
return|;
comment|/* Set the wq config */
name|wq
operator|->
name|cfg
operator|.
name|q_len
operator|=
name|q_len
expr_stmt|;
name|wq
operator|->
name|cfg
operator|.
name|wq_type
operator|=
operator|(
name|uint8_t
operator|)
name|wq_type
expr_stmt|;
name|wq
operator|->
name|cfg
operator|.
name|eqd
operator|=
name|OCE_DEFAULT_WQ_EQD
expr_stmt|;
name|wq
operator|->
name|cfg
operator|.
name|nbufs
operator|=
literal|2
operator|*
name|wq
operator|->
name|cfg
operator|.
name|q_len
expr_stmt|;
name|wq
operator|->
name|cfg
operator|.
name|nhdl
operator|=
literal|2
operator|*
name|wq
operator|->
name|cfg
operator|.
name|q_len
expr_stmt|;
name|wq
operator|->
name|parent
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|OCE_MAX_TX_SIZE
argument_list|,
name|OCE_MAX_TX_ELEMENTS
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|free_wq
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OCE_WQ_PACKET_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|bus_dmamap_create
argument_list|(
name|wq
operator|->
name|tag
argument_list|,
literal|0
argument_list|,
operator|&
name|wq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|free_wq
goto|;
block|}
name|wq
operator|->
name|ring
operator|=
name|oce_create_ring_buffer
argument_list|(
name|sc
argument_list|,
name|q_len
argument_list|,
name|NIC_WQE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wq
operator|->
name|ring
condition|)
goto|goto
name|free_wq
goto|;
name|LOCK_CREATE
argument_list|(
operator|&
name|wq
operator|->
name|tx_lock
argument_list|,
literal|"TX_lock"
argument_list|)
expr_stmt|;
name|LOCK_CREATE
argument_list|(
operator|&
name|wq
operator|->
name|tx_compl_lock
argument_list|,
literal|"WQ_HANDLER_LOCK"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* Allocate buf ring for multiqueue*/
name|wq
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
literal|4096
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|wq
operator|->
name|tx_lock
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wq
operator|->
name|br
condition|)
goto|goto
name|free_wq
goto|;
endif|#
directive|endif
return|return
name|wq
return|;
name|free_wq
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Create WQ failed\n"
argument_list|)
expr_stmt|;
name|oce_wq_free
argument_list|(
name|wq
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief 		Frees the work queue  * @param wq		pointer to work queue to free  */
end_comment

begin_function
specifier|static
name|void
name|oce_wq_free
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
operator|(
name|POCE_SOFTC
operator|)
name|wq
operator|->
name|parent
decl_stmt|;
name|int
name|i
decl_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|wq
operator|->
name|txtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|ring
operator|!=
name|NULL
condition|)
block|{
name|oce_destroy_ring_buffer
argument_list|(
name|sc
argument_list|,
name|wq
operator|->
name|ring
argument_list|)
expr_stmt|;
name|wq
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OCE_WQ_PACKET_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|wq
operator|->
name|tag
argument_list|,
name|wq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|wq
operator|->
name|tag
argument_list|,
name|wq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|wq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wq
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|wq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|wq
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|LOCK_DESTROY
argument_list|(
operator|&
name|wq
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|LOCK_DESTROY
argument_list|(
operator|&
name|wq
operator|->
name|tx_compl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief 		Create a work queue  * @param wq		pointer to work queue  * @param eq		pointer to associated event queue  */
end_comment

begin_function
specifier|static
name|int
name|oce_wq_create
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
name|wq
operator|->
name|parent
decl_stmt|;
name|struct
name|oce_cq
modifier|*
name|cq
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* create the CQ */
name|cq
operator|=
name|oce_cq_create
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|,
name|CQ_LEN_1024
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_nic_tx_cqe
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq
condition|)
return|return
name|ENXIO
return|;
name|wq
operator|->
name|cq
operator|=
name|cq
expr_stmt|;
name|rc
operator|=
name|oce_mbox_create_wq
argument_list|(
name|wq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
name|wq
operator|->
name|qstate
operator|=
name|QCREATED
expr_stmt|;
name|wq
operator|->
name|wq_free
operator|=
name|wq
operator|->
name|cfg
operator|.
name|q_len
expr_stmt|;
name|wq
operator|->
name|ring
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|wq
operator|->
name|ring
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|eq
operator|->
name|cq
index|[
name|eq
operator|->
name|cq_valid
index|]
operator|=
name|cq
expr_stmt|;
name|eq
operator|->
name|cq_valid
operator|++
expr_stmt|;
name|cq
operator|->
name|cb_arg
operator|=
name|wq
expr_stmt|;
name|cq
operator|->
name|cq_handler
operator|=
name|oce_wq_handler
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WQ create failed\n"
argument_list|)
expr_stmt|;
name|oce_wq_del
argument_list|(
name|wq
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * @brief 		Delete a work queue  * @param wq		pointer to work queue  */
end_comment

begin_function
specifier|static
name|void
name|oce_wq_del
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|)
block|{
name|struct
name|oce_mbx
name|mbx
decl_stmt|;
name|struct
name|mbx_delete_nic_wq
modifier|*
name|fwcmd
decl_stmt|;
name|POCE_SOFTC
name|sc
init|=
operator|(
name|POCE_SOFTC
operator|)
name|wq
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|wq
operator|->
name|qstate
operator|==
name|QCREATED
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_mbx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now fill the command */
name|fwcmd
operator|=
operator|(
expr|struct
name|mbx_delete_nic_wq
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|wq_id
operator|=
name|wq
operator|->
name|wq_id
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_delete_nic_wq
argument_list|)
argument_list|,
name|QTYPE_WQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wq
operator|->
name|qstate
operator|=
name|QDELETED
expr_stmt|;
block|}
if|if
condition|(
name|wq
operator|->
name|cq
operator|!=
name|NULL
condition|)
block|{
name|oce_cq_del
argument_list|(
name|sc
argument_list|,
name|wq
operator|->
name|cq
argument_list|)
expr_stmt|;
name|wq
operator|->
name|cq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief 		function to allocate receive queue resources  * @param sc		software handle to the device  * @param q_len		length of receive queue  * @param frag_size	size of an receive queue fragment  * @param mtu		maximum transmission unit  * @param rss		is-rss-queue flag  * @returns		the pointer to the RQ created or NULL on failure  */
end_comment

begin_function
specifier|static
name|struct
name|oce_rq
modifier|*
name|oce_rq_init
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|frag_size
parameter_list|,
name|uint32_t
name|mtu
parameter_list|,
name|uint32_t
name|rss
parameter_list|)
block|{
name|struct
name|oce_rq
modifier|*
name|rq
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|OCE_LOG2
argument_list|(
name|frag_size
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|q_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|q_len
operator|>
literal|1024
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* allocate the rq */
name|rq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|oce_rq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rq
condition|)
return|return
name|NULL
return|;
name|rq
operator|->
name|cfg
operator|.
name|q_len
operator|=
name|q_len
expr_stmt|;
name|rq
operator|->
name|cfg
operator|.
name|frag_size
operator|=
name|frag_size
expr_stmt|;
name|rq
operator|->
name|cfg
operator|.
name|mtu
operator|=
name|mtu
expr_stmt|;
name|rq
operator|->
name|cfg
operator|.
name|eqd
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|lro_pkts_queued
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|cfg
operator|.
name|is_rss_queue
operator|=
name|rss
expr_stmt|;
name|rq
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|parent
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|oce_rq_buf_size
argument_list|,
literal|1
argument_list|,
name|oce_rq_buf_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rq
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|free_rq
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OCE_RQ_PACKET_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|bus_dmamap_create
argument_list|(
name|rq
operator|->
name|tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|free_rq
goto|;
block|}
comment|/* create the ring buffer */
name|rq
operator|->
name|ring
operator|=
name|oce_create_ring_buffer
argument_list|(
name|sc
argument_list|,
name|q_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_nic_rqe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rq
operator|->
name|ring
condition|)
goto|goto
name|free_rq
goto|;
name|LOCK_CREATE
argument_list|(
operator|&
name|rq
operator|->
name|rx_lock
argument_list|,
literal|"RX_lock"
argument_list|)
expr_stmt|;
return|return
name|rq
return|;
name|free_rq
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Create RQ failed\n"
argument_list|)
expr_stmt|;
name|oce_rq_free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief 		Free a receive queue  * @param rq		pointer to receive queue  */
end_comment

begin_function
specifier|static
name|void
name|oce_rq_free
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
operator|(
name|POCE_SOFTC
operator|)
name|rq
operator|->
name|parent
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rq
operator|->
name|ring
operator|!=
name|NULL
condition|)
block|{
name|oce_destroy_ring_buffer
argument_list|(
name|sc
argument_list|,
name|rq
operator|->
name|ring
argument_list|)
expr_stmt|;
name|rq
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OCE_RQ_PACKET_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|rq
operator|->
name|tag
argument_list|,
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|rq
operator|->
name|tag
argument_list|,
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|mbuf
condition|)
block|{
name|m_free
argument_list|(
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
name|rq
operator|->
name|pckts
index|[
name|i
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rq
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|rq
operator|->
name|tag
argument_list|)
expr_stmt|;
name|LOCK_DESTROY
argument_list|(
operator|&
name|rq
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief 		Create a receive queue  * @param rq 		receive queue  * @param if_id		interface identifier index`  * @param eq		pointer to event queue  */
end_comment

begin_function
specifier|static
name|int
name|oce_rq_create
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|,
name|uint32_t
name|if_id
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
name|rq
operator|->
name|parent
decl_stmt|;
name|struct
name|oce_cq
modifier|*
name|cq
decl_stmt|;
name|cq
operator|=
name|oce_cq_create
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|,
name|sc
operator|->
name|enable_hwlro
condition|?
name|CQ_LEN_2048
else|:
name|CQ_LEN_1024
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_nic_rx_cqe
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq
condition|)
return|return
name|ENXIO
return|;
name|rq
operator|->
name|cq
operator|=
name|cq
expr_stmt|;
name|rq
operator|->
name|cfg
operator|.
name|if_id
operator|=
name|if_id
expr_stmt|;
comment|/* Dont create RQ here. Create in if_activate */
name|rq
operator|->
name|qstate
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|ring
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|ring
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|eq
operator|->
name|cq
index|[
name|eq
operator|->
name|cq_valid
index|]
operator|=
name|cq
expr_stmt|;
name|eq
operator|->
name|cq_valid
operator|++
expr_stmt|;
name|cq
operator|->
name|cb_arg
operator|=
name|rq
expr_stmt|;
name|cq
operator|->
name|cq_handler
operator|=
name|oce_rq_handler
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @brief 		Delete a receive queue  * @param rq		receive queue  */
end_comment

begin_function
specifier|static
name|void
name|oce_rq_del
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
operator|(
name|POCE_SOFTC
operator|)
name|rq
operator|->
name|parent
decl_stmt|;
name|struct
name|oce_mbx
name|mbx
decl_stmt|;
name|struct
name|mbx_delete_nic_rq
modifier|*
name|fwcmd
decl_stmt|;
name|struct
name|mbx_delete_nic_rq_v1
modifier|*
name|fwcmd1
decl_stmt|;
if|if
condition|(
name|rq
operator|->
name|qstate
operator|==
name|QCREATED
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
name|mbx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rq
operator|->
name|islro
condition|)
block|{
name|fwcmd
operator|=
operator|(
expr|struct
name|mbx_delete_nic_rq
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|rq_id
operator|=
name|rq
operator|->
name|rq_id
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_delete_nic_rq
argument_list|)
argument_list|,
name|QTYPE_RQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fwcmd1
operator|=
operator|(
expr|struct
name|mbx_delete_nic_rq_v1
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd1
operator|->
name|params
operator|.
name|req
operator|.
name|rq_id
operator|=
name|rq
operator|->
name|rq_id
expr_stmt|;
name|fwcmd1
operator|->
name|params
operator|.
name|req
operator|.
name|rq_flags
operator|=
operator|(
name|NIC_RQ_FLAGS_RSS
operator||
name|NIC_RQ_FLAGS_LRO
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_delete_nic_rq_v1
argument_list|)
argument_list|,
name|QTYPE_RQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rq
operator|->
name|qstate
operator|=
name|QDELETED
expr_stmt|;
block|}
if|if
condition|(
name|rq
operator|->
name|cq
operator|!=
name|NULL
condition|)
block|{
name|oce_cq_del
argument_list|(
name|sc
argument_list|,
name|rq
operator|->
name|cq
argument_list|)
expr_stmt|;
name|rq
operator|->
name|cq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief		function to create an event queue  * @param sc		software handle to the device  * @param q_len		length of event queue  * @param item_size	size of an event queue item  * @param eq_delay	event queue delay  * @retval eq      	success, pointer to event queue  * @retval NULL		failure  */
end_comment

begin_function
specifier|static
name|struct
name|oce_eq
modifier|*
name|oce_eq_create
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|item_size
parameter_list|,
name|uint32_t
name|eq_delay
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
block|{
name|struct
name|oce_eq
modifier|*
name|eq
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* allocate an eq */
name|eq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|oce_eq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|eq
operator|->
name|parent
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|eq
operator|->
name|eq_id
operator|=
literal|0xffff
expr_stmt|;
name|eq
operator|->
name|ring
operator|=
name|oce_create_ring_buffer
argument_list|(
name|sc
argument_list|,
name|q_len
argument_list|,
name|item_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eq
operator|->
name|ring
condition|)
goto|goto
name|free_eq
goto|;
name|eq
operator|->
name|eq_cfg
operator|.
name|q_len
operator|=
name|q_len
expr_stmt|;
name|eq
operator|->
name|eq_cfg
operator|.
name|item_size
operator|=
name|item_size
expr_stmt|;
name|eq
operator|->
name|eq_cfg
operator|.
name|cur_eqd
operator|=
operator|(
name|uint8_t
operator|)
name|eq_delay
expr_stmt|;
name|rc
operator|=
name|oce_mbox_create_eq
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|free_eq
goto|;
name|sc
operator|->
name|intrs
index|[
name|sc
operator|->
name|neqs
operator|++
index|]
operator|.
name|eq
operator|=
name|eq
expr_stmt|;
return|return
name|eq
return|;
name|free_eq
label|:
name|oce_eq_del
argument_list|(
name|eq
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief 		Function to delete an event queue  * @param eq		pointer to an event queue  */
end_comment

begin_function
specifier|static
name|void
name|oce_eq_del
parameter_list|(
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|oce_mbx
name|mbx
decl_stmt|;
name|struct
name|mbx_destroy_common_eq
modifier|*
name|fwcmd
decl_stmt|;
name|POCE_SOFTC
name|sc
init|=
operator|(
name|POCE_SOFTC
operator|)
name|eq
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|eq
operator|->
name|eq_id
operator|!=
literal|0xffff
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
name|mbx
argument_list|)
argument_list|)
expr_stmt|;
name|fwcmd
operator|=
operator|(
expr|struct
name|mbx_destroy_common_eq
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|id
operator|=
name|eq
operator|->
name|eq_id
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_destroy_common_eq
argument_list|)
argument_list|,
name|QTYPE_EQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eq
operator|->
name|ring
operator|!=
name|NULL
condition|)
block|{
name|oce_destroy_ring_buffer
argument_list|(
name|sc
argument_list|,
name|eq
operator|->
name|ring
argument_list|)
expr_stmt|;
name|eq
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|eq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief		Function to create an MQ  * @param sc		software handle to the device  * @param eq		the EQ to associate with the MQ for event notification  * @param q_len		the number of entries to create in the MQ  * @returns		pointer to the created MQ, failure otherwise  */
end_comment

begin_function
specifier|static
name|struct
name|oce_mq
modifier|*
name|oce_mq_create
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|,
name|uint32_t
name|q_len
parameter_list|)
block|{
name|struct
name|oce_mbx
name|mbx
decl_stmt|;
name|struct
name|mbx_create_common_mq_ex
modifier|*
name|fwcmd
init|=
name|NULL
decl_stmt|;
name|struct
name|oce_mq
modifier|*
name|mq
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|oce_cq
modifier|*
name|cq
decl_stmt|;
name|oce_mq_ext_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|uint32_t
name|num_pages
decl_stmt|;
name|uint32_t
name|page_size
decl_stmt|;
name|int
name|version
decl_stmt|;
name|cq
operator|=
name|oce_cq_create
argument_list|(
name|sc
argument_list|,
name|eq
argument_list|,
name|CQ_LEN_256
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_mq_cqe
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq
condition|)
return|return
name|NULL
return|;
comment|/* allocate the mq */
name|mq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|oce_mq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mq
condition|)
block|{
name|oce_cq_del
argument_list|(
name|sc
argument_list|,
name|cq
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mq
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|mq
operator|->
name|ring
operator|=
name|oce_create_ring_buffer
argument_list|(
name|sc
argument_list|,
name|q_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_mbx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mq
operator|->
name|ring
condition|)
goto|goto
name|error
goto|;
name|bzero
argument_list|(
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_mbx
argument_list|)
argument_list|)
expr_stmt|;
name|IS_XE201
argument_list|(
name|sc
argument_list|)
condition|?
operator|(
name|version
operator|=
name|OCE_MBX_VER_V1
operator|)
else|:
operator|(
name|version
operator|=
name|OCE_MBX_VER_V0
operator|)
expr_stmt|;
name|fwcmd
operator|=
operator|(
expr|struct
name|mbx_create_common_mq_ex
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|mbx_common_req_hdr_init
argument_list|(
operator|&
name|fwcmd
operator|->
name|hdr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MBX_SUBSYSTEM_COMMON
argument_list|,
name|OPCODE_COMMON_CREATE_MQ_EXT
argument_list|,
name|MBX_TIMEOUT_SEC
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_create_common_mq_ex
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|num_pages
operator|=
name|oce_page_list
argument_list|(
name|mq
operator|->
name|ring
argument_list|,
operator|&
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|pages
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|page_size
operator|=
name|mq
operator|->
name|ring
operator|->
name|num_items
operator|*
name|mq
operator|->
name|ring
operator|->
name|item_size
expr_stmt|;
name|ctx
operator|=
operator|&
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|context
expr_stmt|;
if|if
condition|(
name|IS_XE201
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|v1
operator|.
name|num_pages
operator|=
name|num_pages
expr_stmt|;
name|ctx
operator|->
name|v1
operator|.
name|ring_size
operator|=
name|OCE_LOG2
argument_list|(
name|q_len
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctx
operator|->
name|v1
operator|.
name|cq_id
operator|=
name|cq
operator|->
name|cq_id
expr_stmt|;
name|ctx
operator|->
name|v1
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|v1
operator|.
name|async_cq_id
operator|=
name|cq
operator|->
name|cq_id
expr_stmt|;
name|ctx
operator|->
name|v1
operator|.
name|async_cq_valid
operator|=
literal|1
expr_stmt|;
comment|/* Subscribe to Link State and Group 5 Events(bits 1& 5 set) */
name|ctx
operator|->
name|v1
operator|.
name|async_evt_bitmap
operator||=
name|LE_32
argument_list|(
literal|0x00000022
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|v1
operator|.
name|async_evt_bitmap
operator||=
name|LE_32
argument_list|(
literal|1
operator|<<
name|ASYNC_EVENT_CODE_DEBUG
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|v1
operator|.
name|async_evt_bitmap
operator||=
name|LE_32
argument_list|(
literal|1
operator|<<
name|ASYNC_EVENT_CODE_SLIPORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|v0
operator|.
name|num_pages
operator|=
name|num_pages
expr_stmt|;
name|ctx
operator|->
name|v0
operator|.
name|cq_id
operator|=
name|cq
operator|->
name|cq_id
expr_stmt|;
name|ctx
operator|->
name|v0
operator|.
name|ring_size
operator|=
name|OCE_LOG2
argument_list|(
name|q_len
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctx
operator|->
name|v0
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Subscribe to Link State and Group5 Events(bits 1& 5 set) */
name|ctx
operator|->
name|v0
operator|.
name|async_evt_bitmap
operator|=
literal|0xffffffff
expr_stmt|;
block|}
name|mbx
operator|.
name|u0
operator|.
name|s
operator|.
name|embedded
operator|=
literal|1
expr_stmt|;
name|mbx
operator|.
name|payload_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_create_common_mq_ex
argument_list|)
expr_stmt|;
name|DW_SWAP
argument_list|(
name|u32ptr
argument_list|(
operator|&
name|mbx
argument_list|)
argument_list|,
name|mbx
operator|.
name|payload_length
operator|+
name|OCE_BMBX_RHDR_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
name|oce_mbox_post
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|rc
operator|=
name|fwcmd
operator|->
name|hdr
operator|.
name|u0
operator|.
name|rsp
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s failed - cmd status: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mq
operator|->
name|mq_id
operator|=
name|LE_16
argument_list|(
name|fwcmd
operator|->
name|params
operator|.
name|rsp
operator|.
name|mq_id
argument_list|)
expr_stmt|;
name|mq
operator|->
name|cq
operator|=
name|cq
expr_stmt|;
name|eq
operator|->
name|cq
index|[
name|eq
operator|->
name|cq_valid
index|]
operator|=
name|cq
expr_stmt|;
name|eq
operator|->
name|cq_valid
operator|++
expr_stmt|;
name|mq
operator|->
name|cq
operator|->
name|eq
operator|=
name|eq
expr_stmt|;
name|mq
operator|->
name|cfg
operator|.
name|q_len
operator|=
operator|(
name|uint8_t
operator|)
name|q_len
expr_stmt|;
name|mq
operator|->
name|cfg
operator|.
name|eqd
operator|=
literal|0
expr_stmt|;
name|mq
operator|->
name|qstate
operator|=
name|QCREATED
expr_stmt|;
name|mq
operator|->
name|cq
operator|->
name|cb_arg
operator|=
name|mq
expr_stmt|;
name|mq
operator|->
name|cq
operator|->
name|cq_handler
operator|=
name|oce_mq_handler
expr_stmt|;
return|return
name|mq
return|;
name|error
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"MQ create failed\n"
argument_list|)
expr_stmt|;
name|oce_mq_free
argument_list|(
name|mq
argument_list|)
expr_stmt|;
name|mq
operator|=
name|NULL
expr_stmt|;
return|return
name|mq
return|;
block|}
end_function

begin_comment
comment|/**  * @brief		Function to free a mailbox queue  * @param mq		pointer to a mailbox queue  */
end_comment

begin_function
specifier|static
name|void
name|oce_mq_free
parameter_list|(
name|struct
name|oce_mq
modifier|*
name|mq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
operator|(
name|POCE_SOFTC
operator|)
name|mq
operator|->
name|parent
decl_stmt|;
name|struct
name|oce_mbx
name|mbx
decl_stmt|;
name|struct
name|mbx_destroy_common_mq
modifier|*
name|fwcmd
decl_stmt|;
if|if
condition|(
operator|!
name|mq
condition|)
return|return;
if|if
condition|(
name|mq
operator|->
name|ring
operator|!=
name|NULL
condition|)
block|{
name|oce_destroy_ring_buffer
argument_list|(
name|sc
argument_list|,
name|mq
operator|->
name|ring
argument_list|)
expr_stmt|;
name|mq
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mq
operator|->
name|qstate
operator|==
name|QCREATED
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_mbx
argument_list|)
argument_list|)
expr_stmt|;
name|fwcmd
operator|=
operator|(
expr|struct
name|mbx_destroy_common_mq
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|id
operator|=
name|mq
operator|->
name|mq_id
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_destroy_common_mq
argument_list|)
argument_list|,
name|QTYPE_MQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mq
operator|->
name|qstate
operator|=
name|QDELETED
expr_stmt|;
block|}
if|if
condition|(
name|mq
operator|->
name|cq
operator|!=
name|NULL
condition|)
block|{
name|oce_cq_del
argument_list|(
name|sc
argument_list|,
name|mq
operator|->
name|cq
argument_list|)
expr_stmt|;
name|mq
operator|->
name|cq
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|mq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief		Function to delete a EQ, CQ, MQ, WQ or RQ  * @param sc		sofware handle to the device  * @param mbx		mailbox command to send to the fw to delete the queue  *			(mbx contains the queue information to delete)  * @param req_size	the size of the mbx payload dependent on the qtype  * @param qtype		the type of queue i.e. EQ, CQ, MQ, WQ or RQ  * @returns 		0 on success, failure otherwise  */
end_comment

begin_function
specifier|static
name|int
name|oce_destroy_q
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_mbx
modifier|*
name|mbx
parameter_list|,
name|size_t
name|req_size
parameter_list|,
name|enum
name|qtype
name|qtype
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|struct
name|mbx_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|mbx_hdr
operator|*
operator|)
operator|&
name|mbx
operator|->
name|payload
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|subsys
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|qtype
condition|)
block|{
case|case
name|QTYPE_EQ
case|:
name|opcode
operator|=
name|OPCODE_COMMON_DESTROY_EQ
expr_stmt|;
name|subsys
operator|=
name|MBX_SUBSYSTEM_COMMON
expr_stmt|;
break|break;
case|case
name|QTYPE_CQ
case|:
name|opcode
operator|=
name|OPCODE_COMMON_DESTROY_CQ
expr_stmt|;
name|subsys
operator|=
name|MBX_SUBSYSTEM_COMMON
expr_stmt|;
break|break;
case|case
name|QTYPE_MQ
case|:
name|opcode
operator|=
name|OPCODE_COMMON_DESTROY_MQ
expr_stmt|;
name|subsys
operator|=
name|MBX_SUBSYSTEM_COMMON
expr_stmt|;
break|break;
case|case
name|QTYPE_WQ
case|:
name|opcode
operator|=
name|NIC_DELETE_WQ
expr_stmt|;
name|subsys
operator|=
name|MBX_SUBSYSTEM_NIC
expr_stmt|;
break|break;
case|case
name|QTYPE_RQ
case|:
name|opcode
operator|=
name|NIC_DELETE_RQ
expr_stmt|;
name|subsys
operator|=
name|MBX_SUBSYSTEM_NIC
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|mbx_common_req_hdr_init
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|subsys
argument_list|,
name|opcode
argument_list|,
name|MBX_TIMEOUT_SEC
argument_list|,
name|req_size
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|mbx
operator|->
name|u0
operator|.
name|s
operator|.
name|embedded
operator|=
literal|1
expr_stmt|;
name|mbx
operator|->
name|payload_length
operator|=
operator|(
name|uint32_t
operator|)
name|req_size
expr_stmt|;
name|DW_SWAP
argument_list|(
name|u32ptr
argument_list|(
name|mbx
argument_list|)
argument_list|,
name|mbx
operator|->
name|payload_length
operator|+
name|OCE_BMBX_RHDR_SZ
argument_list|)
expr_stmt|;
name|rc
operator|=
name|oce_mbox_post
argument_list|(
name|sc
argument_list|,
name|mbx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|rc
operator|=
name|hdr
operator|->
name|u0
operator|.
name|rsp
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s failed - cmd status: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * @brief		Function to create a completion queue  * @param sc		software handle to the device  * @param eq		optional eq to be associated with to the cq  * @param q_len		length of completion queue  * @param item_size	size of completion queue items  * @param sol_event	command context event  * @param is_eventable	event table  * @param nodelay	no delay flag  * @param ncoalesce	no coalescence flag  * @returns 		pointer to the cq created, NULL on failure  */
end_comment

begin_function
name|struct
name|oce_cq
modifier|*
name|oce_cq_create
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|,
name|uint32_t
name|q_len
parameter_list|,
name|uint32_t
name|item_size
parameter_list|,
name|uint32_t
name|sol_event
parameter_list|,
name|uint32_t
name|is_eventable
parameter_list|,
name|uint32_t
name|nodelay
parameter_list|,
name|uint32_t
name|ncoalesce
parameter_list|)
block|{
name|struct
name|oce_cq
modifier|*
name|cq
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|cq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|oce_cq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq
condition|)
return|return
name|NULL
return|;
name|cq
operator|->
name|ring
operator|=
name|oce_create_ring_buffer
argument_list|(
name|sc
argument_list|,
name|q_len
argument_list|,
name|item_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq
operator|->
name|ring
condition|)
goto|goto
name|error
goto|;
name|cq
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|cq
operator|->
name|eq
operator|=
name|eq
expr_stmt|;
name|cq
operator|->
name|cq_cfg
operator|.
name|q_len
operator|=
name|q_len
expr_stmt|;
name|cq
operator|->
name|cq_cfg
operator|.
name|item_size
operator|=
name|item_size
expr_stmt|;
name|cq
operator|->
name|cq_cfg
operator|.
name|nodelay
operator|=
operator|(
name|uint8_t
operator|)
name|nodelay
expr_stmt|;
name|rc
operator|=
name|oce_mbox_cq_create
argument_list|(
name|cq
argument_list|,
name|ncoalesce
argument_list|,
name|is_eventable
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
name|sc
operator|->
name|cq
index|[
name|sc
operator|->
name|ncqs
operator|++
index|]
operator|=
name|cq
expr_stmt|;
return|return
name|cq
return|;
name|error
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CQ create failed\n"
argument_list|)
expr_stmt|;
name|oce_cq_del
argument_list|(
name|sc
argument_list|,
name|cq
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief		Deletes the completion queue  * @param sc		software handle to the device  * @param cq		pointer to a completion queue  */
end_comment

begin_function
specifier|static
name|void
name|oce_cq_del
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|struct
name|oce_cq
modifier|*
name|cq
parameter_list|)
block|{
name|struct
name|oce_mbx
name|mbx
decl_stmt|;
name|struct
name|mbx_destroy_common_cq
modifier|*
name|fwcmd
decl_stmt|;
if|if
condition|(
name|cq
operator|->
name|ring
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oce_mbx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now fill the command */
name|fwcmd
operator|=
operator|(
expr|struct
name|mbx_destroy_common_cq
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|id
operator|=
name|cq
operator|->
name|cq_id
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_destroy_common_cq
argument_list|)
argument_list|,
name|QTYPE_CQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOW destroy the ring */
name|oce_destroy_ring_buffer
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|ring
argument_list|)
expr_stmt|;
name|cq
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|cq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief		Start a receive queue  * @param rq		pointer to a receive queue  */
end_comment

begin_function
name|int
name|oce_start_rq
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
operator|(
name|POCE_SOFTC
operator|)
name|rq
operator|->
name|parent
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|enable_hwlro
condition|)
name|rc
operator|=
name|oce_alloc_rx_bufs
argument_list|(
name|rq
argument_list|,
literal|960
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|oce_alloc_rx_bufs
argument_list|(
name|rq
argument_list|,
name|rq
operator|->
name|cfg
operator|.
name|q_len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|oce_arm_cq
argument_list|(
name|rq
operator|->
name|parent
argument_list|,
name|rq
operator|->
name|cq
operator|->
name|cq_id
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * @brief		Start a work queue  * @param wq		pointer to a work queue  */
end_comment

begin_function
name|int
name|oce_start_wq
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|)
block|{
name|oce_arm_cq
argument_list|(
name|wq
operator|->
name|parent
argument_list|,
name|wq
operator|->
name|cq
operator|->
name|cq_id
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @brief		Start a mailbox queue  * @param mq		pointer to a mailbox queue  */
end_comment

begin_function
name|int
name|oce_start_mq
parameter_list|(
name|struct
name|oce_mq
modifier|*
name|mq
parameter_list|)
block|{
name|oce_arm_cq
argument_list|(
name|mq
operator|->
name|parent
argument_list|,
name|mq
operator|->
name|cq
operator|->
name|cq_id
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @brief		Function to arm an EQ so that it can generate events  * @param sc		software handle to the device  * @param qid		id of the EQ returned by the fw at the time of creation  * @param npopped	number of EQEs to arm  * @param rearm		rearm bit enable/disable  * @param clearint	bit to clear the interrupt condition because of which  *			EQEs are generated  */
end_comment

begin_function
name|void
name|oce_arm_eq
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|int16_t
name|qid
parameter_list|,
name|int
name|npopped
parameter_list|,
name|uint32_t
name|rearm
parameter_list|,
name|uint32_t
name|clearint
parameter_list|)
block|{
name|eq_db_t
name|eq_db
init|=
block|{
literal|0
block|}
decl_stmt|;
name|eq_db
operator|.
name|bits
operator|.
name|rearm
operator|=
name|rearm
expr_stmt|;
name|eq_db
operator|.
name|bits
operator|.
name|event
operator|=
literal|1
expr_stmt|;
name|eq_db
operator|.
name|bits
operator|.
name|num_popped
operator|=
name|npopped
expr_stmt|;
name|eq_db
operator|.
name|bits
operator|.
name|clrint
operator|=
name|clearint
expr_stmt|;
name|eq_db
operator|.
name|bits
operator|.
name|qid
operator|=
name|qid
expr_stmt|;
name|OCE_WRITE_REG32
argument_list|(
name|sc
argument_list|,
name|db
argument_list|,
name|PD_EQ_DB
argument_list|,
name|eq_db
operator|.
name|dw0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief		Function to arm a CQ with CQEs  * @param sc		software handle to the device  * @param qid		id of the CQ returned by the fw at the time of creation  * @param npopped	number of CQEs to arm  * @param rearm		rearm bit enable/disable  */
end_comment

begin_function
name|void
name|oce_arm_cq
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|,
name|int16_t
name|qid
parameter_list|,
name|int
name|npopped
parameter_list|,
name|uint32_t
name|rearm
parameter_list|)
block|{
name|cq_db_t
name|cq_db
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cq_db
operator|.
name|bits
operator|.
name|rearm
operator|=
name|rearm
expr_stmt|;
name|cq_db
operator|.
name|bits
operator|.
name|num_popped
operator|=
name|npopped
expr_stmt|;
name|cq_db
operator|.
name|bits
operator|.
name|event
operator|=
literal|0
expr_stmt|;
name|cq_db
operator|.
name|bits
operator|.
name|qid
operator|=
name|qid
expr_stmt|;
name|OCE_WRITE_REG32
argument_list|(
name|sc
argument_list|,
name|db
argument_list|,
name|PD_CQ_DB
argument_list|,
name|cq_db
operator|.
name|dw0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * @brief		function to cleanup the eqs used during stop  * @param eq		pointer to event queue structure  * @returns		the number of EQs processed  */
end_comment

begin_function
name|void
name|oce_drain_eq
parameter_list|(
name|struct
name|oce_eq
modifier|*
name|eq
parameter_list|)
block|{
name|struct
name|oce_eqe
modifier|*
name|eqe
decl_stmt|;
name|uint16_t
name|num_eqe
init|=
literal|0
decl_stmt|;
name|POCE_SOFTC
name|sc
init|=
name|eq
operator|->
name|parent
decl_stmt|;
do|do
block|{
name|eqe
operator|=
name|RING_GET_CONSUMER_ITEM_VA
argument_list|(
name|eq
operator|->
name|ring
argument_list|,
expr|struct
name|oce_eqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|eqe
operator|->
name|evnt
operator|==
literal|0
condition|)
break|break;
name|eqe
operator|->
name|evnt
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|eq
operator|->
name|ring
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|eq
operator|->
name|ring
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|num_eqe
operator|++
expr_stmt|;
name|RING_GET
argument_list|(
name|eq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TRUE
condition|)
do|;
name|oce_arm_eq
argument_list|(
name|sc
argument_list|,
name|eq
operator|->
name|eq_id
argument_list|,
name|num_eqe
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|oce_drain_wq_cq
parameter_list|(
name|struct
name|oce_wq
modifier|*
name|wq
parameter_list|)
block|{
name|POCE_SOFTC
name|sc
init|=
name|wq
operator|->
name|parent
decl_stmt|;
name|struct
name|oce_cq
modifier|*
name|cq
init|=
name|wq
operator|->
name|cq
decl_stmt|;
name|struct
name|oce_nic_tx_cqe
modifier|*
name|cqe
decl_stmt|;
name|int
name|num_cqes
init|=
literal|0
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
do|do
block|{
name|cqe
operator|=
name|RING_GET_CONSUMER_ITEM_VA
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
expr|struct
name|oce_nic_tx_cqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|cqe
operator|->
name|u0
operator|.
name|dw
index|[
literal|3
index|]
operator|==
literal|0
condition|)
break|break;
name|cqe
operator|->
name|u0
operator|.
name|dw
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|RING_GET
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|num_cqes
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|TRUE
condition|)
do|;
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
name|num_cqes
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * @brief		function to drain a MCQ and process its CQEs  * @param dev		software handle to the device  * @param cq		pointer to the cq to drain  * @returns		the number of CQEs processed  */
end_comment

begin_function
name|void
name|oce_drain_mq_cq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* TODO: additional code. */
return|return;
block|}
end_function

begin_comment
comment|/**  * @brief		function to process a Recieve queue  * @param arg		pointer to the RQ to charge  * @return		number of cqes processed  */
end_comment

begin_function
name|void
name|oce_drain_rq_cq
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|oce_nic_rx_cqe
modifier|*
name|cqe
decl_stmt|;
name|uint16_t
name|num_cqe
init|=
literal|0
decl_stmt|;
name|struct
name|oce_cq
modifier|*
name|cq
decl_stmt|;
name|POCE_SOFTC
name|sc
decl_stmt|;
name|sc
operator|=
name|rq
operator|->
name|parent
expr_stmt|;
name|cq
operator|=
name|rq
operator|->
name|cq
expr_stmt|;
name|cqe
operator|=
name|RING_GET_CONSUMER_ITEM_VA
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
expr|struct
name|oce_nic_rx_cqe
argument_list|)
expr_stmt|;
comment|/* dequeue till you reach an invalid cqe */
while|while
condition|(
name|RQ_CQE_VALID
argument_list|(
name|cqe
argument_list|)
condition|)
block|{
name|RQ_CQE_INVALIDATE
argument_list|(
name|cqe
argument_list|)
expr_stmt|;
name|RING_GET
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cqe
operator|=
name|RING_GET_CONSUMER_ITEM_VA
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
expr|struct
name|oce_nic_rx_cqe
argument_list|)
expr_stmt|;
name|num_cqe
operator|++
expr_stmt|;
block|}
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
name|num_cqe
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|oce_free_posted_rxbuf
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|oce_packet_desc
modifier|*
name|pd
decl_stmt|;
while|while
condition|(
name|rq
operator|->
name|pending
condition|)
block|{
name|pd
operator|=
operator|&
name|rq
operator|->
name|pckts
index|[
name|rq
operator|->
name|ring
operator|->
name|cidx
index|]
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rq
operator|->
name|tag
argument_list|,
name|pd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rq
operator|->
name|tag
argument_list|,
name|pd
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|pd
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|pd
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|RING_GET
argument_list|(
name|rq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rq
operator|->
name|pending
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|oce_rx_cq_clean_hwlro
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|oce_cq
modifier|*
name|cq
init|=
name|rq
operator|->
name|cq
decl_stmt|;
name|POCE_SOFTC
name|sc
init|=
name|rq
operator|->
name|parent
decl_stmt|;
name|struct
name|nic_hwlro_singleton_cqe
modifier|*
name|cqe
decl_stmt|;
name|struct
name|nic_hwlro_cqe_part2
modifier|*
name|cqe2
decl_stmt|;
name|int
name|flush_wait
init|=
literal|0
decl_stmt|;
name|int
name|flush_compl
init|=
literal|0
decl_stmt|;
name|int
name|num_frags
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cqe
operator|=
name|RING_GET_CONSUMER_ITEM_VA
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
expr|struct
name|nic_hwlro_singleton_cqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|cqe
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|cqe
operator|->
name|cqe_type
operator|==
literal|0
condition|)
block|{
comment|/* singleton cqe */
comment|/* we should not get singleton cqe after cqe1 on same rq */
if|if
condition|(
name|rq
operator|->
name|cqe_firstpart
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Got singleton cqe after cqe1 \n"
argument_list|)
expr_stmt|;
goto|goto
name|exit_rx_cq_clean_hwlro
goto|;
block|}
name|num_frags
operator|=
name|cqe
operator|->
name|pkt_size
operator|/
name|rq
operator|->
name|cfg
operator|.
name|frag_size
expr_stmt|;
if|if
condition|(
name|cqe
operator|->
name|pkt_size
operator|%
name|rq
operator|->
name|cfg
operator|.
name|frag_size
condition|)
name|num_frags
operator|++
expr_stmt|;
name|oce_discard_rx_comp
argument_list|(
name|rq
argument_list|,
name|num_frags
argument_list|)
expr_stmt|;
comment|/* Check if CQE is flush completion */
if|if
condition|(
operator|!
name|cqe
operator|->
name|pkt_size
condition|)
name|flush_compl
operator|=
literal|1
expr_stmt|;
name|cqe
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|RING_GET
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cqe
operator|->
name|cqe_type
operator|==
literal|0x1
condition|)
block|{
comment|/* first part */
comment|/* we should not get cqe1 after cqe1 on same rq */
if|if
condition|(
name|rq
operator|->
name|cqe_firstpart
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Got cqe1 after cqe1 \n"
argument_list|)
expr_stmt|;
goto|goto
name|exit_rx_cq_clean_hwlro
goto|;
block|}
name|rq
operator|->
name|cqe_firstpart
operator|=
operator|(
expr|struct
name|nic_hwlro_cqe_part1
operator|*
operator|)
name|cqe
expr_stmt|;
name|RING_GET
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cqe
operator|->
name|cqe_type
operator|==
literal|0x2
condition|)
block|{
comment|/* second part */
name|cqe2
operator|=
operator|(
expr|struct
name|nic_hwlro_cqe_part2
operator|*
operator|)
name|cqe
expr_stmt|;
comment|/* We should not get cqe2 without cqe1 */
if|if
condition|(
name|rq
operator|->
name|cqe_firstpart
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Got cqe2 without cqe1 \n"
argument_list|)
expr_stmt|;
goto|goto
name|exit_rx_cq_clean_hwlro
goto|;
block|}
name|num_frags
operator|=
name|cqe2
operator|->
name|coalesced_size
operator|/
name|rq
operator|->
name|cfg
operator|.
name|frag_size
expr_stmt|;
if|if
condition|(
name|cqe2
operator|->
name|coalesced_size
operator|%
name|rq
operator|->
name|cfg
operator|.
name|frag_size
condition|)
name|num_frags
operator|++
expr_stmt|;
comment|/* Flush completion will always come in singleton CQE */
name|oce_discard_rx_comp
argument_list|(
name|rq
argument_list|,
name|num_frags
argument_list|)
expr_stmt|;
name|rq
operator|->
name|cqe_firstpart
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|cqe2
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|cqe_firstpart
operator|=
name|NULL
expr_stmt|;
name|RING_GET
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush_compl
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|flush_wait
operator|++
operator|>
literal|100
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"did not receive hwlro flush compl\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* After cleanup, leave the CQ in unarmed state */
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit_rx_cq_clean_hwlro
label|:
return|return;
block|}
end_function

begin_function
name|void
name|oce_rx_cq_clean
parameter_list|(
name|struct
name|oce_rq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|oce_nic_rx_cqe
modifier|*
name|cqe
decl_stmt|;
name|struct
name|oce_cq
modifier|*
name|cq
decl_stmt|;
name|POCE_SOFTC
name|sc
decl_stmt|;
name|int
name|flush_wait
init|=
literal|0
decl_stmt|;
name|int
name|flush_compl
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|rq
operator|->
name|parent
expr_stmt|;
name|cq
operator|=
name|rq
operator|->
name|cq
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|cq
operator|->
name|ring
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cqe
operator|=
name|RING_GET_CONSUMER_ITEM_VA
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
expr|struct
name|oce_nic_rx_cqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|RQ_CQE_VALID
argument_list|(
name|cqe
argument_list|)
condition|)
block|{
name|DW_SWAP
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|cqe
argument_list|,
sizeof|sizeof
argument_list|(
name|oce_rq_cqe
argument_list|)
argument_list|)
expr_stmt|;
name|oce_discard_rx_comp
argument_list|(
name|rq
argument_list|,
name|cqe
operator|->
name|u0
operator|.
name|s
operator|.
name|num_fragments
argument_list|)
expr_stmt|;
comment|/* Check if CQE is flush completion */
if|if
condition|(
operator|(
name|cqe
operator|->
name|u0
operator|.
name|s
operator|.
name|num_fragments
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cqe
operator|->
name|u0
operator|.
name|s
operator|.
name|pkt_size
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cqe
operator|->
name|u0
operator|.
name|s
operator|.
name|error
operator|==
literal|0
operator|)
condition|)
name|flush_compl
operator|=
literal|1
expr_stmt|;
name|RQ_CQE_INVALIDATE
argument_list|(
name|cqe
argument_list|)
expr_stmt|;
name|RING_GET
argument_list|(
name|cq
operator|->
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
if|if
condition|(
name|IF_LRO_ENABLED
argument_list|(
name|sc
argument_list|)
condition|)
name|oce_rx_flush_lro
argument_list|(
name|rq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush_compl
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|flush_wait
operator|++
operator|>
literal|100
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"did not receive flush compl\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* After cleanup, leave the CQ in unarmed state */
name|oce_arm_cq
argument_list|(
name|sc
argument_list|,
name|cq
operator|->
name|cq_id
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|oce_stop_rx
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|)
block|{
name|struct
name|oce_mbx
name|mbx
decl_stmt|;
name|struct
name|mbx_delete_nic_rq
modifier|*
name|fwcmd
decl_stmt|;
name|struct
name|mbx_delete_nic_rq_v1
modifier|*
name|fwcmd1
decl_stmt|;
name|struct
name|oce_rq
modifier|*
name|rq
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* before deleting disable hwlro */
if|if
condition|(
name|sc
operator|->
name|enable_hwlro
condition|)
name|oce_mbox_nic_set_iface_lro_config
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|for_all_rq_queues
argument_list|(
argument|sc
argument_list|,
argument|rq
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|rq
operator|->
name|qstate
operator|==
name|QCREATED
condition|)
block|{
comment|/* Delete rxq in firmware */
name|LOCK
argument_list|(
operator|&
name|rq
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
name|mbx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rq
operator|->
name|islro
condition|)
block|{
name|fwcmd
operator|=
operator|(
expr|struct
name|mbx_delete_nic_rq
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd
operator|->
name|params
operator|.
name|req
operator|.
name|rq_id
operator|=
name|rq
operator|->
name|rq_id
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_delete_nic_rq
argument_list|)
argument_list|,
name|QTYPE_RQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fwcmd1
operator|=
operator|(
expr|struct
name|mbx_delete_nic_rq_v1
operator|*
operator|)
operator|&
name|mbx
operator|.
name|payload
expr_stmt|;
name|fwcmd1
operator|->
name|params
operator|.
name|req
operator|.
name|rq_id
operator|=
name|rq
operator|->
name|rq_id
expr_stmt|;
name|fwcmd1
operator|->
name|params
operator|.
name|req
operator|.
name|rq_flags
operator|=
operator|(
name|NIC_RQ_FLAGS_RSS
operator||
name|NIC_RQ_FLAGS_LRO
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|oce_destroy_q
argument_list|(
name|sc
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbx_delete_nic_rq_v1
argument_list|)
argument_list|,
name|QTYPE_RQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rq
operator|->
name|qstate
operator|=
name|QDELETED
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rq
operator|->
name|islro
condition|)
name|oce_rx_cq_clean
argument_list|(
name|rq
argument_list|)
expr_stmt|;
else|else
name|oce_rx_cq_clean_hwlro
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* Free posted RX buffers that are not used */
name|oce_free_posted_rxbuf
argument_list|(
name|rq
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rq
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|oce_start_rx
parameter_list|(
name|POCE_SOFTC
name|sc
parameter_list|)
block|{
name|struct
name|oce_rq
modifier|*
name|rq
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|for_all_rq_queues
argument_list|(
argument|sc
argument_list|,
argument|rq
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|rq
operator|->
name|qstate
operator|==
name|QCREATED
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|sc
operator|->
name|enable_hwlro
operator|)
condition|)
block|{
name|rc
operator|=
name|oce_mbox_create_rq
argument_list|(
name|rq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
name|rq
operator|->
name|islro
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|oce_mbox_create_rq_v2
argument_list|(
name|rq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
name|rq
operator|->
name|islro
operator|=
literal|1
expr_stmt|;
block|}
comment|/* reset queue pointers */
name|rq
operator|->
name|qstate
operator|=
name|QCREATED
expr_stmt|;
name|rq
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|ring
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|ring
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|enable_hwlro
condition|)
block|{
name|rc
operator|=
name|oce_mbox_nic_set_iface_lro_config
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* RSS config */
if|if
condition|(
name|is_rss_enabled
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|oce_config_nic_rss
argument_list|(
name|sc
argument_list|,
operator|(
name|uint8_t
operator|)
name|sc
operator|->
name|if_id
argument_list|,
name|RSS_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error
goto|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
name|error
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Start RX failed\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

end_unit

