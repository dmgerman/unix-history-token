begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000-2001 by Coleman Kane<cokane@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Gardner Buchanan.  * 4. The name of Gardner Buchanan may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 3dfx driver for FreeBSD 4.x - Finished 11 May 2000, 12:25AM ET  *  * Copyright (C) 2000-2001, by Coleman Kane<cokane@FreeBSD.org>,   * based upon the 3dfx driver written for linux, by Daryll Straus, Jon Taylor,  * and Jens Axboe, located at http://linux.3dfx.com.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/* rman.h depends on machine/bus.h */
end_comment

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_io.h>
end_include

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_vars.h>
end_include

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_pci.h>
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|tdfx_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tdfx_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up the boot probe/attach routines */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|tdfx_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tdfx_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|tdfx_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|tdfx_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|tdfx_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TDFX
argument_list|,
literal|"tdfx_driver"
argument_list|,
literal|"3DFX Graphics[/2D]/3D Accelerator(s)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Char. Dev. file operations structure */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|tdfx_cdev
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|tdfx_open
block|,
operator|.
name|d_close
operator|=
name|tdfx_close
block|,
operator|.
name|d_ioctl
operator|=
name|tdfx_ioctl
block|,
operator|.
name|d_mmap
operator|=
name|tdfx_mmap
block|,
operator|.
name|d_name
operator|=
literal|"tdfx"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tdfx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * probe routine called on kernel boot to register supported devices. We get 	 * a device structure to work with, and we can test the VENDOR/DEVICE IDs to 	 * see if this PCI device is one that we support. Return BUS_PRROBE_DEFAULT 	 * if yes, ENXIO if not. 	 */
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCI_DEVICE_ALLIANCE_AT3D
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ProMotion At3D 3D Accelerator"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
case|case
name|PCI_DEVICE_3DFX_VOODOO2
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"3DFX Voodoo II 3D Accelerator"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
comment|/*case PCI_DEVICE_3DFX_BANSHEE: 		device_set_desc(dev, "3DFX Voodoo Banshee 2D/3D Graphics Accelerator"); 		return BUS_PROBE_DEFAULT; 	case PCI_DEVICE_3DFX_VOODOO3: 		device_set_desc(dev, "3DFX Voodoo3 2D/3D Graphics Accelerator"); 		return BUS_PROBE_DEFAULT;*/
case|case
name|PCI_DEVICE_3DFX_VOODOO1
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"3DFX Voodoo Graphics 3D Accelerator"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
empty_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * The attach routine is called after the probe routine successfully says it 	 * supports a given card. We now proceed to initialize this card for use with 	 * the system. I want to map the device memory for userland allocation and 	 * fill an information structure with information on this card. I'd also like 	 * to set Write Combining with the MTRR code so that we can hopefully speed 	 * up memory writes. The last thing is to register the character device 	 * interface to the card, so we can open it from /dev/3dfxN, where N is a 	 * small, whole number. 	 */
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
decl_stmt|;
name|u_long
name|val
decl_stmt|;
comment|/* rid value tells bus_alloc_resource where to find the addresses of ports or 	 * of memory ranges in the PCI config space*/
name|int
name|rid
init|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/* Increment the card counter (for the ioctl code) */
name|tdfx_count
operator|++
expr_stmt|;
comment|/* Enable MemMap on Voodoo */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Fill the soft config struct with info about this device*/
name|tdfx_info
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|tdfx_info
operator|->
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|type
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
expr_stmt|;
name|tdfx_info
operator|->
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|dv
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|curFile
operator|=
name|NULL
expr_stmt|;
comment|/*  	 *	Get the Memory Location from the PCI Config, mask out lower word, since 	 * the config space register is only one word long (this is nicer than a 	 * bitshift). 	 */
name|tdfx_info
operator|->
name|addr0
operator|=
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x10
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xffff0000
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Base0 @ 0x%x\n"
argument_list|,
name|tdfx_info
operator|->
name|addr0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Notify the VM that we will be mapping some memory later */
name|tdfx_info
operator|->
name|memrange
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|memrange
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error mapping mem, won't be able to use mmap()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdfx_info
operator|->
name|memrid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tdfx_info
operator|->
name|memrid
operator|=
name|rid
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Mapped to: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rman_get_start
argument_list|(
name|tdfx_info
operator|->
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Setup for Voodoo3 and Banshee, PIO and an extram Memrange */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO3
operator|||
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_BANSHEE
condition|)
block|{
name|rid
operator|=
literal|0x14
expr_stmt|;
comment|/* 2nd mem map */
name|tdfx_info
operator|->
name|addr1
operator|=
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x14
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xffff0000
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Base1 @ 0x%x\n"
argument_list|,
name|tdfx_info
operator|->
name|addr1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdfx_info
operator|->
name|memrange2
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|memrange2
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Mem1 couldn't be allocated, glide may not work."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdfx_info
operator|->
name|memrid2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tdfx_info
operator|->
name|memrid2
operator|=
name|rid
expr_stmt|;
block|}
comment|/* Now to map the PIO stuff */
name|rid
operator|=
name|PCIR_IOBASE0_2
expr_stmt|;
name|tdfx_info
operator|->
name|pio0
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x2c
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|pio0max
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x30
argument_list|,
literal|2
argument_list|)
operator|+
name|tdfx_info
operator|->
name|pio0
expr_stmt|;
name|tdfx_info
operator|->
name|piorange
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|piorange
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map PIO range."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdfx_info
operator|->
name|piorid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tdfx_info
operator|->
name|piorid
operator|=
name|rid
expr_stmt|;
block|}
block|}
else|else
block|{
name|tdfx_info
operator|->
name|addr1
operator|=
literal|0
expr_stmt|;
name|tdfx_info
operator|->
name|memrange2
operator|=
name|NULL
expr_stmt|;
name|tdfx_info
operator|->
name|piorange
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  	 *	Set Writecombining, or at least Uncacheable for the memory region, if we 	 * are able to 	 */
if|if
condition|(
name|tdfx_setmtrr
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Some weird error setting MTRRs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
comment|/*  	 * make_dev registers the cdev to access the 3dfx card from /dev 	 *	use hex here for the dev num, simply to provide better support if> 10 	 * voodoo cards, for the mad. The user must set the link. 	 * Why would we want that many voodoo cards anyhow?  	 */
name|tdfx_info
operator|->
name|devt
operator|=
name|make_dev
argument_list|(
operator|&
name|tdfx_cdev
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"3dfx%x"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|devt
operator|->
name|si_drv1
operator|=
name|tdfx_info
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|tdfx_info
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Delete allocated resource, of course */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|tdfx_info
operator|->
name|memrid
argument_list|,
name|tdfx_info
operator|->
name|memrange
argument_list|)
expr_stmt|;
comment|/* Release extended Voodoo3/Banshee resources */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_BANSHEE
operator|||
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO3
condition|)
block|{
if|if
condition|(
name|tdfx_info
operator|->
name|memrange2
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|tdfx_info
operator|->
name|memrid2
argument_list|,
name|tdfx_info
operator|->
name|memrange
argument_list|)
expr_stmt|;
comment|/*	if(tdfx_info->piorange != NULL) 			bus_release_resource(dev, SYS_RES_IOPORT, tdfx_info->piorid, 				tdfx_info->piorange);*/
block|}
comment|/* Though it is safe to leave the WRCOMB support since the  		mem driver checks for it, we should remove it in order 		to free an MTRR for another device */
name|retval
operator|=
name|tdfx_clrmtrr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"tdfx: For some reason, I couldn't clear the mtrr\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove device entry when it can no longer be accessed */
name|destroy_dev
argument_list|(
name|tdfx_info
operator|->
name|devt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"tdfx: Device Shutdown\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_clrmtrr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* This function removes the MTRR set by the attach call, so it can be used 	 * in the future by other drivers.  	 */
name|int
name|retval
decl_stmt|,
name|act
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|act
operator|=
name|MEMRANGE_SET_REMOVE
expr_stmt|;
name|retval
operator|=
name|mem_range_attr_set
argument_list|(
operator|&
name|tdfx_info
operator|->
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_setmtrr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * This is the MTRR setting function for the 3dfx card. It is called from 	 * tdfx_attach. If we can't set the MTRR properly, it's not the end of the 	 * world. We can still continue, just with slightly (very slightly) degraded 	 * performance. 	 */
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|act
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* The older Voodoo cards have a shorter memrange than the newer ones */
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO1
operator|)
operator|||
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO2
operator|)
condition|)
block|{
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_len
operator|=
literal|0x400000
expr_stmt|;
comment|/* The memory descriptor is described as the top 15 bits of the real 			address */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_base
operator|=
name|tdfx_info
operator|->
name|addr0
operator|&
literal|0xfffe0000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO3
operator|)
operator|||
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_BANSHEE
operator|)
condition|)
block|{
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_len
operator|=
literal|0x1000000
expr_stmt|;
comment|/* The Voodoo3 and Banshee LFB is the second memory address */
comment|/* The memory descriptor is described as the top 15 bits of the real 			address */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_base
operator|=
name|tdfx_info
operator|->
name|addr1
operator|&
literal|0xfffe0000
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/*      *	The Alliance Pro Motion AT3D was not mentioned in the linux 	 * driver as far as MTRR support goes, so I just won't put the 	 * code in here for it. This is where it should go, though.  	 */
comment|/* Firstly, try to set write combining */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_flags
operator|=
name|MDF_WRITECOMBINE
expr_stmt|;
name|bcopy
argument_list|(
literal|"tdfx"
argument_list|,
operator|&
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_owner
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|act
operator|=
name|MEMRANGE_SET_UPDATE
expr_stmt|;
name|retval
operator|=
name|mem_range_attr_set
argument_list|(
operator|&
name|tdfx_info
operator|->
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MTRR Set Correctly for tdfx\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO2
operator|)
operator|||
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO1
operator|)
condition|)
block|{
comment|/* if, for some reason we can't set the WRCOMB range with the V1/V2, we 		 * can still possibly use the UNCACHEABLE region for it instead, and help 		 * out in a small way */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_flags
operator|=
name|MDF_UNCACHEABLE
expr_stmt|;
comment|/* This length of 1000h was taken from the linux device driver... */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_len
operator|=
literal|0x1000
expr_stmt|;
comment|/* 		 * If, for some reason, we can't set the MTRR (N/A?) we may still continue 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MTRR Set Type Uncacheable %x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Couldn't Set MTRR\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/*  	 *	The open cdev method handles open(2) calls to /dev/3dfx[n]  	 * We can pretty much allow any opening of the device. 	 */
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|busy
operator|!=
literal|0
condition|)
return|return
name|EBUSY
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"3dfx: Opened by #%d\n"
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the driver as busy */
name|tdfx_info
operator|->
name|busy
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/*  	 *	The close cdev method handles close(2) calls to /dev/3dfx[n]  	 * We'll always want to close the device when it's called. 	 */
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|busy
operator|==
literal|0
condition|)
return|return
name|EBADF
return|;
name|tdfx_info
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Closed by #%d\n"
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
comment|/*  	 * mmap(2) is called by a user process to request that an area of memory 	 * associated with this device be mapped for the process to work with. Nprot 	 * holds the protections requested, PROT_READ, PROT_WRITE, or both. 	 */
comment|/**** OLD GET CONFIG ****/
comment|/* struct tdfx_softc* tdfx_info; */
comment|/* Get the configuration for our card XXX*/
comment|/*tdfx_info = dev->si_drv1; */
comment|/************************/
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
index|[
literal|2
index|]
decl_stmt|;
name|tdfx_info
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If, for some reason, its not configured, we bail out */
if|if
condition|(
name|tdfx_info
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"tdfx: tdfx_info (softc) is NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
comment|/* We must stay within the bound of our address space */
if|if
condition|(
operator|(
name|offset
operator|&
literal|0xff000000
operator|)
operator|==
name|tdfx_info
index|[
literal|0
index|]
operator|->
name|addr0
condition|)
block|{
name|offset
operator|&=
literal|0xffffff
expr_stmt|;
operator|*
name|paddr
operator|=
name|rman_get_start
argument_list|(
name|tdfx_info
index|[
literal|0
index|]
operator|->
name|memrange
argument_list|)
operator|+
name|offset
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tdfx_count
operator|>
literal|1
condition|)
block|{
name|tdfx_info
index|[
literal|1
index|]
operator|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0xff000000
operator|)
operator|==
name|tdfx_info
index|[
literal|1
index|]
operator|->
name|addr0
condition|)
block|{
name|offset
operator|&=
literal|0xffffff
expr_stmt|;
operator|*
name|paddr
operator|=
name|rman_get_start
argument_list|(
name|tdfx_info
index|[
literal|1
index|]
operator|->
name|memrange
argument_list|)
operator|+
name|offset
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* See if the Banshee/V3 LFB is being requested */
comment|/*if(tdfx_info->memrange2 != NULL&& (offset& 0xff000000) == 			tdfx_info->addr1) { 	  	offset&= 0xffffff; 		return atop(rman_get_start(tdfx_info[1]->memrange2) + offset); 	}*/
comment|/* VoodooNG code */
comment|/* The ret call */
comment|/* atop -> address to page 	 * rman_get_start, get the (struct resource*)->r_start member, 	 * the mapping base address. 	 */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_query_boards
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      *	This returns the number of installed tdfx cards, we have been keeping 	 * count, look at tdfx_attach  	 */
return|return
name|tdfx_count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_query_fetch
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* XXX Comment this later, after careful inspection and spring cleaning :) */
comment|/* Various return values 8bit-32bit */
name|u_int8_t
name|ret_byte
decl_stmt|;
name|u_int16_t
name|ret_word
decl_stmt|;
name|u_int32_t
name|ret_dword
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|NULL
decl_stmt|;
comment|/* This one depend on the tdfx_* structs being properly initialized */
comment|/*piod->device&= 0xf;*/
if|if
condition|(
operator|(
name|piod
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tdfx_count
operator|<=
name|piod
operator|->
name|device
operator|)
operator|||
operator|(
name|piod
operator|->
name|device
operator|<
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"tdfx: Bad device or internal struct in tdfx_query_fetch\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EINVAL
return|;
block|}
name|tdfx_info
operator|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|piod
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENXIO
return|;
comment|/* We must restrict the size reads from the port, since to high or low of a 	 * size witll result in wrong data being passed, and that's bad */
comment|/* A few of these were pulled during the attach phase */
switch|switch
condition|(
name|piod
operator|->
name|port
condition|)
block|{
case|case
name|PCI_VENDOR_ID_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
name|copyout
argument_list|(
operator|&
name|tdfx_info
operator|->
name|vendor
argument_list|,
name|piod
operator|->
name|value
argument_list|,
name|piod
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_DEVICE_ID_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
name|copyout
argument_list|(
operator|&
name|tdfx_info
operator|->
name|type
argument_list|,
name|piod
operator|->
name|value
argument_list|,
name|piod
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_BASE_ADDRESS_0_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|copyout
argument_list|(
operator|&
name|tdfx_info
operator|->
name|addr0
argument_list|,
name|piod
operator|->
name|value
argument_list|,
name|piod
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_BASE_ADDRESS_1_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|copyout
argument_list|(
operator|&
name|tdfx_info
operator|->
name|addr1
argument_list|,
name|piod
operator|->
name|value
argument_list|,
name|piod
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_PRIBUS_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|PCI_IOBASE_0_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|PCI_IOLIMIT_0_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL1_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|PCI_REVISION_ID_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL4_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Read the value and return */
switch|switch
condition|(
name|piod
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
name|ret_byte
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
index|[
name|piod
operator|->
name|device
index|]
operator|.
name|dev
argument_list|,
name|piod
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_byte
argument_list|,
name|piod
operator|->
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ret_word
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
index|[
name|piod
operator|->
name|device
index|]
operator|.
name|dev
argument_list|,
name|piod
operator|->
name|port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_word
argument_list|,
name|piod
operator|->
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ret_dword
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
index|[
name|piod
operator|->
name|device
index|]
operator|.
name|dev
argument_list|,
name|piod
operator|->
name|port
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_dword
argument_list|,
name|piod
operator|->
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_query_update
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* XXX Comment this later, after careful inspection and spring cleaning :) */
comment|/* Return vals */
name|u_int8_t
name|ret_byte
decl_stmt|;
name|u_int16_t
name|ret_word
decl_stmt|;
name|u_int32_t
name|ret_dword
decl_stmt|;
comment|/* Port vals, mask */
name|u_int32_t
name|retval
decl_stmt|,
name|preval
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|piod
operator|==
name|NULL
operator|)
operator|||
operator|(
name|piod
operator|->
name|device
operator|>=
operator|(
name|tdfx_count
operator|&
literal|0xf
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"tdfx: Bad struct or device in tdfx_query_update\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EINVAL
return|;
block|}
name|tdfx_info
operator|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|piod
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENXIO
return|;
comment|/* Code below this line in the fuction was taken from the  	 * Linux driver and converted for freebsd. */
comment|/* Check the size for all the ports, to make sure stuff doesn't get messed up 	 * by poorly written clients */
switch|switch
condition|(
name|piod
operator|->
name|port
condition|)
block|{
case|case
name|PCI_COMMAND_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL1_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL2_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL3_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL4_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Read the current value */
name|retval
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
operator|->
name|dev
argument_list|,
name|piod
operator|->
name|port
operator|&
operator|~
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* These set up a mask to use, since apparently they wanted to write 4 bytes 	 * at once to the ports */
switch|switch
condition|(
name|piod
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|preval
operator|=
name|ret_byte
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
name|mask
operator|=
literal|0xff
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|preval
operator|=
name|ret_word
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
name|mask
operator|=
literal|0xffff
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_dword
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|preval
operator|=
name|ret_dword
expr_stmt|;
name|mask
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Finally, combine the values and write it to the port */
name|retval
operator|=
operator|(
name|retval
operator|&
operator|~
name|mask
operator|)
operator||
name|preval
expr_stmt|;
name|pci_write_config
argument_list|(
name|tdfx_info
operator|->
name|dev
argument_list|,
name|piod
operator|->
name|port
operator|&
operator|~
literal|3
argument_list|,
name|retval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For both of these, I added a variable named workport of type u_int so  * that I could eliminate the warning about my data type size. The  * applications expect the port to be of type short, so I needed to change  * this within the function */
end_comment

begin_function
specifier|static
name|int
name|tdfx_do_pio_rd
parameter_list|(
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* Return val */
name|u_int8_t
name|ret_byte
decl_stmt|;
name|u_int
name|workport
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|piod
operator|->
name|device
argument_list|)
decl_stmt|;
comment|/* Restricts the access of ports other than those we use */
if|if
condition|(
operator|(
operator|(
name|piod
operator|->
name|port
operator|!=
name|VGA_INPUT_STATUS_1C
operator|)
operator|||
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_INDEX
operator|)
operator|||
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_DATA
operator|)
operator|||
operator|(
name|piod
operator|->
name|port
operator|!=
name|VGA_MISC_OUTPUT_READ
operator|)
operator|)
operator|&&
operator|(
name|piod
operator|->
name|port
operator|<
name|tdfx_info
operator|->
name|pio0
operator|)
operator|&&
operator|(
name|piod
operator|->
name|port
operator|>
name|tdfx_info
operator|->
name|pio0max
operator|)
condition|)
return|return
operator|-
name|EPERM
return|;
comment|/* All VGA STATUS REGS are byte registers, size should never be> 1 */
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|1
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Write the data to the intended port */
name|workport
operator|=
name|piod
operator|->
name|port
expr_stmt|;
name|ret_byte
operator|=
name|inb
argument_list|(
name|workport
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_byte
argument_list|,
name|piod
operator|->
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_do_pio_wt
parameter_list|(
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* return val */
name|u_int8_t
name|ret_byte
decl_stmt|;
name|u_int
name|workport
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|piod
operator|->
name|device
argument_list|)
decl_stmt|;
comment|/* Replace old switch w/ massive if(...) */
comment|/* Restricts the access of ports other than those we use */
if|if
condition|(
operator|(
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_INDEX
operator|)
operator|&&
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_DATA
operator|)
operator|&&
operator|(
name|piod
operator|->
name|port
operator|!=
name|VGA_MISC_OUTPUT_READ
operator|)
operator|)
comment|/* Can't write VGA_ST_1C */
operator|&&
operator|(
name|piod
operator|->
name|port
operator|<
name|tdfx_info
operator|->
name|pio0
operator|)
operator|&&
operator|(
name|piod
operator|->
name|port
operator|>
name|tdfx_info
operator|->
name|pio0max
operator|)
condition|)
return|return
operator|-
name|EPERM
return|;
comment|/* All VGA STATUS REGS are byte registers, size should never be> 1 */
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|1
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Write the data to the intended port */
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|)
expr_stmt|;
name|workport
operator|=
name|piod
operator|->
name|port
expr_stmt|;
name|outb
argument_list|(
name|workport
argument_list|,
name|ret_byte
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_do_query
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* There are three sub-commands to the query 0x33 */
switch|switch
condition|(
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
return|return
name|tdfx_query_boards
argument_list|()
return|;
break|break;
case|case
literal|3
case|:
return|return
name|tdfx_query_fetch
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
return|;
break|break;
case|case
literal|4
case|:
return|return
name|tdfx_query_update
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
return|;
break|break;
default|default:
comment|/* In case we are thrown a bogus sub-command! */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Bad Sub-cmd: 0x%x\n"
argument_list|,
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_do_pio
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* Two types of PIO, INPUT and OUTPUT, as the name suggests */
switch|switch
condition|(
name|_IOC_DIR
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
case|case
name|IOCV_OUT
case|:
return|return
name|tdfx_do_pio_rd
argument_list|(
name|piod
argument_list|)
return|;
break|break;
case|case
name|IOCV_IN
case|:
return|return
name|tdfx_do_pio_wt
argument_list|(
name|piod
argument_list|)
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Calls to ioctl(2) eventually end up here. Unhandled ioctls return an ENXIO,  * normally, you would read in the data pointed to by data, then write your  * output to it. The ioctl *should* normally return zero if everything is  * alright, but 3dfx didn't make it that way...  *  * For all of the ioctl code, in the event of a real error,  * we return -Exxxx rather than simply Exxxx. The reason for this  * is that the ioctls actually RET information back to the program  * sometimes, rather than filling it in the passed structure. We  * want to distinguish errors from useful data, and maintain compatibility.  *  * There is this portion of the proc struct called p_retval[], we can store a  * return value in td->td_retval[0] and place the return value if it is positive  * in there, then we can return 0 (good). If the return value is negative, we  * can return -retval and the error should be properly handled.  */
end_comment

begin_function
specifier|static
name|int
name|tdfx_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|struct
name|tdfx_pio_data
modifier|*
name|piod
init|=
operator|(
expr|struct
name|tdfx_pio_data
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"IOCTL'd by #%d, cmd: 0x%x, data: %p\n"
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|(
name|u_int32_t
operator|)
name|cmd
argument_list|,
name|piod
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|_IOC_TYPE
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
comment|/* Return the real error if negative, or simply stick the valid return 		 * in td->td_retval */
case|case
literal|0x33
case|:
comment|/* The '3'(0x33) type IOCTL is for querying the installed cards */
if|if
condition|(
operator|(
name|retval
operator|=
name|tdfx_do_query
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|retval
expr_stmt|;
else|else
return|return
operator|-
name|retval
return|;
break|break;
case|case
literal|0
case|:
comment|/* The 0 type IOCTL is for programmed I/O methods */
if|if
condition|(
operator|(
name|tdfx_do_pio
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|retval
expr_stmt|;
else|else
return|return
operator|-
name|retval
return|;
break|break;
default|default:
comment|/* Technically, we won't reach this from linux emu, but when glide 			 * finally gets ported, watch out! */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Bad IOCTL from #%d\n"
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is the device driver struct. This is sent to the driver subsystem to  * register the method structure and the info strcut space for this particular  * instance of the driver.  */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|tdfx_driver
init|=
block|{
literal|"tdfx"
block|,
name|tdfx_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tdfx_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tell Mr. Kernel about us! */
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|tdfx
argument_list|,
name|pci
argument_list|,
name|tdfx_driver
argument_list|,
name|tdfx_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|tdfx
argument_list|,
name|mem
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|tdfx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

