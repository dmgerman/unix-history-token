begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 by Coleman Kane<cokane@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Gardner Buchanan.  * 4. The name of Gardner Buchanan may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *   $FreeBSD$  */
end_comment

begin_comment
comment|/* 3dfx driver for FreeBSD 4.x - Finished 11 May 2000, 12:25AM ET  *  * Copyright (C) 2000, by Coleman Kane<cokane@FreeBSD.org>,   * based upon the 3dfx driver written for linux, by Daryll Straus, Jon Taylor,  * and Jens Axboe, located at http://linux.3dfx.com.  */
end_comment

begin_comment
comment|/*  * put this here, so as to bail out immediately if we have no PCI BUS installed  */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_private.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/* rman.h depends on machine/bus.h */
end_comment

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TDFX_LINUX
end_ifdef

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_linux.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_linux.h>
end_include

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_io.h>
end_include

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_vars.h>
end_include

begin_include
include|#
directive|include
file|<dev/tdfx/tdfx_pci.h>
end_include

begin_include
include|#
directive|include
file|"opt_tdfx.h"
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|tdfx_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tdfx_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up the boot probe/attach routines */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|tdfx_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tdfx_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|tdfx_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|tdfx_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|tdfx_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TDFX
argument_list|,
literal|"TDFX Driver"
argument_list|,
literal|"3DFX Graphics[/2D]/3D Accelerator(s)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TDFX_LINUX
end_ifdef

begin_expr_stmt
name|LINUX_IOCTL_SET
argument_list|(
name|tdfx
argument_list|,
name|LINUX_IOCTL_TDFX_MIN
argument_list|,
name|LINUX_IOCTL_TDFX_MAX
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Char. Dev. file operations structure */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|tdfx_cdev
init|=
block|{
name|tdfx_open
block|,
comment|/* open */
name|tdfx_close
block|,
comment|/* close */
name|noread
block|,
comment|/* read */
name|nowrite
block|,
comment|/* write */
name|tdfx_ioctl
block|,
comment|/* ioctl */
name|nopoll
block|,
comment|/* poll */
name|tdfx_mmap
block|,
comment|/* mmap */
name|nostrategy
block|,
comment|/* strategy */
literal|"tdfx"
block|,
comment|/* dev name */
name|CDEV_MAJOR
block|,
comment|/* char major */
name|nodump
block|,
comment|/* dump */
name|nopsize
block|,
comment|/* size */
literal|0
block|,
comment|/* flags (no set flags) */
operator|-
literal|1
comment|/* bmaj (no block dev) */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tdfx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * probe routine called on kernel boot to register supported devices. We get 	 * a device structure to work with, and we can test the VENDOR/DEVICE IDs to 	 * see if this PCI device is one that we support. Return 0 if yes, ENXIO if 	 * not. 	 */
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCI_DEVICE_ALLIANCE_AT3D
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ProMotion At3D 3D Accelerator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_DEVICE_3DFX_VOODOO2
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"3DFX Voodoo II 3D Accelerator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_DEVICE_3DFX_BANSHEE
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"3DFX Voodoo Banshee 2D/3D Graphics Accelerator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_DEVICE_3DFX_VOODOO3
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"3DFX Voodoo3 2D/3D Graphics Accelerator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_DEVICE_3DFX_VOODOO1
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"3DFX Voodoo Graphics 3D Accelerator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
empty_stmt|;
block|}
empty_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * The attach routine is called after the probe routine successfully says it 	 * supports a given card. We now proceed to initialize this card for use with 	 * the system. I want to map the device memory for userland allocation and 	 * fill an information structure with information on this card. I'd also like 	 * to set Write Combining with the MTRR code so that we can hopefully speed 	 * up memory writes. The last thing is to register the character device 	 * interface to the card, so we can open it from /dev/3dfxN, where N is a 	 * small, whole number. 	 */
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
decl_stmt|;
name|u_long
name|val
decl_stmt|;
comment|/* rid value tells bus_alloc_resource where to find the addresses of ports or 	 * of memory ranges in the PCI config space*/
name|int
name|rid
init|=
name|PCIR_MAPS
decl_stmt|;
comment|/* Increment the card counter (for the ioctl code) */
name|tdfx_count
operator|++
expr_stmt|;
comment|/* Enable MemMap on Voodoo */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Fill the soft config struct with info about this device*/
name|tdfx_info
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|tdfx_info
operator|->
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|type
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
expr_stmt|;
name|tdfx_info
operator|->
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|dv
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tdfx_info
operator|->
name|curFile
operator|=
name|NULL
expr_stmt|;
comment|/*  	 *	Get the Memory Location from the PCI Config, mask out lower word, since 	 * the config space register is only one word long (this is nicer than a 	 * bitshift). 	 */
name|tdfx_info
operator|->
name|addr0
operator|=
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x10
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xffff0000
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Base0 @ 0x%x\n"
argument_list|,
name|tdfx_info
operator|->
name|addr0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Notify the VM that we will be mapping some memory later */
name|tdfx_info
operator|->
name|memrange
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|memrange
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error mapping mem, won't be able to use mmap()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdfx_info
operator|->
name|memrid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tdfx_info
operator|->
name|memrid
operator|=
name|rid
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Mapped to: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rman_get_start
argument_list|(
name|tdfx_info
operator|->
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  	 *	Set Writecombining, or at least Uncacheable for the memory region, if we 	 * are able to 	 */
if|if
condition|(
name|tdfx_setmtrr
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Some weird error setting MTRRs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
comment|/*  	 * make_dev registers the cdev to access the 3dfx card from /dev 	 *	use hex here for the dev num, simply to provide better support if> 10 	 * voodoo cards, for the mad. The user must set the link, or use MAKEDEV. 	 * Why would we want that many voodoo cards anyhow?  	 */
name|make_dev
argument_list|(
operator|&
name|tdfx_cdev
argument_list|,
name|dev
operator|->
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|02660
argument_list|,
literal|"3dfx%x"
argument_list|,
name|dev
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|tdfx_info
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Delete allocated resource, of course */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
name|tdfx_info
operator|->
name|memrange
argument_list|)
expr_stmt|;
comment|/* Though it is safe to leave the WRCOMB support since the  		mem driver checks for it, we should remove it in order 		to free an MTRR for another device */
name|retval
operator|=
name|tdfx_clrmtrr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"tdfx: For some reason, I couldn't clear the mtrr\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"tdfx: Device Shutdown\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_clrmtrr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* This function removes the MTRR set by the attach call, so it can be used 	 * in the future by other drivers.  	 */
name|int
name|retval
decl_stmt|,
name|act
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|act
operator|=
name|MEMRANGE_SET_REMOVE
expr_stmt|;
name|retval
operator|=
name|mem_range_attr_set
argument_list|(
operator|&
name|tdfx_info
operator|->
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_setmtrr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * This is the MTRR setting function for the 3dfx card. It is called from 	 * tdfx_attach. If we can't set the MTRR properly, it's not the end of the 	 * world. We can still continue, just with slightly (very slightly) degraded 	 * performance. 	 */
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|act
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* The memory descriptor is described as the top 15 bits of the real 		address */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_base
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x10
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xfffe0000
expr_stmt|;
comment|/* The older Voodoo cards have a shorter memrange than the newer ones */
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO1
operator|)
operator|||
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO2
operator|)
condition|)
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_len
operator|=
literal|0x400000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO3
operator|)
operator|||
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_BANSHEE
operator|)
condition|)
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_len
operator|=
literal|0x1000000
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/*      *	The Alliance Pro Motion AT3D was not mentioned in the linux 	 * driver as far as MTRR support goes, so I just won't put the 	 * code in here for it. This is where it should go, though.  	 */
comment|/* Firstly, try to set write combining */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_flags
operator|=
name|MDF_WRITECOMBINE
expr_stmt|;
name|bcopy
argument_list|(
literal|"tdfx"
argument_list|,
operator|&
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_owner
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|act
operator|=
name|MEMRANGE_SET_UPDATE
expr_stmt|;
name|retval
operator|=
name|mem_range_attr_set
argument_list|(
operator|&
name|tdfx_info
operator|->
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MTRR Set Correctly for tdfx\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO2
operator|)
operator|||
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_DEVICE_3DFX_VOODOO1
operator|)
condition|)
block|{
comment|/* if, for some reason we can't set the WRCOMB range with the V1/V2, we 		 * can still possibly use the UNCACHEABLE region for it instead, and help 		 * out in a small way */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_flags
operator|=
name|MDF_UNCACHEABLE
expr_stmt|;
comment|/* This length of 1000h was taken from the linux device driver... */
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_len
operator|=
literal|0x1000
expr_stmt|;
comment|/* 		 * If, for some reason, we can't set the MTRR (N/A?) we may still continue 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MTRR Set Type Uncacheable 					%x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|tdfx_info
operator|->
name|mrdesc
operator|.
name|mr_base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Couldn't Set MTRR\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Couldn't Set MTRR\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/*  	 *	The open cdev method handles open(2) calls to /dev/3dfx[n]  	 * We can pretty much allow any opening of the device. 	 */
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|busy
operator|!=
literal|0
condition|)
return|return
name|EBUSY
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"3dfx: Opened by #%d\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the driver as busy */
name|tdfx_info
operator|->
name|busy
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/*  	 *	The close cdev method handles close(2) calls to /dev/3dfx[n]  	 * We'll always want to close the device when it's called. 	 */
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdfx_info
operator|->
name|busy
operator|==
literal|0
condition|)
return|return
name|EBADF
return|;
name|tdfx_info
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Closed by #%d\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
comment|/*  	 * mmap(2) is called by a user process to request that an area of memory 	 * associated with this device be mapped for the process to work with. Nprot 	 * holds the protections requested, PROT_READ, PROT_WRITE, or both. 	 */
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
decl_stmt|;
comment|/* Get the configuration for our card XXX*/
name|tdfx_info
operator|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If, for some reason, its not configured, we bail out */
if|if
condition|(
name|tdfx_info
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"tdfx: tdfx_info (softc) is NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
comment|/* We must stay within the bound of our address space */
if|if
condition|(
operator|(
name|offset
operator|&
literal|0xff000000
operator|)
operator|==
name|tdfx_info
operator|->
name|addr0
condition|)
name|offset
operator|&=
literal|0xffffff
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|>=
literal|0x1000000
operator|)
operator|||
operator|(
name|offset
operator|<
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"tdfx: offset %x out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
comment|/* atop -> address to page 	 * rman_get_start, get the (struct resource*)->r_start member, 	 * the mapping base address. 	 */
return|return
name|atop
argument_list|(
name|rman_get_start
argument_list|(
name|tdfx_info
operator|->
name|memrange
argument_list|)
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_query_boards
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      *	This returns the number of installed tdfx cards, we have been keeping 	 * count, look at tdfx_attach  	 */
return|return
name|tdfx_count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_query_fetch
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* XXX Comment this later, after careful inspection and spring cleaning :) */
comment|/* Various return values 8bit-32bit */
name|u_int8_t
name|ret_byte
decl_stmt|;
name|u_int16_t
name|ret_word
decl_stmt|;
name|u_int32_t
name|ret_dword
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|NULL
decl_stmt|;
comment|/* This one depend on the tdfx_* structs being properly initialized */
comment|/*piod->device&= 0xf;*/
if|if
condition|(
operator|(
name|piod
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tdfx_count
operator|<=
name|piod
operator|->
name|device
operator|)
operator|||
operator|(
name|piod
operator|->
name|device
operator|<
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"tdfx: Bad device or internal struct in tdfx_query_fetch\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EINVAL
return|;
block|}
name|tdfx_info
operator|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|piod
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENXIO
return|;
comment|/* We must restrict the size reads from the port, since to high or low of a 	 * size witll result in wrong data being passed, and that's bad */
comment|/* A few of these were pulled during the attach phase */
switch|switch
condition|(
name|piod
operator|->
name|port
condition|)
block|{
case|case
name|PCI_VENDOR_ID_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
name|copyout
argument_list|(
operator|&
name|tdfx_info
operator|->
name|vendor
argument_list|,
name|piod
operator|->
name|value
argument_list|,
name|piod
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_DEVICE_ID_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
name|copyout
argument_list|(
operator|&
name|tdfx_info
operator|->
name|type
argument_list|,
name|piod
operator|->
name|value
argument_list|,
name|piod
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCI_BASE_ADDRESS_0_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|copyout
argument_list|(
operator|&
name|tdfx_info
operator|->
name|addr0
argument_list|,
name|piod
operator|->
name|value
argument_list|,
name|piod
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SST1_PCI_SPECIAL1_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|PCI_REVISION_ID_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL4_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Read the value and return */
switch|switch
condition|(
name|piod
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
name|ret_byte
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
index|[
name|piod
operator|->
name|device
index|]
operator|.
name|dev
argument_list|,
name|piod
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_byte
argument_list|,
name|piod
operator|->
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ret_word
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
index|[
name|piod
operator|->
name|device
index|]
operator|.
name|dev
argument_list|,
name|piod
operator|->
name|port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_word
argument_list|,
name|piod
operator|->
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ret_dword
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
index|[
name|piod
operator|->
name|device
index|]
operator|.
name|dev
argument_list|,
name|piod
operator|->
name|port
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_dword
argument_list|,
name|piod
operator|->
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_query_update
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* XXX Comment this later, after careful inspection and spring cleaning :) */
comment|/* Return vals */
name|u_int8_t
name|ret_byte
decl_stmt|;
name|u_int16_t
name|ret_word
decl_stmt|;
name|u_int32_t
name|ret_dword
decl_stmt|;
comment|/* Port vals, mask */
name|u_int32_t
name|retval
decl_stmt|,
name|preval
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|tdfx_softc
modifier|*
name|tdfx_info
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|piod
operator|==
name|NULL
operator|)
operator|||
operator|(
name|piod
operator|->
name|device
operator|>=
operator|(
name|tdfx_count
operator|&
literal|0xf
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"tdfx: Bad struct or device in tdfx_query_update\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EINVAL
return|;
block|}
name|tdfx_info
operator|=
operator|(
expr|struct
name|tdfx_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|tdfx_devclass
argument_list|,
name|piod
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdfx_info
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENXIO
return|;
comment|/* Code below this line in the fuction was taken from the  	 * Linux driver and converted for freebsd. */
comment|/* Check the size for all the ports, to make sure stuff doesn't get messed up 	 * by poorly written clients */
switch|switch
condition|(
name|piod
operator|->
name|port
condition|)
block|{
case|case
name|PCI_COMMAND_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL1_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL2_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL3_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|SST1_PCI_SPECIAL4_FREEBSD
case|:
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Read the current value */
name|retval
operator|=
name|pci_read_config
argument_list|(
name|tdfx_info
operator|->
name|dev
argument_list|,
name|piod
operator|->
name|port
operator|&
operator|~
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* These set up a mask to use, since apparently they wanted to write 4 bytes 	 * at once to the ports */
switch|switch
condition|(
name|piod
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|preval
operator|=
name|ret_byte
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
name|mask
operator|=
literal|0xff
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|preval
operator|=
name|ret_word
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
name|mask
operator|=
literal|0xffff
operator|<<
operator|(
literal|8
operator|*
operator|(
name|piod
operator|->
name|port
operator|&
literal|0x3
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_dword
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|preval
operator|=
name|ret_dword
expr_stmt|;
name|mask
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Finally, combine the values and write it to the port */
name|retval
operator|=
operator|(
name|retval
operator|&
operator|~
name|mask
operator|)
operator||
name|preval
expr_stmt|;
name|pci_write_config
argument_list|(
name|tdfx_info
operator|->
name|dev
argument_list|,
name|piod
operator|->
name|port
operator|&
operator|~
literal|3
argument_list|,
name|retval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_do_pio_rd
parameter_list|(
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* Return val */
name|u_int8_t
name|ret_byte
decl_stmt|;
comment|/* Restricts the access of ports other than those we use */
if|if
condition|(
operator|(
name|piod
operator|->
name|port
operator|!=
name|VGA_INPUT_STATUS_1C
operator|)
operator|||
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_INDEX
operator|)
operator|||
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_DATA
operator|)
operator|||
operator|(
name|piod
operator|->
name|port
operator|!=
name|VGA_MISC_OUTPUT_READ
operator|)
condition|)
return|return
operator|-
name|EPERM
return|;
comment|/* All VGA STATUS REGS are byte registers, size should never be> 1 */
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|1
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Write the data to the intended port */
name|ret_byte
operator|=
name|inb
argument_list|(
name|piod
operator|->
name|port
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ret_byte
argument_list|,
name|piod
operator|->
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_do_pio_wt
parameter_list|(
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* return val */
name|u_int8_t
name|ret_byte
decl_stmt|;
comment|/* Replace old switch w/ massive if(...) */
comment|/* Restricts the access of ports other than those we use */
if|if
condition|(
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_INDEX
operator|)
operator|&&
operator|(
name|piod
operator|->
name|port
operator|!=
name|SC_DATA
operator|)
operator|&&
operator|(
name|piod
operator|->
name|port
operator|!=
name|VGA_MISC_OUTPUT_READ
operator|)
condition|)
comment|/* Can't write VGA_ST_1C */
return|return
operator|-
name|EPERM
return|;
comment|/* All VGA STATUS REGS are byte registers, size should never be> 1 */
if|if
condition|(
name|piod
operator|->
name|size
operator|!=
literal|1
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Write the data to the intended port */
name|copyin
argument_list|(
name|piod
operator|->
name|value
argument_list|,
operator|&
name|ret_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|piod
operator|->
name|port
argument_list|,
name|ret_byte
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_do_query
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* There are three sub-commands to the query 0x33 */
switch|switch
condition|(
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
return|return
name|tdfx_query_boards
argument_list|()
return|;
break|break;
case|case
literal|3
case|:
return|return
name|tdfx_query_fetch
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
return|;
break|break;
case|case
literal|4
case|:
return|return
name|tdfx_query_update
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
return|;
break|break;
default|default:
comment|/* In case we are thrown a bogus sub-command! */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Bad Sub-cmd: 0x%x\n"
argument_list|,
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EINVAL
return|;
block|}
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdfx_do_pio
parameter_list|(
name|u_int
name|cmd
parameter_list|,
name|struct
name|tdfx_pio_data
modifier|*
name|piod
parameter_list|)
block|{
comment|/* Two types of PIO, INPUT and OUTPUT, as the name suggests */
switch|switch
condition|(
name|_IOC_DIR
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
case|case
name|IOCV_OUT
case|:
return|return
name|tdfx_do_pio_rd
argument_list|(
name|piod
argument_list|)
return|;
break|break;
case|case
name|IOCV_IN
case|:
return|return
name|tdfx_do_pio_wt
argument_list|(
name|piod
argument_list|)
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Calls to ioctl(2) eventually end up here. Unhandled ioctls return an ENXIO,  * normally, you would read in the data pointed to by data, then write your  * output to it. The ioctl *should* normally return zero if everything is  * alright, but 3dfx didn't make it that way...  *  * For all of the ioctl code, in the event of a real error,  * we return -Exxxx rather than simply Exxxx. The reason for this  * is that the ioctls actually RET information back to the program  * sometimes, rather than filling it in the passed structure. We  * want to distinguish errors from useful data, and maintain compatibility.  *  * There is this portion of the proc struct called p_retval[], we can store a  * return value in p->p_retval[0] and place the return value if it is positive  * in there, then we can return 0 (good). If the return value is negative, we  * can return -retval and the error should be properly handled.  */
end_comment

begin_function
specifier|static
name|int
name|tdfx_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|struct
name|tdfx_pio_data
modifier|*
name|piod
init|=
operator|(
expr|struct
name|tdfx_pio_data
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"IOCTL'd by #%d, cmd: 0x%x, data: 0x%x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|u_int32_t
operator|)
name|cmd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|piod
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|_IOC_TYPE
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
comment|/* Return the real error if negative, or simply stick the valid return 		 * in p->p_retval */
case|case
literal|0x33
case|:
comment|/* The '3'(0x33) type IOCTL is for querying the installed cards */
if|if
condition|(
operator|(
name|retval
operator|=
name|tdfx_do_query
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|retval
expr_stmt|;
else|else
return|return
operator|-
name|retval
return|;
break|break;
case|case
literal|0
case|:
comment|/* The 0 type IOCTL is for programmed I/O methods */
if|if
condition|(
operator|(
name|tdfx_do_pio
argument_list|(
name|cmd
argument_list|,
name|piod
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|retval
expr_stmt|;
else|else
return|return
operator|-
name|retval
return|;
break|break;
default|default:
comment|/* Technically, we won't reach this from linux emu, but when glide 			 * finally gets ported, watch out! */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Bad IOCTL from #%d\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TDFX_LINUX
end_ifdef

begin_comment
comment|/*  * Linux emulation IOCTL for /dev/tdfx  */
end_comment

begin_function
specifier|static
name|int
name|linux_ioctl_tdfx
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_ioctl_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_long
name|cmd
init|=
name|args
operator|->
name|cmd
operator|&
literal|0xffff
decl_stmt|;
comment|/* The structure passed to ioctl has two shorts, one int       and one void*. */
name|char
name|d_pio
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
index|]
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
init|=
name|p
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|args
operator|->
name|fd
index|]
decl_stmt|;
comment|/* We simply copy the data and send it right to ioctl */
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|arg
argument_list|,
operator|&
name|d_pio
argument_list|,
sizeof|sizeof
argument_list|(
name|d_pio
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|fo_ioctl
argument_list|(
name|fp
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|d_pio
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TDFX_LINUX */
end_comment

begin_comment
comment|/* This is the device driver struct. This is sent to the driver subsystem to  * register the method structure and the info strcut space for this particular  * instance of the driver.  */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|tdfx_driver
init|=
block|{
literal|"tdfx"
block|,
name|tdfx_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tdfx_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tell Mr. Kernel about us! */
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|tdfx
argument_list|,
name|pci
argument_list|,
name|tdfx_driver
argument_list|,
name|tdfx_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI */
end_comment

end_unit

