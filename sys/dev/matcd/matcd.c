begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*matcd.c--------------------------------------------------------------------  	Matsushita(Panasonic) / Creative CD-ROM Driver	(matcd) 	Authored by Frank Durda IV  Copyright 1994, 1995, 2002, 2003  Frank Durda IV.  All rights reserved. "FDIV" is a trademark of Frank Durda IV.  ------------------------------------------------------------------------------  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution. 3. Neither the name of the author nor the names of their contributors    may be used to endorse or promote products derived from this software    without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ------------------------------------------------------------------------------  The original version of this software was developed specifically for the FreeBSD Project.  Dedicated to:	My family, my Grandfather, 		and Max, my Golden Retriever  Thanks to:	Jordan Hubbard (jkh) for getting me ramped-up to 2.x system 		quickly enough to make the 2.1 release.  He put up with 		plenty of silly questions and might get the post of 		ambassador some day.  and 		The people who donated equipment and other material to make 		development of this driver possible.  Donations and 		sponsors for projects are appreciated.  -----No changes should be needed above this line-----------------------------  Edit History - (should be in sync with any source control log entries)  	Never seen one of these sections before?  Ok, here is how it works. 	Every time you change the code, you increment the ANSI edit number, 	that number over there in the<%d> and in the (%d) in the 	version string.  You never set this number lower than it is. 	Near, or preferably on lines that change, insert the edit 	number.  If there is a number there already, you can replace it 	with a newer one.  This makes searches for code changes very fast.  	In the edit history, start with the edit number, and a good 	description of what changes were made.  Then follow it with 	the date, your name and an EMAIL address where you can be reached.  	Please follow this practice; it helps leave understandable code in 	your wake.  	ANSI version codes have major and minor release numbers.  Major 	releases numbered 1 thru n.  Major feature additions should get a new 	major release number.  Minor releases start with a null and then 	letters A thru Z as needed.  So  3A(456) is Major release 3, Minor 	release 1, Edit 456 (the equivalent in XX.XX.XX version numbering used 	by certain monopolies would be 03.01.456), and 5(731) is Major release 	5, Minor release 0, Edit 731.  Typically only the author will change 	the major and minor release codes in small projects.  				EDIT edit Edit HISTORY history History<1>	This initial version is to get basic filesystem I/O working 	using the SoundBlaster 16 interface.  The stand-alone adapter 	card doesn't work yet. 	December 1994  Frank Durda IV	uhclem at freebsd.org<2>	Corrections to resolve a race condition when multiple drives 	on the same controller was active.  Fixed drive 1& 2 swap 	problem.  See selectdrive(). 	21-Jan-1995  Frank Durda IV	uhclem at freebsd.org<3>	Added automatic probing and support for all Creative Labs sound 	cards with the Creative/Panasonic interface and the stand-alone 	interface adapters.  See AUTOHUNT and FULLCONFIG conditionals 	for more information. 	21-Jan-1995  Frank Durda IV	uhclem at freebsd.org<4>	Rebundled debug conditionals. 	14-Feb-1995  Frank Durda IV	uhclem at freebsd.org<5>	Changes needed to work on FreeBSD 2.1.  Also added draincmd 	since some conditions cause the drive to produce surprise data. 	See setmode and draincmd 	19-Feb-1995  Frank Durda IV	uhclem at freebsd.org<6>	Got rid of some redundant error code by creating chk_error(). 	Also built a nice generic bus-lock function. 	20-Feb-1995  Frank Durda IV	uhclem at freebsd.org<7>	Improved comments, general structuring. 	Fixed a problem with disc eject not working if LOCKDRIVE was set. 	Apparently the drive will reject an EJECT command if the drive 	is LOCKED. 	21-Feb-1995  Frank Durda IV	uhclem at freebsd.org<8>	Final device name selected and actually made to compile under>2.0. For newer systems, it is "matcd", for older it is "mat". 	24-Feb-1995  Frank Durda IV	uhclem at freebsd.org<9>	Added some additional disk-related ioctl functions that didn't 	make it into earlier versions. 	26-Feb-1995  Frank Durda IV	uhclem at freebsd.org<10>	Updated some conditionals so the code will compile under 	1.1.5.1, although this is not the supported platform. 	Also found that some other devices probe code was changing the 	settings for the port 0x302 debug board, so added code to set it 	to a sane state before we use it. 	26-Feb-1995  Frank Durda IV	uhclem at freebsd.org<11>	The Copyright and Use statement has been replaced in all files 	with a new version. 	01-Mar-1995  Frank Durda IV	uhclem at freebsd.org<12>	Added ioctls having to do with audio volume, routing and playback 	speed.  Also added some code I think is for dynamic loading. 	12-Mar-1995  Frank Durda IV	uhclem at freebsd.org<13>	Added ioctls to return TOC headers and entries. 	19-Mar-1995  Frank Durda IV	uhclem at freebsd.org<14>	More ioctls to finish out general audio support and some clean-up. 	Also fixed a bug in open where CD label information would not 	always be cleared after a disc change.  	Added a check to block attempts to resume audio if already playing. 	The resulting sound is a cross between Kryten and Max Headroom. 	But, if you *want* this "feature", enable #define KRYTEN 	in options.h.  	Complaints about too many comments are noted but that is all.  :-) 	21-Mar-1995  Frank Durda IV	uhclem at freebsd.org<15>	LOCKDRIVE has been modified so that a new series of minor 	numbers are created.  When these are opened, the selected 	drive will have its door locked and the device must be completely 	closed to unlock the media.  The EJECT ioctl will be refused 	when the drive is locked this way.   This is useful for 	servers and other places where the media needs to remain in the 	drive.  Bit 7 of the minor number controls locking.  	As of this edit, the code compiles with no warnings with -Wall set. 	22-Mar-1995  Frank Durda IV	uhclem at freebsd.org<16>	Added a new check in the probe code that looks for the drive 	interface being in an idle state after issuing a reset.  If this 	isn't the case, then the device at this location isn't a 	Matsushita CD-ROM drive.  This will prevent hangs in draincmd later. 	Added the tray close ioctl.  This required modifications to open 	to allow the character devices to be "partially" opened so that 	the close ioctl could be issued when the open would otherwise fail. 	Close also delays slightly after completing because the drive 	doesn't update its disc and media status instantly. 	Also created the capability ioctl that lets an application find out 	up front what things a drive can do. 	Fixed a global spelling error. 	Changed matcddriver structure to simply say "matcd".  The original 	string "matcd interface " broke the kernel -c boot mechanism. 	Updated the #includes in response to a complaint in first release. 	Updated and tested conditionals so that driver will still compile 	under FreeBSD 1.1.5.1 as well as 2.0 and early 2.1. 	04-Apr-1995  Frank Durda IV	uhclem at freebsd.org<17>	The function matcd_toc_entries which is executed in response to 	the CDIOREADTOCENTRYS ioctl didn't cope with programs that only 	requested part of the TOC.  This change is based on code submitted 	by Doug Robson (dfr@render.com). 	(This change was introduced out of order and exists in FreeBSD 	 2.0.5 without the version stamp being updated.  I.N.M.F.) 	01-Jun-1995  Frank Durda IV	uhclem at freebsd.org<18>	While working on the TEAC CD-ROM driver (teaccd) that is reusing 	chunks of code from this driver, I discovered several functions, 	arrays and other things that should have been declared 'static'. 	These changes are necessary if the TEAC CD-ROM driver is to be 	present at the same time as matcd. 	Also fixed the residual buss vs bus symbols and strings. 	There are no functional code changes in this edit. 	02-May-1995  Frank Durda IV	uhclem at freebsd.org<19>	Creative has changed the Status port slightly in their 	sound boards based on the Vibra-16 (and probably the Vibra-16S) 	chipset.  This change masks some unused bits that were formally 	on all the time and are doing different things in this design. 	The changes are transparent to all other supported boards. 	20-Jun-1995  Frank Durda IV	uhclem at freebsd.org<20>	Code was added to detect non-Creative (SoundBlaster) host 	interfaces, and the driver will  switch to code compatible with the 	detected host interface.  This should add support for MediaVision, 	IBM, Reveal, and other compatible adapters with split 	data/status-ports.  This code allows a mix of SoundBlaster (Type 0) 	and non-SoundBlaster (Type 1) boards in the same system with no 	special configuration.  	I also updated the attach code to display the interface type and 	changed the host interface probe messages to reflect the "c" for 	controller in controller-specific messages as the existing messages 	were confusing when a second card was in place .  The kernel -c 	tables have been updated accordingly, so you now have a matcdc%d 	controller to change settings on. 	24-Jun-95  Frank Durda IV	uhclem at freebsd.org<21>	Added interface handling code in two of those "this should not 	happen" routines, draincmd and get_stat.   Since these routines are 	called by functions during probing that may not know what type 	interface is out there, the code assumes that a given adapter is 	both a type 0 and a type 1 adapter at the same time.  Plus, 	this code gets executed once in a very long time so the cost of 	assuming both host adapter types is not significant. 	04-Jul-1995  Frank Durda IV	uhclem at freebsd.org<22>	Four external interface prototypes were altered by someone else. 	I believe these changes are for making GCC and/or the linker shut-up 	when building some other part of the system since matcd already 	compiles -Wall with no warnings... 	08-Sep-1995  Frank Durda IV	uhclem at freebsd.org<23>	This change implements the ioctls for preventing media removal 	and allowing media removal. 	Currently, these calls will work according to the following rules: 			No "l" devs opened	Any "l" dev open 	CDALLOW		accepted always		rejected always 	CDPREVENT	accepted always		accepted always  	One refinement might be to allow CDALLOW/CDPREVENT to always 	work if UID 0 issued the ioctl, but that will wait for later.  	I also made a change to the information that the toc_entry code 	returns so that xcdplayer won't malfunction.  (It would not play 	the last track on a non-mixed mode audio CD.)  Unlike cdplayer, 	xcdplayer asks for track information one track at a time, and 	calls for information on the lead-out track by its official 	number (0xaa), rather than referring to the "after last" (n+1) track 	as cdplayer does.  Anyway, this change should make both players 	happy. 	16-Sep-1995  Frank Durda IV	uhclem at freebsd.org<24>	In Edit 15 when the extra devs were created for selective locking, 	the door locking was broken if a non-locking dev on the drive is 	closed.  The problem was caused by not tracking locked devs and 	non-locking devs as being different partitions.   The change is to 	simply use the locking dev bit to flag a set of shadow partitions 	when it comes to lock operations.  All other operations treat the 	locked and unlocked partitions as being identical. 	18-Sep-1995  Frank Durda IV	uhclem at freebsd.org<25>	During work on Edit 23, I noted that on slow and very busy systems, 	sometimes the driver would go to sleep forever.  The problem appears 	to have been a race condition caused by doing separate timeout/sleep 	calls without using SPL first.  The change here is to use tsleep 	which provides the equivalent of timeout/sleep timeout/tsleep if the 	last paremeter is tsleep is set to the time value that would have been 	given to timeout. 	I also fixed some duplicate location strings in the tsleep calls. 	24-Sep-1995  Frank Durda IV	uhclem at freebsd.org<26>	Moved a function declaration that generated two warnings with 	the FULLCONFIG/FULLDRIVER conditionals disabled. 	Updated the igot function so that it correctly reports limited 	functions when a sub-set driver is compiled. 	Eliminated FULLCONFIG conditional and now set controller counts 	based on the NMATCD #define produced by the config process. 	Also, disable the audio-related ioctls based on the BOOTMFS 	conditional to help make the boot floppy kernel smaller. 	18-Oct-1995  Frank Durda IV	uhclem at freebsd.org<27>	An unknown number of modifications were made by third parties 	after edit 26, but they neglected to document everything that 	was changed and why.  These are known collectively as edit 27.  	All Edit 27 changes were later discarded as part of the creation 	of Release 3, as some of the changes became incompatible with 	FreeBSD 4.x/5.x, and some broke drive operations that used to work. 	January 2003	Frank Durda IV	uhclem at freebsd.org  Begin work on Major Release 3 here<28>	Begin work on converting the code to run on FreeBSD 5.0.  This 	included making the driver into a loadable kernel module, and 	interfacing with the new port allocator scheme.  This code is not 	based off what was in 4.6, but comes from the last version I 	personally submitted to the project, thus eliminating some fluff that 	crept in over the years.  The conditionally-compiled sections for 	building on pre-FreeBSD 2.0 releases have been removed, as it was 	likely not useful to anyone anymore.  	I reclaimed Major device 46 for matcd - it was dropped from the 5.0 	"majors" file - but as of this date it has not been reassigned to 	some other device. 	10-Jan-2003  Frank Durda IV	uhclem at freebsd.org<29>	Work to adapt to the new way of passing key settings around between 	functions and calls to the driver that seems to be forced on loadable 	drivers or perhaps all drivers.  This required substantial debugging 	as the port addresses identified during probing were not reaching 	all the functions that needed that information. 	14-Jan-2003  Frank Durda IV	uhclem at freebsd.org<30>	Work continues, and matcd successfully loads and unloads itself and 	creates and cleans up its devs on repeated kldload/kldunloads. 	Notice: Because the dev_depends() kernel call for internally linking 	multiple devs to a master dev does not appear to exist prior to 5.0  	(was not present in 4.6 or 4.7 releases), the dev create/cleanup 	code may not link on older versions, not without commenting out 	parts of that section of the driver.  See matcd_attach. 	09-Feb-2003  Frank Durda IV	uhclem at freebsd.org<31>	Open() now does everything it is supposed to, and completes 	successfully.  It isn't clear if disable_intr/enable_intr is 	definitely going to prevent the drive commands from being issued 	within 10msec, but this seems to be the calls to now use in place 	of spl(7)/splx(). 	13-Feb-2003  Frank Durda IV	uhclem at freebsd.org<32>	Strategy code changed to deal with the newer mechanisms for handling 	request queues that exists in 5.0.  The driver will now mount and 	read an ISO filesystem. 	17-Feb-2003  Frank Durda IV	uhclem at freebsd.org<33>	A sweep through the code to eliminate compiler warnings.  The code now 	produces just one warning in the timeout() call, and so far this one 	evades elimination.  This edit also started to remove some now-dead 	code, unneccessary includes and debug code inserted during the 	previous two edits while trying to get basic functions working again. 	22-Feb-2003  Frank Durda IV	uhclem at freebsd.org<34>	Removal of the DIAGPORT code.  Although very useful during original 	development and for troubleshooting some problems found by others, it 	is no longer practical to keep, partly due to the way port allocation 	is now handled in FreeBSD, but mostly because of how few motherboards 	still have slots that will accomodate these diagnostic cards, most 	of which were ISA.  This presence of this code, even though ifdef-ed 	out in all earlier finished FreeBSD releases, still drove some of 	the other developers nuts for unclear reasons, but they should be 	happy now... :-) 	02-Mar-2003  Frank Durda IV	uhclem at freebsd.org<35>	Work to make the FULLDRIVER conditional build still compile.  This 	inserts the audio and special ioctls not needed to be able to perform 	simple single-session filesystem mounts, and was used to keep the 	boot floppy kernel size down.  This work was mainly just re-working 	the way our internal data was passed around between functions (See 	edit 29), and tracking down declarations that have moved from one 	include file to another.  Since all the code for talking to the 	actual drives worked previously, only the interface back to the rest 	of the kernel and calling apps needs any modernization. 	09-Mar-2003  Frank Durda IV	uhclem at freebsd.org<36>	Once work was complete on getting the FULLDRIVER audio functions 	compiling again, suddenly we could not mount filesystems anymore. 	This was eventually traced to a previously-not-performed-ioctl-call, 	now made by some other part of the kernel immediately after an open() 	call succeeds.  This ioctl reads the TOC for all tracks on the disc. 	Who is making this ioctl call (and what the answers are good for) 	is not immediately apparent.  	However, when FULLDRIVER wasn't present, this ioctl code was not 	available and the driver returned an error to the ioctl, but the mount 	succeeded anyway and the filesystem could be used with no issues. 	When the ioctl code was there (as a result of FULLDRIVER build), it 	was returning the information requested in MSF format, and this was 	confusing the caller.  	When matcd was originally written, returning MSF was all that the 	original CD audio players ever wanted, but this new mount-time 	query wants the answers in LBA format.  So the READTOC call has been 	updated to return either MSF or LBA formats.  Having implemented 	that, filesystems can be mounted again. 	16-Mar-2003  Frank Durda IV	uhclem at freebsd.org<37>	Related to Edit 36, when the various ioctls were updated to return 	the offset information that was requested in either LBA or MSF 	format, that broke the cdcontrol utility, which will request 	information (via the "stat" command) in LBA or MSF based on the last 	setting of the "set" command, but cdcontrol displays bogus results if 	LBA results are returned when cdcontrol asked for them.  An 	examination of the behavior of the IDE CD-ROM driver shows that for 	SUBQ data, the IDE driver ignores the format type in the request and 	always returns MSF format, and that seems to be what cdcontrol really 	wants, never mind what it asked for.  Subsequently, a conditional 	(SUBQRETREQUESTED) has been added which will direct the driver to 	always return MSF in response to SUBQ queries (default), or to return 	what the caller actually asked for.  This probably should not be 	activated until all other CD-ROM drivers and cdcontrol are fixed 	on this point. 	22-Mar-2003  Frank Durda IV	uhclem at freebsd.org<38>	A revisit of the compiler warning on timeout() that just refuses to go 	away.  A review of other drivers using timeout() suggests that the 	way timeout() is used within the kernel has been changed from 	traditional calling and passed parameters.  This call has no man page 	(apparently not even a reference in an include file exists) which 	makes confirmation difficult.  Further, as the timeout is not used 	predictably by the driver (sometimes needed, sometimes not), testing a 	change in this area will take some stress/duration testing. 	26-Mar-2003  Frank Durda IV	uhclem at freebsd.org<39>	Two hardware failure conditions were identified when a eight-drive, 	two controller configuration was tested.  Some types of cable 	failure are now detected and reported by the driver.  Other failure 	modes are documented here for reference: 	1.	If the firmware version string displayed during the driver 		probing process (normally of the form) "[CR-NNNN.NN]" is 		displayed as "[]", or "[          ]" indicates that two or 		more drives are jumpered with the same drive select.  This 		condition may be accompanied by other strange random messages.  	2.	A firmware Version string "[^A^A^A^A^A^A^A^A^A^A]" indicates 		that the cable used on the Matsushita drive appears to be 		an IDE cable which has a pin pulled out of it (when this is 		done, it is usually in the key position).  A fully-pinned 		cable must be used.  A cable with shorts to ground or opens 		on numerous lines can also cause this symptom.  	3.	If the driver refuses to go into Idle state, this indicates 		a bad cable OR a power-supply under-volt condition.  The 		drives appear to stay in a Data or Status phase indefinitely 		if the supply voltages are below +5 and +12 VDC.  The drive 		BUSY light may also remain lit continuously or the eject 		button may be ignored.  	The rest of this edit was more clean-up and removal of some debug 	messages. 	02-Apr-2003  Frank Durda IV	uhclem at freebsd.org<40>	Replaced Copyright text section in all files with the new revisionist 	(and vague) one currently required.  Everybody should be happy.  :-) 	03-Apr-2003  Frank Durda IV	uhclem at freebsd.org<41>	Rebuilt on a stock 5.0-RELEASE platform to look for any issues 	that crept in since the late 2002 snapshot I had been using and 	to verify functionality on a dual-processor system.  	Changed the ioctl for eject so that it would work when there was 	no media in the drive.  The way it was seemed obviously wrong, but no 	one had said anything about this behavior in all the years it has 	worked that way.  	Also discovered that some of the ioctls failed to lock the device 	prior to issuing commands, and this could cause other operations 	to that same drive to not start and hang forever.  Example, 	"strings /dev" on one process while another issues an eject.  Yes, 	the "strings" will end up getting an error, but that is what should 	happen, not having "strings" simply stop and never come back. 	18-Apr-2003  Frank Durda IV	uhclem at freebsd.org<42>	Changes to make matcd.c compile again on a 6-May-2003 pre-Beta 5.1 	cvsup, as the deck chairs continue to shift. 	o	Dropped tests for DIOCWLABEL on reads, which is now undefined. 	o	bioqdisksort() in the kernel depths changed its name from 5.0.* 	o	bounds_check_with_label() kernel call disappeared since 5.0 		with no apparent replacement.* 	o	The way the cdevsw structure is done has changed for the nth 		time.  It differs from what existed in 5.0. 	o	Dropped ioctl support for DIOCWDINFO and DIOCSDINFO. 		Although both ioctls are still defined in system include 		files, the setdisklabel() that I need to call to perform 		the ioctls has disappeared since 5.0. 	* Items marked are in the ifdef NOTEDIT42 rather than deleting 	  code that refers to kernel calls that may mysteriously return 	  in some future check-in. 	10-May-2003  Frank Durda IV	uhclem at freebsd.org  End of Edit History ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*Please match this ANSI version format: 		 		Version_d[ c](d)_dd-mmm-yyyy	*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|MATCDVERSION
index|[]
init|=
literal|"Version  3(42) 10-May-2003"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
operator|*
operator|/
specifier|static
name|char
name|MATCDCOPYRIGHT
index|[]
operator|=
literal|"Matsushita CD-ROM driver, Copr. 1994,1995,2002,2003 Frank Durda IV"
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- 	Fixed Defines - Change these values only if you are positive that 	you know what you are doing.  Values meant to be changed are in the 	file "dev/matcd/options.h". ---------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|RAW_DEVICE
value|46
end_define

begin_comment
comment|/*Major Dev number for raw device*/
end_comment

begin_define
define|#
directive|define
name|RAW_PART
value|2
end_define

begin_define
define|#
directive|define
name|TICKRES
value|10
end_define

begin_comment
comment|/*Our coarse timer resolution*/
end_comment

begin_define
define|#
directive|define
name|ISABUSKHZ
value|8330
end_define

begin_comment
comment|/*Number of IN/OUT ops on ISA/sec*/
end_comment

begin_define
define|#
directive|define
name|MAXTRKS
value|101
end_define

begin_comment
comment|/*Maximum possible tracks*/
end_comment

begin_define
define|#
directive|define
name|DRIVESPERC
value|4
end_define

begin_comment
comment|/*Max drive selects per controller*/
end_comment

begin_define
define|#
directive|define
name|TOTALDRIVES
value|NUMCTRLRS*DRIVESPERC
end_define

begin_comment
comment|/*Max possible drives*/
end_comment

begin_define
define|#
directive|define
name|MATCDBLK
value|2048
end_define

begin_comment
comment|/*Standard block size*/
end_comment

begin_define
define|#
directive|define
name|MATCDRBLK
value|2352
end_define

begin_comment
comment|/*Raw and/or DA block size*/
end_comment

begin_define
define|#
directive|define
name|MATCD_RETRYS
value|5
end_define

begin_comment
comment|/*Number of retries for read ops*/
end_comment

begin_define
define|#
directive|define
name|MATCD_READ_1
value|0x80
end_define

begin_comment
comment|/*Read state machine defines*/
end_comment

begin_define
define|#
directive|define
name|MATCD_READ_2
value|0x90
end_define

begin_comment
comment|/*Read state machine defines*/
end_comment

begin_comment
comment|/*	Bit equates for matcd_data.flags*/
end_comment

begin_define
define|#
directive|define
name|MATCDINIT
value|0x0001
end_define

begin_comment
comment|/*Probe ran on host adapter*/
end_comment

begin_define
define|#
directive|define
name|MATCDLABEL
value|0x0004
end_define

begin_comment
comment|/*Valid TOC exists*/
end_comment

begin_define
define|#
directive|define
name|MATCDLOCK
value|0x0008
end_define

begin_comment
comment|/*<15>Drive door is locked*/
end_comment

begin_define
define|#
directive|define
name|MATCDWARN
value|0x0020
end_define

begin_comment
comment|/*Have reported an open disc change*/
end_comment

begin_comment
comment|/*	Bit equates for matcd_data.partflags*/
end_comment

begin_define
define|#
directive|define
name|MATCDOPEN
value|0x0001
end_define

begin_define
define|#
directive|define
name|MATCDREADRAW
value|0x0002
end_define

begin_comment
comment|/*	Flags in the if_state array */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|BUSBUSY
value|0x01
end_define

begin_comment
comment|/*<18>Bus is already busy*/
end_comment

begin_comment
comment|/*	Error classes returned by chk_error()*/
end_comment

begin_define
define|#
directive|define
name|ERR_RETRY
value|1
end_define

begin_comment
comment|/*A retry might recover this*/
end_comment

begin_define
define|#
directive|define
name|ERR_INIT
value|2
end_define

begin_comment
comment|/*A retry certainly will get this*/
end_comment

begin_define
define|#
directive|define
name|ERR_FATAL
value|3
end_define

begin_comment
comment|/*This cannot be recovered from*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	These macros take apart the minor number and yield the 	partition, drive on controller, and controller. 	This must match the settings in /dev/MAKEDEV. ---------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|matcd_partition
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev))& 0x07)
end_define

begin_define
define|#
directive|define
name|matcd_ldrive
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x78)>> 3)
end_define

begin_define
define|#
directive|define
name|matcd_cdrive
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x18)>> 3)
end_define

begin_define
define|#
directive|define
name|matcd_controller
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x60)>> 5)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKDRIVE
end_ifdef

begin_define
define|#
directive|define
name|matcd_lockable
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x80)>> 5)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*LOCKDRIVE*/
end_comment

begin_define
define|#
directive|define
name|matcd_lockable
parameter_list|(
name|dev
parameter_list|)
value|(0);
end_define

begin_comment
comment|/*Behave like non-locking*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*LOCKDRIVE*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	Include file declarations ---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/matcd/options.h>
end_include

begin_include
include|#
directive|include
file|<dev/matcd/matcd_data.h>
end_include

begin_include
include|#
directive|include
file|<dev/matcd/matcddrv.h>
end_include

begin_include
include|#
directive|include
file|<dev/matcd/creativeif.h>
end_include

begin_comment
comment|/*--------------------------------------------------------------------------- 	Global structures and variables ---------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bio_queue_head
name|request_head
index|[
name|NUMCTRLRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<18>One queue for 							each interface*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nextcontroller
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Number of interface units probed*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|drivepresent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Drive has>0 drives found*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|iftype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Probe/Attach I/F type relay*/
end_comment

begin_struct
struct|struct
name|matcd_volinfo
block|{
name|unsigned
name|char
name|type
decl_stmt|;
comment|/*00 CD-DA or CD-ROM 					  10 CD-I 					  20 XA */
name|unsigned
name|char
name|trk_low
decl_stmt|;
comment|/*Normally 1*/
name|unsigned
name|char
name|trk_high
decl_stmt|;
comment|/*Highest track number*/
name|unsigned
name|char
name|vol_msf
index|[
literal|3
index|]
decl_stmt|;
comment|/*Size of disc in min/sec/frame*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|matcd_mbx
block|{
name|short
name|controller
decl_stmt|;
name|short
name|ldrive
decl_stmt|;
name|short
name|partition
decl_stmt|;
name|short
name|port
decl_stmt|;
name|short
name|iftype
decl_stmt|;
comment|/*<20>Host interface type*/
name|short
name|retry
decl_stmt|;
name|short
name|nblk
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|u_long
name|skip
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|p_offset
decl_stmt|;
name|short
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|matcd_data
block|{
name|device_t
name|dev
decl_stmt|;
name|dev_t
name|matcd_dev_t
decl_stmt|;
name|short
name|config
decl_stmt|;
name|short
name|drivemode
decl_stmt|;
comment|/*Last state drive was set to*/
name|short
name|flags
decl_stmt|;
name|short
name|status
decl_stmt|;
comment|/*Last audio-related function*/
name|int
name|blksize
decl_stmt|;
name|u_long
name|disksize
decl_stmt|;
name|short
name|iobase
decl_stmt|;
name|short
name|iftype
decl_stmt|;
comment|/*Host interface type*/
name|struct
name|disklabel
name|dlabel
decl_stmt|;
name|unsigned
name|int
name|partflags
index|[
name|MAXPARTITIONS
index|]
decl_stmt|;
name|unsigned
name|int
name|openflags
decl_stmt|;
name|struct
name|matcd_volinfo
name|volinfo
decl_stmt|;
name|struct
name|matcd_mbx
name|mbx
decl_stmt|;
name|u_char
name|patch
index|[
literal|2
index|]
decl_stmt|;
comment|/*Last known audio routing*/
name|u_char
name|volume
index|[
literal|2
index|]
decl_stmt|;
comment|/*Last known volume setting*/
name|struct
name|bio_queue_head
name|head
decl_stmt|;
block|}
name|matcd_data
index|[
name|TOTALDRIVES
index|]
struct|;
end_struct

begin_struct
struct|struct
name|matcd_read2
block|{
name|unsigned
name|char
name|start_msf
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|end_msf
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|if_state
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*State of host I/F and bus*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	Entry points and other connections to/from kernel - see matcd_isa.c ---------------------------------------------------------------------------*/
end_comment

begin_function_decl
name|int
name|matcd_probe
parameter_list|(
name|struct
name|matcd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|matcd_attach
parameter_list|(
name|struct
name|matcd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|ptx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|ptx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcdstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|matcdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|matcd_timeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- 	Internal function declarations ---------------------------------------------------------------------------*/
end_comment

begin_function_decl
specifier|static
name|int
name|matcdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_start
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zero_cmd
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_pread
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_fastcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_slowcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_blockread
parameter_list|(
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selectdrive
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|drive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doreset
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doprobe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|struct
name|matcd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unlockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_volinfo
parameter_list|(
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draincmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_error
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chk_error
parameter_list|(
name|int
name|errnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msf_to_blk
parameter_list|(
name|unsigned
name|char
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blk_to_msf
parameter_list|(
name|int
name|blk
parameter_list|,
name|unsigned
name|char
modifier|*
name|msf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_toc_header
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_toc_header
modifier|*
name|toc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_toc_entries
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_toc_entry
modifier|*
name|ioc_entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_read_subq
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_subchannel
modifier|*
name|sqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_igot
parameter_list|(
name|struct
name|ioc_capability
modifier|*
name|sqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|waitforit
parameter_list|(
name|int
name|timelimit
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|where
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_stat
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|media_chk
parameter_list|(
name|struct
name|matcd_data
modifier|*
name|cd
parameter_list|,
name|int
name|errnum
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|test
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_eject
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_doorclose
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_dlock
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|docmd
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_setmode
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FULLDRIVER
end_ifdef

begin_function_decl
specifier|static
name|int
name|matcd_playtracks
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_track
modifier|*
name|pt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_playmsf
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|pt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_playblk
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_blocks
modifier|*
name|pb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_pause
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_stop
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_level
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_vol
modifier|*
name|volume
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_patch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_patch
modifier|*
name|routing
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_route
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|command
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_pitch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_pitch
modifier|*
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FULLDRIVER*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	This Character Device Switch Table gives the rest of the kernel 	a list of what functions do and don't exist, and what to call to 	get them.  Read-only block devices have pretty much the same items.<42>	Apparently now you don't declare things you can't do.  You used 	to say "nowhatever it was". ---------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|matcd_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|matcdopen
block|,
comment|/* open */
operator|.
name|d_close
operator|=
name|matcdclose
block|,
comment|/* close */
operator|.
name|d_read
operator|=
name|physread
block|,
comment|/* read */
comment|/* write used to be here */
operator|.
name|d_ioctl
operator|=
name|matcdioctl
block|,
comment|/* ioctl */
operator|.
name|d_strategy
operator|=
name|matcdstrategy
block|,
comment|/* strategy */
operator|.
name|d_name
operator|=
literal|"matcd"
block|,
comment|/* name */
operator|.
name|d_maj
operator|=
name|RAW_DEVICE
block|,
comment|/* maj */
operator|.
name|d_flags
operator|=
name|D_DISK
operator||
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_attach - Locates drives on the adapters that were located. 		If we got here, we located an interface and at least one 		drive.  Now we figure out how many drives are under that 		interface.  The Panasonic interface is too simple to call 		it a controller, but in the existing PDP model, that is 		what it would be. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_attach
parameter_list|(
name|struct
name|matcd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|z
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|port
init|=
name|sc
operator|->
name|port_bsh
decl_stmt|;
comment|/*Take port ID selected in probe()*/
name|dev_t
name|d
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"matcdc%d: Host interface type %d port %x\n"
argument_list|,
name|nextcontroller
argument_list|,
name|iftype
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|cdrive
operator|=
literal|0
init|;
name|cdrive
operator|<
literal|4
condition|;
name|cdrive
operator|++
control|)
block|{
comment|/*We're hunting drives...*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*A reasonably harmless command. 					  This command will fail after 					  power-up or after reset. It's OK*/
name|unit
operator|=
name|cdrive
operator|+
operator|(
name|DRIVESPERC
operator|*
name|nextcontroller
operator|)
expr_stmt|;
if|if
condition|(
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|unit
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*Issue cmd*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*If there was an error, 						  we must ask for error info 						  or subsequent cmds fail*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READERROR
expr_stmt|;
comment|/*Inquire*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|unit
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: Status byte %x "
argument_list|,
name|unit
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READID
expr_stmt|;
comment|/*Get drive ID*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|unit
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|10
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read Drive Parm*/
name|get_stat
argument_list|(
name|port
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|data
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Build ASCIZ string*/
name|printf
argument_list|(
literal|"matcd%d: [%s]  "
argument_list|,
name|unit
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|unit
index|]
expr_stmt|;
name|cd
operator|->
name|flags
operator||=
name|MATCDINIT
expr_stmt|;
name|cd
operator|->
name|iobase
operator|=
name|port
expr_stmt|;
name|cd
operator|->
name|iftype
operator|=
name|iftype
expr_stmt|;
name|cd
operator|->
name|openflags
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|volume
index|[
literal|0
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
operator|=
name|DEFVOL
expr_stmt|;
comment|/*Match volume drive resets to*/
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/*Channel 0 to Left*/
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/*Channel 1 to Right*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_NO_STATUS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPARTITIONS
condition|;
name|i
operator|++
control|)
block|{
name|cd
operator|->
name|partflags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*	This section creates the devices files in the /dev directory for each 	drive that is found.   There must be a drive 0 on each controller in 	order to get any device files at all. */
if|if
condition|(
name|unit
operator|%
literal|4
operator|==
literal|0
condition|)
block|{
comment|/*First drive of controller*/
name|sc
operator|->
name|matcd_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
literal|8
operator|*
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"matcd%da"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*Drives 1 thru N*/
name|d
operator|=
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
literal|8
operator|*
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"matcd%da"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|sc
operator|->
name|matcd_dev_t
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
operator|(
literal|8
operator|*
name|unit
operator|)
operator|+
literal|2
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"matcd%dc"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|sc
operator|->
name|matcd_dev_t
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
operator|(
literal|8
operator|*
name|unit
operator|)
operator|+
literal|128
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"matcd%dla"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|sc
operator|->
name|matcd_dev_t
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
operator|(
literal|8
operator|*
name|unit
operator|)
operator|+
literal|130
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"matcd%dlc"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|sc
operator|->
name|matcd_dev_t
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|bioq_init
argument_list|(
operator|&
name|request_head
index|[
name|nextcontroller
index|]
argument_list|)
expr_stmt|;
comment|/*Init request queue*/
name|nextcontroller
operator|++
expr_stmt|;
comment|/*Bump ctlr assign to next number*/
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*End line of drive reports*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Must return "NO ERROR"*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdopen - Open the device  	This routine actually gets called every time anybody opens 	any partition on a drive.  But the first call is the one that 	does all the work.<15>	If LOCKDRIVE is enabled, additional minor number devices allow<15>	the drive to be locked while being accessed. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|ptx
parameter_list|)
block|{
name|int
name|cdrive
decl_stmt|,
name|ldrive
decl_stmt|,
name|partition
decl_stmt|,
name|controller
decl_stmt|,
name|lock
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|lock
operator|=
name|matcd_lockable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open: dev %x partition %x controller %x flags %x cdrive %x\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|int
operator|)
name|dev
argument_list|,
name|partition
argument_list|,
name|controller
argument_list|,
name|cd
operator|->
name|flags
argument_list|,
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDINIT
operator|)
condition|)
block|{
comment|/*Did probe find this drive*/
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|&&
name|cd
operator|->
name|openflags
condition|)
block|{
comment|/*Has drive completely closed?*/
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*No, all partitions must close*/
block|}
comment|/*	Now, test to see if the media is ready */
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*Test drive*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matopen"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d Result of NOP is %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_DSKIN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*Is there a disc in the drive?*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: No Disc in open\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLABEL
expr_stmt|;
comment|/*Mark label as invalid*/
if|if
condition|(
name|major
argument_list|(
name|dev
argument_list|)
operator|==
name|RAW_DEVICE
condition|)
block|{
comment|/*Is the char device?*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Allow Semi open*/
block|}
else|else
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*Normally blow off*/
block|}
block|}
if|if
condition|(
name|z
operator|&
name|MATCD_ST_ERROR
condition|)
block|{
comment|/*Was there an error*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Find out what it was*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d NOP Error was %x\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
name|cd
operator|->
name|openflags
condition|)
block|{
comment|/*Any parts open?*/
if|if
condition|(
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/*Was it a disc chg?*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Disc change detected i %x z %x\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Free bus lck*/
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
else|else
block|{
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Was it a disc chg?*/
comment|/*Clear volume info*/
block|}
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
comment|/*	Here we fill in the disklabel structure although most is hardcoded. */
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	Now we query the drive for the actual size of the media. 	This is where we find out if there is any media, or if the 	media isn't a Mode 1 or Mode 2/XA disc. 	See version information about Mode 2/XA support. */
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|i
operator|=
name|matcdsize
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Bus unlocked in open\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Could not read the disc size\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*matcdsize filled in rest of dlabel*/
comment|/*	Based on the results, fill in the variable entries in the disklabel */
name|cd
operator|->
name|dlabel
operator|.
name|d_secsize
operator|=
name|cd
operator|->
name|blksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_ncylinders
operator|=
operator|(
name|cd
operator|->
name|disksize
operator|/
literal|100
operator|)
operator|+
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_secperunit
operator|=
name|cd
operator|->
name|disksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|cd
operator|->
name|disksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_checksum
operator|=
name|dkcksum
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|)
expr_stmt|;
comment|/*	Now fill in the hardcoded section */
comment|/*123456789012345678*/
name|strncpy
argument_list|(
name|cd
operator|->
name|dlabel
operator|.
name|d_typename
argument_list|,
literal|"Matsushita CDR "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cd
operator|->
name|dlabel
operator|.
name|d_packname
argument_list|,
literal|"(c) 2003, fdiv "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_magic
operator|=
name|DISKMAGIC
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_magic2
operator|=
name|DISKMAGIC
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_nsectors
operator|=
literal|100
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_secpercyl
operator|=
literal|100
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_ntracks
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_interleave
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_rpm
operator|=
literal|300
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_npartitions
operator|=
literal|1
expr_stmt|;
comment|/*See note below*/
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fstype
operator|=
literal|9
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_flags
operator|=
name|D_REMOVABLE
expr_stmt|;
comment|/*	I originally considered allowing the partition to match tracks or 	sessions on the media, but since you are allowed up to 99 	tracks in the RedBook world, this would not fit in with the older 	BSD fixed partition count scheme. */
name|cd
operator|->
name|flags
operator||=
name|MATCDLABEL
expr_stmt|;
comment|/*Mark drive as having TOC*/
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d open2: partition=%d disksize=%d blksize=%x flags=%x\n"
argument_list|,
name|ldrive
argument_list|,
name|partition
argument_list|,
operator|(
name|int
operator|)
name|cd
operator|->
name|disksize
argument_list|,
name|cd
operator|->
name|blksize
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|openflags
operator|==
literal|0
operator|&&
name|lock
condition|)
block|{
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Lock drive*/
name|cmd
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
name|cd
operator|->
name|flags
operator||=
name|MATCDLOCK
expr_stmt|;
comment|/*Drive is now locked*/
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|cd
operator|->
name|openflags
operator||=
operator|(
literal|1
operator|<<
operator|(
name|partition
operator|+
name|lock
operator|)
operator|)
expr_stmt|;
comment|/*Mark partition open*/
if|if
condition|(
name|partition
operator|==
name|RAW_PART
operator|||
operator|(
name|partition
operator|<
name|cd
operator|->
name|dlabel
operator|.
name|d_npartitions
operator|&&
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
name|partition
index|]
operator|.
name|p_fstype
operator|!=
name|FS_UNUSED
operator|)
condition|)
block|{
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator||=
name|MATCDOPEN
expr_stmt|;
if|if
condition|(
name|partition
operator|==
name|RAW_PART
condition|)
block|{
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator||=
name|MATCDREADRAW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open is complete - openflags %x\n"
argument_list|,
name|ldrive
argument_list|,
name|cd
operator|->
name|openflags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open FAILED\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdclose - Close the device  	Close may not do much other than clear some driver settings. 	Note that audio playback will continue.  	If you define LOCKDRIVE, and the drive has been opened using 	one of the locking minor numbers, code in close will unlock 	the drive.  See Edit 15 in Edit History. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|ptx
parameter_list|)
block|{
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|,
name|port
decl_stmt|,
name|partition
decl_stmt|,
name|controller
decl_stmt|,
name|lock
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCKDRIVE
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|lock
operator|=
name|matcd_lockable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cd
operator|=
name|matcd_data
operator|+
name|ldrive
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Close partition=%d flags %x openflags %x partflags %x\n"
argument_list|,
name|ldrive
argument_list|,
name|partition
argument_list|,
name|cd
operator|->
name|flags
argument_list|,
name|cd
operator|->
name|openflags
argument_list|,
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDINIT
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator|&=
operator|~
operator|(
name|MATCDOPEN
operator||
name|MATCDREADRAW
operator|)
expr_stmt|;
name|cd
operator|->
name|openflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|partition
operator|+
name|lock
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|openflags
operator|==
literal|0
condition|)
block|{
comment|/*Really last close?*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLOCK
condition|)
block|{
comment|/*Was drive locked?*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Yes, so unlock it*/
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Unlock drive*/
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|cd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MATCDWARN
operator||
name|MATCDLOCK
operator|)
expr_stmt|;
comment|/*<15>*/
comment|/*Clear warning flag*/
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_probe - Search for host interface/adapters  	The probe routine hunts for the first drive on the interface since 	there is no way to locate just the adapter.   It also resets the 	entire drive chain while it is there.  matcd_attach() takes care of 	the rest of the initialization.  	The probe routine can be compiled two ways.  In AUTOHUNT mode, 	the kernel config file can say "port?" and we will check all ports 	listed in the port_hint array (see above).  	Without AUTOHUNT set, the config file must list a specific port 	address to check.  	Note that specifying the explicit addresses makes boot-up a lot 	faster.  	The probe will locate Panasonic/Creative interface on the following 	Creative adapter boards: 		#1330A	Sound Blaster PRO 		#1730	Sound Blaster 16 		#1740	Sound Blaster 16 (cost reduced) 		#2230	Sound Blaster 16 (cost reduced) 		#2770	Sound Blaster 16 Value (cost reduced) 		#1810	omniCD upgrade kit adapter card (stand-alone CD) 		#3100	PhoneBlaster SB16 + Sierra 14.4K modem combo 	Creative releases a newer and cheaper-to-make Sound Blaster 	board every few months, so by the original release date of this 	software, there are probably 8 different board models called 	Sound Blaster 16.  These include "Vibra", "Value", etc.  	Please report additional part numbers and board descriptions 	and new port numbers that work to the author.  ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_probe
parameter_list|(
name|struct
name|matcd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|y
decl_stmt|;
name|int
name|port
init|=
name|sc
operator|->
name|port_bsh
decl_stmt|;
comment|/*Obtain port number hint*/
name|cdrive
operator|=
name|nextcontroller
expr_stmt|;
comment|/*Controller defined by pass for now*/
if|if
condition|(
name|nextcontroller
operator|==
name|NUMCTRLRS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"matcdc%d: - Too many interfaces specified- adjust NMATCD\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nextcontroller
operator|==
literal|0
condition|)
block|{
comment|/*Very first time to be called*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTALDRIVES
condition|;
name|i
operator|++
control|)
block|{
name|matcd_data
index|[
name|i
index|]
operator|.
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
name|matcd_data
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|=
name|nextcontroller
operator|*
name|DRIVESPERC
expr_stmt|;
comment|/*Precompute controller offset*/
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|DRIVESPERC
condition|;
name|y
operator|++
control|)
block|{
name|matcd_data
index|[
name|i
operator|+
name|y
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"matcdc%d: In probe i %d y %d port %x\n"
argument_list|,
name|nextcontroller
argument_list|,
name|i
argument_list|,
name|y
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
ifdef|#
directive|ifdef
name|AUTOHUNT
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"matcd%d: size of port_hints %d\n"
argument_list|,
name|nextcontroller
argument_list|,
sizeof|sizeof
argument_list|(
name|port_hints
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|port_hints
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|=
name|port_hints
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"matcdc%d: Port hint %x\n"
argument_list|,
name|nextcontroller
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DOUPDATE
name|dev
operator|->
name|id_iobase
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*Put port ? back*/
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
comment|/*Nothing left to try*/
block|}
if|if
condition|(
name|port
operator|!=
literal|0
condition|)
block|{
comment|/*Untested port found*/
ifdef|#
directive|ifdef
name|DOUPDATE
name|dev
operator|->
name|id_iobase
operator|=
name|port
expr_stmt|;
endif|#
directive|endif
name|port_hints
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Don't use that port again*/
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NUMPORTS
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DOUPDATE
name|dev
operator|->
name|id_iobase
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*Put port ? back as it was*/
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
comment|/*Interface not found*/
block|}
else|else
block|{
comment|/*Config specified a port*/
name|i
operator|=
literal|0
expr_stmt|;
comment|/*so eliminate it from the hint list*/
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
comment|/*or we might try to assign it again*/
if|if
condition|(
name|port_hints
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/*End of list*/
if|if
condition|(
name|port_hints
index|[
name|i
index|]
operator|==
name|port
condition|)
block|{
name|port_hints
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Clear duplicate*/
break|break;
block|}
block|}
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|#
directive|else
comment|/*AUTOHUNT*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"matcdc%d: AUTOHUNT disabled but port? specified in config\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/*AUTOHUNT*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	doprobe - Common probe code that actually checks the ports we 		have decided to test.<20>	Edit 20 changes adds code to determine if the host interface 	is one that behaves like the Creative SoundBlaster cards, 	or whether the host interface like those used by some boards 	made by Media Vision and a version known as Lasermate. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|doprobe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|struct
name|matcd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|RESETONBOOT
name|doreset
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Reset what might be our device*/
endif|#
directive|endif
comment|/*RESETONBOOT*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Guarantee status phase*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*A reasonably harmless command. 				  	  This command will fail after 				  	  power-up or after reset. That's OK*/
ifdef|#
directive|ifdef
name|RESETONBOOT
if|if
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
operator|!=
literal|0xff
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*Something detected but it isn't 					      the device we wanted*/
endif|#
directive|endif
comment|/*RESETONBOOT*/
if|if
condition|(
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*Issue command*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Switch to Creative Data phase*/
name|i
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*Read a byte in data phase*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Switch to Creative Status phase*/
if|if
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
comment|/*Drive went idle*/
name|iftype
operator|=
literal|1
expr_stmt|;
comment|/*It is not a Creative interface.*/
block|}
else|else
block|{
comment|/*Status byte still available*/
name|iftype
operator|=
literal|0
expr_stmt|;
comment|/*It is a Creative interface*/
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"matcdc%d: Probe found something\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
comment|/*------If you change the following, it makes remote support difficult-------*/
if|if
condition|(
name|drivepresent
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Matsushita/Panasonic CD-ROM Driver by FDIV, %s\n"
argument_list|,
name|MATCDVERSION
argument_list|)
expr_stmt|;
name|drivepresent
operator|++
expr_stmt|;
if|if
condition|(
name|drivepresent
operator|==
literal|0
condition|)
comment|/*make LINT happy*/
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|MATCDCOPYRIGHT
argument_list|)
expr_stmt|;
block|}
comment|/*------If you change the preceding, it makes remote support difficult-------*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Drive 0 detected*/
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"matcdc%d: Probe DID NOT find something\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	doreset - Resets all the drives connected to a interface ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|doreset
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Reset what might be our device*/
comment|/*Although this ensures a known 					  state, it does close the drive 					  door (if open) and aborts any 					  audio playback in progress. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|125
operator|*
name|ISABUSKHZ
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/*DELAY 500msec minimum. Worst 					  case is door open and none or 					  unreadable media */
name|z
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*This makes the loop run at a 					  known speed.  This value is ok 					  for the 8.33MHz ISA bus*/
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|matcd_data
index|[
operator|(
name|cdrive
operator|*
literal|4
operator|)
operator|+
name|i
index|]
operator|.
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_fastcmd - Send a command to a drive  	This routine executed commands that return instantly (or reasonably 	quick), such as RESET, NOP, READ ERROR, etc.  The only difference 	between it and handling for slower commands, is the slower commands 	will invoke a timeout/sleep if they don't get an instant response.  	Fastcmd is mainly used in probe(), attach() and error related 	functions.  Every attempt should be made to NOT use this 	function for any command that might be executed when the system 	is up. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_fastcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|z
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|unsigned
name|char
modifier|*
name|cx
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|draincmd
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Make sure bus is really idle*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|cx
operator|=
name|cp
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: Fast Send port %x sel %d command %x %x %x %x %x %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|,
name|cdrive
argument_list|,
name|cx
index|[
literal|0
index|]
argument_list|,
name|cx
index|[
literal|1
index|]
argument_list|,
name|cx
index|[
literal|2
index|]
argument_list|,
name|cx
index|[
literal|3
index|]
argument_list|,
name|cx
index|[
literal|4
index|]
argument_list|,
name|cx
index|[
literal|5
index|]
argument_list|,
name|cx
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|selectdrive
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Enable the desired target drive*/
name|disable_intr
argument_list|()
expr_stmt|;
comment|/*----------------------------------------*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/*The seven bytes of the command*/
name|outb
argument_list|(
name|port
operator|+
name|CMD
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/*must be sent within 10msec or*/
block|}
comment|/*the drive will ignore the cmd*/
name|enable_intr
argument_list|()
expr_stmt|;
comment|/*------------------------------------------------*/
comment|/*	Now we wait a maximum of 240msec for a response.  Only in a few rare 	cases does it take this long.  If it is longer, the command in 	question should probably be slept on rather than increasing this 	timing value. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|60
operator|*
name|ISABUSKHZ
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|z
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
break|break;
block|}
comment|/*	We are now either in a data or status phase, OR we timed-out.*/
if|if
condition|(
name|z
operator|==
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Command time-out\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|z
operator|!=
name|DTEN
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	draincmd - Empty any pending data drive has to send  	Draincmd makes certain the bus is idle and throws away any  	residual data from the drive if there is any.  Called as preface 	to most commands.  Added in Edit 5.  	This was added because switching drive modes causes the drive to 	emit buffers that were meant to be sent to the D-to-A to be sent 	to the host.  See setmode. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|draincmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|i
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
return|return;
name|printf
argument_list|(
literal|"matcd%d: in draincmd: bus not idle %x %x - trying to fix\n"
argument_list|,
name|ldrive
argument_list|,
name|port
operator|+
name|STATUS
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Data present READING - "
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|i
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*Ok for Creative*/
name|inb
argument_list|(
name|port
operator|+
name|ALTDATA
argument_list|)
expr_stmt|;
comment|/*Ok for others*/
name|i
operator|++
expr_stmt|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"%d bytes read\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
block|}
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Now read status: "
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|i
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
name|z
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
comment|/*Read bus status*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"Data byte %x and status is now %x\n"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
if|if
condition|(
operator|(
name|z
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Bus not idle %x - resetting\n"
argument_list|,
name|cdrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|doreset
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	selectdrive - Swaps drive select bits  	On Creative SB/SB16/stand-alone adapters, possibly to make them 	hard to reverse engineer, the drive select signals are swapped. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|selectdrive
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|drive
parameter_list|)
block|{
switch|switch
condition|(
name|drive
condition|)
block|{
case|case
literal|0
case|:
comment|/*0x00 -> 0x00*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*0x01 -> 0x02*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/*0x02 -> 0x01*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/*0x03 -> 0x03*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE3
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	get_stat - Reads status byte  	This routine should be totally unnecessary, performing the 	task with a single line of in-line code.  However in special 	cases, the drives return blocks of data that are not associated 	with the command in question.  This appears to be at least one 	firmware error and the rest of the driver makes an effort to avoid 	triggering the fault.  However, when this situation occurs, simply 	reading and throwing-away this bogus data is faster and less 	destructive than resetting all the drives on a given controller to get 	back in sync, plus not resetting leaves the other drives unaffected. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|get_stat
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|busstat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*Read status byte, last step of cmd*/
name|busstat
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
comment|/*Get bus status - should be 0xff*/
while|while
condition|(
operator|(
name|busstat
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: get_stat: After reading status byte, bus didn't go idle %x %x %x - Check for bad cable\n"
argument_list|,
name|ldrive
argument_list|,
name|status
argument_list|,
name|busstat
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|busstat
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
operator|(
name|void
operator|)
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|port
operator|+
name|ALTDATA
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*Read the status byte again*/
name|busstat
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	zero_cmd - Initialize command buffer ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|zero_cmd
parameter_list|(
name|char
modifier|*
name|lcmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCMDSIZ
condition|;
name|lcmd
index|[
name|i
operator|++
index|]
operator|=
literal|0
control|)
empty_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_slowcmd - Issue a command to the drive  	This routine is for commands that might take a long time, such 	as a read or seek.  The caller must determine if the command 	completes instantly or schedule a poll later on. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcd_slowcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|unsigned
name|char
modifier|*
name|cx
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|draincmd
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Make sure bus is really idle*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|cx
operator|=
name|cp
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: Slow Send port %x sel %d command %x %x %x %x %x %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|,
name|cdrive
argument_list|,
name|cx
index|[
literal|0
index|]
argument_list|,
name|cx
index|[
literal|1
index|]
argument_list|,
name|cx
index|[
literal|2
index|]
argument_list|,
name|cx
index|[
literal|3
index|]
argument_list|,
name|cx
index|[
literal|4
index|]
argument_list|,
name|cx
index|[
literal|5
index|]
argument_list|,
name|cx
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|selectdrive
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Enable the desired target drive*/
if|if
condition|(
operator|*
name|cp
operator|==
name|ABORT
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
name|size
operator|=
literal|7
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
comment|/*------------------------------------------------*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|/*The seven bytes of the command*/
name|outb
argument_list|(
name|port
operator|+
name|CMD
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/*must be sent within 10msec or*/
block|}
comment|/*the drive will ignore the cmd*/
name|enable_intr
argument_list|()
expr_stmt|;
comment|/*------------------------------------------------*/
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	waitforit - Waits for a command started by slowcmd to complete. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|waitforit
parameter_list|(
name|int
name|timelimit
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|where
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: waitforit port %x timelimit %x hz %x\n"
argument_list|,
name|port
argument_list|,
name|timelimit
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
while|while
condition|(
name|i
operator|<
name|timelimit
condition|)
block|{
name|j
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|STEN
operator||
name|DTEN
operator|)
expr_stmt|;
comment|/*Read status*/
if|if
condition|(
name|j
operator|!=
operator|(
name|STEN
operator||
name|DTEN
operator|)
condition|)
break|break;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nextcontroller
argument_list|,
name|PRIBIO
argument_list|,
name|where
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: Count was %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
if|if
condition|(
name|j
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Command complete*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: Timeout!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
literal|1
operator|)
return|;
comment|/*Timeout occurred*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	lockbus - Wait for the bus on the requested driver interface 		to go idle and acquire it. 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|lockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: Requesting bus lock in lockbus, controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
while|while
condition|(
operator|(
name|if_state
index|[
name|controller
index|]
operator|&
name|BUSBUSY
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: Can't do it now - going to sleep %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|,
name|PRIBIO
argument_list|,
literal|"matlck"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|if_state
index|[
name|controller
index|]
operator||=
name|BUSBUSY
expr_stmt|;
comment|/*It's ours NOW*/
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: Bus now locked in lockbus, controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	unlockbus - Release the host interface bus we already have so 		someone else can use it. 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|unlockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|if_state
index|[
name|controller
index|]
operator|&=
operator|~
name|BUSBUSY
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: bus unlocked %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/*Wakeup other users*/
name|matcd_start
argument_list|(
operator|&
name|request_head
index|[
name|controller
index|]
argument_list|)
expr_stmt|;
comment|/*Wake up any block I/O*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	media_chk - 	Checks error for types related to media 			changes. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|media_chk
parameter_list|(
name|struct
name|matcd_data
modifier|*
name|cd
parameter_list|,
name|int
name|errnum
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|test
parameter_list|)
block|{
if|if
condition|(
name|errnum
operator|==
name|NOT_READY
operator|||
name|errnum
operator|==
name|MEDIA_CHANGED
operator|||
name|errnum
operator|==
name|HARD_RESET
operator|||
name|errnum
operator|==
name|DISC_OUT
condition|)
block|{
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLABEL
expr_stmt|;
comment|/*Mark label as invalid*/
if|if
condition|(
name|test
operator|==
literal|0
condition|)
block|{
comment|/*<14>Do warn by default*/
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDWARN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*Msg seen already?*/
name|printf
argument_list|(
literal|"matcd%d: Media changed - Further I/O aborted until device closed\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|cd
operator|->
name|flags
operator||=
name|MATCDWARN
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|errnum
operator|==
name|MODE_ERROR
condition|)
comment|/*Maybe the setting is*/
name|cd
operator|->
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
comment|/*wrong so force a reset*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	docmd - Get the bus, do the command, wait for completion, 		attempt retries, give up the bus. 		For commands that do not return data. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|docmd
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|retries
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|retries
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
block|{
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|80
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matcmd"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|=
name|chk_error
argument_list|(
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ERR_INIT
condition|)
block|{
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	get_error - Read the error that aborted a command. 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|get_error
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|errnum
decl_stmt|;
name|unsigned
name|char
name|cmd1
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|zero_cmd
argument_list|(
name|cmd1
argument_list|)
expr_stmt|;
name|cmd1
index|[
literal|0
index|]
operator|=
name|READERROR
expr_stmt|;
comment|/*Enquire*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd1
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|errnum
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Caller wants it classified*/
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Chkerror found %x on command %x addrval %x statusdata %x statusport %x\n"
argument_list|,
name|ldrive
argument_list|,
name|errnum
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|status
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
name|errnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	chk_error - Classify the error that the drive reported 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|chk_error
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
switch|switch
condition|(
name|errnum
condition|)
block|{
comment|/*	These are errors we can attempt a retry for, although the drive 	has already done so. */
case|case
name|UNRECV_ERROR
case|:
case|case
name|SEEK_ERROR
case|:
case|case
name|TRACK_ERROR
case|:
case|case
name|FOCUS_ERROR
case|:
case|case
name|CLV_ERROR
case|:
case|case
name|DATA_ERROR
case|:
case|case
name|MODE_ERROR
case|:
comment|/*Make this retryable*/
return|return
operator|(
name|ERR_RETRY
operator|)
return|;
comment|/*	These errors usually indicate the user took the media from the 	drive while the dev was open.  We will invalidate the unit 	until it closes when we see this. */
case|case
name|NOT_READY
case|:
case|case
name|MEDIA_CHANGED
case|:
case|case
name|DISC_OUT
case|:
case|case
name|HARD_RESET
case|:
return|return
operator|(
name|ERR_INIT
operator|)
return|;
comment|/*	These errors indicate the system is confused about the drive 	or media, and point to bugs in the driver or OS.  These errors 	cannot be retried since you will always get the same error.  	case	RAM_ERROR: 	case	DIAG_ERROR: 	case	CDB_ERROR: 	case	END_ADDRESS: 	case	ILLEGAL_REQ: 	case	ADDRESS_ERROR:  	They also get the same action as default, so they are commented-out 	intentionally.  A smart compiler would do the right thing and generate 	no code if not commented-out, but we don't seem to have any smart 	compilers these days. */
default|default:
return|return
operator|(
name|ERR_FATAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_pread - Read small blocks of control data from a drive ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcd_pread
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|data
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdstrategy - Accepts I/O requests from kernel for processing  	This routine accepts a read request block pointer (historically 	but somewhat inaccurately called *bp for buffer pointer). 	Various sanity checks are performed on the request. 	When we are happy with the request and the state of the device, 	the request is added to the queue of requests for the interface 	that the drive is connected to.  We support multiple interfaces 	so there are multiple queues.  Once the request is added, we 	call the matcd_start routine to start the device in case it isn't 	doing something already.   All I/O including ioctl requests 	rely on the current request starting the next one before exiting. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcdstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|bio_queue_head
modifier|*
name|dp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|controller
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Strategy: buf=0x%lx, offset#=%jx bcount=%ld\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bp
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_offset
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ldrive %x controller %x cd %lx\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
operator|||
name|bp
operator|->
name|bio_offset
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Bogus parameters received - kernel may be corrupted\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_READ
operator|)
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
block|{
comment|/*Request is zero-length - all done*/
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|NOTEDIT42
if|if
condition|(
name|matcd_partition
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
operator|!=
name|RAW_PART
condition|)
block|{
if|if
condition|(
name|bounds_check_with_label
argument_list|(
name|bp
argument_list|,
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
comment|/*NOTEDIT42*/
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*Make sure we don't get intr'ed*/
name|dp
operator|=
operator|&
name|request_head
index|[
name|controller
index|]
expr_stmt|;
comment|/*Pointer to controller queue*/
name|bioq_disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/*Add new request (bp) to queue (dp 					  and sort the requests in a way that 					  may not be ideal for CD-ROM media*/
name|matcd_start
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*Ok, with our newly sorted queue, 					  see if we can start an I/O operation 					  right now*/
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*Return priorities to normal*/
comment|/*All the BSD books say do this here, 					  but some drivers are doing it after 					  disksort, which seems dangerous.*/
return|return;
comment|/*All done*/
name|bad
label|:
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/*Request bad in some way*/
name|done
label|:
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
comment|/*Show amount of data un read*/
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/*Signal we have done all we plan to*/
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_start - Pull a request from the queue and consider doing it. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcd_start
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|partition
modifier|*
name|p
decl_stmt|;
name|int
name|part
decl_stmt|,
name|ldrive
decl_stmt|,
name|controller
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
block|{
comment|/*Nothing on this controller queue*/
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/*Wakeup any blocked*/
return|return;
comment|/* opens, ioctls, etc*/
block|}
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: In start controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|if_state
index|[
name|controller
index|]
operator|&
name|BUSBUSY
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Dropping thread in start,  controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
return|return;
block|}
name|bioq_remove
argument_list|(
operator|&
name|request_head
index|[
name|controller
index|]
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/*Delete off queue*/
comment|/*	Ok, the controller is idle (not necessarily the drive) and so 	get the command to do and issue it */
name|part
operator|=
name|matcd_partition
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|p
operator|=
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
operator|+
name|part
expr_stmt|;
name|if_state
index|[
name|controller
index|]
operator||=
name|BUSBUSY
expr_stmt|;
comment|/*Mark bus as busy*/
name|cd
operator|->
name|mbx
operator|.
name|ldrive
operator|=
name|ldrive
expr_stmt|;
comment|/*Save current logical drive*/
name|cd
operator|->
name|mbx
operator|.
name|controller
operator|=
name|controller
expr_stmt|;
comment|/*and controller*/
name|cd
operator|->
name|mbx
operator|.
name|partition
operator|=
name|part
expr_stmt|;
comment|/*and partition (2048 vs 2532)*/
name|cd
operator|->
name|mbx
operator|.
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
name|cd
operator|->
name|mbx
operator|.
name|iftype
operator|=
name|cd
operator|->
name|iftype
expr_stmt|;
comment|/*interface type*/
name|cd
operator|->
name|mbx
operator|.
name|retry
operator|=
name|MATCD_RETRYS
expr_stmt|;
comment|/*and the retry count*/
name|cd
operator|->
name|mbx
operator|.
name|bp
operator|=
name|bp
expr_stmt|;
comment|/*and the bp*/
name|cd
operator|->
name|mbx
operator|.
name|p_offset
operator|=
name|p
operator|->
name|p_offset
expr_stmt|;
comment|/*and where the data will go*/
name|matcd_blockread
argument_list|(
name|MATCD_READ_1
operator|+
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Actually start the read*/
return|return;
comment|/*Dropping thread.  matcd_blockread 					  must have scheduled a timeout or 					  we will go to sleep forever*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdioctl - Process things that aren't block reads  	In this driver, ioctls are used mainly to change 	the mode the drive is running in, play audio and other 	things that don't fit into the block read scheme of things. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|,
name|partition
decl_stmt|;
name|int
name|port
decl_stmt|,
name|controller
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|ldrive
operator|>>
literal|2
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: ioctl %lx cdrive %x parms "
argument_list|,
name|ldrive
argument_list|,
name|command
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  flags %x\n"
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
name|command
operator|==
name|CDIOCCLOSE
condition|)
block|{
comment|/*Allow close even if door open*/
return|return
operator|(
name|matcd_doorclose
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|command
operator|==
name|CDIOCEJECT
condition|)
block|{
comment|/*Allow with tray empty or full*/
return|return
operator|(
name|matcd_eject
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
condition|)
block|{
comment|/*Did we read TOC OK? on open?*/
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*then drive really isn't ready*/
block|}
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|cd
operator|->
name|dlabel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|NOTEDIT42
case|case
name|DIOCWDINFO
case|:
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
else|else
block|{
return|return
name|setdisklabel
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/*NOTEDIT42*/
case|case
name|CDIOCALLOW
case|:
return|return
operator|(
name|matcd_dlock
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|CDIOCPREVENT
case|:
return|return
operator|(
name|matcd_dlock
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|MATCDLOCK
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|FULLDRIVER
case|case
name|CDIOCPLAYTRACKS
case|:
return|return
operator|(
name|matcd_playtracks
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_track
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCPLAYMSF
case|:
return|return
operator|(
name|matcd_playmsf
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCPLAYBLOCKS
case|:
return|return
operator|(
name|matcd_playblk
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_blocks
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCRESUME
case|:
return|return
operator|(
name|matcd_pause
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|RESUME
argument_list|)
operator|)
return|;
case|case
name|CDIOCPAUSE
case|:
return|return
operator|(
name|matcd_pause
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|CDIOCSTOP
case|:
return|return
operator|(
name|matcd_stop
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|)
operator|)
return|;
case|case
name|CDIOCGETVOL
case|:
case|case
name|CDIOCSETVOL
case|:
return|return
operator|(
name|matcd_level
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
argument_list|,
name|command
argument_list|)
operator|)
return|;
case|case
name|CDIOCSETMONO
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*SRC OUT	SRC OUT*/
case|case
name|CDIOCSETSTEREO
case|:
comment|/*0 -> L	1 -> R*/
case|case
name|CDIOCSETMUTE
case|:
comment|/*0 -> NULL	1 -> NULL*/
case|case
name|CDIOCSETLEFT
case|:
comment|/*0 -> L&R	1 -> NULL*/
case|case
name|CDIOCSETRIGHT
case|:
comment|/*0 -> NULL	1 -> L&R*/
comment|/*Adjust audio routing*/
return|return
operator|(
name|matcd_route
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|command
argument_list|)
operator|)
return|;
case|case
name|CDIOCSETPATCH
case|:
return|return
operator|(
name|matcd_patch
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_patch
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCPITCH
case|:
return|return
operator|(
name|matcd_pitch
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_pitch
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCSTART
case|:
comment|/*Only reason this isn't*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*implemented is I can't find out*/
comment|/*what it should do!*/
endif|#
directive|endif
comment|/*FULLDRIVER*/
case|case
name|CDIOREADTOCHEADER
case|:
return|return
operator|(
name|matcd_toc_header
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_toc_header
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOREADTOCENTRYS
case|:
return|return
operator|(
name|matcd_toc_entries
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_read_toc_entry
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCREADSUBCHANNEL
case|:
return|return
operator|(
name|matcd_read_subq
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_read_subchannel
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCCAPABILITY
case|:
comment|/*Request drive/driver capability*/
return|return
operator|(
name|matcd_igot
argument_list|(
operator|(
expr|struct
name|ioc_capability
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCRESET
case|:
comment|/*There is no way to hard reset*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*just one drive*/
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdsize - Reports how many blocks exist on the disc. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|blksize
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|part
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|part
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|==
name|RAW_PART
condition|)
name|blksize
operator|=
name|MATCDRBLK
expr_stmt|;
comment|/*2352*/
else|else
name|blksize
operator|=
name|MATCDBLK
expr_stmt|;
comment|/*2048*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
if|if
condition|(
name|matcd_volinfo
argument_list|(
name|ldrive
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|cd
operator|->
name|blksize
operator|=
name|blksize
expr_stmt|;
name|size
operator|=
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
expr_stmt|;
name|cd
operator|->
name|disksize
operator|=
name|size
operator|*
operator|(
name|blksize
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Media size %d\n"
argument_list|,
name|ldrive
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_setmode - Configures disc to run in the desired data mode  	This routine assumes the drive is already idle.  NOTE -	Undocumented action of hardware:  If you change (or reaffirm) data 	modes with MODESELECT + BLOCKPARAM immediately after a command was 	issued that aborted a DA play operation, the drive will unexpectedly 	return 2532 bytes of data in a data phase on the first or second 	subsequent command.  	Original Symptom: drive will refuse to go idle after reading data 	and status expected for a command.  State mechanics for this are 	not fully understood. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_setmode
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
name|matcd_data
operator|+
name|ldrive
expr_stmt|;
name|retries
operator|=
literal|3
expr_stmt|;
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|drivemode
operator|==
name|mode
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Drive already set*/
block|}
comment|/*	The drive is not in the right mode, so we need to set it. */
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Set drive transfer modes*/
comment|/*	cmd[1]=BLOCKPARAM;		  BLOCKPARAM==0& cmd is zero*/
name|cmd
index|[
literal|2
index|]
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_DATA
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x08
expr_stmt|;
comment|/*2048 bytes*/
break|break;
case|case
name|MODE_USER
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x09
expr_stmt|;
comment|/*2352 bytes*/
name|cmd
index|[
literal|4
index|]
operator|=
literal|0x30
expr_stmt|;
break|break;
case|case
name|MODE_DA
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x09
expr_stmt|;
comment|/*2352 bytes*/
name|cmd
index|[
literal|4
index|]
operator|=
literal|0x30
expr_stmt|;
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|cd
operator|->
name|drivemode
operator|=
name|mode
expr_stmt|;
comment|/*Set new mode*/
return|return
operator|(
name|i
operator|)
return|;
block|}
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
block|}
name|cd
operator|->
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
comment|/*We failed*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_volinfo - Read information from disc Table of Contents ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_volinfo
parameter_list|(
name|int
name|ldrive
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|int
name|z
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|retry
operator|=
literal|10
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: In volinfo, port %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
while|while
condition|(
name|retry
operator|>
literal|0
condition|)
block|{
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READDINFO
expr_stmt|;
comment|/*Read Disc Info*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matvinf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/*THIS SHOULD NOT HAPPEN*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
name|printf
argument_list|(
literal|"matcd%d: command failed, status %x\n"
argument_list|,
name|ldrive
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|6
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Data got was %x %x %x %x %x %x   "
argument_list|,
name|ldrive
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status byte %x\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/*No Error*/
comment|/*	If media change or other error, you have to read the error data or 	the drive will reject subsequent commands. */
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAKEOUT
if|if
condition|(
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|chk_error
argument_list|(
name|i
argument_list|)
operator|==
name|ERR_FATAL
condition|)
block|{
comment|/*Should not chg here*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: command failed, status %x\n"
argument_list|,
name|ldrive
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nextcontroller
argument_list|,
name|PRIBIO
argument_list|,
literal|"matvi2"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/*<25>*/
if|if
condition|(
operator|(
operator|--
name|retry
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Retrying err was %d"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Status port %x  \n"
argument_list|,
name|ldrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
name|cd
operator|->
name|volinfo
operator|.
name|type
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|2
index|]
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|+
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|)
block|{
name|cd
operator|->
name|flags
operator||=
name|MATCDLABEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	blk_to_msf - Convert block numbers into CD disk block ids ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|blk_to_msf
parameter_list|(
name|int
name|blk
parameter_list|,
name|unsigned
name|char
modifier|*
name|msf
parameter_list|)
block|{
name|blk
operator|=
name|blk
operator|+
literal|150
expr_stmt|;
comment|/*2 seconds skip required to 					  reach ISO data*/
name|msf
index|[
literal|0
index|]
operator|=
name|blk
operator|/
literal|4500
expr_stmt|;
name|blk
operator|=
name|blk
operator|%
literal|4500
expr_stmt|;
name|msf
index|[
literal|1
index|]
operator|=
name|blk
operator|/
literal|75
expr_stmt|;
name|msf
index|[
literal|2
index|]
operator|=
name|blk
operator|%
literal|75
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	msf_to_blk - Convert CD disk block ids into block numbers ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|msf_to_blk
parameter_list|(
name|unsigned
name|char
modifier|*
name|cd
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|cd
index|[
literal|0
index|]
operator|*
literal|60
operator|)
comment|/*Convert MSF to*/
operator|+
name|cd
index|[
literal|1
index|]
operator|)
operator|*
literal|75
comment|/*Blocks minus 2*/
operator|+
name|cd
index|[
literal|2
index|]
operator|-
literal|150
operator|)
return|;
comment|/*seconds*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcd_timeout
parameter_list|(
name|void
modifier|*
name|state
parameter_list|)
block|{
name|matcd_blockread
argument_list|(
operator|(
name|int
operator|)
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_blockread - Performs actual background disc I/O operations  	This routine is handed the block number to read, issues the 	command to the drive, waits for it to complete, reads the 	data or error, retries if needed, and returns the results 	to the host. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcd_blockread
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|struct
name|matcd_mbx
modifier|*
name|mbx
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|;
name|int
name|port
decl_stmt|;
name|short
name|iftype
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|bio_queue_head
modifier|*
name|dp
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|matcd_read2
name|rbuf
decl_stmt|;
name|int
name|blknum
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|errtyp
decl_stmt|;
name|int
name|phase
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|mbx
operator|=
operator|&
name|matcd_data
index|[
name|state
operator|&
literal|0x0f
index|]
operator|.
name|mbx
expr_stmt|;
name|ldrive
operator|=
name|mbx
operator|->
name|ldrive
expr_stmt|;
comment|/*ldrive is logical drive #*/
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
comment|/*cdrive is drive # on a controller*/
name|port
operator|=
name|mbx
operator|->
name|port
expr_stmt|;
comment|/*port is base port for i/f*/
name|iftype
operator|=
name|mbx
operator|->
name|iftype
expr_stmt|;
name|bp
operator|=
name|mbx
operator|->
name|bp
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|request_head
index|[
name|mbx
operator|->
name|controller
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Show state %x cdrive %d partition %d\n"
argument_list|,
name|ldrive
argument_list|,
name|state
argument_list|,
name|cdrive
argument_list|,
name|mbx
operator|->
name|partition
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|loop
label|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Top  dp %x\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
switch|switch
condition|(
name|state
operator|&
literal|0xf0
condition|)
block|{
case|case
name|MATCD_READ_1
case|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: State 1 cd->flags %x\n"
argument_list|,
name|ldrive
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
comment|/* to check for raw/cooked mode */
if|if
condition|(
name|cd
operator|->
name|partflags
index|[
name|mbx
operator|->
name|partition
index|]
operator|&
name|MATCDREADRAW
condition|)
block|{
name|mbx
operator|->
name|sz
operator|=
name|MATCDRBLK
expr_stmt|;
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Set MODE_DA result %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
else|else
block|{
name|mbx
operator|->
name|sz
operator|=
name|cd
operator|->
name|blksize
expr_stmt|;
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Set MODE_DATA result %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
comment|/*for first block*/
ifdef|#
directive|ifdef
name|DEBUGIOPLUS
name|printf
argument_list|(
literal|"matcd%d: A mbx %x bp %x b_bcount %x sz %x\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mbx
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|bp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|bp
operator|->
name|b_bcount
argument_list|,
name|mbx
operator|->
name|sz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|mbx
operator|->
name|nblk
operator|=
operator|(
name|bp
operator|->
name|bio_bcount
operator|+
operator|(
name|mbx
operator|->
name|sz
operator|-
literal|1
operator|)
operator|)
operator|/
name|mbx
operator|->
name|sz
expr_stmt|;
name|mbx
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|nextblock
label|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: at Nextblock b_offset %jd\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|blknum
operator|=
name|bp
operator|->
name|bio_offset
operator|/
name|mbx
operator|->
name|sz
operator|+
name|mbx
operator|->
name|p_offset
operator|+
name|mbx
operator|->
name|skip
operator|/
name|mbx
operator|->
name|sz
expr_stmt|;
name|blk_to_msf
argument_list|(
name|blknum
argument_list|,
name|rbuf
operator|.
name|start_msf
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READ
expr_stmt|;
comment|/*Get drive ID*/
name|cmd
index|[
literal|1
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|0
index|]
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|1
index|]
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|2
index|]
expr_stmt|;
name|cmd
index|[
literal|6
index|]
operator|=
literal|1
expr_stmt|;
comment|/*Xfer only one block*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*	Now that we have issued the command, check immediately to 	see if data is ready.   The drive has read-ahead caching, so 	it is possible the data is already in the drive buffer.  	If the data is not ready, schedule a wakeup and later on this 	code will run again to see if the data is ready then. */
case|case
name|MATCD_READ_2
case|:
name|state
operator|=
name|MATCD_READ_2
operator|+
name|ldrive
expr_stmt|;
name|phase
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: In state 2 status %x  "
argument_list|,
name|ldrive
argument_list|,
name|phase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
operator|(
name|DTEN
operator||
name|STEN
operator|)
case|:
comment|/*DTEN==H  STEN==H*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Sleeping %x\n"
argument_list|,
name|ldrive
argument_list|,
name|MATCD_READ_2
operator|+
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|timeout
argument_list|(
name|matcd_timeout
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|MATCD_READ_2
operator|+
name|ldrive
argument_list|)
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
return|return;
case|case
name|STEN
case|:
comment|/*DTEN=L STEN=H*/
case|case
literal|0
case|:
comment|/*DTEN=L STEN=L*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Data Phase\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|addr
operator|=
name|bp
operator|->
name|bio_data
operator|+
name|mbx
operator|->
name|skip
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Xfer Addr %x  size %x"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
argument_list|,
name|mbx
operator|->
name|sz
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/*Reset read count*/
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|iftype
operator|==
literal|0
condition|)
block|{
comment|/*Creative host I/F*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
operator|*
name|addr
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Disable read*/
block|}
else|else
block|{
comment|/*Not Creative interface*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
operator|*
name|addr
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|ALTDATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Read %d bytes\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
comment|/*	Now, wait for the Status phase to arrive.   This will also 	tell us if any went wrong with the request. */
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
name|DTEN
condition|)
empty_stmt|;
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Status port %x byte %x  "
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|status
operator|&
name|MATCD_ST_ERROR
condition|)
block|{
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: %s while reading offset %jd [Soft]\n"
argument_list|,
name|ldrive
argument_list|,
name|matcderrors
index|[
name|i
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*<14>was wrong place*/
block|}
if|if
condition|(
operator|--
name|mbx
operator|->
name|nblk
operator|>
literal|0
condition|)
block|{
name|mbx
operator|->
name|skip
operator|+=
name|mbx
operator|->
name|sz
expr_stmt|;
goto|goto
name|nextblock
goto|;
comment|/*Oooooh, you flunk the course*/
block|}
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/*Signal transfer complete*/
name|unlockbus
argument_list|(
name|ldrive
operator|>>
literal|2
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
name|matcd_start
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*See if other drives have work*/
return|return;
comment|/*	Here we skipped the data phase and went directly to status. 	This indicates a hard error. */
case|case
name|DTEN
case|:
comment|/*DTEN=H STEN=L*/
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: error, status was %x\n"
argument_list|,
name|ldrive
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
comment|/*	Ok, we need more details, so read error.  This is needed to issue 	any further commands anyway */
name|errtyp
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: %s while reading offset %jd\n"
argument_list|,
name|ldrive
argument_list|,
name|matcderrors
index|[
name|errtyp
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|media_chk
argument_list|(
name|cd
argument_list|,
name|errtyp
argument_list|,
name|ldrive
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errtyp
operator|=
name|chk_error
argument_list|(
name|errtyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtyp
operator|==
name|ERR_RETRY
condition|)
block|{
comment|/*We can retry*/
comment|/*<14>this error but the drive*/
comment|/*<14>probably has already*/
if|if
condition|(
name|mbx
operator|->
name|retry
operator|--
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|MATCD_READ_1
operator|+
name|ldrive
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Attempting retry\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
goto|goto
name|loop
goto|;
block|}
block|}
block|}
comment|/* 	The other error types are either something very bad or the media 	has been removed by the user.  In both cases there is no retry 	for this call.  We will invalidate the label in both cases. */
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|ldrive
operator|>>
literal|2
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|matcd_start
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_eject - Open drive tray ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_eject
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*Get I/O port base*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLOCK
condition|)
block|{
comment|/*Drive was locked via open*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*so don't allow the eject*/
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Initialize command buffer*/
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Unlock drive*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
name|cmd
index|[
literal|0
index|]
operator|=
name|DOOROPEN
expr_stmt|;
comment|/*Open Door*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
name|cd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MATCDLABEL
operator||
name|MATCDLOCK
operator|)
expr_stmt|;
comment|/*Mark vol info invalid*/
return|return
operator|(
name|i
operator|)
return|;
comment|/*Return result we got*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_doorclose - Close drive tray<16>	Added in Edit 16 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_doorclose
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*Get I/O port base*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Initialize command buffer*/
name|cmd
index|[
literal|0
index|]
operator|=
name|DOORCLOSE
expr_stmt|;
comment|/*Open Door*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd impl lck*/
name|cd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MATCDLABEL
operator||
name|MATCDLOCK
operator|)
expr_stmt|;
comment|/*Mark vol info invalid*/
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nextcontroller
argument_list|,
name|PRIBIO
argument_list|,
literal|"matclos"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
comment|/*Return result we got*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------<23>	matcd_dlock - Honor/Reject drive tray requests ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_dlock
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*Get I/O port base*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Initialize command buffer*/
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Unlock drive*/
if|if
condition|(
name|action
condition|)
block|{
comment|/*They want to lock the door?*/
name|cd
operator|->
name|flags
operator||=
name|MATCDLOCK
expr_stmt|;
comment|/*Remember we did this*/
name|cmd
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/*Lock Door command*/
block|}
else|else
block|{
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLOCK
expr_stmt|;
comment|/*Remember we did this*/
comment|/*Unlock Door command*/
block|}
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
return|return
operator|(
name|i
operator|)
return|;
comment|/*Return result we got*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_toc_header - Return Table of Contents header to caller<13>	New for Edit 13 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_toc_header
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_toc_header
modifier|*
name|toc
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|i
operator|=
name|matcd_volinfo
argument_list|(
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Check on manual change state*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*Did media change manually*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|toc
operator|->
name|len
operator|=
name|msf_to_blk
argument_list|(
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
expr_stmt|;
comment|/*In frames*/
name|toc
operator|->
name|starting_track
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
expr_stmt|;
comment|/*1*/
name|toc
operator|->
name|ending_track
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
expr_stmt|;
comment|/*Last track*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_toc_entries - Read most/all of the TOC entries  	These entries are cached by the drive, but it might be worth 	the space investment to have the driver cache these as well. 	For a disc with 40 tracks, it means 41 command calls to get 	this information from the drive.<13>	New for Edit 13  ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_toc_entries
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_toc_entry
modifier|*
name|ioc_entry
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|cd_toc_entry
name|entries
index|[
name|MAXTRKS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|cd_toc_entry
modifier|*
name|from
decl_stmt|;
name|struct
name|cd_toc_entry
modifier|*
name|to
decl_stmt|;
name|int
name|len
decl_stmt|,
name|trk
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|char
name|lowtrk
decl_stmt|,
name|hightrk
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|lowtrk
operator|=
literal|0xff
expr_stmt|;
name|hightrk
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READTOC
expr_stmt|;
for|for
control|(
name|trk
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|-
literal|1
init|;
name|trk
operator|<
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|;
name|trk
operator|++
control|)
block|{
name|cmd
index|[
literal|2
index|]
operator|=
name|trk
operator|+
literal|1
expr_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"mats1"
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*Something went wrong*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"%d Track %d addr/ctrl %x  m:%d s:%d f:%d\n"
argument_list|,
name|trk
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|entries
index|[
name|trk
index|]
operator|.
name|control
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
comment|/*Track type*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr_type
operator|=
name|ioc_entry
operator|->
name|address_format
expr_stmt|;
comment|/*Type*/
name|entries
index|[
name|trk
index|]
operator|.
name|track
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Track #, can be Out of Order*/
if|if
condition|(
name|data
index|[
literal|2
index|]
operator|>
name|hightrk
condition|)
name|hightrk
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Determine min*/
if|if
condition|(
name|data
index|[
literal|2
index|]
operator|<
name|lowtrk
condition|)
name|lowtrk
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*and max track #*/
if|if
condition|(
name|ioc_entry
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|minute
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
comment|/*Min*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|second
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
comment|/*Sec*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|frame
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
comment|/*Frame*/
block|}
else|else
block|{
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|lba
operator|=
name|msf_to_blk
argument_list|(
operator|&
name|data
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|entries
index|[
name|trk
index|]
operator|.
name|control
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Copy from last valid track*/
name|entries
index|[
name|trk
index|]
operator|.
name|track
operator|=
literal|0xaa
expr_stmt|;
comment|/*Lead-out*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr_type
operator|=
name|ioc_entry
operator|->
name|address_format
expr_stmt|;
comment|/*Type*/
if|if
condition|(
name|ioc_entry
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
comment|/*Fill*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|minute
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
expr_stmt|;
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|second
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
expr_stmt|;
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|frame
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|lba
operator|=
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
expr_stmt|;
block|}
name|trk
operator|++
expr_stmt|;
comment|/*Bump to include leadout track*/
comment|/*	Now that we have read all the data from the drive, copy the 	array from the kernel address space into the user address space */
name|len
operator|=
name|ioc_entry
operator|->
name|data_len
expr_stmt|;
name|i
operator|=
name|ioc_entry
operator|->
name|starting_track
expr_stmt|;
comment|/*What did they want?*/
if|if
condition|(
name|i
operator|==
literal|0xaa
condition|)
name|i
operator|=
name|hightrk
operator|+
literal|1
expr_stmt|;
comment|/*Give them lead-out info*/
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|lowtrk
expr_stmt|;
comment|/*Give them lowest track found*/
name|from
operator|=
operator|&
name|entries
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|to
operator|=
name|ioc_entry
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|trk
operator|&&
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
name|to
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_subq - Read the Sub-Q packet - (where are we?)  	This call gives a snapshot state of where the optical 	pick-up is when the command is issued.<14>	New for Edit 14 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_read_subq
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_subchannel
modifier|*
name|sqp
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|cd_sub_channel_info
name|subq
decl_stmt|;
comment|/*Build result here*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
block|}
comment|/*	We only support the ioctl functions we could get information 	on, so test for the things we can do */
if|if
condition|(
name|sqp
operator|->
name|data_format
operator|!=
name|CD_CURRENT_POSITION
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READSUBQ
expr_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*	While we wait, fill in the hard-coded entries of the table.<37>	Note that cdcontrol will request the format be LBA when that 	mode is selected, but cdcontrol really wants the replies returned 	in MSF.  Sounds like a bug in cdcontrol, but always returning the 	results in MSF for SUBQ queries is what the IDE driver does, so 	that's what we will do as well.  Set SUBQRETREQUESTED when the driver 	is to return in whatever format was requested. */
ifdef|#
directive|ifdef
name|SUBQRETREQUESTED
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|data_format
operator|=
name|sqp
operator|->
name|address_format
expr_stmt|;
else|#
directive|else
comment|/*SUBQRETREQUESTED*/
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|data_format
operator|=
name|CD_MSF_FORMAT
expr_stmt|;
comment|/*Always ret MSF*/
endif|#
directive|endif
comment|/*SUBQRETREQUESTED*/
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"mats2"
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|11
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*Something went wrong*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"Subq track %d index %d adr/ctl %x  abs %d:%2d:%2d  rel %d:%2d:%2d UPC %x\n"
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|,
name|data
index|[
literal|7
index|]
argument_list|,
name|data
index|[
literal|8
index|]
argument_list|,
name|data
index|[
literal|9
index|]
argument_list|,
name|data
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
name|z
operator|&
name|MATCD_ST_AUDIOBSY
condition|)
block|{
comment|/*Drive playing or paused*/
if|if
condition|(
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_PAUSED
condition|)
block|{
comment|/*Have we issued*/
name|i
operator|=
name|cd
operator|->
name|status
expr_stmt|;
comment|/*a pause command?*/
block|}
else|else
block|{
name|i
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*No, we really are playing*/
block|}
block|}
else|else
block|{
if|if
condition|(
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_IN_PROGRESS
condition|)
block|{
comment|/*It was playing*/
name|i
operator|=
name|CD_AS_PLAY_COMPLETED
expr_stmt|;
comment|/*so it finished*/
block|}
else|else
block|{
comment|/*Any other status reported*/
name|i
operator|=
name|cd
operator|->
name|status
expr_stmt|;
comment|/*as we get it*/
block|}
block|}
name|subq
operator|.
name|header
operator|.
name|audio_status
operator|=
name|cd
operator|->
name|status
operator|=
name|i
expr_stmt|;
comment|/*Store status we selected*/
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|track_number
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|index_number
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|sqp
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
comment|/*Req MSF format*/
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|minute
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|second
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|frame
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|minute
operator|=
name|data
index|[
literal|7
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|second
operator|=
name|data
index|[
literal|8
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|frame
operator|=
name|data
index|[
literal|9
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/*Req LBA format*/
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|lba
operator|=
name|msf_to_blk
argument_list|(
operator|&
name|data
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|lba
operator|=
name|msf_to_blk
argument_list|(
operator|&
name|data
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*	Ok, now copy our nicely-built structure from the kernel address 	space into the user address space (we hope) */
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|subq
argument_list|,
name|sqp
operator|->
name|data
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_info
argument_list|)
argument_list|,
name|sqp
operator|->
name|data_len
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_igot - Like the song, report the capabilities that the 		     drive/driver has available.  	This call returns a structure of flags indicating what 	functions are available so that the application can offer 	only the functions the drive is actually capable of.<16>	New for Edit 16 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_igot
parameter_list|(
name|struct
name|ioc_capability
modifier|*
name|sqp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FULLDRIVER
name|sqp
operator|->
name|play_function
operator|=
operator|(
name|CDDOPLAYTRK
operator||
comment|/*Can play trks/indx*/
name|CDDOPLAYMSF
operator||
comment|/*Can play msf to msf*/
name|CDDOPAUSE
operator||
comment|/*Can pause playback*/
name|CDDORESUME
operator||
comment|/*Can resume playback*/
name|CDDOSTOP
operator||
comment|/*Can stop playback*/
name|CDDOPITCH
operator|)
expr_stmt|;
comment|/*Can change play pitch*/
name|sqp
operator|->
name|routing_function
operator|=
operator|(
name|CDREADVOLUME
operator||
comment|/*Can read volume*/
name|CDSETVOLUME
operator||
comment|/*Can set volume*/
name|CDSETSTEREO
operator||
comment|/*Can select stereo play*/
name|CDSETLEFT
operator||
comment|/*Can select left-only*/
name|CDSETRIGHT
operator||
comment|/*Can select right-only*/
name|CDSETMUTE
operator||
comment|/*Can mute audio*/
name|CDSETPATCH
operator|)
expr_stmt|;
comment|/*Direct patch settings*/
else|#
directive|else
comment|/*FULLDRIVER*/
name|sqp
operator|->
name|play_function
operator|=
literal|0
expr_stmt|;
comment|/*No audio capability*/
name|sqp
operator|->
name|routing_function
operator|=
literal|0
expr_stmt|;
comment|/*No audio capability*/
endif|#
directive|endif
comment|/*FULLDRIVER*/
name|sqp
operator|->
name|special_function
operator|=
operator|(
name|CDDOEJECT
operator||
comment|/*Door can be opened*/
name|CDDOCLOSE
operator||
comment|/*Door can be closed*/
name|CDDOLOCK
operator||
comment|/*Door can be locked*/
name|CDREADSUBQ
operator||
comment|/*Can read subchannel*/
name|CDREADENTRIES
operator||
comment|/*Can read TOC entries*/
name|CDREADHEADER
operator|)
expr_stmt|;
comment|/*Can read TOC*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FULLDRIVER
end_ifdef

begin_comment
comment|/*----------------------------------------------------------------------------- 	The following functions are related to the audio playback 	capabilities of the drive.   They can be omitted from the 	finished driver using the FULLDRIVER conditional.  	The full set of features the drive is capable of are currently 	not implemented but will be added in upcoming releases. -----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_playtracks - Plays one or more audio tracks -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_playtracks
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_track
modifier|*
name|pt
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|start
operator|=
name|pt
operator|->
name|start_track
expr_stmt|;
name|end
operator|=
name|pt
operator|->
name|end_track
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|1
operator|||
comment|/*Starting track valid?*/
name|end
operator|<
literal|1
operator|||
comment|/*Ending track valid?*/
name|start
operator|>
name|end
operator|||
comment|/*Start higher than end?*/
name|end
operator|>
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|)
comment|/*End track higher than disc size?*/
return|return
operator|(
name|ESPIPE
operator|)
return|;
comment|/*Track out of range*/
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
comment|/*Force drive into audio mode*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/*Not legal for this media?*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PLAYTRKS
expr_stmt|;
comment|/*Play Audio Track/Index*/
name|cmd
index|[
literal|1
index|]
operator|=
name|start
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|pt
operator|->
name|start_index
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|end
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|pt
operator|->
name|end_index
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Play track results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*<14>*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_playmsf - Plays between a range of blocks -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_playmsf
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|pt
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: playmsf %2x %2x %2x -> %2x %2x %2x\n"
argument_list|,
name|ldrive
argument_list|,
name|pt
operator|->
name|start_m
argument_list|,
name|pt
operator|->
name|start_s
argument_list|,
name|pt
operator|->
name|start_f
argument_list|,
name|pt
operator|->
name|end_m
argument_list|,
name|pt
operator|->
name|end_s
argument_list|,
name|pt
operator|->
name|end_f
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
if|if
condition|(
operator|(
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
operator|<
literal|2
operator|)
operator|||
comment|/*Must be after 0'1"75F*/
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pt
operator|->
name|start_m
argument_list|)
operator|>
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Invalid block combination\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|ESPIPE
operator|)
return|;
comment|/*Track out of range*/
block|}
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
comment|/*Force drive into audio mode*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/*Not legal for this media?*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PLAYBLOCKS
expr_stmt|;
comment|/*Play Audio Blocks*/
name|cmd
index|[
literal|1
index|]
operator|=
name|pt
operator|->
name|start_m
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|pt
operator|->
name|start_s
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|pt
operator|->
name|start_f
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|pt
operator|->
name|end_m
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
name|pt
operator|->
name|end_s
expr_stmt|;
name|cmd
index|[
literal|6
index|]
operator|=
name|pt
operator|->
name|end_f
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*<14>*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_playblk - Plays between a range of blocks -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_playblk
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_blocks
modifier|*
name|pb
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|blkstart
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|blkend
index|[
literal|3
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: playblocks %x %d\n"
argument_list|,
name|ldrive
argument_list|,
name|pb
operator|->
name|blk
argument_list|,
name|pb
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|i
operator|=
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|len
operator|<
literal|1
operator|||
comment|/*Must ask for 1 or more blks*/
name|pb
operator|->
name|blk
operator|<
literal|0
operator|||
comment|/*Must not be negative*/
name|pb
operator|->
name|blk
operator|>
name|i
operator|||
comment|/*Beyond end of disc*/
operator|(
name|pb
operator|->
name|blk
operator|+
name|pb
operator|->
name|len
operator|)
operator|>
name|i
condition|)
block|{
comment|/*Beyond end of disc*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Block request out of range\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|ESPIPE
operator|)
return|;
comment|/*Track out of range*/
block|}
name|blk_to_msf
argument_list|(
name|pb
operator|->
name|blk
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|blkstart
argument_list|)
expr_stmt|;
name|blk_to_msf
argument_list|(
name|pb
operator|->
name|blk
operator|+
name|pb
operator|->
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|blkend
argument_list|)
expr_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
comment|/*Force drive into audio mode*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/*Not legal for this media?*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PLAYBLOCKS
expr_stmt|;
comment|/*Play Audio Blocks*/
name|cmd
index|[
literal|1
index|]
operator|=
name|blkstart
index|[
literal|0
index|]
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|blkstart
index|[
literal|1
index|]
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|blkstart
index|[
literal|2
index|]
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|blkend
index|[
literal|0
index|]
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
name|blkend
index|[
literal|1
index|]
expr_stmt|;
name|cmd
index|[
literal|6
index|]
operator|=
name|blkend
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*<14>*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_pause - Pause or Resume audio playback -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_pause
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*<14>Just find out whats going on*/
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*<14>*/
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matpau"
argument_list|)
expr_stmt|;
comment|/*<25>*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<14>Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*<14>Something went wrong*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*<14>*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*<14>*/
block|}
comment|/*<14>*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_AUDIOBSY
operator|)
operator|==
literal|0
operator|&&
comment|/*<14>If drive is idle*/
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_IN_PROGRESS
condition|)
block|{
comment|/*<14>but was playing*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_COMPLETED
expr_stmt|;
comment|/*<14>then its done*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|action
condition|)
block|{
comment|/*<14>Set state for subq ioctl*/
ifndef|#
directive|ifndef
name|KRYTEN
if|if
condition|(
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_IN_PROGRESS
condition|)
block|{
comment|/*<14>Don't resume*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*<14>if already playing*/
block|}
comment|/*<14>Max Headroom sound occurs*/
endif|#
directive|endif
comment|/*KRYTEN*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*<14>to read*/
block|}
else|else
block|{
comment|/*<14>There is no way to ask the*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_PAUSED
expr_stmt|;
comment|/*<14>drive if it is paused*/
block|}
comment|/*<14>*/
name|cmd
index|[
literal|0
index|]
operator|=
name|PAUSE
expr_stmt|;
comment|/*Pause or Resume playing audio*/
name|cmd
index|[
literal|1
index|]
operator|=
name|action
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Pause / Resume results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_stop  - Stop audio playback -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_stop
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|ABORT
expr_stmt|;
comment|/*Abort playing audio*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Abort results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_COMPLETED
expr_stmt|;
comment|/*<14>the drive if it is paused*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_level - Read or set the audio levels<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_level
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_vol
modifier|*
name|level
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|5
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|CDIOCSETVOL
condition|)
block|{
comment|/*We are setting new volume settings*/
comment|/*	Here we set the volume levels.  Note that the same command 	also sets the patching (routing) of audio, so we have to rely 	on previously-stored settings to fill in these fields. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
comment|/*	Although the drive allows a left and right channel volume to be 	specified separately, the drive refuses the settings if the 	values are different. */
name|c
operator|=
name|level
operator|->
name|vol
index|[
literal|0
index|]
operator||
name|level
operator|->
name|vol
index|[
literal|1
index|]
expr_stmt|;
comment|/*Or them together*/
name|cmd
index|[
literal|4
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/*Channel 0 (Left) volume*/
name|cmd
index|[
literal|6
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
comment|/*Channel 1 (Right) volume*/
name|cmd
index|[
literal|3
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|0
index|]
expr_stmt|;
comment|/*Channel 0 (Left)  patching*/
name|cmd
index|[
literal|5
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 1 (Right)  patching*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Volume set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
else|else
block|{
comment|/*Read existing settings*/
comment|/*	This code reads the settings for the drive back - note that 	volume and patching are both returned so we have to keep 	both internally. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESENSE
expr_stmt|;
comment|/*Read drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matlvl"
argument_list|)
expr_stmt|;
comment|/*<25>*/
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|5
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Data got was %x %x %x %x %x   "
argument_list|,
name|ldrive
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status byte %x\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|cd
operator|->
name|volume
index|[
literal|0
index|]
operator|=
name|level
operator|->
name|vol
index|[
literal|0
index|]
operator|=
comment|/*Channel 0 (Left) volume*/
name|data
index|[
literal|2
index|]
expr_stmt|;
name|cd
operator|->
name|volume
index|[
literal|1
index|]
operator|=
name|level
operator|->
name|vol
index|[
literal|1
index|]
operator|=
comment|/*Channel 1 (Right) volume*/
name|data
index|[
literal|4
index|]
expr_stmt|;
name|level
operator|->
name|vol
index|[
literal|2
index|]
operator|=
name|level
operator|->
name|vol
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Channel 2& 3 not avail*/
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 0 (Left) patching*/
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
comment|/*Channel 1 (Right) patching*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_routing - Set the audio routing (patching)<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_route
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|command
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|l
decl_stmt|,
name|r
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|CDIOCSETMUTE
case|:
name|l
operator|=
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CDIOCSETLEFT
case|:
name|l
operator|=
name|r
operator|=
name|OUTLEFT
expr_stmt|;
break|break;
case|case
name|CDIOCSETRIGHT
case|:
name|l
operator|=
name|r
operator|=
name|OUTRIGHT
expr_stmt|;
break|break;
default|default:
case|case
name|CDIOCSETSTEREO
case|:
name|l
operator|=
name|OUTLEFT
expr_stmt|;
name|r
operator|=
name|OUTRIGHT
expr_stmt|;
break|break;
block|}
comment|/*	Here we set the volume levels.  Note that the same command 	also sets the patching (routing) of audio, so we have to rely 	on previously-stored settings to fill in these fields. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
comment|/*	Although the drive allows a left and right channel volume to be 	specified separately, the drive refuses the settings if the 	values are different. */
name|cmd
index|[
literal|4
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|0
index|]
expr_stmt|;
comment|/*Channel 0 (Left) volume*/
name|cmd
index|[
literal|6
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 1 (Right) volume*/
name|cmd
index|[
literal|3
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
name|l
expr_stmt|;
comment|/*Channel 0 (Left)  patching*/
name|cmd
index|[
literal|5
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
name|r
expr_stmt|;
comment|/*Channel 1 (Right)  patching*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Routing set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_patch - Set the audio routing (patching)<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_patch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_patch
modifier|*
name|routing
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*	Here we set the volume levels.  Note that the same command 	also sets the patching (routing) of audio, so we have to rely 	on previously-stored settings to fill in these fields. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
comment|/*	Although the drive allows a left and right channel volume to be 	specified separately, the drive refuses the settings if the 	values are different. */
name|cmd
index|[
literal|4
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|0
index|]
expr_stmt|;
comment|/*Channel 0 (Left) volume*/
name|cmd
index|[
literal|6
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 1 (Right) volume*/
name|cmd
index|[
literal|3
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
comment|/*Channel 0 (Left)  patching*/
operator|(
name|routing
operator|->
name|patch
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
comment|/*Channel 1 (Right)  patching*/
operator|(
name|routing
operator|->
name|patch
index|[
literal|1
index|]
operator|&
literal|0x03
operator|)
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Routing set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_pitch - Change audio playback rate 		      Apart from making things sound funny, the only 		      other application might be Karaoke.  Ugh.<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_pitch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_pitch
modifier|*
name|speed
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|short
name|i
decl_stmt|;
name|int
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*	This function sets the audio playback rate.  In SCSI devices this is 	referred to as the logical block addresses per second parameter. 	Uh huh.  Sounds like they didn't want anyone to find it. 	Anyway, a study found that no one else has implemented this ioctl 	but the capability does exist in the SCSI standard so I am following 	the SCSI scheme even though it really doesn't fit this drive well.  	I originally defined the parameter to this ioctl as -32767 to -1 	being "play slower", 0x0000 flat and 1 to 32767 being "play faster" 	within the scale allowed by the device.  The value is scaled to fit 	the range allowed by the device and any excess is treated as being 	the positive or negative limit.  No ioctl input pitch value is 	considered invalid.  	This device has a +/- 13% playback pitch specified by a range 	-130 to +130.  The drive does a hard enforcement on this.  	SCSI defines a 16 bit LBAS count, and a "multiplier" that 	is either x1 or x(1/256).  The Matsushita drive only provides 	10 bits total for indicating pitch so the LSbits are discarded. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|SPEEDPARM
expr_stmt|;
comment|/*Audio speed settings*/
name|i
operator|=
name|speed
operator|->
name|speed
operator|>>
literal|7
expr_stmt|;
comment|/*Scale down to our usable range*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/*Real pitch value*/
if|if
condition|(
name|i
operator|<
operator|-
literal|130
condition|)
name|i
operator|=
operator|-
literal|130
expr_stmt|;
comment|/*Force into range we support*/
elseif|else
if|if
condition|(
name|i
operator|>
literal|130
condition|)
name|i
operator|=
literal|130
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0x03
operator|)
operator||
literal|0x04
expr_stmt|;
comment|/*Get upper bits*/
name|cmd
index|[
literal|4
index|]
operator|=
operator|(
name|i
operator|&
literal|0xff
operator|)
expr_stmt|;
comment|/*Set lower bits*/
block|}
name|z
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Pitch set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FULLDRIVER*/
end_comment

begin_comment
comment|/*End of matcd.c*/
end_comment

end_unit

