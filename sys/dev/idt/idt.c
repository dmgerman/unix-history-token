begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000, 2001 Richard Hodges and Matriplex, inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *	notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *	notice, this list of conditions and the following disclaimer in the  *	documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *	must display the following acknowledgement:  *	This product includes software developed by Matriplex, inc.  * 4. The name of the author may not be used to endorse or promote products  *	derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  ******************************************************************************  *  * This driver is derived from the Nicstar driver by Mark Tinguely, and  * some of the original driver still exists here.  Those portions are...  *   Copyright (c) 1996, 1997, 1998, 1999 Mark Tinguely  *   All rights reserved.  *  ******************************************************************************  *  *  This driver supports the Fore LE155, LE25, and IDT 77211 cards.  *  *  ATM CBR connections are supported, and bandwidth is allocated in  *  slots of 64k each.  Three VBR queues handle traffic for VBR and  *  UBR.  Two UBR queues prioritize UBR traffic.  ILMI and signalling  *  get the higher priority queue, as well as UBR traffic that specifies  *  a peak cell rate.  All other UBR traffic goes into the lower queue.  *  ******************************************************************************  *  *  The following sysctl variables are used:  *  * hw.idt.log_bufstat  (0)   Log free buffers (every few minutes)  * hw.idt.log_vcs      (0)   Log VC opens, closes, and other events  * hw.idt.bufs_large  (100)  Max/target number of free 2k buffers  * hw.idt.bufs_small  (200)  Max/target number of free mbufs  * hw.idt.cur_large   (R/O)  Current number of free 2k buffers  * hw.idt.cur_small   (R/O)  Current number of free mbufs  * hw.idt.qptr_hold    (1)   Optimize TX queue buffer for lowest overhead  *  * Note that the read-only buffer counts will not work with multiple cards.  *  ******************************************************************************  *  *  Assumptions:  *  *  1.  All mbuf clusters are 2048 bytes, and aligned.  *  2.  All mbufs are 256 bytes, and aligned (see idt_intr_tsq).  *  *  Bugs:  *  *  1.  Function idt_detach() is unusuable because idt_release_mem() is  *      incomplete.  The mbufs held in the free buffer queues can be  *      recovered from the "mcheck" hash table.  *  2.  The memory allocation could be cleaned up quite a bit.  *  ******************************************************************************  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* bootverbose */
end_comment

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_if
if|#
directive|if
name|MCLBYTES
operator|!=
literal|2048
end_if

begin_error
error|#
directive|error
literal|"This nicstar driver depends on 2048 byte mbuf clusters."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<dev/idt/idtreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/idt/idtvar.h>
end_include

begin_define
define|#
directive|define
name|MAXCARDS
value|10
end_define

begin_comment
comment|/* set to impossibly high */
end_comment

begin_comment
comment|/******************************************************************************  *  *  You may change IDT_LBUFS and IDT_SBUFS if you wish.  */
end_comment

begin_define
define|#
directive|define
name|NICSTAR_LRG_SIZE
value|2048
end_define

begin_comment
comment|/* must be power of two */
end_comment

begin_define
define|#
directive|define
name|IDT_LBUFS
value|100
end_define

begin_comment
comment|/* default number of 2k buffers */
end_comment

begin_define
define|#
directive|define
name|IDT_SBUFS
value|200
end_define

begin_comment
comment|/* default number of 96-byte buffers */
end_comment

begin_define
define|#
directive|define
name|IDT_TST_START
value|0x1c000
end_define

begin_comment
comment|/* transmit schedule table start */
end_comment

begin_define
define|#
directive|define
name|IDT_SCD_START
value|0x1d000
end_define

begin_comment
comment|/* segmentation channel descriptors start */
end_comment

begin_define
define|#
directive|define
name|IDT_SCD_SIZE
value|509
end_define

begin_comment
comment|/* max number of SCD entries */
end_comment

begin_define
define|#
directive|define
name|NICSTAR_FIXPAGES
value|10
end_define

begin_decl_stmt
specifier|static
name|int
name|idt_sysctl_logbufs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* periodic buffer status messages */
end_comment

begin_decl_stmt
name|int
name|idt_sysctl_logvcs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log VC open& close events      */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idt_sysctl_buflarge
init|=
name|IDT_LBUFS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* desired large buffer queue */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idt_sysctl_bufsmall
init|=
name|IDT_SBUFS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* desired small buffer queue */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idt_sysctl_curlarge
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current large buffer queue */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idt_sysctl_cursmall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current small buffer queue */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idt_sysctl_qptrhold
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hold TX queue pointer back */
end_comment

begin_decl_stmt
name|int
name|idt_sysctl_vbriscbr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use CBR slots for VBR VC's */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|idt
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"IDT Nicstar"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|log_bufstat
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idt_sysctl_logbufs
argument_list|,
literal|0
argument_list|,
literal|"Log buffer status"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|log_vcs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idt_sysctl_logvcs
argument_list|,
literal|0
argument_list|,
literal|"Log VC open/close"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|bufs_large
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idt_sysctl_buflarge
argument_list|,
name|IDT_LBUFS
argument_list|,
literal|"Large buffer queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|bufs_small
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idt_sysctl_bufsmall
argument_list|,
name|IDT_SBUFS
argument_list|,
literal|"Small buffer queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|cur_large
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|idt_sysctl_curlarge
argument_list|,
literal|0
argument_list|,
literal|"Current large queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|cur_small
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|idt_sysctl_cursmall
argument_list|,
literal|0
argument_list|,
literal|"Current small queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|qptr_hold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idt_sysctl_qptrhold
argument_list|,
literal|1
argument_list|,
literal|"Optimize TX queue ptr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_idt
argument_list|,
name|OID_AUTO
argument_list|,
name|vbr_is_cbr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idt_sysctl_vbriscbr
argument_list|,
literal|0
argument_list|,
literal|"Use CBR for VBR VC's"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/******************************************************************************  *  * common VCI values  *  * 0/0  Idle cells  * 0/1  Meta signalling  * x/1  Meta signalling  * 0/2  Broadcast signalling  * x/2  Broadcast signalling  * x/3  Segment OAM F4 flow  * x/4  End-end OAM F4 flow  * 0/5  p-p signalling  * x/5  p-p signalling  * x/6  rate management  * 0/14 SPANS  * 0/15 SPANS  * 0/16 ILMI  * 0/18 PNNI  */
end_comment

begin_comment
comment|/*******************************************************************************  *  *  fixbuf memory map:  *  *  0000 - 1fff:  TSQ  Transmit status queue 1024 entries *  8 bytes each  *  2000 - 3fff:  RSQ  Receive status queue,  512 entries * 16 bytes each  *  4000 - 5fff:  VBR  segmentation channel queue (highest priority)  *  6000 - 7fff:  ABR  segmentation channel queue (middle priority)  *  8000 - 9fff:  UBR  segmentation channel queue (lowest priority)  *  *  IDT device memory map:  *  *  1fc00:  RX large buffer queue (4k)  *  1f800:  RX small buffer queue (4k)  *  1e800:  RX cells FIFO (16k)  *  1e7f4:  SCD0 - VBR (12)  *  1e7e8:  SCD1 - ABR (12)  *  1e7dc:  SCD2 - UBR (12)  *  1e7db:  CBR SCD end (last word)  *  1d000:  CBR SCD start (509 entries)  *  1cfff:  TST end (4095 available slots)  *  1c000:  TST start (first CBR slot)  *  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|idt_found
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------- buffer management -------- */
end_comment

begin_function_decl
specifier|static
name|int
name|nicstar_sram_wr
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicstar_sram_rd
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
parameter_list|,
name|u_long
parameter_list|,
name|u_long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicstar_add_buf
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicstar_util_rd
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
parameter_list|,
name|u_long
parameter_list|,
name|u_long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicstar_util_wr
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|nicstar_ld_rcv_buf
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -------- interface routines -------- */
end_comment

begin_function_decl
name|int
name|nicstar_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|nicstar_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -------- VCC open/close routines -------- */
end_comment

begin_function_decl
specifier|static
name|void
name|nicstar_itrx
parameter_list|(
name|nicstar_reg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -------- receiving routines -------- */
end_comment

begin_function_decl
specifier|static
name|void
name|nicstar_rawc
parameter_list|(
name|nicstar_reg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicstar_recv
parameter_list|(
name|nicstar_reg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicstar_phys
parameter_list|(
name|nicstar_reg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  *  New functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|idt_buffer_init
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|idt_mbufcl_get
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_connect_init
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idt_connect_newvbr
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idt_intr_tsq
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|idt_malloc_contig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_mbuf_align
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_mbuf_append4
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|idt_mbuf_copy
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_mbuf_prepend
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_mbuf_used
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_mcheck_add
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_mcheck_rem
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_mcheck_init
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_queue_flush
parameter_list|(
name|CONNECTION
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|idt_queue_get
parameter_list|(
name|TX_QUEUE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_queue_init
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_queue_put
parameter_list|(
name|CONNECTION
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_receive_aal5
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idt_transmit_drop
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idt_transmit_top
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|TX_QUEUE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_slots_add
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|TX_QUEUE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_slots_init
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_slots_rem
parameter_list|(
name|IDT
modifier|*
parameter_list|,
name|TX_QUEUE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_phys_detect
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idt_status_bufs
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idt_status_wait
parameter_list|(
name|IDT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************  *  *  VBR queue divisor table  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|vbr_div_m
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|6
block|,
literal|5
block|,
literal|1
block|,
literal|5
block|,
literal|4
block|,
literal|6
block|,
literal|2
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|4
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|2
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|2
block|,
literal|3
block|,
literal|6
block|,
literal|1
block|,
literal|6
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|1
block|,
literal|7
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|7
block|,
literal|1
block|,
literal|7
block|,
literal|5
block|,
literal|7
block|,
literal|5
block|,
literal|2
block|,
literal|7
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|4
block|,
literal|7
block|,
literal|5
block|,
literal|7
block|,
literal|2
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|5
block|,
literal|4
block|,
literal|7
block|,
literal|3
block|,
literal|7
block|,
literal|2
block|,
literal|7
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|4
block|,
literal|7
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|2
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|7
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|7
block|,
literal|7
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|7
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|vbr_div_n
index|[]
init|=
block|{
literal|127
block|,
literal|127
block|,
literal|127
block|,
literal|127
block|,
literal|127
block|,
literal|127
block|,
literal|127
block|,
literal|127
block|,
literal|125
block|,
literal|111
block|,
literal|100
block|,
literal|91
block|,
literal|83
block|,
literal|77
block|,
literal|71
block|,
literal|67
block|,
literal|125
block|,
literal|59
block|,
literal|111
block|,
literal|105
block|,
literal|50
block|,
literal|95
block|,
literal|91
block|,
literal|87
block|,
literal|125
block|,
literal|40
block|,
literal|77
block|,
literal|37
block|,
literal|107
block|,
literal|69
block|,
literal|100
block|,
literal|97
block|,
literal|125
block|,
literal|91
block|,
literal|88
block|,
literal|57
block|,
literal|111
block|,
literal|27
block|,
literal|79
block|,
literal|77
block|,
literal|25
block|,
literal|122
block|,
literal|119
block|,
literal|93
block|,
literal|91
block|,
literal|111
block|,
literal|87
block|,
literal|85
block|,
literal|125
block|,
literal|102
block|,
literal|20
block|,
literal|98
block|,
literal|77
block|,
literal|113
block|,
literal|37
block|,
literal|109
block|,
literal|125
block|,
literal|123
block|,
literal|69
block|,
literal|17
block|,
literal|50
block|,
literal|82
block|,
literal|113
block|,
literal|111
block|,
literal|78
block|,
literal|77
block|,
literal|106
block|,
literal|104
block|,
literal|103
block|,
literal|29
block|,
literal|100
block|,
literal|99
block|,
literal|97
block|,
literal|96
block|,
literal|27
block|,
literal|40
block|,
literal|79
block|,
literal|13
block|,
literal|77
block|,
literal|38
block|,
literal|25
block|,
literal|37
block|,
literal|61
block|,
literal|12
block|,
literal|83
block|,
literal|47
block|,
literal|58
block|,
literal|23
block|,
literal|34
block|,
literal|45
block|,
literal|78
block|,
literal|11
block|,
literal|76
block|,
literal|43
block|,
literal|32
block|,
literal|21
block|,
literal|73
block|,
literal|72
block|,
literal|51
block|,
literal|71
block|,
literal|10
block|,
literal|69
block|,
literal|49
block|,
literal|68
block|,
literal|48
block|,
literal|19
block|,
literal|66
block|,
literal|28
block|,
literal|37
block|,
literal|55
block|,
literal|64
block|,
literal|9
block|,
literal|9
block|,
literal|62
block|,
literal|35
block|,
literal|61
block|,
literal|43
block|,
literal|60
block|,
literal|17
block|,
literal|42
block|,
literal|25
block|,
literal|33
block|,
literal|41
block|,
literal|57
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|55
block|,
literal|39
block|,
literal|31
block|,
literal|54
block|,
literal|23
block|,
literal|53
block|,
literal|15
block|,
literal|52
block|,
literal|37
block|,
literal|22
block|,
literal|51
block|,
literal|29
block|,
literal|36
block|,
literal|50
block|,
literal|50
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|48
block|,
literal|48
block|,
literal|34
block|,
literal|27
block|,
literal|47
block|,
literal|20
block|,
literal|33
block|,
literal|46
block|,
literal|46
block|,
literal|13
block|,
literal|45
block|,
literal|32
block|,
literal|32
block|,
literal|19
block|,
literal|44
block|,
literal|25
block|,
literal|31
block|,
literal|37
block|,
literal|43
block|,
literal|43
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|41
block|,
literal|41
block|,
literal|41
block|,
literal|29
block|,
literal|29
block|,
literal|23
block|,
literal|40
block|,
literal|17
block|,
literal|17
block|,
literal|28
block|,
literal|28
block|,
literal|39
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|38
block|,
literal|27
block|,
literal|27
block|,
literal|16
block|,
literal|16
block|,
literal|37
block|,
literal|21
block|,
literal|21
block|,
literal|26
block|,
literal|31
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|34
block|,
literal|34
block|,
literal|34
block|,
literal|34
block|,
literal|29
block|,
literal|24
block|,
literal|24
block|,
literal|19
block|,
literal|19
block|,
literal|33
block|,
literal|33
block|,
literal|14
block|,
literal|14
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|32
block|,
literal|32
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|31
block|,
literal|31
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|30
block|,
literal|30
block|,
literal|17
block|,
literal|17
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|25
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|23
block|,
literal|23
block|,
literal|19
block|,
literal|19
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|26
block|,
literal|26
block|,
literal|26
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|19
block|,
literal|19
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  *  *  Stop the device (shutdown)  *  *  in:  IDT device  *  * Date first: 11/14/2000  last: 11/14/2000  */
end_comment

begin_function
name|void
name|idt_device_stop
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|u_long
name|val
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
operator|*
operator|(
name|idt
operator|->
name|reg_cfg
operator|)
operator|=
literal|0x80000000
expr_stmt|;
comment|/* put chip into reset */
name|val
operator|=
operator|*
operator|(
name|idt
operator|->
name|reg_gp
operator|)
expr_stmt|;
comment|/* wait... */
name|val
operator||=
operator|*
operator|(
name|idt
operator|->
name|reg_gp
operator|)
expr_stmt|;
comment|/* wait... */
name|val
operator||=
operator|*
operator|(
name|idt
operator|->
name|reg_gp
operator|)
expr_stmt|;
comment|/* wait... */
operator|*
operator|(
name|idt
operator|->
name|reg_cfg
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* out of reset */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Initialize the hardware  */
end_comment

begin_function
name|void
name|phys_init
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|NICSTAR_TESTSRAM
name|u_long
name|z
decl_stmt|,
name|s2
decl_stmt|,
name|bad
decl_stmt|;
endif|#
directive|endif
name|u_long
name|x
decl_stmt|,
name|s1
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|regCFG
init|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGCFG
operator|)
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|regGP
init|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGGP
operator|)
decl_stmt|;
specifier|volatile
name|u_long
name|stat_val
decl_stmt|;
comment|/* clean status bits */
name|stat_val
operator|=
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|idt
operator|->
name|stat_reg
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|idt
operator|->
name|stat_reg
operator|=
name|stat_val
operator||
literal|0xcc30
expr_stmt|;
comment|/* clear ints */
name|idt
operator|->
name|flg_le25
operator|=
literal|0
expr_stmt|;
comment|/* is this FORE LE25 with 77105 PHY? */
name|idt
operator|->
name|flg_igcrc
operator|=
literal|0
expr_stmt|;
comment|/* ignore receive CRC errors? */
name|idt
operator|->
name|hardware
operator|=
literal|"?"
expr_stmt|;
comment|/* start signalling SAR reset */
operator|*
name|regCFG
operator|=
literal|0x80000000
expr_stmt|;
comment|/* SAR reset--clear occurs at lease 2 PCI cycles after setting */
name|t
operator|=
operator|*
name|regGP
expr_stmt|;
comment|/* wait */
name|t
operator|=
operator|*
name|regCFG
expr_stmt|;
operator|*
name|regCFG
operator|=
literal|0
expr_stmt|;
comment|/* clear reset */
operator|*
name|regGP
operator|=
literal|0x00000000
expr_stmt|;
comment|/* clear PHYS reset */
operator|*
name|regGP
operator|=
literal|0x00000008
expr_stmt|;
comment|/* start PHYS reset */
name|t
operator|=
operator|*
name|regGP
expr_stmt|;
comment|/* wait */
name|t
operator|=
operator|*
name|regCFG
expr_stmt|;
operator|*
name|regGP
operator|=
literal|0x00000001
expr_stmt|;
comment|/* set while changing SUNI settings */
name|t
operator|=
operator|*
name|regGP
expr_stmt|;
comment|/* wait */
name|t
operator|=
operator|*
name|regCFG
expr_stmt|;
name|idt
operator|->
name|flg_le25
operator|=
name|idt_phys_detect
argument_list|(
name|idt
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt
operator|->
name|flg_le25
condition|)
block|{
name|idt
operator|->
name|cellrate_rmax
operator|=
literal|59259
expr_stmt|;
name|idt
operator|->
name|cellrate_tmax
operator|=
literal|59259
expr_stmt|;
name|idt
operator|->
name|cellrate_rcur
operator|=
literal|0
expr_stmt|;
name|idt
operator|->
name|cellrate_tcur
operator|=
literal|0
expr_stmt|;
name|idt
operator|->
name|txslots_max
operator|=
literal|348
expr_stmt|;
comment|/* use n*348 for higher resolution */
name|idt
operator|->
name|txslots_cur
operator|=
literal|0
expr_stmt|;
name|nicstar_util_wr
argument_list|(
name|idt
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* synch (needed for 							 * 77105?) */
name|nicstar_util_wr
argument_list|(
name|idt
argument_list|,
literal|1
argument_list|,
literal|0x00
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
name|nicstar_util_wr
argument_list|(
name|idt
argument_list|,
literal|1
argument_list|,
literal|0x02
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* 77105 RFLUSH */
name|nicstar_util_rd
argument_list|(
name|idt
argument_list|,
literal|0x01
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* read/clear interrupt flag */
block|}
else|else
block|{
name|idt
operator|->
name|cellrate_rmax
operator|=
literal|353207
expr_stmt|;
comment|/* 2075 slots of 1 DS0 each... */
name|idt
operator|->
name|cellrate_tmax
operator|=
literal|353207
expr_stmt|;
name|idt
operator|->
name|cellrate_rcur
operator|=
literal|0
expr_stmt|;
name|idt
operator|->
name|cellrate_tcur
operator|=
literal|0
expr_stmt|;
name|idt
operator|->
name|txslots_max
operator|=
literal|2075
expr_stmt|;
name|idt
operator|->
name|txslots_cur
operator|=
literal|0
expr_stmt|;
comment|/* initialize the 155Mb SUNI */
name|nicstar_util_wr
argument_list|(
name|idt
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* sync utopia with SAR */
name|nicstar_util_wr
argument_list|(
name|idt
argument_list|,
literal|1
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* clear SW reset */
operator|*
name|regGP
operator|=
literal|0x00000000
expr_stmt|;
comment|/* clear when done with SUNI changes */
block|}
ifdef|#
directive|ifdef
name|NICSTAR_TESTSRAM
comment|/* 	 * this will work with 32K and 128K word RAM  because the pattern 	 * repeats every 4 words 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|4
control|)
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|i
argument_list|,
literal|4
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0x5a5a5a5a
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0x5a5a5a5a
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|s1
operator|=
name|nicstar_sram_rd
argument_list|(
name|idt
argument_list|,
name|i
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|s2
operator|=
name|nicstar_sram_rd
argument_list|(
name|idt
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|||
name|s2
operator|||
name|x
operator|!=
literal|0xa5a5a5a5
operator|||
name|z
operator|!=
literal|0x5a5a5a5a
condition|)
block|{
name|printf
argument_list|(
literal|"sram fail1 %d 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|4
control|)
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|i
argument_list|,
literal|4
argument_list|,
literal|0x5a5a5a5a
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0x5a5a5a5a
argument_list|,
literal|0xa5a5a5a5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|s1
operator|=
name|nicstar_sram_rd
argument_list|(
name|idt
argument_list|,
name|i
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|s2
operator|=
name|nicstar_sram_rd
argument_list|(
name|idt
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|||
name|s2
operator|||
name|x
operator|!=
literal|0xa5a5a5a5
operator|||
name|z
operator|!=
literal|0x5a5a5a5a
condition|)
block|{
name|printf
argument_list|(
literal|"sram fail2 %d 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* flush SRAM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|4
control|)
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|i
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  	 * the memory map for the 32K word card has the 	 * addresses 0x8000, 0x10000, 0x18000 mapped back 	 * to address 0, and 0x8001, ..., 0x18001 is mapped  	 * to address 1. address 0x4000 is mapped to 0x1c000  	 */
comment|/* write in the 0 word, see if we read it at 0x10000 */
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x0
argument_list|,
literal|1
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s1
operator|=
name|nicstar_sram_rd
argument_list|(
name|idt
argument_list|,
literal|0x10000
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s1
operator|&&
name|x
operator|==
literal|0xa5a5a5a5
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"32K words of RAM\n"
argument_list|)
expr_stmt|;
name|idt
operator|->
name|sram
operator|=
literal|0x4000
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"128K words of RAM\n"
argument_list|)
expr_stmt|;
name|idt
operator|->
name|sram
operator|=
literal|0x10000
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NICSTAR_FORCE32K
name|idt
operator|->
name|sram
operator|=
literal|0x4000
expr_stmt|;
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"forced to 32K words of RAM\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*  Cellrate notes:  *       The cellrate for OC3 is 353207.55, rounded down above.  This makes  *       2075 slots of one DS0 (64003) each.  *  *       The ATM25 rate is calculated from 25.6mb divided by 424 bits for  *       cell plus 8 bits for "opcode" == 432 bits.  59259 * 432 = 25599888.  *       This provides a 47-byte AAL1 bitrate of 22,281,384 bits/sec, or  *       348 slots of one DS0 (64027) each.  If 8khz synch events are to  *       be sent, then only 347 slots are available.  *  ******************************************************************************  *  *  Physical layer detect  *  *  in:  IDT device  * out:  zero = LE155, NZ = LE25  *  * Date first: 10/30/2000  last: 06/08/2001  */
end_comment

begin_function
name|int
name|idt_phys_detect
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|u_long
name|t
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|nicstar_util_wr
argument_list|(
name|idt
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* synch (needed for 77105?) */
name|nicstar_util_rd
argument_list|(
name|idt
argument_list|,
literal|0x00
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* get Master Control Register */
switch|switch
condition|(
name|t
condition|)
block|{
comment|/* 25.6 Mbps ATM PHY with TC& PMD */
comment|/* http://www.idt.com/products/pages/ATM_Products-77105.html */
case|case
literal|0x09
case|:
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"ATM card is Fore LE25, PHY=77105\n"
argument_list|)
expr_stmt|;
name|idt
operator|->
name|hardware
operator|=
literal|"ATM25/77105"
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* S/UNI-155-LITE */
comment|/* http://www.pmc-sierra.com/products/details/pm5346/index.html */
case|case
literal|0x30
case|:
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"ATM card is Fore LE155 or IDT, PHY=PM5346\n"
argument_list|)
expr_stmt|;
name|idt
operator|->
name|hardware
operator|=
literal|"ATM155/PM5346"
expr_stmt|;
break|break;
comment|/* S/UNI-155-ULTRA */
comment|/* http://www.pmc-sierra.com/products/details/pm5350/index.html */
case|case
literal|0x31
case|:
case|case
literal|0x70
case|:
case|case
literal|0x78
case|:
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"ATM card is Fore LE155, PHY=PM5350\n"
argument_list|)
expr_stmt|;
name|idt
operator|->
name|hardware
operator|=
literal|"ATM155/PM5350"
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"cannot figure out card type, assuming LE155 (reg=%d).\n"
argument_list|,
operator|(
name|int
operator|)
name|t
argument_list|)
expr_stmt|;
name|idt
operator|->
name|hardware
operator|=
literal|"unknown (LE155?)"
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Register 0 values:  *       77105  = 0x09  *       PM5346 = 0x30  *       PM5250 = 0x31  (actually observed)  *       PM5350 = 0x70 or 0x78 (according to docs)  *  ******************************************************************************  *  *  Initialize the data structures  */
end_comment

begin_function
name|void
name|nicstar_init
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|u_long
modifier|*
name|p
decl_stmt|;
name|idt_connect_init
argument_list|(
name|idt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize for 0 VPI bits (12 VCI 					 * bits) */
comment|/* allocate space for TSQ, RSQ, SCD for VBR,ABR, UBR */
name|idt
operator|->
name|fixbuf
operator|=
name|vm_page_alloc_contig
argument_list|(
name|NICSTAR_FIXPAGES
operator|*
name|PAGE_SIZE
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt
operator|->
name|fixbuf
operator|==
name|NULL
condition|)
return|return;
comment|/* no space card disabled */
if|if
condition|(
name|idt_buffer_init
argument_list|(
name|idt
argument_list|)
condition|)
comment|/* allocate large buffers */
goto|goto
name|freemem
goto|;
comment|/* free memory and return */
if|if
condition|(
name|idt_mcheck_init
argument_list|(
name|idt
argument_list|)
condition|)
goto|goto
name|freemem
goto|;
name|idt_found
operator|++
expr_stmt|;
comment|/* number of cards found on machine */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"nicstar: buffer size %d\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|idt_queue_init
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* initialize all TX_QUEUE structures */
name|idt_slots_init
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* initialize CBR table slots */
comment|/* initialize variable rate mbuf queues */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|idt
operator|->
name|fixbuf
argument_list|,
name|NICSTAR_FIXPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* TSQ initialization */
for|for
control|(
name|p
operator|=
operator|(
name|u_long
operator|*
operator|)
name|idt
operator|->
name|fixbuf
init|;
name|p
operator|<
operator|(
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|fixbuf
operator|+
literal|0x2000
operator|)
condition|;
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0x00000000
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80000000
expr_stmt|;
comment|/* set empty bit */
block|}
name|buf
operator|=
name|vtophys
argument_list|(
name|idt
operator|->
name|fixbuf
argument_list|)
expr_stmt|;
comment|/* Transmit Status Queue Base */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGTSQB
operator|)
operator|=
name|buf
expr_stmt|;
comment|/* Transmit Status Queue Head */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGTSQH
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* 8k aligned */
name|idt
operator|->
name|tsq_base
operator|=
operator|(
name|u_long
operator|*
operator|)
name|idt
operator|->
name|fixbuf
expr_stmt|;
name|idt
operator|->
name|tsq_head
operator|=
operator|(
name|u_long
operator|*
operator|)
name|idt
operator|->
name|fixbuf
expr_stmt|;
name|idt
operator|->
name|tsq_size
operator|=
literal|1024
expr_stmt|;
comment|/* Recieve Status Queue Base */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGRSQB
operator|)
operator|=
name|buf
operator|+
literal|0x2000
expr_stmt|;
comment|/* Transmit Status Queue Head */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGRSQH
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* 8k aligned */
name|idt
operator|->
name|rsqh
operator|=
literal|0
expr_stmt|;
comment|/* Now load receive buffers into SRAM */
name|nicstar_ld_rcv_buf
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* load variable SCQ */
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7dc
argument_list|,
literal|4
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|buf
operator|+
literal|0x8000
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* SD2 */
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7e0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7e4
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7e8
argument_list|,
literal|4
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|buf
operator|+
literal|0x6000
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* SD1 */
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7ec
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7f0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7f4
argument_list|,
literal|4
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|buf
operator|+
literal|0x4000
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* SD0 */
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7f8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
literal|0x1e7fc
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize RCT */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idt
operator|->
name|sram
condition|;
name|i
operator|+=
literal|4
control|)
block|{
comment|/* XXX ifdef table size */
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|i
argument_list|,
literal|4
argument_list|,
literal|0x0
argument_list|,
literal|0x0
argument_list|,
literal|0x0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
comment|/* VPI/VCI mask is 0 */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGVMSK
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Set the Transmit Schedule Table base address */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGTSTB
operator|)
operator|=
name|IDT_TST_START
expr_stmt|;
comment|/* Configuration Register settings:  * Bit(s)	Meaning					value  * 31		Software reset				0  * 30		RESERVED				0  * 29		Recieve Enabled				1  * 28-27	Small Buffer Size (host memory)		01 (96 bytes)  * 26-25	Large Buffer Size (host memory)		00 (2048 bytes)  * 24		Interrupt on empty free buffer queue	1  *  * 23-22	Recieve Status Queue Size (host memory)	10 (8192 bytes)  * 21		Accpect Invalid cells into Raw Queue	1  * 20		Ignore General Flow control		1  *  * 19-18	VPI/VCI Select				00  * 17-16	Recieve Connect Table Size		00 (32K SRAM)  *							10 (128K SRAM)  *  * 15		Accpect non-open VPI/VCI to Raw Queue	1  * 14-12	time to delay after Rx and interrupt	001 (0us)  *  * 11		Interrupt when a Raw Cell is added	1  * 10		Interrupt when Recieve Queue near full	1  *  9		Recieve RM (PTI = 110 or 111)		1  *  8		RESERVED				0  *  *  7		Interrupt on Timer rollover		1  *  6		RESERVED				0  *  5		Transmit Enabled			1  *  4		Interrupt on Transmit Status Indicator	1  *  *  3		Interrupt on transmit underruns		1  *  2		UTOPIA cell/byte mode			0 (cell)  *  1		Interrupt on nearly full TSQ		1  *  0		Enable Physical Interrupt		1  */
comment|/* original values:  0x31b09ebb and 0x31b29eb  */
comment|/* 	 * 11/01/2000: changed from 0x31b09eb to 0x29b09eb for 96-byte 	 * sm-buf 	 */
if|if
condition|(
name|idt
operator|->
name|sram
operator|==
literal|0x4000
condition|)
comment|/* 32K */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGCFG
operator|)
operator|=
literal|0x29b09ebb
expr_stmt|;
else|else
comment|/* 128K */
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGCFG
operator|)
operator|=
literal|0x29b29ebb
expr_stmt|;
return|return;
name|freemem
label|:
comment|/* free memory and return */
name|idt_release_mem
argument_list|(
name|idt
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"cannot allocate memory\n"
argument_list|)
expr_stmt|;
return|return;
comment|/* no space card disabled */
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Release all allocated memory  *  *  in:  IDT device  *  * Date first: 11/14/2000  last: 11/14/2000  */
end_comment

begin_function
name|void
name|idt_release_mem
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
if|if
condition|(
name|idt
operator|->
name|fixbuf
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|idt
operator|->
name|fixbuf
argument_list|,
operator|(
name|NICSTAR_FIXPAGES
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt
operator|->
name|cbr_base
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|idt
operator|->
name|cbr_base
argument_list|,
name|idt
operator|->
name|cbr_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s() is NOT SAFE!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* we also have idt->connection and idt->mcheck to do as well... */
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Write one to four words to SRAM  *  *    writes one to four words into sram starting at "sram_location"  *  *    returns -1 if sram location is out of range.  *    returns count, if count is not in the range from 1-4.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int
name|nicstar_sram_wr
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|,
name|u_long
name|address
parameter_list|,
name|int
name|count
parameter_list|,
name|u_long
name|data0
parameter_list|,
name|u_long
name|data1
parameter_list|,
name|u_long
name|data2
parameter_list|,
name|u_long
name|data3
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
literal|0x20000
condition|)
comment|/* bad address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
comment|/* 12/06/2000 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
operator|--
name|count
condition|)
block|{
case|case
literal|3
case|:
operator|*
operator|(
name|idt
operator|->
name|reg_data
operator|+
literal|3
operator|)
operator|=
name|data3
expr_stmt|;
comment|/* drop down to do others */
case|case
literal|2
case|:
operator|*
operator|(
name|idt
operator|->
name|reg_data
operator|+
literal|2
operator|)
operator|=
name|data2
expr_stmt|;
comment|/* drop down to do others */
case|case
literal|1
case|:
operator|*
operator|(
name|idt
operator|->
name|reg_data
operator|+
literal|1
operator|)
operator|=
name|data1
expr_stmt|;
comment|/* drop down to do others */
case|case
literal|0
case|:
operator|*
name|idt
operator|->
name|reg_data
operator|=
name|data0
expr_stmt|;
comment|/* load last data item */
break|break;
comment|/* done loading values */
default|default:
return|return
operator|(
name|count
operator|)
return|;
comment|/* nothing to do */
block|}
comment|/* write the word(s) */
operator|*
name|idt
operator|->
name|reg_cmd
operator|=
literal|0x40000000
operator||
operator|(
name|address
operator|<<
literal|2
operator|)
operator||
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  05/31/2001:  Removed wait between data register(s) and write command.  *       The docs do not state it is helpful, and the example only has one  *       wait, before the data register load.  The wait time is very high -  *       aproximately 6 microseconds per wait.  *  ******************************************************************************  *  *  Read one word from SRAM  *  *    reads one word of sram at "sram_location" and places the value  *    in "answer_pointer"  *  *    returns -1 if sram location is out of range.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int
name|nicstar_sram_rd
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|,
name|u_long
name|address
parameter_list|,
name|u_long
modifier|*
name|data0
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
literal|0x20000
condition|)
comment|/* bad address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|idt
operator|->
name|reg_cmd
operator|=
literal|0x50000000
operator||
operator|(
name|address
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* read a word */
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|data0
operator|=
operator|*
name|idt
operator|->
name|reg_data
expr_stmt|;
comment|/* save word */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Open or Close connection in IDT Receive Connection Table  *  *  in:  IDT device, VPI, VCI, opflag (0 = close, 1 = open)  * out:  zero = success  *  *  Date first: 12/14/2000  last: 12/14/2000  */
end_comment

begin_function
name|int
name|idt_connect_opencls
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|,
name|int
name|opflag
parameter_list|)
block|{
name|int
name|address
decl_stmt|;
name|int
name|word1
decl_stmt|;
if|if
condition|(
name|connection
operator|->
name|vpi
operator|>=
name|idt
operator|->
name|conn_maxvpi
operator|||
name|connection
operator|->
name|vci
operator|>=
name|idt
operator|->
name|conn_maxvci
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|address
operator|=
name|connection
operator|->
name|vpi
operator|*
name|idt
operator|->
name|conn_maxvci
operator|+
name|connection
operator|->
name|vci
expr_stmt|;
name|address
operator|<<=
literal|2
expr_stmt|;
comment|/* each entry is 4 words */
if|if
condition|(
name|opflag
condition|)
block|{
switch|switch
condition|(
name|connection
operator|->
name|aal
condition|)
block|{
case|case
name|ATM_AAL0
case|:
name|word1
operator|=
literal|0x00038000
expr_stmt|;
break|break;
comment|/* raw cell queue */
case|case
name|ATM_AAL1
case|:
name|word1
operator|=
literal|0x00008000
expr_stmt|;
break|break;
comment|/* Nicstar "AAL0" */
case|case
name|ATM_AAL3_4
case|:
name|word1
operator|=
literal|0x00018000
expr_stmt|;
break|break;
case|case
name|ATM_AAL5
case|:
name|word1
operator|=
literal|0x00028000
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|address
argument_list|,
literal|4
argument_list|,
name|word1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|opflag
operator|=
literal|0x00080000
expr_stmt|;
comment|/* bit-19 set or clear */
block|}
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|idt
operator|->
name|reg_cmd
operator|=
literal|0x20000000
operator||
name|opflag
operator||
name|address
operator|<<
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *    nicstar_add_buf    ( card, mbuf1, mbuf2, which_queue)  *  *    This adds two buffers to the specified queue. This uses the  *    mbuf address as handle and the buffer physical address must be  *    the DMA address.  *  *    returns -1 if queue is full, the address is not word aligned, or  *    an invalid queue is specified.  *    returns 0 if parameters were acceptable.  */
end_comment

begin_function
name|int
name|nicstar_add_buf
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|buf0
parameter_list|,
name|struct
name|mbuf
modifier|*
name|buf1
parameter_list|,
name|u_long
name|islrg
parameter_list|)
block|{
name|u_long
name|stat_val
decl_stmt|;
name|u_long
name|val0
decl_stmt|,
name|val1
decl_stmt|,
name|val2
decl_stmt|,
name|val3
decl_stmt|;
if|if
condition|(
name|islrg
operator|>
literal|1
condition|)
comment|/* bad buffer size */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|stat_val
operator|=
operator|*
name|idt
operator|->
name|reg_stat
expr_stmt|;
if|if
condition|(
name|islrg
condition|)
block|{
if|if
condition|(
name|stat_val
operator|&
literal|0x80
condition|)
comment|/* large queue is full */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|stat_val
operator|&
literal|0x100
condition|)
comment|/* small queue is full */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|buf0
operator|||
operator|!
name|buf1
operator|||
operator|(
call|(
name|u_long
call|)
argument_list|(
name|buf0
operator|->
name|m_data
argument_list|)
operator|&
literal|0x7
operator|)
operator|||
operator|(
call|(
name|u_long
call|)
argument_list|(
name|buf1
operator|->
name|m_data
argument_list|)
operator|&
literal|0x7
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* buffers must word aligned */
block|}
if|if
condition|(
name|idt
operator|->
name|raw_headm
operator|==
name|NULL
condition|)
comment|/* raw cell buffer pointer not 					 * initialized */
if|if
condition|(
name|islrg
condition|)
block|{
name|idt
operator|->
name|raw_headm
operator|=
name|buf0
expr_stmt|;
name|idt
operator|->
name|raw_headp
operator|=
name|vtophys
argument_list|(
name|buf0
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
comment|/* 12/06/2000 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|val0
operator|=
operator|(
name|u_long
operator|)
name|buf0
expr_stmt|;
comment|/* mbuf address is handle */
name|val1
operator|=
name|vtophys
argument_list|(
name|buf0
operator|->
name|m_data
argument_list|)
expr_stmt|;
comment|/* DMA addr of buff1 */
name|val2
operator|=
operator|(
name|u_long
operator|)
name|buf1
expr_stmt|;
comment|/* mbuf address is handle */
name|val3
operator|=
name|vtophys
argument_list|(
name|buf1
operator|->
name|m_data
argument_list|)
expr_stmt|;
comment|/* DMA addr of buff2 */
operator|*
operator|(
name|idt
operator|->
name|reg_data
operator|+
literal|0
operator|)
operator|=
name|val0
expr_stmt|;
operator|*
operator|(
name|idt
operator|->
name|reg_data
operator|+
literal|1
operator|)
operator|=
name|val1
expr_stmt|;
operator|*
operator|(
name|idt
operator|->
name|reg_data
operator|+
literal|2
operator|)
operator|=
name|val2
expr_stmt|;
operator|*
operator|(
name|idt
operator|->
name|reg_data
operator|+
literal|3
operator|)
operator|=
name|val3
expr_stmt|;
operator|*
name|idt
operator|->
name|reg_cmd
operator|=
literal|0x60000000
operator||
name|islrg
expr_stmt|;
name|idt_mcheck_add
argument_list|(
name|idt
argument_list|,
name|buf0
argument_list|)
expr_stmt|;
name|idt_mcheck_add
argument_list|(
name|idt
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    nicstar_util_rd    ( card, util_location, answer_pointer )  *  *    reads one byte from the utility bus at "util_location" and places the  *    value in "answer_pointer"  *  *    returns -1 if util location is out of range.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int
name|nicstar_util_rd
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|,
name|u_long
name|address
parameter_list|,
name|u_long
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
literal|0x81
condition|)
comment|/* bad address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|idt
operator|->
name|reg_cmd
operator|=
literal|0x80000200
operator||
name|address
expr_stmt|;
comment|/* read a word */
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|data
operator|=
operator|*
name|idt
operator|->
name|reg_data
operator|&
literal|0xff
expr_stmt|;
comment|/* save word */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    nicstar_util_wr    ( card, util location, data )  *  *    writes one byte to the utility bus at "util_location"  *  *    returns -1 if util location is out of range.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int
name|nicstar_util_wr
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|,
name|int
name|cs
parameter_list|,
name|u_long
name|address
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
literal|0x81
condition|)
comment|/* bad address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cs
operator|>
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|idt_status_wait
argument_list|(
name|idt
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|idt
operator|->
name|reg_data
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
comment|/* load last data item */
if|if
condition|(
name|cs
operator|==
literal|0
condition|)
operator|*
name|idt
operator|->
name|reg_cmd
operator|=
literal|0x90000100
operator||
name|address
expr_stmt|;
comment|/* write the byte, CS1 */
else|else
operator|*
name|idt
operator|->
name|reg_cmd
operator|=
literal|0x90000200
operator||
name|address
expr_stmt|;
comment|/* write the byte, CS2 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    nicstar_eeprom_rd    ( card , byte_location )  *  *    reads one byte from the utility bus at "byte_location" and return the  *    value as an integer. this routint is only used to read the MAC address  *    from the EEPROM at boot time.  */
end_comment

begin_function
name|int
name|nicstar_eeprom_rd
parameter_list|(
name|nicstar_reg_t
modifier|*
specifier|const
name|idt
parameter_list|,
name|u_long
name|address
parameter_list|)
block|{
specifier|volatile
name|u_long
modifier|*
name|regGP
init|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGGP
operator|)
decl_stmt|;
specifier|volatile
name|u_long
name|gp
init|=
operator|*
name|regGP
operator|&
literal|0xfffffff0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* make sure idle */
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x06
expr_stmt|;
comment|/* CS and Clock high */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* CS and Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* toggle in  READ CMD (00000011) */
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x04
expr_stmt|;
comment|/* Clock high (data 0) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* CS and Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x04
expr_stmt|;
comment|/* Clock high (data 0) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* CS and Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x04
expr_stmt|;
comment|/* Clock high (data 0) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* CS and Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x04
expr_stmt|;
comment|/* Clock high (data 0) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* CS and Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x04
expr_stmt|;
comment|/* Clock high (data 0) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* CS and Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x04
expr_stmt|;
comment|/* Clock high (data 0) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x01
expr_stmt|;
comment|/* CS and Clock low data 1 */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x05
expr_stmt|;
comment|/* Clock high (data 1) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x01
expr_stmt|;
comment|/* CS and Clock low data 1 */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x05
expr_stmt|;
comment|/* Clock high (data 1) */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* toggle in the address */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|regGP
operator|=
operator|(
name|gp
operator||
operator|(
operator|(
name|address
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|regGP
operator|=
operator|(
name|gp
operator||
literal|0x04
operator||
operator|(
operator|(
name|address
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Clock high */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* read EEPROM data */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|value
operator||=
operator|(
operator|(
operator|*
name|regGP
operator|&
literal|0x10000
operator|)
operator|>>
operator|(
literal|16
operator|-
name|i
operator|)
operator|)
expr_stmt|;
operator|*
name|regGP
operator|=
name|gp
operator||
literal|0x04
expr_stmt|;
comment|/* Clock high */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
operator|*
name|regGP
operator|=
name|gp
expr_stmt|;
comment|/* CS and Clock low */
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Load the card receive buffers  *  *  in:  IDT device  *  *  Date first: 11/01/2000  last: 05/25/2000  */
end_comment

begin_function
name|void
name|nicstar_ld_rcv_buf
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|u_long
name|stat_reg
decl_stmt|;
name|int
name|card_small
decl_stmt|;
name|int
name|card_large
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|stat_reg
operator|=
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|idt
operator|->
name|stat_reg
expr_stmt|;
name|card_small
operator|=
operator|(
name|stat_reg
operator|&
literal|0xff000000
operator|)
operator|>>
literal|23
expr_stmt|;
comment|/* reg is number of 							 * pairs */
name|card_large
operator|=
operator|(
name|stat_reg
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|15
expr_stmt|;
if|if
condition|(
name|idt_sysctl_bufsmall
operator|>
literal|510
condition|)
name|idt_sysctl_bufsmall
operator|=
literal|510
expr_stmt|;
if|if
condition|(
name|idt_sysctl_buflarge
operator|>
literal|510
condition|)
name|idt_sysctl_buflarge
operator|=
literal|510
expr_stmt|;
if|if
condition|(
name|idt_sysctl_bufsmall
operator|<
literal|10
condition|)
name|idt_sysctl_bufsmall
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|idt_sysctl_buflarge
operator|<
literal|10
condition|)
name|idt_sysctl_buflarge
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|card_small
operator|<
name|idt_sysctl_bufsmall
condition|)
block|{
comment|/* 05/25/2001 from fixed */
name|MGETHDR
argument_list|(
name|m1
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
break|break;
name|MGETHDR
argument_list|(
name|m2
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
break|break;
block|}
name|MH_ALIGN
argument_list|(
name|m1
argument_list|,
literal|96
argument_list|)
expr_stmt|;
comment|/* word align& allow lots of 					 * prepending */
name|MH_ALIGN
argument_list|(
name|m2
argument_list|,
literal|96
argument_list|)
expr_stmt|;
if|if
condition|(
name|nicstar_add_buf
argument_list|(
name|idt
argument_list|,
name|m1
argument_list|,
name|m2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Cannot add small buffers, size=%d.\n"
argument_list|,
name|card_small
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m2
argument_list|)
expr_stmt|;
break|break;
block|}
name|card_small
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|card_large
operator|<
name|idt_sysctl_buflarge
condition|)
block|{
comment|/* 05/25/2001 from fixed */
name|m1
operator|=
name|idt_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
break|break;
name|m2
operator|=
name|idt_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nicstar_add_buf
argument_list|(
name|idt
argument_list|,
name|m1
argument_list|,
name|m2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Cannot add large buffers, size=%d.\n"
argument_list|,
name|card_large
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m2
argument_list|)
expr_stmt|;
break|break;
block|}
name|card_large
operator|+=
literal|2
expr_stmt|;
block|}
name|idt_sysctl_curlarge
operator|=
name|card_large
expr_stmt|;
name|idt_sysctl_cursmall
operator|=
name|card_small
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Wait for command to finish  *  *  in:  IDT device  * out:  zero = success  *  *  Date first: 12/06/2000  last: 12/16/2000  */
end_comment

begin_function
name|int
name|idt_status_wait
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|timeout
operator|=
literal|33
operator|*
literal|100
expr_stmt|;
comment|/* allow 100 microseconds timeout */
while|while
condition|(
operator|*
name|idt
operator|->
name|reg_stat
operator|&
literal|0x200
condition|)
if|if
condition|(
operator|--
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"timeout waiting for device status.\n"
argument_list|)
expr_stmt|;
name|idt
operator|->
name|stats_cmderrors
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Log status of system buffers  *  *  in:  IDT device  *  *  Date first: 10/31/2000  last: 05/25/2001  */
end_comment

begin_function
name|void
name|idt_status_bufs
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|u_long
name|stat_reg
decl_stmt|;
name|int
name|card_small
decl_stmt|;
name|int
name|card_large
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|stat_reg
operator|=
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|idt
operator|->
name|stat_reg
expr_stmt|;
name|card_small
operator|=
operator|(
name|stat_reg
operator|&
literal|0xff000000
operator|)
operator|>>
literal|23
expr_stmt|;
comment|/* reg is number of 							 * pairs */
name|card_large
operator|=
operator|(
name|stat_reg
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|15
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"BUFFER STATUS: small=%d/%d, large=%d/%d.\n"
argument_list|,
name|card_small
argument_list|,
name|idt_sysctl_bufsmall
argument_list|,
name|card_large
argument_list|,
name|idt_sysctl_buflarge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Since this is called when the card timer wraps, we should only see  *  this 16 times (LE155) or 10 (LE25) per hour.  *  *******************************************************************************  *  *  Add mbuf into "owned" list  *  *  in:  IDT device, mbuf  * out:  zero = success  *  * Date first: 11/13/2000  last: 11/13/2000  */
end_comment

begin_function
name|int
name|idt_mcheck_add
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|hpos
decl_stmt|;
name|int
name|s
decl_stmt|;
name|hpos
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|m
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|1023
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|idt
operator|->
name|mcheck
index|[
name|hpos
index|]
expr_stmt|;
name|idt
operator|->
name|mcheck
index|[
name|hpos
index|]
operator|=
name|m
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Remove mbuf from "owned" list  *  *  in:  IDT device, mbuf  * out:  zero = success  *  * Date first: 11/13/2000  last: 11/13/2000  */
end_comment

begin_function
name|int
name|idt_mcheck_rem
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|nbuf
decl_stmt|;
name|int
name|hpos
decl_stmt|;
name|int
name|s
decl_stmt|;
name|hpos
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|m
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|1023
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|nbuf
operator|=
name|idt
operator|->
name|mcheck
index|[
name|hpos
index|]
expr_stmt|;
if|if
condition|(
name|nbuf
operator|==
name|m
condition|)
block|{
name|idt
operator|->
name|mcheck
index|[
name|hpos
index|]
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|nbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nbuf
operator|->
name|m_next
operator|!=
name|m
condition|)
block|{
name|nbuf
operator|=
name|nbuf
operator|->
name|m_next
expr_stmt|;
continue|continue;
block|}
name|nbuf
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Card should not have this mbuf! %x\n"
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Initialize mbuf "owned" list  *  *  in:  IDT device  * out:  zero = success  *  * Date first: 11/13/2000  last: 05/26/2001  */
end_comment

begin_function
name|int
name|idt_mcheck_init
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|x
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|idt
operator|->
name|mcheck
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt
operator|->
name|mcheck
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|1024
condition|;
name|x
operator|++
control|)
name|idt
operator|->
name|mcheck
index|[
name|x
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Allocate contiguous, fixed memory  *  *  in:  number of pages  * out:  pointer, NULL = failure  *  * Date first: 11/29/2000  last: 11/29/2000  */
end_comment

begin_function
name|vm_offset_t
name|idt_malloc_contig
parameter_list|(
name|int
name|pages
parameter_list|)
block|{
name|vm_offset_t
name|retval
decl_stmt|;
name|retval
operator|=
name|vm_page_alloc_contig
argument_list|(
name|pages
operator|*
name|PAGE_SIZE
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDEF
name|printf
argument_list|(
literal|"idt: vm_offset_t allocated %d pages at %x\n"
argument_list|,
name|pages
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize all TX_QUEUE structures  *  *  in:  IDT device  * out:  zero = succes  *  *  Date first: 11/29/2000  last: 11/29/2000  */
end_comment

begin_function
specifier|static
name|int
name|idt_queue_init
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|vm_offset_t
name|scqbase
decl_stmt|;
name|int
name|x
decl_stmt|;
name|idt
operator|->
name|cbr_size
operator|=
name|IDT_MAX_CBRQUEUE
operator|*
literal|16
operator|*
literal|64
expr_stmt|;
name|idt
operator|->
name|cbr_base
operator|=
name|idt_malloc_contig
argument_list|(
name|idt
operator|->
name|cbr_size
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|scqbase
operator|=
name|idt
operator|->
name|cbr_base
expr_stmt|;
if|if
condition|(
name|scqbase
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|idt
operator|->
name|cbr_freect
operator|=
name|idt
operator|->
name|cbr_size
operator|/
operator|(
literal|16
operator|*
literal|64
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|idt
operator|->
name|cbr_freect
condition|;
name|x
operator|++
control|)
block|{
name|txqueue
operator|=
operator|&
name|idt
operator|->
name|cbr_txqb
index|[
name|x
index|]
expr_stmt|;
name|txqueue
operator|->
name|mget
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|scd
operator|=
name|IDT_SCD_START
operator|+
name|x
operator|*
literal|12
expr_stmt|;
name|txqueue
operator|->
name|scq_base
operator|=
operator|(
name|u_long
operator|*
operator|)
name|scqbase
expr_stmt|;
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
name|txqueue
operator|->
name|scq_len
operator|=
literal|64
expr_stmt|;
comment|/* all CBR queues use 64 entries */
name|txqueue
operator|->
name|scq_cur
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|vbr_m
operator|=
literal|0
expr_stmt|;
comment|/* m& n set to zero for CBR */
name|txqueue
operator|->
name|vbr_n
operator|=
literal|0
expr_stmt|;
name|idt
operator|->
name|cbr_free
index|[
name|x
index|]
operator|=
name|txqueue
expr_stmt|;
name|scqbase
operator|+=
literal|64
operator|*
literal|16
expr_stmt|;
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|4
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|txqueue
operator|=
operator|&
name|idt
operator|->
name|queue_vbr
expr_stmt|;
comment|/* VBR queue */
name|txqueue
operator|->
name|mget
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|scd
operator|=
literal|0x1e7f4
expr_stmt|;
name|txqueue
operator|->
name|scq_base
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|fixbuf
operator|+
literal|0x4000
operator|)
expr_stmt|;
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
name|txqueue
operator|->
name|scq_len
operator|=
literal|512
expr_stmt|;
comment|/* all VBR queues use 512 entries */
name|txqueue
operator|->
name|scq_cur
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|vbr_m
operator|=
literal|1
expr_stmt|;
name|txqueue
operator|->
name|vbr_n
operator|=
literal|1
expr_stmt|;
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|4
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txqueue
operator|=
operator|&
name|idt
operator|->
name|queue_abr
expr_stmt|;
comment|/* ABR queue (not currently used) */
name|txqueue
operator|->
name|mget
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|scd
operator|=
literal|0x1e7e8
expr_stmt|;
name|txqueue
operator|->
name|scq_base
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|fixbuf
operator|+
literal|0x6000
operator|)
expr_stmt|;
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
name|txqueue
operator|->
name|scq_len
operator|=
literal|512
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|vbr_m
operator|=
literal|1
expr_stmt|;
name|txqueue
operator|->
name|vbr_n
operator|=
literal|1
expr_stmt|;
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|4
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txqueue
operator|=
operator|&
name|idt
operator|->
name|queue_ubr
expr_stmt|;
comment|/* UBR queue */
name|txqueue
operator|->
name|mget
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|scd
operator|=
literal|0x1e7dc
expr_stmt|;
name|txqueue
operator|->
name|scq_base
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|fixbuf
operator|+
literal|0x8000
operator|)
expr_stmt|;
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
name|txqueue
operator|->
name|scq_len
operator|=
literal|512
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|vbr_m
operator|=
literal|1
expr_stmt|;
comment|/* since the ABR queue is lowest priority, */
name|txqueue
operator|->
name|vbr_n
operator|=
literal|1
expr_stmt|;
comment|/* these factors should never change */
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|4
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get mbuf chain from TX_QUEUE  *  *  in:  CONNECTION  * out:  mbuf, NULL = empty  *  *  Date first: 12/03/2000  last: 12/03/2000  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|idt_queue_get
parameter_list|(
name|TX_QUEUE
modifier|*
name|txqueue
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|m1
operator|=
name|txqueue
operator|->
name|mget
expr_stmt|;
if|if
condition|(
name|m1
operator|!=
name|NULL
condition|)
block|{
name|m2
operator|=
name|m1
operator|->
name|m_nextpkt
expr_stmt|;
name|txqueue
operator|->
name|mget
operator|=
name|m2
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
comment|/* is queue empty now? */
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|m1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Add mbuf chain to connection TX_QUEUE  *  *  in:  CONNECTION, mbuf chain  * out:  zero = succes  *  *  Date first: 12/03/2000  last: 06/01/2001  */
end_comment

begin_function
specifier|static
name|int
name|idt_queue_put
parameter_list|(
name|CONNECTION
modifier|*
name|connection
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|txqueue
operator|=
name|connection
operator|->
name|queue
expr_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|connection
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|mput
operator|!=
name|NULL
condition|)
block|{
operator|*
name|txqueue
operator|->
name|mput
operator|=
name|m
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
else|else
block|{
comment|/* queue is empty */
name|txqueue
operator|->
name|mget
operator|=
name|m
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Flush all connection mbufs from TX_QUEUE  *  *  in:  CONNECTION  * out:  zero = succes  *  *  Date first: 12/03/2000  last: 12/03/2000  */
end_comment

begin_function
specifier|static
name|int
name|idt_queue_flush
parameter_list|(
name|CONNECTION
modifier|*
name|connection
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|txqueue
operator|=
name|connection
operator|->
name|queue
expr_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|m0
operator|=
operator|&
name|txqueue
operator|->
name|mget
expr_stmt|;
name|m1
operator|=
operator|*
name|m0
expr_stmt|;
while|while
condition|(
name|m1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|m1
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|connection
condition|)
block|{
operator|*
name|m0
operator|=
name|m1
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|m1
operator|=
operator|*
name|m0
expr_stmt|;
continue|continue;
block|}
name|m0
operator|=
operator|&
name|m1
operator|->
name|m_nextpkt
expr_stmt|;
name|m1
operator|=
operator|*
name|m0
expr_stmt|;
block|}
name|txqueue
operator|->
name|mput
operator|=
name|m0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Calculate number of table positions for CBR connection  *  *  in:  IDT device, PCR (cells/second)  * out:  table positions needed (minimum = 1)  *  *  Date first: 11/29/2000  last: 06/12/2001  */
end_comment

begin_function
name|int
name|idt_slots_cbr
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|int
name|pcr
parameter_list|)
block|{
name|unsigned
name|int
name|bitrate
decl_stmt|;
name|unsigned
name|int
name|slots
decl_stmt|;
name|unsigned
name|int
name|rem
decl_stmt|;
if|if
condition|(
name|pcr
operator|==
literal|171
condition|)
block|{
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"idt_slots_cbr:  CBR channel=64000, 1 slot\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pcr
operator|<
literal|171
condition|)
block|{
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"idt_slots_cbr:  CBR pcr %d rounded up to 1 slot\n"
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bitrate
operator|=
name|pcr
operator|*
literal|47
operator|*
literal|8
expr_stmt|;
name|slots
operator|=
name|bitrate
operator|/
literal|64000
expr_stmt|;
name|rem
operator|=
name|bitrate
operator|%
literal|64000
expr_stmt|;
if|if
condition|(
name|rem
operator|&&
name|idt_sysctl_logvcs
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"idt_slots_cbr: CBR cell rate rounded down to %d from %d\n"
argument_list|,
operator|(
operator|(
name|slots
operator|*
literal|64000
operator|)
operator|/
literal|376
operator|)
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
comment|/* slots++;  */
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"idt_slots_cbr:  CBR pcr=%d, slots=%d.\n"
argument_list|,
name|pcr
argument_list|,
name|slots
argument_list|)
expr_stmt|;
return|return
operator|(
name|slots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  The original algorithm rounded up or down by 32k, the goal being to  *  map 64000 requests exactly.  Unfortunately, this caused one particular  *  SVC to be set one slot too low, causing mbuf cluster starvation.  *  We can still handle the single 64k channel with a special case, and  *  let all others fall where they may.  *  *******************************************************************************  *  *  Add TX QUEUE pointer to slots in CBR table  *  *  in:  IDT device, TX_QUEUE, number slots  * out:  zero = success  *  *  Date first: 11/29/2000  last: 06/11/2001  */
end_comment

begin_function
specifier|static
name|int
name|idt_slots_add
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|TX_QUEUE
modifier|*
name|queue
parameter_list|,
name|int
name|slots
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|curval
decl_stmt|;
name|int
name|p_max
decl_stmt|;
comment|/* extra precision slots maximum */
name|int
name|p_spc
decl_stmt|;
comment|/* extra precision spacing value */
name|int
name|p_ptr
decl_stmt|;
comment|/* extra precision pointer */
name|int
name|qptr
decl_stmt|,
name|qmax
decl_stmt|;
name|int
name|qlast
decl_stmt|;
name|int
name|scdval
decl_stmt|;
if|if
condition|(
name|slots
operator|<
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|qmax
operator|=
name|idt
operator|->
name|txslots_max
expr_stmt|;
name|p_max
operator|=
name|qmax
operator|<<
literal|8
expr_stmt|;
name|p_spc
operator|=
name|p_max
operator|/
name|slots
expr_stmt|;
name|p_ptr
operator|=
name|p_spc
operator|>>
literal|1
expr_stmt|;
comment|/* use half spacing for start point */
name|qptr
operator|=
name|p_ptr
operator|>>
literal|8
expr_stmt|;
name|qlast
operator|=
name|qptr
expr_stmt|;
name|scdval
operator|=
literal|0x20000000
operator||
name|queue
operator|->
name|scd
expr_stmt|;
if|if
condition|(
name|CBR_VERBOSE
condition|)
block|{
name|printf
argument_list|(
literal|"idt_slots_add: p_max = %d\n"
argument_list|,
name|p_max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"idt_slots_add: p_spc = %d\n"
argument_list|,
name|p_spc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"idt_slots_add: p_ptr = %d\n"
argument_list|,
name|p_ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"idt_slots_add: qptr  = %d\n"
argument_list|,
name|qptr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|slots
condition|)
block|{
if|if
condition|(
name|qptr
operator|>=
name|qmax
condition|)
comment|/* handle wrap for empty slot choosing */
name|qptr
operator|-=
name|qmax
expr_stmt|;
name|curval
operator|=
name|idt
operator|->
name|cbr_slot
index|[
name|qptr
index|]
expr_stmt|;
if|if
condition|(
name|curval
operator|!=
name|NULL
condition|)
block|{
comment|/* this slot has CBR, so try next */
name|qptr
operator|++
expr_stmt|;
comment|/* next slot */
continue|continue;
block|}
if|if
condition|(
name|CBR_VERBOSE
condition|)
block|{
name|printf
argument_list|(
literal|"idt_slots_add: using qptr %d (%d)\n"
argument_list|,
name|qptr
argument_list|,
name|qptr
operator|-
name|qlast
argument_list|)
expr_stmt|;
name|qlast
operator|=
name|qptr
expr_stmt|;
block|}
name|idt
operator|->
name|cbr_slot
index|[
name|qptr
index|]
operator|=
name|queue
expr_stmt|;
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|qptr
operator|+
name|IDT_TST_START
argument_list|,
literal|1
argument_list|,
name|scdval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slots
operator|--
expr_stmt|;
name|p_ptr
operator|+=
name|p_spc
expr_stmt|;
if|if
condition|(
name|p_ptr
operator|>=
name|p_max
condition|)
comment|/* main pointer wrap */
name|p_ptr
operator|-=
name|p_max
expr_stmt|;
name|qptr
operator|=
name|p_ptr
operator|>>
literal|8
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 06/11/2001:  Extra precision pointer is used in order to handle cases where  *       fractional slot spacing causes a large area of slots to be filled.  *       This can cause further CBR circuits to get slots that have very  *       poor spacing.  *  *******************************************************************************  *  *  Remove TX QUEUE pointer from slots in CBR table  *  *  in:  IDT device, TX_QUEUE  * out:  number of CBR slots released  *  *  Date first: 12/03/2000  last: 12/03/2000  */
end_comment

begin_function
specifier|static
name|int
name|idt_slots_rem
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|TX_QUEUE
modifier|*
name|queue
parameter_list|)
block|{
name|int
name|qptr
decl_stmt|,
name|qmax
decl_stmt|;
name|int
name|slots
decl_stmt|;
name|qmax
operator|=
name|idt
operator|->
name|txslots_max
expr_stmt|;
name|slots
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qptr
operator|=
literal|0
init|;
name|qptr
operator|<
name|qmax
condition|;
name|qptr
operator|++
control|)
block|{
if|if
condition|(
name|idt
operator|->
name|cbr_slot
index|[
name|qptr
index|]
operator|!=
name|queue
condition|)
continue|continue;
name|idt
operator|->
name|cbr_slot
index|[
name|qptr
index|]
operator|=
name|NULL
expr_stmt|;
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|qptr
operator|+
name|IDT_TST_START
argument_list|,
literal|1
argument_list|,
literal|0x40000000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slots
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|slots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize slots in CBR table  *  *  in:  IDT device  * out:  zero = success  *  *  Date first: 11/29/2000  last: 11/29/2000  */
end_comment

begin_function
specifier|static
name|int
name|idt_slots_init
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
comment|/* table start pointer */
name|int
name|qptr
decl_stmt|;
name|start
operator|=
name|IDT_TST_START
expr_stmt|;
comment|/* first, fill up the TX CBR table with 'VBR' entries  */
for|for
control|(
name|qptr
operator|=
literal|0
init|;
name|qptr
operator|<
name|idt
operator|->
name|txslots_max
condition|;
name|qptr
operator|++
control|)
block|{
name|idt
operator|->
name|cbr_slot
index|[
name|qptr
index|]
operator|=
name|NULL
expr_stmt|;
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|qptr
operator|+
name|start
argument_list|,
literal|1
argument_list|,
literal|0x40000000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* now write the jump back to the table start */
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|qptr
operator|+
name|start
argument_list|,
literal|1
argument_list|,
literal|0x60000000
operator||
name|start
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Open output queue for connection  *  *  in:  IDT device, connection (class, traf_pcr,& traf_scr fields valid)  * out:  zero = success  *  *  Date first: 11/29/2000  last: 06/13/2001  */
end_comment

begin_function
name|int
name|idt_connect_txopen
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|int
name|cellrate
decl_stmt|;
name|int
name|cbr_slots
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cellrate
operator|=
name|connection
operator|->
name|traf_scr
expr_stmt|;
comment|/* 06/13/2001 use SCR instead 						 * of PCR */
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_UBR
condition|)
block|{
comment|/* UBR takes whatever is left 						 * over */
name|connection
operator|->
name|queue
operator|=
operator|&
name|idt
operator|->
name|queue_ubr
expr_stmt|;
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"idt_connect_txopen: UBR connection for %d/%d\n"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_ABR
condition|)
block|{
comment|/* ABR treated as UBR-plus */
name|connection
operator|->
name|queue
operator|=
operator|&
name|idt
operator|->
name|queue_abr
expr_stmt|;
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"idt_connect_txopen: UBR+ connection for %d/%d\n"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_CBR
condition|)
block|{
name|cbr_slots
operator|=
name|idt_slots_cbr
argument_list|(
name|idt
argument_list|,
name|cellrate
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbr_slots
operator|>
operator|(
name|idt
operator|->
name|txslots_max
operator|-
name|idt
operator|->
name|txslots_cur
operator|)
operator|||
name|idt
operator|->
name|cbr_freect
operator|<
literal|1
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* requested rate not available */
block|}
name|idt
operator|->
name|txslots_cur
operator|+=
name|cbr_slots
expr_stmt|;
name|idt
operator|->
name|cellrate_tcur
operator|+=
name|cellrate
expr_stmt|;
name|idt
operator|->
name|cbr_freect
operator|--
expr_stmt|;
name|txqueue
operator|=
name|idt
operator|->
name|cbr_free
index|[
name|idt
operator|->
name|cbr_freect
index|]
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
name|cellrate
expr_stmt|;
comment|/* was connection->traf_pcr */
if|if
condition|(
name|idt_slots_add
argument_list|(
name|idt
argument_list|,
name|txqueue
argument_list|,
name|cbr_slots
argument_list|)
condition|)
block|{
name|idt
operator|->
name|txslots_cur
operator|-=
name|cbr_slots
expr_stmt|;
comment|/* cannot add CBR slots */
name|idt
operator|->
name|cellrate_tcur
operator|-=
name|cellrate
expr_stmt|;
name|idt
operator|->
name|cbr_free
index|[
name|idt
operator|->
name|cbr_freect
index|]
operator|=
name|txqueue
expr_stmt|;
name|idt
operator|->
name|cbr_freect
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"idt_connect_txopen: CBR connection for %d/%d\n"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|txqueue
expr_stmt|;
block|}
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_VBR
condition|)
block|{
name|txqueue
operator|=
operator|&
name|idt
operator|->
name|queue_vbr
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|txqueue
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|+=
name|connection
operator|->
name|traf_scr
expr_stmt|;
comment|/* from traf_pcr 							 * 12/17/2000 */
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"idt_connect_txopen: VBR connection for %d/%d\n"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
block|}
name|idt_connect_newvbr
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* recalculate VBR divisor values */
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_CBR
operator|||
name|connection
operator|->
name|class
operator|==
name|T_ATM_VBR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* unknown class */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Close connection output queue  *  *  in:  IDT device, connection (class, traf_pcr,& traf_scr fields valid)  * out:  zero = success  *  *  Date first: 12/03/2000  last: 12/03/2000  */
end_comment

begin_function
name|int
name|idt_connect_txclose
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|int
name|cellrate
decl_stmt|;
name|int
name|slots
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cellrate
operator|=
name|connection
operator|->
name|traf_pcr
expr_stmt|;
name|txqueue
operator|=
name|connection
operator|->
name|queue
expr_stmt|;
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"idt_connect_txclose: closing connection for %d/%d\n"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
name|idt_queue_flush
argument_list|(
name|connection
argument_list|)
expr_stmt|;
comment|/* flush all connection mbufs */
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_UBR
operator|||
comment|/* UBR takes whatever is left 						 * over */
name|connection
operator|->
name|class
operator|==
name|T_ATM_ABR
condition|)
block|{
comment|/* ABR not supported, use UBR */
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_CBR
condition|)
block|{
name|slots
operator|=
name|idt_slots_rem
argument_list|(
name|idt
argument_list|,
name|txqueue
argument_list|)
expr_stmt|;
comment|/* remove this queue 							 * from CBR slots */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|idt
operator|->
name|txslots_cur
operator|-=
name|slots
expr_stmt|;
name|idt
operator|->
name|cellrate_tcur
operator|-=
name|cellrate
expr_stmt|;
if|if
condition|(
name|txqueue
operator|!=
name|NULL
condition|)
block|{
comment|/* 06/12/2001 check for failure on 					 * open */
name|idt
operator|->
name|cbr_free
index|[
name|idt
operator|->
name|cbr_freect
index|]
operator|=
name|txqueue
expr_stmt|;
name|idt
operator|->
name|cbr_freect
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_VBR
condition|)
block|{
name|txqueue
operator|=
operator|&
name|idt
operator|->
name|queue_vbr
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|-=
name|connection
operator|->
name|traf_scr
expr_stmt|;
comment|/* from traf_pcr 							 * 12/17/2000 */
block|}
name|idt_connect_newvbr
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* recalculate VBR divisor values */
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|T_ATM_CBR
operator|||
name|connection
operator|->
name|class
operator|==
name|T_ATM_VBR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* unknown class */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Calculate new VBR divisor values  *  *  in:  IDT device  *  * Date first: 12/03/2000  last: 12/03/2000  */
end_comment

begin_function
specifier|static
name|void
name|idt_connect_newvbr
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|int
name|rate_newvbr
decl_stmt|;
name|int
name|rate_noncbr
decl_stmt|;
name|int
name|divisor
decl_stmt|;
name|txqueue
operator|=
operator|&
name|idt
operator|->
name|queue_vbr
expr_stmt|;
name|rate_newvbr
operator|=
name|txqueue
operator|->
name|rate
expr_stmt|;
name|rate_noncbr
operator|=
name|idt
operator|->
name|cellrate_tmax
operator|-
name|idt
operator|->
name|cellrate_tcur
expr_stmt|;
if|if
condition|(
name|rate_newvbr
operator|<
literal|1
condition|)
comment|/* keep sane and prevent divide by zero */
name|rate_newvbr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rate_newvbr
operator|>=
name|rate_noncbr
condition|)
block|{
name|txqueue
operator|->
name|vbr_m
operator|=
literal|1
expr_stmt|;
name|txqueue
operator|->
name|vbr_n
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|divisor
operator|=
name|rate_newvbr
operator|*
literal|1000
expr_stmt|;
comment|/* size of lookup table */
name|divisor
operator|+=
name|rate_newvbr
operator|>>
literal|1
expr_stmt|;
comment|/* apply rounding to divide */
name|divisor
operator|/=
name|rate_noncbr
expr_stmt|;
comment|/* always< 1000, since newvbr< noncbr */
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"idt_connect_newvbr: divisor=%d\n"
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
name|txqueue
operator|->
name|vbr_m
operator|=
name|vbr_div_m
index|[
name|divisor
index|]
expr_stmt|;
name|txqueue
operator|->
name|vbr_n
operator|=
name|vbr_div_n
index|[
name|divisor
index|]
expr_stmt|;
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"idt_connect_newvbr: m=%d, n=%d\n"
argument_list|,
name|txqueue
operator|->
name|vbr_m
argument_list|,
name|txqueue
operator|->
name|vbr_n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  For VBR, we track the sum of all the VBR peak cellrates, and divide  *  that from the "remaining" bandwidth, which is total minus current CBR.  *  *  We will need to adjust the VBR divisor whenever we add a CBR or VBR.  *  *  Because of the integer scalign (1000) preload, the cellrate for the  *  VBR channel should not exceed 2 million (aprox 5 OC3s).  This is  *  protected by the check for rate_newvbr>= rate_noncbr.  *  *******************************************************************************  *  *  Initialize large buffers, indexes, and reference counts  *  *  in:  IDT device  * out:  zero = success  *  * Date first: 11/01/2000  last: 05/25/2001  */
end_comment

begin_function
name|int
name|idt_buffer_init
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|idt
operator|->
name|raw_headm
operator|=
name|NULL
expr_stmt|;
comment|/* nicstar_add_buf() will initialize */
name|idt
operator|->
name|raw_headp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get large buffer from kernel pool  *  * out:  mbuf, NULL = error  *  * Date first: 05/25/2001  last: 05/25/2001  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|idt_mbufcl_get
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
return|return
operator|(
name|m
operator|)
return|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize connection table  *  *  in:  IDT, number of VPI bits (0, 1, or 2)  * out:  zero = success  *  * Date first: 10/29/2000  last: 12/10/2000  */
end_comment

begin_function
name|int
name|idt_connect_init
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|int
name|vpibits
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|int
name|pages
decl_stmt|;
name|int
name|vpi
decl_stmt|;
name|int
name|vci
decl_stmt|;
switch|switch
condition|(
name|vpibits
condition|)
block|{
case|case
literal|1
case|:
name|idt
operator|->
name|conn_maxvpi
operator|=
literal|2
expr_stmt|;
name|idt
operator|->
name|conn_maxvci
operator|=
literal|2048
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|idt
operator|->
name|conn_maxvpi
operator|=
literal|4
expr_stmt|;
name|idt
operator|->
name|conn_maxvci
operator|=
literal|1024
expr_stmt|;
break|break;
default|default:
name|idt
operator|->
name|conn_maxvpi
operator|=
literal|1
expr_stmt|;
name|idt
operator|->
name|conn_maxvci
operator|=
literal|4096
expr_stmt|;
block|}
name|pages
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|CONNECTION
argument_list|)
operator|*
name|MAX_CONNECTION
operator|)
operator|+
name|PAGE_SIZE
operator|-
literal|1
expr_stmt|;
name|pages
operator|/=
name|PAGE_SIZE
expr_stmt|;
name|idt
operator|->
name|connection
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|vm_page_alloc_contig
argument_list|(
name|pages
operator|*
name|PAGE_SIZE
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt
operator|->
name|connection
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|vpi
operator|=
literal|0
init|;
name|vpi
operator|<
name|idt
operator|->
name|conn_maxvpi
condition|;
name|vpi
operator|++
control|)
for|for
control|(
name|vci
operator|=
literal|0
init|;
name|vci
operator|<
name|idt
operator|->
name|conn_maxvci
condition|;
name|vci
operator|++
control|)
block|{
name|connection
operator|=
operator|&
name|idt
operator|->
name|connection
index|[
name|vpi
operator|*
name|idt
operator|->
name|conn_maxvci
operator|+
name|vci
index|]
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|=
name|NULL
expr_stmt|;
comment|/* may want to change to 							 * "unclaimed" */
name|connection
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* closed */
name|connection
operator|->
name|vpi
operator|=
name|vpi
expr_stmt|;
name|connection
operator|->
name|vci
operator|=
name|vci
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
comment|/* no current TX queue */
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
comment|/* no current receive 							 * mbuf */
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|maxpdu
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_pcr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_scr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|aal
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|class
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|flg_mpeg2ts
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|flg_clp
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Look up a connection  *  *  in:  IDT, vpi, vci  * out:  CONNECTION, NULL=invalid vpi/vci  *  * Date first: 10/29/2000  last: 10/29/2000  */
end_comment

begin_function
name|CONNECTION
modifier|*
name|idt_connect_find
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|int
name|vpi
parameter_list|,
name|int
name|vci
parameter_list|)
block|{
if|if
condition|(
name|vpi
operator|>=
name|idt
operator|->
name|conn_maxvpi
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|vci
operator|>=
name|idt
operator|->
name|conn_maxvci
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|idt
operator|->
name|connection
index|[
name|vpi
operator|*
name|idt
operator|->
name|conn_maxvci
operator|+
name|vci
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *                       MBUF SECTION  *  ******************************************************************************  *  *  Align data in mbuf (to 32-bit boundary)  *  *  in:  mbuf  * out:  zero = success  *  * Date first: 11/08/2000  last: 11/15/2000  */
end_comment

begin_function
name|int
name|idt_mbuf_align
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|prev
parameter_list|)
block|{
name|caddr_t
name|buf_base
decl_stmt|;
name|int
name|buf_size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|newlen
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_data
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
comment|/* external storage */
name|buf_base
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|buf_size
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
comment|/* 		 * we should really bail out at this point, since we cannot 		 * just shift the data in an external mbuf 		 */
block|}
else|else
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
comment|/* internal storage, packet 						 * header */
name|buf_base
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|buf_size
operator|=
name|MHLEN
expr_stmt|;
block|}
else|else
block|{
name|buf_base
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
comment|/* internal storage, no packet 						 * header */
name|buf_size
operator|=
name|MLEN
expr_stmt|;
block|}
block|}
name|offset
operator|=
literal|4
operator|-
operator|(
operator|(
name|int
operator|)
name|buf_base
operator|&
literal|3
operator|)
expr_stmt|;
name|offset
operator|&=
literal|3
expr_stmt|;
name|buf_base
operator|+=
name|offset
expr_stmt|;
comment|/* new (aligned) buffer base */
if|if
condition|(
name|m
operator|->
name|m_len
operator|+
name|offset
operator|>
name|buf_size
condition|)
comment|/* not enough space to just 						 * move */
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
if|if
condition|(
name|idt_mbuf_append4
argument_list|(
name|prev
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* give word to prev 									 * mbuf */
name|m
operator|->
name|m_data
operator|+=
literal|4
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|+
name|offset
operator|>
name|buf_size
condition|)
comment|/* still not enough space */
if|if
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|newlen
operator|=
name|buf_size
operator|-
name|offset
expr_stmt|;
comment|/* maximum new length */
name|newlen
operator|&=
literal|0xfffffc
expr_stmt|;
comment|/* fix the length too... */
name|count
operator|=
name|buf_size
operator|-
name|newlen
expr_stmt|;
comment|/* bytes we have to get 							 * rid of */
if|if
condition|(
name|idt_mbuf_prepend
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|m
operator|->
name|m_data
operator|+
name|newlen
argument_list|,
name|count
argument_list|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_len
operator|=
name|newlen
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|+
name|offset
operator|>
name|buf_size
condition|)
comment|/* we're stuck... */
return|return
operator|(
literal|1
operator|)
return|;
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|buf_base
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* move data to aligned 						 * position */
name|m
operator|->
name|m_data
operator|=
name|buf_base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Append 4 bytes to mbuf  *  *  in:  mbuf, data pointer  * out:  zero = success  *  * Date first: 11/08/2000  last: 12/13/2000  */
end_comment

begin_function
name|int
name|idt_mbuf_append4
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|newdata
parameter_list|)
block|{
name|caddr_t
name|buf_base
decl_stmt|;
name|int
name|buf_size
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|space
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
comment|/* external storage */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 12/13/2000 we must not touch it */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
comment|/* internal storage, packet header */
name|buf_base
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|buf_size
operator|=
name|MHLEN
expr_stmt|;
block|}
else|else
block|{
name|buf_base
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
comment|/* internal storage, no packet header */
name|buf_size
operator|=
name|MLEN
expr_stmt|;
block|}
name|align
operator|=
operator|(
literal|4
operator|-
operator|(
operator|(
name|int
operator|)
name|buf_base
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
expr_stmt|;
name|buf_base
operator|+=
name|align
expr_stmt|;
name|buf_size
operator|-=
name|align
expr_stmt|;
name|buf_size
operator|&=
literal|0xfffffc
expr_stmt|;
name|space
operator|=
name|buf_size
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|space
operator|<
literal|4
condition|)
comment|/* enough space to add 4 bytes? */
return|return
operator|(
literal|1
operator|)
return|;
name|space
operator|-=
name|m
operator|->
name|m_data
operator|-
name|buf_base
expr_stmt|;
comment|/* get space at end */
if|if
condition|(
name|space
operator|<
literal|4
condition|)
block|{
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|buf_base
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|buf_base
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|newdata
argument_list|,
name|m
operator|->
name|m_data
operator|+
name|m
operator|->
name|m_len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get current base of data storage  *  *  in:  mbuf  * out:  base  *  * Date first: 11/16/2000  last: 11/16/2000  */
end_comment

begin_function
name|caddr_t
name|idt_mbuf_base
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
comment|/* external storage */
return|return
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
comment|/* internal storage, packet header */
return|return
operator|(
name|m
operator|->
name|m_pktdat
operator|)
return|;
return|return
operator|(
name|m
operator|->
name|m_dat
operator|)
return|;
comment|/* internal storage, no packet header */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Copy mbuf chain to new chain (aligned)  *  *  in:  mbuf  * out:  new mbuf chain, NULL=error  *  * Date first: 11/19/2000  last: 05/25/2001  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|idt_mbuf_copy
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|nbuf
decl_stmt|,
modifier|*
name|dbuf
decl_stmt|,
modifier|*
name|sbuf
decl_stmt|;
name|u_char
modifier|*
name|sptr
decl_stmt|;
name|int
name|slen
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|nbuf
operator|=
name|idt_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dbuf
operator|=
name|nbuf
expr_stmt|;
name|dbuf
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sbuf
operator|=
name|m
init|;
name|sbuf
operator|!=
name|NULL
condition|;
name|sbuf
operator|=
name|sbuf
operator|->
name|m_next
control|)
block|{
name|sptr
operator|=
name|sbuf
operator|->
name|m_data
expr_stmt|;
name|slen
operator|=
name|sbuf
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|slen
condition|)
block|{
name|clen
operator|=
name|slen
expr_stmt|;
if|if
condition|(
name|clen
operator|>
name|NICSTAR_LRG_SIZE
operator|-
name|dbuf
operator|->
name|m_len
condition|)
name|clen
operator|=
name|NICSTAR_LRG_SIZE
operator|-
name|dbuf
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|sptr
argument_list|,
name|dbuf
operator|->
name|m_data
operator|+
name|dbuf
operator|->
name|m_len
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|sptr
operator|+=
name|clen
expr_stmt|;
name|slen
operator|-=
name|clen
expr_stmt|;
name|dbuf
operator|->
name|m_len
operator|+=
name|clen
expr_stmt|;
if|if
condition|(
name|dbuf
operator|->
name|m_len
operator|>=
name|NICSTAR_LRG_SIZE
condition|)
block|{
name|dbuf
operator|->
name|m_next
operator|=
name|idt_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbuf
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dbuf
operator|=
name|dbuf
operator|->
name|m_next
expr_stmt|;
name|dbuf
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if need dest buf */
block|}
comment|/* while(slen) */
block|}
comment|/* for... source buf */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|nbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Prepend data to mbuf (no alignment done)  *  *  in:  mbuf, data pointer, data length  * out:  zero = success  *  * Date first: 11/15/2000  last: 12/13/2000  */
end_comment

begin_function
name|int
name|idt_mbuf_prepend
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|newdata
parameter_list|,
name|int
name|newlen
parameter_list|)
block|{
name|caddr_t
name|buf_base
decl_stmt|;
name|int
name|buf_size
decl_stmt|;
name|int
name|space
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
comment|/* external storage */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 12/13/2000 we must not touch it */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
comment|/* internal storage, packet header */
name|buf_base
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|buf_size
operator|=
name|MHLEN
expr_stmt|;
block|}
else|else
block|{
name|buf_base
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
comment|/* internal storage, no packet header */
name|buf_size
operator|=
name|MLEN
expr_stmt|;
block|}
name|space
operator|=
name|m
operator|->
name|m_data
operator|-
name|buf_base
expr_stmt|;
if|if
condition|(
name|space
operator|>=
name|newlen
condition|)
block|{
comment|/* already space at head of mbuf */
name|m
operator|->
name|m_data
operator|-=
name|newlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|newlen
expr_stmt|;
name|bcopy
argument_list|(
name|newdata
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|space
operator|=
name|buf_size
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* can we get the space by shifting? */
if|if
condition|(
name|space
operator|<
name|newlen
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_data
operator|+
name|newlen
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|newdata
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|newlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get amount of data used in mbuf chain  *  *  in:  mbuf chain  * out:  used space  *  * Date first: 11/10/2000  last: 11/10/2000  */
end_comment

begin_function
name|int
name|idt_mbuf_used
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mfirst
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|int
name|mbuf_used
decl_stmt|;
name|mbuf_used
operator|=
literal|0
expr_stmt|;
comment|/* used mbuf space */
for|for
control|(
name|m1
operator|=
name|mfirst
init|;
name|m1
operator|!=
name|NULL
condition|;
name|m1
operator|=
name|m1
operator|->
name|m_next
control|)
name|mbuf_used
operator|+=
name|m1
operator|->
name|m_len
expr_stmt|;
return|return
operator|(
name|mbuf_used
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Notes on transmit buffers:  *  *  According to the IDT Nicstar User Manual (version 1.0 2/26/1997), we must  *  follow these rules for the transmit buffers (page 66):  *  *  1.  The buffer length must not be zero.  *  2.  The buffer length must be a multiple of four bytes.  *  3.  The sum of the buffer lengths must be a multiple of 48 bytes if  *      it is a CS-PDU (eg AAL5).  *  4.  All buffers for a CS-PDU must be contiguous and grouped (no other  *      PDU buffers or even TSRs).  *  5.  For AAL5 PDUs, the buffer lengths must include 8 bytes for the  *      AAL5 length/control and CRC fields.  *  6.  For AAL5 PDUs, the buffer length of the last buffer must be> 8 bytes.  *  7.  For AAL5 PDUs, all buffers containing bytes for the last cell must  *      have the END_CS_PDU bit set to 1.  *  *  Also, from the IDT applications note ("FAQ") 77211_AN_97088.pdf file:  *    Page 5, under "General Technical Questions" (copied EXACTLY):  *  *  5).  Can the NicStar begin segmentation from a non-word aligned buffer?  *       No, the transmit buffer must point to a word aligned buffer.  *  *  Since the buffers MUST be word aligned and MUST be word lengths, we have  *  two potential problems with M_EXT mbufs:  *  *  1.  If the M_EXT mbuf has a non word aligned address, we have to copy  *      the whole thing to a fresh buffer.  Unless - the previous mbuf is  *      not M_EXT, and it is short by exactly the same amount.  Unlikely.  *  *  2.  If the M_EXT mbuf has a non word length, we have to push those bytes  *      to the next mbuf.  If the next mbuf is also M_EXT, we are stuck.  *      Unless - the extra bytes from both mbufs are exactly 4 bytes.  Then  *      we can MGET an empty buf to splice in between.  *  *  Also, these rules mean that if any buffer is not word-length, all of the  *  following buffers will need to be copied/shifted, unless one or more have  *  lengths off by the right amount to fix the earlier buffer.  *  *******************************************************************************  *  *  Put mbuf chain on transmit queue  *  *  in:  IDT device, mbuf chain, vpi, vci, flags (2 MPEG2 TS == 8 AAL5 cells)  * out:  (nothing)  *  * Date first: 11/08/2000  last: 05/30/2000  */
end_comment

begin_function
name|void
name|idt_transmit
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mfirst
parameter_list|,
name|int
name|vpi
parameter_list|,
name|int
name|vci
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|malign
decl_stmt|,
modifier|*
name|msend
decl_stmt|;
name|int
name|tot_size
decl_stmt|,
name|tot_scq
decl_stmt|,
name|x
decl_stmt|;
name|int
name|this_len
decl_stmt|;
name|int
name|padding
decl_stmt|;
name|connection
operator|=
name|idt_connect_find
argument_list|(
name|idt
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
comment|/* this VPI/VCI not open */
name|idt_transmit_drop
argument_list|(
name|idt
argument_list|,
name|mfirst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|connection
operator|->
name|queue
operator|==
name|NULL
condition|)
block|{
name|idt_transmit_drop
argument_list|(
name|idt
argument_list|,
name|mfirst
argument_list|)
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
condition|)
name|connection
operator|->
name|flg_mpeg2ts
operator|=
literal|1
expr_stmt|;
else|else
name|connection
operator|->
name|flg_mpeg2ts
operator|=
literal|0
expr_stmt|;
comment|/* 	 * New strategy:  assume that all the buffers are aligned and word 	 * length.  Drop out and handle exceptions below. 	 */
name|tot_size
operator|=
literal|0
expr_stmt|;
name|tot_scq
operator|=
literal|1
expr_stmt|;
name|malign
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|m1
operator|=
name|mfirst
init|;
name|m1
operator|!=
name|NULL
condition|;
name|m1
operator|=
name|m1
operator|->
name|m_next
control|)
block|{
name|this_len
operator|=
name|m1
operator|->
name|m_len
expr_stmt|;
name|tot_size
operator|+=
name|this_len
expr_stmt|;
name|tot_scq
operator|++
expr_stmt|;
if|if
condition|(
name|malign
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|m1
operator|->
name|m_data
argument_list|)
operator|&
literal|3
condition|)
block|{
comment|/* bad alignment */
name|malign
operator|=
name|m1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|this_len
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
comment|/* mbuf length is ok */
continue|continue;
if|if
condition|(
name|m1
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
comment|/* bad length (in middle) */
name|malign
operator|=
name|m1
expr_stmt|;
continue|continue;
block|}
name|padding
operator|=
literal|4
operator|-
operator|(
name|this_len
operator|&
literal|3
operator|)
expr_stmt|;
name|tot_size
operator|+=
name|padding
expr_stmt|;
name|m1
operator|->
name|m_len
operator|+=
name|padding
expr_stmt|;
break|break;
comment|/* last mbuf, so avoid the loop test */
block|}
if|if
condition|(
name|malign
operator|==
name|NULL
condition|)
block|{
comment|/* perfect packet, no copy needed */
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|tot_size
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|flg_mpeg2ts
condition|)
name|tot_scq
operator|+=
name|tot_size
operator|/
literal|376
expr_stmt|;
comment|/* more entries needed 							 * for split */
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|tot_scq
expr_stmt|;
if|if
condition|(
name|idt_queue_put
argument_list|(
name|connection
argument_list|,
name|mfirst
argument_list|)
condition|)
comment|/* put packet on TX 							 * queue */
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Cannot queue packet for %d/%d.\n"
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|queue
operator|->
name|mget
operator|==
name|mfirst
condition|)
comment|/* was the queue empty? */
name|idt_transmit_top
argument_list|(
name|idt
argument_list|,
name|connection
operator|->
name|queue
argument_list|)
expr_stmt|;
comment|/* IFF empty, prime it 									 * now */
return|return;
block|}
comment|/* 	 * Bad alignment or length, so fall through to old code... The first 	 * alignment problem is at 'malign' 	 */
if|if
condition|(
name|idt_sysctl_logvcs
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Bad TX buf alignment, len=%d.\n"
argument_list|,
name|tot_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt_mbuf_align
argument_list|(
name|mfirst
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"idt_transmit: cannot align first mbuf.\n"
argument_list|)
expr_stmt|;
name|idt_transmit_drop
argument_list|(
name|idt
argument_list|,
name|mfirst
argument_list|)
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* find first mbuf with bad alignment (if any) */
name|m0
operator|=
name|mfirst
expr_stmt|;
for|for
control|(
name|m1
operator|=
name|mfirst
operator|->
name|m_next
init|;
name|m1
operator|!=
name|NULL
condition|;
name|m0
operator|=
name|m1
operator|,
name|m1
operator|=
name|m1
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m1
operator|->
name|m_len
operator|&
literal|3
condition|)
break|break;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|m1
operator|->
name|m_data
argument_list|)
operator|&
literal|3
condition|)
break|break;
block|}
if|if
condition|(
name|m1
operator|!=
name|NULL
condition|)
block|{
name|m1
operator|=
name|idt_mbuf_copy
argument_list|(
name|idt
argument_list|,
name|m1
argument_list|)
expr_stmt|;
comment|/* copy the rest into new 						 * mbufs */
name|m0
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"idt_transmit: could not copy buffers.\n"
argument_list|)
expr_stmt|;
name|idt_transmit_drop
argument_list|(
name|idt
argument_list|,
name|mfirst
argument_list|)
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
return|return;
comment|/* FIX THIS - this path has been taken */
block|}
block|}
name|msend
operator|=
name|mfirst
expr_stmt|;
comment|/* The mbuf chain is aligned, now we need to pad to word length */
name|tot_size
operator|=
name|idt_mbuf_used
argument_list|(
name|msend
argument_list|)
expr_stmt|;
comment|/* forget the pkthdr length... */
name|msend
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|tot_size
expr_stmt|;
name|padding
operator|=
operator|(
literal|4
operator|-
operator|(
name|tot_size
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|padding
condition|)
block|{
for|for
control|(
name|m1
operator|=
name|msend
init|;
name|m1
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m1
operator|=
name|m1
operator|->
name|m_next
control|)
empty_stmt|;
name|m1
operator|->
name|m_len
operator|+=
name|padding
expr_stmt|;
block|}
name|x
operator|=
literal|1
expr_stmt|;
comment|/* now calculate the SCQ entries needed */
for|for
control|(
name|m1
operator|=
name|msend
init|;
name|m1
operator|!=
name|NULL
condition|;
name|m1
operator|=
name|m1
operator|->
name|m_next
control|)
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|flg_mpeg2ts
condition|)
name|x
operator|+=
name|tot_size
operator|/
literal|376
expr_stmt|;
comment|/* more entries needed for split */
name|msend
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|x
expr_stmt|;
comment|/* now we have an mbuf chain, from *msend to *m1 ready to go */
if|if
condition|(
name|idt_queue_put
argument_list|(
name|connection
argument_list|,
name|msend
argument_list|)
condition|)
comment|/* put packet on TX queue */
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Cannot queue packet for %d/%d.\n"
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|queue
operator|->
name|mget
operator|==
name|msend
condition|)
comment|/* was the queue empty? */
name|idt_transmit_top
argument_list|(
name|idt
argument_list|,
name|connection
operator|->
name|queue
argument_list|)
expr_stmt|;
comment|/* IFF empty, prime it 								 * now */
block|}
end_function

begin_comment
comment|/*  Notes on mbuf usage in the transmit queue:  *  *  m_pkthdr.rcvif       Connection pointer (set by idt_queue_put)  *  m_pkthdr.len         Length of PDU  *  m_pkthdr.header      TX queue pointer (06/01/2001)  *  m_pkthdr.csum_flags  Unused, keep zero  *  m_pkthdr.csum_data   Number of SCQ entries needed or used  *  m_pkthdr.aux         Unused, keep NULL  *  *******************************************************************************  *  *  Drop transmit mbuf chain and update counters  *  *  in:  IDT device, mbuf chain  * out:  (nothing)  *  * Date first: 11/08/2000  last: 11/08/2000  */
end_comment

begin_function
name|void
name|idt_transmit_drop
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mfirst
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|mesglen
decl_stmt|;
name|mesglen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mfirst
operator|!=
name|NULL
condition|)
block|{
name|mesglen
operator|+=
name|mfirst
operator|->
name|m_len
expr_stmt|;
name|next
operator|=
name|m_free
argument_list|(
name|mfirst
argument_list|)
expr_stmt|;
name|mfirst
operator|=
name|next
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"dropping transmit packet, size=%d\n"
argument_list|,
name|mesglen
argument_list|)
expr_stmt|;
name|idt
operator|->
name|stats_oerrors
operator|++
expr_stmt|;
comment|/* 12/15/2000 */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Put mbuf chain on transmit queue  *  *  in:  IDT device, TX_QUEUE  * out:  (nothing)  *  * Date first: 12/03/2000  last: 06/01/2001  */
end_comment

begin_function
name|void
name|idt_transmit_top
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|TX_QUEUE
modifier|*
name|txqueue
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|static
name|int
name|padding
index|[
literal|13
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|scq_space
decl_stmt|;
name|int
name|val
decl_stmt|,
name|val1
decl_stmt|,
name|val3
decl_stmt|,
name|val4
decl_stmt|;
name|int
name|count
decl_stmt|,
name|mlen
decl_stmt|,
name|tlen
decl_stmt|,
name|pad
decl_stmt|;
name|char
modifier|*
name|mptr
decl_stmt|;
name|int
name|pdulen
decl_stmt|;
name|int
name|vci
decl_stmt|,
name|vpi
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
comment|/* 12/12/2000 */
return|return;
if|if
condition|(
name|txqueue
operator|->
name|mget
operator|==
name|NULL
condition|)
comment|/* check for empty queue */
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|scq_space
operator|=
name|txqueue
operator|->
name|scq_len
operator|-
name|txqueue
operator|->
name|scq_cur
expr_stmt|;
comment|/* Now we can add the queue entries for the PDUs */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|top
operator|=
name|txqueue
operator|->
name|mget
expr_stmt|;
comment|/* next available mbuf */
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|top
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+
literal|4
operator|>
name|scq_space
condition|)
break|break;
comment|/* not enough space for this PDU */
name|top
operator|=
name|idt_queue_get
argument_list|(
name|txqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
break|break;
name|connection
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|top
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|vpi
operator|=
name|connection
operator|->
name|vpi
expr_stmt|;
name|vci
operator|=
name|connection
operator|->
name|vci
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
operator|(
name|void
operator|*
operator|)
name|connection
operator|->
name|queue
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0
expr_stmt|;
comment|/* track actual number of SCQ 						 * entries used */
name|tlen
operator|=
name|top
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
switch|switch
condition|(
name|connection
operator|->
name|aal
condition|)
block|{
case|case
name|ATM_AAL0
case|:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ATM_AAL3_4
case|:
name|val
operator|=
literal|0x04000000
expr_stmt|;
break|break;
case|case
name|ATM_AAL5
case|:
name|val
operator|=
literal|0x08000000
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"bad AAL for %d/%d\n"
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|val
operator||=
name|txqueue
operator|->
name|vbr_m
operator|<<
literal|23
expr_stmt|;
name|val
operator||=
name|txqueue
operator|->
name|vbr_n
operator|<<
literal|16
expr_stmt|;
name|val4
operator|=
operator|(
name|vpi
operator|<<
literal|20
operator|)
operator||
operator|(
name|vci
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|flg_clp
condition|)
name|val4
operator||=
literal|1
expr_stmt|;
comment|/* set CLP flag */
comment|/* 		 * Now we are ready to start mapping the mbuf(s) to transmit 		 * buffer descriptors.  If the MPEG2TS flag is set, we want 		 * to create AAL5 PDUs of exactly 384 data bytes each. 		 */
name|pdulen
operator|=
name|top
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* default case: don't split 						 * PDU */
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|flg_mpeg2ts
condition|)
block|{
if|if
condition|(
operator|(
name|pdulen
operator|%
literal|376
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* correct multiple */
name|pdulen
operator|=
literal|376
expr_stmt|;
comment|/* cut off every pdu at 374 						 * data bytes */
name|pad
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Bad MPEG2 PDU buffer (%d bytes).\n"
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
block|}
name|val3
operator|=
name|pdulen
expr_stmt|;
comment|/* actual (unpadded) PDU length */
name|pdulen
operator|+=
operator|(
literal|4
operator|-
operator|(
name|pdulen
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|pad
operator|==
literal|0
condition|)
block|{
comment|/* normal padding (PDU not split) */
name|pad
operator|=
name|pdulen
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|aal
operator|==
name|ATM_AAL5
condition|)
name|pad
operator|+=
literal|8
expr_stmt|;
name|pad
operator|=
literal|48
operator|-
operator|(
name|pad
operator|%
literal|48
operator|)
expr_stmt|;
if|if
condition|(
name|pad
operator|==
literal|48
condition|)
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|aal
operator|==
name|ATM_AAL5
condition|)
name|pad
operator|+=
literal|8
expr_stmt|;
comment|/* pad of up to 52 is 						 * possible/neccessary */
block|}
name|tlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|top
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
while|while
condition|(
operator|(
name|mlen
operator|=
name|m
operator|->
name|m_len
operator|)
condition|)
block|{
if|if
condition|(
name|mlen
operator|+
name|tlen
operator|>
name|pdulen
condition|)
name|mlen
operator|=
name|pdulen
operator|-
name|tlen
expr_stmt|;
comment|/* how much of this 								 * buffer can we use? */
name|mptr
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
name|tlen
operator|+=
name|mlen
expr_stmt|;
comment|/* length of this PDU */
name|m
operator|->
name|m_len
operator|-=
name|mlen
expr_stmt|;
comment|/* bytes remaining in 							 * mbuf */
name|m
operator|->
name|m_data
operator|+=
name|mlen
expr_stmt|;
comment|/* new data pointer */
name|val1
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|tlen
operator|>
name|pdulen
operator|+
name|pad
operator|-
literal|48
condition|)
comment|/* is this buffer in the 								 * last cell? */
name|val1
operator||=
literal|0x40000000
expr_stmt|;
comment|/* last buffer in PDU */
if|if
condition|(
name|tlen
operator|==
name|pdulen
condition|)
block|{
comment|/* end of PDU, so figure 							 * padding needed */
name|idt
operator|->
name|stats_opdus
operator|++
expr_stmt|;
comment|/* 12/15/2000 */
name|idt
operator|->
name|stats_obytes
operator|+=
name|pdulen
expr_stmt|;
comment|/* 12/15/2000 */
name|connection
operator|->
name|vccinf
operator|->
name|vc_opdus
operator|++
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_obytes
operator|+=
name|pdulen
expr_stmt|;
name|tlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pad
operator|<=
literal|8
condition|)
name|mlen
operator|+=
name|pad
expr_stmt|;
comment|/* just "add" padding to 								 * this buffer */
block|}
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val1
operator||
name|mlen
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|vtophys
argument_list|(
name|mptr
argument_list|)
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val3
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val4
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_next
operator|-
name|txqueue
operator|->
name|scq_base
operator|>=
name|txqueue
operator|->
name|scq_len
operator|*
literal|4
condition|)
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|scq_space
operator|--
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|++
expr_stmt|;
comment|/* 12/22/2000 */
comment|/* 				 * if we need more than 8 bytes of padding, 				 * use the zero-filled buffer defined above. 				 */
if|if
condition|(
name|tlen
operator|==
literal|0
operator|&&
name|pad
operator|>
literal|8
condition|)
block|{
comment|/* end of PDU, do we 								 * need padding? */
name|val1
operator||=
literal|0x40000000
expr_stmt|;
comment|/* last buffer in PDU */
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val1
operator||
name|pad
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|vtophys
argument_list|(
name|padding
argument_list|)
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val3
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val4
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_next
operator|-
name|txqueue
operator|->
name|scq_base
operator|>=
name|txqueue
operator|->
name|scq_len
operator|*
literal|4
condition|)
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|scq_space
operator|--
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|++
expr_stmt|;
comment|/* 12/22/2000 */
block|}
block|}
block|}
comment|/* 		 * Now that we have set up the descriptors, add the entry 		 * for Transmit Status Request so we know when the PDU(s) 		 * are done. 		 */
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
literal|0xa0000000
expr_stmt|;
comment|/* TSR with interrupt */
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
operator|(
name|u_long
operator|)
name|top
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_next
operator|-
name|txqueue
operator|->
name|scq_base
operator|>=
name|txqueue
operator|->
name|scq_len
operator|*
literal|4
condition|)
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|scq_space
operator|--
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|++
expr_stmt|;
comment|/* 12/22/2000 */
name|count
operator|++
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|+=
name|top
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
block|}
comment|/* 	 * 05/31/2001: Optimization: Since writing to SRAM is very 	 * expensive, we will only do this when the pointer is stale (half 	 * of the queue). If the queue is less than 1/4 full, then write the 	 * pointer anyway. 	 */
if|if
condition|(
name|idt_sysctl_qptrhold
condition|)
block|{
name|scq_space
operator|=
name|txqueue
operator|->
name|scq_next
operator|-
name|txqueue
operator|->
name|scq_last
expr_stmt|;
comment|/* number pending */
name|scq_space
operator|/=
literal|4
expr_stmt|;
if|if
condition|(
name|scq_space
operator|<
literal|0
condition|)
name|scq_space
operator|+=
name|txqueue
operator|->
name|scq_len
expr_stmt|;
if|if
condition|(
name|scq_space
operator|*
literal|2
operator|<
name|txqueue
operator|->
name|scq_len
operator|&&
comment|/* less than half 							 * pending */
name|txqueue
operator|->
name|scq_cur
operator|>
name|txqueue
operator|->
name|scq_len
operator|/
literal|4
condition|)
comment|/* and queue is active */
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
comment|/* we need to update the queue pointer */
name|nicstar_sram_wr
argument_list|(
name|idt
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|1
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  Once a packet has been put in the Segmentation Channel Queue, it will  *  be sent, and then the mbuf will harvested by idt_intr_tsq().  While it  *  is in the SCQ, m_pkthdr.header is the pointer to the TX queue.  This is  *  important because if the connection is closed while there are still  *  mbufs in the SCQ, idt_intr_tsq() still needs to update the TX queue.  *  ******************************************************************************  *  *  Handle entries in Transmit Status Queue (end of PDU interrupt or TSQ full)  *  *  in:  IDT device  *  *  Date first: 12/04/2000  last: 06/10/2001  */
end_comment

begin_function
specifier|static
name|void
name|idt_intr_tsq
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|u_long
modifier|*
name|tsq_ptr
decl_stmt|;
name|u_long
name|val
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|tsq_ptr
operator|=
name|idt
operator|->
name|tsq_head
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|tsq_ptr
index|[
literal|1
index|]
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|tsq_ptr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* first test for timer rollover entry */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|m
operator|&
literal|0x000000ff
operator|)
condition|)
comment|/* now do sanity check 							 * on the mbuf ptr */
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"DANGER! bad mbuf (%x), stamp=%x\n"
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|int
operator|)
name|tsq_ptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|connection
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|txqueue
operator|=
operator|(
name|TX_QUEUE
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|header
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_cur
operator|<
literal|0
operator|||
name|txqueue
operator|->
name|scq_cur
operator|>
name|txqueue
operator|->
name|scq_len
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"DANGER! scq_cur is %d\n"
argument_list|,
name|txqueue
operator|->
name|scq_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|idt_transmit_top
argument_list|(
name|idt
argument_list|,
name|txqueue
argument_list|)
expr_stmt|;
comment|/* move more into queue */
block|}
block|}
name|tsq_ptr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tsq_ptr
index|[
literal|1
index|]
operator|=
literal|0x80000000
expr_stmt|;
comment|/* reset TSQ entry */
name|tsq_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tsq_ptr
operator|>=
name|idt
operator|->
name|tsq_base
operator|+
name|idt
operator|->
name|tsq_size
operator|*
literal|2
condition|)
name|tsq_ptr
operator|=
name|idt
operator|->
name|tsq_base
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|idt
operator|->
name|tsq_head
operator|=
name|tsq_ptr
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|val
operator|=
operator|(
name|int
operator|)
name|tsq_ptr
operator|-
operator|(
name|int
operator|)
name|idt
operator|->
name|tsq_base
expr_stmt|;
name|val
operator|-=
literal|8
expr_stmt|;
comment|/* always stay one behind */
name|val
operator|&=
literal|0x001ff8
expr_stmt|;
operator|*
name|idt
operator|->
name|reg_tsqh
operator|=
name|val
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  There is a problem with the pointer rollover where the SAR will think the  *  TSQ buffer is full (forever?) unless we hold the head pointer back.  *  This is not mentioned in the 77211 docs, but is a resolved issue in  *  revision D of the 77252 chips (see 77252 errata).  *  *  If a connection is closed while there are still mbufs in the TX queue,  *  the connection TX queue pointer will be NULL.  That is why we have a  *  special copy of the pointer in m_pkthdr.header.  Also, idt_transmit_top()  *  will allow the TX queue for that connection to empty properly.  *  *  It is possible for a TSQ entry to be 0x00ffffff/0x00ffffff, which is  *  obviously not an mbuf and not a timer rollover entry.  We now have an  *  mbuf sanity check for this.  *  ******************************************************************************  *  *    nicstar_itrx ( card )  *  *    service error in transmitting PDU interrupt.  * */
end_comment

begin_function
specifier|static
name|void
name|nicstar_itrx
parameter_list|(
name|nicstar_reg_t
modifier|*
name|idt
parameter_list|)
block|{
comment|/* trace mbuf and release */
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Raw cell receive interrupt  *  *    service raw cell reception interrupt.  *  */
end_comment

begin_function
specifier|static
name|void
name|nicstar_rawc
parameter_list|(
name|nicstar_reg_t
modifier|*
name|idt
parameter_list|)
block|{
name|u_long
name|ptr_tail
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|qmbuf
decl_stmt|;
name|u_long
modifier|*
name|qptr
decl_stmt|;
name|u_long
name|next_mbuf
decl_stmt|;
name|u_long
name|next_phys
decl_stmt|;
if|if
condition|(
name|idt
operator|->
name|raw_headm
operator|==
name|NULL
operator|||
name|idt
operator|->
name|raw_headp
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"RAW cell received, buffers not ready (%x/%x).\n"
argument_list|,
operator|(
name|int
operator|)
name|idt
operator|->
name|raw_headm
argument_list|,
operator|(
name|int
operator|)
name|idt
operator|->
name|raw_headp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr_tail
operator|=
operator|*
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGRAWT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr_tail
operator|&
literal|0xfffff800
operator|)
operator|==
name|idt
operator|->
name|raw_headp
condition|)
return|return;
comment|/* still in the same large buffer */
if|if
condition|(
operator|(
name|ptr_tail
operator|&
literal|0x7ff
operator|)
operator|<
literal|64
condition|)
comment|/* wait until something in new buffer */
return|return;
name|qmbuf
operator|=
name|idt
operator|->
name|raw_headm
expr_stmt|;
name|qptr
operator|=
operator|(
name|u_long
operator|*
operator|)
name|qmbuf
operator|->
name|m_data
expr_stmt|;
name|next_mbuf
operator|=
name|qptr
index|[
literal|31
operator|*
literal|16
operator|+
literal|1
index|]
expr_stmt|;
comment|/* next handle (virtual) */
name|next_phys
operator|=
name|qptr
index|[
literal|31
operator|*
literal|16
operator|+
literal|0
index|]
expr_stmt|;
comment|/* next physical address */
comment|/* if we want to do anything with the raw data, this is the place  */
name|idt_mcheck_rem
argument_list|(
name|idt
argument_list|,
name|qmbuf
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|qmbuf
argument_list|)
expr_stmt|;
name|idt
operator|->
name|raw_headm
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|next_mbuf
expr_stmt|;
name|idt
operator|->
name|raw_headp
operator|=
name|next_phys
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  Handle AAL5 PDU length  *  *  in:  IDT device, first mbuf in chain, last mbuf  * out:  zero = success, nz = failure (mbuf chain freed)  *  * Date first: 11/18/2000  last: 12/14/2000  */
end_comment

begin_function
name|int
name|idt_receive_aal5
parameter_list|(
name|IDT
modifier|*
name|idt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mfirst
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mdata
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|aal5len
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|aal5len
operator|=
name|mdata
operator|->
name|m_data
operator|+
name|mdata
operator|->
name|m_len
operator|-
literal|6
expr_stmt|;
comment|/* aal5 length = 16 bits */
name|plen
operator|=
name|aal5len
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|aal5len
index|[
literal|1
index|]
expr_stmt|;
name|diff
operator|=
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|plen
expr_stmt|;
comment|/* number of bytes to trim */
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"AAL5 PDU length (%d) greater than cells (%d), discarding\n"
argument_list|,
name|plen
argument_list|,
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mfirst
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|mdata
operator|->
name|m_len
operator|<
name|diff
condition|)
block|{
comment|/* last mbuf not big enough */
name|diff
operator|-=
name|mdata
operator|->
name|m_len
expr_stmt|;
name|m2
operator|=
name|mdata
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdata
operator|==
name|mfirst
condition|)
block|{
comment|/* we just tossed the whole PDU */
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"AAL5 PDU length failed, discarding.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* the packetheadr length was bad! */
block|}
for|for
control|(
name|mdata
operator|=
name|mfirst
init|;
name|mdata
operator|->
name|m_next
operator|!=
name|m2
condition|;
name|mdata
operator|=
name|mdata
operator|->
name|m_next
control|)
empty_stmt|;
name|mdata
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* remove old link to free'd mbuf */
block|}
name|mdata
operator|->
name|m_len
operator|-=
name|diff
expr_stmt|;
comment|/* trim last mbuf */
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 12/14/2000: Removed "pruning" log message.  *  *****************************************************************************  *  *    nicstar_recv ( card )  *  *    rebuilds PDUs from entries in the Recieve Status Queue.  *  */
end_comment

begin_struct
struct|struct
name|rsq_entry
block|{
name|u_long
name|vpivci
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mdata
decl_stmt|;
name|u_long
name|crc
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|nicstar_recv
parameter_list|(
name|nicstar_reg_t
modifier|*
name|idt
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|regh
init|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|idt
operator|->
name|virt_baseaddr
operator|+
name|REGRSQH
operator|)
decl_stmt|;
name|struct
name|rsq_entry
modifier|*
name|rsq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mdata
decl_stmt|,
modifier|*
name|mptr
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|u_long
name|crc
decl_stmt|;
name|int
name|vpi
decl_stmt|;
name|int
name|vci
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|int
name|x
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|rsq
operator|=
operator|(
expr|struct
name|rsq_entry
operator|*
operator|)
operator|(
name|idt
operator|->
name|fixbuf
operator|+
literal|0x2000
operator|+
operator|(
name|idt
operator|->
name|rsqh
operator|&
literal|0x1ffc
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|rsq
operator|->
name|flags
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|rsq
operator|->
name|flags
operator|&
literal|0x80000000
condition|)
block|{
name|vpi
operator|=
name|rsq
operator|->
name|vpivci
operator|>>
literal|16
expr_stmt|;
comment|/* first, grab the RSQ data */
name|vci
operator|=
name|rsq
operator|->
name|vpivci
operator|&
literal|0xffff
expr_stmt|;
name|mdata
operator|=
name|rsq
operator|->
name|mdata
expr_stmt|;
name|crc
operator|=
name|rsq
operator|->
name|crc
expr_stmt|;
name|flags
operator|=
name|rsq
operator|->
name|flags
expr_stmt|;
name|clen
operator|=
operator|(
name|flags
operator|&
literal|0x1ff
operator|)
operator|*
literal|48
expr_stmt|;
name|rsq
operator|->
name|vpivci
operator|=
literal|0
expr_stmt|;
comment|/* now recycle the RSQ entry */
name|rsq
operator|->
name|mdata
operator|=
name|NULL
expr_stmt|;
name|rsq
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|rsq
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* turn off valid bit */
name|rsq
operator|++
expr_stmt|;
if|if
condition|(
name|rsq
operator|==
operator|(
expr|struct
name|rsq_entry
operator|*
operator|)
operator|(
name|idt
operator|->
name|fixbuf
operator|+
literal|0x4000
operator|)
condition|)
name|rsq
operator|=
operator|(
expr|struct
name|rsq_entry
operator|*
operator|)
operator|(
name|idt
operator|->
name|fixbuf
operator|+
literal|0x2000
operator|)
expr_stmt|;
name|idt_mcheck_rem
argument_list|(
name|idt
argument_list|,
name|mdata
argument_list|)
expr_stmt|;
name|connection
operator|=
name|idt_connect_find
argument_list|(
name|idt
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
comment|/* we don't want this PDU */
name|printf
argument_list|(
literal|"nicstar_recv: No connection %d/%d - discarding packet.\n"
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
comment|/* throw mbuf away */
continue|continue;
block|}
name|mdata
operator|->
name|m_len
operator|=
name|clen
expr_stmt|;
name|mptr
operator|=
name|connection
operator|->
name|recv
expr_stmt|;
if|if
condition|(
name|mptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mdata
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|connection
operator|->
name|recv
operator|=
name|mdata
expr_stmt|;
else|else
block|{
name|idt
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
comment|/* 12/15/2000 */
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mptr
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
comment|/* find last mbuf in 							 * chain */
name|mptr
operator|=
name|mptr
operator|->
name|m_next
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|25
condition|)
break|break;
block|}
if|if
condition|(
name|x
operator|>
literal|25
condition|)
block|{
name|mptr
operator|=
name|connection
operator|->
name|recv
expr_stmt|;
name|printf
argument_list|(
literal|"nicstar_recv: invalid mbuf chain - probable corruption!\n"
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
name|idt
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
comment|/* 12/15/2000 */
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|mptr
operator|->
name|m_next
operator|=
name|mdata
expr_stmt|;
block|}
name|connection
operator|->
name|rlen
operator|+=
name|clen
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x2000
condition|)
block|{
comment|/* end of PDU */
name|mptr
operator|=
name|connection
operator|->
name|recv
expr_stmt|;
comment|/* one or more mbufs 							 * will be here */
name|clen
operator|=
name|connection
operator|->
name|rlen
expr_stmt|;
comment|/* length based on cell 							 * count */
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|clen
expr_stmt|;
name|mptr
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|mptr
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mptr
operator|->
name|m_pkthdr
operator|.
name|aux
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"received pkthdr.aux=%x\n"
argument_list|,
operator|(
name|int
operator|)
name|mptr
operator|->
name|m_pkthdr
operator|.
name|aux
argument_list|)
expr_stmt|;
name|mptr
operator|->
name|m_pkthdr
operator|.
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mptr
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"received pkthdr.csum_flags=%x\n"
argument_list|,
name|mptr
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|)
expr_stmt|;
name|mptr
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x200
operator|&&
comment|/* bad CRC */
name|idt
operator|->
name|flg_igcrc
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"nicstar_recv: Bad CRC - discarding PDU: %d/%d\n"
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|idt
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
comment|/* 12/15/2000 */
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|connection
operator|->
name|aal
operator|==
name|ATM_AAL5
condition|)
block|{
if|if
condition|(
name|idt_receive_aal5
argument_list|(
name|idt
argument_list|,
name|mptr
argument_list|,
name|mdata
argument_list|)
condition|)
comment|/* adjust for AAL5 									 * length */
continue|continue;
block|}
name|idt
operator|->
name|stats_ipdus
operator|++
expr_stmt|;
comment|/* 12/15/2000 */
name|idt
operator|->
name|stats_ibytes
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 12/15/2000 */
name|connection
operator|->
name|vccinf
operator|->
name|vc_ipdus
operator|++
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_ibytes
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|idt_receive
argument_list|(
name|idt
argument_list|,
name|mptr
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|connection
operator|->
name|rlen
operator|>
name|connection
operator|->
name|maxpdu
condition|)
block|{
comment|/* this packet is insane */
name|printf
argument_list|(
literal|"nicstar_recv: Bad packet, len=%d - discarding.\n"
argument_list|,
name|connection
operator|->
name|rlen
argument_list|)
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|idt
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
comment|/* 12/15/2000 */
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mptr
argument_list|)
expr_stmt|;
block|}
comment|/* end of PDU */
block|}
name|idt
operator|->
name|rsqh
operator|=
name|vtophys
argument_list|(
operator|(
name|u_long
operator|)
name|rsq
argument_list|)
operator|&
literal|0x1ffc
expr_stmt|;
operator|*
name|regh
operator|=
operator|(
name|idt
operator|->
name|rsqh
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rsq_entry
argument_list|)
operator|)
operator|&
literal|0x1ff0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Physical Interrupt handler  *  *  service phyical interrupt.  *  */
end_comment

begin_function
specifier|static
name|void
name|nicstar_phys
parameter_list|(
name|nicstar_reg_t
modifier|*
name|idt
parameter_list|)
block|{
name|u_long
name|t
decl_stmt|;
if|if
condition|(
name|idt
operator|->
name|flg_le25
condition|)
block|{
name|nicstar_util_rd
argument_list|(
name|idt
argument_list|,
literal|0x01
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* get interrupt cause */
if|if
condition|(
name|t
operator|&
literal|0x01
condition|)
block|{
name|nicstar_util_wr
argument_list|(
name|idt
argument_list|,
literal|1
argument_list|,
literal|0x02
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* reset rx fifo */
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"PHY cleared.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Physical interrupt.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Status register values  */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_RSQAF
value|0x0002
end_define

begin_comment
comment|/* receive status queue almost full */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_LBMT
value|0x0004
end_define

begin_comment
comment|/* large buffer queue empty */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_SBMT
value|0x0008
end_define

begin_comment
comment|/* small buffer queue empty */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_RAWC
value|0x0010
end_define

begin_comment
comment|/* raw cell interrupt */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_EPDU
value|0x0020
end_define

begin_comment
comment|/* end of PDU interrupt */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_PHY
value|0x0400
end_define

begin_comment
comment|/* physical interrupt */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_TIME
value|0x0800
end_define

begin_comment
comment|/* timer overflow interrupt */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_TSQAF
value|0x1000
end_define

begin_comment
comment|/* transmit status queue almost full */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_TXIN
value|0x4000
end_define

begin_comment
comment|/* TX PDU incomplete */
end_comment

begin_define
define|#
directive|define
name|STAT_REG_TXOK
value|0x8000
end_define

begin_comment
comment|/* TX status indicator */
end_comment

begin_comment
comment|/******************************************************************************  *  *  Interrupt handler  *  *    service card interrupt.  *  *    nicstar_intr ( card )  */
end_comment

begin_function
name|void
name|nicstar_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|IDT
modifier|*
name|idt
decl_stmt|;
specifier|volatile
name|u_long
name|stat_val
decl_stmt|,
name|config_val
decl_stmt|;
name|int
name|int_flags
decl_stmt|;
specifier|volatile
name|int
name|i
decl_stmt|;
name|idt
operator|=
operator|(
name|IDT
operator|*
operator|)
name|arg
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|config_val
operator|=
operator|*
name|idt
operator|->
name|reg_cfg
expr_stmt|;
name|stat_val
operator|=
operator|*
name|idt
operator|->
name|reg_stat
expr_stmt|;
name|int_flags
operator|=
name|STAT_REG_TSQAF
operator||
comment|/* transmit status queue almost full */
name|STAT_REG_RSQAF
operator||
comment|/* receive status queue almost full */
name|STAT_REG_RAWC
operator||
comment|/* raw cell interrupt */
name|STAT_REG_EPDU
operator||
comment|/* end of PDU interrupt */
name|STAT_REG_TIME
operator||
comment|/* timer overflow interrupt */
name|STAT_REG_TXIN
operator||
comment|/* TX PDU incomplete */
name|STAT_REG_TXOK
expr_stmt|;
comment|/* TX status indicator */
if|if
condition|(
name|idt
operator|->
name|flg_le25
condition|)
name|int_flags
operator||=
name|STAT_REG_PHY
expr_stmt|;
comment|/* include flag for physical 						 * interrupt */
if|if
condition|(
name|stat_val
operator|&
operator|(
name|STAT_REG_LBMT
operator||
name|STAT_REG_SBMT
operator|)
condition|)
block|{
comment|/* buffer queue(s) empty */
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_SBMT
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"small free buffer queue empty.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_LBMT
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"large free buffer queue empty.\n"
argument_list|)
expr_stmt|;
name|nicstar_ld_rcv_buf
argument_list|(
name|idt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idt
operator|->
name|reg_stat
operator|&
name|STAT_REG_LBMT
condition|)
block|{
comment|/* still empty, so 							 * disable IRQ */
name|config_val
operator|&=
operator|~
literal|0x01000000
expr_stmt|;
operator|*
name|idt
operator|->
name|reg_cfg
operator|=
name|config_val
expr_stmt|;
block|}
block|}
comment|/* loop until no more interrupts to service */
while|while
condition|(
name|stat_val
operator|&
name|int_flags
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|100
condition|)
break|break;
operator|*
name|idt
operator|->
name|reg_stat
operator|=
name|stat_val
operator|&
name|int_flags
expr_stmt|;
comment|/* clear status bits */
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_EPDU
condition|)
block|{
comment|/* receive PDU */
name|nicstar_recv
argument_list|(
name|idt
argument_list|)
expr_stmt|;
name|nicstar_ld_rcv_buf
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* replace buffers, 							 * moved here 11/14/2000 */
block|}
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_RAWC
condition|)
block|{
comment|/* raw cell */
name|nicstar_rawc
argument_list|(
name|idt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_TXOK
condition|)
block|{
comment|/* transmit complete */
name|idt_intr_tsq
argument_list|(
name|idt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_TXIN
condition|)
block|{
comment|/* bad transmit */
name|nicstar_itrx
argument_list|(
name|idt
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"Bad transmit.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_TIME
condition|)
block|{
comment|/* timer wrap */
name|idt
operator|->
name|timer_wrap
operator|++
expr_stmt|;
name|idt_intr_tsq
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* check the TSQ */
name|nicstar_recv
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* check the receive queue */
if|if
condition|(
name|idt_sysctl_logbufs
condition|)
name|idt_status_bufs
argument_list|(
name|idt
argument_list|)
expr_stmt|;
comment|/* show the buffer 							 * status */
block|}
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_PHY
condition|)
block|{
comment|/* physical interrupt */
name|nicstar_phys
argument_list|(
name|idt
argument_list|)
expr_stmt|;
operator|*
name|idt
operator|->
name|reg_stat
operator|=
name|STAT_REG_PHY
expr_stmt|;
comment|/* clear the int flag */
block|}
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_RSQAF
condition|)
block|{
comment|/* RSQ almost full */
name|nicstar_recv
argument_list|(
name|idt
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"warning, RSQ almost full.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idt
operator|->
name|reg_stat
operator|&
name|STAT_REG_RSQAF
condition|)
block|{
comment|/* RSQ full */
name|printf
argument_list|(
literal|"RSQ is full, disabling interrupt.\n"
argument_list|)
expr_stmt|;
name|config_val
operator|&=
literal|0x00000800
expr_stmt|;
operator|*
name|idt
operator|->
name|reg_cfg
operator|=
name|config_val
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat_val
operator|&
name|STAT_REG_TSQAF
condition|)
block|{
comment|/* TSQ almost full */
name|idt_intr_tsq
argument_list|(
name|idt
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"warning, TSQ almost full.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idt
operator|->
name|reg_stat
operator|&
name|STAT_REG_TSQAF
condition|)
block|{
name|printf
argument_list|(
literal|"TSQ is full, disabling interrupt.\n"
argument_list|)
expr_stmt|;
name|config_val
operator|&=
operator|~
literal|0x00000002
expr_stmt|;
operator|*
name|idt
operator|->
name|reg_cfg
operator|=
name|config_val
expr_stmt|;
block|}
block|}
name|stat_val
operator|=
operator|*
name|idt
operator|->
name|reg_stat
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
literal|50
condition|)
name|device_printf
argument_list|(
name|idt
operator|->
name|dev
argument_list|,
literal|"i=%3d, status=%08x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|stat_val
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

