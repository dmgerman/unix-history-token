begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Name   : sky2.c  * Project: Gigabit Ethernet Driver for FreeBSD 5.x/6.x  * Version: $Revision: 1.23 $  * Date   : $Date: 2005/12/22 09:04:11 $  * Purpose: Main driver source file  *  *****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  *  *	LICENSE:  *	Copyright (C) Marvell International Ltd. and/or its affiliates  *  *	The computer program files contained in this folder ("Files")  *	are provided to you under the BSD-type license terms provided  *	below, and any use of such Files and any derivative works  *	thereof created by you shall be governed by the following terms  *	and conditions:  *  *	- Redistributions of source code must retain the above copyright  *	  notice, this list of conditions and the following disclaimer.  *	- Redistributions in binary form must reproduce the above  *	  copyright notice, this list of conditions and the following  *	  disclaimer in the documentation and/or other materials provided  *	  with the distribution.  *	- Neither the name of Marvell nor the names of its contributors  *	  may be used to endorse or promote products derived from this  *	  software without specific prior written permission.  *  *	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  *	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  *	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  *	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  *	BUT NOT LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES;  *	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  *	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  *	OF THE POSSIBILITY OF SUCH DAMAGE.  *	/LICENSE  *  *****************************************************************************/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 1999, 2000  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003 Nathan L. Binkert<binkertn@umich.edu>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Device driver for the Marvell Yukon II Ethernet controller.  * Due to lack of documentation, this driver is based on the code from  * sk(4) and Marvell's myk(4) driver for FreeBSD 5.x.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/msk/if_mskreg.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|msk
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|msk
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|msk
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* "device miibus" required.  See GENERIC if you get errors here. */
end_comment

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/* Tunables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msi_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.msk.msi_disable"
argument_list|,
operator|&
name|msi_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|legacy_intr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.msk.legacy_intr"
argument_list|,
operator|&
name|legacy_intr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|jumbo_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.msk.jumbo_disable"
argument_list|,
operator|&
name|jumbo_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MSK_CSUM_FEATURES
value|(CSUM_TCP | CSUM_UDP)
end_define

begin_comment
comment|/*  * Devices supported by this driver.  */
end_comment

begin_struct
specifier|static
struct|struct
name|msk_product
block|{
name|uint16_t
name|msk_vendorid
decl_stmt|;
name|uint16_t
name|msk_deviceid
decl_stmt|;
specifier|const
name|char
modifier|*
name|msk_name
decl_stmt|;
block|}
name|msk_products
index|[]
init|=
block|{
block|{
name|VENDORID_SK
block|,
name|DEVICEID_SK_YUKON2
block|,
literal|"SK-9Sxx Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_SK
block|,
name|DEVICEID_SK_YUKON2_EXPR
block|,
literal|"SK-9Exx Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8021CU
block|,
literal|"Marvell Yukon 88E8021CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8021X
block|,
literal|"Marvell Yukon 88E8021 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8022CU
block|,
literal|"Marvell Yukon 88E8022CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8022X
block|,
literal|"Marvell Yukon 88E8022 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8061CU
block|,
literal|"Marvell Yukon 88E8061CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8061X
block|,
literal|"Marvell Yukon 88E8061 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8062CU
block|,
literal|"Marvell Yukon 88E8062CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8062X
block|,
literal|"Marvell Yukon 88E8062 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8035
block|,
literal|"Marvell Yukon 88E8035 Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8036
block|,
literal|"Marvell Yukon 88E8036 Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8038
block|,
literal|"Marvell Yukon 88E8038 Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8039
block|,
literal|"Marvell Yukon 88E8039 Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8040
block|,
literal|"Marvell Yukon 88E8040 Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8040T
block|,
literal|"Marvell Yukon 88E8040T Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8042
block|,
literal|"Marvell Yukon 88E8042 Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8048
block|,
literal|"Marvell Yukon 88E8048 Fast Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4361
block|,
literal|"Marvell Yukon 88E8050 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4360
block|,
literal|"Marvell Yukon 88E8052 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4362
block|,
literal|"Marvell Yukon 88E8053 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4363
block|,
literal|"Marvell Yukon 88E8055 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4364
block|,
literal|"Marvell Yukon 88E8056 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4365
block|,
literal|"Marvell Yukon 88E8070 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_436A
block|,
literal|"Marvell Yukon 88E8058 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_436B
block|,
literal|"Marvell Yukon 88E8071 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_436C
block|,
literal|"Marvell Yukon 88E8072 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_436D
block|,
literal|"Marvell Yukon 88E8055 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4370
block|,
literal|"Marvell Yukon 88E8075 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4380
block|,
literal|"Marvell Yukon 88E8057 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4381
block|,
literal|"Marvell Yukon 88E8059 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_DLINK
block|,
name|DEVICEID_DLINK_DGE550SX
block|,
literal|"D-Link 550SX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_DLINK
block|,
name|DEVICEID_DLINK_DGE560SX
block|,
literal|"D-Link 560SX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_DLINK
block|,
name|DEVICEID_DLINK_DGE560T
block|,
literal|"D-Link 560T Gigabit Ethernet"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|model_name
index|[]
init|=
block|{
literal|"Yukon XL"
block|,
literal|"Yukon EC Ultra"
block|,
literal|"Yukon EX"
block|,
literal|"Yukon EC"
block|,
literal|"Yukon FE"
block|,
literal|"Yukon FE+"
block|,
literal|"Yukon Supreme"
block|,
literal|"Yukon Ultra 2"
block|,
literal|"Yukon Unknown"
block|,
literal|"Yukon Optima"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mskc_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_setup_rambuffer
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mskc_reset
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_intr_phy
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_intr_gmac
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_rxput
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_handle_events
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_handle_hwerr
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_intr_hwerr
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_fixup_rx
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_rxcsum
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_jumbo_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_txeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_encap
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_set_prefetch
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_addr_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_set_rambuffer
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_set_tx_stfwd
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_init_locked
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_stop
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_watchdog
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_phy_power
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_dmamap_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_status_dma_alloc
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_status_dma_free
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_txrx_dma_alloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_rx_dma_jalloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_txrx_dma_free
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_rx_dma_jfree
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_rx_fill
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_init_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_init_jumbo_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_init_tx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_discard_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_discard_jumbo_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_jumbo_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_phy_readreg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_phy_writereg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_rxfilter
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_setvlan
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_stats_clear
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_stats_update
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_sysctl_stat32
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_sysctl_stat64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_sysctl_node
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_msk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|mskc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mskc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mskc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mskc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|mskc_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|mskc_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|mskc_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mskc_driver
init|=
block|{
literal|"mskc"
block|,
name|mskc_methods
block|,
expr|sizeof
operator|(
expr|struct
name|msk_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|mskc_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|msk_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|msk_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|msk_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|msk_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|msk_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|msk_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|msk_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|msk_driver
init|=
block|{
literal|"msk"
block|,
name|msk_methods
block|,
expr|sizeof
operator|(
expr|struct
name|msk_if_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|msk_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mskc
argument_list|,
name|pci
argument_list|,
name|mskc_driver
argument_list|,
name|mskc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|msk
argument_list|,
name|mskc
argument_list|,
name|msk_driver
argument_list|,
name|msk_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|msk
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_res_spec_io
index|[]
init|=
block|{
block|{
name|SYS_RES_IOPORT
block|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_res_spec_mem
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_irq_spec_legacy
index|[]
init|=
block|{
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_irq_spec_msi
index|[]
init|=
block|{
block|{
name|SYS_RES_IRQ
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|msk_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|msk_phy_readreg
argument_list|(
name|sc_if
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_phy_readreg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|,
name|GM_SMI_CT_PHY_AD
argument_list|(
name|phy
argument_list|)
operator||
name|GM_SMI_CT_REG_AD
argument_list|(
name|reg
argument_list|)
operator||
name|GM_SMI_CT_OP_RD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|GM_SMI_CT_RD_VAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_DATA
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|sc_if
operator|->
name|msk_ifp
argument_list|,
literal|"phy failed to come ready\n"
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_phy_writereg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|,
name|GM_SMI_CT_PHY_AD
argument_list|(
name|phy
argument_list|)
operator||
name|GM_SMI_CT_REG_AD
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|)
operator|&
name|GM_SMI_CT_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
name|if_printf
argument_list|(
name|sc_if
operator|->
name|msk_ifp
argument_list|,
literal|"phy write timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|gmac
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
name|mii
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|sc_if
operator|->
name|msk_flags
operator|&=
operator|~
name|MSK_FLAG_LINK
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
operator|)
operator|==
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
condition|)
block|{
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
case|case
name|IFM_100_TX
case|:
name|sc_if
operator|->
name|msk_flags
operator||=
name|MSK_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|IFM_1000_T
case|:
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_CX
case|:
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_FASTETHER
operator|)
operator|==
literal|0
condition|)
name|sc_if
operator|->
name|msk_flags
operator||=
name|MSK_FLAG_LINK
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_LINK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Enable Tx FIFO Underrun. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_MSK
argument_list|)
argument_list|,
name|GM_IS_TX_FF_UR
operator||
name|GM_IS_RX_FF_OR
argument_list|)
expr_stmt|;
comment|/* 		 * Because mii(4) notify msk(4) that it detected link status 		 * change, there is no need to enable automatic 		 * speed/flow-control/duplex updates. 		 */
name|gmac
operator|=
name|GM_GPCR_AU_ALL_DIS
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_T
case|:
name|gmac
operator||=
name|GM_GPCR_SPEED_1000
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|gmac
operator||=
name|GM_GPCR_SPEED_100
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
break|break;
block|}
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|==
literal|0
condition|)
name|gmac
operator||=
name|GM_GPCR_FC_RX_DIS
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|==
literal|0
condition|)
name|gmac
operator||=
name|GM_GPCR_FC_TX_DIS
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|gmac
operator||=
name|GM_GPCR_DUP_FULL
expr_stmt|;
else|else
name|gmac
operator||=
name|GM_GPCR_FC_RX_DIS
operator||
name|GM_GPCR_FC_TX_DIS
expr_stmt|;
name|gmac
operator||=
name|GM_GPCR_RX_ENA
operator||
name|GM_GPCR_TX_ENA
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Read again to ensure writing. */
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
name|gmac
operator|=
name|GMC_PAUSE_OFF
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|gmac
operator|=
name|GMC_PAUSE_ON
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Enable PHY interrupt for FIFO underrun/overflow. */
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_MASK
argument_list|,
name|PHY_M_IS_FIFO_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Link state changed to down. 		 * Disable PHY interrupts. 		 */
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable Rx/Tx MAC. */
name|gmac
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gmac
operator|&
operator|(
name|GM_GPCR_RX_ENA
operator||
name|GM_GPCR_TX_ENA
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|gmac
operator|&=
operator|~
operator|(
name|GM_GPCR_RX_ENA
operator||
name|GM_GPCR_TX_ENA
operator|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Read again to ensure writing. */
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_rxfilter
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint32_t
name|mchash
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|bzero
argument_list|(
name|mchash
argument_list|,
sizeof|sizeof
argument_list|(
name|mchash
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|&=
operator|~
operator|(
name|GM_RXCR_UCF_ENA
operator||
name|GM_RXCR_MCF_ENA
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|mode
operator||=
name|GM_RXCR_UCF_ENA
operator||
name|GM_RXCR_MCF_ENA
expr_stmt|;
name|mchash
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|mchash
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|mode
operator||=
name|GM_RXCR_UCF_ENA
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_be
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Just want the 6 least significant bits. */
name|crc
operator|&=
literal|0x3f
expr_stmt|;
comment|/* Set the corresponding bit in the hash table. */
name|mchash
index|[
name|crc
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mchash
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|mchash
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|mode
operator||=
name|GM_RXCR_MCF_ENA
expr_stmt|;
block|}
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H1
argument_list|,
name|mchash
index|[
literal|0
index|]
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H2
argument_list|,
operator|(
name|mchash
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H3
argument_list|,
name|mchash
index|[
literal|1
index|]
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H4
argument_list|,
operator|(
name|mchash
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_setvlan
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|RX_VLAN_STRIP_ON
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_VLAN_TAG_ON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|RX_VLAN_STRIP_OFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_VLAN_TAG_OFF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|msk_rx_fill
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|jumbo
parameter_list|)
block|{
name|uint16_t
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sc_if
operator|->
name|msk_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Wait until controller executes OP_TCPSTART command. */
for|for
control|(
name|i
operator|=
literal|100
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|idx
operator|=
name|CSR_READ_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_GET_IDX_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"prefetch unit stuck?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* 		 * Fill consumed LE with free buffer. This can be done 		 * in Rx handler but we don't want to add special code 		 * in fast handler. 		 */
if|if
condition|(
name|jumbo
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|msk_jumbo_newbuf
argument_list|(
name|sc_if
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msk_newbuf
argument_list|(
name|sc_if
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
literal|0
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_init_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nbuf
decl_stmt|,
name|prod
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_putwm
operator|=
name|MSK_PUT_WM
expr_stmt|;
name|rd
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|msk_rx_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_rx_desc
argument_list|)
operator|*
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prod
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_rx_ring
index|[
name|prod
index|]
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|nbuf
operator|=
name|MSK_RX_BUF_CNT
expr_stmt|;
name|prod
operator|=
literal|0
expr_stmt|;
comment|/* Have controller know how to compute Rx checksum. */
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sc_if
operator|->
name|msk_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_rx_ring
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|ETHER_HDR_LEN
operator|<<
literal|16
operator||
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_TCPSTART
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_rx_ring
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|ETHER_HDR_LEN
operator|<<
literal|16
operator||
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_TCPSTART
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
name|nbuf
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msk_newbuf
argument_list|(
name|sc_if
argument_list|,
name|prod
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|MSK_RX_INC
argument_list|(
name|prod
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Update prefetch unit. */
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
name|prod
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
operator|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|+
name|MSK_RX_RING_CNT
operator|-
literal|1
operator|)
operator|%
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msk_rx_fill
argument_list|(
name|sc_if
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_init_jumbo_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nbuf
decl_stmt|,
name|prod
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_putwm
operator|=
name|MSK_PUT_WM
expr_stmt|;
name|rd
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|msk_jumbo_rx_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_rx_desc
argument_list|)
operator|*
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prod
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_jumbo_rx_ring
index|[
name|prod
index|]
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|nbuf
operator|=
name|MSK_RX_BUF_CNT
expr_stmt|;
name|prod
operator|=
literal|0
expr_stmt|;
comment|/* Have controller know how to compute Rx checksum. */
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sc_if
operator|->
name|msk_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_jumbo_rx_ring
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|ETHER_HDR_LEN
operator|<<
literal|16
operator||
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_TCPSTART
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_jumbo_rx_ring
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|ETHER_HDR_LEN
operator|<<
literal|16
operator||
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_TCPSTART
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
name|nbuf
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msk_jumbo_newbuf
argument_list|(
name|sc_if
argument_list|,
name|prod
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|MSK_RX_INC
argument_list|(
name|prod
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Update prefetch unit. */
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
name|prod
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
operator|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|+
name|MSK_JUMBO_RX_RING_CNT
operator|-
literal|1
operator|)
operator|%
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msk_rx_fill
argument_list|(
name|sc_if
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_init_tx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tso_mtu
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_last_csum
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cons
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_high_addr
operator|=
literal|0
expr_stmt|;
name|rd
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|msk_tx_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_tx_desc
argument_list|)
operator|*
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_le
operator|=
operator|&
name|rd
operator|->
name|msk_tx_ring
index|[
name|i
index|]
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|msk_discard_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|idx
index|]
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_ADDR64
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|idx
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|idx
index|]
expr_stmt|;
name|m
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|m
operator|->
name|m_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|msk_discard_jumbo_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|idx
index|]
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_ADDR64
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|idx
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|idx
index|]
expr_stmt|;
name|m
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|m
operator|->
name|m_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|==
literal|0
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
name|MSK_RX_BUF_ALIGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|idx
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_ADDR64
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|idx
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|idx
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
name|map
operator|=
name|rxd
operator|->
name|rx_dmamap
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_jumbo_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUM9BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MJUM9BYTES
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|==
literal|0
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
name|MSK_RX_BUF_ALIGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|idx
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_ADDR64
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|idx
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|idx
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
name|map
operator|=
name|rxd
operator|->
name|rx_dmamap
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set media options.  */
end_comment

begin_function
specifier|static
name|int
name|msk_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report current media status.  */
end_comment

begin_function
specifier|static
name|void
name|msk_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|,
name|reinit
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|MSK_JUMBO_MTU
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|!=
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_JUMBO
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_JUMBO_NOCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|MSK_CSUM_FEATURES
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TXCSUM
operator|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc_if
operator|->
name|msk_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
name|msk_rxfilter
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DETACH
operator|)
operator|==
literal|0
condition|)
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|msk_rxfilter
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|reinit
operator|=
literal|0
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|MSK_CSUM_FEATURES
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|MSK_CSUM_FEATURES
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|==
literal|0
condition|)
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_VLAN_HWCSUM
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TSO4
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_VLAN_HWTSO
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_VLAN_HWTAGGING
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_VLAN_HWTAGGING
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_HWCSUM
operator|)
expr_stmt|;
name|msk_setvlan
argument_list|(
name|sc_if
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
operator|&&
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_JUMBO_NOCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|MSK_CSUM_FEATURES
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TXCSUM
operator|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reinit
operator|>
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_product
modifier|*
name|mp
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|,
name|devid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|=
name|msk_products
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|msk_products
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|msk_products
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|mp
operator|->
name|msk_vendorid
operator|&&
name|devid
operator|==
name|mp
operator|->
name|msk_deviceid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|mp
operator|->
name|msk_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_setup_rambuffer
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get adapter SRAM size. */
name|sc
operator|->
name|msk_ramsize
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_E_0
argument_list|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"RAM buffer size : %dKB\n"
argument_list|,
name|sc
operator|->
name|msk_ramsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_ramsize
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_RAMBUF
expr_stmt|;
comment|/* 	 * Give receiver 2/3 of memory and round down to the multiple 	 * of 1024. Tx/Rx RAM buffer size of Yukon II should be multiple 	 * of 1024. 	 */
name|sc
operator|->
name|msk_rxqsize
operator|=
name|rounddown
argument_list|(
operator|(
name|sc
operator|->
name|msk_ramsize
operator|*
literal|1024
operator|*
literal|2
operator|)
operator|/
literal|3
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_txqsize
operator|=
operator|(
name|sc
operator|->
name|msk_ramsize
operator|*
literal|1024
operator|)
operator|-
name|sc
operator|->
name|msk_rxqsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|next
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|msk_rxqstart
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
name|sc
operator|->
name|msk_rxqend
index|[
name|i
index|]
operator|=
name|next
operator|+
name|sc
operator|->
name|msk_rxqsize
operator|-
literal|1
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|msk_rxqend
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|msk_txqstart
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
name|sc
operator|->
name|msk_txqend
index|[
name|i
index|]
operator|=
name|next
operator|+
name|sc
operator|->
name|msk_txqsize
operator|-
literal|1
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|msk_txqend
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Port %d : Rx Queue %dKB(0x%08x:0x%08x)\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|msk_rxqsize
operator|/
literal|1024
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msk_rxqend
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Port %d : Tx Queue %dKB(0x%08x:0x%08x)\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|msk_txqsize
operator|/
literal|1024
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msk_txqend
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_phy_power
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint32_t
name|our
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MSK_PHY_POWERUP
case|:
comment|/* Switch power to VCC (WA for VAUX problem). */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B0_POWER_CTRL
argument_list|,
name|PC_VAUX_ENA
operator||
name|PC_VCC_ENA
operator||
name|PC_VAUX_OFF
operator||
name|PC_VCC_ON
argument_list|)
expr_stmt|;
comment|/* Disable Core Clock Division, set Clock Select to 0. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_CTRL
argument_list|,
name|Y2_CLK_DIV_DIS
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
comment|/* Enable bits are inverted. */
name|val
operator|=
name|Y2_PCI_CLK_LNK1_DIS
operator||
name|Y2_COR_CLK_LNK1_DIS
operator||
name|Y2_CLK_GAT_LNK1_DIS
operator||
name|Y2_PCI_CLK_LNK2_DIS
operator||
name|Y2_COR_CLK_LNK2_DIS
operator||
name|Y2_CLK_GAT_LNK2_DIS
expr_stmt|;
block|}
comment|/* 		 * Enable PCI& Core Clock, enable clock gating for both Links. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_GATE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|our
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_1
argument_list|)
expr_stmt|;
name|our
operator|&=
operator|~
operator|(
name|PCI_Y2_PHY1_POWD
operator||
name|PCI_Y2_PHY2_POWD
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
comment|/* Deassert Low Power for 1st PHY. */
name|our
operator||=
name|PCI_Y2_PHY1_COMA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
name|our
operator||=
name|PCI_Y2_PHY2_COMA
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC_U
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EX
operator|||
name|sc
operator|->
name|msk_hw_id
operator|>=
name|CHIP_ID_YUKON_FE_P
condition|)
block|{
name|val
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_4
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|(
name|PCI_FORCE_ASPM_REQUEST
operator||
name|PCI_ASPM_GPHY_LINK_DOWN
operator||
name|PCI_ASPM_INT_FIFO_EMPTY
operator||
name|PCI_ASPM_CLKRUN_REQUEST
operator|)
expr_stmt|;
comment|/* Set all bits to 0 except bits 15..12. */
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_5
argument_list|)
expr_stmt|;
name|val
operator|&=
name|PCI_CTL_TIM_VMAIN_AV_MSK
expr_stmt|;
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_5
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_CFG_REG_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_HW_WOL_ON
argument_list|)
expr_stmt|;
comment|/* 			 * Disable status race, workaround for 			 * Yukon EC Ultra& Yukon EX. 			 */
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B2_GP_IO
argument_list|)
expr_stmt|;
name|val
operator||=
name|GLB_GPIO_STAT_RACE_DIS
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_GP_IO
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B2_GP_IO
argument_list|)
expr_stmt|;
block|}
comment|/* Release PHY from PowerDown/COMA mode. */
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
name|our
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_LINK_CTRL
argument_list|)
argument_list|,
name|GMLC_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_LINK_CTRL
argument_list|)
argument_list|,
name|GMLC_RST_CLR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MSK_PHY_POWERDOWN
case|:
name|val
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_1
argument_list|)
expr_stmt|;
name|val
operator||=
name|PCI_Y2_PHY1_POWD
operator||
name|PCI_Y2_PHY2_POWD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
name|val
operator|&=
operator|~
name|PCI_Y2_PHY1_COMA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
name|val
operator|&=
operator|~
name|PCI_Y2_PHY2_COMA
expr_stmt|;
block|}
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|Y2_PCI_CLK_LNK1_DIS
operator||
name|Y2_COR_CLK_LNK1_DIS
operator||
name|Y2_CLK_GAT_LNK1_DIS
operator||
name|Y2_PCI_CLK_LNK2_DIS
operator||
name|Y2_COR_CLK_LNK2_DIS
operator||
name|Y2_CLK_GAT_LNK2_DIS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
comment|/* Enable bits are inverted. */
name|val
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Disable PCI& Core Clock, disable clock gating for 		 * both Links. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_GATE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B0_POWER_CTRL
argument_list|,
name|PC_VAUX_ENA
operator||
name|PC_VCC_ENA
operator||
name|PC_VAUX_ON
operator||
name|PC_VCC_OFF
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mskc_reset
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_addr_t
name|addr
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|initram
decl_stmt|;
comment|/* Disable ASF. */
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|>=
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_id
operator|<=
name|CHIP_ID_YUKON_SUPR
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EX
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_SUPR
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B28_Y2_CPU_WDOG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|B28_Y2_ASF_HCU_CCSR
argument_list|)
expr_stmt|;
comment|/* Clear AHB bridge& microcontroller reset. */
name|status
operator|&=
operator|~
operator|(
name|Y2_ASF_HCU_CCSR_AHB_RST
operator||
name|Y2_ASF_HCU_CCSR_CPU_RST_MODE
operator|)
expr_stmt|;
comment|/* Clear ASF microcontroller state. */
name|status
operator|&=
operator|~
name|Y2_ASF_HCU_CCSR_UC_STATE_MSK
expr_stmt|;
name|status
operator|&=
operator|~
name|Y2_ASF_HCU_CCSR_CPU_CLK_DIVIDE_MSK
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B28_Y2_ASF_HCU_CCSR
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B28_Y2_CPU_WDOG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B28_Y2_ASF_STAT_CMD
argument_list|,
name|Y2_ASF_RESET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_ASF_DISABLE
argument_list|)
expr_stmt|;
comment|/* 		 * Since we disabled ASF, S/W reset is required for 		 * Power Management. 		 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_CLR
argument_list|)
expr_stmt|;
block|}
comment|/* Clear all error bits in the PCI status register. */
name|status
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|status
operator||
name|PCIM_STATUS_PERR
operator||
name|PCIM_STATUS_SERR
operator||
name|PCIM_STATUS_RMABORT
operator||
name|PCIM_STATUS_RTABORT
operator||
name|PCIM_STATUS_MDPERR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_MRST_CLR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|msk_bustype
condition|)
block|{
case|case
name|MSK_PEX_BUS
case|:
comment|/* Clear all PEX errors. */
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PEX_RX_OV
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
name|Y2_IS_HW_ERR
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_IS_PCI_EXP
expr_stmt|;
block|}
break|break;
case|case
name|MSK_PCI_BUS
case|:
case|case
name|MSK_PCIX_BUS
case|:
comment|/* Set Cache Line Size to 2(8bytes) if configured to 0. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_bustype
operator|==
name|MSK_PCIX_BUS
condition|)
block|{
comment|/* Set Cache Line Size opt. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator||=
name|PCI_CLS_OPT
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Set PHY power state. */
name|msk_phy_power
argument_list|(
name|sc
argument_list|,
name|MSK_PHY_POWERUP
argument_list|)
expr_stmt|;
comment|/* Reset GPHY/GMAC Control */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
comment|/* GPHY Control reset. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GPHY_CTRL
argument_list|)
argument_list|,
name|GPC_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GPHY_CTRL
argument_list|)
argument_list|,
name|GPC_RST_CLR
argument_list|)
expr_stmt|;
comment|/* GMAC Control reset. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_F_LOOPB_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EX
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_SUPR
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_BYP_MACSECRX_ON
operator||
name|GMC_BYP_MACSECTX_ON
operator||
name|GMC_BYP_RETR_ON
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_SUPR
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_SU_B0
condition|)
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_3
argument_list|,
name|PCI_CLK_MACSEC_DIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_OPT
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|==
literal|0
condition|)
block|{
comment|/* Disable PCIe PHY powerdown(reg 0x80, bit7). */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PEX_PHY_DATA
argument_list|,
operator|(
literal|0x0080
operator|<<
literal|16
operator|)
operator||
literal|0x0080
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
comment|/* LED On. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_LED_STAT_ON
argument_list|)
expr_stmt|;
comment|/* Clear TWSI IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_I2C_IRQ
argument_list|,
name|I2C_CLR_IRQ
argument_list|)
expr_stmt|;
comment|/* Turn off hardware timer. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TI_CTRL
argument_list|,
name|TIM_STOP
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TI_CTRL
argument_list|,
name|TIM_CLR_IRQ
argument_list|)
expr_stmt|;
comment|/* Turn off descriptor polling. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B28_DPT_CTRL
argument_list|,
name|DPT_STOP
argument_list|)
expr_stmt|;
comment|/* Turn off time stamps. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|GMAC_TI_ST_CTRL
argument_list|,
name|GMT_ST_STOP
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|GMAC_TI_ST_CTRL
argument_list|,
name|GMT_ST_CLR_IRQ
argument_list|)
expr_stmt|;
name|initram
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_FE
condition|)
name|initram
operator|++
expr_stmt|;
comment|/* Configure timeout values. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|initram
operator|>
literal|0
operator|&&
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_R1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XA1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XS1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_R1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XA1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XS1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_R2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XA2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XS2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_R2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XA2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XS2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
comment|/*          * On dual port PCI-X card, there is an problem where status          * can be received out of order due to split transactions.          */
if|if
condition|(
name|sc
operator|->
name|msk_pcixcap
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
block|{
name|uint16_t
name|pcix_cmd
decl_stmt|;
name|pcix_cmd
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|sc
operator|->
name|msk_pcixcap
operator|+
name|PCIXR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear Max Outstanding Split Transactions. */
name|pcix_cmd
operator|&=
operator|~
name|PCIXM_COMMAND_MAX_SPLITS
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|sc
operator|->
name|msk_pcixcap
operator|+
name|PCIXR_COMMAND
argument_list|,
name|pcix_cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_expcap
operator|!=
literal|0
condition|)
block|{
comment|/* Change Max. Read Request Size to 2048 bytes. */
if|if
condition|(
name|pci_get_max_read_req
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|)
operator|==
literal|512
condition|)
name|pci_set_max_read_req
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
block|}
comment|/* Clear status list. */
name|bzero
argument_list|(
name|sc
operator|->
name|msk_stat_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_stat_desc
argument_list|)
operator|*
name|sc
operator|->
name|msk_stat_count
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_stat_cons
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_RST_CLR
argument_list|)
expr_stmt|;
comment|/* Set the status list base address. */
name|addr
operator|=
name|sc
operator|->
name|msk_stat_ring_paddr
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_LIST_ADDR_LO
argument_list|,
name|MSK_ADDR_LO
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_LIST_ADDR_HI
argument_list|,
name|MSK_ADDR_HI
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the status list last index. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STAT_LAST_IDX
argument_list|,
name|sc
operator|->
name|msk_stat_count
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EC_A1
condition|)
block|{
comment|/* WA for dev. #4.3 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STAT_TX_IDX_TH
argument_list|,
name|ST_TXTH_IDX_MASK
argument_list|)
expr_stmt|;
comment|/* WA for dev. #4.18 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_WM
argument_list|,
literal|0x21
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_ISR_WM
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STAT_TX_IDX_TH
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_WM
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_XL_A0
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_ISR_WM
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
else|else
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_ISR_WM
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_ISR_TIMER_INI
argument_list|,
literal|0x0190
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Use default value for STAT_ISR_TIMER_INI, STAT_LEV_TIMER_INI. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_TX_TIMER_INI
argument_list|,
name|MSK_USECS
argument_list|(
name|sc
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable status unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_OP_ON
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_TX_TIMER_CTRL
argument_list|,
name|TIM_START
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_LEV_TIMER_CTRL
argument_list|,
name|TIM_START
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_ISR_TIMER_CTRL
argument_list|,
name|TIM_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|char
name|desc
index|[
literal|100
index|]
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Not much to do here. We always know there will be 	 * at least one GMAC present, and if there are two, 	 * mskc_attach() will create a second device instance 	 * for us. 	 */
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
literal|"Marvell Technology Group Ltd. %s Id 0x%02x Rev 0x%02x"
argument_list|,
name|model_name
index|[
name|sc
operator|->
name|msk_hw_id
operator|-
name|CHIP_ID_YUKON_XL
index|]
argument_list|,
name|sc
operator|->
name|msk_hw_id
argument_list|,
name|sc
operator|->
name|msk_hw_rev
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|msk_mii_data
modifier|*
name|mmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|error
decl_stmt|;
name|uint8_t
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mmd
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|port
operator|=
name|mmd
operator|->
name|port
expr_stmt|;
name|sc_if
operator|->
name|msk_if_dev
operator|=
name|dev
expr_stmt|;
name|sc_if
operator|->
name|msk_port
operator|=
name|port
expr_stmt|;
name|sc_if
operator|->
name|msk_softc
operator|=
name|sc
expr_stmt|;
name|sc_if
operator|->
name|msk_flags
operator|=
name|sc
operator|->
name|msk_pflags
expr_stmt|;
name|sc
operator|->
name|msk_if
index|[
name|port
index|]
operator|=
name|sc_if
expr_stmt|;
comment|/* Setup Tx/Rx queue register offsets. */
if|if
condition|(
name|port
operator|==
name|MSK_PORT_A
condition|)
block|{
name|sc_if
operator|->
name|msk_txq
operator|=
name|Q_XA1
expr_stmt|;
name|sc_if
operator|->
name|msk_txsq
operator|=
name|Q_XS1
expr_stmt|;
name|sc_if
operator|->
name|msk_rxq
operator|=
name|Q_R1
expr_stmt|;
block|}
else|else
block|{
name|sc_if
operator|->
name|msk_txq
operator|=
name|Q_XA2
expr_stmt|;
name|sc_if
operator|->
name|msk_txsq
operator|=
name|Q_XS2
expr_stmt|;
name|sc_if
operator|->
name|msk_rxq
operator|=
name|Q_R2
expr_stmt|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_softc
operator|->
name|msk_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msk_sysctl_node
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|msk_txrx_dma_alloc
argument_list|(
name|sc_if
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|fail
goto|;
name|msk_rx_dma_jalloc
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc_if
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
expr_stmt|;
comment|/* 	 * Enable Rx checksum offloading if controller supports 	 * new descriptor formant and controller is not Yukon XL. 	 */
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|msk_hw_id
operator|!=
name|CHIP_ID_YUKON_XL
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_NORX_CSUM
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|MSK_CSUM_FEATURES
operator||
name|CSUM_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|msk_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|msk_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|msk_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|MSK_TX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|MSK_TX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* 	 * Get station address for this interface. Note that 	 * dual port cards actually come with three station 	 * addresses: one for each port, plus an extra. The 	 * extra one is used by the SysKonnect driver software 	 * as a 'virtual' station address for when both ports 	 * are operating in failover mode. Currently we don't 	 * use this extra address. 	 */
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|eaddr
index|[
name|i
index|]
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_MAC_1
operator|+
operator|(
name|port
operator|*
literal|8
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Call MI attach routine.  Can't hold locks when calling into ether_*. 	 */
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* VLAN capability setup */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_NOHWVLAN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Due to Tx checksum offload hardware bugs, msk(4) manually 		 * computes checksum for short frames. For VLAN tagged frames 		 * this workaround does not work so disable checksum offload 		 * for VLAN interface. 		 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
expr_stmt|;
comment|/* 		 * Enable Rx checksum offloading for VLAN tagged frames 		 * if controller support new descriptor format. 		 */
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_NORX_CSUM
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 * Must appear after the call to ether_ifattach() because 	 * ether_ifattach() sets ifi_hdrlen to the default value. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
comment|/* 	 * Do miibus setup. 	 */
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_miibus
argument_list|,
name|ifp
argument_list|,
name|msk_mediachange
argument_list|,
name|msk_mediastatus
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
name|mmd
operator|->
name|mii_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"attaching PHYs failed\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Access should be ok even though lock has been dropped */
name|sc
operator|->
name|msk_if
index|[
name|port
index|]
operator|=
name|NULL
expr_stmt|;
name|msk_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface. Allocate softc structures, do ifmedia  * setup and ethernet/BPF attach.  */
end_comment

begin_function
specifier|static
name|int
name|mskc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_mii_data
modifier|*
name|mmd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|msic
decl_stmt|,
name|msir
decl_stmt|,
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate I/O resource */
ifdef|#
directive|ifdef
name|MSK_USEIOSPACE
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_io
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_mem
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|msk_irq_spec
operator|=
name|msk_irq_spec_legacy
expr_stmt|;
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_res_spec
argument_list|,
name|sc
operator|->
name|msk_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_res_spec
operator|==
name|msk_res_spec_mem
condition|)
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_io
expr_stmt|;
else|else
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_mem
expr_stmt|;
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_res_spec
argument_list|,
name|sc
operator|->
name|msk_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't allocate %s resources\n"
argument_list|,
name|sc
operator|->
name|msk_res_spec
operator|==
name|msk_res_spec_mem
condition|?
literal|"memory"
else|:
literal|"I/O"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Enable all clocks before accessing any registers. */
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_CLR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_hw_id
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_CHIP_ID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_hw_rev
operator|=
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_MAC_CFG
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
comment|/* Bail out if chip is not recognized. */
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|<
name|CHIP_ID_YUKON_XL
operator|||
name|sc
operator|->
name|msk_hw_id
operator|>
name|CHIP_ID_YUKON_OPT
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_UNKNOWN
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown device: id=0x%02x, rev=0x%02x\n"
argument_list|,
name|sc
operator|->
name|msk_hw_id
argument_list|,
name|sc
operator|->
name|msk_hw_rev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"process_limit"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|msk_process_limit
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_msk_proc_limit
argument_list|,
literal|"I"
argument_list|,
literal|"max number of Rx events to process"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_process_limit
operator|=
name|MSK_PROC_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"process_limit"
argument_list|,
operator|&
name|sc
operator|->
name|msk_process_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_process_limit
operator|<
name|MSK_PROC_MIN
operator|||
name|sc
operator|->
name|msk_process_limit
operator|>
name|MSK_PROC_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"process_limit value out of range; "
literal|"using default: %d\n"
argument_list|,
name|MSK_PROC_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_process_limit
operator|=
name|MSK_PROC_DEFAULT
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|msk_int_holdoff
operator|=
name|MSK_INT_HOLDOFF_DEFAULT
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"int_holdoff"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|msk_int_holdoff
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of time to delay interrupts"
argument_list|)
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"int_holdoff"
argument_list|,
operator|&
name|sc
operator|->
name|msk_int_holdoff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_pmd
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_PMD_TYP
argument_list|)
expr_stmt|;
comment|/* Check number of MACs. */
name|sc
operator|->
name|msk_num_port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_HW_RES
argument_list|)
operator|&
name|CFG_DUAL_MAC_MSK
operator|)
operator|==
name|CFG_DUAL_MAC_MSK
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_GATE
argument_list|)
operator|&
name|Y2_STATUS_LNK2_INAC
operator|)
condition|)
name|sc
operator|->
name|msk_num_port
operator|++
expr_stmt|;
block|}
comment|/* Check bus type. */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|msk_bustype
operator|=
name|MSK_PEX_BUS
expr_stmt|;
name|sc
operator|->
name|msk_expcap
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIY_PCIX
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|msk_bustype
operator|=
name|MSK_PCIX_BUS
expr_stmt|;
name|sc
operator|->
name|msk_pcixcap
operator|=
name|reg
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|msk_bustype
operator|=
name|MSK_PCI_BUS
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|msk_hw_id
condition|)
block|{
case|case
name|CHIP_ID_YUKON_EC
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_EC_U
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO
operator||
name|MSK_FLAG_JUMBO_NOCSUM
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_EX
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO
operator||
name|MSK_FLAG_DESCV2
operator||
name|MSK_FLAG_AUTOTX_CSUM
expr_stmt|;
comment|/* 		 * Yukon Extreme seems to have silicon bug for 		 * automatic Tx checksum calculation capability. 		 */
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EX_B0
condition|)
name|sc
operator|->
name|msk_pflags
operator|&=
operator|~
name|MSK_FLAG_AUTOTX_CSUM
expr_stmt|;
comment|/* 		 * Yukon Extreme A0 could not use store-and-forward 		 * for jumbo frames, so disable Tx checksum 		 * offloading for jumbo frames. 		 */
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EX_A0
condition|)
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO_NOCSUM
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_FE
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|100
expr_stmt|;
comment|/* 100 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_FASTETHER
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_FE_P
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|50
expr_stmt|;
comment|/* 50 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_FASTETHER
operator||
name|MSK_FLAG_DESCV2
operator||
name|MSK_FLAG_AUTOTX_CSUM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_FE_P_A0
condition|)
block|{
comment|/* 			 * XXX 			 * FE+ A0 has status LE writeback bug so msk(4) 			 * does not rely on status word of received frame 			 * in msk_rxeof() which in turn disables all 			 * hardware assistance bits reported by the status 			 * word as well as validity of the received frame. 			 * Just pass received frames to upper stack with 			 * minimal test and let upper stack handle them. 			 */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_NOHWVLAN
operator||
name|MSK_FLAG_NORXCHK
operator||
name|MSK_FLAG_NORX_CSUM
expr_stmt|;
block|}
break|break;
case|case
name|CHIP_ID_YUKON_XL
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|156
expr_stmt|;
comment|/* 156 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_SUPR
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO
operator||
name|MSK_FLAG_DESCV2
operator||
name|MSK_FLAG_AUTOTX_CSUM
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_UL_2
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_OPT
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 MHz */
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_JUMBO
operator||
name|MSK_FLAG_DESCV2
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|msk_clock
operator|=
literal|156
expr_stmt|;
comment|/* 156 MHz */
break|break;
block|}
comment|/* Allocate IRQ resources. */
name|msic
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MSI count : %d\n"
argument_list|,
name|msic
argument_list|)
expr_stmt|;
if|if
condition|(
name|legacy_intr
operator|!=
literal|0
condition|)
name|msi_disable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msi_disable
operator|==
literal|0
operator|&&
name|msic
operator|>
literal|0
condition|)
block|{
name|msir
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msir
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msir
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_MSI
expr_stmt|;
name|sc
operator|->
name|msk_irq_spec
operator|=
name|msk_irq_spec_msi
expr_stmt|;
block|}
else|else
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq_spec
argument_list|,
name|sc
operator|->
name|msk_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't allocate IRQ resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|msk_status_dma_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Set base interrupt mask. */
name|sc
operator|->
name|msk_intrmask
operator|=
name|Y2_IS_HW_ERR
operator||
name|Y2_IS_STAT_BMU
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|=
name|Y2_IS_TIST_OV
operator||
name|Y2_IS_MST_ERR
operator||
name|Y2_IS_IRQ_STAT
operator||
name|Y2_IS_PCI_EXP
operator||
name|Y2_IS_PCI_NEXP
expr_stmt|;
comment|/* Reset the adapter. */
name|mskc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mskc_setup_rambuffer
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"msk"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add child for PORT_A\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mmd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msk_mii_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate memory for "
literal|"ivars of PORT_A\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mmd
operator|->
name|port
operator|=
name|MSK_PORT_A
expr_stmt|;
name|mmd
operator|->
name|pmd
operator|=
name|sc
operator|->
name|msk_pmd
expr_stmt|;
name|mmd
operator|->
name|mii_flags
operator||=
name|MIIF_DOPAUSE
operator||
name|MIIF_FORCEPAUSE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_pmd
operator|==
literal|'L'
operator|||
name|sc
operator|->
name|msk_pmd
operator|==
literal|'S'
condition|)
name|mmd
operator|->
name|mii_flags
operator||=
name|MIIF_HAVEFIBER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_pmd
operator|==
literal|'P'
condition|)
name|mmd
operator|->
name|mii_flags
operator||=
name|MIIF_HAVEFIBER
operator||
name|MIIF_MACPRIV0
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
argument_list|,
name|mmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"msk"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add child for PORT_B\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mmd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msk_mii_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate memory for "
literal|"ivars of PORT_B\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mmd
operator|->
name|port
operator|=
name|MSK_PORT_B
expr_stmt|;
name|mmd
operator|->
name|pmd
operator|=
name|sc
operator|->
name|msk_pmd
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_pmd
operator|==
literal|'L'
operator|||
name|sc
operator|->
name|msk_pmd
operator|==
literal|'S'
condition|)
name|mmd
operator|->
name|mii_flags
operator||=
name|MIIF_HAVEFIBER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_pmd
operator|==
literal|'P'
condition|)
name|mmd
operator|->
name|mii_flags
operator||=
name|MIIF_HAVEFIBER
operator||
name|MIIF_MACPRIV0
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
argument_list|,
name|mmd
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach port(s)\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Hook interrupt last to avoid having to lock softc. */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq
index|[
literal|0
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|msk_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|msk_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't set up interrupt handler\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|mskc_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown hardware and free up resources. This can be called any  * time after the mutex has been initialized. It is called in both  * the error case in attach and the normal detach case so it needs  * to be careful about only freeing resources that have actually been  * allocated.  */
end_comment

begin_function
specifier|static
name|int
name|msk_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_softc
operator|->
name|msk_mtx
argument_list|)
argument_list|,
operator|(
literal|"msk mutex not initialized in msk_detach"
operator|)
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* XXX */
name|sc_if
operator|->
name|msk_flags
operator||=
name|MSK_FLAG_DETACH
expr_stmt|;
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Can't hold locks while calling detach. */
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're generally called from mskc_detach() which is using 	 * device_delete_child() to get to here. It's already trashed 	 * miibus for us, so don't do it here or we'll panic. 	 * 	 * if (sc_if->msk_miibus != NULL) { 	 * 	device_delete_child(dev, sc_if->msk_miibus); 	 * 	sc_if->msk_miibus = NULL; 	 * } 	 */
name|msk_rx_dma_jfree
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|msk_txrx_dma_free
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|sc
operator|->
name|msk_if
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|=
name|NULL
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
argument_list|,
operator|(
literal|"msk mutex not initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_alive
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
comment|/* LED Off. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_LED_STAT_OFF
argument_list|)
expr_stmt|;
comment|/* Put hardware reset. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|msk_status_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_intrhand
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|msk_intrhand
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_intrhand
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq_spec
argument_list|,
name|sc
operator|->
name|msk_irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|msk_pflags
operator|&
name|MSK_FLAG_MSI
operator|)
operator|!=
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_res_spec
argument_list|,
name|sc
operator|->
name|msk_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|msk_dmamap_arg
block|{
name|bus_addr_t
name|msk_busaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|msk_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|msk_dmamap_arg
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|ctx
operator|=
name|arg
expr_stmt|;
name|ctx
operator|->
name|msk_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create status DMA region. */
end_comment

begin_function
specifier|static
name|int
name|msk_status_dma_alloc
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|msk_dmamap_arg
name|ctx
decl_stmt|;
name|bus_size_t
name|stat_sz
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * It seems controller requires number of status LE entries 	 * is power of 2 and the maximum number of status LE entries 	 * is 4096.  For dual-port controllers, the number of status 	 * LE entries should be large enough to hold both port's 	 * status updates. 	 */
name|count
operator|=
literal|3
operator|*
name|MSK_RX_RING_CNT
operator|+
name|MSK_TX_RING_CNT
expr_stmt|;
name|count
operator|=
name|imin
argument_list|(
literal|4096
argument_list|,
name|roundup2
argument_list|(
name|count
argument_list|,
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_stat_count
operator|=
name|count
expr_stmt|;
name|stat_sz
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|msk_stat_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|)
argument_list|,
comment|/* parent */
name|MSK_STAT_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|stat_sz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|stat_sz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|msk_stat_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"failed to create status DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Allocate DMA'able memory and load the DMA map for status ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|msk_stat_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|msk_stat_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"failed to allocate DMA'able memory for status ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|,
name|sc
operator|->
name|msk_stat_ring
argument_list|,
name|stat_sz
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"failed to load DMA'able memory for status ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|msk_stat_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_status_dma_free
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Destroy status block. */
if|if
condition|(
name|sc
operator|->
name|msk_stat_tag
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_stat_map
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_stat_ring
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_ring
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_stat_ring
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|msk_stat_map
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_stat_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|msk_txrx_dma_alloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_dmamap_arg
name|ctx
decl_stmt|;
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|bus_size_t
name|rxalign
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* Create parent DMA tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create parent DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Tx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|MSK_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_TX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_TX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Tx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Rx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|MSK_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_RX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_RX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Rx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Tx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_TSO_MAXSIZE
argument_list|,
comment|/* maxsize */
name|MSK_MAXTXSEGS
argument_list|,
comment|/* nsegments */
name|MSK_TSO_MAXSGSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Tx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxalign
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Workaround hardware hang which seems to happen when Rx buffer 	 * is not aligned on multiple of FIFO word(8 bytes). 	 */
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|!=
literal|0
condition|)
name|rxalign
operator|=
name|MSK_RX_BUF_ALIGN
expr_stmt|;
comment|/* Create tag for Rx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|rxalign
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Rx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate DMA'able memory and load the DMA map for Tx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to allocate DMA'able memory for Tx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
argument_list|,
name|MSK_TX_RING_SZ
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to load DMA'able memory for Tx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
comment|/* Allocate DMA'able memory and load the DMA map for Rx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to allocate DMA'able memory for Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
argument_list|,
name|MSK_RX_RING_SZ
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to load DMA'able memory for Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
comment|/* Create DMA maps for Tx buffers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Tx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Create DMA maps for Rx buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create spare Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_rx_dma_jalloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_dmamap_arg
name|ctx
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|bus_size_t
name|rxalign
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|jumbo_disable
operator|!=
literal|0
operator|||
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_JUMBO
operator|)
operator|==
literal|0
condition|)
block|{
name|sc_if
operator|->
name|msk_flags
operator|&=
operator|~
name|MSK_FLAG_JUMBO
expr_stmt|;
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"disabling jumbo frame support\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Create tag for jumbo Rx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|MSK_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_JUMBO_RX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_JUMBO_RX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create jumbo Rx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|jumbo_fail
goto|;
block|}
name|rxalign
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Workaround hardware hang which seems to happen when Rx buffer 	 * is not aligned on multiple of FIFO word(8 bytes). 	 */
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|!=
literal|0
condition|)
name|rxalign
operator|=
name|MSK_RX_BUF_ALIGN
expr_stmt|;
comment|/* Create tag for jumbo Rx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|rxalign
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUM9BYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUM9BYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create jumbo Rx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|jumbo_fail
goto|;
block|}
comment|/* Allocate DMA'able memory and load the DMA map for jumbo Rx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to allocate DMA'able memory for jumbo Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|jumbo_fail
goto|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
argument_list|,
name|MSK_JUMBO_RX_RING_SZ
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to load DMA'able memory for jumbo Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|jumbo_fail
goto|;
block|}
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
comment|/* Create DMA maps for jumbo Rx buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create spare jumbo Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|jumbo_fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|jrxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|jrxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|jrxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create jumbo Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|jumbo_fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|jumbo_fail
label|:
name|msk_rx_dma_jfree
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"disabling jumbo frame support "
literal|"due to resource shortage\n"
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_flags
operator|&=
operator|~
name|MSK_FLAG_JUMBO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_txrx_dma_free
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Tx ring. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
operator|&&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
operator|=
name|NULL
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx ring. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
operator|&&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Tx buffers. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx buffers. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_rx_dma_jfree
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Jumbo Rx ring. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
operator|&&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Jumbo Rx buffers. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|jrxd
operator|->
name|rx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|jrxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|jrxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|msk_encap
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|,
modifier|*
name|txd_last
decl_stmt|;
name|struct
name|msk_tx_desc
modifier|*
name|tx_le
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_segment_t
name|txsegs
index|[
name|MSK_MAXTXSEGS
index|]
decl_stmt|;
name|uint32_t
name|control
decl_stmt|,
name|csum
decl_stmt|,
name|prod
decl_stmt|,
name|si
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|,
name|tcp_offset
decl_stmt|,
name|tso_mtu
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nseg
decl_stmt|,
name|tso
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|tcp_offset
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_AUTOTX_CSUM
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|MSK_CSUM_FEATURES
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Since mbuf has no protocol specific structure information 		 * in it we have to inspect protocol information here to 		 * setup TSO and checksum offload. I don't know why Marvell 		 * made a such decision in chip design because other GigE 		 * hardwares normally takes care of all these chores in 		 * hardware. However, TSO performance of Yukon II is very 		 * good such that it's worth to implement it. 		 */
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Get a writable copy. */
name|m
operator|=
name|m_dup
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Check if hardware VLAN insertion is off. */
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|offset
operator|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|tcp_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|offset
operator|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_AUTOTX_CSUM
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MSK_MIN_FRAMELEN
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * It seems that Yukon II has Tx checksum offload bug 			 * for small TCP packets that's less than 60 bytes in 			 * size (e.g. TCP window probe packet, pure ACK packet). 			 * Common work around like padding with zeros to make 			 * the frame minimum ethernet frame size didn't work at 			 * all. 			 * Instead of disabling checksum offload completely we 			 * resort to S/W checksum routine when we encounter 			 * short TCP frames. 			 * Short UDP packets appear to be handled correctly by 			 * Yukon II. Also I assume this bug does not happen on 			 * controllers that use newer descriptor format or 			 * automatic Tx checksum calculation. 			 */
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|)
operator|=
name|in_cksum_skip
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_TCP
expr_stmt|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
name|prod
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
expr_stmt|;
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|prod
index|]
expr_stmt|;
name|txd_last
operator|=
name|txd
expr_stmt|;
name|map
operator|=
name|txd
operator|->
name|tx_dmamap
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|m
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MSK_MAXTXSEGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Check number of available descriptors. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|+
name|nseg
operator|>=
operator|(
name|MSK_TX_RING_CNT
operator|-
name|MSK_RESERVED_TX_DESC_CNT
operator|)
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|control
operator|=
literal|0
expr_stmt|;
name|tso
operator|=
literal|0
expr_stmt|;
name|tx_le
operator|=
name|NULL
expr_stmt|;
comment|/* Check TSO support. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|!=
literal|0
condition|)
name|tso_mtu
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
else|else
name|tso_mtu
operator|=
name|offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
if|if
condition|(
name|tso_mtu
operator|!=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tso_mtu
condition|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|tso_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|!=
literal|0
condition|)
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_MSS
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
else|else
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_LRGLEN
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tso_mtu
operator|=
name|tso_mtu
expr_stmt|;
block|}
name|tso
operator|++
expr_stmt|;
block|}
comment|/* Check if we have a VLAN tag to insert. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tx_le
operator|==
name|NULL
condition|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_VLAN
operator||
name|HW_OWNER
operator||
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx_le
operator|->
name|msk_control
operator||=
name|htole32
argument_list|(
name|OP_VLAN
operator||
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|control
operator||=
name|INS_VLAN
expr_stmt|;
block|}
comment|/* Check if we have to handle checksum offload. */
if|if
condition|(
name|tso
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|MSK_CSUM_FEATURES
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_AUTOTX_CSUM
operator|)
operator|!=
literal|0
condition|)
name|control
operator||=
name|CALSUM
expr_stmt|;
else|else
block|{
name|control
operator||=
name|CALSUM
operator||
name|WR_SUM
operator||
name|INIT_SUM
operator||
name|LOCK_SUM
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
operator|)
operator|!=
literal|0
condition|)
name|control
operator||=
name|UDPTCP
expr_stmt|;
comment|/* Checksum write position. */
name|csum
operator|=
operator|(
name|tcp_offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|)
operator|&
literal|0xffff
expr_stmt|;
comment|/* Checksum start position. */
name|csum
operator||=
operator|(
name|uint32_t
operator|)
name|tcp_offset
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_last_csum
condition|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|csum
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
literal|1
operator|<<
literal|16
operator||
operator|(
name|OP_TCPLISW
operator||
name|HW_OWNER
operator|)
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_last_csum
operator|=
name|csum
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
if|if
condition|(
name|MSK_ADDR_HI
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
operator|!=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_high_addr
condition|)
block|{
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_high_addr
operator|=
name|MSK_ADDR_HI
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_HI
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_ADDR64
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|si
operator|=
name|prod
expr_stmt|;
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tso
operator|==
literal|0
condition|)
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|control
operator||
name|OP_PACKET
argument_list|)
expr_stmt|;
else|else
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|control
operator||
name|OP_LARGESEND
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
if|if
condition|(
name|MSK_ADDR_HI
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
operator|!=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_high_addr
condition|)
block|{
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_high_addr
operator|=
name|MSK_ADDR_HI
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_HI
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_ADDR64
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
block|}
endif|#
directive|endif
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_len
operator||
name|control
operator||
name|OP_BUFFER
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
comment|/* Update producer index. */
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
operator|=
name|prod
expr_stmt|;
comment|/* Set EOP on the last descriptor. */
name|prod
operator|=
operator|(
name|prod
operator|+
name|MSK_TX_RING_CNT
operator|-
literal|1
operator|)
operator|%
name|MSK_TX_RING_CNT
expr_stmt|;
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator||=
name|htole32
argument_list|(
name|EOP
argument_list|)
expr_stmt|;
comment|/* Turn the first descriptor ownership to hardware. */
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|si
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator||=
name|htole32
argument_list|(
name|HW_OWNER
argument_list|)
expr_stmt|;
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|prod
index|]
expr_stmt|;
name|map
operator|=
name|txd_last
operator|->
name|tx_dmamap
expr_stmt|;
name|txd_last
operator|->
name|tx_dmamap
operator|=
name|txd
operator|->
name|tx_dmamap
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|map
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|m
expr_stmt|;
comment|/* Sync descriptors. */
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|msk_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|enq
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|enq
operator|=
literal|0
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|&&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|<
operator|(
name|MSK_TX_RING_CNT
operator|-
name|MSK_RESERVED_TX_DESC_CNT
operator|)
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, set the OACTIVE flag and wait 		 * for the NIC to drain the ring. 		 */
if|if
condition|(
name|msk_encap
argument_list|(
name|sc_if
argument_list|,
operator|&
name|m_head
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
comment|/* 		 * If there's a BPF listener, bounce a copy of this frame 		 * to him. 		 */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
comment|/* Transmit */
name|CSR_WRITE_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
argument_list|)
expr_stmt|;
comment|/* Set a timeout in case the chip goes out to lunch. */
name|sc_if
operator|->
name|msk_watchdog_timer
operator|=
name|MSK_TX_TIMEOUT
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_watchdog
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc_if
operator|->
name|msk_watchdog_timer
condition|)
return|return;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|sc_if
operator|->
name|msk_ifp
argument_list|,
literal|"watchdog timeout "
literal|"(missed link)\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|msk_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|)
condition|)
name|msk_stop
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Put hardware reset. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|)
condition|)
name|msk_stop
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|msk_phy_power
argument_list|(
name|sc
argument_list|,
name|MSK_PHY_POWERDOWN
argument_list|)
expr_stmt|;
comment|/* Put hardware reset. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_pflags
operator||=
name|MSK_FLAG_SUSPEND
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PCI_OUR_REG_3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mskc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|msk_pflags
operator|&=
operator|~
name|MSK_FLAG_SUSPEND
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function
specifier|static
name|__inline
name|void
name|msk_fixup_rx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|src
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint16_t
operator|*
argument_list|)
expr_stmt|;
name|dst
operator|=
name|src
operator|-
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|m
operator|->
name|m_len
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
operator|(
name|MSK_RX_BUF_ALIGN
operator|-
name|ETHER_ALIGN
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|void
name|msk_rxcsum
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|uint32_t
name|control
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|int32_t
name|hlen
decl_stmt|,
name|len
decl_stmt|,
name|pktlen
decl_stmt|,
name|temp32
decl_stmt|;
name|uint16_t
name|csum
decl_stmt|,
modifier|*
name|opts
decl_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|control
operator|&
operator|(
name|CSS_IPV4
operator||
name|CSS_IPFRAG
operator|)
operator|)
operator|==
name|CSS_IPV4
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
name|CSS_IPV4_CSUM_OK
operator|)
operator|!=
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
operator|(
name|CSS_TCP
operator||
name|CSS_UDP
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|control
operator|&
operator|(
name|CSS_TCPUDP_CSUM_OK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* 	 * Marvell Yukon controllers that support OP_RXCHKS has known 	 * to have various Rx checksum offloading bugs. These 	 * controllers can be configured to compute simple checksum 	 * at two different positions. So we can compute IP and TCP/UDP 	 * checksum at the same time. We intentionally have controller 	 * compute TCP/UDP checksum twice by specifying the same 	 * checksum start position and compare the result. If the value 	 * is different it would indicate the hardware logic was wrong. 	 */
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_csum
operator|&
literal|0xFFFF
operator|)
operator|!=
operator|(
name|sc_if
operator|->
name|msk_csum
operator|>>
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Rx checksum value mismatch!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pktlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
return|return;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
return|return;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|pktlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|<
name|hlen
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|!=
name|pktlen
condition|)
return|return;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
return|return;
comment|/* can't handle fragmented packet. */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|)
condition|)
return|return;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
condition|)
return|return;
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|uh
operator|->
name|uh_sum
operator|==
literal|0
condition|)
return|return;
comment|/* no checksum */
break|break;
default|default:
return|return;
block|}
name|csum
operator|=
name|bswap16
argument_list|(
name|sc_if
operator|->
name|msk_csum
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* Checksum fixup for IP options. */
name|len
operator|=
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|opts
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|,
name|opts
operator|++
control|)
block|{
name|temp32
operator|=
name|csum
operator|-
operator|*
name|opts
expr_stmt|;
name|temp32
operator|=
operator|(
name|temp32
operator|>>
literal|16
operator|)
operator|+
operator|(
name|temp32
operator|&
literal|65535
operator|)
expr_stmt|;
name|csum
operator|=
name|temp32
operator|&
literal|65535
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|csum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|uint32_t
name|control
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|rxlen
decl_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|cons
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
expr_stmt|;
do|do
block|{
name|rxlen
operator|=
name|status
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
name|rxlen
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_NORXCHK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * For controllers that returns bogus status code 			 * just do minimal check and let upper stack 			 * handle this frame. 			 */
if|if
condition|(
name|len
operator|>
name|MSK_MAX_FRAMELEN
operator|||
name|len
operator|<
name|ETHER_HDR_LEN
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|msk_discard_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|sc_if
operator|->
name|msk_framesize
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_ANY_ERR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_RX_OK
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|rxlen
operator|!=
name|len
operator|)
condition|)
block|{
comment|/* Don't count flow-control packet as errors. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_GOOD_FC
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|msk_discard_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
operator|(
name|cons
operator|+
literal|1
operator|)
operator|%
name|MSK_RX_RING_CNT
index|]
expr_stmt|;
else|#
directive|else
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|cons
index|]
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
if|if
condition|(
name|msk_newbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
comment|/* Reuse old buffer. */
name|msk_discard_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|!=
literal|0
condition|)
name|msk_fixup_rx
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|msk_rxcsum
argument_list|(
name|sc_if
argument_list|,
name|control
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Check for VLAN tagged packets. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|sc_if
operator|->
name|msk_vtag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|MSK_RX_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_RX_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_jumbo_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|uint32_t
name|control
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|rxlen
decl_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|cons
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
expr_stmt|;
do|do
block|{
name|rxlen
operator|=
name|status
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
name|rxlen
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|sc_if
operator|->
name|msk_framesize
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_ANY_ERR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_RX_OK
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|rxlen
operator|!=
name|len
operator|)
condition|)
block|{
comment|/* Don't count flow-control packet as errors. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_GOOD_FC
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|msk_discard_jumbo_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|MSK_64BIT_DMA
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
operator|(
name|cons
operator|+
literal|1
operator|)
operator|%
name|MSK_JUMBO_RX_RING_CNT
index|]
expr_stmt|;
else|#
directive|else
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|cons
index|]
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|jrxd
operator|->
name|rx_m
expr_stmt|;
if|if
condition|(
name|msk_jumbo_newbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
comment|/* Reuse old buffer. */
name|msk_discard_jumbo_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|!=
literal|0
condition|)
name|msk_fixup_rx
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|msk_rxcsum
argument_list|(
name|sc_if
argument_list|,
name|control
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Check for VLAN tagged packets. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|sc_if
operator|->
name|msk_vtag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|MSK_RX_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_RX_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_txeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_tx_desc
modifier|*
name|cur_tx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|control
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|prog
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Go through our tx ring and free mbufs for those 	 * frames that have been sent. 	 */
name|cons
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cons
expr_stmt|;
name|prog
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|cons
operator|!=
name|idx
condition|;
name|MSK_INC
argument_list|(
name|cons
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
control|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|<=
literal|0
condition|)
break|break;
name|prog
operator|++
expr_stmt|;
name|cur_tx
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|cons
index|]
expr_stmt|;
name|control
operator|=
name|le32toh
argument_list|(
name|cur_tx
operator|->
name|msk_control
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|--
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
name|EOP
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|cons
index|]
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: freeing NULL mbuf!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|prog
operator|>
literal|0
condition|)
block|{
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cons
operator|=
name|cons
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|==
literal|0
condition|)
name|sc_if
operator|->
name|msk_watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* No need to sync LEs as we didn't update LEs. */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_tick
parameter_list|(
name|void
modifier|*
name|xsc_if
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc_if
operator|=
name|xsc_if
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
name|msk_miibus_statchg
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|)
expr_stmt|;
name|msk_handle_events
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|)
expr_stmt|;
name|msk_watchdog
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|,
name|hz
argument_list|,
name|msk_tick
argument_list|,
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_intr_phy
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|uint16_t
name|status
decl_stmt|;
name|msk_phy_readreg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_STAT
argument_list|)
expr_stmt|;
name|status
operator|=
name|msk_phy_readreg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_STAT
argument_list|)
expr_stmt|;
comment|/* Handle FIFO Underrun/Overflow? */
if|if
condition|(
operator|(
name|status
operator|&
name|PHY_M_IS_FIFO_ERROR
operator|)
condition|)
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"PHY FIFO underrun/overflow.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_intr_gmac
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|status
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_SRC
argument_list|)
argument_list|)
expr_stmt|;
comment|/* GMAC Rx FIFO overrun. */
if|if
condition|(
operator|(
name|status
operator|&
name|GM_IS_RX_FF_OR
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_CLI_RX_FO
argument_list|)
expr_stmt|;
comment|/* GMAC Tx FIFO underrun. */
if|if
condition|(
operator|(
name|status
operator|&
name|GM_IS_TX_FF_UR
operator|)
operator|!=
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_CLI_TX_FU
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Tx FIFO underrun!\n"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX 		 * In case of Tx underrun, we may need to flush/reset 		 * Tx MAC but that would also require resynchronization 		 * with status LEs. Reinitializing status LEs would 		 * affect other port in dual MAC configuration so it 		 * should be avoided as possible as we can. 		 * Due to lack of documentation it's all vague guess but 		 * it needs more investigation. 		 */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_handle_hwerr
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_RD1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"RAM buffer read parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_CLR_RD_PERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_WR1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"RAM buffer write parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_CLR_WR_PERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_MAC1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Tx MAC parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_CLI_TX_PE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_RX1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Rx parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_IRQ_PAR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_TCP_TXS1
operator||
name|Y2_IS_TCP_TXA1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"TCP segmentation error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_IRQ_TCP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_intr_hwerr
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|tlphead
index|[
literal|4
index|]
decl_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_ISRC
argument_list|)
expr_stmt|;
comment|/* Time Stamp timer overflow. */
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_TIST_OV
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|GMAC_TI_ST_CTRL
argument_list|,
name|GMT_ST_CLR_IRQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PCI_NEXP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * PCI Express Error occured which is not described in PEX 		 * spec. 		 * This error is also mapped either to Master Abort( 		 * Y2_IS_MST_ERR) or Target Abort (Y2_IS_IRQ_STAT) bit and 		 * can only be cleared there.                  */
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"PCI Express protocol violation error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_MST_ERR
operator||
name|Y2_IS_IRQ_STAT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint16_t
name|v16
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_MST_ERR
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"unexpected IRQ Status error\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"unexpected IRQ Master error\n"
argument_list|)
expr_stmt|;
comment|/* Reset all bits in the PCI status register. */
name|v16
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|v16
operator||
name|PCIM_STATUS_PERR
operator||
name|PCIM_STATUS_SERR
operator||
name|PCIM_STATUS_RMABORT
operator||
name|PCIM_STATUS_RTABORT
operator||
name|PCIM_STATUS_MDPERR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
block|}
comment|/* Check for PCI Express Uncorrectable Error. */
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PCI_EXP
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|v32
decl_stmt|;
comment|/* 		 * On PCI Express bus bridges are called root complexes (RC). 		 * PCI Express errors are recognized by the root complex too, 		 * which requests the system to handle the problem. After 		 * error occurence it may be that no access to the adapter 		 * may be performed any longer. 		 */
name|v32
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v32
operator|&
name|PEX_UNSUP_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Ignore unsupported request error. */
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Uncorrectable PCI Express error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v32
operator|&
operator|(
name|PEX_FATAL_ERRORS
operator||
name|PEX_POIS_TLP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Get TLP header form Log Registers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tlphead
index|[
name|i
index|]
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PEX_HEADER_LOG
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Check for vendor defined broadcast message. */
if|if
condition|(
operator|!
operator|(
name|tlphead
index|[
literal|0
index|]
operator|==
literal|0x73004001
operator|&&
name|tlphead
index|[
literal|1
index|]
operator|==
literal|0x7f
operator|)
condition|)
block|{
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_IS_PCI_EXP
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrhwemask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear the interrupt. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_HWE_L1_MASK
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
operator|!=
name|NULL
condition|)
name|msk_handle_hwerr
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_HWE_L2_MASK
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
operator|!=
name|NULL
condition|)
name|msk_handle_hwerr
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
argument_list|,
name|status
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|msk_rxput
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
operator|(
name|MCLBYTES
operator|-
name|MSK_RX_BUF_ALIGN
operator|)
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
else|else
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_handle_events
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|int
name|rxput
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|msk_stat_desc
modifier|*
name|sd
decl_stmt|;
name|uint32_t
name|control
decl_stmt|,
name|status
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|len
decl_stmt|,
name|port
decl_stmt|,
name|rxprog
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_stat_cons
operator|==
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STAT_PUT_IDX
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Sync status LEs. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|rxput
index|[
name|MSK_PORT_A
index|]
operator|=
name|rxput
index|[
name|MSK_PORT_B
index|]
operator|=
literal|0
expr_stmt|;
name|rxprog
operator|=
literal|0
expr_stmt|;
name|cons
operator|=
name|sc
operator|->
name|msk_stat_cons
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sd
operator|=
operator|&
name|sc
operator|->
name|msk_stat_ring
index|[
name|cons
index|]
expr_stmt|;
name|control
operator|=
name|le32toh
argument_list|(
name|sd
operator|->
name|msk_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
name|HW_OWNER
operator|)
operator|==
literal|0
condition|)
break|break;
name|control
operator|&=
operator|~
name|HW_OWNER
expr_stmt|;
name|sd
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|sd
operator|->
name|msk_status
argument_list|)
expr_stmt|;
name|len
operator|=
name|control
operator|&
name|STLE_LEN_MASK
expr_stmt|;
name|port
operator|=
operator|(
name|control
operator|>>
literal|16
operator|)
operator|&
literal|0x01
expr_stmt|;
name|sc_if
operator|=
name|sc
operator|->
name|msk_if
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|sc_if
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"invalid port opcode "
literal|"0x%08x\n"
argument_list|,
name|control
operator|&
name|STLE_OP_MASK
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|control
operator|&
name|STLE_OP_MASK
condition|)
block|{
case|case
name|OP_RXVLAN
case|:
name|sc_if
operator|->
name|msk_vtag
operator|=
name|ntohs
argument_list|(
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RXCHKSVLAN
case|:
name|sc_if
operator|->
name|msk_vtag
operator|=
name|ntohs
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|OP_RXCHKS
case|:
name|sc_if
operator|->
name|msk_csum
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|OP_RXSTAT
case|:
if|if
condition|(
operator|!
operator|(
name|sc_if
operator|->
name|msk_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
break|break;
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
operator|(
name|MCLBYTES
operator|-
name|MSK_RX_BUF_ALIGN
operator|)
condition|)
name|msk_jumbo_rxeof
argument_list|(
name|sc_if
argument_list|,
name|status
argument_list|,
name|control
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|msk_rxeof
argument_list|(
name|sc_if
argument_list|,
name|status
argument_list|,
name|control
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rxprog
operator|++
expr_stmt|;
comment|/* 			 * Because there is no way to sync single Rx LE 			 * put the DMA sync operation off until the end of 			 * event processing. 			 */
name|rxput
index|[
name|port
index|]
operator|++
expr_stmt|;
comment|/* Update prefetch unit if we've passed water mark. */
if|if
condition|(
name|rxput
index|[
name|port
index|]
operator|>=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_putwm
condition|)
block|{
name|msk_rxput
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|rxput
index|[
name|port
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|OP_TXINDEXLE
case|:
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
operator|!=
name|NULL
condition|)
name|msk_txeof
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
argument_list|,
name|status
operator|&
name|STLE_TXA1_MSKL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
operator|!=
name|NULL
condition|)
name|msk_txeof
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
argument_list|,
operator|(
operator|(
name|status
operator|&
name|STLE_TXA2_MSKL
operator|)
operator|>>
name|STLE_TXA2_SHIFTL
operator|)
operator||
operator|(
operator|(
name|len
operator|&
name|STLE_TXA2_MSKH
operator|)
operator|<<
name|STLE_TXA2_SHIFTH
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"unhandled opcode 0x%08x\n"
argument_list|,
name|control
operator|&
name|STLE_OP_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
name|MSK_INC
argument_list|(
name|cons
argument_list|,
name|sc
operator|->
name|msk_stat_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxprog
operator|>
name|sc
operator|->
name|msk_process_limit
condition|)
break|break;
block|}
name|sc
operator|->
name|msk_stat_cons
operator|=
name|cons
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxput
index|[
name|MSK_PORT_A
index|]
operator|>
literal|0
condition|)
name|msk_rxput
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxput
index|[
name|MSK_PORT_B
index|]
operator|>
literal|0
condition|)
name|msk_rxput
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|msk_stat_cons
operator|!=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STAT_PUT_IDX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if0
decl_stmt|,
modifier|*
name|sc_if1
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp0
decl_stmt|,
modifier|*
name|ifp1
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|domore
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reading B0_Y2_SP_ISRC2 masks further interrupts. */
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_Y2_SP_ISRC2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xffffffff
operator|||
operator|(
name|sc
operator|->
name|msk_pflags
operator|&
name|MSK_FLAG_SUSPEND
operator|)
operator|!=
literal|0
operator|||
operator|(
name|status
operator|&
name|sc
operator|->
name|msk_intrmask
operator|)
operator|==
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_Y2_SP_ICR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc_if0
operator|=
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
expr_stmt|;
name|sc_if1
operator|=
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
expr_stmt|;
name|ifp0
operator|=
name|ifp1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc_if0
operator|!=
name|NULL
condition|)
name|ifp0
operator|=
name|sc_if0
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
name|sc_if1
operator|!=
name|NULL
condition|)
name|ifp1
operator|=
name|sc_if1
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_PHY1
operator|)
operator|!=
literal|0
operator|&&
name|sc_if0
operator|!=
name|NULL
condition|)
name|msk_intr_phy
argument_list|(
name|sc_if0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_PHY2
operator|)
operator|!=
literal|0
operator|&&
name|sc_if1
operator|!=
name|NULL
condition|)
name|msk_intr_phy
argument_list|(
name|sc_if1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_MAC1
operator|)
operator|!=
literal|0
operator|&&
name|sc_if0
operator|!=
name|NULL
condition|)
name|msk_intr_gmac
argument_list|(
name|sc_if0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_MAC2
operator|)
operator|!=
literal|0
operator|&&
name|sc_if1
operator|!=
name|NULL
condition|)
name|msk_intr_gmac
argument_list|(
name|sc_if1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_CHK_RX1
operator||
name|Y2_IS_CHK_RX2
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Rx descriptor error\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
operator|(
name|Y2_IS_CHK_RX1
operator||
name|Y2_IS_CHK_RX2
operator|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_CHK_TXA1
operator||
name|Y2_IS_CHK_TXA2
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Tx descriptor error\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
operator|(
name|Y2_IS_CHK_TXA1
operator||
name|Y2_IS_CHK_TXA2
operator|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_HW_ERR
operator|)
operator|!=
literal|0
condition|)
name|msk_intr_hwerr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|domore
operator|=
name|msk_handle_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_STAT_BMU
operator|)
operator|!=
literal|0
operator|&&
name|domore
operator|==
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_CLR_IRQ
argument_list|)
expr_stmt|;
comment|/* Reenable interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_Y2_SP_ICR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp0
operator|!=
name|NULL
operator|&&
operator|(
name|ifp0
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp0
operator|->
name|if_snd
argument_list|)
condition|)
name|msk_start_locked
argument_list|(
name|ifp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp1
operator|!=
name|NULL
operator|&&
operator|(
name|ifp1
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp1
operator|->
name|if_snd
argument_list|)
condition|)
name|msk_start_locked
argument_list|(
name|ifp1
argument_list|)
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_set_tx_stfwd
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EX
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|!=
name|CHIP_REV_YU_EX_A0
operator|)
operator|||
name|sc
operator|->
name|msk_hw_id
operator|>=
name|CHIP_ID_YUKON_SUPR
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_STFW_ENA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
comment|/* Set Tx GMAC FIFO Almost Empty Threshold. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_AE_THR
argument_list|)
argument_list|,
name|MSK_ECU_JUMBO_WM
operator|<<
literal|16
operator||
name|MSK_ECU_AE_THR
argument_list|)
expr_stmt|;
comment|/* Disable Store& Forward mode for Tx. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_STFW_DIS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_STFW_ENA
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
init|=
name|xsc
decl_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_init_locked
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|uint16_t
name|gmac
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Cancel pending I/O and free all Rx/Tx buffers. */
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|<
name|ETHERMTU
condition|)
name|sc_if
operator|->
name|msk_framesize
operator|=
name|ETHERMTU
expr_stmt|;
else|else
name|sc_if
operator|->
name|msk_framesize
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
name|sc_if
operator|->
name|msk_framesize
operator|+=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
operator|&&
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_JUMBO_NOCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|MSK_CSUM_FEATURES
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TXCSUM
operator|)
expr_stmt|;
block|}
comment|/* GMAC Control reset. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_F_LOOPB_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EX
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_SUPR
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_BYP_MACSECRX_ON
operator||
name|GMC_BYP_MACSECTX_ON
operator||
name|GMC_BYP_RETR_ON
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize GMAC first such that speed/duplex/flow-control 	 * parameters are renegotiated when interface is brought up. 	 */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dummy read the Interrupt Source Register. */
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_SRC
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear MIB stats. */
name|msk_stats_clear
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Disable FCS. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|,
name|GM_RXCR_CRC_DIS
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Control Register. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_CTRL
argument_list|,
name|TX_COL_THR
argument_list|(
name|TX_COL_DEF
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Flow Control Register. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_FLOW_CTRL
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Parameter Register. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_PARAM
argument_list|,
name|TX_JAM_LEN_VAL
argument_list|(
name|TX_JAM_LEN_DEF
argument_list|)
operator||
name|TX_JAM_IPG_VAL
argument_list|(
name|TX_JAM_IPG_DEF
argument_list|)
operator||
name|TX_IPG_JAM_DATA
argument_list|(
name|TX_IPG_JAM_DEF
argument_list|)
operator||
name|TX_BACK_OFF_LIM
argument_list|(
name|TX_BOF_LIM_DEF
argument_list|)
argument_list|)
expr_stmt|;
name|gmac
operator|=
name|DATA_BLIND_VAL
argument_list|(
name|DATA_BLIND_DEF
argument_list|)
operator||
name|GM_SMOD_VLAN_ENA
operator||
name|IPG_DATA_VAL
argument_list|(
name|IPG_DATA_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
name|gmac
operator||=
name|GM_SMOD_JUMBO_ENA
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SERIAL_MODE
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Set station address. */
name|eaddr
operator|=
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_1L
argument_list|,
name|eaddr
index|[
literal|0
index|]
operator||
operator|(
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_1M
argument_list|,
name|eaddr
index|[
literal|2
index|]
operator||
operator|(
name|eaddr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_1H
argument_list|,
name|eaddr
index|[
literal|4
index|]
operator||
operator|(
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_2L
argument_list|,
name|eaddr
index|[
literal|0
index|]
operator||
operator|(
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_2M
argument_list|,
name|eaddr
index|[
literal|2
index|]
operator||
operator|(
name|eaddr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_2H
argument_list|,
name|eaddr
index|[
literal|4
index|]
operator||
operator|(
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable interrupts for counter overflows. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_IRQ_MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_IRQ_MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TR_IRQ_MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure Rx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_CLR
argument_list|)
expr_stmt|;
name|reg
operator|=
name|GMF_OPER_ON
operator||
name|GMF_RX_F_FL_ON
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_FE_P
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EX
condition|)
name|reg
operator||=
name|GMF_RX_OVER_ON
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set receive filter. */
name|msk_rxfilter
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
condition|)
block|{
comment|/* Clear flush mask - HW bug. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_FL_MSK
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Flush Rx MAC FIFO on any flow control or error. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_FL_MSK
argument_list|)
argument_list|,
name|GMR_FS_ANY_ERR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set Rx FIFO flush threshold to 64 bytes + 1 FIFO word 	 * due to hardware hang on receipt of pause frames. 	 */
name|reg
operator|=
name|RX_GMF_FL_THR_DEF
operator|+
literal|1
expr_stmt|;
comment|/* Another magic for Yukon FE+ - From Linux. */
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_FE_P
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_FE_P_A0
condition|)
name|reg
operator|=
literal|0x178
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_FL_THR
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Configure Tx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_OPER_ON
argument_list|)
expr_stmt|;
comment|/* Configure hardware VLAN tag insertion/stripping. */
name|msk_setvlan
argument_list|(
name|sc_if
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Set Rx Pause threshold. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_LP_THR
argument_list|)
argument_list|,
name|MSK_ECU_LLPP
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_UP_THR
argument_list|)
argument_list|,
name|MSK_ECU_ULPP
argument_list|)
expr_stmt|;
comment|/* Configure store-and-forward for Tx. */
name|msk_set_tx_stfwd
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_FE_P
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_FE_P_A0
condition|)
block|{
comment|/* Disable dynamic watermark - from Linux. */
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_EA
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
literal|0x03
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_EA
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Disable Force Sync bit and Alloc bit in Tx RAM interface 	 * arbiter as we don't use Sync Tx queue. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TXA_CTRL
argument_list|)
argument_list|,
name|TXA_DIS_FSYNC
operator||
name|TXA_DIS_ALLOC
operator||
name|TXA_STOP_RC
argument_list|)
expr_stmt|;
comment|/* Enable the RAM Interface Arbiter. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TXA_CTRL
argument_list|)
argument_list|,
name|TXA_ENA_ARB
argument_list|)
expr_stmt|;
comment|/* Setup RAM buffer. */
name|msk_set_rambuffer
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Disable Tx sync Queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txsq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
argument_list|)
expr_stmt|;
comment|/* Setup Tx Queue Bus Memory Interface. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_RESET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_OPER_INIT
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_FIFO_OP_ON
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_WM
argument_list|)
argument_list|,
name|MSK_BMU_TX_WM
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|msk_hw_id
condition|)
block|{
case|case
name|CHIP_ID_YUKON_EC_U
case|:
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EC_U_A0
condition|)
block|{
comment|/* Fix for Yukon-EC Ultra: set BMU FIFO level */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_AL
argument_list|)
argument_list|,
name|MSK_ECU_TXFF_LEV
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHIP_ID_YUKON_EX
case|:
comment|/* 		 * Yukon Extreme seems to have silicon bug for 		 * automatic Tx checksum calculation capability. 		 */
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EX_B0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_F
argument_list|)
argument_list|,
name|F_TX_CHK_AUTO_OFF
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Setup Rx Queue Bus Memory Interface. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_RESET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_OPER_INIT
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_FIFO_OP_ON
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_WM
argument_list|)
argument_list|,
name|MSK_BMU_RX_WM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC_U
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>=
name|CHIP_REV_YU_EC_U_A1
condition|)
block|{
comment|/* MAC Rx RAM Read is controlled by hardware. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_F
argument_list|)
argument_list|,
name|F_M_RX_RAM_DIS
argument_list|)
expr_stmt|;
block|}
name|msk_set_prefetch
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring_paddr
argument_list|,
name|MSK_TX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|msk_init_tx_ring
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Disable Rx checksum offload and RSS hash. */
name|reg
operator|=
name|BMU_DIS_RX_RSS_HASH
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_DESCV2
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|reg
operator||=
name|BMU_ENA_RX_CHKSUM
expr_stmt|;
else|else
name|reg
operator||=
name|BMU_DIS_RX_CHKSUM
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
operator|(
name|MCLBYTES
operator|-
name|MSK_RX_BUF_ALIGN
operator|)
condition|)
block|{
name|msk_set_prefetch
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring_paddr
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|msk_init_jumbo_rx_ring
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msk_set_prefetch
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring_paddr
argument_list|,
name|MSK_RX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|msk_init_rx_ring
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"initialization failed: no memory for Rx buffers\n"
argument_list|)
expr_stmt|;
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EX
operator|||
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_SUPR
condition|)
block|{
comment|/* Disable flushing of non-ASF packets. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RX_MACSEC_FLUSH_OFF
argument_list|)
expr_stmt|;
block|}
comment|/* Configure interrupt handling. */
if|if
condition|(
name|sc_if
operator|->
name|msk_port
operator|==
name|MSK_PORT_A
condition|)
block|{
name|sc
operator|->
name|msk_intrmask
operator||=
name|Y2_IS_PORT_A
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator||=
name|Y2_HWE_L1_MASK
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|msk_intrmask
operator||=
name|Y2_IS_PORT_B
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator||=
name|Y2_HWE_L2_MASK
expr_stmt|;
block|}
comment|/* Configure IRQ moderation mask. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_IRQM_MSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_int_holdoff
operator|>
literal|0
condition|)
block|{
comment|/* Configure initial IRQ moderation timer value. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_IRQM_INI
argument_list|,
name|MSK_USECS
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|msk_int_holdoff
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_IRQM_VAL
argument_list|,
name|MSK_USECS
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|msk_int_holdoff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start IRQ moderation. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_IRQM_CTRL
argument_list|,
name|TIM_START
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrhwemask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_flags
operator|&=
operator|~
name|MSK_FLAG_LINK
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|,
name|hz
argument_list|,
name|msk_tick
argument_list|,
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_set_rambuffer
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ltpp
decl_stmt|,
name|utpp
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
operator|(
name|sc_if
operator|->
name|msk_flags
operator|&
name|MSK_FLAG_RAMBUF
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Setup Rx Queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_START
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_END
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_WP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_RP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|utpp
operator|=
operator|(
name|sc
operator|->
name|msk_rxqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|+
literal|1
operator|-
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|-
name|MSK_RB_ULPP
operator|)
operator|/
literal|8
expr_stmt|;
name|ltpp
operator|=
operator|(
name|sc
operator|->
name|msk_rxqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|+
literal|1
operator|-
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|-
name|MSK_RB_LLPP_B
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_rxqsize
operator|<
name|MSK_MIN_RXQ_SIZE
condition|)
name|ltpp
operator|+=
operator|(
name|MSK_RB_LLPP_B
operator|-
name|MSK_RB_LLPP_S
operator|)
operator|/
literal|8
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_RX_UTPP
argument_list|)
argument_list|,
name|utpp
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_RX_LTPP
argument_list|)
argument_list|,
name|ltpp
argument_list|)
expr_stmt|;
comment|/* Set Rx priority(RB_RX_UTHP/RB_RX_LTHP) thresholds? */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_ENA_OP_MD
argument_list|)
expr_stmt|;
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup Tx Queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_START
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_END
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_WP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_RP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Enable Store& Forward for Tx side. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_ENA_STFWD
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_ENA_OP_MD
argument_list|)
expr_stmt|;
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_set_prefetch
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qaddr
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
comment|/* Reset the prefetch unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_CLR
argument_list|)
expr_stmt|;
comment|/* Set LE base address. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_ADDR_LOW_REG
argument_list|)
argument_list|,
name|MSK_ADDR_LO
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_ADDR_HI_REG
argument_list|)
argument_list|,
name|MSK_ADDR_HI
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the list last index. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_LAST_IDX_REG
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Turn on prefetch unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_OP_ON
argument_list|)
expr_stmt|;
comment|/* Dummy read to ensure write. */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_stop
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable interrupts. */
if|if
condition|(
name|sc_if
operator|->
name|msk_port
operator|==
name|MSK_PORT_A
condition|)
block|{
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
name|Y2_IS_PORT_A
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_HWE_L1_MASK
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
name|Y2_IS_PORT_B
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_HWE_L2_MASK
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrhwemask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
comment|/* Disable Tx/Rx MAC. */
name|val
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|GM_GPCR_RX_ENA
operator||
name|GM_GPCR_TX_ENA
operator|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Read again to ensure writing. */
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
comment|/* Update stats and clear counters. */
name|msk_stats_update
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Stop Tx BMU. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_STOP
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|BMU_STOP
operator||
name|BMU_IDLE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_STOP
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Tx BMU stop failed\n"
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
operator||
name|RB_DIS_OP_MD
argument_list|)
expr_stmt|;
comment|/* Disable all GMAC interrupt. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_MSK
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable PHY interrupt. */
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable the RAM Interface Arbiter. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TXA_CTRL
argument_list|)
argument_list|,
name|TXA_DIS_ARB
argument_list|)
expr_stmt|;
comment|/* Reset the PCI FIFO of the async Tx queue */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_RST_SET
operator||
name|BMU_FIFO_RST
argument_list|)
expr_stmt|;
comment|/* Reset the Tx prefetch units. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset the RAM Buffer async Tx queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset Tx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
comment|/* Set Pause Off. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_PAUSE_OFF
argument_list|)
expr_stmt|;
comment|/* 	 * The Rx Stop command will not work for Yukon-2 if the BMU does not 	 * reach the end of packet and since we can't make sure that we have 	 * incoming data, we must reset the BMU while it is not during a DMA 	 * transfer. Since it is possible that the Rx path is still active, 	 * the Rx RAM buffer will be stopped first, so any possible incoming 	 * data will not trigger a DMA. After the RAM buffer is stopped, the 	 * BMU is polled until any DMA in progress is ended and only then it 	 * will be reset. 	 */
comment|/* Disable the RAM Buffer receive queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_DIS_OP_MD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_RSL
argument_list|)
argument_list|)
operator|==
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_RL
argument_list|)
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Rx BMU stop failed\n"
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_RST_SET
operator||
name|BMU_FIFO_RST
argument_list|)
expr_stmt|;
comment|/* Reset the Rx prefetch unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset the RAM Buffer receive queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset Rx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
comment|/* Free Rx and Tx mbufs still in the queues. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxd
operator|->
name|rx_m
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|jrxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|jrxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|jrxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|jrxd
operator|->
name|rx_m
argument_list|)
expr_stmt|;
name|jrxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Mark the interface down. 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc_if
operator|->
name|msk_flags
operator|&=
operator|~
name|MSK_FLAG_LINK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When GM_PAR_MIB_CLR bit of GM_PHY_ADDR is set, reading lower  * counter clears high 16 bits of the counter such that accessing  * lower 16 bits should be the last operation.  */
end_comment

begin_define
define|#
directive|define
name|MSK_READ_MIB32
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(((uint32_t)GMAC_READ_2(sc, x, (y) + 4))<< 16) +	\ 	(uint32_t)GMAC_READ_2(sc, x, y)
end_define

begin_define
define|#
directive|define
name|MSK_READ_MIB64
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(((uint64_t)MSK_READ_MIB32(x, (y) + 8))<< 32) +	\ 	(uint64_t)MSK_READ_MIB32(x, y)
end_define

begin_function
specifier|static
name|void
name|msk_stats_clear
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint16_t
name|gmac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
comment|/* Set MIB Clear Counter Mode. */
name|gmac
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|,
name|gmac
operator||
name|GM_PAR_MIB_CLR
argument_list|)
expr_stmt|;
comment|/* Read all MIB Counters with Clear Mode set. */
for|for
control|(
name|i
operator|=
name|GM_RXF_UC_OK
init|;
name|i
operator|<=
name|GM_TXE_FIFO_UR
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
name|reg
operator|=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Clear MIB Clear Counter Mode. */
name|gmac
operator|&=
operator|~
name|GM_PAR_MIB_CLR
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_stats_update
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|msk_hw_stats
modifier|*
name|stats
decl_stmt|;
name|uint16_t
name|gmac
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|stats
operator|=
operator|&
name|sc_if
operator|->
name|msk_stats
expr_stmt|;
comment|/* Set MIB Clear Counter Mode. */
name|gmac
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|,
name|gmac
operator||
name|GM_PAR_MIB_CLR
argument_list|)
expr_stmt|;
comment|/* Rx stats. */
name|stats
operator|->
name|rx_ucast_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_UC_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_bcast_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_BC_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pause_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_MPAUSE
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_mcast_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_MC_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_crc_errs
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_FCS_ERR
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_SPARE1
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_good_octets
operator|+=
name|MSK_READ_MIB64
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXO_OK_LO
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_bad_octets
operator|+=
name|MSK_READ_MIB64
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXO_ERR_LO
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_runts
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_SHT
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_runt_errs
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXE_FRAG
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_64
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_64B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_65_127
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_127B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_128_255
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_255B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_256_511
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_511B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_512_1023
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_1023B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_1024_1518
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_1518B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_1519_max
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_MAX_SZ
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_too_long
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_LNG_ERR
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_pkts_jabbers
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_JAB_PKT
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_SPARE2
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_fifo_oflows
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXE_FIFO_OV
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RXF_SPARE3
argument_list|)
expr_stmt|;
comment|/* Tx stats. */
name|stats
operator|->
name|tx_ucast_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_UC_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_bcast_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_BC_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pause_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_MPAUSE
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_mcast_frames
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_MC_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_octets
operator|+=
name|MSK_READ_MIB64
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXO_OK_LO
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pkts_64
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_64B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pkts_65_127
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_127B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pkts_128_255
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_255B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pkts_256_511
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_511B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pkts_512_1023
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_1023B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pkts_1024_1518
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_1518B
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_pkts_1519_max
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_MAX_SZ
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_SPARE1
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_colls
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_COL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_late_colls
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_LAT_COL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_excess_colls
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_ABO_COL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_multi_colls
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_MUL_COL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_single_colls
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXF_SNG_COL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_underflows
operator|+=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TXE_FIFO_UR
argument_list|)
expr_stmt|;
comment|/* Clear MIB Clear Counter Mode. */
name|gmac
operator|&=
operator|~
name|GM_PAR_MIB_CLR
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_sysctl_stat32
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|uint32_t
name|result
decl_stmt|,
modifier|*
name|stat
decl_stmt|;
name|int
name|off
decl_stmt|;
name|sc_if
operator|=
operator|(
expr|struct
name|msk_if_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|off
operator|=
name|arg2
expr_stmt|;
name|stat
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_stats
operator|+
name|off
operator|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|result
operator|=
name|MSK_READ_MIB32
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MIB_CNT_BASE
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
name|result
operator|+=
operator|*
name|stat
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_sysctl_stat64
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|uint64_t
name|result
decl_stmt|,
modifier|*
name|stat
decl_stmt|;
name|int
name|off
decl_stmt|;
name|sc_if
operator|=
operator|(
expr|struct
name|msk_if_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|off
operator|=
name|arg2
expr_stmt|;
name|stat
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_stats
operator|+
name|off
operator|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|result
operator|=
name|MSK_READ_MIB64
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MIB_CNT_BASE
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
name|result
operator|+=
operator|*
name|stat
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_quad
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MSK_READ_MIB32
end_undef

begin_undef
undef|#
directive|undef
name|MSK_READ_MIB64
end_undef

begin_define
define|#
directive|define
name|MSK_SYSCTL_STAT32
parameter_list|(
name|sc
parameter_list|,
name|c
parameter_list|,
name|o
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|SYSCTL_ADD_PROC(c, p, OID_AUTO, o, CTLTYPE_UINT | CTLFLAG_RD, 	\ 	    sc, offsetof(struct msk_hw_stats, n), msk_sysctl_stat32,	\ 	    "IU", d)
end_define

begin_define
define|#
directive|define
name|MSK_SYSCTL_STAT64
parameter_list|(
name|sc
parameter_list|,
name|c
parameter_list|,
name|o
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|SYSCTL_ADD_PROC(c, p, OID_AUTO, o, CTLTYPE_UINT | CTLFLAG_RD, 	\ 	    sc, offsetof(struct msk_hw_stats, n), msk_sysctl_stat64,	\ 	    "Q", d)
end_define

begin_function
specifier|static
name|void
name|msk_sysctl_node
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|,
modifier|*
name|schild
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"MSK Statistics"
argument_list|)
expr_stmt|;
name|schild
operator|=
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|schild
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"MSK RX Statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"ucast_frames"
argument_list|,
name|child
argument_list|,
name|rx_ucast_frames
argument_list|,
literal|"Good unicast frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"bcast_frames"
argument_list|,
name|child
argument_list|,
name|rx_bcast_frames
argument_list|,
literal|"Good broadcast frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"pause_frames"
argument_list|,
name|child
argument_list|,
name|rx_pause_frames
argument_list|,
literal|"Pause frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"mcast_frames"
argument_list|,
name|child
argument_list|,
name|rx_mcast_frames
argument_list|,
literal|"Multicast frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"crc_errs"
argument_list|,
name|child
argument_list|,
name|rx_crc_errs
argument_list|,
literal|"CRC errors"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT64
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"good_octets"
argument_list|,
name|child
argument_list|,
name|rx_good_octets
argument_list|,
literal|"Good octets"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT64
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"bad_octets"
argument_list|,
name|child
argument_list|,
name|rx_bad_octets
argument_list|,
literal|"Bad octets"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_64"
argument_list|,
name|child
argument_list|,
name|rx_pkts_64
argument_list|,
literal|"64 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_65_127"
argument_list|,
name|child
argument_list|,
name|rx_pkts_65_127
argument_list|,
literal|"65 to 127 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_128_255"
argument_list|,
name|child
argument_list|,
name|rx_pkts_128_255
argument_list|,
literal|"128 to 255 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_256_511"
argument_list|,
name|child
argument_list|,
name|rx_pkts_256_511
argument_list|,
literal|"256 to 511 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_512_1023"
argument_list|,
name|child
argument_list|,
name|rx_pkts_512_1023
argument_list|,
literal|"512 to 1023 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_1024_1518"
argument_list|,
name|child
argument_list|,
name|rx_pkts_1024_1518
argument_list|,
literal|"1024 to 1518 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_1519_max"
argument_list|,
name|child
argument_list|,
name|rx_pkts_1519_max
argument_list|,
literal|"1519 to max frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_too_long"
argument_list|,
name|child
argument_list|,
name|rx_pkts_too_long
argument_list|,
literal|"frames too long"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"jabbers"
argument_list|,
name|child
argument_list|,
name|rx_pkts_jabbers
argument_list|,
literal|"Jabber errors"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"overflows"
argument_list|,
name|child
argument_list|,
name|rx_fifo_oflows
argument_list|,
literal|"FIFO overflows"
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|schild
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"MSK TX Statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"ucast_frames"
argument_list|,
name|child
argument_list|,
name|tx_ucast_frames
argument_list|,
literal|"Unicast frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"bcast_frames"
argument_list|,
name|child
argument_list|,
name|tx_bcast_frames
argument_list|,
literal|"Broadcast frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"pause_frames"
argument_list|,
name|child
argument_list|,
name|tx_pause_frames
argument_list|,
literal|"Pause frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"mcast_frames"
argument_list|,
name|child
argument_list|,
name|tx_mcast_frames
argument_list|,
literal|"Multicast frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT64
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"octets"
argument_list|,
name|child
argument_list|,
name|tx_octets
argument_list|,
literal|"Octets"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_64"
argument_list|,
name|child
argument_list|,
name|tx_pkts_64
argument_list|,
literal|"64 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_65_127"
argument_list|,
name|child
argument_list|,
name|tx_pkts_65_127
argument_list|,
literal|"65 to 127 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_128_255"
argument_list|,
name|child
argument_list|,
name|tx_pkts_128_255
argument_list|,
literal|"128 to 255 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_256_511"
argument_list|,
name|child
argument_list|,
name|tx_pkts_256_511
argument_list|,
literal|"256 to 511 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_512_1023"
argument_list|,
name|child
argument_list|,
name|tx_pkts_512_1023
argument_list|,
literal|"512 to 1023 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_1024_1518"
argument_list|,
name|child
argument_list|,
name|tx_pkts_1024_1518
argument_list|,
literal|"1024 to 1518 bytes frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"frames_1519_max"
argument_list|,
name|child
argument_list|,
name|tx_pkts_1519_max
argument_list|,
literal|"1519 to max frames"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"colls"
argument_list|,
name|child
argument_list|,
name|tx_colls
argument_list|,
literal|"Collisions"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"late_colls"
argument_list|,
name|child
argument_list|,
name|tx_late_colls
argument_list|,
literal|"Late collisions"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"excess_colls"
argument_list|,
name|child
argument_list|,
name|tx_excess_colls
argument_list|,
literal|"Excessive collisions"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"multi_colls"
argument_list|,
name|child
argument_list|,
name|tx_multi_colls
argument_list|,
literal|"Multiple collisions"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"single_colls"
argument_list|,
name|child
argument_list|,
name|tx_single_colls
argument_list|,
literal|"Single collisions"
argument_list|)
expr_stmt|;
name|MSK_SYSCTL_STAT32
argument_list|(
name|sc_if
argument_list|,
name|ctx
argument_list|,
literal|"underflows"
argument_list|,
name|child
argument_list|,
name|tx_underflows
argument_list|,
literal|"FIFO underflows"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MSK_SYSCTL_STAT32
end_undef

begin_undef
undef|#
directive|undef
name|MSK_SYSCTL_STAT64
end_undef

begin_function
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|arg1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
name|low
operator|||
name|value
operator|>
name|high
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_msk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|MSK_PROC_MIN
argument_list|,
name|MSK_PROC_MAX
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

