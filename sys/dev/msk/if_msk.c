begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Name   : sky2.c  * Project: Gigabit Ethernet Driver for FreeBSD 5.x/6.x  * Version: $Revision: 1.23 $  * Date   : $Date: 2005/12/22 09:04:11 $  * Purpose: Main driver source file  *  *****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  *  *	LICENSE:  *	Copyright (C) Marvell International Ltd. and/or its affiliates  *  *	The computer program files contained in this folder ("Files")  *	are provided to you under the BSD-type license terms provided  *	below, and any use of such Files and any derivative works  *	thereof created by you shall be governed by the following terms  *	and conditions:  *  *	- Redistributions of source code must retain the above copyright  *	  notice, this list of conditions and the following disclaimer.  *	- Redistributions in binary form must reproduce the above  *	  copyright notice, this list of conditions and the following  *	  disclaimer in the documentation and/or other materials provided  *	  with the distribution.  *	- Neither the name of Marvell nor the names of its contributors  *	  may be used to endorse or promote products derived from this  *	  software without specific prior written permission.  *  *	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  *	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  *	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  *	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  *	BUT NOT LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES;  *	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  *	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  *	OF THE POSSIBILITY OF SUCH DAMAGE.  *	/LICENSE  *  *****************************************************************************/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 1999, 2000  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003 Nathan L. Binkert<binkertn@umich.edu>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Device driver for the Marvell Yukon II Ethernet controller.  * Due to lack of documentation, this driver is based on the code from  * sk(4) and Marvell's myk(4) driver for FreeBSD 5.x.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/brgphyreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/msk/if_mskreg.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|msk
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|msk
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|msk
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* "device miibus" required.  See GENERIC if you get errors here. */
end_comment

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/* Tunables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msi_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.msk.msi_disable"
argument_list|,
operator|&
name|msi_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MSK_CSUM_FEATURES
value|(CSUM_TCP | CSUM_UDP)
end_define

begin_comment
comment|/*  * Devices supported by this driver.  */
end_comment

begin_struct
specifier|static
struct|struct
name|msk_product
block|{
name|uint16_t
name|msk_vendorid
decl_stmt|;
name|uint16_t
name|msk_deviceid
decl_stmt|;
specifier|const
name|char
modifier|*
name|msk_name
decl_stmt|;
block|}
name|msk_products
index|[]
init|=
block|{
block|{
name|VENDORID_SK
block|,
name|DEVICEID_SK_YUKON2
block|,
literal|"SK-9Sxx Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_SK
block|,
name|DEVICEID_SK_YUKON2_EXPR
block|,
literal|"SK-9Exx Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8021CU
block|,
literal|"Marvell Yukon 88E8021CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8021X
block|,
literal|"Marvell Yukon 88E8021 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8022CU
block|,
literal|"Marvell Yukon 88E8022CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8022X
block|,
literal|"Marvell Yukon 88E8022 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8061CU
block|,
literal|"Marvell Yukon 88E8061CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8061X
block|,
literal|"Marvell Yukon 88E8061 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8062CU
block|,
literal|"Marvell Yukon 88E8062CU Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8062X
block|,
literal|"Marvell Yukon 88E8062 SX/LX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8035
block|,
literal|"Marvell Yukon 88E8035 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8036
block|,
literal|"Marvell Yukon 88E8036 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_8038
block|,
literal|"Marvell Yukon 88E8038 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4361
block|,
literal|"Marvell Yukon 88E8050 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4360
block|,
literal|"Marvell Yukon 88E8052 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4362
block|,
literal|"Marvell Yukon 88E8053 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4363
block|,
literal|"Marvell Yukon 88E8055 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_MARVELL
block|,
name|DEVICEID_MRVL_4364
block|,
literal|"Marvell Yukon 88E8056 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_DLINK
block|,
name|DEVICEID_DLINK_DGE550SX
block|,
literal|"D-Link 550SX Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_DLINK
block|,
name|DEVICEID_DLINK_DGE560T
block|,
literal|"D-Link 560T Gigabit Ethernet"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|model_name
index|[]
init|=
block|{
literal|"Yukon XL"
block|,
literal|"Yukon EC Ultra"
block|,
literal|"Yukon Unknown"
block|,
literal|"Yukon EC"
block|,
literal|"Yukon FE"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mskc_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mskc_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_setup_rambuffer
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mskc_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mskc_reset
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_int_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_intr_phy
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_intr_gmac
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_rxput
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_handle_events
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_handle_hwerr
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_intr_hwerr
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_jumbo_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_txeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|msk_defrag
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_encap
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_tx_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_set_prefetch
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_addr_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_set_rambuffer
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_init_locked
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_stop
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_watchdog
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_phy_power
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_dmamap_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_status_dma_alloc
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_status_dma_free
parameter_list|(
name|struct
name|msk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_txrx_dma_alloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_txrx_dma_free
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|msk_jalloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_jfree
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_init_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_init_jumbo_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_init_tx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_discard_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|msk_discard_jumbo_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_jumbo_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_phy_readreg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_phy_writereg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msk_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_link_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_setmulti
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_setvlan
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msk_setpromisc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_msk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|mskc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mskc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mskc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mskc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|mskc_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|mskc_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|mskc_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mskc_driver
init|=
block|{
literal|"mskc"
block|,
name|mskc_methods
block|,
expr|sizeof
operator|(
expr|struct
name|msk_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|mskc_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|msk_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|msk_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|msk_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|msk_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|msk_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|msk_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|msk_miibus_statchg
argument_list|)
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|msk_driver
init|=
block|{
literal|"msk"
block|,
name|msk_methods
block|,
expr|sizeof
operator|(
expr|struct
name|msk_if_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|msk_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mskc
argument_list|,
name|pci
argument_list|,
name|mskc_driver
argument_list|,
name|mskc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|msk
argument_list|,
name|mskc
argument_list|,
name|msk_driver
argument_list|,
name|msk_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|msk
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_res_spec_io
index|[]
init|=
block|{
block|{
name|SYS_RES_IOPORT
block|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_res_spec_mem
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_irq_spec_legacy
index|[]
init|=
block|{
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|msk_irq_spec_msi
index|[]
init|=
block|{
block|{
name|SYS_RES_IRQ
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|2
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|msk_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|msk_phy_readreg
argument_list|(
name|sc_if
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_phy_readreg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|,
name|GM_SMI_CT_PHY_AD
argument_list|(
name|phy
argument_list|)
operator||
name|GM_SMI_CT_REG_AD
argument_list|(
name|reg
argument_list|)
operator||
name|GM_SMI_CT_OP_RD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|GM_SMI_CT_RD_VAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_DATA
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|sc_if
operator|->
name|msk_ifp
argument_list|,
literal|"phy failed to come ready\n"
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_phy_writereg
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|,
name|GM_SMI_CT_PHY_AD
argument_list|(
name|phy
argument_list|)
operator||
name|GM_SMI_CT_REG_AD
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SMI_CTRL
argument_list|)
operator|&
name|GM_SMI_CT_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
name|if_printf
argument_list|(
name|sc_if
operator|->
name|msk_ifp
argument_list|,
literal|"phy write timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_link_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_link_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|gmac
decl_stmt|;
name|sc_if
operator|=
operator|(
expr|struct
name|msk_if_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
name|mii
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
block|{
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
condition|)
block|{
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|!=
name|IFM_NONE
condition|)
name|sc_if
operator|->
name|msk_link
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|sc_if
operator|->
name|msk_link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_link
operator|!=
literal|0
condition|)
block|{
comment|/* Enable Tx FIFO Underrun. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_MSK
argument_list|)
argument_list|,
name|GM_IS_TX_FF_UR
operator||
name|GM_IS_RX_FF_OR
argument_list|)
expr_stmt|;
comment|/* 		 * Because mii(4) notify msk(4) that it detected link status 		 * change, there is no need to enable automatic 		 * speed/flow-control/duplex updates. 		 */
name|gmac
operator|=
name|GM_GPCR_AU_ALL_DIS
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_T
case|:
name|gmac
operator||=
name|GM_GPCR_SPEED_1000
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|gmac
operator||=
name|GM_GPCR_SPEED_100
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|gmac
operator||=
name|GM_GPCR_DUP_FULL
expr_stmt|;
comment|/* Disable Rx flow control. */
if|if
condition|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
name|IFM_FLAG0
operator|)
operator|==
literal|0
condition|)
name|gmac
operator||=
name|GM_GPCR_FC_RX_DIS
expr_stmt|;
comment|/* Disable Tx flow control. */
if|if
condition|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
name|IFM_FLAG1
operator|)
operator|==
literal|0
condition|)
name|gmac
operator||=
name|GM_GPCR_FC_TX_DIS
expr_stmt|;
name|gmac
operator||=
name|GM_GPCR_RX_ENA
operator||
name|GM_GPCR_TX_ENA
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Read again to ensure writing. */
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
name|gmac
operator|=
name|GMC_PAUSE_ON
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
operator|(
name|IFM_FLAG0
operator||
name|IFM_FLAG1
operator|)
operator|)
operator|==
literal|0
condition|)
name|gmac
operator|=
name|GMC_PAUSE_OFF
expr_stmt|;
comment|/* Diable pause for 10/100 Mbps in half-duplex mode. */
if|if
condition|(
operator|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_100_TX
operator|||
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_10_T
operator|)
condition|)
name|gmac
operator|=
name|GMC_PAUSE_OFF
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Enable PHY interrupt for FIFO underrun/overflow. */
if|if
condition|(
name|sc
operator|->
name|msk_marvell_phy
condition|)
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_MASK
argument_list|,
name|PHY_M_IS_FIFO_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Link state changed to down. 		 * Disable PHY interrupts. 		 */
if|if
condition|(
name|sc
operator|->
name|msk_marvell_phy
condition|)
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable Rx/Tx MAC. */
name|gmac
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
name|gmac
operator|&=
operator|~
operator|(
name|GM_GPCR_RX_ENA
operator||
name|GM_GPCR_TX_ENA
operator|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Read again to ensure writing. */
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_setmulti
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint32_t
name|mchash
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|bzero
argument_list|(
name|mchash
argument_list|,
sizeof|sizeof
argument_list|(
name|mchash
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|)
expr_stmt|;
name|mode
operator||=
name|GM_RXCR_UCF_ENA
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|&=
operator|~
operator|(
name|GM_RXCR_UCF_ENA
operator||
name|GM_RXCR_MCF_ENA
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|mchash
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|mchash
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
else|else
block|{
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_be
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Just want the 6 least significant bits. */
name|crc
operator|&=
literal|0x3f
expr_stmt|;
comment|/* Set the corresponding bit in the hash table. */
name|mchash
index|[
name|crc
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mode
operator||=
name|GM_RXCR_MCF_ENA
expr_stmt|;
block|}
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H1
argument_list|,
name|mchash
index|[
literal|0
index|]
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H2
argument_list|,
operator|(
name|mchash
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H3
argument_list|,
name|mchash
index|[
literal|1
index|]
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MC_ADDR_H4
argument_list|,
operator|(
name|mchash
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_setvlan
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|RX_VLAN_STRIP_ON
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_VLAN_TAG_ON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|RX_VLAN_STRIP_OFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_VLAN_TAG_OFF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_setpromisc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|mode
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|mode
operator|&=
operator|~
operator|(
name|GM_RXCR_UCF_ENA
operator||
name|GM_RXCR_MCF_ENA
operator|)
expr_stmt|;
else|else
name|mode
operator||=
operator|(
name|GM_RXCR_UCF_ENA
operator||
name|GM_RXCR_MCF_ENA
operator|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_init_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|prod
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_putwm
operator|=
name|MSK_PUT_WM
expr_stmt|;
name|rd
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|msk_rx_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_rx_desc
argument_list|)
operator|*
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
name|prod
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_rx_ring
index|[
name|prod
index|]
expr_stmt|;
if|if
condition|(
name|msk_newbuf
argument_list|(
name|sc_if
argument_list|,
name|prod
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Update prefetch unit. */
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
name|MSK_RX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_init_jumbo_rx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|prod
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_putwm
operator|=
name|MSK_PUT_WM
expr_stmt|;
name|rd
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|msk_jumbo_rx_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_rx_desc
argument_list|)
operator|*
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
name|prod
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|prod
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_le
operator|=
operator|&
name|rd
operator|->
name|msk_jumbo_rx_ring
index|[
name|prod
index|]
expr_stmt|;
if|if
condition|(
name|msk_jumbo_newbuf
argument_list|(
name|sc_if
argument_list|,
name|prod
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
operator|=
name|MSK_JUMBO_RX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_init_tx_ring
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tso_mtu
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cons
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|=
literal|0
expr_stmt|;
name|rd
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|msk_tx_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_tx_desc
argument_list|)
operator|*
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_le
operator|=
operator|&
name|rd
operator|->
name|msk_tx_ring
index|[
name|i
index|]
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|msk_discard_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|idx
index|]
expr_stmt|;
name|m
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|m
operator|->
name|m_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|msk_discard_jumbo_rxbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|idx
index|]
expr_stmt|;
name|m
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|m
operator|->
name|m_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|rxd
operator|->
name|rx_dmamap
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_jumbo_newbuf
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_rx_desc
modifier|*
name|rx_le
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|buf
operator|=
name|msk_jalloc
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Attach the buffer to the mbuf. */
name|MEXTADD
argument_list|(
name|m
argument_list|,
name|buf
argument_list|,
name|MSK_JLEN
argument_list|,
name|msk_jfree
argument_list|,
operator|(
expr|struct
name|msk_if_softc
operator|*
operator|)
name|sc_if
argument_list|,
literal|0
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|MSK_JLEN
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|rxd
operator|->
name|rx_dmamap
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|m
expr_stmt|;
name|rx_le
operator|=
name|rxd
operator|->
name|rx_le
expr_stmt|;
name|rx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|OP_PACKET
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set media options.  */
end_comment

begin_function
specifier|static
name|int
name|msk_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report current media status.  */
end_comment

begin_function
specifier|static
name|void
name|msk_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|MSK_JUMBO_MTU
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc_if
operator|->
name|msk_softc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC_U
operator|&&
name|ifr
operator|->
name|ifr_mtu
operator|>
name|MSK_MAX_FRAMELEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc_if
operator|->
name|msk_if_flags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
name|msk_setpromisc
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|msk_setmulti
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_detach
operator|==
literal|0
condition|)
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
name|sc_if
operator|->
name|msk_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|msk_setmulti
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|MSK_CSUM_FEATURES
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|MSK_CSUM_FEATURES
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|msk_setvlan
argument_list|(
name|sc_if
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TSO4
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_product
modifier|*
name|mp
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|,
name|devid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|=
name|msk_products
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|msk_products
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|msk_products
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|mp
operator|->
name|msk_vendorid
operator|&&
name|devid
operator|==
name|mp
operator|->
name|msk_deviceid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|mp
operator|->
name|msk_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_setup_rambuffer
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|totqsize
decl_stmt|,
name|minqsize
decl_stmt|;
name|int
name|avail
decl_stmt|,
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|val
decl_stmt|;
comment|/* Get adapter SRAM size. */
name|val
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_E_0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_ramsize
operator|=
operator|(
name|val
operator|==
literal|0
operator|)
condition|?
literal|128
else|:
name|val
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_FE
condition|)
name|sc
operator|->
name|msk_ramsize
operator|=
literal|4
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"RAM buffer size : %dKB\n"
argument_list|,
name|sc
operator|->
name|msk_ramsize
argument_list|)
expr_stmt|;
name|totqsize
operator|=
name|sc
operator|->
name|msk_ramsize
operator|*
name|sc
operator|->
name|msk_num_port
expr_stmt|;
name|minqsize
operator|=
name|MSK_MIN_RXQ_SIZE
operator|+
name|MSK_MIN_TXQ_SIZE
expr_stmt|;
if|if
condition|(
name|minqsize
operator|>
name|sc
operator|->
name|msk_ramsize
condition|)
name|minqsize
operator|=
name|sc
operator|->
name|msk_ramsize
expr_stmt|;
if|if
condition|(
name|minqsize
operator|*
name|sc
operator|->
name|msk_num_port
operator|>
name|totqsize
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"not enough RAM buffer memory : %d/%dKB\n"
argument_list|,
name|minqsize
operator|*
name|sc
operator|->
name|msk_num_port
argument_list|,
name|totqsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|avail
operator|=
name|totqsize
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Divide up the memory evenly so that everyone gets a 		 * fair share for dual port adapters. 		 */
name|avail
operator|=
name|sc
operator|->
name|msk_ramsize
expr_stmt|;
block|}
comment|/* Take away the minimum memory for active queues. */
name|avail
operator|-=
name|minqsize
expr_stmt|;
comment|/* Rx queue gets the minimum + 80% of the rest. */
name|sc
operator|->
name|msk_rxqsize
operator|=
operator|(
name|avail
operator|*
name|MSK_RAM_QUOTA_RX
operator|)
operator|/
literal|100
operator|+
name|MSK_MIN_RXQ_SIZE
expr_stmt|;
name|avail
operator|-=
operator|(
name|sc
operator|->
name|msk_rxqsize
operator|-
name|MSK_MIN_RXQ_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|msk_txqsize
operator|=
name|avail
operator|+
name|MSK_MIN_TXQ_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|next
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|msk_rxqstart
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
name|sc
operator|->
name|msk_rxqend
index|[
name|i
index|]
operator|=
name|next
operator|+
operator|(
name|sc
operator|->
name|msk_rxqsize
operator|*
literal|1024
operator|)
operator|-
literal|1
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|msk_rxqend
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|msk_txqstart
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
name|sc
operator|->
name|msk_txqend
index|[
name|i
index|]
operator|=
name|next
operator|+
operator|(
name|sc
operator|->
name|msk_txqsize
operator|*
literal|1024
operator|)
operator|-
literal|1
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|msk_txqend
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Port %d : Rx Queue %dKB(0x%08x:0x%08x)\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|msk_rxqsize
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msk_rxqend
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Port %d : Tx Queue %dKB(0x%08x:0x%08x)\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|msk_txqsize
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msk_txqend
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_phy_power
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MSK_PHY_POWERUP
case|:
comment|/* Switch power to VCC (WA for VAUX problem). */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B0_POWER_CTRL
argument_list|,
name|PC_VAUX_ENA
operator||
name|PC_VCC_ENA
operator||
name|PC_VAUX_OFF
operator||
name|PC_VCC_ON
argument_list|)
expr_stmt|;
comment|/* Disable Core Clock Division, set Clock Select to 0. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_CTRL
argument_list|,
name|Y2_CLK_DIV_DIS
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
comment|/* Enable bits are inverted. */
name|val
operator|=
name|Y2_PCI_CLK_LNK1_DIS
operator||
name|Y2_COR_CLK_LNK1_DIS
operator||
name|Y2_CLK_GAT_LNK1_DIS
operator||
name|Y2_PCI_CLK_LNK2_DIS
operator||
name|Y2_COR_CLK_LNK2_DIS
operator||
name|Y2_CLK_GAT_LNK2_DIS
expr_stmt|;
block|}
comment|/* 		 * Enable PCI& Core Clock, enable clock gating for both Links. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_GATE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|PCI_Y2_PHY1_POWD
operator||
name|PCI_Y2_PHY2_POWD
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
comment|/* Deassert Low Power for 1st PHY. */
name|val
operator||=
name|PCI_Y2_PHY1_COMA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
name|val
operator||=
name|PCI_Y2_PHY2_COMA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC_U
condition|)
block|{
name|uint32_t
name|our
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_HW_WOL_ON
argument_list|)
expr_stmt|;
comment|/* Enable all clocks. */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_3
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|our
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|our
operator|&=
operator|(
name|PCI_FORCE_ASPM_REQUEST
operator||
name|PCI_ASPM_GPHY_LINK_DOWN
operator||
name|PCI_ASPM_INT_FIFO_EMPTY
operator||
name|PCI_ASPM_CLKRUN_REQUEST
operator|)
expr_stmt|;
comment|/* Set all bits to 0 except bits 15..12. */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_4
argument_list|,
name|our
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set to default value. */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Release PHY from PowerDown/COMA mode. */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_LINK_CTRL
argument_list|)
argument_list|,
name|GMLC_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_LINK_CTRL
argument_list|)
argument_list|,
name|GMLC_RST_CLR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MSK_PHY_POWERDOWN
case|:
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator||=
name|PCI_Y2_PHY1_POWD
operator||
name|PCI_Y2_PHY2_POWD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
name|val
operator|&=
operator|~
name|PCI_Y2_PHY1_COMA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
name|val
operator|&=
operator|~
name|PCI_Y2_PHY2_COMA
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|Y2_PCI_CLK_LNK1_DIS
operator||
name|Y2_COR_CLK_LNK1_DIS
operator||
name|Y2_CLK_GAT_LNK1_DIS
operator||
name|Y2_PCI_CLK_LNK2_DIS
operator||
name|Y2_COR_CLK_LNK2_DIS
operator||
name|Y2_CLK_GAT_LNK2_DIS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_XL
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>
name|CHIP_REV_YU_XL_A1
condition|)
block|{
comment|/* Enable bits are inverted. */
name|val
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Disable PCI& Core Clock, disable clock gating for 		 * both Links. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_GATE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B0_POWER_CTRL
argument_list|,
name|PC_VAUX_ENA
operator||
name|PC_VCC_ENA
operator||
name|PC_VAUX_ON
operator||
name|PC_VCC_OFF
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mskc_reset
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_addr_t
name|addr
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_CLR
argument_list|)
expr_stmt|;
comment|/* Disable ASF. */
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|<
name|CHIP_ID_YUKON_XL
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B28_Y2_ASF_STAT_CMD
argument_list|,
name|Y2_ASF_RESET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_ASF_DISABLE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Since we disabled ASF, S/W reset is required for Power Management. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_CLR
argument_list|)
expr_stmt|;
comment|/* Clear all error bits in the PCI status register. */
name|status
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|status
operator||
name|PCIM_STATUS_PERR
operator||
name|PCIM_STATUS_SERR
operator||
name|PCIM_STATUS_RMABORT
operator||
name|PCIM_STATUS_RTABORT
operator||
name|PCIM_STATUS_PERRREPORT
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_MRST_CLR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|msk_bustype
condition|)
block|{
case|case
name|MSK_PEX_BUS
case|:
comment|/* Clear all PEX errors. */
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PEX_RX_OV
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
name|Y2_IS_HW_ERR
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_IS_PCI_EXP
expr_stmt|;
block|}
break|break;
case|case
name|MSK_PCI_BUS
case|:
case|case
name|MSK_PCIX_BUS
case|:
comment|/* Set Cache Line Size to 2(8bytes) if configured to 0. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_bustype
operator|==
name|MSK_PCIX_BUS
condition|)
block|{
comment|/* Set Cache Line Size opt. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator||=
name|PCI_CLS_OPT
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCI_OUR_REG_1
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Set PHY power state. */
name|msk_phy_power
argument_list|(
name|sc
argument_list|,
name|MSK_PHY_POWERUP
argument_list|)
expr_stmt|;
comment|/* Reset GPHY/GMAC Control */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
comment|/* GPHY Control reset. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GPHY_CTRL
argument_list|)
argument_list|,
name|GPC_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GPHY_CTRL
argument_list|)
argument_list|,
name|GPC_RST_CLR
argument_list|)
expr_stmt|;
comment|/* GMAC Control reset. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|i
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_F_LOOPB_OFF
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
comment|/* LED On. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_LED_STAT_ON
argument_list|)
expr_stmt|;
comment|/* Clear TWSI IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B2_I2C_IRQ
argument_list|,
name|I2C_CLR_IRQ
argument_list|)
expr_stmt|;
comment|/* Turn off hardware timer. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TI_CTRL
argument_list|,
name|TIM_STOP
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TI_CTRL
argument_list|,
name|TIM_CLR_IRQ
argument_list|)
expr_stmt|;
comment|/* Turn off descriptor polling. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B28_DPT_CTRL
argument_list|,
name|DPT_STOP
argument_list|)
expr_stmt|;
comment|/* Turn off time stamps. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|GMAC_TI_ST_CTRL
argument_list|,
name|GMT_ST_STOP
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|GMAC_TI_ST_CTRL
argument_list|,
name|GMT_ST_CLR_IRQ
argument_list|)
expr_stmt|;
comment|/* Configure timeout values. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_R1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XA1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XS1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_R1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XA1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XS1
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_R2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XA2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_WTO_XS2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_R2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XA2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|i
argument_list|,
name|B3_RI_RTO_XS2
argument_list|)
argument_list|,
name|MSK_RI_TO_53
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
comment|/*          * On dual port PCI-X card, there is an problem where status          * can be received out of order due to split transactions.          */
if|if
condition|(
name|sc
operator|->
name|msk_bustype
operator|==
name|MSK_PCIX_BUS
operator|&&
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
block|{
name|int
name|pcix
decl_stmt|;
name|uint16_t
name|pcix_cmd
decl_stmt|;
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIY_PCIX
argument_list|,
operator|&
name|pcix
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pcix_cmd
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|pcix
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear Max Outstanding Split Transactions. */
name|pcix_cmd
operator|&=
operator|~
literal|0x70
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|pcix
operator|+
literal|2
argument_list|,
name|pcix_cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|msk_bustype
operator|==
name|MSK_PEX_BUS
condition|)
block|{
name|uint16_t
name|v
decl_stmt|,
name|width
decl_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PEX_DEV_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Change Max. Read Request Size to 4096 bytes. */
name|v
operator|&=
operator|~
name|PEX_DC_MAX_RRS_MSK
expr_stmt|;
name|v
operator||=
name|PEX_DC_MAX_RD_RQ_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PEX_DEV_CTRL
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|width
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PEX_LNK_STAT
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|width
operator|&
name|PEX_LS_LINK_WI_MSK
operator|)
operator|>>
literal|4
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PEX_LNK_CAP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|&
name|PEX_LS_LINK_WI_MSK
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|width
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"negotiated width of link(x%d) != "
literal|"max. width of link(x%d)\n"
argument_list|,
name|width
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* Clear status list. */
name|bzero
argument_list|(
name|sc
operator|->
name|msk_stat_ring
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msk_stat_desc
argument_list|)
operator|*
name|MSK_STAT_RING_CNT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_stat_cons
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_RST_CLR
argument_list|)
expr_stmt|;
comment|/* Set the status list base address. */
name|addr
operator|=
name|sc
operator|->
name|msk_stat_ring_paddr
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_LIST_ADDR_LO
argument_list|,
name|MSK_ADDR_LO
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_LIST_ADDR_HI
argument_list|,
name|MSK_ADDR_HI
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the status list last index. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STAT_LAST_IDX
argument_list|,
name|MSK_STAT_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|HW_FEATURE
argument_list|(
name|sc
argument_list|,
name|HWF_WA_DEV_43_418
argument_list|)
condition|)
block|{
comment|/* WA for dev. #4.3 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STAT_TX_IDX_TH
argument_list|,
name|ST_TXTH_IDX_MASK
argument_list|)
expr_stmt|;
comment|/* WA for dev. #4.18 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_WM
argument_list|,
literal|0x21
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_ISR_WM
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STAT_TX_IDX_TH
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_WM
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_FIFO_ISR_WM
argument_list|,
name|HW_FEATURE
argument_list|(
name|sc
argument_list|,
name|HWF_WA_DEV_4109
argument_list|)
condition|?
literal|0x10
else|:
literal|0x04
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_ISR_TIMER_INI
argument_list|,
literal|0x0190
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Use default value for STAT_ISR_TIMER_INI, STAT_LEV_TIMER_INI. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_TX_TIMER_INI
argument_list|,
name|MSK_USECS
argument_list|(
name|sc
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable status unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_OP_ON
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_TX_TIMER_CTRL
argument_list|,
name|TIM_START
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_LEV_TIMER_CTRL
argument_list|,
name|TIM_START
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STAT_ISR_TIMER_CTRL
argument_list|,
name|TIM_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|char
name|desc
index|[
literal|100
index|]
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Not much to do here. We always know there will be 	 * at least one GMAC present, and if there are two, 	 * mskc_attach() will create a second device instance 	 * for us. 	 */
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
literal|"Marvell Technology Group Ltd. %s Id 0x%02x Rev 0x%02x"
argument_list|,
name|model_name
index|[
name|sc
operator|->
name|msk_hw_id
operator|-
name|CHIP_ID_YUKON_XL
index|]
argument_list|,
name|sc
operator|->
name|msk_hw_id
argument_list|,
name|sc
operator|->
name|msk_hw_rev
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|error
decl_stmt|;
name|uint8_t
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|port
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_if_dev
operator|=
name|dev
expr_stmt|;
name|sc_if
operator|->
name|msk_port
operator|=
name|port
expr_stmt|;
name|sc_if
operator|->
name|msk_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|msk_if
index|[
name|port
index|]
operator|=
name|sc_if
expr_stmt|;
comment|/* Setup Tx/Rx queue register offsets. */
if|if
condition|(
name|port
operator|==
name|MSK_PORT_A
condition|)
block|{
name|sc_if
operator|->
name|msk_txq
operator|=
name|Q_XA1
expr_stmt|;
name|sc_if
operator|->
name|msk_txsq
operator|=
name|Q_XS1
expr_stmt|;
name|sc_if
operator|->
name|msk_rxq
operator|=
name|Q_R1
expr_stmt|;
block|}
else|else
block|{
name|sc_if
operator|->
name|msk_txq
operator|=
name|Q_XA2
expr_stmt|;
name|sc_if
operator|->
name|msk_txsq
operator|=
name|Q_XS2
expr_stmt|;
name|sc_if
operator|->
name|msk_rxq
operator|=
name|Q_R2
expr_stmt|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_softc
operator|->
name|msk_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_link_task
argument_list|,
literal|0
argument_list|,
name|msk_link_task
argument_list|,
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|msk_txrx_dma_alloc
argument_list|(
name|sc_if
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|fail
goto|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc_if
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
comment|/* 	 * IFCAP_RXCSUM capability is intentionally disabled as the hardware 	 * has serious bug in Rx checksum offload for all Yukon II family 	 * hardware. It seems there is a workaround to make it work somtimes. 	 * However, the workaround also have to check OP code sequences to 	 * verify whether the OP code is correct. Sometimes it should compute 	 * IP/TCP/UDP checksum in driver in order to verify correctness of 	 * checksum computed by hardware. If you have to compute checksum 	 * with software to verify the hardware's checksum why have hardware 	 * compute the checksum? I think there is no reason to spend time to 	 * make Rx checksum offload work on Yukon II hardware. 	 */
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|MSK_CSUM_FEATURES
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|!=
name|CHIP_ID_YUKON_EC_U
condition|)
block|{
comment|/* It seems Yukon EC Ultra doesn't support TSO. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|msk_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|msk_start
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|msk_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|MSK_TX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|MSK_TX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tx_task
argument_list|,
literal|1
argument_list|,
name|msk_tx_task
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Get station address for this interface. Note that 	 * dual port cards actually come with three station 	 * addresses: one for each port, plus an extra. The 	 * extra one is used by the SysKonnect driver software 	 * as a 'virtual' station address for when both ports 	 * are operating in failover mode. Currently we don't 	 * use this extra address. 	 */
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|eaddr
index|[
name|i
index|]
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_MAC_1
operator|+
operator|(
name|port
operator|*
literal|8
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Call MI attach routine.  Can't hold locks when calling into ether_*. 	 */
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* VLAN capability setup */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_HWCSUM
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 * Must appear after the call to ether_ifattach() because 	 * ether_ifattach() sets ifi_hdrlen to the default value. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
comment|/* 	 * Do miibus setup. 	 */
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_miibus
argument_list|,
name|msk_mediachange
argument_list|,
name|msk_mediastatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"no PHY found!\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Check whether PHY Id is MARVELL. */
if|if
condition|(
name|msk_phy_readreg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_ID0
argument_list|)
operator|==
name|PHY_MARV_ID0_VAL
condition|)
name|sc
operator|->
name|msk_marvell_phy
operator|=
literal|1
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Access should be ok even though lock has been dropped */
name|sc
operator|->
name|msk_if
index|[
name|port
index|]
operator|=
name|NULL
expr_stmt|;
name|msk_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface. Allocate softc structures, do ifmedia  * setup and ethernet/BPF attach.  */
end_comment

begin_function
specifier|static
name|int
name|mskc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|msic
decl_stmt|,
modifier|*
name|port
decl_stmt|,
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate I/O resource */
ifdef|#
directive|ifdef
name|MSK_USEIOSPACE
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_io
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_mem
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|msk_irq_spec
operator|=
name|msk_irq_spec_legacy
expr_stmt|;
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_res_spec
argument_list|,
name|sc
operator|->
name|msk_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_res_spec
operator|==
name|msk_res_spec_mem
condition|)
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_io
expr_stmt|;
else|else
name|sc
operator|->
name|msk_res_spec
operator|=
name|msk_res_spec_mem
expr_stmt|;
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_res_spec
argument_list|,
name|sc
operator|->
name|msk_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't allocate %s resources\n"
argument_list|,
name|sc
operator|->
name|msk_res_spec
operator|==
name|msk_res_spec_mem
condition|?
literal|"memory"
else|:
literal|"I/O"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_CLR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_hw_id
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_CHIP_ID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_hw_rev
operator|=
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_MAC_CFG
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
comment|/* Bail out if chip is not recognized. */
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|<
name|CHIP_ID_YUKON_XL
operator|||
name|sc
operator|->
name|msk_hw_id
operator|>
name|CHIP_ID_YUKON_FE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown device: id=0x%02x, rev=0x%02x\n"
argument_list|,
name|sc
operator|->
name|msk_hw_id
argument_list|,
name|sc
operator|->
name|msk_hw_rev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"process_limit"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|msk_process_limit
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_msk_proc_limit
argument_list|,
literal|"I"
argument_list|,
literal|"max number of Rx events to process"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_process_limit
operator|=
name|MSK_PROC_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"process_limit"
argument_list|,
operator|&
name|sc
operator|->
name|msk_process_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_process_limit
operator|<
name|MSK_PROC_MIN
operator|||
name|sc
operator|->
name|msk_process_limit
operator|>
name|MSK_PROC_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"process_limit value out of range; "
literal|"using default: %d\n"
argument_list|,
name|MSK_PROC_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_process_limit
operator|=
name|MSK_PROC_DEFAULT
expr_stmt|;
block|}
block|}
comment|/* Soft reset. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_CLR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_pmd
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_PMD_TYP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_pmd
operator|==
literal|'L'
operator|||
name|sc
operator|->
name|msk_pmd
operator|==
literal|'S'
condition|)
name|sc
operator|->
name|msk_coppertype
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|msk_coppertype
operator|=
literal|1
expr_stmt|;
comment|/* Check number of MACs. */
name|sc
operator|->
name|msk_num_port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_HW_RES
argument_list|)
operator|&
name|CFG_DUAL_MAC_MSK
operator|)
operator|==
name|CFG_DUAL_MAC_MSK
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|B2_Y2_CLK_GATE
argument_list|)
operator|&
name|Y2_STATUS_LNK2_INAC
operator|)
condition|)
name|sc
operator|->
name|msk_num_port
operator|++
expr_stmt|;
block|}
comment|/* Check bus type. */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|msk_bustype
operator|=
name|MSK_PEX_BUS
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIY_PCIX
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|msk_bustype
operator|=
name|MSK_PCIX_BUS
expr_stmt|;
else|else
name|sc
operator|->
name|msk_bustype
operator|=
name|MSK_PCI_BUS
expr_stmt|;
comment|/* Get H/W features(bugs). */
switch|switch
condition|(
name|sc
operator|->
name|msk_hw_id
condition|)
block|{
case|case
name|CHIP_ID_YUKON_EC
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 Mhz */
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EC_A1
condition|)
block|{
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_42
operator||
name|HWF_WA_DEV_46
operator||
name|HWF_WA_DEV_43_418
operator||
name|HWF_WA_DEV_420
operator||
name|HWF_WA_DEV_423
operator||
name|HWF_WA_DEV_424
operator||
name|HWF_WA_DEV_425
operator||
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_428
operator||
name|HWF_WA_DEV_483
operator||
name|HWF_WA_DEV_4109
operator||
name|HWF_WA_DEV_4152
operator||
name|HWF_WA_DEV_4167
expr_stmt|;
block|}
else|else
block|{
comment|/* A2/A3 */
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_424
operator||
name|HWF_WA_DEV_425
operator||
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_428
operator||
name|HWF_WA_DEV_483
operator||
name|HWF_WA_DEV_4109
operator||
name|HWF_WA_DEV_4152
operator||
name|HWF_WA_DEV_4167
expr_stmt|;
block|}
break|break;
case|case
name|CHIP_ID_YUKON_EC_U
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|125
expr_stmt|;
comment|/* 125 Mhz */
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EC_U_A0
condition|)
block|{
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_483
operator||
name|HWF_WA_DEV_4109
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EC_A1
condition|)
block|{
name|uint16_t
name|v
decl_stmt|;
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_4109
operator||
name|HWF_WA_DEV_4185
expr_stmt|;
name|v
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|Q_XA1
argument_list|,
name|Q_WM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|sc
operator|->
name|msk_hw_feature
operator||=
name|HWF_WA_DEV_4185CS
operator||
name|HWF_WA_DEV_4200
expr_stmt|;
block|}
break|break;
case|case
name|CHIP_ID_YUKON_FE
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|100
expr_stmt|;
comment|/* 100 Mhz */
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_4109
operator||
name|HWF_WA_DEV_4152
operator||
name|HWF_WA_DEV_4167
expr_stmt|;
break|break;
case|case
name|CHIP_ID_YUKON_XL
case|:
name|sc
operator|->
name|msk_clock
operator|=
literal|156
expr_stmt|;
comment|/* 156 Mhz */
switch|switch
condition|(
name|sc
operator|->
name|msk_hw_rev
condition|)
block|{
case|case
name|CHIP_REV_YU_XL_A0
case|:
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_463
operator||
name|HWF_WA_DEV_472
operator||
name|HWF_WA_DEV_479
operator||
name|HWF_WA_DEV_483
operator||
name|HWF_WA_DEV_4115
operator||
name|HWF_WA_DEV_4152
operator||
name|HWF_WA_DEV_4167
expr_stmt|;
break|break;
case|case
name|CHIP_REV_YU_XL_A1
case|:
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_483
operator||
name|HWF_WA_DEV_4109
operator||
name|HWF_WA_DEV_4115
operator||
name|HWF_WA_DEV_4152
operator||
name|HWF_WA_DEV_4167
expr_stmt|;
break|break;
case|case
name|CHIP_REV_YU_XL_A2
case|:
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_483
operator||
name|HWF_WA_DEV_4109
operator||
name|HWF_WA_DEV_4115
operator||
name|HWF_WA_DEV_4167
expr_stmt|;
break|break;
case|case
name|CHIP_REV_YU_XL_A3
case|:
name|sc
operator|->
name|msk_hw_feature
operator|=
name|HWF_WA_DEV_427
operator||
name|HWF_WA_DEV_483
operator||
name|HWF_WA_DEV_4109
operator||
name|HWF_WA_DEV_4115
expr_stmt|;
block|}
break|break;
default|default:
name|sc
operator|->
name|msk_clock
operator|=
literal|156
expr_stmt|;
comment|/* 156 Mhz */
name|sc
operator|->
name|msk_hw_feature
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate IRQ resources. */
name|msic
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MSI count : %d\n"
argument_list|,
name|msic
argument_list|)
expr_stmt|;
comment|/* 	 * The Yukon II reports it can handle two messages, one for each 	 * possible port.  We go ahead and allocate two messages and only 	 * setup a handler for both if we have a dual port card. 	 * 	 * XXX: I haven't untangled the interrupt handler to handle dual 	 * port cards with separate MSI messages, so for now I disable MSI 	 * on dual port cards. 	 */
if|if
condition|(
name|msic
operator|==
literal|2
operator|&&
name|msi_disable
operator|==
literal|0
operator|&&
name|sc
operator|->
name|msk_num_port
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msic
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msic
operator|==
literal|2
condition|)
block|{
name|sc
operator|->
name|msk_msi
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|msk_irq_spec
operator|=
name|msk_irq_spec_msi
expr_stmt|;
block|}
else|else
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq_spec
argument_list|,
name|sc
operator|->
name|msk_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't allocate IRQ resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|msk_status_dma_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Set base interrupt mask. */
name|sc
operator|->
name|msk_intrmask
operator|=
name|Y2_IS_HW_ERR
operator||
name|Y2_IS_STAT_BMU
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|=
name|Y2_IS_TIST_OV
operator||
name|Y2_IS_MST_ERR
operator||
name|Y2_IS_IRQ_STAT
operator||
name|Y2_IS_PCI_EXP
operator||
name|Y2_IS_PCI_NEXP
expr_stmt|;
comment|/* Reset the adapter. */
name|mskc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mskc_setup_rambuffer
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"msk"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add child for PORT_A\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|port
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate memory for "
literal|"ivars of PORT_A\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
operator|*
name|port
operator|=
name|MSK_PORT_A
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_num_port
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"msk"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add child for PORT_B\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|port
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate memory for "
literal|"ivars of PORT_B\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
operator|*
name|port
operator|=
name|MSK_PORT_B
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach port(s)\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|msk_int_task
argument_list|,
literal|0
argument_list|,
name|msk_int_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"msk_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|msk_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|msk_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Hook interrupt last to avoid having to lock softc. */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq
index|[
literal|0
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|msk_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|msk_intrhand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't set up interrupt handler\n"
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|msk_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_tq
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|mskc_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown hardware and free up resources. This can be called any  * time after the mutex has been initialized. It is called in both  * the error case in attach and the normal detach case so it needs  * to be careful about only freeing resources that have actually been  * allocated.  */
end_comment

begin_function
specifier|static
name|int
name|msk_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc_if
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_softc
operator|->
name|msk_mtx
argument_list|)
argument_list|,
operator|(
literal|"msk mutex not initialized in msk_detach"
operator|)
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* XXX */
name|sc_if
operator|->
name|msk_detach
operator|=
literal|1
expr_stmt|;
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Can't hold locks while calling detach. */
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_tx_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_link_task
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're generally called from mskc_detach() which is using 	 * device_delete_child() to get to here. It's already trashed 	 * miibus for us, so don't do it here or we'll panic. 	 * 	 * if (sc_if->msk_miibus != NULL) { 	 * 	device_delete_child(dev, sc_if->msk_miibus); 	 * 	sc_if->msk_miibus = NULL; 	 * } 	 */
name|msk_txrx_dma_free
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|sc
operator|->
name|msk_if
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|=
name|NULL
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
argument_list|,
operator|(
literal|"msk mutex not initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_alive
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_A
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_devs
index|[
name|MSK_PORT_B
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
comment|/* LED Off. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|Y2_LED_STAT_OFF
argument_list|)
expr_stmt|;
comment|/* Put hardware reset. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|msk_status_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|msk_tq
argument_list|,
operator|&
name|sc
operator|->
name|msk_int_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|msk_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_tq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_intrhand
index|[
literal|0
index|]
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|msk_intrhand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_intrhand
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msk_intrhand
index|[
literal|1
index|]
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|msk_intrhand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_intrhand
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_irq_spec
argument_list|,
name|sc
operator|->
name|msk_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_msi
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|msk_res_spec
argument_list|,
name|sc
operator|->
name|msk_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|msk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|msk_dmamap_arg
block|{
name|bus_addr_t
name|msk_busaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|msk_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|msk_dmamap_arg
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|ctx
operator|=
name|arg
expr_stmt|;
name|ctx
operator|->
name|msk_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create status DMA region. */
end_comment

begin_function
specifier|static
name|int
name|msk_status_dma_alloc
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|msk_dmamap_arg
name|ctx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|)
argument_list|,
comment|/* parent */
name|MSK_STAT_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_STAT_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_STAT_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|msk_stat_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"failed to create status DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Allocate DMA'able memory and load the DMA map for status ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|msk_stat_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|msk_stat_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"failed to allocate DMA'able memory for status ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|,
name|sc
operator|->
name|msk_stat_ring
argument_list|,
name|MSK_STAT_RING_SZ
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"failed to load DMA'able memory for status ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|msk_stat_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_status_dma_free
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Destroy status block. */
if|if
condition|(
name|sc
operator|->
name|msk_stat_tag
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_stat_map
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_stat_ring
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_ring
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_stat_ring
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|msk_stat_map
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_stat_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|msk_txrx_dma_alloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_dmamap_arg
name|ctx
decl_stmt|;
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|struct
name|msk_jpool_entry
modifier|*
name|entry
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jlist_mtx
argument_list|,
literal|"msk_jlist_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jinuse_listhead
argument_list|)
expr_stmt|;
comment|/* Create parent DMA tag. */
comment|/* 	 * XXX 	 * It seems that Yukon II supports full 64bits DMA operations. But 	 * it needs two descriptors(list elements) for 64bits DMA operations. 	 * Since we don't know what DMA address mappings(32bits or 64bits) 	 * would be used in advance for each mbufs, we limits its DMA space 	 * to be in range of 32bits address space. Otherwise, we should check 	 * what DMA address is used and chain another descriptor for the 	 * 64bits DMA operation. This also means descriptor ring size is 	 * variable. Limiting DMA address to be in 32bit address space greatly 	 * simplyfies descriptor handling and possibly would increase 	 * performance a bit due to efficient handling of descriptors. 	 * Apart from harassing checksum offloading mechanisms, it seems 	 * it's really bad idea to use a seperate descriptor for 64bit 	 * DMA operation to save small descriptor memory. Anyway, I've 	 * never seen these exotic scheme on ethernet interface hardware. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create parent DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Tx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|MSK_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_TX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_TX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Tx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Rx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|MSK_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_RX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_RX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Rx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for jumbo Rx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|MSK_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_JUMBO_RX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_JUMBO_RX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create jumbo Rx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for jumbo buffer blocks. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSK_JMEM
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSK_JMEM
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create jumbo Rx buffer block DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Tx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
operator|*
name|MSK_MAXTXSEGS
argument_list|,
comment|/* maxsize */
name|MSK_MAXTXSEGS
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Tx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Rx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Rx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for jumbo Rx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
operator|*
name|MSK_MAXRXSEGS
argument_list|,
comment|/* maxsize */
name|MSK_MAXRXSEGS
argument_list|,
comment|/* nsegments */
name|MSK_JLEN
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create jumbo Rx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate DMA'able memory and load the DMA map for Tx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to allocate DMA'able memory for Tx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
argument_list|,
name|MSK_TX_RING_SZ
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to load DMA'able memory for Tx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
comment|/* Allocate DMA'able memory and load the DMA map for Rx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to allocate DMA'able memory for Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
argument_list|,
name|MSK_RX_RING_SZ
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to load DMA'able memory for Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
comment|/* Allocate DMA'able memory and load the DMA map for jumbo Rx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to allocate DMA'able memory for jumbo Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
argument_list|,
name|MSK_JUMBO_RX_RING_SZ
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to load DMA'able memory for jumbo Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
comment|/* Create DMA maps for Tx buffers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Tx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Create DMA maps for Rx buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create spare Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Create DMA maps for jumbo Rx buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create spare jumbo Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|jrxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|jrxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|jrxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to create jumbo Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Allocate DMA'able memory and load the DMA map for jumbo buf. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to allocate DMA'able memory for jumbo buf\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|msk_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_map
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf
argument_list|,
name|MSK_JMEM
argument_list|,
name|msk_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"failed to load DMA'able memory for jumbobuf\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf_paddr
operator|=
name|ctx
operator|.
name|msk_busaddr
expr_stmt|;
comment|/* 	 * Now divide it up into 9K pieces and save the addresses 	 * in an array. 	 */
name|ptr
operator|=
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JSLOTS
condition|;
name|i
operator|++
control|)
block|{
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jslots
index|[
name|i
index|]
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|MSK_JLEN
expr_stmt|;
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msk_jpool_entry
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"no memory for jumbo buffers!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|entry
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|,
name|entry
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
block|}
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_txrx_dma_free
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|struct
name|msk_jpool_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MSK_JLIST_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jinuse_listhead
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"asked to free buffer that is in use!\n"
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jinuse_listhead
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|,
name|entry
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|)
condition|)
block|{
name|entry
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|MSK_JLIST_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Destroy jumbo buffer block. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_tag
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_map
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf
operator|=
name|NULL
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_map
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Tx ring. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
operator|&&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
operator|=
name|NULL
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx ring. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
operator|&&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Jumbo Rx ring. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
operator|&&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Tx buffers. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx buffers. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_sparemap
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Jumbo Rx buffers. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|jrxd
operator|->
name|rx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|jrxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|jrxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_sparemap
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_parent_tag
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jlist_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a jumbo buffer.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|msk_jalloc
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_jpool_entry
modifier|*
name|entry
decl_stmt|;
name|MSK_JLIST_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|entry
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|MSK_JLIST_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jinuse_listhead
argument_list|,
name|entry
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
name|MSK_JLIST_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jslots
index|[
name|entry
operator|->
name|slot
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a jumbo buffer.  */
end_comment

begin_function
specifier|static
name|void
name|msk_jfree
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|msk_jpool_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Extract the softc struct pointer. */
name|sc_if
operator|=
operator|(
expr|struct
name|msk_if_softc
operator|*
operator|)
name|args
expr_stmt|;
name|KASSERT
argument_list|(
name|sc_if
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: can't find softc pointer!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|MSK_JLIST_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Calculate the slot this buffer belongs to. */
name|i
operator|=
operator|(
operator|(
name|vm_offset_t
operator|)
name|buf
operator|-
operator|(
name|vm_offset_t
operator|)
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_buf
operator|)
operator|/
name|MSK_JLEN
expr_stmt|;
name|KASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|MSK_JSLOTS
argument_list|,
operator|(
literal|"%s: asked to free buffer that we don't manage!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jinuse_listhead
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: buffer not in use!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jinuse_listhead
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jfree_listhead
argument_list|,
name|entry
argument_list|,
name|jpool_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_jinuse_listhead
argument_list|)
condition|)
name|wakeup
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|MSK_JLIST_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * It's copy of ath_defrag(ath(4)).  *  * Defragment an mbuf chain, returning at most maxfrags separate  * mbufs+clusters.  If this is not possible NULL is returned and  * the original mbuf chain is left in it's present (potentially  * modified) state.  We use two techniques: collapsing consecutive  * mbufs and replacing consecutive mbufs by a cluster.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|msk_defrag
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|how
parameter_list|,
name|int
name|maxfrags
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|n2
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|u_int
name|curfrags
decl_stmt|;
comment|/* 	 * Calculate the current number of frags. 	 */
name|curfrags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|curfrags
operator|++
expr_stmt|;
comment|/* 	 * First, try to collapse mbufs.  Note that we always collapse 	 * towards the front so we don't need to deal with moving the 	 * pkthdr.  This may be suboptimal if the first mbuf has much 	 * less data than the following. 	 */
name|m
operator|=
name|m0
expr_stmt|;
name|again
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_RDONLY
operator|)
operator|==
literal|0
operator|&&
name|n
operator|->
name|m_len
operator|<
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|curfrags
operator|<=
name|maxfrags
condition|)
return|return
operator|(
name|m0
operator|)
return|;
block|}
else|else
name|m
operator|=
name|n
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|maxfrags
operator|>
literal|1
argument_list|,
operator|(
literal|"maxfrags %u, but normal collapse failed"
operator|,
name|maxfrags
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Collapse consecutive mbufs to a cluster. 	 */
name|prev
operator|=
operator|&
name|m0
operator|->
name|m_next
expr_stmt|;
comment|/* NB: not the first mbuf */
while|while
condition|(
operator|(
name|n
operator|=
operator|*
name|prev
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|n2
operator|=
name|n
operator|->
name|m_next
operator|)
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|m_len
operator|+
name|n2
operator|->
name|m_len
operator|<
name|MCLBYTES
condition|)
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|how
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n2
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|n
operator|->
name|m_len
argument_list|,
name|n2
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|n
operator|->
name|m_len
operator|+
name|n2
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n2
operator|->
name|m_next
expr_stmt|;
operator|*
name|prev
operator|=
name|m
expr_stmt|;
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|curfrags
operator|<=
name|maxfrags
condition|)
comment|/* +1 cl -2 mbufs */
return|return
name|m0
return|;
comment|/* 			 * Still not there, try the normal collapse 			 * again before we allocate another cluster. 			 */
goto|goto
name|again
goto|;
block|}
name|prev
operator|=
operator|&
name|n
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	 * No place where we can collapse to a cluster; punt. 	 * This can occur if, for example, you request 2 frags 	 * but the packet requires that both be clusters (we 	 * never reallocate the first mbuf to avoid moving the 	 * packet header). 	 */
name|bad
label|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_encap
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|,
modifier|*
name|txd_last
decl_stmt|;
name|struct
name|msk_tx_desc
modifier|*
name|tx_le
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_segment_t
name|txsegs
index|[
name|MSK_MAXTXSEGS
index|]
decl_stmt|;
name|uint32_t
name|control
decl_stmt|,
name|prod
decl_stmt|,
name|si
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|,
name|tcp_offset
decl_stmt|,
name|tso_mtu
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nseg
decl_stmt|,
name|tso
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|tcp_offset
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|MSK_CSUM_FEATURES
operator||
name|CSUM_TSO
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Since mbuf has no protocol specific structure information 		 * in it we have to inspect protocol information here to 		 * setup TSO and checksum offload. I don't know why Marvell 		 * made a such decision in chip design because other GigE 		 * hardwares normally takes care of all these chores in 		 * hardware. However, TSO performance of Yukon II is very 		 * good such that it's worth to implement it. 		 */
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
comment|/* TODO check for M_WRITABLE(m) */
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Check if hardware VLAN insertion is off. */
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|offset
operator|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|tcp_offset
operator|=
name|offset
expr_stmt|;
comment|/* 		 * It seems that Yukon II has Tx checksum offload bug for 		 * small TCP packets that's less than 60 bytes in size 		 * (e.g. TCP window probe packet, pure ACK packet). 		 * Common work around like padding with zeros to make the 		 * frame minimum ethernet frame size didn't work at all. 		 * Instead of disabling checksum offload completely we 		 * resort to S/W checksum routine when we encounter short 		 * TCP frames. 		 * Short UDP packets appear to be handled correctly by 		 * Yukon II. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MSK_MIN_FRAMELEN
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint16_t
name|csum
decl_stmt|;
name|csum
operator|=
name|in_cksum_skip
argument_list|(
name|m
argument_list|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|+
name|offset
operator|-
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|)
operator|=
name|csum
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_TCP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|tcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcphdr
operator|*
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
name|prod
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
expr_stmt|;
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|prod
index|]
expr_stmt|;
name|txd_last
operator|=
name|txd
expr_stmt|;
name|map
operator|=
name|txd
operator|->
name|tx_dmamap
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|m
operator|=
name|msk_defrag
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MSK_MAXTXSEGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Check number of available descriptors. */
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|+
name|nseg
operator|>=
operator|(
name|MSK_TX_RING_CNT
operator|-
name|MSK_RESERVED_TX_DESC_CNT
operator|)
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|control
operator|=
literal|0
expr_stmt|;
name|tso
operator|=
literal|0
expr_stmt|;
name|tx_le
operator|=
name|NULL
expr_stmt|;
comment|/* Check TSO support. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|tso_mtu
operator|=
name|offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
if|if
condition|(
name|tso_mtu
operator|!=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tso_mtu
condition|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|tso_mtu
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_LRGLEN
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tso_mtu
operator|=
name|tso_mtu
expr_stmt|;
block|}
name|tso
operator|++
expr_stmt|;
block|}
comment|/* Check if we have a VLAN tag to insert. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tso
operator|==
literal|0
condition|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|OP_VLAN
operator||
name|HW_OWNER
operator||
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx_le
operator|->
name|msk_control
operator||=
name|htole32
argument_list|(
name|OP_VLAN
operator||
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|control
operator||=
name|INS_VLAN
expr_stmt|;
block|}
comment|/* Check if we have to handle checksum offload. */
if|if
condition|(
name|tso
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|MSK_CSUM_FEATURES
operator|)
operator|!=
literal|0
condition|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
operator|(
operator|(
name|tcp_offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|tcp_offset
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
literal|1
operator|<<
literal|16
operator||
operator|(
name|OP_TCPLISW
operator||
name|HW_OWNER
operator|)
argument_list|)
expr_stmt|;
name|control
operator|=
name|CALSUM
operator||
name|WR_SUM
operator||
name|INIT_SUM
operator||
name|LOCK_SUM
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
operator|)
operator|!=
literal|0
condition|)
name|control
operator||=
name|UDPTCP
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|si
operator|=
name|prod
expr_stmt|;
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tso
operator|==
literal|0
condition|)
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|control
operator||
name|OP_PACKET
argument_list|)
expr_stmt|;
else|else
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_len
operator||
name|control
operator||
name|OP_LARGESEND
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_addr
operator|=
name|htole32
argument_list|(
name|MSK_ADDR_LO
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_len
operator||
name|control
operator||
name|OP_BUFFER
operator||
name|HW_OWNER
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|++
expr_stmt|;
name|MSK_INC
argument_list|(
name|prod
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
comment|/* Update producer index. */
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
operator|=
name|prod
expr_stmt|;
comment|/* Set EOP on the last desciptor. */
name|prod
operator|=
operator|(
name|prod
operator|+
name|MSK_TX_RING_CNT
operator|-
literal|1
operator|)
operator|%
name|MSK_TX_RING_CNT
expr_stmt|;
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator||=
name|htole32
argument_list|(
name|EOP
argument_list|)
expr_stmt|;
comment|/* Turn the first descriptor ownership to hardware. */
name|tx_le
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|si
index|]
expr_stmt|;
name|tx_le
operator|->
name|msk_control
operator||=
name|htole32
argument_list|(
name|HW_OWNER
argument_list|)
expr_stmt|;
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|prod
index|]
expr_stmt|;
name|map
operator|=
name|txd_last
operator|->
name|tx_dmamap
expr_stmt|;
name|txd_last
operator|->
name|tx_dmamap
operator|=
name|txd
operator|->
name|tx_dmamap
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|map
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|m
expr_stmt|;
comment|/* Sync descriptors. */
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_tx_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|arg
expr_stmt|;
name|msk_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|enq
decl_stmt|;
name|sc_if
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
name|sc_if
operator|->
name|msk_link
operator|==
literal|0
condition|)
block|{
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|enq
operator|=
literal|0
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|&&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|<
operator|(
name|MSK_TX_RING_CNT
operator|-
name|MSK_RESERVED_TX_DESC_CNT
operator|)
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, set the OACTIVE flag and wait 		 * for the NIC to drain the ring. 		 */
if|if
condition|(
name|msk_encap
argument_list|(
name|sc_if
argument_list|,
operator|&
name|m_head
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
comment|/* 		 * If there's a BPF listener, bounce a copy of this frame 		 * to him. 		 */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
comment|/* Transmit */
name|CSR_WRITE_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_prod
argument_list|)
expr_stmt|;
comment|/* Set a timeout in case the chip goes out to lunch. */
name|sc_if
operator|->
name|msk_watchdog_timer
operator|=
name|MSK_TX_TIMEOUT
expr_stmt|;
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_watchdog
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|ridx
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc_if
operator|->
name|msk_watchdog_timer
condition|)
return|return;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_link
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|sc_if
operator|->
name|msk_ifp
argument_list|,
literal|"watchdog timeout "
literal|"(missed link)\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Reclaim first as there is a possibility of losing Tx completion 	 * interrupts. 	 */
name|ridx
operator|=
name|sc_if
operator|->
name|msk_port
operator|==
name|MSK_PORT_A
condition|?
name|STAT_TXA1_RIDX
else|:
name|STAT_TXA2_RIDX
expr_stmt|;
name|idx
operator|=
name|CSR_READ_2
argument_list|(
name|sc_if
operator|->
name|msk_softc
argument_list|,
name|ridx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cons
operator|!=
name|idx
condition|)
block|{
name|msk_txeof
argument_list|(
name|sc_if
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"watchdog timeout (missed Tx interrupts) "
literal|"-- recovering\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_tx_task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|sc_if
operator|->
name|msk_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mskc_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|msk_stop
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
comment|/* Put hardware reset. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|)
condition|)
name|msk_stop
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|msk_phy_power
argument_list|(
name|sc
argument_list|,
name|MSK_PHY_POWERDOWN
argument_list|)
expr_stmt|;
comment|/* Put hardware reset. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|B0_CTST
argument_list|,
name|CS_RST_SET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_suspended
operator|=
literal|1
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mskc_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mskc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msk_num_port
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
operator|->
name|msk_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|)
condition|)
name|msk_init_locked
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|msk_suspended
operator|=
literal|0
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|rxlen
decl_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|cons
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
expr_stmt|;
do|do
block|{
name|rxlen
operator|=
name|status
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
name|rxlen
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|sc_if
operator|->
name|msk_framesize
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_ANY_ERR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_RX_OK
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|rxlen
operator|!=
name|len
operator|)
condition|)
block|{
comment|/* Don't count flow-control packet as errors. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_GOOD_FC
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|msk_discard_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|cons
index|]
expr_stmt|;
name|m
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
if|if
condition|(
name|msk_newbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
comment|/* Reuse old buffer. */
name|msk_discard_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Check for VLAN tagged packets. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|sc_if
operator|->
name|msk_vtag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|,
name|MSK_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_jumbo_rxeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|rxlen
decl_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|cons
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
expr_stmt|;
do|do
block|{
name|rxlen
operator|=
name|status
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
name|rxlen
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|sc_if
operator|->
name|msk_framesize
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_ANY_ERR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|GMR_FS_RX_OK
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|rxlen
operator|!=
name|len
operator|)
condition|)
block|{
comment|/* Don't count flow-control packet as errors. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_GOOD_FC
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|msk_discard_jumbo_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|cons
index|]
expr_stmt|;
name|m
operator|=
name|jrxd
operator|->
name|rx_m
expr_stmt|;
if|if
condition|(
name|msk_jumbo_newbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
comment|/* Reuse old buffer. */
name|msk_discard_jumbo_rxbuf
argument_list|(
name|sc_if
argument_list|,
name|cons
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Check for VLAN tagged packets. */
if|if
condition|(
operator|(
name|status
operator|&
name|GMR_FS_VLAN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|sc_if
operator|->
name|msk_vtag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_cons
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MSK_INC
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_txeof
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_tx_desc
modifier|*
name|cur_tx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|control
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|prog
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Go through our tx ring and free mbufs for those 	 * frames that have been sent. 	 */
name|cons
operator|=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cons
expr_stmt|;
name|prog
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|cons
operator|!=
name|idx
condition|;
name|MSK_INC
argument_list|(
name|cons
argument_list|,
name|MSK_TX_RING_CNT
argument_list|)
control|)
block|{
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|<=
literal|0
condition|)
break|break;
name|prog
operator|++
expr_stmt|;
name|cur_tx
operator|=
operator|&
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring
index|[
name|cons
index|]
expr_stmt|;
name|control
operator|=
name|le32toh
argument_list|(
name|cur_tx
operator|->
name|msk_control
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|--
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
name|EOP
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|cons
index|]
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: freeing NULL mbuf!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|prog
operator|>
literal|0
condition|)
block|{
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cons
operator|=
name|cons
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_cnt
operator|==
literal|0
condition|)
name|sc_if
operator|->
name|msk_watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* No need to sync LEs as we didn't update LEs. */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_tick
parameter_list|(
name|void
modifier|*
name|xsc_if
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc_if
operator|=
name|xsc_if
expr_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|msk_watchdog
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|,
name|hz
argument_list|,
name|msk_tick
argument_list|,
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_intr_phy
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|uint16_t
name|status
decl_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_softc
operator|->
name|msk_marvell_phy
condition|)
block|{
name|msk_phy_readreg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_STAT
argument_list|)
expr_stmt|;
name|status
operator|=
name|msk_phy_readreg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_STAT
argument_list|)
expr_stmt|;
comment|/* Handle FIFO Underrun/Overflow? */
if|if
condition|(
operator|(
name|status
operator|&
name|PHY_M_IS_FIFO_ERROR
operator|)
condition|)
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"PHY FIFO underrun/overflow.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_intr_gmac
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|status
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_SRC
argument_list|)
argument_list|)
expr_stmt|;
comment|/* GMAC Rx FIFO overrun. */
if|if
condition|(
operator|(
name|status
operator|&
name|GM_IS_RX_FF_OR
operator|)
operator|!=
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_CLI_RX_FO
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Rx FIFO overrun!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* GMAC Tx FIFO underrun. */
if|if
condition|(
operator|(
name|status
operator|&
name|GM_IS_TX_FF_UR
operator|)
operator|!=
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_CLI_TX_FU
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Tx FIFO underrun!\n"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX 		 * In case of Tx underrun, we may need to flush/reset 		 * Tx MAC but that would also require resynchronization 		 * with status LEs. Reintializing status LEs would 		 * affect other port in dual MAC configuration so it 		 * should be avoided as possible as we can. 		 * Due to lack of documentation it's all vague guess but 		 * it needs more investigation. 		 */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_handle_hwerr
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_RD1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"RAM buffer read parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_CLR_RD_PERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_WR1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"RAM buffer write parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|SELECT_RAM_BUFFER
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|B3_RI_CTRL
argument_list|)
argument_list|,
name|RI_CLR_WR_PERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_MAC1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Tx MAC parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_CLI_TX_PE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PAR_RX1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Rx parity error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_IRQ_PAR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_TCP_TXS1
operator||
name|Y2_IS_TCP_TXA1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"TCP segmentation error\n"
argument_list|)
expr_stmt|;
comment|/* Clear IRQ. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_IRQ_TCP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msk_intr_hwerr
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|tlphead
index|[
literal|4
index|]
decl_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_ISRC
argument_list|)
expr_stmt|;
comment|/* Time Stamp timer overflow. */
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_TIST_OV
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|GMAC_TI_ST_CTRL
argument_list|,
name|GMT_ST_CLR_IRQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PCI_NEXP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * PCI Express Error occured which is not described in PEX 		 * spec. 		 * This error is also mapped either to Master Abort( 		 * Y2_IS_MST_ERR) or Target Abort (Y2_IS_IRQ_STAT) bit and 		 * can only be cleared there.                  */
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"PCI Express protocol violation error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_MST_ERR
operator||
name|Y2_IS_IRQ_STAT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint16_t
name|v16
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_MST_ERR
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"unexpected IRQ Status error\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"unexpected IRQ Master error\n"
argument_list|)
expr_stmt|;
comment|/* Reset all bits in the PCI status register. */
name|v16
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|v16
operator||
name|PCIM_STATUS_PERR
operator||
name|PCIM_STATUS_SERR
operator||
name|PCIM_STATUS_RMABORT
operator||
name|PCIM_STATUS_RTABORT
operator||
name|PCIM_STATUS_PERRREPORT
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
block|}
comment|/* Check for PCI Express Uncorrectable Error. */
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_PCI_EXP
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|v32
decl_stmt|;
comment|/* 		 * On PCI Express bus bridges are called root complexes (RC). 		 * PCI Express errors are recognized by the root complex too, 		 * which requests the system to handle the problem. After 		 * error occurence it may be that no access to the adapter 		 * may be performed any longer. 		 */
name|v32
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v32
operator|&
name|PEX_UNSUP_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Ignore unsupported request error. */
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Uncorrectable PCI Express error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v32
operator|&
operator|(
name|PEX_FATAL_ERRORS
operator||
name|PEX_POIS_TLP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Get TLP header form Log Registers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tlphead
index|[
name|i
index|]
operator|=
name|CSR_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|PEX_HEADER_LOG
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Check for vendor defined broadcast message. */
if|if
condition|(
operator|!
operator|(
name|tlphead
index|[
literal|0
index|]
operator|==
literal|0x73004001
operator|&&
name|tlphead
index|[
literal|1
index|]
operator|==
literal|0x7f
operator|)
condition|)
block|{
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_IS_PCI_EXP
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrhwemask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear the interrupt. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_ON
argument_list|)
expr_stmt|;
name|CSR_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PEX_UNC_ERR_STAT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|B2_TST_CTRL1
argument_list|,
name|TST_CFG_WRITE_OFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_HWE_L1_MASK
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
operator|!=
name|NULL
condition|)
name|msk_handle_hwerr
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_HWE_L2_MASK
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
operator|!=
name|NULL
condition|)
name|msk_handle_hwerr
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
argument_list|,
name|status
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|msk_rxput
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
operator|(
name|MCLBYTES
operator|-
name|ETHER_HDR_LEN
operator|)
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
else|else
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_tag
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_PUT_IDX_REG
argument_list|)
argument_list|,
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_prod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_handle_events
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
decl_stmt|;
name|int
name|rxput
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|msk_stat_desc
modifier|*
name|sd
decl_stmt|;
name|uint32_t
name|control
decl_stmt|,
name|status
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|idx
decl_stmt|,
name|len
decl_stmt|,
name|port
decl_stmt|,
name|rxprog
decl_stmt|;
name|idx
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STAT_PUT_IDX
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|sc
operator|->
name|msk_stat_cons
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Sync status LEs. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|msk_stat_tag
argument_list|,
name|sc
operator|->
name|msk_stat_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* XXX Sync Rx LEs here. */
name|rxput
index|[
name|MSK_PORT_A
index|]
operator|=
name|rxput
index|[
name|MSK_PORT_B
index|]
operator|=
literal|0
expr_stmt|;
name|rxprog
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cons
operator|=
name|sc
operator|->
name|msk_stat_cons
init|;
name|cons
operator|!=
name|idx
condition|;
control|)
block|{
name|sd
operator|=
operator|&
name|sc
operator|->
name|msk_stat_ring
index|[
name|cons
index|]
expr_stmt|;
name|control
operator|=
name|le32toh
argument_list|(
name|sd
operator|->
name|msk_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
name|HW_OWNER
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Marvell's FreeBSD driver updates status LE after clearing 		 * HW_OWNER. However we don't have a way to sync single LE 		 * with bus_dma(9) API. bus_dma(9) provides a way to sync 		 * an entire DMA map. So don't sync LE until we have a better 		 * way to sync LEs. 		 */
name|control
operator|&=
operator|~
name|HW_OWNER
expr_stmt|;
name|sd
operator|->
name|msk_control
operator|=
name|htole32
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|sd
operator|->
name|msk_status
argument_list|)
expr_stmt|;
name|len
operator|=
name|control
operator|&
name|STLE_LEN_MASK
expr_stmt|;
name|port
operator|=
operator|(
name|control
operator|>>
literal|16
operator|)
operator|&
literal|0x01
expr_stmt|;
name|sc_if
operator|=
name|sc
operator|->
name|msk_if
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|sc_if
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"invalid port opcode "
literal|"0x%08x\n"
argument_list|,
name|control
operator|&
name|STLE_OP_MASK
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|control
operator|&
name|STLE_OP_MASK
condition|)
block|{
case|case
name|OP_RXVLAN
case|:
name|sc_if
operator|->
name|msk_vtag
operator|=
name|ntohs
argument_list|(
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RXCHKSVLAN
case|:
name|sc_if
operator|->
name|msk_vtag
operator|=
name|ntohs
argument_list|(
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RXSTAT
case|:
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
operator|(
name|MCLBYTES
operator|-
name|ETHER_HDR_LEN
operator|)
condition|)
name|msk_jumbo_rxeof
argument_list|(
name|sc_if
argument_list|,
name|status
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|msk_rxeof
argument_list|(
name|sc_if
argument_list|,
name|status
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rxprog
operator|++
expr_stmt|;
comment|/* 			 * Because there is no way to sync single Rx LE 			 * put the DMA sync operation off until the end of 			 * event processing. 			 */
name|rxput
index|[
name|port
index|]
operator|++
expr_stmt|;
comment|/* Update prefetch unit if we've passed water mark. */
if|if
condition|(
name|rxput
index|[
name|port
index|]
operator|>=
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_putwm
condition|)
block|{
name|msk_rxput
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|rxput
index|[
name|port
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|OP_TXINDEXLE
case|:
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
operator|!=
name|NULL
condition|)
name|msk_txeof
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
argument_list|,
name|status
operator|&
name|STLE_TXA1_MSKL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
operator|!=
name|NULL
condition|)
name|msk_txeof
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
argument_list|,
operator|(
operator|(
name|status
operator|&
name|STLE_TXA2_MSKL
operator|)
operator|>>
name|STLE_TXA2_SHIFTL
operator|)
operator||
operator|(
operator|(
name|len
operator|&
name|STLE_TXA2_MSKH
operator|)
operator|<<
name|STLE_TXA2_SHIFTH
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"unhandled opcode 0x%08x\n"
argument_list|,
name|control
operator|&
name|STLE_OP_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
name|MSK_INC
argument_list|(
name|cons
argument_list|,
name|MSK_STAT_RING_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxprog
operator|>
name|sc
operator|->
name|msk_process_limit
condition|)
break|break;
block|}
name|sc
operator|->
name|msk_stat_cons
operator|=
name|cons
expr_stmt|;
comment|/* XXX We should sync status LEs here. See above notes. */
if|if
condition|(
name|rxput
index|[
name|MSK_PORT_A
index|]
operator|>
literal|0
condition|)
name|msk_rxput
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxput
index|[
name|MSK_PORT_B
index|]
operator|>
literal|0
condition|)
name|msk_rxput
argument_list|(
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|msk_stat_cons
operator|!=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STAT_PUT_IDX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msk_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_Y2_SP_ISRC2
argument_list|)
expr_stmt|;
comment|/* Reading B0_Y2_SP_ISRC2 masks further interrupts. */
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xffffffff
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_Y2_SP_ICR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
block|}
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|msk_tq
argument_list|,
operator|&
name|sc
operator|->
name|msk_int_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_int_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_if_softc
modifier|*
name|sc_if0
decl_stmt|,
modifier|*
name|sc_if1
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp0
decl_stmt|,
modifier|*
name|ifp1
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|domore
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|MSK_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get interrupt source. */
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_ISRC
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xffffffff
operator|||
name|sc
operator|->
name|msk_suspended
operator|!=
literal|0
operator|||
operator|(
name|status
operator|&
name|sc
operator|->
name|msk_intrmask
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
name|sc_if0
operator|=
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_A
index|]
expr_stmt|;
name|sc_if1
operator|=
name|sc
operator|->
name|msk_if
index|[
name|MSK_PORT_B
index|]
expr_stmt|;
name|ifp0
operator|=
name|ifp1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc_if0
operator|!=
name|NULL
condition|)
name|ifp0
operator|=
name|sc_if0
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
name|sc_if1
operator|!=
name|NULL
condition|)
name|ifp1
operator|=
name|sc_if1
operator|->
name|msk_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_PHY1
operator|)
operator|!=
literal|0
operator|&&
name|sc_if0
operator|!=
name|NULL
condition|)
name|msk_intr_phy
argument_list|(
name|sc_if0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_PHY2
operator|)
operator|!=
literal|0
operator|&&
name|sc_if1
operator|!=
name|NULL
condition|)
name|msk_intr_phy
argument_list|(
name|sc_if1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_MAC1
operator|)
operator|!=
literal|0
operator|&&
name|sc_if0
operator|!=
name|NULL
condition|)
name|msk_intr_gmac
argument_list|(
name|sc_if0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_IRQ_MAC2
operator|)
operator|!=
literal|0
operator|&&
name|sc_if1
operator|!=
name|NULL
condition|)
name|msk_intr_gmac
argument_list|(
name|sc_if1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_CHK_RX1
operator||
name|Y2_IS_CHK_RX2
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Rx descriptor error\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
operator|(
name|Y2_IS_CHK_RX1
operator||
name|Y2_IS_CHK_RX2
operator|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|Y2_IS_CHK_TXA1
operator||
name|Y2_IS_CHK_TXA2
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|msk_dev
argument_list|,
literal|"Tx descriptor error\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
operator|(
name|Y2_IS_CHK_TXA1
operator||
name|Y2_IS_CHK_TXA2
operator|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_HW_ERR
operator|)
operator|!=
literal|0
condition|)
name|msk_intr_hwerr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|domore
operator|=
name|msk_handle_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|Y2_IS_STAT_BMU
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STAT_CTRL
argument_list|,
name|SC_STAT_CLR_IRQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp0
operator|!=
name|NULL
operator|&&
operator|(
name|ifp0
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp0
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|sc_if0
operator|->
name|msk_tx_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp1
operator|!=
name|NULL
operator|&&
operator|(
name|ifp1
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp1
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|sc_if1
operator|->
name|msk_tx_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|domore
operator|>
literal|0
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|msk_tq
argument_list|,
operator|&
name|sc
operator|->
name|msk_int_task
argument_list|)
expr_stmt|;
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
name|MSK_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reenable interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_Y2_SP_ICR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|msk_if_softc
modifier|*
name|sc_if
init|=
name|xsc
decl_stmt|;
name|MSK_IF_LOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|msk_init_locked
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|MSK_IF_UNLOCK
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_init_locked
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint16_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
operator|/
literal|2
index|]
decl_stmt|;
name|uint16_t
name|gmac
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc_if
operator|->
name|msk_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Cancel pending I/O and free all Rx/Tx buffers. */
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_framesize
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
comment|/* 	 * Initialize GMAC first. 	 * Without this initialization, Rx MAC did not work as expected 	 * and Rx MAC garbled status LEs and it resulted in out-of-order 	 * or duplicated frame delivery which in turn showed very poor 	 * Rx performance.(I had to write a packet analysis code that 	 * could be embeded in driver to diagnose this issue.) 	 * I've spent almost 2 months to fix this issue. If I have had 	 * datasheet for Yukon II I wouldn't have encountered this. :-( 	 */
name|gmac
operator|=
name|GM_GPCR_SPEED_100
operator||
name|GM_GPCR_SPEED_1000
operator||
name|GM_GPCR_DUP_FULL
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Dummy read the Interrupt Source Register. */
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_SRC
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set MIB Clear Counter Mode. */
name|gmac
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|,
name|gmac
operator||
name|GM_PAR_MIB_CLR
argument_list|)
expr_stmt|;
comment|/* Read all MIB Counters with Clear Mode set. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GM_MIB_CNT_SIZE
condition|;
name|i
operator|++
control|)
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_MIB_CNT_BASE
operator|+
literal|8
operator|*
name|i
argument_list|)
expr_stmt|;
comment|/* Clear MIB Clear Counter Mode. */
name|gmac
operator|&=
operator|~
name|GM_PAR_MIB_CLR
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_PHY_ADDR
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Disable FCS. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_CTRL
argument_list|,
name|GM_RXCR_CRC_DIS
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Control Register. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_CTRL
argument_list|,
name|TX_COL_THR
argument_list|(
name|TX_COL_DEF
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Flow Control Register. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_FLOW_CTRL
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Parameter Register. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_PARAM
argument_list|,
name|TX_JAM_LEN_VAL
argument_list|(
name|TX_JAM_LEN_DEF
argument_list|)
operator||
name|TX_JAM_IPG_VAL
argument_list|(
name|TX_JAM_IPG_DEF
argument_list|)
operator||
name|TX_IPG_JAM_DATA
argument_list|(
name|TX_IPG_JAM_DEF
argument_list|)
operator||
name|TX_BACK_OFF_LIM
argument_list|(
name|TX_BOF_LIM_DEF
argument_list|)
argument_list|)
expr_stmt|;
name|gmac
operator|=
name|DATA_BLIND_VAL
argument_list|(
name|DATA_BLIND_DEF
argument_list|)
operator||
name|GM_SMOD_VLAN_ENA
operator||
name|IPG_DATA_VAL
argument_list|(
name|IPG_DATA_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
name|MSK_MAX_FRAMELEN
condition|)
name|gmac
operator||=
name|GM_SMOD_JUMBO_ENA
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SERIAL_MODE
argument_list|,
name|gmac
argument_list|)
expr_stmt|;
comment|/* Set station address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_1L
operator|+
name|i
operator|*
literal|4
argument_list|,
name|eaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_SRC_ADDR_2L
operator|+
name|i
operator|*
literal|4
argument_list|,
name|eaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Disable interrupts for counter overflows. */
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TX_IRQ_MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_RX_IRQ_MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_TR_IRQ_MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure Rx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_OPER_ON
operator||
name|GMF_RX_F_FL_ON
argument_list|)
expr_stmt|;
comment|/* Set promiscuous mode. */
name|msk_setpromisc
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Set multicast filter. */
name|msk_setmulti
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Flush Rx MAC FIFO on any flow control or error. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_FL_MSK
argument_list|)
argument_list|,
name|GMR_FS_ANY_ERR
argument_list|)
expr_stmt|;
comment|/* Set Rx FIFO flush threshold to 64 bytes. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_FL_THR
argument_list|)
argument_list|,
name|RX_GMF_FL_THR_DEF
argument_list|)
expr_stmt|;
comment|/* Configure Tx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_OPER_ON
argument_list|)
expr_stmt|;
comment|/* Configure hardware VLAN tag insertion/stripping. */
name|msk_setvlan
argument_list|(
name|sc_if
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX It seems STFW is requried for all cases. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_STFW_ENA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC_U
condition|)
block|{
comment|/* Set Rx Pause threshould. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_LP_THR
argument_list|)
argument_list|,
name|MSK_ECU_LLPP
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_UP_THR
argument_list|)
argument_list|,
name|MSK_ECU_ULPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
name|MSK_MAX_FRAMELEN
condition|)
block|{
comment|/* 			 * Can't sure the following code is needed as Yukon 			 * Yukon EC Ultra may not support jumbo frames. 			 * 			 * Set Tx GMAC FIFO Almost Empty Threshold. 			 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_AE_THR
argument_list|)
argument_list|,
name|MSK_ECU_AE_THR
argument_list|)
expr_stmt|;
comment|/* Disable Store& Forward mode for Tx. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|TX_STFW_DIS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Disable Force Sync bit and Alloc bit in Tx RAM interface 	 * arbiter as we don't use Sync Tx queue. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TXA_CTRL
argument_list|)
argument_list|,
name|TXA_DIS_FSYNC
operator||
name|TXA_DIS_ALLOC
operator||
name|TXA_STOP_RC
argument_list|)
expr_stmt|;
comment|/* Enable the RAM Interface Arbiter. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TXA_CTRL
argument_list|)
argument_list|,
name|TXA_ENA_ARB
argument_list|)
expr_stmt|;
comment|/* Setup RAM buffer. */
name|msk_set_rambuffer
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Disable Tx sync Queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txsq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
argument_list|)
expr_stmt|;
comment|/* Setup Tx Queue Bus Memory Interface. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_RESET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_OPER_INIT
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_FIFO_OP_ON
argument_list|)
expr_stmt|;
comment|/* Increase IPID when hardware generates IP packets in TSO. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_hwassist
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_TX_IPIDINCR_ON
argument_list|)
expr_stmt|;
else|else
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_TX_IPIDINCR_OFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_WM
argument_list|)
argument_list|,
name|MSK_BMU_TX_WM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC_U
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|==
name|CHIP_REV_YU_EC_U_A0
condition|)
block|{
comment|/* Fix for Yukon-EC Ultra: set BMU FIFO level */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_AL
argument_list|)
argument_list|,
name|MSK_ECU_TXFF_LEV
argument_list|)
expr_stmt|;
block|}
comment|/* Setup Rx Queue Bus Memory Interface. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_CLR_RESET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_OPER_INIT
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_FIFO_OP_ON
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_WM
argument_list|)
argument_list|,
name|MSK_BMU_RX_WM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_hw_id
operator|==
name|CHIP_ID_YUKON_EC_U
operator|&&
name|sc
operator|->
name|msk_hw_rev
operator|>=
name|CHIP_REV_YU_EC_U_A1
condition|)
block|{
comment|/* MAC Rx RAM Read is controlled by hardware. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_F
argument_list|)
argument_list|,
name|F_M_RX_RAM_DIS
argument_list|)
expr_stmt|;
block|}
name|msk_set_prefetch
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_tx_ring_paddr
argument_list|,
name|MSK_TX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|msk_init_tx_ring
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Disable Rx checksum offload and RSS hash. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_DIS_RX_CHKSUM
operator||
name|BMU_DIS_RX_RSS_HASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_if
operator|->
name|msk_framesize
operator|>
operator|(
name|MCLBYTES
operator|-
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
name|msk_set_prefetch
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_jumbo_rx_ring_paddr
argument_list|,
name|MSK_JUMBO_RX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|msk_init_jumbo_rx_ring
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msk_set_prefetch
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|sc_if
operator|->
name|msk_rdata
operator|.
name|msk_rx_ring_paddr
argument_list|,
name|MSK_RX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|msk_init_rx_ring
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"initialization failed: no memory for Rx buffers\n"
argument_list|)
expr_stmt|;
name|msk_stop
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Configure interrupt handling. */
if|if
condition|(
name|sc_if
operator|->
name|msk_port
operator|==
name|MSK_PORT_A
condition|)
block|{
name|sc
operator|->
name|msk_intrmask
operator||=
name|Y2_IS_PORT_A
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator||=
name|Y2_HWE_L1_MASK
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|msk_intrmask
operator||=
name|Y2_IS_PORT_B
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator||=
name|Y2_HWE_L2_MASK
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrhwemask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_link
operator|=
literal|0
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|,
name|hz
argument_list|,
name|msk_tick
argument_list|,
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_set_rambuffer
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ltpp
decl_stmt|,
name|utpp
decl_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
comment|/* Setup Rx Queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_START
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_END
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_WP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_RP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|utpp
operator|=
operator|(
name|sc
operator|->
name|msk_rxqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|+
literal|1
operator|-
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|-
name|MSK_RB_ULPP
operator|)
operator|/
literal|8
expr_stmt|;
name|ltpp
operator|=
operator|(
name|sc
operator|->
name|msk_rxqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|+
literal|1
operator|-
name|sc
operator|->
name|msk_rxqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|-
name|MSK_RB_LLPP_B
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msk_rxqsize
operator|<
name|MSK_MIN_RXQ_SIZE
condition|)
name|ltpp
operator|+=
operator|(
name|MSK_RB_LLPP_B
operator|-
name|MSK_RB_LLPP_S
operator|)
operator|/
literal|8
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_RX_UTPP
argument_list|)
argument_list|,
name|utpp
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_RX_LTPP
argument_list|)
argument_list|,
name|ltpp
argument_list|)
expr_stmt|;
comment|/* Set Rx priority(RB_RX_UTHP/RB_RX_LTHP) thresholds? */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_ENA_OP_MD
argument_list|)
expr_stmt|;
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup Tx Queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_CLR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_START
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_END
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqend
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_WP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_RP
argument_list|)
argument_list|,
name|sc
operator|->
name|msk_txqstart
index|[
name|sc_if
operator|->
name|msk_port
index|]
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Enable Store& Forward for Tx side. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_ENA_STFWD
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_ENA_OP_MD
argument_list|)
expr_stmt|;
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_set_prefetch
parameter_list|(
name|struct
name|msk_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qaddr
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
comment|/* Reset the prefetch unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_SET
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_CLR
argument_list|)
expr_stmt|;
comment|/* Set LE base address. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_ADDR_LOW_REG
argument_list|)
argument_list|,
name|MSK_ADDR_LO
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_ADDR_HI_REG
argument_list|)
argument_list|,
name|MSK_ADDR_HI
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the list last index. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_LAST_IDX_REG
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Turn on prefetch unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_OP_ON
argument_list|)
expr_stmt|;
comment|/* Dummy read to ensure write. */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|qaddr
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msk_stop
parameter_list|(
name|struct
name|msk_if_softc
modifier|*
name|sc_if
parameter_list|)
block|{
name|struct
name|msk_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|msk_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|msk_rxdesc
modifier|*
name|jrxd
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MSK_IF_LOCK_ASSERT
argument_list|(
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_if
operator|->
name|msk_softc
expr_stmt|;
name|ifp
operator|=
name|sc_if
operator|->
name|msk_ifp
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc_if
operator|->
name|msk_tick_ch
argument_list|)
expr_stmt|;
name|sc_if
operator|->
name|msk_watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable interrupts. */
if|if
condition|(
name|sc_if
operator|->
name|msk_port
operator|==
name|MSK_PORT_A
condition|)
block|{
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
name|Y2_IS_PORT_A
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_HWE_L1_MASK
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|msk_intrmask
operator|&=
operator|~
name|Y2_IS_PORT_B
expr_stmt|;
name|sc
operator|->
name|msk_intrhwemask
operator|&=
operator|~
name|Y2_HWE_L2_MASK
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrhwemask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_HWE_IMSK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|,
name|sc
operator|->
name|msk_intrmask
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|B0_IMSK
argument_list|)
expr_stmt|;
comment|/* Disable Tx/Rx MAC. */
name|val
operator|=
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|GM_GPCR_RX_ENA
operator||
name|GM_GPCR_TX_ENA
operator|)
expr_stmt|;
name|GMAC_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Read again to ensure writing. */
name|GMAC_READ_2
argument_list|(
name|sc
argument_list|,
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GM_GP_CTRL
argument_list|)
expr_stmt|;
comment|/* Stop Tx BMU. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_STOP
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|BMU_STOP
operator||
name|BMU_IDLE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_STOP
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Tx BMU stop failed\n"
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
operator||
name|RB_DIS_OP_MD
argument_list|)
expr_stmt|;
comment|/* Disable all GMAC interrupt. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_IRQ_MSK
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable PHY interrupt. */
if|if
condition|(
name|sc
operator|->
name|msk_marvell_phy
condition|)
name|msk_phy_writereg
argument_list|(
name|sc_if
argument_list|,
name|PHY_ADDR_MARV
argument_list|,
name|PHY_MARV_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable the RAM Interface Arbiter. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TXA_CTRL
argument_list|)
argument_list|,
name|TXA_DIS_ARB
argument_list|)
expr_stmt|;
comment|/* Reset the PCI FIFO of the async Tx queue */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_RST_SET
operator||
name|BMU_FIFO_RST
argument_list|)
expr_stmt|;
comment|/* Reset the Tx prefetch units. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset the RAM Buffer async Tx queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_txq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset Tx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|TX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
comment|/* Set Pause Off. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|GMAC_CTRL
argument_list|)
argument_list|,
name|GMC_PAUSE_OFF
argument_list|)
expr_stmt|;
comment|/* 	 * The Rx Stop command will not work for Yukon-2 if the BMU does not 	 * reach the end of packet and since we can't make sure that we have 	 * incoming data, we must reset the BMU while it is not during a DMA 	 * transfer. Since it is possible that the Rx path is still active, 	 * the Rx RAM buffer will be stopped first, so any possible incoming 	 * data will not trigger a DMA. After the RAM buffer is stopped, the 	 * BMU is polled until any DMA in progress is ended and only then it 	 * will be reset. 	 */
comment|/* Disable the RAM Buffer receive queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_DIS_OP_MD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_RSL
argument_list|)
argument_list|)
operator|==
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_RL
argument_list|)
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MSK_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|sc_if
operator|->
name|msk_if_dev
argument_list|,
literal|"Rx BMU stop failed\n"
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|Q_CSR
argument_list|)
argument_list|,
name|BMU_RST_SET
operator||
name|BMU_FIFO_RST
argument_list|)
expr_stmt|;
comment|/* Reset the Rx prefetch unit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|Y2_PREF_Q_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|PREF_UNIT_CTRL_REG
argument_list|)
argument_list|,
name|PREF_UNIT_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset the RAM Buffer receive queue. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RB_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_rxq
argument_list|,
name|RB_CTRL
argument_list|)
argument_list|,
name|RB_RST_SET
argument_list|)
expr_stmt|;
comment|/* Reset Rx MAC FIFO. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MR_ADDR
argument_list|(
name|sc_if
operator|->
name|msk_port
argument_list|,
name|RX_GMF_CTRL_T
argument_list|)
argument_list|,
name|GMF_RST_SET
argument_list|)
expr_stmt|;
comment|/* Free Rx and Tx mbufs still in the queues. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxd
operator|->
name|rx_m
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_JUMBO_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|jrxd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|jrxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|jrxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_jumbo_rx_tag
argument_list|,
name|jrxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|jrxd
operator|->
name|rx_m
argument_list|)
expr_stmt|;
name|jrxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSK_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc_if
operator|->
name|msk_cdata
operator|.
name|msk_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Mark the interface down. 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc_if
operator|->
name|msk_link
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|arg1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
name|low
operator|||
name|value
operator|>
name|high
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_msk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|MSK_PROC_MIN
argument_list|,
name|MSK_PROC_MAX
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

