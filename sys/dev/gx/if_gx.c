begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999,2000,2001 Jonathan Lemon  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/gx/if_gxreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/gx/if_gxvar.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|gx
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_define
define|#
directive|define
name|TUNABLE_TX_INTR_DELAY
value|100
end_define

begin_define
define|#
directive|define
name|TUNABLE_RX_INTR_DELAY
value|100
end_define

begin_define
define|#
directive|define
name|GX_CSUM_FEATURES
value|(CSUM_IP | CSUM_TCP | CSUM_UDP | CSUM_IP_FRAGS)
end_define

begin_comment
comment|/*  * Various supported device vendors/types and their names.  */
end_comment

begin_struct
struct|struct
name|gx_device
block|{
name|u_int16_t
name|vendor
decl_stmt|;
name|u_int16_t
name|device
decl_stmt|;
name|int
name|version_flags
decl_stmt|;
name|u_int32_t
name|version_ipg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|gx_device
name|gx_devs
index|[]
init|=
block|{
block|{
name|INTEL_VENDORID
block|,
name|DEVICEID_WISEMAN
block|,
name|GXF_FORCE_TBI
operator||
name|GXF_OLD_REGS
block|,
literal|10
operator||
literal|2
operator|<<
literal|10
operator||
literal|10
operator|<<
literal|20
block|,
literal|"Intel Gigabit Ethernet (82542)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|DEVICEID_LIVINGOOD_FIBER
block|,
name|GXF_DMA
operator||
name|GXF_ENABLE_MWI
operator||
name|GXF_CSUM
block|,
literal|6
operator||
literal|8
operator|<<
literal|10
operator||
literal|6
operator|<<
literal|20
block|,
literal|"Intel Gigabit Ethernet (82543GC-F)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|DEVICEID_LIVINGOOD_COPPER
block|,
name|GXF_DMA
operator||
name|GXF_ENABLE_MWI
operator||
name|GXF_CSUM
block|,
literal|8
operator||
literal|8
operator|<<
literal|10
operator||
literal|6
operator|<<
literal|20
block|,
literal|"Intel Gigabit Ethernet (82543GC-T)"
block|}
block|,
if|#
directive|if
literal|0
comment|/* notyet.. */
block|{ INTEL_VENDORID, DEVICEID_CORDOVA_FIBER, 	    GXF_DMA | GXF_ENABLE_MWI | GXF_CSUM, 	    6 | 8<< 10 | 6<< 20, 	    "Intel Gigabit Ethernet (82544EI-F)" }, 	{ INTEL_VENDORID, DEVICEID_CORDOVA_COPPER, 	    GXF_DMA | GXF_ENABLE_MWI | GXF_CSUM, 	    8 | 8<< 10 | 6<< 20, 	    "Intel Gigabit Ethernet (82544EI-T)" }, 	{ INTEL_VENDORID, DEVICEID_CORDOVA2_COPPER, 	    GXF_DMA | GXF_ENABLE_MWI | GXF_CSUM, 	    8 | 8<< 10 | 6<< 20, 	    "Intel Gigabit Ethernet (82544GC-T)" },
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gx_regs
name|new_regs
init|=
block|{
name|GX_RX_RING_BASE
block|,
name|GX_RX_RING_LEN
block|,
name|GX_RX_RING_HEAD
block|,
name|GX_RX_RING_TAIL
block|,
name|GX_RX_INTR_DELAY
block|,
name|GX_RX_DMA_CTRL
block|,
name|GX_TX_RING_BASE
block|,
name|GX_TX_RING_LEN
block|,
name|GX_TX_RING_HEAD
block|,
name|GX_TX_RING_TAIL
block|,
name|GX_TX_INTR_DELAY
block|,
name|GX_TX_DMA_CTRL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gx_regs
name|old_regs
init|=
block|{
name|GX_RX_OLD_RING_BASE
block|,
name|GX_RX_OLD_RING_LEN
block|,
name|GX_RX_OLD_RING_HEAD
block|,
name|GX_RX_OLD_RING_TAIL
block|,
name|GX_RX_OLD_INTR_DELAY
block|,
name|GX_RX_OLD_DMA_CTRL
block|,
name|GX_TX_OLD_RING_BASE
block|,
name|GX_TX_OLD_RING_LEN
block|,
name|GX_TX_OLD_RING_HEAD
block|,
name|GX_TX_OLD_RING_TAIL
block|,
name|GX_TX_OLD_INTR_DELAY
block|,
name|GX_TX_OLD_DMA_CTRL
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|gx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|gx_device
modifier|*
name|gx_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_eeprom_getword
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int16_t
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_read_eeprom
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|,
name|caddr_t
name|dest
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_setmulti
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_reset
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_phy_reset
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_release
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_stop
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_init_rx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_free_rx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gx_init_tx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gx_free_tx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|gx_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|gx_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|gx_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|gx_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|gx_shutdown
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|gx_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|gx_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|gx_miibus_statchg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|gx_driver
init|=
block|{
literal|"gx"
block|,
name|gx_methods
block|,
expr|sizeof
operator|(
expr|struct
name|gx_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|gx_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_gx
argument_list|,
name|pci
argument_list|,
name|gx_driver
argument_list|,
name|gx_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|gx
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|gx_device
modifier|*
name|gx_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|gx_devs
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|gx_devs
index|[
name|i
index|]
operator|.
name|vendor
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|gx_devs
index|[
name|i
index|]
operator|.
name|device
operator|)
condition|)
return|return
operator|(
operator|&
name|gx_devs
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gx_device
modifier|*
name|gx_dev
decl_stmt|;
name|gx_dev
operator|=
name|gx_match
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|gx_dev
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|struct
name|gx_device
modifier|*
name|gx_dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|gx
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gx_softc
argument_list|)
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_dev
operator|=
name|dev
expr_stmt|;
name|gx_dev
operator|=
name|gx_match
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_vflags
operator|=
name|gx_dev
operator|->
name|version_flags
expr_stmt|;
name|gx
operator|->
name|gx_ipg
operator|=
name|gx_dev
operator|->
name|version_ipg
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|gx
operator|->
name|gx_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|GX_LOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_vflags
operator|&
name|GXF_ENABLE_MWI
condition|)
name|command
operator||=
name|PCIM_CMD_MWIEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* XXX check cache line size? */
if|if
condition|(
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable memory mapping!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rid
operator|=
name|GX_PCI_LOMEM
expr_stmt|;
name|gx
operator|->
name|gx_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* support PIO mode */
block|rid = PCI_LOIO; 	gx->gx_res = bus_alloc_resource(dev, SYS_RES_IOPORT,&rid, 	    0, ~0, 1, RF_ACTIVE);
endif|#
directive|endif
if|if
condition|(
name|gx
operator|->
name|gx_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|gx
operator|->
name|gx_btag
operator|=
name|rman_get_bustag
argument_list|(
name|gx
operator|->
name|gx_res
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|gx
operator|->
name|gx_res
argument_list|)
expr_stmt|;
comment|/* Allocate interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|gx
operator|->
name|gx_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|gx
operator|->
name|gx_irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|gx_intr
argument_list|,
name|gx
argument_list|,
operator|&
name|gx
operator|->
name|gx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't setup irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* compensate for different register mappings */
if|if
condition|(
name|gx
operator|->
name|gx_vflags
operator|&
name|GXF_OLD_REGS
condition|)
name|gx
operator|->
name|gx_reg
operator|=
name|old_regs
expr_stmt|;
else|else
name|gx
operator|->
name|gx_reg
operator|=
name|new_regs
expr_stmt|;
if|if
condition|(
name|gx_read_eeprom
argument_list|(
name|gx
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|GX_EEMAP_MAC
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to read station address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Ethernet address: %6D\n"
argument_list|,
name|gx
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* Allocate the ring buffers. */
name|gx
operator|->
name|gx_rdata
operator|=
name|contigmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gx_ring_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_rdata
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no memory for list buffers!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|gx
operator|->
name|gx_rdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gx_ring_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set default tuneable values. */
name|gx
operator|->
name|gx_tx_intr_delay
operator|=
name|TUNABLE_TX_INTR_DELAY
expr_stmt|;
name|gx
operator|->
name|gx_rx_intr_delay
operator|=
name|TUNABLE_RX_INTR_DELAY
expr_stmt|;
comment|/* Set up ifnet structure */
name|ifp
operator|=
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|gx
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"gx"
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|gx_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|gx_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|gx_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|gx_init
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|GX_TX_RING_CNT
operator|-
literal|1
expr_stmt|;
comment|/* see if we can enable hardware checksumming */
if|if
condition|(
name|gx
operator|->
name|gx_vflags
operator|&
name|GXF_CSUM
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
block|}
comment|/* figure out transciever type */
if|if
condition|(
name|gx
operator|->
name|gx_vflags
operator|&
name|GXF_FORCE_TBI
operator|||
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_STATUS
argument_list|)
operator|&
name|GX_STAT_TBIMODE
condition|)
name|gx
operator|->
name|gx_tbimode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
block|{
comment|/* SERDES transceiver */
name|ifmedia_init
argument_list|(
operator|&
name|gx
operator|->
name|gx_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|gx_ifmedia_upd
argument_list|,
name|gx_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|gx
operator|->
name|gx_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|gx
operator|->
name|gx_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|gx
operator|->
name|gx_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* GMII/MII transceiver */
name|gx_phy_reset
argument_list|(
name|gx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|gx
operator|->
name|gx_miibus
argument_list|,
name|gx_ifmedia_upd
argument_list|,
name|gx_ifmedia_sts
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"GMII/MII, PHY not detected\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * Call MI attach routines. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|GX_UNLOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|GX_UNLOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|gx_release
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_release
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|bus_generic_detach
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_miibus
condition|)
name|device_delete_child
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
name|gx
operator|->
name|gx_miibus
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
name|gx
operator|->
name|gx_irq
argument_list|,
name|gx
operator|->
name|gx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_irq
condition|)
name|bus_release_resource
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|gx
operator|->
name|gx_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_res
condition|)
name|bus_release_resource
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|GX_PCI_LOMEM
argument_list|,
name|gx
operator|->
name|gx_res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
init|=
operator|(
expr|struct
name|gx_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|u_int16_t
modifier|*
name|m
decl_stmt|;
name|u_int32_t
name|ctrl
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|tmp
decl_stmt|;
name|dev
operator|=
name|gx
operator|->
name|gx_dev
expr_stmt|;
name|ifp
operator|=
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|GX_LOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* Disable host interrupts, halt chip. */
name|gx_reset
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* disable I/O, flush RX/TX FIFOs, and free RX/TX buffers */
name|gx_stop
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* Load our MAC address, invalidate other 15 RX addresses. */
name|m
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_RX_ADDR_BASE
argument_list|,
operator|(
name|m
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_RX_ADDR_BASE
operator|+
literal|4
argument_list|,
name|m
index|[
literal|2
index|]
operator||
name|GX_RA_VALID
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_8
argument_list|(
name|gx
argument_list|,
name|GX_RX_ADDR_BASE
operator|+
name|i
operator|*
literal|8
argument_list|,
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Program multicast filter. */
name|gx_setmulti
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* Init RX ring. */
name|gx_init_rx_ring
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* Init TX ring. */
name|gx_init_tx_ring
argument_list|(
name|gx
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_vflags
operator|&
name|GXF_DMA
condition|)
block|{
comment|/* set up DMA control */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_rx_dma_ctrl
argument_list|,
literal|0x00010000
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_tx_dma_ctrl
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
comment|/* enable receiver */
name|ctrl
operator|=
name|GX_RXC_ENABLE
operator||
name|GX_RXC_RX_THOLD_EIGHTH
operator||
name|GX_RXC_RX_BSIZE_2K
expr_stmt|;
name|ctrl
operator||=
name|GX_RXC_BCAST_ACCEPT
expr_stmt|;
comment|/* Enable or disable promiscuous mode as needed. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|ctrl
operator||=
name|GX_RXC_UNI_PROMISC
expr_stmt|;
comment|/* This is required if we want to accept jumbo frames */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
name|ctrl
operator||=
name|GX_RXC_LONG_PKT_ENABLE
expr_stmt|;
comment|/* setup receive checksum control */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_RX_CSUM_CONTROL
argument_list|,
name|GX_CSUM_TCP
comment|/* | GX_CSUM_IP*/
argument_list|)
expr_stmt|;
comment|/* setup transmit checksum control */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|GX_CSUM_FEATURES
expr_stmt|;
name|ctrl
operator||=
name|GX_RXC_STRIP_ETHERCRC
expr_stmt|;
comment|/* not on 82542? */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_RX_CONTROL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* enable transmitter */
name|ctrl
operator|=
name|GX_TXC_ENABLE
operator||
name|GX_TXC_PAD_SHORT_PKTS
operator||
name|GX_TXC_COLL_RETRY_16
expr_stmt|;
comment|/* XXX we should support half-duplex here too... */
name|ctrl
operator||=
name|GX_TXC_COLL_TIME_FDX
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_TX_CONTROL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* 	 * set up recommended IPG times, which vary depending on chip type: 	 * 	IPG transmit time:  80ns 	 *	IPG receive time 1: 20ns 	 *	IPG receive time 2: 80ns 	 */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_TX_IPG
argument_list|,
name|gx
operator|->
name|gx_ipg
argument_list|)
expr_stmt|;
comment|/* set up 802.3x MAC flow control address -- 01:80:c2:00:00:01 */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_FLOW_CTRL_BASE
argument_list|,
literal|0x00C28001
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_FLOW_CTRL_BASE
operator|+
literal|4
argument_list|,
literal|0x00000100
argument_list|)
expr_stmt|;
comment|/* set up 802.3x MAC flow control type -- 88:08 */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_FLOW_CTRL_TYPE
argument_list|,
literal|0x8808
argument_list|)
expr_stmt|;
comment|/* Set up tuneables */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_rx_delay
argument_list|,
name|gx
operator|->
name|gx_rx_intr_delay
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_tx_delay
argument_list|,
name|gx
operator|->
name|gx_tx_intr_delay
argument_list|)
expr_stmt|;
comment|/* 	 * Configure chip for correct operation. 	 */
name|ctrl
operator|=
name|GX_CTRL_DUPLEX
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|ctrl
operator||=
name|GX_CTRL_BIGENDIAN
expr_stmt|;
endif|#
directive|endif
name|ctrl
operator||=
name|GX_CTRL_VLAN_ENABLE
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
block|{
comment|/* 		 * It seems that TXCW must be initialized from the EEPROM 		 * manually. 		 * 		 * XXX 		 * should probably read the eeprom and re-insert the 		 * values here. 		 */
define|#
directive|define
name|TXCONFIG_WORD
value|0x000001A0
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_TX_CONFIG
argument_list|,
name|TXCONFIG_WORD
argument_list|)
expr_stmt|;
comment|/* turn on hardware autonegotiate */
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_TX_CONFIG
argument_list|,
name|GX_TXCFG_AUTONEG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Auto-detect speed from PHY, instead of using direct 		 * indication.  The SLU bit doesn't force the link, but 		 * must be present for ASDE to work. 		 */
name|gx_phy_reset
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|GX_CTRL_SET_LINK_UP
operator||
name|GX_CTRL_AUTOSPEED
expr_stmt|;
block|}
comment|/* 	 * Take chip out of reset and start it running. 	 */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Turn interrupts on. */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_INT_MASK_SET
argument_list|,
name|GX_INT_WANTED
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * Set the current media. 	 */
if|if
condition|(
name|gx
operator|->
name|gx_miibus
operator|!=
name|NULL
condition|)
block|{
name|mii_mediachg
argument_list|(
name|device_get_softc
argument_list|(
name|gx
operator|->
name|gx_miibus
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifm
operator|=
operator|&
name|gx
operator|->
name|gx_media
expr_stmt|;
name|tmp
operator|=
name|ifm
operator|->
name|ifm_media
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|gx_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * Have the LINK0 flag force the link in TBI mode. 	 */
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
condition|)
block|{
name|GX_CLRBIT
argument_list|(
name|gx
argument_list|,
name|GX_TX_CONFIG
argument_list|,
name|GX_TXCFG_AUTONEG
argument_list|)
expr_stmt|;
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|GX_CTRL_SET_LINK_UP
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("66mhz: %s  64bit: %s\n", 	CSR_READ_4(gx, GX_STATUS)& GX_STAT_PCI66 ? "yes" : "no", 	CSR_READ_4(gx, GX_STATUS)& GX_STAT_BUS64 ? "yes" : "no");
endif|#
directive|endif
name|GX_UNLOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop all chip I/O so that the kernel's probe routines don't  * get confused by errant DMAs when rebooting.  */
end_comment

begin_function
specifier|static
name|void
name|gx_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|gx
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gx_reset
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|gx_stop
argument_list|(
name|gx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|gx
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|GX_LOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|gx_reset
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|gx_stop
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|gx
operator|->
name|gx_media
argument_list|)
expr_stmt|;
name|gx_release
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|gx
operator|->
name|gx_rdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gx_ring_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|GX_UNLOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|gx
operator|->
name|gx_mtx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_eeprom_getword
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int16_t
modifier|*
name|dest
parameter_list|)
block|{
name|u_int16_t
name|word
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|base
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|x
decl_stmt|;
name|addr
operator|=
operator|(
name|GX_EE_OPC_READ
operator|<<
name|GX_EE_ADDR_SIZE
operator|)
operator||
operator|(
name|addr
operator|&
operator|(
operator|(
literal|1
operator|<<
name|GX_EE_ADDR_SIZE
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|base
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|)
expr_stmt|;
name|base
operator|&=
operator|~
operator|(
name|GX_EE_DATA_OUT
operator||
name|GX_EE_DATA_IN
operator||
name|GX_EE_CLOCK
operator|)
expr_stmt|;
name|base
operator||=
name|GX_EE_SELECT
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|,
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
operator|(
name|GX_EE_OPC_SIZE
operator|+
name|GX_EE_ADDR_SIZE
operator|)
operator|-
literal|1
operator|)
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
name|reg
operator|=
name|base
operator||
operator|(
name|addr
operator|&
name|x
condition|?
name|GX_EE_DATA_IN
else|:
literal|0
operator|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|,
name|reg
operator||
name|GX_EE_CLOCK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|1
operator|<<
literal|15
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|,
name|base
operator||
name|GX_EE_CLOCK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|GX_EE_DATA_OUT
condition|)
name|word
operator||=
name|x
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_EEPROM_CTRL
argument_list|,
name|base
operator|&
operator|~
name|GX_EE_SELECT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|word
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gx_read_eeprom
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|,
name|caddr_t
name|dest
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|word
decl_stmt|;
name|int
name|i
decl_stmt|;
name|word
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|dest
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|gx_eeprom_getword
argument_list|(
name|gx
argument_list|,
name|off
operator|+
name|i
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|word
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set media options.  */
end_comment

begin_function
specifier|static
name|int
name|gx_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|gx
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
block|{
name|ifm
operator|=
operator|&
name|gx
operator|->
name|gx_media
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|GX_CTRL_LINK_RESET
argument_list|)
expr_stmt|;
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_TX_CONFIG
argument_list|,
name|GX_TXCFG_AUTONEG
argument_list|)
expr_stmt|;
name|GX_CLRBIT
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|GX_CTRL_LINK_RESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFM_1000_SX
case|:
name|device_printf
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
literal|"manual config not supported yet.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|GX_CLRBIT(gx, GX_TX_CONFIG, GX_TXCFG_AUTONEG); 			config =
comment|/* bit symbols for 802.3z */
block|0; 			ctrl |= GX_CTRL_SET_LINK_UP; 			if ((ifm->ifm_media& IFM_GMASK) == IFM_FDX) 				ctrl |= GX_CTRL_DUPLEX;
endif|#
directive|endif
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|ifm
operator|=
operator|&
name|gx
operator|->
name|gx_media
expr_stmt|;
comment|/* 		 * 1000TX half duplex does not work. 		 */
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_ETHER
operator|&&
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_1000_T
operator|&&
operator|(
name|IFM_OPTIONS
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|gx
operator|->
name|gx_miibus
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report current media status.  */
end_comment

begin_function
specifier|static
name|void
name|gx_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|gx
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|GX_STAT_LINKUP
operator|)
operator|==
literal|0
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|gx
operator|->
name|gx_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
operator|(
name|IFM_1000_T
operator||
name|IFM_HDX
operator|)
operator|)
operator|==
operator|(
name|IFM_1000_T
operator||
name|IFM_HDX
operator|)
condition|)
name|mii
operator|->
name|mii_media_active
operator|=
name|IFM_ETHER
operator||
name|IFM_NONE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gx_mii_shiftin
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|,
name|int
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int32_t
name|reg
decl_stmt|,
name|x
decl_stmt|;
comment|/* 	 * Set up default GPIO direction + PHY data out. 	 */
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|GX_CTRL_GPIO_DIR_MASK
operator||
name|GX_CTRL_PHY_IO
operator||
name|GX_CTRL_PHY_CLK
operator|)
expr_stmt|;
name|reg
operator||=
name|GX_CTRL_GPIO_DIR
operator||
name|GX_CTRL_PHY_IO_DIR
expr_stmt|;
comment|/*          * Shift in data to PHY.          */
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|length
operator|-
literal|1
operator|)
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|data
operator|&
name|x
condition|)
name|reg
operator||=
name|GX_CTRL_PHY_IO
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
name|GX_CTRL_PHY_IO
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
operator||
name|GX_CTRL_PHY_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|gx_mii_shiftout
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|u_int32_t
name|reg
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* 	 * Set up default GPIO direction + PHY data in. 	 */
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|GX_CTRL_GPIO_DIR_MASK
operator||
name|GX_CTRL_PHY_IO
operator||
name|GX_CTRL_PHY_CLK
operator|)
expr_stmt|;
name|reg
operator||=
name|GX_CTRL_GPIO_DIR
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
operator||
name|GX_CTRL_PHY_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Shift out data from PHY. 	 */
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
literal|15
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
operator||
name|GX_CTRL_PHY_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|)
operator|&
name|GX_CTRL_PHY_IO
condition|)
name|data
operator||=
name|x
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
operator||
name|GX_CTRL_PHY_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gx_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|gx
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX 	 * Note: Cordova has a MDIC register. livingood and< have mii bits 	 */
name|gx_mii_shiftin
argument_list|(
name|gx
argument_list|,
name|GX_PHY_PREAMBLE
argument_list|,
name|GX_PHY_PREAMBLE_LEN
argument_list|)
expr_stmt|;
name|gx_mii_shiftin
argument_list|(
name|gx
argument_list|,
operator|(
name|GX_PHY_SOF
operator|<<
literal|12
operator|)
operator||
operator|(
name|GX_PHY_OP_READ
operator|<<
literal|10
operator|)
operator||
operator|(
name|phy
operator|<<
literal|5
operator|)
operator||
name|reg
argument_list|,
name|GX_PHY_READ_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|gx_mii_shiftout
argument_list|(
name|gx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|gx
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
return|return;
name|gx_mii_shiftin
argument_list|(
name|gx
argument_list|,
name|GX_PHY_PREAMBLE
argument_list|,
name|GX_PHY_PREAMBLE_LEN
argument_list|)
expr_stmt|;
name|gx_mii_shiftin
argument_list|(
name|gx
argument_list|,
operator|(
name|GX_PHY_SOF
operator|<<
literal|30
operator|)
operator||
operator|(
name|GX_PHY_OP_WRITE
operator|<<
literal|28
operator|)
operator||
operator|(
name|phy
operator|<<
literal|23
operator|)
operator||
operator|(
name|reg
operator|<<
literal|18
operator|)
operator||
operator|(
name|GX_PHY_TURNAROUND
operator|<<
literal|16
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
argument_list|,
name|GX_PHY_WRITE_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|s
decl_stmt|;
name|gx
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
return|return;
comment|/* 	 * Set flow control behavior to mirror what PHY negotiated. 	 */
name|mii
operator|=
name|device_get_softc
argument_list|(
name|gx
operator|->
name|gx_miibus
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|GX_LOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_FLAG0
condition|)
name|reg
operator||=
name|GX_CTRL_RX_FLOWCTRL
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
name|GX_CTRL_RX_FLOWCTRL
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_FLAG1
condition|)
name|reg
operator||=
name|GX_CTRL_TX_FLOWCTRL
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
name|GX_CTRL_TX_FLOWCTRL
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|GX_UNLOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gx_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|s
decl_stmt|,
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|GX_LOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|GX_MAX_MTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|gx_init
argument_list|(
name|gx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|gx_stop
argument_list|(
name|gx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
operator|(
name|gx
operator|->
name|gx_if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_RX_CONTROL
argument_list|,
name|GX_RXC_UNI_PROMISC
argument_list|)
expr_stmt|;
else|else
name|GX_CLRBIT
argument_list|(
name|gx
argument_list|,
name|GX_RX_CONTROL
argument_list|,
name|GX_RXC_UNI_PROMISC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gx_init
argument_list|(
name|gx
argument_list|)
expr_stmt|;
block|}
name|gx
operator|->
name|gx_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|gx_setmulti
argument_list|(
name|gx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
if|if
condition|(
name|gx
operator|->
name|gx_miibus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|gx
operator|->
name|gx_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|gx
operator|->
name|gx_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_HWCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_HWCSUM
expr_stmt|;
else|else
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|gx_init
argument_list|(
name|gx
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|GX_UNLOCK
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_phy_reset
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|GX_CTRL_SET_LINK_UP
argument_list|)
expr_stmt|;
comment|/* 	 * PHY reset is active low. 	 */
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL_EXT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|GX_CTRLX_GPIO_DIR_MASK
operator||
name|GX_CTRLX_PHY_RESET
operator|)
expr_stmt|;
name|reg
operator||=
name|GX_CTRLX_GPIO_DIR
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL_EXT
argument_list|,
name|reg
operator||
name|GX_CTRLX_PHY_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL_EXT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_CTRL_EXT
argument_list|,
name|reg
operator||
name|GX_CTRLX_PHY_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* post-livingood (cordova) only */
block|GX_SETBIT(gx, GX_CTRL, 0x80000000); 		DELAY(1000); 		GX_CLRBIT(gx, GX_CTRL, 0x80000000);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|gx_reset
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
comment|/* Disable host interrupts. */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_INT_MASK_CLR
argument_list|,
name|GX_INT_ALL
argument_list|)
expr_stmt|;
comment|/* reset chip (THWAP!) */
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|GX_CTRL_DEVICE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_stop
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* reset and flush transmitter */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_TX_CONTROL
argument_list|,
name|GX_TXC_RESET
argument_list|)
expr_stmt|;
comment|/* reset and flush receiver */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_RX_CONTROL
argument_list|,
name|GX_RXC_RESET
argument_list|)
expr_stmt|;
comment|/* reset link */
if|if
condition|(
name|gx
operator|->
name|gx_tbimode
condition|)
name|GX_SETBIT
argument_list|(
name|gx
argument_list|,
name|GX_CTRL
argument_list|,
name|GX_CTRL_LINK_RESET
argument_list|)
expr_stmt|;
comment|/* Free the RX lists. */
name|gx_free_rx_ring
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* Free TX buffers. */
name|gx_free_tx_ring
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|gx
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|device_printf
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
literal|"watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|gx_reset
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|gx_init
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intialize a receive ring descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|gx_newbuf
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
name|struct
name|gx_rx_desc
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
literal|"mbuf allocation failed -- packet dropped\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|MCLGET
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m_new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
literal|"cluster allocation failed -- packet dropped\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_new
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * this will _NOT_ work for large MTU's; it will overwrite 	 * the end of the buffer.  E.g.: take this out for jumbograms, 	 * but then that breaks alignment. 	 */
if|if
condition|(
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_mtu
operator|<=
name|ETHERMTU
condition|)
name|m_adj
argument_list|(
name|m_new
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_cdata
operator|.
name|gx_rx_chain
index|[
name|idx
index|]
operator|=
name|m_new
expr_stmt|;
name|r
operator|=
operator|&
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_rx_ring
index|[
name|idx
index|]
expr_stmt|;
name|r
operator|->
name|rx_addr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|rx_staterr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The receive ring can have up to 64K descriptors, which at 2K per mbuf  * cluster, could add up to 128M of memory.  Due to alignment constraints,  * the number of descriptors must be a multiple of 8.  For now, we  * allocate 256 entries and hope that our CPU is fast enough to keep up  * with the NIC.  */
end_comment

begin_function
specifier|static
name|int
name|gx_init_rx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GX_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|gx_newbuf
argument_list|(
name|gx
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* bring receiver out of reset state, leave disabled */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_RX_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up ring registers */
name|CSR_WRITE_8
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_rx_base
argument_list|,
operator|(
name|u_quad_t
operator|)
name|vtophys
argument_list|(
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_rx_ring
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_rx_length
argument_list|,
name|GX_RX_RING_CNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gx_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_rx_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_rx_tail
argument_list|,
name|GX_RX_RING_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_rx_tail_idx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_free_rx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mp
operator|=
name|gx
operator|->
name|gx_cdata
operator|.
name|gx_rx_chain
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GX_RX_RING_CNT
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|mp
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_rx_ring
argument_list|,
name|GX_RX_RING_CNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gx_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* release any partially-received packet chain */
if|if
condition|(
name|gx
operator|->
name|gx_pkthdr
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|gx
operator|->
name|gx_pkthdr
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_pkthdr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gx_init_tx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
comment|/* bring transmitter out of reset state, leave disabled */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_TX_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up ring registers */
name|CSR_WRITE_8
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_tx_base
argument_list|,
operator|(
name|u_quad_t
operator|)
name|vtophys
argument_list|(
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_tx_ring
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_tx_length
argument_list|,
name|GX_TX_RING_CNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_tx_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_tx_tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_tx_head_idx
operator|=
literal|0
expr_stmt|;
name|gx
operator|->
name|gx_tx_tail_idx
operator|=
literal|0
expr_stmt|;
name|gx
operator|->
name|gx_txcnt
operator|=
literal|0
expr_stmt|;
comment|/* set up initial TX context */
name|gx
operator|->
name|gx_txcontext
operator|=
name|GX_TXCONTEXT_NONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_free_tx_ring
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mp
operator|=
name|gx
operator|->
name|gx_cdata
operator|.
name|gx_tx_chain
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GX_TX_RING_CNT
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|mp
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_tx_ring
argument_list|,
name|GX_TX_RING_CNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_setmulti
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* wipe out the multicast table */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_MULTICAST_BASE
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_rxeof
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|gx_rx_desc
modifier|*
name|rx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|staterr
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|gx
operator|->
name|gx_rx_interrupts
operator|++
expr_stmt|;
name|ifp
operator|=
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|idx
operator|=
name|gx
operator|->
name|gx_rx_tail_idx
expr_stmt|;
while|while
condition|(
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_rx_ring
index|[
name|idx
index|]
operator|.
name|rx_staterr
operator|&
name|GX_RXSTAT_COMPLETED
condition|)
block|{
name|rx
operator|=
operator|&
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_rx_ring
index|[
name|idx
index|]
expr_stmt|;
name|m
operator|=
name|gx
operator|->
name|gx_cdata
operator|.
name|gx_rx_chain
index|[
name|idx
index|]
expr_stmt|;
comment|/* 		 * gx_newbuf overwrites status and length bits, so we  		 * make a copy of them here. 		 */
name|len
operator|=
name|rx
operator|->
name|rx_len
expr_stmt|;
name|staterr
operator|=
name|rx
operator|->
name|rx_staterr
expr_stmt|;
if|if
condition|(
name|staterr
operator|&
name|GX_INPUT_ERROR
condition|)
goto|goto
name|ierror
goto|;
if|if
condition|(
name|gx_newbuf
argument_list|(
name|gx
argument_list|,
name|idx
argument_list|,
name|NULL
argument_list|)
operator|==
name|ENOBUFS
condition|)
goto|goto
name|ierror
goto|;
name|GX_INC
argument_list|(
name|idx
argument_list|,
name|GX_RX_RING_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|staterr
operator|&
name|GX_RXSTAT_INEXACT_MATCH
condition|)
block|{
comment|/* 			 * multicast packet, must verify against 			 * multicast address. 			 */
block|}
if|if
condition|(
operator|(
name|staterr
operator|&
name|GX_RXSTAT_END_OF_PACKET
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gx
operator|->
name|gx_pkthdr
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|gx
operator|->
name|gx_pkthdr
operator|=
name|m
expr_stmt|;
name|gx
operator|->
name|gx_pktnextp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|gx
operator|->
name|gx_pkthdr
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
operator|*
operator|(
name|gx
operator|->
name|gx_pktnextp
operator|)
operator|=
name|m
expr_stmt|;
name|gx
operator|->
name|gx_pktnextp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|gx
operator|->
name|gx_pkthdr
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|gx
operator|->
name|gx_pkthdr
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
operator|*
operator|(
name|gx
operator|->
name|gx_pktnextp
operator|)
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|gx
operator|->
name|gx_pkthdr
expr_stmt|;
name|gx
operator|->
name|gx_pkthdr
operator|=
name|NULL
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* Remove header from mbuf and pass it on. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|IP_CSMASK
value|(GX_RXSTAT_IGNORE_CSUM | GX_RXSTAT_HAS_IP_CSUM)
define|#
directive|define
name|TCP_CSMASK
define|\
value|(GX_RXSTAT_IGNORE_CSUM | GX_RXSTAT_HAS_TCP_CSUM | GX_RXERR_TCP_CSUM)
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 			 * Intel Erratum #23 indicates that the Receive IP 			 * Checksum offload feature has been completely 			 * disabled. 			 */
block|if ((staterr& IP_CSUM_MASK) == GX_RXSTAT_HAS_IP_CSUM) { 				m->m_pkthdr.csum_flags |= CSUM_IP_CHECKED; 				if ((staterr& GX_RXERR_IP_CSUM) == 0) 					m->m_pkthdr.csum_flags |= CSUM_IP_VALID; 			}
endif|#
directive|endif
if|if
condition|(
operator|(
name|staterr
operator|&
name|TCP_CSMASK
operator|)
operator|==
name|GX_RXSTAT_HAS_TCP_CSUM
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
comment|/* 		 * If we received a packet with a vlan tag, pass it 		 * to vlan_input() instead of ether_input(). 		 */
if|if
condition|(
name|staterr
operator|&
name|GX_RXSTAT_VLAN_PKT
condition|)
block|{
name|VLAN_INPUT_TAG
argument_list|(
name|eh
argument_list|,
name|m
argument_list|,
name|rx
operator|->
name|rx_special
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
continue|continue;
name|ierror
label|:
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|gx_newbuf
argument_list|(
name|gx
argument_list|,
name|idx
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*  		 * XXX 		 * this isn't quite right.  Suppose we have a packet that 		 * spans 5 descriptors (9K split into 2K buffers).  If 		 * the 3rd descriptor sets an error, we need to ignore 		 * the last two.  The way things stand now, the last two 		 * will be accepted as a single packet. 		 * 		 * we don't worry about this -- the chip may not set an 		 * error in this case, and the checksum of the upper layers 		 * will catch the error. 		 */
if|if
condition|(
name|gx
operator|->
name|gx_pkthdr
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|gx
operator|->
name|gx_pkthdr
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_pkthdr
operator|=
name|NULL
expr_stmt|;
block|}
name|GX_INC
argument_list|(
name|idx
argument_list|,
name|GX_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
name|gx
operator|->
name|gx_rx_tail_idx
operator|=
name|idx
expr_stmt|;
if|if
condition|(
operator|--
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
name|GX_RX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_rx_tail
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_txeof
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|cnt
decl_stmt|;
name|gx
operator|->
name|gx_tx_interrupts
operator|++
expr_stmt|;
name|ifp
operator|=
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|idx
operator|=
name|gx
operator|->
name|gx_tx_head_idx
expr_stmt|;
name|cnt
operator|=
name|gx
operator|->
name|gx_txcnt
expr_stmt|;
comment|/* 	 * If the system chipset performs I/O write buffering, it is  	 * possible for the PIO read of the head descriptor to bypass the 	 * memory write of the descriptor, resulting in reading a descriptor 	 * which has not been updated yet. 	 */
while|while
condition|(
name|cnt
condition|)
block|{
name|struct
name|gx_tx_desc_old
modifier|*
name|tx
decl_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|gx_tx_desc_old
operator|*
operator|)
operator|&
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_tx_ring
index|[
name|idx
index|]
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|tx
operator|->
name|tx_command
operator|&
name|GX_TXOLD_END_OF_PKT
operator|)
operator|==
literal|0
condition|)
block|{
name|GX_INC
argument_list|(
name|idx
argument_list|,
name|GX_TX_RING_CNT
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|tx
operator|->
name|tx_status
operator|&
name|GX_TXSTAT_DONE
operator|)
operator|==
literal|0
condition|)
break|break;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|gx
operator|->
name|gx_cdata
operator|.
name|gx_tx_chain
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_cdata
operator|.
name|gx_tx_chain
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|gx
operator|->
name|gx_txcnt
operator|=
name|cnt
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|GX_INC
argument_list|(
name|idx
argument_list|,
name|GX_TX_RING_CNT
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_tx_head_idx
operator|=
name|idx
expr_stmt|;
block|}
if|if
condition|(
name|gx
operator|->
name|gx_txcnt
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gx_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int32_t
name|intr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|gx
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
operator|&
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|gx
operator|->
name|gx_interrupts
operator|++
expr_stmt|;
comment|/* Disable host interrupts. */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_INT_MASK_CLR
argument_list|,
name|GX_INT_ALL
argument_list|)
expr_stmt|;
comment|/* 	 * find out why we're being bothered. 	 * reading this register automatically clears all bits. 	 */
name|intr
operator|=
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_INT_READ
argument_list|)
expr_stmt|;
comment|/* Check RX return ring producer/consumer */
if|if
condition|(
name|intr
operator|&
operator|(
name|GX_INT_RCV_TIMER
operator||
name|GX_INT_RCV_THOLD
operator||
name|GX_INT_RCV_OVERRUN
operator|)
condition|)
name|gx_rxeof
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* Check TX ring producer/consumer */
if|if
condition|(
name|intr
operator|&
operator|(
name|GX_INT_XMIT_DONE
operator||
name|GX_INT_XMIT_EMPTY
operator|)
condition|)
name|gx_txeof
argument_list|(
name|gx
argument_list|)
expr_stmt|;
comment|/* 	 * handle other interrupts here. 	 */
comment|/* 	 * Link change interrupts are not reliable; the interrupt may 	 * not be generated if the link is lost.  However, the register 	 * read is reliable, so check that.  Use SEQ errors to possibly 	 * indicate that the link has changed. 	 */
if|if
condition|(
name|intr
operator|&
name|GX_INT_LINK_CHANGE
condition|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|gx
argument_list|,
name|GX_STATUS
argument_list|)
operator|&
name|GX_STAT_LINKUP
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
literal|"link down\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|gx
operator|->
name|gx_dev
argument_list|,
literal|"link up\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Turn interrupts on. */
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|GX_INT_MASK_SET
argument_list|,
name|GX_INT_WANTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|gx_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an mbuf chain in the tx ring by coupling the mbuf data  * pointers to descriptors.  */
end_comment

begin_function
specifier|static
name|int
name|gx_encap
parameter_list|(
name|struct
name|gx_softc
modifier|*
name|gx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|gx_tx_desc_data
modifier|*
name|tx
init|=
name|NULL
decl_stmt|;
name|struct
name|gx_tx_desc_ctx
modifier|*
name|tctx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|cnt
decl_stmt|,
name|csumopts
decl_stmt|,
name|txcontext
decl_stmt|;
name|struct
name|ifvlan
modifier|*
name|ifv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|m_head
operator|->
name|m_flags
operator|&
operator|(
name|M_PROTO1
operator||
name|M_PKTHDR
operator|)
operator|)
operator|==
operator|(
name|M_PROTO1
operator||
name|M_PKTHDR
operator|)
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|!=
name|NULL
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_type
operator|==
name|IFT_L2VLAN
condition|)
name|ifv
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_softc
expr_stmt|;
name|cnt
operator|=
name|gx
operator|->
name|gx_txcnt
expr_stmt|;
name|idx
operator|=
name|gx
operator|->
name|gx_tx_tail_idx
expr_stmt|;
name|txcontext
operator|=
name|gx
operator|->
name|gx_txcontext
expr_stmt|;
comment|/* 	 * Insure we have at least 4 descriptors pre-allocated. 	 */
if|if
condition|(
name|cnt
operator|>=
name|GX_TX_RING_CNT
operator|-
literal|4
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 	 * Set up the appropriate offload context if necessary. 	 */
name|csumopts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
name|csumopts
operator||=
name|GX_TXTCP_OPT_IP_CSUM
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
block|{
name|csumopts
operator||=
name|GX_TXTCP_OPT_TCP_CSUM
expr_stmt|;
name|txcontext
operator|=
name|GX_TXCONTEXT_TCPIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
name|csumopts
operator||=
name|GX_TXTCP_OPT_TCP_CSUM
expr_stmt|;
name|txcontext
operator|=
name|GX_TXCONTEXT_UDPIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|txcontext
operator|==
name|GX_TXCONTEXT_NONE
condition|)
name|txcontext
operator|=
name|GX_TXCONTEXT_TCPIP
expr_stmt|;
if|if
condition|(
name|txcontext
operator|==
name|gx
operator|->
name|gx_txcontext
condition|)
goto|goto
name|context_done
goto|;
name|tctx
operator|=
operator|(
expr|struct
name|gx_tx_desc_ctx
operator|*
operator|)
operator|&
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_tx_ring
index|[
name|idx
index|]
expr_stmt|;
name|tctx
operator|->
name|tx_ip_csum_start
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|tctx
operator|->
name|tx_ip_csum_end
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|-
literal|1
expr_stmt|;
name|tctx
operator|->
name|tx_ip_csum_offset
operator|=
name|ETHER_HDR_LEN
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_sum
argument_list|)
expr_stmt|;
name|tctx
operator|->
name|tx_tcp_csum_start
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|tctx
operator|->
name|tx_tcp_csum_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txcontext
operator|==
name|GX_TXCONTEXT_TCPIP
condition|)
name|tctx
operator|->
name|tx_tcp_csum_offset
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
else|else
name|tctx
operator|->
name|tx_tcp_csum_offset
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
expr_stmt|;
name|tctx
operator|->
name|tx_command
operator|=
name|GX_TXCTX_EXTENSION
operator||
name|GX_TXCTX_INT_DELAY
expr_stmt|;
name|tctx
operator|->
name|tx_type
operator|=
literal|0
expr_stmt|;
name|tctx
operator|->
name|tx_status
operator|=
literal|0
expr_stmt|;
name|GX_INC
argument_list|(
name|idx
argument_list|,
name|GX_TX_RING_CNT
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|context_done
label|:
comment|/*  	 * Start packing the mbufs in this chain into the transmit 	 * descriptors.  Stop when we run out of descriptors or hit 	 * the end of the mbuf chain. 	 */
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cnt
operator|==
name|GX_TX_RING_CNT
condition|)
block|{
name|printf
argument_list|(
literal|"overflow(2): %d, %d\n"
argument_list|,
name|cnt
argument_list|,
name|GX_TX_RING_CNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|tx
operator|=
operator|(
expr|struct
name|gx_tx_desc_data
operator|*
operator|)
operator|&
name|gx
operator|->
name|gx_rdata
operator|->
name|gx_tx_ring
index|[
name|idx
index|]
expr_stmt|;
name|tx
operator|->
name|tx_addr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_status
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|tx_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|gx
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_hwassist
condition|)
block|{
name|tx
operator|->
name|tx_type
operator|=
literal|1
expr_stmt|;
name|tx
operator|->
name|tx_command
operator|=
name|GX_TXTCP_EXTENSION
expr_stmt|;
name|tx
operator|->
name|tx_options
operator|=
name|csumopts
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This is really a struct gx_tx_desc_old. 			 */
name|tx
operator|->
name|tx_command
operator|=
literal|0
expr_stmt|;
block|}
name|GX_INC
argument_list|(
name|idx
argument_list|,
name|GX_TX_RING_CNT
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|!=
name|NULL
condition|)
block|{
name|tx
operator|->
name|tx_command
operator||=
name|GX_TXTCP_REPORT_STATUS
operator||
name|GX_TXTCP_INT_DELAY
operator||
name|GX_TXTCP_ETHER_CRC
operator||
name|GX_TXTCP_END_OF_PKT
expr_stmt|;
if|if
condition|(
name|ifv
operator|!=
name|NULL
condition|)
block|{
name|tx
operator|->
name|tx_command
operator||=
name|GX_TXTCP_VLAN_ENABLE
expr_stmt|;
name|tx
operator|->
name|tx_vlan
operator|=
name|ifv
operator|->
name|ifv_tag
expr_stmt|;
block|}
name|gx
operator|->
name|gx_txcnt
operator|=
name|cnt
expr_stmt|;
name|gx
operator|->
name|gx_tx_tail_idx
operator|=
name|idx
expr_stmt|;
name|gx
operator|->
name|gx_txcontext
operator|=
name|txcontext
expr_stmt|;
name|idx
operator|=
name|GX_PREV
argument_list|(
name|idx
argument_list|,
name|GX_TX_RING_CNT
argument_list|)
expr_stmt|;
name|gx
operator|->
name|gx_cdata
operator|.
name|gx_tx_chain
index|[
name|idx
index|]
operator|=
name|m_head
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|gx
argument_list|,
name|gx
operator|->
name|gx_reg
operator|.
name|r_tx_tail
argument_list|,
name|gx
operator|->
name|gx_tx_tail_idx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main transmit routine. To avoid having to do mbuf copies, we put pointers  * to the mbuf data regions directly in the transmit descriptors.  */
end_comment

begin_function
specifier|static
name|void
name|gx_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|gx_softc
modifier|*
name|gx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|gx
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, set the OACTIVE flag and wait 		 * for the NIC to drain the ring. 		 */
if|if
condition|(
name|gx_encap
argument_list|(
name|gx
argument_list|,
name|m_head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
break|break;
block|}
comment|/* 		 * If there's a BPF listener, bounce a copy of this frame 		 * to him. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/* 		 * Set a timeout in case the chip goes out to lunch. 		 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

