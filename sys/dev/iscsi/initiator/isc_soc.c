begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2007 Daniel Braniss<danny@cs.huji.ac.il>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  | iSCSI  | $Id: isc_soc.c,v 1.26 2007/05/19 06:09:01 danny Exp danny $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_iscsi_initiator.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi/initiator/iscsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi/initiator/iscsivar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MBUF
end_ifndef

begin_define
define|#
directive|define
name|USE_MBUF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MBUF
end_ifdef

begin_comment
comment|/*  |  a dummy function for freeing external storage for mbuf  */
end_comment

begin_function
specifier|static
name|void
name|nil_fn
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{ }
end_function

begin_decl_stmt
specifier|static
name|int
name|nil_refcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MBUF */
end_comment

begin_function
name|int
name|isc_sendPDU
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|,
name|pduq_t
modifier|*
name|pq
parameter_list|)
block|{
name|pdu_t
modifier|*
name|pp
init|=
operator|&
name|pq
operator|->
name|pdu
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MBUF
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
else|#
directive|else
name|struct
name|uio
modifier|*
name|uio
init|=
operator|&
name|pq
operator|->
name|uio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iv
decl_stmt|;
endif|#
directive|endif
comment|/* USE_MBUF */
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MBUF
name|bzero
argument_list|(
name|uio
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uio
argument_list|)
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|->
name|uio_td
operator|=
name|sp
operator|->
name|td
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|=
name|iv
operator|=
name|pq
operator|->
name|iov
expr_stmt|;
name|iv
operator|->
name|iov_base
operator|=
operator|&
name|pp
operator|->
name|ipdu
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|pq
operator|->
name|len
expr_stmt|;
name|iv
operator|++
expr_stmt|;
else|#
directive|else
comment|/* USE_MBUF */
comment|/*  mbuf for the iSCSI header */
name|MGETHDR
argument_list|(
name|mh
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|mh
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|ipdu
argument_list|,
name|mh
operator|->
name|m_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* USE_MBUF */
if|if
condition|(
name|sp
operator|->
name|hdrDigest
condition|)
name|pq
operator|->
name|pdu
operator|.
name|hdr_dig
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
operator|&
name|pp
operator|->
name|ipdu
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ahs_len
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_MBUF
name|iv
operator|->
name|iov_base
operator|=
name|pp
operator|->
name|ahs
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
name|pp
operator|->
name|ahs_len
expr_stmt|;
name|iv
operator|++
expr_stmt|;
else|#
directive|else
comment|/* USE_MBUF */
comment|/* Add any AHS to the iSCSI hdr mbuf */
comment|/* XXX Assert: (mh->m_pkthdr.len + pp->ahs_len)< MHLEN */
name|bcopy
argument_list|(
name|pp
operator|->
name|ahs
argument_list|,
operator|(
name|mh
operator|->
name|m_data
operator|+
name|mh
operator|->
name|m_len
operator|)
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_len
operator|+=
name|pp
operator|->
name|ahs_len
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pp
operator|->
name|ahs_len
expr_stmt|;
endif|#
directive|endif
comment|/* USE_MBUF */
if|if
condition|(
name|sp
operator|->
name|hdrDigest
condition|)
name|pq
operator|->
name|pdu
operator|.
name|hdr_dig
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
operator|&
name|pp
operator|->
name|ahs
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|,
name|pq
operator|->
name|pdu
operator|.
name|hdr_dig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|hdrDigest
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"hdr_dig=%x"
argument_list|,
name|pq
operator|->
name|pdu
operator|.
name|hdr_dig
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MBUF
name|iv
operator|->
name|iov_base
operator|=
operator|&
name|pp
operator|->
name|hdr_dig
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|iv
operator|++
expr_stmt|;
else|#
directive|else
comment|/* USE_MBUF */
comment|/* Add header digest to the iSCSI hdr mbuf */
comment|/* XXX Assert: (mh->m_pkthdr.len + 4)< MHLEN */
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|hdr_dig
argument_list|,
operator|(
name|mh
operator|->
name|m_data
operator|+
name|mh
operator|->
name|m_len
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_MBUF */
block|}
ifdef|#
directive|ifdef
name|USE_MBUF
name|mp
operator|=
operator|&
name|mh
operator|->
name|m_next
expr_stmt|;
endif|#
directive|endif
comment|/* USE_MBUF */
if|if
condition|(
name|pq
operator|->
name|pdu
operator|.
name|ds
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_MBUF
name|iv
operator|->
name|iov_base
operator|=
name|pp
operator|->
name|ds
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
name|pp
operator|->
name|ds_len
expr_stmt|;
while|while
condition|(
name|iv
operator|->
name|iov_len
operator|&
literal|03
condition|)
comment|// the specs say it must be int alligned
name|iv
operator|->
name|iov_len
operator|++
expr_stmt|;
name|iv
operator|++
expr_stmt|;
else|#
directive|else
comment|/* USE_MBUF */
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|len
operator|=
name|pp
operator|->
name|ds_len
expr_stmt|;
while|while
condition|(
name|len
operator|&
literal|03
condition|)
comment|// the specs say it must be int alligned
name|len
operator|++
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|l
decl_stmt|;
name|MGET
argument_list|(
name|md
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|md
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|=
operator|&
name|nil_refcnt
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|MEXTADD
argument_list|(
name|md
argument_list|,
name|pp
operator|->
name|ds
operator|+
name|off
argument_list|,
name|l
argument_list|,
name|nil_fn
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EXT_EXTREF
argument_list|)
expr_stmt|;
name|md
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|md
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|l
expr_stmt|;
operator|*
name|mp
operator|=
name|md
expr_stmt|;
name|mp
operator|=
operator|&
name|md
operator|->
name|m_next
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|off
operator|+=
name|l
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_MBUF */
block|}
if|if
condition|(
name|sp
operator|->
name|dataDigest
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MBUF
name|struct
name|mbuf
modifier|*
name|me
decl_stmt|;
endif|#
directive|endif
comment|/* USE_MBUF */
name|pp
operator|->
name|ds_dig
operator|=
name|sp
operator|->
name|dataDigest
argument_list|(
name|pp
operator|->
name|ds
argument_list|,
name|pp
operator|->
name|ds_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MBUF
name|iv
operator|->
name|iov_base
operator|=
operator|&
name|pp
operator|->
name|ds_dig
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|iv
operator|++
expr_stmt|;
else|#
directive|else
comment|/* USE_MBUF */
name|MGET
argument_list|(
name|me
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|me
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|mh
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|ds_dig
argument_list|,
name|me
operator|->
name|m_data
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|me
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|me
expr_stmt|;
endif|#
directive|endif
comment|/* USE_MBUF */
block|}
ifndef|#
directive|ifndef
name|USE_MBUF
name|uio
operator|->
name|uio_iovcnt
operator|=
name|iv
operator|-
name|pq
operator|->
name|iov
expr_stmt|;
name|sdebug
argument_list|(
literal|5
argument_list|,
literal|"opcode=%x iovcnt=%d uio_resid=%d itt=%x"
argument_list|,
name|pp
operator|->
name|ipdu
operator|.
name|bhs
operator|.
name|opcode
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|ntohl
argument_list|(
name|pp
operator|->
name|ipdu
operator|.
name|bhs
operator|.
name|itt
argument_list|)
argument_list|)
expr_stmt|;
name|sdebug
argument_list|(
literal|5
argument_list|,
literal|"sp=%p sp->soc=%p uio=%p sp->td=%p"
argument_list|,
name|sp
argument_list|,
name|sp
operator|->
name|soc
argument_list|,
name|uio
argument_list|,
name|sp
operator|->
name|td
argument_list|)
expr_stmt|;
do|do
block|{
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|sosend
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sp
operator|->
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|||
name|error
operator|||
name|len
operator|==
name|uio
operator|->
name|uio_resid
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"uio->uio_resid=%d uio->uio_iovcnt=%d error=%d len=%d"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|,
name|error
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EAGAIN
expr_stmt|;
comment|// 35
block|}
break|break;
block|}
comment|/* 	   | XXX: untested code 	   */
name|sdebug
argument_list|(
literal|1
argument_list|,
literal|"uio->uio_resid=%d uio->uio_iovcnt=%d"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|)
expr_stmt|;
name|iv
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|len
operator|-=
name|uio
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_iovcnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|iv
operator|->
name|iov_len
operator|>
name|len
condition|)
block|{
name|caddr_t
name|bp
init|=
operator|(
name|caddr_t
operator|)
name|iv
operator|->
name|iov_base
decl_stmt|;
name|iv
operator|->
name|iov_len
operator|-=
name|len
expr_stmt|;
name|iv
operator|->
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|bp
index|[
name|len
index|]
expr_stmt|;
break|break;
block|}
name|len
operator|-=
name|iv
operator|->
name|iov_len
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|++
expr_stmt|;
name|iv
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
do|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|stats
operator|.
name|nsent
operator|++
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|sp
operator|->
name|stats
operator|.
name|t_sent
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_MBUF */
if|if
condition|(
operator|(
name|error
operator|=
name|sosend
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mh
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sp
operator|->
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* USE_MBUF */
block|}
ifndef|#
directive|ifndef
name|USE_MBUF
return|return
name|error
return|;
else|#
directive|else
comment|/* USE_MBUF */
name|sp
operator|->
name|stats
operator|.
name|nsent
operator|++
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|sp
operator|->
name|stats
operator|.
name|t_sent
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* USE_MBUF */
block|}
comment|/*  | wait till a PDU header is received  | from the socket.  */
comment|/*    The format of the BHS is:     Byte/     0       |       1       |       2       |       3       |       /              |               |               |               |      |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|      +---------------+---------------+---------------+---------------+     0|.|I| Opcode    |F|  Opcode-specific fields                     |      +---------------+---------------+---------------+---------------+     4|TotalAHSLength | DataSegmentLength                             |      +---------------+---------------+---------------+---------------+     8| LUN or Opcode-specific fields                                 |      +                                                               +    12|                                                               |      +---------------+---------------+---------------+---------------+    16| Initiator Task Tag                                            |      +---------------+---------------+---------------+---------------+    20/ Opcode-specific fields                                        /     +/                                                               /      +---------------+---------------+---------------+---------------+    48  */
specifier|static
name|__inline
name|int
name|so_getbhs
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|bhs_t
modifier|*
name|bhs
init|=
operator|&
name|sp
operator|->
name|bhs
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
operator|&
name|sp
operator|->
name|uio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
init|=
operator|&
name|sp
operator|->
name|iov
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
name|bhs
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|bhs_t
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|=
name|iov
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|->
name|uio_td
operator|=
name|curthread
expr_stmt|;
comment|// why ...
name|uio
operator|->
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|bhs_t
argument_list|)
expr_stmt|;
name|flags
operator|=
name|MSG_WAITALL
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|debug
argument_list|(
literal|2
argument_list|,
literal|"error=%d so_error=%d uio->uio_resid=%d iov.iov_len=%zd"
argument_list|,
name|error
argument_list|,
name|sp
operator|->
name|soc
operator|->
name|so_error
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"error=%d so_error=%d uio->uio_resid=%d iov.iov_len=%zd so_state=%x"
argument_list|,
name|error
argument_list|,
name|sp
operator|->
name|soc
operator|->
name|so_error
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|iov
operator|->
name|iov_len
argument_list|,
name|sp
operator|->
name|soc
operator|->
name|so_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
comment|// EPIPE;
block|}
return|return
name|error
return|;
block|}
comment|/*  | so_recv gets called when there is at least  | an iSCSI header in the queue  */
specifier|static
name|int
name|so_recv
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|,
name|pduq_t
modifier|*
name|pq
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|sp
operator|->
name|soc
decl_stmt|;
name|sn_t
modifier|*
name|sn
init|=
operator|&
name|sp
operator|->
name|sn
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
operator|&
name|pq
operator|->
name|uio
decl_stmt|;
name|pdu_t
modifier|*
name|pp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|len
decl_stmt|;
name|bhs_t
modifier|*
name|bhs
decl_stmt|;
name|u_int
name|max
decl_stmt|,
name|exp
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/*       | now calculate how much data should be in the buffer       | NOTE: digest is not verified/calculated - yet       */
name|pp
operator|=
operator|&
name|pq
operator|->
name|pdu
expr_stmt|;
name|bhs
operator|=
operator|&
name|pp
operator|->
name|ipdu
operator|.
name|bhs
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bhs
operator|->
name|AHSLength
condition|)
block|{
name|pp
operator|->
name|ahs_len
operator|=
name|bhs
operator|->
name|AHSLength
operator|*
literal|4
expr_stmt|;
name|len
operator|+=
name|pp
operator|->
name|ahs_len
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|hdrDigest
condition|)
name|len
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|bhs
operator|->
name|DSLength
condition|)
block|{
name|n
operator|=
name|bhs
operator|->
name|DSLength
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|pp
operator|->
name|ds_len
operator|=
operator|(
operator|(
name|n
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
name|n
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|n
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
else|#
directive|else
name|pp
operator|->
name|ds_len
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
name|len
operator|+=
name|pp
operator|->
name|ds_len
expr_stmt|;
while|while
condition|(
name|len
operator|&
literal|03
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|dataDigest
condition|)
name|len
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|opt
operator|.
name|maxRecvDataSegmentLength
operator|>
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
name|sp
operator|->
name|opt
operator|.
name|maxRecvDataSegmentLength
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|xdebug("impossible PDU length(%d) opt.maxRecvDataSegmentLength=%d", 		 len, sp->opt.maxRecvDataSegmentLength);
comment|// deep trouble here, probably all we can do is
comment|// force a disconnect, XXX: check RFC ...
block|log(LOG_ERR, 	      "so_recv: impossible PDU length(%ld) from iSCSI %s/%s\n", 	      len, sp->opt.targetAddress, sp->opt.targetName);
endif|#
directive|endif
comment|/* 	   | XXX: this will realy screwup the stream. 	   | should clear up the buffer till a valid header 	   | is found, or just close connection ... 	   | should read the RFC. 	   */
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|->
name|uio_td
operator|=
name|curthread
expr_stmt|;
comment|// why ...
name|flags
operator|=
name|MSG_WAITALL
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|,
operator|&
name|pq
operator|->
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|//if(error == EAGAIN)
comment|// XXX: this needs work! it hangs iscontrol
if|if
condition|(
name|error
operator|||
name|uio
operator|->
name|uio_resid
condition|)
goto|goto
name|out
goto|;
block|}
name|pq
operator|->
name|len
operator|+=
name|len
expr_stmt|;
name|sdebug
argument_list|(
literal|6
argument_list|,
literal|"len=%d] opcode=0x%x ahs_len=0x%x ds_len=0x%x"
argument_list|,
name|pq
operator|->
name|len
argument_list|,
name|bhs
operator|->
name|opcode
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|,
name|pp
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|max
operator|=
name|ntohl
argument_list|(
name|bhs
operator|->
name|MaxCmdSN
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ntohl
argument_list|(
name|bhs
operator|->
name|ExpStSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|exp
operator|-
literal|1
operator|&&
name|max
operator|>
name|exp
operator|-
name|_MAXINCR
condition|)
block|{
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"bad cmd window size"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
comment|// XXX: for now;
goto|goto
name|out
goto|;
comment|// error
block|}
if|if
condition|(
name|SNA_GT
argument_list|(
name|max
argument_list|,
name|sn
operator|->
name|maxCmd
argument_list|)
condition|)
name|sn
operator|->
name|maxCmd
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|SNA_GT
argument_list|(
name|exp
argument_list|,
name|sn
operator|->
name|expCmd
argument_list|)
condition|)
name|sn
operator|->
name|expCmd
operator|=
name|exp
expr_stmt|;
name|sp
operator|->
name|cws
operator|=
name|sn
operator|->
name|maxCmd
operator|-
name|sn
operator|->
name|expCmd
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
comment|// XXX: need some work here
name|xdebug
argument_list|(
literal|"have a problem, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pdu_free
argument_list|(
name|sp
operator|->
name|isc
argument_list|,
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/*  | wait for something to arrive.  | and if the pdu is without errors, process it.  */
specifier|static
name|int
name|so_input
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|pduq_t
modifier|*
name|pq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/*       | first read in the iSCSI header       */
name|error
operator|=
name|so_getbhs
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 	   | now read the rest. 	   */
name|pq
operator|=
name|pdu_alloc
argument_list|(
name|sp
operator|->
name|isc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// OK to WAIT
name|pq
operator|->
name|pdu
operator|.
name|ipdu
operator|.
name|bhs
operator|=
name|sp
operator|->
name|bhs
expr_stmt|;
name|pq
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
name|bhs_t
argument_list|)
expr_stmt|;
comment|// so far only the header was read
name|error
operator|=
name|so_recv
argument_list|(
name|sp
argument_list|,
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|+=
literal|0x800
expr_stmt|;
comment|// XXX: just to see the error.
comment|// terminal error
comment|// XXX: close connection and exit
block|}
else|else
block|{
name|sp
operator|->
name|stats
operator|.
name|nrecv
operator|++
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|sp
operator|->
name|stats
operator|.
name|t_recv
argument_list|)
expr_stmt|;
name|ism_recv
argument_list|(
name|sp
argument_list|,
name|pq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
comment|/*  | one per active (connected) session.  | this thread is responsible for reading  | in packets from the target.  */
specifier|static
name|void
name|isc_soc
parameter_list|(
name|void
modifier|*
name|vp
parameter_list|)
block|{
name|isc_session_t
modifier|*
name|sp
init|=
operator|(
name|isc_session_t
operator|*
operator|)
name|vp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|sp
operator|->
name|soc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|ISC_CON_RUNNING
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cam_path
condition|)
name|ic_release
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sp
operator|->
name|flags
operator|&
name|ISC_CON_RUN
condition|)
block|{
comment|// XXX: hunting ...
if|if
condition|(
name|sp
operator|->
name|soc
operator|==
name|NULL
operator|||
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"sp->soc=%p"
argument_list|,
name|sp
operator|->
name|soc
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|so_input
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ISC_OWAITING
name|mtx_lock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|ISC_OWAITING
condition|)
block|{
name|sp
operator|->
name|flags
operator|&=
operator|~
name|ISC_OWAITING
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|sp
operator|->
name|flags
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|wakeup
argument_list|(
operator|&
name|sp
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
break|break;
elseif|else
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
comment|// there seems to be a problem in 6.0 ...
name|tsleep
argument_list|(
name|sp
argument_list|,
name|PRIBIO
argument_list|,
literal|"isc_soc"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"terminated, flags=%x so_count=%d so_state=%x error=%d"
argument_list|,
name|sp
operator|->
name|flags
argument_list|,
name|so
operator|->
name|so_count
argument_list|,
name|so
operator|->
name|so_state
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|proc
operator|!=
name|NULL
operator|)
operator|&&
name|sp
operator|->
name|signal
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|sp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|sp
operator|->
name|proc
argument_list|,
name|sp
operator|->
name|signal
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|sp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|ISC_SIGNALED
expr_stmt|;
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"pid=%d signaled(%d)"
argument_list|,
name|sp
operator|->
name|proc
operator|->
name|p_pid
argument_list|,
name|sp
operator|->
name|signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we have to do something ourselves
comment|// like closing this session ...
block|}
comment|/*       | we've been terminated       */
comment|// do we need this mutex ...?
name|mtx_lock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|ISC_CON_RUNNING
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sp
operator|->
name|soc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|isc_stop_receiver
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|n
init|=
literal|5
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|sdebug
argument_list|(
literal|4
argument_list|,
literal|"sp=%p sp->soc=%p"
argument_list|,
name|sp
argument_list|,
name|sp
condition|?
name|sp
operator|->
name|soc
else|:
literal|0
argument_list|)
expr_stmt|;
name|soshutdown
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|SHUT_RD
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|ISC_CON_RUN
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|sp
operator|->
name|flags
operator|&
name|ISC_CON_RUNNING
operator|)
condition|)
block|{
name|sdebug
argument_list|(
literal|3
argument_list|,
literal|"waiting n=%d... flags=%x"
argument_list|,
name|n
argument_list|,
name|sp
operator|->
name|flags
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|sp
operator|->
name|soc
argument_list|,
operator|&
name|sp
operator|->
name|io_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"isc_stpc"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|fp
operator|!=
name|NULL
condition|)
name|fdrop
argument_list|(
name|sp
operator|->
name|fp
argument_list|,
name|sp
operator|->
name|td
argument_list|)
expr_stmt|;
name|fputsock
argument_list|(
name|sp
operator|->
name|soc
argument_list|)
expr_stmt|;
name|sp
operator|->
name|soc
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|void
name|isc_start_receiver
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|ISC_CON_RUN
expr_stmt|;
name|kproc_create
argument_list|(
name|isc_soc
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|soc_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"iscsi%d"
argument_list|,
name|sp
operator|->
name|sid
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

