begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi/icl.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi/iscsi_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi/iscsi_proto.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi/iscsi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
end_ifdef

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
end_ifdef

begin_expr_stmt
name|FEATURE
argument_list|(
name|iscsi_kernel_proxy
argument_list|,
literal|"iSCSI initiator built with ICL_KERNEL_PROXY"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX: This is global so the iscsi_unload() can access it.  * 	Think about how to do this properly.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|iscsi_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|iscsi
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"iSCSI initiator"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|debug
argument_list|,
literal|0
argument_list|,
literal|"Enable debug messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ping_timeout
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|ping_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ping_timeout
argument_list|,
literal|0
argument_list|,
literal|"Timeout for ping (NOP-Out) requests, in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iscsid_timeout
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|iscsid_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|iscsid_timeout
argument_list|,
literal|0
argument_list|,
literal|"Time to wait for iscsid(8) to handle reconnection, in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|login_timeout
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|login_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|login_timeout
argument_list|,
literal|0
argument_list|,
literal|"Time to wait for iscsid(8) to finish Login Phase, in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|maxtags
init|=
literal|255
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|maxtags
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|maxtags
argument_list|,
literal|0
argument_list|,
literal|"Max number of IO requests queued"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|fail_on_disconnection
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|fail_on_disconnection
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|fail_on_disconnection
argument_list|,
literal|0
argument_list|,
literal|"Destroy CAM SIM on connection failure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ISCSI
argument_list|,
literal|"iSCSI"
argument_list|,
literal|"iSCSI initiator"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|iscsi_outstanding_zone
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CONN_SESSION
parameter_list|(
name|X
parameter_list|)
value|((struct iscsi_session *)X->ic_prv0)
end_define

begin_define
define|#
directive|define
name|PDU_SESSION
parameter_list|(
name|X
parameter_list|)
value|(CONN_SESSION(X->ip_conn))
end_define

begin_define
define|#
directive|define
name|ISCSI_DEBUG
parameter_list|(
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 1) 						\ 			printf("%s: " X "\n", __func__, ## __VA_ARGS__);\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ISCSI_WARN
parameter_list|(
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 0) {					\ 			printf("WARNING: %s: " X "\n",			\ 			    __func__, ## __VA_ARGS__);			\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ISCSI_SESSION_DEBUG
parameter_list|(
name|S
parameter_list|,
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 1) {					\ 			printf("%s: %s (%s): " X "\n",			\ 			    __func__, S->is_conf.isc_target_addr,	\ 			    S->is_conf.isc_target, ## __VA_ARGS__);	\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ISCSI_SESSION_WARN
parameter_list|(
name|S
parameter_list|,
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 0) {					\ 			printf("WARNING: %s (%s): " X "\n",		\ 			    S->is_conf.isc_target_addr,			\ 			    S->is_conf.isc_target, ## __VA_ARGS__);	\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ISCSI_SESSION_LOCK
parameter_list|(
name|X
parameter_list|)
value|mtx_lock(&X->is_lock)
end_define

begin_define
define|#
directive|define
name|ISCSI_SESSION_UNLOCK
parameter_list|(
name|X
parameter_list|)
value|mtx_unlock(&X->is_lock)
end_define

begin_define
define|#
directive|define
name|ISCSI_SESSION_LOCK_ASSERT
parameter_list|(
name|X
parameter_list|)
value|mtx_assert(&X->is_lock, MA_OWNED)
end_define

begin_function_decl
specifier|static
name|int
name|iscsi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|iscsi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|iscsi_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"iscsi"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_queue_locked
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_queue
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_update_statsn
parameter_list|(
specifier|const
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_nop_in
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_scsi_response
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_task_response
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_data_in
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_logout_response
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_r2t
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_async_message
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_pdu_handle_reject
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_session_reconnect
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_session_terminate
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|iscsi_outstanding
modifier|*
name|iscsi_outstanding_find
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|uint32_t
name|initiator_task_tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|iscsi_outstanding
modifier|*
name|iscsi_outstanding_add
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|uint32_t
name|initiator_task_tag
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iscsi_outstanding_remove
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|struct
name|iscsi_outstanding
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bool
name|iscsi_pdu_prepare
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|iscsi_bhs_scsi_command
modifier|*
name|bhssc
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
comment|/* 	 * We're only using fields common for all the request 	 * (initiator -> target) PDUs. 	 */
name|bhssc
operator|=
operator|(
expr|struct
name|iscsi_bhs_scsi_command
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
comment|/* 	 * Data-Out PDU does not contain CmdSN. 	 */
if|if
condition|(
name|bhssc
operator|->
name|bhssc_opcode
operator|!=
name|ISCSI_BHS_OPCODE_SCSI_DATA_OUT
condition|)
block|{
if|if
condition|(
name|is
operator|->
name|is_cmdsn
operator|>
name|is
operator|->
name|is_maxcmdsn
operator|&&
operator|(
name|bhssc
operator|->
name|bhssc_opcode
operator|&
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Current MaxCmdSN prevents us from sending any more 			 * SCSI Command PDUs to the target; postpone the PDU. 			 * It will get resent by either iscsi_pdu_queue(), 			 * or by maintenance thread. 			 */
if|#
directive|if
literal|0
block|ISCSI_SESSION_DEBUG(is, "postponing send, CmdSN %d, ExpCmdSN %d, MaxCmdSN %d, opcode 0x%x", 			    is->is_cmdsn, is->is_expcmdsn, is->is_maxcmdsn, bhssc->bhssc_opcode);
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
name|bhssc
operator|->
name|bhssc_cmdsn
operator|=
name|htonl
argument_list|(
name|is
operator|->
name|is_cmdsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bhssc
operator|->
name|bhssc_opcode
operator|&
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
name|is
operator|->
name|is_cmdsn
operator|++
expr_stmt|;
block|}
name|bhssc
operator|->
name|bhssc_expstatsn
operator|=
name|htonl
argument_list|(
name|is
operator|->
name|is_statsn
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_session_send_postponed
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|bool
name|postpone
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
condition|)
block|{
name|request
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
expr_stmt|;
name|postpone
operator|=
name|iscsi_pdu_prepare
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|postpone
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|,
name|ip_next
argument_list|)
expr_stmt|;
name|icl_pdu_queue
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_queue_locked
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|bool
name|postpone
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|iscsi_session_send_postponed
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|postpone
operator|=
name|iscsi_pdu_prepare
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|postpone
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|,
name|request
argument_list|,
name|ip_next
argument_list|)
expr_stmt|;
return|return;
block|}
name|icl_pdu_queue
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_queue
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|iscsi_pdu_queue_locked
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_session_logout
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|iscsi_bhs_logout_request
modifier|*
name|bhslr
decl_stmt|;
name|request
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|is
operator|->
name|is_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
return|return;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_logout_request
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|bhslr
operator|->
name|bhslr_opcode
operator|=
name|ISCSI_BHS_OPCODE_LOGOUT_REQUEST
expr_stmt|;
name|bhslr
operator|->
name|bhslr_reason
operator|=
name|BHSLR_REASON_CLOSE_SESSION
expr_stmt|;
name|iscsi_pdu_queue_locked
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_session_terminate_task
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|struct
name|iscsi_outstanding
modifier|*
name|io
parameter_list|,
name|bool
name|requeue
parameter_list|)
block|{
if|if
condition|(
name|io
operator|->
name|io_ccb
operator|!=
name|NULL
condition|)
block|{
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
operator|(
name|CAM_SIM_QUEUED
operator||
name|CAM_STATUS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|requeue
condition|)
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
else|else
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|io
operator|->
name|io_ccb
argument_list|)
expr_stmt|;
block|}
name|iscsi_outstanding_remove
argument_list|(
name|is
argument_list|,
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_session_terminate_tasks
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|bool
name|requeue
parameter_list|)
block|{
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io
argument_list|,
argument|&is->is_outstanding
argument_list|,
argument|io_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|iscsi_session_terminate_task
argument_list|(
name|is
argument_list|,
name|io
argument_list|,
name|requeue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_session_cleanup
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|bool
name|destroy_sim
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|pdu
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
comment|/* 	 * Don't queue any new PDUs. 	 */
if|if
condition|(
name|is
operator|->
name|is_sim
operator|!=
name|NULL
operator|&&
name|is
operator|->
name|is_simq_frozen
operator|==
name|false
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|is
operator|->
name|is_sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_simq_frozen
operator|=
name|true
expr_stmt|;
block|}
comment|/* 	 * Remove postponed PDUs. 	 */
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
condition|)
block|{
name|pdu
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|,
name|ip_next
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|destroy_sim
operator|==
name|false
condition|)
block|{
comment|/* 		 * Terminate SCSI tasks, asking CAM to requeue them. 		 */
name|iscsi_session_terminate_tasks
argument_list|(
name|is
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|iscsi_session_terminate_tasks
argument_list|(
name|is
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_sim
operator|==
name|NULL
condition|)
return|return;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"deregistering SIM"
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|is
operator|->
name|is_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_simq_frozen
condition|)
block|{
name|xpt_release_simq
argument_list|(
name|is
operator|->
name|is_sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_simq_frozen
operator|=
name|false
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|is
operator|->
name|is_path
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_path
operator|=
name|NULL
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|is
operator|->
name|is_sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|is
operator|->
name|is_sim
argument_list|,
name|TRUE
comment|/*free_devq*/
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_sim
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_devq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_maintenance_thread_reconnect
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
block|{
name|icl_conn_close
argument_list|(
name|is
operator|->
name|is_conn
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_connected
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_reconnecting
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_login_phase
operator|=
name|false
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|is
operator|->
name|is_login_pdu
operator|!=
name|NULL
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|is
operator|->
name|is_login_pdu
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_login_pdu
operator|=
name|NULL
expr_stmt|;
block|}
name|cv_signal
argument_list|(
operator|&
name|is
operator|->
name|is_login_cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fail_on_disconnection
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"connection failed, destroying devices"
argument_list|)
expr_stmt|;
name|iscsi_session_cleanup
argument_list|(
name|is
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iscsi_session_cleanup
argument_list|(
name|is
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_outstanding
argument_list|)
argument_list|,
operator|(
literal|"destroying session with active tasks"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
argument_list|,
operator|(
literal|"destroying session with postponed PDUs"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Request immediate reconnection from iscsid(8). 	 */
comment|//ISCSI_SESSION_DEBUG(is, "waking up iscsid(8)");
name|is
operator|->
name|is_waiting_for_iscsid
operator|=
name|true
expr_stmt|;
name|strlcpy
argument_list|(
name|is
operator|->
name|is_reason
argument_list|,
literal|"Waiting for iscsid(8)"
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|is_reason
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_timeout
operator|=
literal|0
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|is
operator|->
name|is_softc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_maintenance_thread_terminate
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
block|{
name|struct
name|iscsi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|is
operator|->
name|is_softc
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|,
name|is
argument_list|,
name|is_next
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|icl_conn_close
argument_list|(
name|is
operator|->
name|is_conn
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|is
operator|->
name|is_terminating
argument_list|,
operator|(
literal|"is_terminating == false"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|is
operator|->
name|is_login_pdu
operator|!=
name|NULL
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|is
operator|->
name|is_login_pdu
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_login_pdu
operator|=
name|NULL
expr_stmt|;
block|}
name|cv_signal
argument_list|(
operator|&
name|is
operator|->
name|is_login_cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_drain
argument_list|(
operator|&
name|is
operator|->
name|is_callout
argument_list|)
expr_stmt|;
name|iscsi_session_cleanup
argument_list|(
name|is
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_outstanding
argument_list|)
argument_list|,
operator|(
literal|"destroying session with active tasks"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
argument_list|,
operator|(
literal|"destroying session with postponed PDUs"
operator|)
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|icl_conn_free
argument_list|(
name|is
operator|->
name|is_conn
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|is
operator|->
name|is_maintenance_cv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
name|cv_destroy
argument_list|(
operator|&
name|is
operator|->
name|is_login_cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"terminated"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
comment|/* 	 * The iscsi_unload() routine might be waiting. 	 */
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_maintenance_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|arg
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_reconnecting
operator|==
name|false
operator|&&
name|is
operator|->
name|is_terminating
operator|==
name|false
operator|&&
name|STAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|is
operator|->
name|is_maintenance_cv
argument_list|,
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_reconnecting
condition|)
block|{
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|iscsi_maintenance_thread_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is
operator|->
name|is_terminating
condition|)
block|{
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|iscsi_maintenance_thread_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
return|return;
block|}
name|iscsi_session_send_postponed
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_session_reconnect
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
block|{
comment|/* 	 * XXX: We can't use locking here, because 	 * 	it's being called from various contexts. 	 * 	Hope it doesn't break anything. 	 */
if|if
condition|(
name|is
operator|->
name|is_reconnecting
condition|)
return|return;
name|is
operator|->
name|is_reconnecting
operator|=
name|true
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|is
operator|->
name|is_maintenance_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_session_terminate
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_terminating
condition|)
return|return;
name|is
operator|->
name|is_terminating
operator|=
name|true
expr_stmt|;
if|#
directive|if
literal|0
block|iscsi_session_logout(is);
endif|#
directive|endif
name|cv_signal
argument_list|(
operator|&
name|is
operator|->
name|is_maintenance_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_callout
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|iscsi_bhs_nop_out
modifier|*
name|bhsno
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|bool
name|reconnect_needed
init|=
name|false
decl_stmt|;
name|is
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_terminating
condition|)
return|return;
name|callout_schedule
argument_list|(
operator|&
name|is
operator|->
name|is_callout
argument_list|,
literal|1
operator|*
name|hz
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_timeout
operator|++
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_waiting_for_iscsid
condition|)
block|{
if|if
condition|(
name|iscsid_timeout
operator|>
literal|0
operator|&&
name|is
operator|->
name|is_timeout
operator|>
name|iscsid_timeout
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"timed out waiting for iscsid(8) "
literal|"for %d seconds; reconnecting"
argument_list|,
name|is
operator|->
name|is_timeout
argument_list|)
expr_stmt|;
name|reconnect_needed
operator|=
name|true
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|is
operator|->
name|is_login_phase
condition|)
block|{
if|if
condition|(
name|login_timeout
operator|>
literal|0
operator|&&
name|is
operator|->
name|is_timeout
operator|>
name|login_timeout
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"login timed out after %d seconds; "
literal|"reconnecting"
argument_list|,
name|is
operator|->
name|is_timeout
argument_list|)
expr_stmt|;
name|reconnect_needed
operator|=
name|true
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ping_timeout
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Pings are disabled.  Don't send NOP-Out in this case. 		 * Reset the timeout, to avoid triggering reconnection, 		 * should the user decide to reenable them. 		 */
name|is
operator|->
name|is_timeout
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|is
operator|->
name|is_timeout
operator|>=
name|ping_timeout
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"no ping reply (NOP-In) after %d seconds; "
literal|"reconnecting"
argument_list|,
name|ping_timeout
argument_list|)
expr_stmt|;
name|reconnect_needed
operator|=
name|true
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
comment|/* 	 * If the ping was reset less than one second ago - which means 	 * that we've received some PDU during the last second - assume 	 * the traffic flows correctly and don't bother sending a NOP-Out. 	 * 	 * (It's 2 - one for one second, and one for incrementing is_timeout 	 * earlier in this routine.) 	 */
if|if
condition|(
name|is
operator|->
name|is_timeout
operator|<
literal|2
condition|)
return|return;
name|request
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|is
operator|->
name|is_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate PDU"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsno
operator|=
operator|(
expr|struct
name|iscsi_bhs_nop_out
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|bhsno
operator|->
name|bhsno_opcode
operator|=
name|ISCSI_BHS_OPCODE_NOP_OUT
operator||
name|ISCSI_BHS_OPCODE_IMMEDIATE
expr_stmt|;
name|bhsno
operator|->
name|bhsno_flags
operator|=
literal|0x80
expr_stmt|;
name|bhsno
operator|->
name|bhsno_target_transfer_tag
operator|=
literal|0xffffffff
expr_stmt|;
name|iscsi_pdu_queue
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|reconnect_needed
condition|)
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_update_statsn
parameter_list|(
specifier|const
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
specifier|const
name|struct
name|iscsi_bhs_data_in
modifier|*
name|bhsdi
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|uint32_t
name|expcmdsn
decl_stmt|,
name|maxcmdsn
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
comment|/* 	 * We're only using fields common for all the response 	 * (target -> initiator) PDUs. 	 */
name|bhsdi
operator|=
operator|(
specifier|const
expr|struct
name|iscsi_bhs_data_in
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
comment|/* 	 * Ok, I lied.  In case of Data-In, "The fields StatSN, Status, 	 * and Residual Count only have meaningful content if the S bit 	 * is set to 1", so we also need to check the bit specific for 	 * Data-In PDU. 	 */
if|if
condition|(
name|bhsdi
operator|->
name|bhsdi_opcode
operator|!=
name|ISCSI_BHS_OPCODE_SCSI_DATA_IN
operator|||
operator|(
name|bhsdi
operator|->
name|bhsdi_flags
operator|&
name|BHSDI_FLAGS_S
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_statsn
argument_list|)
operator|<
name|is
operator|->
name|is_statsn
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"PDU StatSN %d>= session StatSN %d, opcode 0x%x"
argument_list|,
name|is
operator|->
name|is_statsn
argument_list|,
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_statsn
argument_list|)
argument_list|,
name|bhsdi
operator|->
name|bhsdi_opcode
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_statsn
operator|=
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_statsn
argument_list|)
expr_stmt|;
block|}
name|expcmdsn
operator|=
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_expcmdsn
argument_list|)
expr_stmt|;
name|maxcmdsn
operator|=
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_maxcmdsn
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Compare using Serial Arithmetic Sense. 	 */
if|if
condition|(
name|maxcmdsn
operator|+
literal|1
operator|<
name|expcmdsn
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"PDU MaxCmdSN %d + 1< PDU ExpCmdSN %d; ignoring"
argument_list|,
name|maxcmdsn
argument_list|,
name|expcmdsn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|maxcmdsn
operator|>
name|is
operator|->
name|is_maxcmdsn
condition|)
block|{
name|is
operator|->
name|is_maxcmdsn
operator|=
name|maxcmdsn
expr_stmt|;
comment|/* 			 * Command window increased; kick the maintanance thread 			 * to send out postponed commands. 			 */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
condition|)
name|cv_signal
argument_list|(
operator|&
name|is
operator|->
name|is_maintenance_cv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxcmdsn
operator|<
name|is
operator|->
name|is_maxcmdsn
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"PDU MaxCmdSN %d< session MaxCmdSN %d; ignoring"
argument_list|,
name|maxcmdsn
argument_list|,
name|is
operator|->
name|is_maxcmdsn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expcmdsn
operator|>
name|is
operator|->
name|is_expcmdsn
condition|)
block|{
name|is
operator|->
name|is_expcmdsn
operator|=
name|expcmdsn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expcmdsn
operator|<
name|is
operator|->
name|is_expcmdsn
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"PDU ExpCmdSN %d< session ExpCmdSN %d; ignoring"
argument_list|,
name|expcmdsn
argument_list|,
name|is
operator|->
name|is_expcmdsn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Every incoming PDU - not just NOP-In - resets the ping timer. 	 * The purpose of the timeout is to reset the connection when it stalls; 	 * we don't want this to happen when NOP-In or NOP-Out ends up delayed 	 * in some queue. 	 */
name|is
operator|->
name|is_timeout
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_receive_callback
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|is
operator|->
name|is_login_phase
condition|)
block|{
if|if
condition|(
name|is
operator|->
name|is_login_pdu
operator|==
name|NULL
condition|)
name|is
operator|->
name|is_login_pdu
operator|=
name|response
expr_stmt|;
else|else
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|is
operator|->
name|is_login_cv
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|iscsi_pdu_update_statsn
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* 	 * The handling routine is responsible for freeing the PDU 	 * when it's no longer needed. 	 */
switch|switch
condition|(
name|response
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
condition|)
block|{
case|case
name|ISCSI_BHS_OPCODE_NOP_IN
case|:
name|iscsi_pdu_handle_nop_in
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_SCSI_RESPONSE
case|:
name|iscsi_pdu_handle_scsi_response
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_TASK_RESPONSE
case|:
name|iscsi_pdu_handle_task_response
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_SCSI_DATA_IN
case|:
name|iscsi_pdu_handle_data_in
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_LOGOUT_RESPONSE
case|:
name|iscsi_pdu_handle_logout_response
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_R2T
case|:
name|iscsi_pdu_handle_r2t
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_ASYNC_MESSAGE
case|:
name|iscsi_pdu_handle_async_message
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_REJECT
case|:
name|iscsi_pdu_handle_reject
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"received PDU with unsupported "
literal|"opcode 0x%x; reconnecting"
argument_list|,
name|response
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_error_callback
parameter_list|(
name|struct
name|icl_conn
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|CONN_SESSION
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"connection error; reconnecting"
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_nop_in
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|iscsi_bhs_nop_out
modifier|*
name|bhsno
decl_stmt|;
name|struct
name|iscsi_bhs_nop_in
modifier|*
name|bhsni
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|size_t
name|datasize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|bhsni
operator|=
operator|(
expr|struct
name|iscsi_bhs_nop_in
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
if|if
condition|(
name|bhsni
operator|->
name|bhsni_target_transfer_tag
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* 		 * Nothing to do; iscsi_pdu_update_statsn() already 		 * zeroed the timeout. 		 */
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return;
block|}
name|datasize
operator|=
name|icl_pdu_data_segment_length
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
name|datasize
argument_list|,
name|M_ISCSI
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate memory; "
literal|"reconnecting"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|icl_pdu_get_data
argument_list|(
name|response
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
block|}
name|request
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|response
operator|->
name|ip_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate memory; "
literal|"reconnecting"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsno
operator|=
operator|(
expr|struct
name|iscsi_bhs_nop_out
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|bhsno
operator|->
name|bhsno_opcode
operator|=
name|ISCSI_BHS_OPCODE_NOP_OUT
operator||
name|ISCSI_BHS_OPCODE_IMMEDIATE
expr_stmt|;
name|bhsno
operator|->
name|bhsno_flags
operator|=
literal|0x80
expr_stmt|;
name|bhsno
operator|->
name|bhsno_initiator_task_tag
operator|=
literal|0xffffffff
expr_stmt|;
name|bhsno
operator|->
name|bhsno_target_transfer_tag
operator|=
name|bhsni
operator|->
name|bhsni_target_transfer_tag
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|icl_pdu_append_data
argument_list|(
name|request
argument_list|,
name|data
argument_list|,
name|datasize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate memory; "
literal|"reconnecting"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|data
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
block|}
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_pdu_queue_locked
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_scsi_response
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|iscsi_bhs_scsi_response
modifier|*
name|bhssr
decl_stmt|;
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|size_t
name|data_segment_len
decl_stmt|;
name|uint16_t
name|sense_len
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|bhssr
operator|=
operator|(
expr|struct
name|iscsi_bhs_scsi_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|io
operator|=
name|iscsi_outstanding_find
argument_list|(
name|is
argument_list|,
name|bhssr
operator|->
name|bhssr_initiator_task_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
operator|||
name|io
operator|->
name|io_ccb
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"bad itt 0x%x"
argument_list|,
name|bhssr
operator|->
name|bhssr_initiator_task_tag
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bhssr
operator|->
name|bhssr_response
operator|!=
name|BHSSR_RESPONSE_COMMAND_COMPLETED
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"service response 0x%x"
argument_list|,
name|bhssr
operator|->
name|bhssr_response
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bhssr
operator|->
name|bhssr_status
operator|==
literal|0
condition|)
block|{
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|io
operator|->
name|io_ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|bhssr
operator|->
name|bhssr_status
expr_stmt|;
block|}
if|if
condition|(
name|bhssr
operator|->
name|bhssr_flags
operator|&
name|BHSSR_FLAGS_RESIDUAL_OVERFLOW
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"target indicated residual overflow"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|csio
operator|=
operator|&
name|io
operator|->
name|io_ccb
operator|->
name|csio
expr_stmt|;
name|data_segment_len
operator|=
name|icl_pdu_data_segment_length
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_segment_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|data_segment_len
operator|<
sizeof|sizeof
argument_list|(
name|sense_len
argument_list|)
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"truncated data segment (%zd bytes)"
argument_list|,
name|data_segment_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|icl_pdu_get_data
argument_list|(
name|response
argument_list|,
literal|0
argument_list|,
operator|&
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_len
argument_list|)
argument_list|)
expr_stmt|;
name|sense_len
operator|=
name|ntohs
argument_list|(
name|sense_len
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ISCSI_SESSION_DEBUG(is, "sense_len %d, data len %zd", 		    sense_len, data_segment_len);
endif|#
directive|endif
if|if
condition|(
sizeof|sizeof
argument_list|(
name|sense_len
argument_list|)
operator|+
name|sense_len
operator|>
name|data_segment_len
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"truncated data segment "
literal|"(%zd bytes, should be %zd)"
argument_list|,
name|data_segment_len
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_len
argument_list|)
operator|+
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|sense_len
argument_list|)
operator|+
name|sense_len
operator|<
name|data_segment_len
condition|)
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"oversize data segment "
literal|"(%zd bytes, should be %zd)"
argument_list|,
name|data_segment_len
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_len
argument_list|)
operator|+
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense_len
operator|>
name|csio
operator|->
name|sense_len
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"truncating sense from %d to %d"
argument_list|,
name|sense_len
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|sense_len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
block|}
name|icl_pdu_get_data
argument_list|(
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_len
argument_list|)
argument_list|,
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|sense_len
argument_list|)
expr_stmt|;
name|csio
operator|->
name|sense_resid
operator|=
name|csio
operator|->
name|sense_len
operator|-
name|sense_len
expr_stmt|;
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|bhssr
operator|->
name|bhssr_flags
operator|&
name|BHSSR_FLAGS_RESIDUAL_UNDERFLOW
condition|)
name|csio
operator|->
name|resid
operator|=
name|ntohl
argument_list|(
name|bhssr
operator|->
name|bhssr_residual_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|KASSERT
argument_list|(
name|io
operator|->
name|io_received
operator|<=
name|csio
operator|->
name|dxfer_len
argument_list|,
operator|(
literal|"io->io_received> csio->dxfer_len"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_received
operator|<
name|csio
operator|->
name|dxfer_len
condition|)
block|{
if|if
condition|(
name|csio
operator|->
name|resid
operator|!=
name|csio
operator|->
name|dxfer_len
operator|-
name|io
operator|->
name|io_received
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"underflow mismatch: "
literal|"target indicates %d, we calculated %zd"
argument_list|,
name|csio
operator|->
name|resid
argument_list|,
name|csio
operator|->
name|dxfer_len
operator|-
name|io
operator|->
name|io_received
argument_list|)
expr_stmt|;
block|}
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
operator|-
name|io
operator|->
name|io_received
expr_stmt|;
block|}
block|}
name|xpt_done
argument_list|(
name|io
operator|->
name|io_ccb
argument_list|)
expr_stmt|;
name|iscsi_outstanding_remove
argument_list|(
name|is
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_task_response
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|iscsi_bhs_task_management_response
modifier|*
name|bhstmr
decl_stmt|;
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|,
modifier|*
name|aio
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|bhstmr
operator|=
operator|(
expr|struct
name|iscsi_bhs_task_management_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|io
operator|=
name|iscsi_outstanding_find
argument_list|(
name|is
argument_list|,
name|bhstmr
operator|->
name|bhstmr_initiator_task_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
operator|||
name|io
operator|->
name|io_ccb
operator|!=
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"bad itt 0x%x"
argument_list|,
name|bhstmr
operator|->
name|bhstmr_initiator_task_tag
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bhstmr
operator|->
name|bhstmr_response
operator|!=
name|BHSTMR_RESPONSE_FUNCTION_COMPLETE
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"task response 0x%x"
argument_list|,
name|bhstmr
operator|->
name|bhstmr_response
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aio
operator|=
name|iscsi_outstanding_find
argument_list|(
name|is
argument_list|,
name|io
operator|->
name|io_datasn
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio
operator|!=
name|NULL
operator|&&
name|aio
operator|->
name|io_ccb
operator|!=
name|NULL
condition|)
name|iscsi_session_terminate_task
argument_list|(
name|is
argument_list|,
name|aio
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|iscsi_outstanding_remove
argument_list|(
name|is
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_data_in
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|iscsi_bhs_data_in
modifier|*
name|bhsdi
decl_stmt|;
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|size_t
name|data_segment_len
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|bhsdi
operator|=
operator|(
expr|struct
name|iscsi_bhs_data_in
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|io
operator|=
name|iscsi_outstanding_find
argument_list|(
name|is
argument_list|,
name|bhsdi
operator|->
name|bhsdi_initiator_task_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
operator|||
name|io
operator|->
name|io_ccb
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"bad itt 0x%x"
argument_list|,
name|bhsdi
operator|->
name|bhsdi_initiator_task_tag
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|data_segment_len
operator|=
name|icl_pdu_data_segment_length
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_segment_len
operator|==
literal|0
condition|)
block|{
comment|/* 		 * "The sending of 0 length data segments should be avoided, 		 * but initiators and targets MUST be able to properly receive 		 * 0 length data segments." 		 */
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We need to track this for security reasons - without it, malicious target 	 * could respond to SCSI READ without sending Data-In PDUs, which would result 	 * in read operation on the initiator side returning random kernel data. 	 */
if|if
condition|(
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_buffer_offset
argument_list|)
operator|!=
name|io
operator|->
name|io_received
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"data out of order; expected offset %zd, got %zd"
argument_list|,
name|io
operator|->
name|io_received
argument_list|,
operator|(
name|size_t
operator|)
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_buffer_offset
argument_list|)
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|csio
operator|=
operator|&
name|io
operator|->
name|io_ccb
operator|->
name|csio
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_received
operator|+
name|data_segment_len
operator|>
name|csio
operator|->
name|dxfer_len
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"oversize data segment (%zd bytes "
literal|"at offset %zd, buffer is %d)"
argument_list|,
name|data_segment_len
argument_list|,
name|io
operator|->
name|io_received
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|icl_pdu_get_data
argument_list|(
name|response
argument_list|,
literal|0
argument_list|,
name|csio
operator|->
name|data_ptr
operator|+
name|io
operator|->
name|io_received
argument_list|,
name|data_segment_len
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_received
operator|+=
name|data_segment_len
expr_stmt|;
comment|/* 	 * XXX: Check DataSN. 	 * XXX: Check F. 	 */
if|if
condition|(
operator|(
name|bhsdi
operator|->
name|bhsdi_flags
operator|&
name|BHSDI_FLAGS_S
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Nothing more to do. 		 */
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//ISCSI_SESSION_DEBUG(is, "got S flag; status 0x%x", bhsdi->bhsdi_status);
if|if
condition|(
name|bhsdi
operator|->
name|bhsdi_status
operator|==
literal|0
condition|)
block|{
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|io_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|csio
operator|->
name|scsi_status
operator|=
name|bhsdi
operator|->
name|bhsdi_status
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|KASSERT
argument_list|(
name|io
operator|->
name|io_received
operator|<=
name|csio
operator|->
name|dxfer_len
argument_list|,
operator|(
literal|"io->io_received> csio->dxfer_len"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_received
operator|<
name|csio
operator|->
name|dxfer_len
condition|)
block|{
name|csio
operator|->
name|resid
operator|=
name|ntohl
argument_list|(
name|bhsdi
operator|->
name|bhsdi_residual_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|resid
operator|!=
name|csio
operator|->
name|dxfer_len
operator|-
name|io
operator|->
name|io_received
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"underflow mismatch: "
literal|"target indicates %d, we calculated %zd"
argument_list|,
name|csio
operator|->
name|resid
argument_list|,
name|csio
operator|->
name|dxfer_len
operator|-
name|io
operator|->
name|io_received
argument_list|)
expr_stmt|;
block|}
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
operator|-
name|io
operator|->
name|io_received
expr_stmt|;
block|}
block|}
name|xpt_done
argument_list|(
name|io
operator|->
name|io_ccb
argument_list|)
expr_stmt|;
name|iscsi_outstanding_remove
argument_list|(
name|is
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_logout_response
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
argument_list|,
literal|"logout response"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_r2t
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|iscsi_bhs_r2t
modifier|*
name|bhsr2t
decl_stmt|;
name|struct
name|iscsi_bhs_data_out
modifier|*
name|bhsdo
decl_stmt|;
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|size_t
name|off
decl_stmt|,
name|len
decl_stmt|,
name|total_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|bhsr2t
operator|=
operator|(
expr|struct
name|iscsi_bhs_r2t
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|io
operator|=
name|iscsi_outstanding_find
argument_list|(
name|is
argument_list|,
name|bhsr2t
operator|->
name|bhsr2t_initiator_task_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
operator|||
name|io
operator|->
name|io_ccb
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"bad itt 0x%x; reconnecting"
argument_list|,
name|bhsr2t
operator|->
name|bhsr2t_initiator_task_tag
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|csio
operator|=
operator|&
name|io
operator|->
name|io_ccb
operator|->
name|csio
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_OUT
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"received R2T for read command; reconnecting"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX: Verify R2TSN. 	 */
name|io
operator|->
name|io_datasn
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|ntohl
argument_list|(
name|bhsr2t
operator|->
name|bhsr2t_buffer_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
name|csio
operator|->
name|dxfer_len
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"target requested invalid offset "
literal|"%zd, buffer is is %d; reconnecting"
argument_list|,
name|off
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|total_len
operator|=
name|ntohl
argument_list|(
name|bhsr2t
operator|->
name|bhsr2t_desired_data_transfer_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|==
literal|0
operator|||
name|total_len
operator|>
name|csio
operator|->
name|dxfer_len
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"target requested invalid length "
literal|"%zd, buffer is %d; reconnecting"
argument_list|,
name|total_len
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//ISCSI_SESSION_DEBUG(is, "r2t; off %zd, len %zd", off, total_len);
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|total_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|is
operator|->
name|is_max_data_segment_length
condition|)
name|len
operator|=
name|is
operator|->
name|is_max_data_segment_length
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|len
operator|>
name|csio
operator|->
name|dxfer_len
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"target requested invalid "
literal|"length/offset %zd, buffer is %d; reconnecting"
argument_list|,
name|off
operator|+
name|len
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|request
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|response
operator|->
name|ip_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsdo
operator|=
operator|(
expr|struct
name|iscsi_bhs_data_out
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|bhsdo
operator|->
name|bhsdo_opcode
operator|=
name|ISCSI_BHS_OPCODE_SCSI_DATA_OUT
expr_stmt|;
name|bhsdo
operator|->
name|bhsdo_lun
operator|=
name|bhsr2t
operator|->
name|bhsr2t_lun
expr_stmt|;
name|bhsdo
operator|->
name|bhsdo_initiator_task_tag
operator|=
name|bhsr2t
operator|->
name|bhsr2t_initiator_task_tag
expr_stmt|;
name|bhsdo
operator|->
name|bhsdo_target_transfer_tag
operator|=
name|bhsr2t
operator|->
name|bhsr2t_target_transfer_tag
expr_stmt|;
name|bhsdo
operator|->
name|bhsdo_datasn
operator|=
name|htonl
argument_list|(
name|io
operator|->
name|io_datasn
operator|++
argument_list|)
expr_stmt|;
name|bhsdo
operator|->
name|bhsdo_buffer_offset
operator|=
name|htonl
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|error
operator|=
name|icl_pdu_append_data
argument_list|(
name|request
argument_list|,
name|csio
operator|->
name|data_ptr
operator|+
name|off
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate memory; "
literal|"reconnecting"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
name|off
operator|+=
name|len
expr_stmt|;
name|total_len
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|total_len
operator|==
literal|0
condition|)
block|{
name|bhsdo
operator|->
name|bhsdo_flags
operator||=
name|BHSDO_FLAGS_F
expr_stmt|;
comment|//ISCSI_SESSION_DEBUG(is, "setting F, off %zd", off);
block|}
else|else
block|{
comment|//ISCSI_SESSION_DEBUG(is, "not finished, off %zd", off);
block|}
name|iscsi_pdu_queue_locked
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|==
literal|0
condition|)
break|break;
block|}
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_async_message
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|iscsi_bhs_asynchronous_message
modifier|*
name|bhsam
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|bhsam
operator|=
operator|(
expr|struct
name|iscsi_bhs_asynchronous_message
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
switch|switch
condition|(
name|bhsam
operator|->
name|bhsam_async_event
condition|)
block|{
case|case
name|BHSAM_EVENT_TARGET_REQUESTS_LOGOUT
case|:
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"target requests logout; removing session"
argument_list|)
expr_stmt|;
name|iscsi_session_logout
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHSAM_EVENT_TARGET_TERMINATES_CONNECTION
case|:
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"target indicates it will drop drop the connection"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHSAM_EVENT_TARGET_TERMINATES_SESSION
case|:
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"target indicates it will drop drop the session"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * XXX: Technically, we're obligated to also handle 		 * 	parameter renegotiation. 		 */
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"ignoring AsyncEvent %d"
argument_list|,
name|bhsam
operator|->
name|bhsam_async_event
argument_list|)
expr_stmt|;
break|break;
block|}
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_pdu_handle_reject
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|iscsi_bhs_reject
modifier|*
name|bhsr
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|bhsr
operator|=
operator|(
expr|struct
name|iscsi_bhs_reject
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"received Reject PDU, reason 0x%x; protocol error?"
argument_list|,
name|bhsr
operator|->
name|bhsr_reason
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_daemon_wait
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_daemon_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_waiting_for_iscsid
condition|)
break|break;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No session requires attention from iscsid(8); wait. 			 */
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
continue|continue;
block|}
name|is
operator|->
name|is_waiting_for_iscsid
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_login_phase
operator|=
name|true
expr_stmt|;
name|is
operator|->
name|is_reason
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|request
operator|->
name|idr_session_id
operator|=
name|is
operator|->
name|is_id
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|request
operator|->
name|idr_isid
argument_list|,
operator|&
name|is
operator|->
name|is_isid
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|idr_isid
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|idr_tsih
operator|=
literal|0
expr_stmt|;
comment|/* New or reinstated session. */
name|memcpy
argument_list|(
operator|&
name|request
operator|->
name|idr_conf
argument_list|,
operator|&
name|is
operator|->
name|is_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|idr_conf
argument_list|)
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_daemon_handoff
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_daemon_handoff
modifier|*
name|handoff
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Find the session to hand off socket to. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_id
operator|==
name|handoff
operator|->
name|idh_session_id
condition|)
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_conf
operator|.
name|isc_discovery
operator|||
name|is
operator|->
name|is_terminating
condition|)
block|{
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|is
operator|->
name|is_connected
condition|)
block|{
comment|/* 		 * This might have happened because another iscsid(8) 		 * instance handed off the connection in the meantime. 		 * Just return. 		 */
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"handoff on already connected "
literal|"session"
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|is
operator|->
name|is_target_alias
argument_list|,
name|handoff
operator|->
name|idh_target_alias
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|is_target_alias
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_tsih
operator|=
name|handoff
operator|->
name|idh_tsih
expr_stmt|;
name|is
operator|->
name|is_statsn
operator|=
name|handoff
operator|->
name|idh_statsn
expr_stmt|;
name|is
operator|->
name|is_initial_r2t
operator|=
name|handoff
operator|->
name|idh_initial_r2t
expr_stmt|;
name|is
operator|->
name|is_immediate_data
operator|=
name|handoff
operator|->
name|idh_immediate_data
expr_stmt|;
name|is
operator|->
name|is_max_data_segment_length
operator|=
name|handoff
operator|->
name|idh_max_data_segment_length
expr_stmt|;
name|is
operator|->
name|is_max_burst_length
operator|=
name|handoff
operator|->
name|idh_max_burst_length
expr_stmt|;
name|is
operator|->
name|is_first_burst_length
operator|=
name|handoff
operator|->
name|idh_first_burst_length
expr_stmt|;
if|if
condition|(
name|handoff
operator|->
name|idh_header_digest
operator|==
name|ISCSI_DIGEST_CRC32C
condition|)
name|is
operator|->
name|is_conn
operator|->
name|ic_header_crc32c
operator|=
name|true
expr_stmt|;
else|else
name|is
operator|->
name|is_conn
operator|->
name|ic_header_crc32c
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|handoff
operator|->
name|idh_data_digest
operator|==
name|ISCSI_DIGEST_CRC32C
condition|)
name|is
operator|->
name|is_conn
operator|->
name|ic_data_crc32c
operator|=
name|true
expr_stmt|;
else|else
name|is
operator|->
name|is_conn
operator|->
name|ic_data_crc32c
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_cmdsn
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_expcmdsn
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_maxcmdsn
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_waiting_for_iscsid
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_login_phase
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_timeout
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_connected
operator|=
name|true
expr_stmt|;
name|is
operator|->
name|is_reason
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|handoff
operator|->
name|idh_socket
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* 		 * Handoff without using ICL proxy. 		 */
name|error
operator|=
name|icl_conn_handoff
argument_list|(
name|is
operator|->
name|is_conn
argument_list|,
name|handoff
operator|->
name|idh_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
block|}
endif|#
directive|endif
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_sim
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * When reconnecting, there already is SIM allocated for the session. 		 */
name|KASSERT
argument_list|(
name|is
operator|->
name|is_simq_frozen
argument_list|,
operator|(
literal|"reconnect without frozen simq"
operator|)
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"releasing"
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|is
operator|->
name|is_sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_simq_frozen
operator|=
name|false
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_devq
operator|=
name|cam_simq_alloc
argument_list|(
name|maxtags
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_devq
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate simq"
argument_list|)
expr_stmt|;
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|is
operator|->
name|is_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|iscsi_action
argument_list|,
name|iscsi_poll
argument_list|,
literal|"iscsi"
argument_list|,
name|is
argument_list|,
name|is
operator|->
name|is_id
comment|/* unit */
argument_list|,
operator|&
name|is
operator|->
name|is_lock
argument_list|,
literal|1
argument_list|,
name|maxtags
argument_list|,
name|is
operator|->
name|is_devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_sim
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate SIM"
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|is
operator|->
name|is_devq
argument_list|)
expr_stmt|;
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|xpt_bus_register
argument_list|(
name|is
operator|->
name|is_sim
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to register bus"
argument_list|)
expr_stmt|;
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|is
operator|->
name|is_path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|is
operator|->
name|is_sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to create path"
argument_list|)
expr_stmt|;
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_daemon_fail
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_daemon_fail
modifier|*
name|fail
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_id
operator|==
name|fail
operator|->
name|idf_session_id
condition|)
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"iscsid(8) failed: %s"
argument_list|,
name|fail
operator|->
name|idf_reason
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|is
operator|->
name|is_reason
argument_list|,
name|fail
operator|->
name|idf_reason
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|is_reason
argument_list|)
argument_list|)
expr_stmt|;
comment|//is->is_waiting_for_iscsid = false;
comment|//is->is_login_phase = true;
comment|//iscsi_session_reconnect(is);
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
end_ifdef

begin_function
specifier|static
name|int
name|iscsi_ioctl_daemon_connect
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_daemon_connect
modifier|*
name|idc
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|from_sa
decl_stmt|,
modifier|*
name|to_sa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_id
operator|==
name|idc
operator|->
name|idc_session_id
condition|)
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|idc
operator|->
name|idc_from_addrlen
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|getsockaddr
argument_list|(
operator|&
name|from_sa
argument_list|,
operator|(
name|void
operator|*
operator|)
name|idc
operator|->
name|idc_from_addr
argument_list|,
name|idc
operator|->
name|idc_from_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"getsockaddr failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
name|from_sa
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|getsockaddr
argument_list|(
operator|&
name|to_sa
argument_list|,
operator|(
name|void
operator|*
operator|)
name|idc
operator|->
name|idc_to_addr
argument_list|,
name|idc
operator|->
name|idc_to_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"getsockaddr failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|from_sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_waiting_for_iscsid
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_login_phase
operator|=
name|true
expr_stmt|;
name|is
operator|->
name|is_timeout
operator|=
literal|0
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|error
operator|=
name|icl_conn_connect
argument_list|(
name|is
operator|->
name|is_conn
argument_list|,
name|idc
operator|->
name|idc_iser
argument_list|,
name|idc
operator|->
name|idc_domain
argument_list|,
name|idc
operator|->
name|idc_socktype
argument_list|,
name|idc
operator|->
name|idc_protocol
argument_list|,
name|from_sa
argument_list|,
name|to_sa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|from_sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to_sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
comment|/* 	 * Digests are always disabled during login phase. 	 */
name|is
operator|->
name|is_conn
operator|->
name|ic_header_crc32c
operator|=
name|false
expr_stmt|;
name|is
operator|->
name|is_conn
operator|->
name|ic_data_crc32c
operator|=
name|false
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_daemon_send
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_daemon_send
modifier|*
name|ids
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|ip
decl_stmt|;
name|size_t
name|datalen
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_id
operator|==
name|ids
operator|->
name|ids_session_id
condition|)
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_login_phase
operator|==
name|false
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|is
operator|->
name|is_terminating
operator|||
name|is
operator|->
name|is_reconnecting
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|datalen
operator|=
name|ids
operator|->
name|ids_data_segment_len
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|ISCSI_MAX_DATA_SEGMENT_LENGTH
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
name|datalen
argument_list|,
name|M_ISCSI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ids
operator|->
name|ids_data_segment
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ip
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|is
operator|->
name|is_conn
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|ip_bhs
argument_list|,
name|ids
operator|->
name|ids_bhs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
operator|->
name|ip_bhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|icl_pdu_append_data
argument_list|(
name|ip
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"icl_pdu_append_data(..., M_WAITOK) failed"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
block|}
name|icl_pdu_queue
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_daemon_receive
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_daemon_receive
modifier|*
name|idr
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|ip
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_id
operator|==
name|idr
operator|->
name|idr_session_id
condition|)
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_login_phase
operator|==
name|false
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
while|while
condition|(
name|is
operator|->
name|is_login_pdu
operator|==
name|NULL
operator|&&
name|is
operator|->
name|is_terminating
operator|==
name|false
operator|&&
name|is
operator|->
name|is_reconnecting
operator|==
name|false
condition|)
name|cv_wait
argument_list|(
operator|&
name|is
operator|->
name|is_login_cv
argument_list|,
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_terminating
operator|||
name|is
operator|->
name|is_reconnecting
condition|)
block|{
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ip
operator|=
name|is
operator|->
name|is_login_pdu
expr_stmt|;
name|is
operator|->
name|is_login_pdu
operator|=
name|NULL
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_data_len
operator|>
name|idr
operator|->
name|idr_data_segment_len
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|copyout
argument_list|(
name|ip
operator|->
name|ip_bhs
argument_list|,
name|idr
operator|->
name|idr_bhs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
operator|->
name|ip_bhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_data_len
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
name|ip
operator|->
name|ip_data_len
argument_list|,
name|M_ISCSI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|icl_pdu_get_data
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|ip
operator|->
name|ip_data_len
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|data
argument_list|,
name|idr
operator|->
name|idr_data_segment
argument_list|,
name|ip
operator|->
name|ip_data_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
block|}
name|icl_pdu_free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICL_KERNEL_PROXY */
end_comment

begin_function
specifier|static
name|void
name|iscsi_sanitize_session_conf
parameter_list|(
name|struct
name|iscsi_session_conf
modifier|*
name|isc
parameter_list|)
block|{
comment|/* 	 * Just make sure all the fields are null-terminated. 	 * 	 * XXX: This is not particularly secure.  We should 	 * 	create our own conf and then copy in relevant 	 * 	fields. 	 */
name|isc
operator|->
name|isc_initiator
index|[
name|ISCSI_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_initiator_addr
index|[
name|ISCSI_ADDR_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_initiator_alias
index|[
name|ISCSI_ALIAS_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_target
index|[
name|ISCSI_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_target_addr
index|[
name|ISCSI_ADDR_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_user
index|[
name|ISCSI_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_secret
index|[
name|ISCSI_SECRET_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_mutual_user
index|[
name|ISCSI_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc
operator|->
name|isc_mutual_secret
index|[
name|ISCSI_SECRET_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|iscsi_valid_session_conf
parameter_list|(
specifier|const
name|struct
name|iscsi_session_conf
modifier|*
name|isc
parameter_list|)
block|{
if|if
condition|(
name|isc
operator|->
name|isc_initiator
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ISCSI_DEBUG
argument_list|(
literal|"empty isc_initiator"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|isc
operator|->
name|isc_target_addr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ISCSI_DEBUG
argument_list|(
literal|"empty isc_target_addr"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|isc
operator|->
name|isc_discovery
operator|!=
literal|0
operator|&&
name|isc
operator|->
name|isc_target
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|ISCSI_DEBUG
argument_list|(
literal|"non-empty isc_target for discovery session"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|isc
operator|->
name|isc_discovery
operator|==
literal|0
operator|&&
name|isc
operator|->
name|isc_target
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|ISCSI_DEBUG
argument_list|(
literal|"empty isc_target for non-discovery session"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_session_add
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_session_add
modifier|*
name|isa
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
specifier|const
name|struct
name|iscsi_session
modifier|*
name|is2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|iscsi_sanitize_session_conf
argument_list|(
operator|&
name|isa
operator|->
name|isa_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscsi_valid_session_conf
argument_list|(
operator|&
name|isa
operator|->
name|isa_conf
argument_list|)
operator|==
name|false
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|is
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|is
argument_list|)
argument_list|,
name|M_ISCSI
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|is
operator|->
name|is_conf
argument_list|,
operator|&
name|isa
operator|->
name|isa_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|is_conf
argument_list|)
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent duplicates. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|is2
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
operator|!
operator|!
name|is
operator|->
name|is_conf
operator|.
name|isc_discovery
operator|!=
operator|!
operator|!
name|is2
operator|->
name|is_conf
operator|.
name|isc_discovery
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_conf
operator|.
name|isc_target_addr
argument_list|,
name|is2
operator|->
name|is_conf
operator|.
name|isc_target_addr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|is
operator|->
name|is_conf
operator|.
name|isc_discovery
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|is
operator|->
name|is_conf
operator|.
name|isc_target
argument_list|,
name|is2
operator|->
name|is_conf
operator|.
name|isc_target
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|is
operator|->
name|is_conn
operator|=
name|icl_conn_new
argument_list|(
literal|"iscsi"
argument_list|,
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_conn
operator|->
name|ic_receive
operator|=
name|iscsi_receive_callback
expr_stmt|;
name|is
operator|->
name|is_conn
operator|->
name|ic_error
operator|=
name|iscsi_error_callback
expr_stmt|;
name|is
operator|->
name|is_conn
operator|->
name|ic_prv0
operator|=
name|is
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|is
operator|->
name|is_outstanding
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|is
operator|->
name|is_postponed
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|,
literal|"iscsi_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|is
operator|->
name|is_maintenance_cv
argument_list|,
literal|"iscsi_mt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
name|cv_init
argument_list|(
operator|&
name|is
operator|->
name|is_login_cv
argument_list|,
literal|"iscsi_login"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|is_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_last_session_id
operator|++
expr_stmt|;
name|is
operator|->
name|is_id
operator|=
name|sc
operator|->
name|sc_last_session_id
expr_stmt|;
name|is
operator|->
name|is_isid
index|[
literal|0
index|]
operator|=
literal|0x80
expr_stmt|;
comment|/* RFC 3720, 10.12.5: 10b, "Random" ISID. */
name|arc4rand
argument_list|(
operator|&
name|is
operator|->
name|is_isid
index|[
literal|1
index|]
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_tsih
operator|=
literal|0
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|is
operator|->
name|is_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|is
operator|->
name|is_callout
argument_list|,
literal|1
operator|*
name|hz
argument_list|,
name|iscsi_callout
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|,
name|is
argument_list|,
name|is_next
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_add
argument_list|(
name|iscsi_maintenance_thread
argument_list|,
name|is
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"iscsimt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"kthread_add(9) failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Trigger immediate reconnection. 	 */
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_waiting_for_iscsid
operator|=
name|true
expr_stmt|;
name|strlcpy
argument_list|(
name|is
operator|->
name|is_reason
argument_list|,
literal|"Waiting for iscsid(8)"
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|is_reason
argument_list|)
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|iscsi_session_conf_matches
parameter_list|(
name|unsigned
name|int
name|id1
parameter_list|,
specifier|const
name|struct
name|iscsi_session_conf
modifier|*
name|c1
parameter_list|,
name|unsigned
name|int
name|id2
parameter_list|,
specifier|const
name|struct
name|iscsi_session_conf
modifier|*
name|c2
parameter_list|)
block|{
if|if
condition|(
name|id2
operator|!=
literal|0
operator|&&
name|id2
operator|!=
name|id1
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|c2
operator|->
name|isc_target
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|isc_target
argument_list|,
name|c2
operator|->
name|isc_target
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|c2
operator|->
name|isc_target_addr
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|isc_target_addr
argument_list|,
name|c2
operator|->
name|isc_target_addr
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_session_remove
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_session_remove
modifier|*
name|isr
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|iscsi_sanitize_session_conf
argument_list|(
operator|&
name|isr
operator|->
name|isr_conf
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscsi_session_conf_matches
argument_list|(
name|is
operator|->
name|is_id
argument_list|,
operator|&
name|is
operator|->
name|is_conf
argument_list|,
name|isr
operator|->
name|isr_session_id
argument_list|,
operator|&
name|isr
operator|->
name|isr_conf
argument_list|)
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
name|iscsi_session_logout
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_session_list
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_session_list
modifier|*
name|isl
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|struct
name|iscsi_session_state
name|iss
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|i
operator|>=
name|isl
operator|->
name|isl_nentries
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|iss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iss
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|iss
operator|.
name|iss_conf
argument_list|,
operator|&
name|is
operator|->
name|is_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|iss
operator|.
name|iss_conf
argument_list|)
argument_list|)
expr_stmt|;
name|iss
operator|.
name|iss_id
operator|=
name|is
operator|->
name|is_id
expr_stmt|;
name|strlcpy
argument_list|(
name|iss
operator|.
name|iss_target_alias
argument_list|,
name|is
operator|->
name|is_target_alias
argument_list|,
sizeof|sizeof
argument_list|(
name|iss
operator|.
name|iss_target_alias
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|iss
operator|.
name|iss_reason
argument_list|,
name|is
operator|->
name|is_reason
argument_list|,
sizeof|sizeof
argument_list|(
name|iss
operator|.
name|iss_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_conn
operator|->
name|ic_header_crc32c
condition|)
name|iss
operator|.
name|iss_header_digest
operator|=
name|ISCSI_DIGEST_CRC32C
expr_stmt|;
else|else
name|iss
operator|.
name|iss_header_digest
operator|=
name|ISCSI_DIGEST_NONE
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_conn
operator|->
name|ic_data_crc32c
condition|)
name|iss
operator|.
name|iss_data_digest
operator|=
name|ISCSI_DIGEST_CRC32C
expr_stmt|;
else|else
name|iss
operator|.
name|iss_data_digest
operator|=
name|ISCSI_DIGEST_NONE
expr_stmt|;
name|iss
operator|.
name|iss_max_data_segment_length
operator|=
name|is
operator|->
name|is_max_data_segment_length
expr_stmt|;
name|iss
operator|.
name|iss_immediate_data
operator|=
name|is
operator|->
name|is_immediate_data
expr_stmt|;
name|iss
operator|.
name|iss_connected
operator|=
name|is
operator|->
name|is_connected
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|iss
argument_list|,
name|isl
operator|->
name|isl_pstates
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|iss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|isl
operator|->
name|isl_nentries
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl_session_modify
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iscsi_session_modify
modifier|*
name|ism
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|iscsi_sanitize_session_conf
argument_list|(
operator|&
name|ism
operator|->
name|ism_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscsi_valid_session_conf
argument_list|(
operator|&
name|ism
operator|->
name|ism_conf
argument_list|)
operator|==
name|false
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
block|{
name|ISCSI_SESSION_LOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_id
operator|==
name|ism
operator|->
name|ism_session_id
condition|)
break|break;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|is
operator|->
name|is_conf
argument_list|,
operator|&
name|ism
operator|->
name|ism_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|is_conf
argument_list|)
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_UNLOCK
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|iscsi_session_reconnect
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|iscsi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ISCSIDWAIT
case|:
return|return
operator|(
name|iscsi_ioctl_daemon_wait
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_daemon_request
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|ISCSIDHANDOFF
case|:
return|return
operator|(
name|iscsi_ioctl_daemon_handoff
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_daemon_handoff
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|ISCSIDFAIL
case|:
return|return
operator|(
name|iscsi_ioctl_daemon_fail
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_daemon_fail
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
case|case
name|ISCSIDCONNECT
case|:
return|return
operator|(
name|iscsi_ioctl_daemon_connect
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_daemon_connect
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|ISCSIDSEND
case|:
return|return
operator|(
name|iscsi_ioctl_daemon_send
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_daemon_send
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|ISCSIDRECEIVE
case|:
return|return
operator|(
name|iscsi_ioctl_daemon_receive
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_daemon_receive
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* ICL_KERNEL_PROXY */
case|case
name|ISCSISADD
case|:
return|return
operator|(
name|iscsi_ioctl_session_add
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_session_add
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|ISCSISREMOVE
case|:
return|return
operator|(
name|iscsi_ioctl_session_remove
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_session_remove
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|ISCSISLIST
case|:
return|return
operator|(
name|iscsi_ioctl_session_list
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_session_list
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|ISCSISMODIFY
case|:
return|return
operator|(
name|iscsi_ioctl_session_modify
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|iscsi_session_modify
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|iscsi_outstanding
modifier|*
name|iscsi_outstanding_find
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|uint32_t
name|initiator_task_tag
parameter_list|)
block|{
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|io
argument_list|,
argument|&is->is_outstanding
argument_list|,
argument|io_next
argument_list|)
block|{
if|if
condition|(
name|io
operator|->
name|io_initiator_task_tag
operator|==
name|initiator_task_tag
condition|)
return|return
operator|(
name|io
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|iscsi_outstanding
modifier|*
name|iscsi_outstanding_find_ccb
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|io
argument_list|,
argument|&is->is_outstanding
argument_list|,
argument|io_next
argument_list|)
block|{
if|if
condition|(
name|io
operator|->
name|io_ccb
operator|==
name|ccb
condition|)
return|return
operator|(
name|io
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|iscsi_outstanding
modifier|*
name|iscsi_outstanding_add
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|uint32_t
name|initiator_task_tag
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|iscsi_outstanding_find
argument_list|(
name|is
argument_list|,
name|initiator_task_tag
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"initiator_task_tag 0x%x already added"
operator|,
name|initiator_task_tag
operator|)
argument_list|)
expr_stmt|;
name|io
operator|=
name|uma_zalloc
argument_list|(
name|iscsi_outstanding_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|ISCSI_SESSION_WARN
argument_list|(
name|is
argument_list|,
literal|"failed to allocate %zd bytes"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|io
operator|->
name|io_initiator_task_tag
operator|=
name|initiator_task_tag
expr_stmt|;
name|io
operator|->
name|io_ccb
operator|=
name|ccb
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|is
operator|->
name|is_outstanding
argument_list|,
name|io
argument_list|,
name|io_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|io
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_outstanding_remove
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|struct
name|iscsi_outstanding
modifier|*
name|io
parameter_list|)
block|{
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|is
operator|->
name|is_outstanding
argument_list|,
name|io
argument_list|,
name|io_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|iscsi_outstanding_zone
argument_list|,
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_action_abort
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|iscsi_bhs_task_management_request
modifier|*
name|bhstmr
decl_stmt|;
name|struct
name|ccb_abort
modifier|*
name|cab
init|=
operator|&
name|ccb
operator|->
name|cab
decl_stmt|;
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|,
modifier|*
name|aio
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|KASSERT(is->is_login_phase == false, ("%s called during Login Phase", __func__));
else|#
directive|else
if|if
condition|(
name|is
operator|->
name|is_login_phase
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|aio
operator|=
name|iscsi_outstanding_find_ccb
argument_list|(
name|is
argument_list|,
name|cab
operator|->
name|abort_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|request
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|is
operator|->
name|is_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhstmr
operator|=
operator|(
expr|struct
name|iscsi_bhs_task_management_request
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|bhstmr
operator|->
name|bhstmr_opcode
operator|=
name|ISCSI_BHS_OPCODE_TASK_REQUEST
expr_stmt|;
name|bhstmr
operator|->
name|bhstmr_function
operator|=
literal|0x80
operator||
name|BHSTMR_FUNCTION_ABORT_TASK
expr_stmt|;
name|bhstmr
operator|->
name|bhstmr_lun
operator|=
name|htobe64
argument_list|(
name|CAM_EXTLUN_BYTE_SWIZZLE
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
argument_list|)
expr_stmt|;
name|bhstmr
operator|->
name|bhstmr_initiator_task_tag
operator|=
name|is
operator|->
name|is_initiator_task_tag
expr_stmt|;
name|is
operator|->
name|is_initiator_task_tag
operator|++
expr_stmt|;
name|bhstmr
operator|->
name|bhstmr_referenced_task_tag
operator|=
name|aio
operator|->
name|io_initiator_task_tag
expr_stmt|;
name|io
operator|=
name|iscsi_outstanding_add
argument_list|(
name|is
argument_list|,
name|bhstmr
operator|->
name|bhstmr_initiator_task_tag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|->
name|io_datasn
operator|=
name|aio
operator|->
name|io_initiator_task_tag
expr_stmt|;
name|iscsi_pdu_queue_locked
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_action_scsiio
parameter_list|(
name|struct
name|iscsi_session
modifier|*
name|is
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|iscsi_bhs_scsi_command
modifier|*
name|bhssc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|iscsi_outstanding
modifier|*
name|io
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|KASSERT(is->is_login_phase == false, ("%s called during Login Phase", __func__));
else|#
directive|else
if|if
condition|(
name|is
operator|->
name|is_login_phase
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"called during login phase"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|request
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|is
operator|->
name|is_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|bhssc
operator|=
operator|(
expr|struct
name|iscsi_bhs_scsi_command
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|bhssc
operator|->
name|bhssc_opcode
operator|=
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
expr_stmt|;
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_F
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_IN
case|:
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_R
expr_stmt|;
break|break;
case|case
name|CAM_DIR_OUT
case|:
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_W
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|csio
operator|->
name|tag_action
condition|)
block|{
case|case
name|MSG_HEAD_OF_Q_TAG
case|:
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_ATTR_HOQ
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_Q_TAG
case|:
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_ATTR_ORDERED
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_ATTR_ACA
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_Q_TAG
case|:
default|default:
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_ATTR_SIMPLE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|bhssc
operator|->
name|bhssc_flags
operator||=
name|BHSSC_FLAGS_ATTR_UNTAGGED
expr_stmt|;
name|bhssc
operator|->
name|bhssc_lun
operator|=
name|htobe64
argument_list|(
name|CAM_EXTLUN_BYTE_SWIZZLE
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
argument_list|)
expr_stmt|;
name|bhssc
operator|->
name|bhssc_initiator_task_tag
operator|=
name|is
operator|->
name|is_initiator_task_tag
expr_stmt|;
name|is
operator|->
name|is_initiator_task_tag
operator|++
expr_stmt|;
name|bhssc
operator|->
name|bhssc_expected_data_transfer_length
operator|=
name|htonl
argument_list|(
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|csio
operator|->
name|cdb_len
operator|<=
sizeof|sizeof
argument_list|(
name|bhssc
operator|->
name|bhssc_cdb
argument_list|)
argument_list|,
operator|(
literal|"unsupported CDB size %zd"
operator|,
operator|(
name|size_t
operator|)
name|csio
operator|->
name|cdb_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|memcpy
argument_list|(
operator|&
name|bhssc
operator|->
name|bhssc_cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|bhssc
operator|->
name|bhssc_cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|io
operator|=
name|iscsi_outstanding_add
argument_list|(
name|is
argument_list|,
name|bhssc
operator|->
name|bhssc_initiator_task_tag
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is
operator|->
name|is_immediate_data
operator|&&
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
comment|//ISCSI_SESSION_DEBUG(is, "adding %zd of immediate data", len);
if|if
condition|(
name|len
operator|>
name|is
operator|->
name|is_first_burst_length
condition|)
block|{
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"len %zd -> %zd"
argument_list|,
name|len
argument_list|,
name|is
operator|->
name|is_first_burst_length
argument_list|)
expr_stmt|;
name|len
operator|=
name|is
operator|->
name|is_first_burst_length
expr_stmt|;
block|}
name|error
operator|=
name|icl_pdu_append_data
argument_list|(
name|request
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_DEBUG
argument_list|(
name|is
argument_list|,
literal|"freezing devq"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|iscsi_pdu_queue_locked
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_terminating
operator|||
operator|(
name|is
operator|->
name|is_connected
operator|==
name|false
operator|&&
name|fail_on_disconnection
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_EXTLUNS
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Note that the variable below is only relevant for targets 		 * that don't claim compliance with anything above SPC2, which 		 * means they don't support REPORT_LUNS. 		 */
name|cpi
operator|->
name|max_lun
operator|=
literal|255
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
operator|~
literal|0
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"iSCSI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
comment|/* XXX */
name|cpi
operator|->
name|transport
operator|=
name|XPORT_ISCSI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC3
expr_stmt|;
name|cpi
operator|->
name|maxio
operator|=
name|MAXPHYS
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC3
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_ISCSI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* 	 * XXX: What's the point? 	 */
block|case XPT_RESET_BUS: 	case XPT_TERM_IO: 		ISCSI_SESSION_DEBUG(is, "faking success for reset, abort, or term_io"); 		ccb->ccb_h.status = CAM_REQ_CMP; 		break;
endif|#
directive|endif
case|case
name|XPT_ABORT
case|:
name|iscsi_action_abort
argument_list|(
name|is
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_SCSI_IO
case|:
name|iscsi_action_scsiio
argument_list|(
name|is
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
default|default:
if|#
directive|if
literal|0
block|ISCSI_SESSION_DEBUG(is, "got unsupported code 0x%x", ccb->ccb_h.func_code);
endif|#
directive|endif
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: you're not supposed to be here"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iscsi_shutdown
parameter_list|(
name|struct
name|iscsi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|;
name|ISCSI_DEBUG
argument_list|(
literal|"removing all sessions due to shutdown"
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|)
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_ISCSI
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|"iscsi"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|,
literal|"iscsi_cv"
argument_list|)
expr_stmt|;
name|iscsi_outstanding_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"iscsi_outstanding"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iscsi_outstanding
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|make_dev_p
argument_list|(
name|MAKEDEV_CHECKNAME
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdev
argument_list|,
operator|&
name|iscsi_cdevsw
argument_list|,
name|NULL
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"iscsi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ISCSI_WARN
argument_list|(
literal|"failed to create device node, error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|sc_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* 	 * Note that this needs to get run before dashutdown().  Otherwise, 	 * when rebooting with iSCSI session with outstanding requests, 	 * but disconnected, dashutdown() will hang on cam_periph_runccb(). 	 */
name|sc
operator|->
name|sc_shutdown_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|iscsi_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|iscsi_session
modifier|*
name|is
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdev
operator|!=
name|NULL
condition|)
block|{
name|ISCSI_DEBUG
argument_list|(
literal|"removing device node"
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|sc_cdev
argument_list|)
expr_stmt|;
name|ISCSI_DEBUG
argument_list|(
literal|"device node removed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_shutdown_eh
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|sc
operator|->
name|sc_shutdown_eh
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|is
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|is_next
argument_list|,
argument|tmp
argument_list|)
name|iscsi_session_terminate
argument_list|(
name|is
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|)
condition|)
block|{
name|ISCSI_DEBUG
argument_list|(
literal|"waiting for sessions to terminate"
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
name|ISCSI_DEBUG
argument_list|(
literal|"all sessions terminated"
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|iscsi_outstanding_zone
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_ISCSI
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_quiesce
parameter_list|(
name|void
parameter_list|)
block|{
name|sx_slock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|)
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iscsi_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|iscsi_load
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|iscsi_unload
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
name|error
operator|=
name|iscsi_quiesce
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|moduledata_t
name|iscsi_data
init|=
block|{
literal|"iscsi"
block|,
name|iscsi_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|iscsi
argument_list|,
name|iscsi_data
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iscsi
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iscsi
argument_list|,
name|icl
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

