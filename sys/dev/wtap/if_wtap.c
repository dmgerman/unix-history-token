begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Monthadar Al Jaberi, TerraNet AB  * All rights reserved.  *  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"if_wtapvar.h"
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* uio struct */
end_comment

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|"if_medium.h"
end_include

begin_comment
comment|/*  * This _requires_ vimage to be useful.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VIMAGE
end_ifndef

begin_error
error|#
directive|error
error|if_wtap requires VIMAGE.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_comment
comment|/* device for IOCTL and read/write for debuggin purposes */
end_comment

begin_comment
comment|/* Function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|wtap_node_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|wtap_node_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|wtap_node_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|wtap_node_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|wtap_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|wtap_node_open
block|,
operator|.
name|d_close
operator|=
name|wtap_node_close
block|,
operator|.
name|d_write
operator|=
name|wtap_node_write
block|,
operator|.
name|d_ioctl
operator|=
name|wtap_node_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"wtapnode"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|wtap_node_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uprintf
argument_list|(
literal|"Opened device \"echo\" successfully.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_node_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|uprintf
argument_list|(
literal|"Closing device \"echo.\"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_node_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|wtap_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|buf_len
decl_stmt|;
name|uprintf
argument_list|(
literal|"write device %s \"echo.\"\n"
argument_list|,
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|buf_len
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|err
operator|=
name|copyin
argument_list|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"Write failed: bad address!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|buf_len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|curthread
argument_list|)
argument_list|)
expr_stmt|;
name|IFNET_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&V_ifnet
argument_list|,
argument|if_link
argument_list|)
block|{
name|printf
argument_list|(
literal|"ifp->if_xname = %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"found match, correspoding wtap = %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|wtap_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|printf
argument_list|(
literal|"wtap id = %d\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|)
expr_stmt|;
name|wtap_inject
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|IFNET_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wtap_node_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|DWTAP_PRINTF
argument_list|(
literal|"Unkown WTAP IOCTL\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|wtap_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|wtap_medium_enqueue
parameter_list|(
name|struct
name|wtap_vap
modifier|*
name|avp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|medium_transmit
argument_list|(
name|avp
operator|->
name|av_md
argument_list|,
name|avp
operator|->
name|id
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|int
name|error
init|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Intercept management frames to collect beacon rssi data  * and to do ibss merges.  */
end_comment

begin_function
specifier|static
name|void
name|wtap_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
if|#
directive|if
literal|0
block|DWTAP_PRINTF("[%d] %s\n", myath_id(ni), __func__);
endif|#
directive|endif
name|WTAP_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_recv_mgmt
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|subtype
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
init|=
operator|&
name|WTAP_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_boff
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and setup an initial beacon frame.  */
end_comment

begin_function
specifier|static
name|int
name|wtap_beacon_alloc
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|wtap_vap
modifier|*
name|avp
init|=
name|WTAP_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"[%s] %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the beacon data buffer must be 32-bit aligned; 	 * we assume the mbuf routines will return us something 	 * with this alignment (perhaps should assert). 	 */
name|avp
operator|->
name|beacon
operator|=
name|ieee80211_beacon_alloc
argument_list|(
name|ni
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|avp
operator|->
name|beacon
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot get mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|callout_init
argument_list|(
operator|&
name|avp
operator|->
name|av_swba
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|avp
operator|->
name|bf_node
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_beacon_config
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_beacon_intrp
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wtap_vap
modifier|*
name|avp
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|<
name|IEEE80211_S_RUN
condition|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"Skip beacon, not running, state %d"
argument_list|,
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
return|return ;
block|}
name|DWTAP_PRINTF
argument_list|(
literal|"[%d] beacon intrp\n"
argument_list|,
name|avp
operator|->
name|id
argument_list|)
expr_stmt|;
comment|//burst mode
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|m
operator|=
name|m_dup
argument_list|(
name|avp
operator|->
name|beacon
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|avp
operator|->
name|bf_node
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s, need to remap the memory because the beacon frame"
literal|" changed size.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|medium_transmit(avp->av_md, avp->id, m);
endif|#
directive|endif
name|wtap_medium_enqueue
argument_list|(
name|avp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|avp
operator|->
name|av_swba
argument_list|,
name|avp
operator|->
name|av_bcinterval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|wtap_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|wtap_vap
modifier|*
name|avp
init|=
name|WTAP_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
comment|/* 	 * Invoke the parent method to do net80211 work. 	 */
name|error
operator|=
name|avp
operator|->
name|av_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* NB: collect bss node again, it may have changed */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_MBSS
case|:
name|error
operator|=
name|wtap_beacon_alloc
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|wtap_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|avp
operator|->
name|av_swba
argument_list|,
name|avp
operator|->
name|av_bcinterval
argument_list|,
name|wtap_beacon_intrp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|avp
operator|->
name|av_swba
argument_list|)
expr_stmt|;
block|}
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|printf
argument_list|(
literal|"%s: bad\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_bmiss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|wtap_vap
modifier|*
name|avp
init|=
operator|(
expr|struct
name|wtap_vap
operator|*
operator|)
name|vap
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|wtap_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|wtap_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|wtap_vap
modifier|*
name|avp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|avp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wtap_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|avp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|avp
operator|->
name|id
operator|=
name|sc
operator|->
name|id
expr_stmt|;
name|avp
operator|->
name|av_md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|avp
operator|->
name|av_bcinterval
operator|=
name|msecs_to_ticks
argument_list|(
name|BEACON_INTRERVAL
operator|+
literal|100
operator|*
name|sc
operator|->
name|id
argument_list|)
expr_stmt|;
name|vap
operator|=
operator|(
expr|struct
name|ieee80211vap
operator|*
operator|)
name|avp
expr_stmt|;
name|error
operator|=
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|IEEE80211_M_MBSS
argument_list|,
name|flags
operator||
name|IEEE80211_CLONE_NOBEACONS
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|avp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* override various methods */
name|avp
operator|->
name|av_recv_mgmt
operator|=
name|vap
operator|->
name|iv_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_recv_mgmt
operator|=
name|wtap_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_reset
operator|=
name|wtap_reset_vap
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|wtap_beacon_update
expr_stmt|;
name|avp
operator|->
name|av_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|wtap_newstate
expr_stmt|;
name|avp
operator|->
name|av_bmiss
operator|=
name|vap
operator|->
name|iv_bmiss
expr_stmt|;
name|vap
operator|->
name|iv_bmiss
operator|=
name|wtap_bmiss
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|wtap_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|wtap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ic
operator|->
name|ic_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* TODO this is a hack to force it to choose the rate we want */
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txrate
operator|=
literal|130
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|wtap_vap
modifier|*
name|avp
init|=
name|WTAP_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|avp
operator|->
name|av_dev
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|avp
operator|->
name|av_swba
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
expr|struct
name|wtap_vap
operator|*
operator|)
name|vap
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NB: This function is not used.  * I had the problem of the queue  * being empty all the time.  * Maybe I am setting the queue wrong?  */
end_comment

begin_function
specifier|static
name|void
name|wtap_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|icifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wtap_softc
modifier|*
name|sc
init|=
name|icifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"my_start, with id=%u\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|up
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"queue empty, just trying to see "
literal|"if the other queue is empty\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("queue for id=1, %u\n", 		        IFQ_IS_EMPTY(&global_mscs[1]->ifp->if_snd)); 		    printf("queue for id=0, %u\n", 		        IFQ_IS_EMPTY(&global_mscs[0]->ifp->if_snd));
endif|#
directive|endif
break|break;
block|}
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"error dequeueing from ifp->snd\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
comment|/* 		 * Check for fragmentation.  If this frame 		 * has been broken up verify we have enough 		 * buffers to send all the fragments so all 		 * go out or none... 		 */
if|#
directive|if
literal|0
block|STAILQ_INIT(&frags);
endif|#
directive|endif
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FRAG
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dont support frags\n"
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wtap_raw_xmit
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error raw_xmiting\n"
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s\n", __func__); 	uprintf("%s, command %lu\n", __func__, cmd);
endif|#
directive|endif
define|#
directive|define
name|IS_RUNNING
parameter_list|(
name|ifp
parameter_list|)
define|\
value|((ifp->if_flags& IFF_UP)&& (ifp->if_drv_flags& IFF_DRV_RUNNING))
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wtap_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
comment|//printf("%s: %s\n", __func__, "SIOCSIFFLAGS");
if|if
condition|(
name|IS_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"running\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * To avoid rescanning another access point, 			 * do not call ath_init() here.  Instead, 			 * only reflect promisc mode settings. 			 */
comment|//ath_mode_init(sc);
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"up\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|up
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * Beware of being called during attach/detach 			 * to reset promiscuous mode.  In that case we 			 * will still be marked UP but not RUNNING. 			 * However trying to re-init the interface 			 * is the wrong thing to do as we've already 			 * torn down much of our state.  There's 			 * probably a better way to deal with this. 			 */
comment|//if (!sc->sc_invalid)
comment|//	ath_init(sc);	/* XXX lose error */
endif|#
directive|endif
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"stoping\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ath_stop_locked(ifp);
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX must wakeup in places like ath_vap_delete */
block|if (!sc->sc_invalid) 				ath_hal_setpower(sc->sc_ah, HAL_PM_FULL_SLEEP);
endif|#
directive|endif
endif|#
directive|endif
block|}
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s: %s\n", __func__, "SIOCGIFMEDIA|SIOCSIFMEDIA");
endif|#
directive|endif
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s: %s\n", __func__, "SIOCGIFADDR");
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DWTAP_PRINTF
argument_list|(
literal|"%s: %s [%lu]\n"
argument_list|,
name|__func__
argument_list|,
literal|"EINVAL"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|IS_RUNNING
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s\n", __func__);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s\n", __func__);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s\n", __func__);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s, %p\n", __func__, m);
endif|#
directive|endif
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|wtap_vap
modifier|*
name|avp
init|=
name|WTAP_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|wtap_medium_enqueue
argument_list|(
name|avp
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|wtap_inject
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|wtap_buf
modifier|*
name|bf
init|=
operator|(
expr|struct
name|wtap_buf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wtap_buf
argument_list|)
argument_list|,
name|M_WTAP_RXBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|bf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"could not allocated a new wtap_buf\n"
operator|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wtap_rx_deliver
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|type
decl_stmt|;
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s\n", __func__);
endif|#
directive|endif
name|DWTAP_PRINTF
argument_list|(
literal|"[%d] receiving m=%p\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no mbuf!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	  * Locate the node for sender, track state, and then 	  * pass the (referenced) node up to the 802.11 layer 	  * for its use. 	  */
name|ni
operator|=
name|ieee80211_find_rxnode_withkey
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sending station is known, dispatch directly. 		 */
name|type
operator|=
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|1
operator|<<
literal|7
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
literal|1
operator|<<
literal|7
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_rx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|wtap_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|wtap_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|wtap_buf
modifier|*
name|bf
decl_stmt|;
if|#
directive|if
literal|0
block|DWTAP_PRINTF("%s\n", __func__);
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"wtap_buf is NULL\n"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|m
expr_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"[%d] receiving m=%p\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|,
name|bf
operator|->
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no mbuf!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bf
argument_list|,
name|M_WTAP_RXBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ieee80211_dump_pkt(ic, mtod(m, caddr_t), 0,0,0);
endif|#
directive|endif
comment|/* 		 * Locate the node for sender, track state, and then 		 * pass the (referenced) node up to the 802.11 layer 		 * for its use. 		 */
name|ni
operator|=
name|ieee80211_find_rxnode_withkey
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Sending station is known, dispatch directly. 			 */
if|#
directive|if
literal|0
block|ieee80211_radiotap_rx(ni->ni_vap, m);
endif|#
directive|endif
name|type
operator|=
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|1
operator|<<
literal|7
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|ieee80211_radiotap_rx_all(ic, m);
endif|#
directive|endif
name|type
operator|=
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
literal|1
operator|<<
literal|7
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* The mbufs are freed by the Net80211 stack */
name|free
argument_list|(
name|bf
argument_list|,
name|M_WTAP_RXBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update WME parameters.  */
end_comment

begin_function
specifier|static
name|int
name|wtap_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtap_if_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|wtap_vap
modifier|*
name|avp
init|=
name|WTAP_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"m->m_pkthdr.rcvif is NULL we cant radiotap_tx\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|wtap_medium_enqueue
argument_list|(
name|avp
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|wtap_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ni
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txrate
operator|=
literal|130
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wtap_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|wtap_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int32_t
name|wtap_attach
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|char
name|wtap_name
index|[]
init|=
block|{
literal|'w'
block|,
literal|'T'
block|,
literal|'a'
block|,
literal|'p'
block|,
name|sc
operator|->
name|id
block|,
literal|'_'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|'s'
block|,
literal|'k'
block|,
literal|'q'
block|,
literal|'\0'
block|}
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"wtap"
argument_list|,
name|sc
operator|->
name|id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|=
name|ifp
expr_stmt|;
name|sc
operator|->
name|up
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
name|wtap_name
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_SOFT
argument_list|,
literal|"%s taskQ"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|,
literal|0
argument_list|,
name|wtap_rx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wtap_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wtap_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wtap_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_DS
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_MBSS
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_MBSS
expr_stmt|;
name|ic
operator|->
name|ic_max_keyix
operator|=
literal|128
expr_stmt|;
comment|/* A value read from Atheros ATH_KEYMAX */
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
operator|=
name|SKU_ETSI
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
operator|=
name|CTRY_SWEDEN
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
operator|=
literal|1
expr_stmt|;
comment|/* Indoors */
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|1
index|]
operator|=
literal|'E'
expr_stmt|;
name|ic
operator|->
name|ic_nchans
operator|=
literal|1
expr_stmt|;
name|ic
operator|->
name|ic_channels
index|[
literal|0
index|]
operator|.
name|ic_flags
operator|=
name|IEEE80211_CHAN_B
expr_stmt|;
name|ic
operator|->
name|ic_channels
index|[
literal|0
index|]
operator|.
name|ic_freq
operator|=
literal|2412
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* new prototype hook-ups */
block|msc->if_input = ifp->if_input; 	ifp->if_input = myath_if_input; 	msc->if_output = ifp->if_output; 	ifp->if_output = myath_if_output;
endif|#
directive|endif
name|sc
operator|->
name|if_transmit
operator|=
name|ifp
operator|->
name|if_transmit
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|wtap_if_transmit
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_newassoc
operator|=
name|wtap_newassoc
expr_stmt|;
if|#
directive|if
literal|0
block|ic->ic_updateslot = myath_updateslot;
endif|#
directive|endif
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|wtap_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|wtap_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|wtap_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|wtap_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|wtap_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|wtap_update_promisc
expr_stmt|;
name|sc
operator|->
name|sc_node_alloc
operator|=
name|ic
operator|->
name|ic_node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|wtap_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_node_free
operator|=
name|ic
operator|->
name|ic_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|wtap_node_free
expr_stmt|;
if|#
directive|if
literal|0
block|ic->ic_node_getsignal = myath_node_getsignal;
endif|#
directive|endif
name|ic
operator|->
name|ic_scan_start
operator|=
name|wtap_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|wtap_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|wtap_set_channel
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
name|WTAP_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
name|WTAP_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
comment|/* Work here, we must find a way to populate the rate table */
if|#
directive|if
literal|0
block|if(ic->ic_rt == NULL){ 		printf("no table for ic_curchan\n"); 		ic->ic_rt = ieee80211_get_ratetable(&ic->ic_channels[0]); 	} 	printf("ic->ic_rt =%p\n", ic->ic_rt); 	printf("rate count %d\n", ic->ic_rt->rateCount);  	uint8_t code = ic->ic_rt->info[0].dot11Rate; 	uint8_t cix = ic->ic_rt->info[0].ctlRateIndex; 	uint8_t ctl_rate = ic->ic_rt->info[cix].dot11Rate; 	printf("code=%d, cix=%d, ctl_rate=%d\n", code, cix, ctl_rate);  	uint8_t rix0 = ic->ic_rt->rateCodeToIndex[130]; 	uint8_t rix1 = ic->ic_rt->rateCodeToIndex[132]; 	uint8_t rix2 = ic->ic_rt->rateCodeToIndex[139]; 	uint8_t rix3 = ic->ic_rt->rateCodeToIndex[150]; 	printf("rix0 %u,rix1 %u,rix2 %u,rix3 %u\n", rix0,rix1,rix2,rix3); 	printf("lpAckDuration=%u\n", ic->ic_rt->info[0].lpAckDuration); 	printf("rate=%d\n", ic->ic_rt->info[0].rateKbps);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int32_t
name|wtap_detach
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_ageq_drain
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|wtap_resume
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wtap_suspend
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wtap_shutdown
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wtap_intr
parameter_list|(
name|struct
name|wtap_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DWTAP_PRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

