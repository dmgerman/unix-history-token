begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2015, Mellanox Technologies, Ltd.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS `AS IS' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<linux/kref.h>
end_include

begin_include
include|#
directive|include
file|<linux/random.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_umem.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_umem_odp.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_verbs.h>
end_include

begin_include
include|#
directive|include
file|"mlx5_ib.h"
end_include

begin_enum
enum|enum
block|{
name|MAX_PENDING_REG_MR
init|=
literal|8
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|MLX5_UMR_ALIGN
value|2048
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
end_ifdef

begin_function_decl
specifier|static
name|__be64
name|mlx5_ib_update_mtt_emergency_buffer
index|[
name|MLX5_UMR_MTT_MIN_CHUNK_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|__be64
argument_list|)
index|]
name|__aligned
parameter_list|(
name|MLX5_UMR_ALIGN
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|DEFINE_MUTEX
argument_list|(
name|mlx5_ib_update_mtt_emergency_buffer_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|clean_mr
parameter_list|(
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|destroy_mkey
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|)
block|{
name|int
name|err
init|=
name|mlx5_core_destroy_mkey
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
operator|&
name|mr
operator|->
name|mmkey
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
comment|/* Wait until all page fault handlers using the mr complete. */
name|synchronize_srcu
argument_list|(
operator|&
name|dev
operator|->
name|mr_srcu
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|order2idx
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|order
parameter_list|)
block|{
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
if|if
condition|(
name|order
operator|<
name|cache
operator|->
name|ent
index|[
literal|0
index|]
operator|.
name|order
condition|)
return|return
literal|0
return|;
else|else
return|return
name|order
operator|-
name|cache
operator|->
name|ent
index|[
literal|0
index|]
operator|.
name|order
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|use_umr_mtt_update
parameter_list|(
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|mr
operator|->
name|order
operator|)
operator|*
name|MLX5_ADAPTER_PAGE_SIZE
operator|>=
name|length
operator|+
operator|(
name|start
operator|&
operator|(
name|MLX5_ADAPTER_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
end_ifdef

begin_function
specifier|static
name|void
name|update_odp_mr
parameter_list|(
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|)
block|{
if|if
condition|(
name|mr
operator|->
name|umem
operator|->
name|odp_data
condition|)
block|{
comment|/* 		 * This barrier prevents the compiler from moving the 		 * setting of umem->odp_data->private to point to our 		 * MR, before reg_umr finished, to ensure that the MR 		 * initialization have finished before starting to 		 * handle invalidations. 		 */
name|smp_wmb
argument_list|()
expr_stmt|;
name|mr
operator|->
name|umem
operator|->
name|odp_data
operator|->
name|private
operator|=
name|mr
expr_stmt|;
comment|/* 		 * Make sure we will see the new 		 * umem->odp_data->private value in the invalidation 		 * routines, before we can get page faults on the 		 * MR. Page faults can happen once we put the MR in 		 * the tree, below this line. Without the barrier, 		 * there can be a fault handling and an invalidation 		 * before umem->odp_data->private == mr is visible to 		 * the invalidation handler. 		 */
name|smp_wmb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|reg_mr_callback
parameter_list|(
name|int
name|status
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
init|=
name|context
decl_stmt|;
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|mr
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|int
name|c
init|=
name|order2idx
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|order
argument_list|)
decl_stmt|;
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
init|=
operator|&
name|cache
operator|->
name|ent
index|[
name|c
index|]
decl_stmt|;
name|u8
name|key
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|mlx5_mr_table
modifier|*
name|table
init|=
operator|&
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|mr_table
decl_stmt|;
name|int
name|err
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pending
operator|--
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"async reg mr failed. status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
name|dev
operator|->
name|fill_delay
operator|=
literal|1
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|dev
operator|->
name|delay_timer
argument_list|,
name|jiffies
operator|+
name|HZ
argument_list|)
expr_stmt|;
return|return;
block|}
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|mkey_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|key
operator|=
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|mkey_key
operator|++
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|mkey_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mr
operator|->
name|mmkey
operator|.
name|key
operator|=
name|mlx5_idx_to_mkey
argument_list|(
name|MLX5_GET
argument_list|(
name|create_mkey_out
argument_list|,
name|mr
operator|->
name|out
argument_list|,
name|mkey_index
argument_list|)
argument_list|)
operator||
name|key
expr_stmt|;
name|cache
operator|->
name|last_add
operator|=
name|jiffies
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|mr
operator|->
name|list
argument_list|,
operator|&
name|ent
operator|->
name|head
argument_list|)
expr_stmt|;
name|ent
operator|->
name|cur
operator|++
expr_stmt|;
name|ent
operator|->
name|size
operator|++
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|err
operator|=
name|radix_tree_insert
argument_list|(
operator|&
name|table
operator|->
name|tree
argument_list|,
name|mlx5_mkey_to_idx
argument_list|(
name|mr
operator|->
name|mmkey
operator|.
name|key
argument_list|)
argument_list|,
operator|&
name|mr
operator|->
name|mmkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_err
argument_list|(
literal|"Error inserting to mkey tree. 0x%x\n"
argument_list|,
operator|-
name|err
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_keys
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
init|=
operator|&
name|cache
operator|->
name|ent
index|[
name|c
index|]
decl_stmt|;
name|int
name|inlen
init|=
name|MLX5_ST_SZ_BYTES
argument_list|(
name|create_mkey_in
argument_list|)
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|npages
init|=
literal|1
operator|<<
name|ent
operator|->
name|order
decl_stmt|;
name|void
modifier|*
name|mkc
decl_stmt|;
name|u32
modifier|*
name|in
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|in
operator|=
name|kzalloc
argument_list|(
name|inlen
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mkc
operator|=
name|MLX5_ADDR_OF
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|memory_key_mkey_entry
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ent
operator|->
name|pending
operator|>=
name|MAX_PENDING_REG_MR
condition|)
block|{
name|err
operator|=
operator|-
name|EAGAIN
expr_stmt|;
break|break;
block|}
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|mr
operator|->
name|order
operator|=
name|ent
operator|->
name|order
expr_stmt|;
name|mr
operator|->
name|umred
operator|=
literal|1
expr_stmt|;
name|mr
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|free
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|umr_en
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|access_mode
argument_list|,
name|MLX5_ACCESS_MODE_MTT
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|qpn
argument_list|,
literal|0xffffff
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|translations_octword_size
argument_list|,
operator|(
name|npages
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|log_page_size
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pending
operator|++
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx5_core_create_mkey
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
operator|&
name|mr
operator|->
name|mmkey
argument_list|,
operator|(
expr|struct
name|mlx5_create_mkey_mbox_in
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|,
name|reg_mr_callback
argument_list|,
name|mr
argument_list|,
operator|(
expr|struct
name|mlx5_create_mkey_mbox_out
operator|*
operator|)
name|mr
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pending
operator|--
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"create mkey failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|kfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_keys
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
init|=
operator|&
name|cache
operator|->
name|ent
index|[
name|c
index|]
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ent
operator|->
name|head
argument_list|)
condition|)
block|{
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mr
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ent
operator|->
name|head
argument_list|,
expr|struct
name|mlx5_ib_mr
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mr
operator|->
name|list
argument_list|)
expr_stmt|;
name|ent
operator|->
name|cur
operator|--
expr_stmt|;
name|ent
operator|->
name|size
operator|--
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|destroy_mkey
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed destroy mkey\n"
argument_list|)
expr_stmt|;
else|else
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|someone_adding
parameter_list|(
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MR_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cache
operator|->
name|ent
index|[
name|i
index|]
operator|.
name|cur
operator|<
name|cache
operator|->
name|ent
index|[
name|i
index|]
operator|.
name|limit
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cache_work_func
parameter_list|(
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|ent
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|int
name|i
init|=
name|order2idx
argument_list|(
name|dev
argument_list|,
name|ent
operator|->
name|order
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|stopped
condition|)
return|return;
name|ent
operator|=
operator|&
name|dev
operator|->
name|cache
operator|.
name|ent
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cur
operator|<
literal|2
operator|*
name|ent
operator|->
name|limit
operator|&&
operator|!
name|dev
operator|->
name|fill_delay
condition|)
block|{
name|err
operator|=
name|add_keys
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cur
operator|<
literal|2
operator|*
name|ent
operator|->
name|limit
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EAGAIN
condition|)
block|{
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"returned eagain, order %d\n"
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
name|queue_delayed_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|dwork
argument_list|,
name|msecs_to_jiffies
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"command failed order %d, err %d\n"
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|queue_delayed_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|dwork
argument_list|,
name|msecs_to_jiffies
argument_list|(
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|cur
operator|>
literal|2
operator|*
name|ent
operator|->
name|limit
condition|)
block|{
comment|/* 		 * The remove_keys() logic is performed as garbage collection 		 * task. Such task is intended to be run when no other active 		 * processes are running. 		 * 		 * The need_resched() will return TRUE if there are user tasks 		 * to be activated in near future. 		 * 		 * In such case, we don't execute remove_keys() and postpone 		 * the garbage collection work to try to run in next cycle, 		 * in order to free CPU resources to other tasks. 		 */
if|if
condition|(
operator|!
name|need_resched
argument_list|()
operator|&&
operator|!
name|someone_adding
argument_list|(
name|cache
argument_list|)
operator|&&
name|time_after
argument_list|(
name|jiffies
argument_list|,
name|cache
operator|->
name|last_add
operator|+
literal|300
operator|*
name|HZ
argument_list|)
condition|)
block|{
name|remove_keys
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cur
operator|>
name|ent
operator|->
name|limit
condition|)
name|queue_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue_delayed_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|dwork
argument_list|,
literal|300
operator|*
name|HZ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|delayed_cache_work_func
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|mlx5_cache_ent
argument_list|,
name|dwork
operator|.
name|work
argument_list|)
expr_stmt|;
name|__cache_work_func
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_work_func
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|mlx5_cache_ent
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|__cache_work_func
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mlx5_ib_mr
modifier|*
name|alloc_cached_mr
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|order
parameter_list|)
block|{
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|=
name|order2idx
argument_list|(
name|dev
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|>=
name|MAX_MR_CACHE_ENTRIES
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"order %d, cache index %d\n"
argument_list|,
name|order
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
name|c
init|;
name|i
operator|<
name|MAX_MR_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|=
operator|&
name|cache
operator|->
name|ent
index|[
name|i
index|]
expr_stmt|;
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"order %d, cache index %d\n"
argument_list|,
name|ent
operator|->
name|order
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ent
operator|->
name|head
argument_list|)
condition|)
block|{
name|mr
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ent
operator|->
name|head
argument_list|,
expr|struct
name|mlx5_ib_mr
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mr
operator|->
name|list
argument_list|)
expr_stmt|;
name|ent
operator|->
name|cur
operator|--
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cur
operator|<
name|ent
operator|->
name|limit
condition|)
name|queue_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|work
argument_list|)
expr_stmt|;
break|break;
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mr
condition|)
name|cache
operator|->
name|ent
index|[
name|c
index|]
operator|.
name|miss
operator|++
expr_stmt|;
return|return
name|mr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_cached_mr
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|)
block|{
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
decl_stmt|;
name|int
name|shrink
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|order2idx
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|>=
name|MAX_MR_CACHE_ENTRIES
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"order %d, cache index %d\n"
argument_list|,
name|mr
operator|->
name|order
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|ent
operator|=
operator|&
name|cache
operator|->
name|ent
index|[
name|c
index|]
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|mr
operator|->
name|list
argument_list|,
operator|&
name|ent
operator|->
name|head
argument_list|)
expr_stmt|;
name|ent
operator|->
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cur
operator|>
literal|2
operator|*
name|ent
operator|->
name|limit
condition|)
name|shrink
operator|=
literal|1
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|shrink
condition|)
name|queue_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clean_keys
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
init|=
operator|&
name|cache
operator|->
name|ent
index|[
name|c
index|]
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cancel_delayed_work
argument_list|(
operator|&
name|ent
operator|->
name|dwork
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ent
operator|->
name|head
argument_list|)
condition|)
block|{
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mr
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ent
operator|->
name|head
argument_list|,
expr|struct
name|mlx5_ib_mr
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mr
operator|->
name|list
argument_list|)
expr_stmt|;
name|ent
operator|->
name|cur
operator|--
expr_stmt|;
name|ent
operator|->
name|size
operator|--
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|destroy_mkey
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed destroy mkey\n"
argument_list|)
expr_stmt|;
else|else
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|delay_time_func
parameter_list|(
name|unsigned
name|long
name|ctx
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
operator|(
expr|struct
name|mlx5_ib_dev
operator|*
operator|)
name|ctx
decl_stmt|;
name|dev
operator|->
name|fill_delay
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx5_mr_cache_init
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx5_mr_cache
modifier|*
name|cache
init|=
operator|&
name|dev
operator|->
name|cache
decl_stmt|;
name|struct
name|mlx5_cache_ent
modifier|*
name|ent
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dev
operator|->
name|slow_path_mutex
argument_list|)
expr_stmt|;
name|cache
operator|->
name|wq
operator|=
name|alloc_ordered_workqueue
argument_list|(
literal|"mkey_cache"
argument_list|,
name|WQ_MEM_RECLAIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|wq
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to create work queue\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|setup_timer
argument_list|(
operator|&
name|dev
operator|->
name|delay_timer
argument_list|,
name|delay_time_func
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MR_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|cache
operator|->
name|ent
index|[
name|i
index|]
operator|.
name|head
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|cache
operator|->
name|ent
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ent
operator|=
operator|&
name|cache
operator|->
name|ent
index|[
name|i
index|]
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ent
operator|->
name|head
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ent
operator|->
name|order
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|ent
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|mdev
operator|->
name|profile
operator|->
name|mask
operator|&
name|MLX5_PROF_MASK_MR_CACHE
condition|)
name|limit
operator|=
name|dev
operator|->
name|mdev
operator|->
name|profile
operator|->
name|mr_cache
index|[
name|i
index|]
operator|.
name|limit
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|ent
operator|->
name|work
argument_list|,
name|cache_work_func
argument_list|)
expr_stmt|;
name|INIT_DELAYED_WORK
argument_list|(
operator|&
name|ent
operator|->
name|dwork
argument_list|,
name|delayed_cache_work_func
argument_list|)
expr_stmt|;
name|ent
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|queue_work
argument_list|(
name|cache
operator|->
name|wq
argument_list|,
operator|&
name|ent
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx5_mr_cache_cleanup
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dev
operator|->
name|cache
operator|.
name|stopped
operator|=
literal|1
expr_stmt|;
name|flush_workqueue
argument_list|(
name|dev
operator|->
name|cache
operator|.
name|wq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MR_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
name|clean_keys
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|dev
operator|->
name|cache
operator|.
name|wq
argument_list|)
expr_stmt|;
name|del_timer_sync
argument_list|(
operator|&
name|dev
operator|->
name|delay_timer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx5_ib_get_dma_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|acc
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|int
name|inlen
init|=
name|MLX5_ST_SZ_BYTES
argument_list|(
name|create_mkey_in
argument_list|)
decl_stmt|;
name|struct
name|mlx5_core_dev
modifier|*
name|mdev
init|=
name|dev
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
decl_stmt|;
name|void
modifier|*
name|mkc
decl_stmt|;
name|u32
modifier|*
name|in
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|in
operator|=
name|kzalloc
argument_list|(
name|inlen
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|mkc
operator|=
name|MLX5_ADDR_OF
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|memory_key_mkey_entry
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|access_mode
argument_list|,
name|MLX5_ACCESS_MODE_PA
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|a
argument_list|,
operator|!
operator|!
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_ATOMIC
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|rw
argument_list|,
operator|!
operator|!
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_WRITE
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|rr
argument_list|,
operator|!
operator|!
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_READ
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|lw
argument_list|,
operator|!
operator|!
operator|(
name|acc
operator|&
name|IB_ACCESS_LOCAL_WRITE
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|lr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|length64
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|pd
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|qpn
argument_list|,
literal|0xffffff
argument_list|)
expr_stmt|;
name|MLX5_SET64
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|start_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx5_core_create_mkey
argument_list|(
name|mdev
argument_list|,
operator|&
name|mr
operator|->
name|mmkey
argument_list|,
operator|(
expr|struct
name|mlx5_create_mkey_mbox_in
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_in
goto|;
name|kfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_in
label|:
name|kfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_octo_len
parameter_list|(
name|u64
name|addr
parameter_list|,
name|u64
name|len
parameter_list|,
name|int
name|page_size
parameter_list|)
block|{
name|u64
name|offset
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|offset
operator|=
name|addr
operator|&
operator|(
name|page_size
operator|-
literal|1
operator|)
expr_stmt|;
name|npages
operator|=
name|ALIGN
argument_list|(
name|len
operator|+
name|offset
argument_list|,
name|page_size
argument_list|)
operator|>>
name|ilog2
argument_list|(
name|page_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|npages
operator|+
literal|1
operator|)
operator|/
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|use_umr
parameter_list|(
name|int
name|order
parameter_list|)
block|{
return|return
name|order
operator|<=
name|MLX5_MAX_UMR_SHIFT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dma_map_mr_pas
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|page_shift
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|__be64
modifier|*
modifier|*
name|mr_pas
parameter_list|,
name|dma_addr_t
modifier|*
name|dma
parameter_list|)
block|{
name|__be64
modifier|*
name|pas
decl_stmt|;
name|struct
name|device
modifier|*
name|ddev
init|=
name|dev
operator|->
name|ib_dev
operator|.
name|dma_device
decl_stmt|;
comment|/* 	 * UMR copies MTTs in units of MLX5_UMR_MTT_ALIGNMENT bytes. 	 * To avoid copying garbage after the pas array, we allocate 	 * a little more. 	 */
operator|*
name|size
operator|=
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|*
name|npages
argument_list|,
name|MLX5_UMR_MTT_ALIGNMENT
argument_list|)
expr_stmt|;
operator|*
name|mr_pas
operator|=
name|kmalloc
argument_list|(
operator|*
name|size
operator|+
name|MLX5_UMR_ALIGN
operator|-
literal|1
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|mr_pas
operator|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|pas
operator|=
name|PTR_ALIGN
argument_list|(
operator|*
name|mr_pas
argument_list|,
name|MLX5_UMR_ALIGN
argument_list|)
expr_stmt|;
name|mlx5_ib_populate_pas
argument_list|(
name|dev
argument_list|,
name|umem
argument_list|,
name|page_shift
argument_list|,
name|pas
argument_list|,
name|MLX5_IB_MTT_PRESENT
argument_list|)
expr_stmt|;
comment|/* Clear padding after the actual pages. */
name|memset
argument_list|(
name|pas
operator|+
name|npages
argument_list|,
literal|0
argument_list|,
operator|*
name|size
operator|-
name|npages
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dma
operator|=
name|dma_map_single
argument_list|(
name|ddev
argument_list|,
name|pas
argument_list|,
operator|*
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_mapping_error
argument_list|(
name|ddev
argument_list|,
operator|*
name|dma
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
operator|*
name|mr_pas
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prep_umr_wqe_common
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_sge
modifier|*
name|sg
parameter_list|,
name|u64
name|dma
parameter_list|,
name|int
name|n
parameter_list|,
name|u32
name|key
parameter_list|,
name|int
name|page_shift
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx5_umr_wr
modifier|*
name|umrwr
init|=
name|umr_wr
argument_list|(
name|wr
argument_list|)
decl_stmt|;
name|sg
operator|->
name|addr
operator|=
name|dma
expr_stmt|;
name|sg
operator|->
name|length
operator|=
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|*
name|n
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|sg
operator|->
name|lkey
operator|=
name|dev
operator|->
name|umrc
operator|.
name|pd
operator|->
name|local_dma_lkey
expr_stmt|;
name|wr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|wr
operator|->
name|sg_list
operator|=
name|sg
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|wr
operator|->
name|num_sge
operator|=
literal|1
expr_stmt|;
else|else
name|wr
operator|->
name|num_sge
operator|=
literal|0
expr_stmt|;
name|wr
operator|->
name|opcode
operator|=
name|MLX5_IB_WR_UMR
expr_stmt|;
name|umrwr
operator|->
name|npages
operator|=
name|n
expr_stmt|;
name|umrwr
operator|->
name|page_shift
operator|=
name|page_shift
expr_stmt|;
name|umrwr
operator|->
name|mkey
operator|=
name|key
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prep_umr_reg_wqe
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_sge
modifier|*
name|sg
parameter_list|,
name|u64
name|dma
parameter_list|,
name|int
name|n
parameter_list|,
name|u32
name|key
parameter_list|,
name|int
name|page_shift
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|u64
name|len
parameter_list|,
name|int
name|access_flags
parameter_list|)
block|{
name|struct
name|mlx5_umr_wr
modifier|*
name|umrwr
init|=
name|umr_wr
argument_list|(
name|wr
argument_list|)
decl_stmt|;
name|prep_umr_wqe_common
argument_list|(
name|pd
argument_list|,
name|wr
argument_list|,
name|sg
argument_list|,
name|dma
argument_list|,
name|n
argument_list|,
name|key
argument_list|,
name|page_shift
argument_list|)
expr_stmt|;
name|wr
operator|->
name|send_flags
operator|=
literal|0
expr_stmt|;
name|umrwr
operator|->
name|target
operator|.
name|virt_addr
operator|=
name|virt_addr
expr_stmt|;
name|umrwr
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|umrwr
operator|->
name|access_flags
operator|=
name|access_flags
expr_stmt|;
name|umrwr
operator|->
name|pd
operator|=
name|pd
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prep_umr_unreg_wqe
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|u32
name|key
parameter_list|)
block|{
name|struct
name|mlx5_umr_wr
modifier|*
name|umrwr
init|=
name|umr_wr
argument_list|(
name|wr
argument_list|)
decl_stmt|;
name|wr
operator|->
name|send_flags
operator|=
name|MLX5_IB_SEND_UMR_UNREG
operator||
name|MLX5_IB_SEND_UMR_FAIL_IF_FREE
expr_stmt|;
name|wr
operator|->
name|opcode
operator|=
name|MLX5_IB_WR_UMR
expr_stmt|;
name|umrwr
operator|->
name|mkey
operator|=
name|key
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_umem
modifier|*
name|mr_umem_get
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|int
name|access_flags
parameter_list|,
name|int
modifier|*
name|npages
parameter_list|,
name|int
modifier|*
name|page_shift
parameter_list|,
name|int
modifier|*
name|ncont
parameter_list|,
name|int
modifier|*
name|order
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|ib_umem
modifier|*
name|umem
init|=
name|ib_umem_get
argument_list|(
name|pd
operator|->
name|uobject
operator|->
name|context
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|access_flags
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|umem
argument_list|)
condition|)
block|{
name|mlx5_ib_err
argument_list|(
name|dev
argument_list|,
literal|"umem get failed (%ld)\n"
argument_list|,
name|PTR_ERR
argument_list|(
name|umem
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|umem
return|;
block|}
name|mlx5_ib_cont_pages
argument_list|(
name|umem
argument_list|,
name|start
argument_list|,
name|npages
argument_list|,
name|page_shift
argument_list|,
name|ncont
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|npages
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"avoid zero region\n"
argument_list|)
expr_stmt|;
name|ib_umem_release
argument_list|(
name|umem
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
block|}
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"npages %d, ncont %d, order %d, page_shift %d\n"
argument_list|,
operator|*
name|npages
argument_list|,
operator|*
name|ncont
argument_list|,
operator|*
name|order
argument_list|,
operator|*
name|page_shift
argument_list|)
expr_stmt|;
return|return
name|umem
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx5_ib_umr_done
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|mlx5_ib_umr_context
modifier|*
name|context
init|=
name|container_of
argument_list|(
name|wc
operator|->
name|wr_cqe
argument_list|,
expr|struct
name|mlx5_ib_umr_context
argument_list|,
name|cqe
argument_list|)
decl_stmt|;
name|context
operator|->
name|status
operator|=
name|wc
operator|->
name|status
expr_stmt|;
name|complete
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mlx5_ib_init_umr_context
parameter_list|(
name|struct
name|mlx5_ib_umr_context
modifier|*
name|context
parameter_list|)
block|{
name|context
operator|->
name|cqe
operator|.
name|done
operator|=
name|mlx5_ib_umr_done
expr_stmt|;
name|context
operator|->
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mlx5_ib_mr
modifier|*
name|reg_umr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|u64
name|len
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|page_shift
parameter_list|,
name|int
name|order
parameter_list|,
name|int
name|access_flags
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|device
modifier|*
name|ddev
init|=
name|dev
operator|->
name|ib_dev
operator|.
name|dma_device
decl_stmt|;
name|struct
name|umr_common
modifier|*
name|umrc
init|=
operator|&
name|dev
operator|->
name|umrc
decl_stmt|;
name|struct
name|mlx5_ib_umr_context
name|umr_context
decl_stmt|;
name|struct
name|mlx5_umr_wr
name|umrwr
init|=
block|{}
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
decl_stmt|;
name|struct
name|ib_sge
name|sg
decl_stmt|;
name|int
name|size
decl_stmt|;
name|__be64
modifier|*
name|mr_pas
decl_stmt|;
name|dma_addr_t
name|dma
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mr
operator|=
name|alloc_cached_mr
argument_list|(
name|dev
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
condition|)
break|break;
name|err
operator|=
name|add_keys
argument_list|(
name|dev
argument_list|,
name|order2idx
argument_list|(
name|dev
argument_list|,
name|order
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
operator|-
name|EAGAIN
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"add_keys failed, err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EAGAIN
argument_list|)
return|;
name|err
operator|=
name|dma_map_mr_pas
argument_list|(
name|dev
argument_list|,
name|umem
argument_list|,
name|npages
argument_list|,
name|page_shift
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|mr_pas
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|free_mr
goto|;
name|mlx5_ib_init_umr_context
argument_list|(
operator|&
name|umr_context
argument_list|)
expr_stmt|;
name|umrwr
operator|.
name|wr
operator|.
name|wr_cqe
operator|=
operator|&
name|umr_context
operator|.
name|cqe
expr_stmt|;
name|prep_umr_reg_wqe
argument_list|(
name|pd
argument_list|,
operator|&
name|umrwr
operator|.
name|wr
argument_list|,
operator|&
name|sg
argument_list|,
name|dma
argument_list|,
name|npages
argument_list|,
name|mr
operator|->
name|mmkey
operator|.
name|key
argument_list|,
name|page_shift
argument_list|,
name|virt_addr
argument_list|,
name|len
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
name|down
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_post_send
argument_list|(
name|umrc
operator|->
name|qp
argument_list|,
operator|&
name|umrwr
operator|.
name|wr
argument_list|,
operator|&
name|bad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"post send failed, err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|unmap_dma
goto|;
block|}
else|else
block|{
name|wait_for_completion
argument_list|(
operator|&
name|umr_context
operator|.
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|umr_context
operator|.
name|status
operator|!=
name|IB_WC_SUCCESS
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"reg umr failed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EFAULT
expr_stmt|;
block|}
block|}
name|mr
operator|->
name|mmkey
operator|.
name|iova
operator|=
name|virt_addr
expr_stmt|;
name|mr
operator|->
name|mmkey
operator|.
name|size
operator|=
name|len
expr_stmt|;
name|mr
operator|->
name|mmkey
operator|.
name|pd
operator|=
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
expr_stmt|;
name|mr
operator|->
name|live
operator|=
literal|1
expr_stmt|;
name|unmap_dma
label|:
name|up
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
name|dma_unmap_single
argument_list|(
name|ddev
argument_list|,
name|dma
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr_pas
argument_list|)
expr_stmt|;
name|free_mr
label|:
if|if
condition|(
name|err
condition|)
block|{
name|free_cached_mr
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
return|return
name|mr
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
end_ifdef

begin_function
name|int
name|mlx5_ib_update_mtt
parameter_list|(
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|,
name|u64
name|start_page_index
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|zap
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|mr
operator|->
name|dev
decl_stmt|;
name|struct
name|device
modifier|*
name|ddev
init|=
name|dev
operator|->
name|ib_dev
operator|.
name|dma_device
decl_stmt|;
name|struct
name|umr_common
modifier|*
name|umrc
init|=
operator|&
name|dev
operator|->
name|umrc
decl_stmt|;
name|struct
name|mlx5_ib_umr_context
name|umr_context
decl_stmt|;
name|struct
name|ib_umem
modifier|*
name|umem
init|=
name|mr
operator|->
name|umem
decl_stmt|;
name|int
name|size
decl_stmt|;
name|__be64
modifier|*
name|pas
decl_stmt|;
name|dma_addr_t
name|dma
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad
decl_stmt|;
name|struct
name|mlx5_umr_wr
name|wr
decl_stmt|;
name|struct
name|ib_sge
name|sg
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|page_index_alignment
init|=
name|MLX5_UMR_MTT_ALIGNMENT
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
decl_stmt|;
specifier|const
name|int
name|page_index_mask
init|=
name|page_index_alignment
operator|-
literal|1
decl_stmt|;
name|size_t
name|pages_mapped
init|=
literal|0
decl_stmt|;
name|size_t
name|pages_to_map
init|=
literal|0
decl_stmt|;
name|size_t
name|pages_iter
init|=
literal|0
decl_stmt|;
name|int
name|use_emergency_buf
init|=
literal|0
decl_stmt|;
comment|/* UMR copies MTTs in units of MLX5_UMR_MTT_ALIGNMENT bytes, 	 * so we need to align the offset and length accordingly */
if|if
condition|(
name|start_page_index
operator|&
name|page_index_mask
condition|)
block|{
name|npages
operator|+=
name|start_page_index
operator|&
name|page_index_mask
expr_stmt|;
name|start_page_index
operator|&=
operator|~
name|page_index_mask
expr_stmt|;
block|}
name|pages_to_map
operator|=
name|ALIGN
argument_list|(
name|npages
argument_list|,
name|page_index_alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_page_index
operator|+
name|pages_to_map
operator|>
name|MLX5_MAX_UMR_PAGES
condition|)
return|return
operator|-
name|EINVAL
return|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|*
name|pages_to_map
expr_stmt|;
name|size
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|PAGE_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* We allocate with GFP_ATOMIC to avoid recursion into page-reclaim 	 * code, when we are called from an invalidation. The pas buffer must 	 * be 2k-aligned for Connect-IB. */
name|pas
operator|=
operator|(
name|__be64
operator|*
operator|)
name|get_zeroed_page
argument_list|(
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pas
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate memory during MTT update, falling back to slower chunked mechanism.\n"
argument_list|)
expr_stmt|;
name|pas
operator|=
name|mlx5_ib_update_mtt_emergency_buffer
expr_stmt|;
name|size
operator|=
name|MLX5_UMR_MTT_MIN_CHUNK_SIZE
expr_stmt|;
name|use_emergency_buf
operator|=
literal|1
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|mlx5_ib_update_mtt_emergency_buffer_mutex
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pas
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|pages_iter
operator|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
expr_stmt|;
name|dma
operator|=
name|dma_map_single
argument_list|(
name|ddev
argument_list|,
name|pas
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_mapping_error
argument_list|(
name|ddev
argument_list|,
name|dma
argument_list|)
condition|)
block|{
name|mlx5_ib_err
argument_list|(
name|dev
argument_list|,
literal|"unable to map DMA during MTT update.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|free_pas
goto|;
block|}
for|for
control|(
name|pages_mapped
operator|=
literal|0
init|;
name|pages_mapped
operator|<
name|pages_to_map
operator|&&
operator|!
name|err
condition|;
name|pages_mapped
operator|+=
name|pages_iter
operator|,
name|start_page_index
operator|+=
name|pages_iter
control|)
block|{
name|dma_sync_single_for_cpu
argument_list|(
name|ddev
argument_list|,
name|dma
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|npages
operator|=
name|min_t
argument_list|(
name|size_t
argument_list|,
name|pages_iter
argument_list|,
name|ib_umem_num_pages
argument_list|(
name|umem
argument_list|)
operator|-
name|start_page_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zap
condition|)
block|{
name|__mlx5_ib_populate_pas
argument_list|(
name|dev
argument_list|,
name|umem
argument_list|,
name|PAGE_SHIFT
argument_list|,
name|start_page_index
argument_list|,
name|npages
argument_list|,
name|pas
argument_list|,
name|MLX5_IB_MTT_PRESENT
argument_list|)
expr_stmt|;
comment|/* Clear padding after the pages brought from the 			 * umem. */
name|memset
argument_list|(
name|pas
operator|+
name|npages
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|npages
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dma_sync_single_for_device
argument_list|(
name|ddev
argument_list|,
name|dma
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|mlx5_ib_init_umr_context
argument_list|(
operator|&
name|umr_context
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|wr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wr
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|wr_cqe
operator|=
operator|&
name|umr_context
operator|.
name|cqe
expr_stmt|;
name|sg
operator|.
name|addr
operator|=
name|dma
expr_stmt|;
name|sg
operator|.
name|length
operator|=
name|ALIGN
argument_list|(
name|npages
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|MLX5_UMR_MTT_ALIGNMENT
argument_list|)
expr_stmt|;
name|sg
operator|.
name|lkey
operator|=
name|dev
operator|->
name|umrc
operator|.
name|pd
operator|->
name|local_dma_lkey
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|send_flags
operator|=
name|MLX5_IB_SEND_UMR_FAIL_IF_FREE
operator||
name|MLX5_IB_SEND_UMR_UPDATE_MTT
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|sg_list
operator|=
operator|&
name|sg
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|num_sge
operator|=
literal|1
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|opcode
operator|=
name|MLX5_IB_WR_UMR
expr_stmt|;
name|wr
operator|.
name|npages
operator|=
name|sg
operator|.
name|length
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
expr_stmt|;
name|wr
operator|.
name|page_shift
operator|=
name|PAGE_SHIFT
expr_stmt|;
name|wr
operator|.
name|mkey
operator|=
name|mr
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|wr
operator|.
name|target
operator|.
name|offset
operator|=
name|start_page_index
expr_stmt|;
name|down
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_post_send
argument_list|(
name|umrc
operator|->
name|qp
argument_list|,
operator|&
name|wr
operator|.
name|wr
argument_list|,
operator|&
name|bad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_err
argument_list|(
name|dev
argument_list|,
literal|"UMR post send failed, err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wait_for_completion
argument_list|(
operator|&
name|umr_context
operator|.
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|umr_context
operator|.
name|status
operator|!=
name|IB_WC_SUCCESS
condition|)
block|{
name|mlx5_ib_err
argument_list|(
name|dev
argument_list|,
literal|"UMR completion failed, code %d\n"
argument_list|,
name|umr_context
operator|.
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EFAULT
expr_stmt|;
block|}
block|}
name|up
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
block|}
name|dma_unmap_single
argument_list|(
name|ddev
argument_list|,
name|dma
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|free_pas
label|:
if|if
condition|(
operator|!
name|use_emergency_buf
condition|)
name|free_page
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|pas
argument_list|)
expr_stmt|;
else|else
name|mutex_unlock
argument_list|(
operator|&
name|mlx5_ib_update_mtt_emergency_buffer_mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * If ibmr is NULL it will be allocated by reg_create.  * Else, the given ibmr will be used.  */
end_comment

begin_function
specifier|static
name|struct
name|mlx5_ib_mr
modifier|*
name|reg_create
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ibmr
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|u64
name|length
parameter_list|,
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|page_shift
parameter_list|,
name|int
name|access_flags
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
decl_stmt|;
name|__be64
modifier|*
name|pas
decl_stmt|;
name|void
modifier|*
name|mkc
decl_stmt|;
name|int
name|inlen
decl_stmt|;
name|u32
modifier|*
name|in
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bool
name|pg_cap
init|=
operator|!
operator|!
operator|(
name|MLX5_CAP_GEN
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
name|pg
argument_list|)
operator|)
decl_stmt|;
name|mr
operator|=
name|ibmr
condition|?
name|to_mmr
argument_list|(
name|ibmr
argument_list|)
else|:
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|inlen
operator|=
name|MLX5_ST_SZ_BYTES
argument_list|(
name|create_mkey_in
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|pas
argument_list|)
operator|*
operator|(
operator|(
name|npages
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
name|in
operator|=
name|mlx5_vzalloc
argument_list|(
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_1
goto|;
block|}
name|pas
operator|=
operator|(
name|__be64
operator|*
operator|)
name|MLX5_ADDR_OF
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|klm_pas_mtt
argument_list|)
expr_stmt|;
name|mlx5_ib_populate_pas
argument_list|(
name|dev
argument_list|,
name|umem
argument_list|,
name|page_shift
argument_list|,
name|pas
argument_list|,
name|pg_cap
condition|?
name|MLX5_IB_MTT_PRESENT
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* The pg_access bit allows setting the access flags 	 * in the page list submitted with the command. */
name|MLX5_SET
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|pg_access
argument_list|,
operator|!
operator|!
operator|(
name|pg_cap
operator|)
argument_list|)
expr_stmt|;
name|mkc
operator|=
name|MLX5_ADDR_OF
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|memory_key_mkey_entry
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|access_mode
argument_list|,
name|MLX5_ACCESS_MODE_MTT
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|a
argument_list|,
operator|!
operator|!
operator|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_ATOMIC
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|rw
argument_list|,
operator|!
operator|!
operator|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_WRITE
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|rr
argument_list|,
operator|!
operator|!
operator|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_READ
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|lw
argument_list|,
operator|!
operator|!
operator|(
name|access_flags
operator|&
name|IB_ACCESS_LOCAL_WRITE
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|lr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET64
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|start_addr
argument_list|,
name|virt_addr
argument_list|)
expr_stmt|;
name|MLX5_SET64
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|len
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|pd
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|bsf_octword_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|translations_octword_size
argument_list|,
name|get_octo_len
argument_list|(
name|virt_addr
argument_list|,
name|length
argument_list|,
literal|1
operator|<<
name|page_shift
argument_list|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|log_page_size
argument_list|,
name|page_shift
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|qpn
argument_list|,
literal|0xffffff
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|translations_octword_actual_size
argument_list|,
name|get_octo_len
argument_list|(
name|virt_addr
argument_list|,
name|length
argument_list|,
literal|1
operator|<<
name|page_shift
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx5_core_create_mkey
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
operator|&
name|mr
operator|->
name|mmkey
argument_list|,
operator|(
expr|struct
name|mlx5_create_mkey_mbox_in
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"create mkey failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_2
goto|;
block|}
name|mr
operator|->
name|umem
operator|=
name|umem
expr_stmt|;
name|mr
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|mr
operator|->
name|live
operator|=
literal|1
expr_stmt|;
name|kvfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"mkey = 0x%x\n"
argument_list|,
name|mr
operator|->
name|mmkey
operator|.
name|key
argument_list|)
expr_stmt|;
return|return
name|mr
return|;
name|err_2
label|:
name|kvfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|err_1
label|:
if|if
condition|(
operator|!
name|ibmr
condition|)
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mr_fileds
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|,
name|int
name|npages
parameter_list|,
name|u64
name|length
parameter_list|,
name|int
name|access_flags
parameter_list|)
block|{
name|mr
operator|->
name|npages
operator|=
name|npages
expr_stmt|;
name|atomic_add
argument_list|(
name|npages
argument_list|,
operator|&
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|reg_pages
argument_list|)
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|mr
operator|->
name|access_flags
operator|=
name|access_flags
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx5_ib_reg_user_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|int
name|access_flags
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_umem
modifier|*
name|umem
decl_stmt|;
name|int
name|page_shift
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|int
name|ncont
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"start 0x%llx, virt_addr 0x%llx, length 0x%llx, access_flags 0x%x\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|start
argument_list|,
operator|(
name|long
name|long
operator|)
name|virt_addr
argument_list|,
operator|(
name|long
name|long
operator|)
name|length
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
name|umem
operator|=
name|mr_umem_get
argument_list|(
name|pd
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|access_flags
argument_list|,
operator|&
name|npages
argument_list|,
operator|&
name|page_shift
argument_list|,
operator|&
name|ncont
argument_list|,
operator|&
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|umem
argument_list|)
condition|)
return|return
operator|(
name|void
operator|*
operator|)
name|umem
return|;
if|if
condition|(
name|use_umr
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|mr
operator|=
name|reg_umr
argument_list|(
name|pd
argument_list|,
name|umem
argument_list|,
name|virt_addr
argument_list|,
name|length
argument_list|,
name|ncont
argument_list|,
name|page_shift
argument_list|,
name|order
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_ERR
argument_list|(
name|mr
argument_list|)
operator|==
operator|-
name|EAGAIN
condition|)
block|{
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"cache empty for order %d"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|mr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_ON_DEMAND
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|pr_err
argument_list|(
literal|"Got MR registration for ODP MR> 512MB, not supported for Connect-IB"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|mr
condition|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|slow_path_mutex
argument_list|)
expr_stmt|;
name|mr
operator|=
name|reg_create
argument_list|(
name|NULL
argument_list|,
name|pd
argument_list|,
name|virt_addr
argument_list|,
name|length
argument_list|,
name|umem
argument_list|,
name|ncont
argument_list|,
name|page_shift
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|slow_path_mutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_ERR
argument_list|(
name|mr
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mr
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"mkey 0x%x\n"
argument_list|,
name|mr
operator|->
name|mmkey
operator|.
name|key
argument_list|)
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|umem
expr_stmt|;
name|set_mr_fileds
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|,
name|npages
argument_list|,
name|length
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
name|update_odp_mr
argument_list|(
name|mr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|error
label|:
name|ib_umem_release
argument_list|(
name|umem
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unreg_umr
parameter_list|(
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|)
block|{
name|struct
name|mlx5_core_dev
modifier|*
name|mdev
init|=
name|dev
operator|->
name|mdev
decl_stmt|;
name|struct
name|umr_common
modifier|*
name|umrc
init|=
operator|&
name|dev
operator|->
name|umrc
decl_stmt|;
name|struct
name|mlx5_ib_umr_context
name|umr_context
decl_stmt|;
name|struct
name|mlx5_umr_wr
name|umrwr
init|=
block|{}
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|state
operator|==
name|MLX5_DEVICE_STATE_INTERNAL_ERROR
condition|)
return|return
literal|0
return|;
name|mlx5_ib_init_umr_context
argument_list|(
operator|&
name|umr_context
argument_list|)
expr_stmt|;
name|umrwr
operator|.
name|wr
operator|.
name|wr_cqe
operator|=
operator|&
name|umr_context
operator|.
name|cqe
expr_stmt|;
name|prep_umr_unreg_wqe
argument_list|(
name|dev
argument_list|,
operator|&
name|umrwr
operator|.
name|wr
argument_list|,
name|mr
operator|->
name|mmkey
operator|.
name|key
argument_list|)
expr_stmt|;
name|down
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_post_send
argument_list|(
name|umrc
operator|->
name|qp
argument_list|,
operator|&
name|umrwr
operator|.
name|wr
argument_list|,
operator|&
name|bad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|up
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|wait_for_completion
argument_list|(
operator|&
name|umr_context
operator|.
name|done
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|umr_context
operator|.
name|status
operator|!=
name|IB_WC_SUCCESS
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"unreg umr failed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
literal|0
return|;
name|error
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rereg_umr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|u64
name|length
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|page_shift
parameter_list|,
name|int
name|order
parameter_list|,
name|int
name|access_flags
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|device
modifier|*
name|ddev
init|=
name|dev
operator|->
name|ib_dev
operator|.
name|dma_device
decl_stmt|;
name|struct
name|mlx5_ib_umr_context
name|umr_context
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad
decl_stmt|;
name|struct
name|mlx5_umr_wr
name|umrwr
init|=
block|{}
decl_stmt|;
name|struct
name|ib_sge
name|sg
decl_stmt|;
name|struct
name|umr_common
modifier|*
name|umrc
init|=
operator|&
name|dev
operator|->
name|umrc
decl_stmt|;
name|dma_addr_t
name|dma
init|=
literal|0
decl_stmt|;
name|__be64
modifier|*
name|mr_pas
init|=
name|NULL
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mlx5_ib_init_umr_context
argument_list|(
operator|&
name|umr_context
argument_list|)
expr_stmt|;
name|umrwr
operator|.
name|wr
operator|.
name|wr_cqe
operator|=
operator|&
name|umr_context
operator|.
name|cqe
expr_stmt|;
name|umrwr
operator|.
name|wr
operator|.
name|send_flags
operator|=
name|MLX5_IB_SEND_UMR_FAIL_IF_FREE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_TRANS
condition|)
block|{
name|err
operator|=
name|dma_map_mr_pas
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|umem
argument_list|,
name|npages
argument_list|,
name|page_shift
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|mr_pas
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|umrwr
operator|.
name|target
operator|.
name|virt_addr
operator|=
name|virt_addr
expr_stmt|;
name|umrwr
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|umrwr
operator|.
name|wr
operator|.
name|send_flags
operator||=
name|MLX5_IB_SEND_UMR_UPDATE_TRANSLATION
expr_stmt|;
block|}
name|prep_umr_wqe_common
argument_list|(
name|pd
argument_list|,
operator|&
name|umrwr
operator|.
name|wr
argument_list|,
operator|&
name|sg
argument_list|,
name|dma
argument_list|,
name|npages
argument_list|,
name|mr
operator|->
name|mmkey
operator|.
name|key
argument_list|,
name|page_shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_PD
condition|)
block|{
name|umrwr
operator|.
name|pd
operator|=
name|pd
expr_stmt|;
name|umrwr
operator|.
name|wr
operator|.
name|send_flags
operator||=
name|MLX5_IB_SEND_UMR_UPDATE_PD
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_ACCESS
condition|)
block|{
name|umrwr
operator|.
name|access_flags
operator|=
name|access_flags
expr_stmt|;
name|umrwr
operator|.
name|wr
operator|.
name|send_flags
operator||=
name|MLX5_IB_SEND_UMR_UPDATE_ACCESS
expr_stmt|;
block|}
comment|/* post send request to UMR QP */
name|down
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_post_send
argument_list|(
name|umrc
operator|->
name|qp
argument_list|,
operator|&
name|umrwr
operator|.
name|wr
argument_list|,
operator|&
name|bad
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"post send failed, err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wait_for_completion
argument_list|(
operator|&
name|umr_context
operator|.
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|umr_context
operator|.
name|status
operator|!=
name|IB_WC_SUCCESS
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"reg umr failed (%u)\n"
argument_list|,
name|umr_context
operator|.
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EFAULT
expr_stmt|;
block|}
block|}
name|up
argument_list|(
operator|&
name|umrc
operator|->
name|sem
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_TRANS
condition|)
block|{
name|dma_unmap_single
argument_list|(
name|ddev
argument_list|,
name|dma
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr_pas
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx5_ib_rereg_user_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ib_mr
parameter_list|,
name|int
name|flags
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|int
name|new_access_flags
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|new_pd
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ib_mr
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
init|=
name|to_mmr
argument_list|(
name|ib_mr
argument_list|)
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
init|=
operator|(
name|flags
operator|&
name|IB_MR_REREG_PD
operator|)
condition|?
name|new_pd
else|:
name|ib_mr
operator|->
name|pd
decl_stmt|;
name|int
name|access_flags
init|=
name|flags
operator|&
name|IB_MR_REREG_ACCESS
condition|?
name|new_access_flags
else|:
name|mr
operator|->
name|access_flags
decl_stmt|;
name|u64
name|addr
init|=
operator|(
name|flags
operator|&
name|IB_MR_REREG_TRANS
operator|)
condition|?
name|virt_addr
else|:
name|mr
operator|->
name|umem
operator|->
name|address
decl_stmt|;
name|u64
name|len
init|=
operator|(
name|flags
operator|&
name|IB_MR_REREG_TRANS
operator|)
condition|?
name|length
else|:
name|mr
operator|->
name|umem
operator|->
name|length
decl_stmt|;
name|int
name|page_shift
init|=
literal|0
decl_stmt|;
name|int
name|npages
init|=
literal|0
decl_stmt|;
name|int
name|ncont
init|=
literal|0
decl_stmt|;
name|int
name|order
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mlx5_ib_dbg
argument_list|(
name|dev
argument_list|,
literal|"start 0x%llx, virt_addr 0x%llx, length 0x%llx, access_flags 0x%x\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|start
argument_list|,
operator|(
name|long
name|long
operator|)
name|virt_addr
argument_list|,
operator|(
name|long
name|long
operator|)
name|length
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|IB_MR_REREG_PD
condition|)
block|{
comment|/* 		 * Replace umem. This needs to be done whether or not UMR is 		 * used. 		 */
name|flags
operator||=
name|IB_MR_REREG_TRANS
expr_stmt|;
name|ib_umem_release
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|mr_umem_get
argument_list|(
name|pd
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|access_flags
argument_list|,
operator|&
name|npages
argument_list|,
operator|&
name|page_shift
argument_list|,
operator|&
name|ncont
argument_list|,
operator|&
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_TRANS
operator|&&
operator|!
name|use_umr_mtt_update
argument_list|(
name|mr
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* 		 * UMR can't be used - MKey needs to be replaced. 		 */
if|if
condition|(
name|mr
operator|->
name|umred
condition|)
block|{
name|err
operator|=
name|unreg_umr
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to unregister MR\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|destroy_mkey
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to destroy MKey\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|mr
operator|=
name|reg_create
argument_list|(
name|ib_mr
argument_list|,
name|pd
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|mr
operator|->
name|umem
argument_list|,
name|ncont
argument_list|,
name|page_shift
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mr
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mr
argument_list|)
return|;
name|mr
operator|->
name|umred
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Send a UMR WQE 		 */
name|err
operator|=
name|rereg_umr
argument_list|(
name|pd
argument_list|,
name|mr
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|npages
argument_list|,
name|page_shift
argument_list|,
name|order
argument_list|,
name|access_flags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to rereg UMR\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_PD
condition|)
block|{
name|ib_mr
operator|->
name|pd
operator|=
name|pd
expr_stmt|;
name|mr
operator|->
name|mmkey
operator|.
name|pd
operator|=
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_ACCESS
condition|)
name|mr
operator|->
name|access_flags
operator|=
name|access_flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IB_MR_REREG_TRANS
condition|)
block|{
name|atomic_sub
argument_list|(
name|mr
operator|->
name|npages
argument_list|,
operator|&
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|reg_pages
argument_list|)
expr_stmt|;
name|set_mr_fileds
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|,
name|npages
argument_list|,
name|len
argument_list|,
name|access_flags
argument_list|)
expr_stmt|;
name|mr
operator|->
name|mmkey
operator|.
name|iova
operator|=
name|addr
expr_stmt|;
name|mr
operator|->
name|mmkey
operator|.
name|size
operator|=
name|len
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
name|update_odp_mr
argument_list|(
name|mr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_alloc_priv_descs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|,
name|int
name|ndescs
parameter_list|,
name|int
name|desc_size
parameter_list|)
block|{
name|int
name|size
init|=
name|ndescs
operator|*
name|desc_size
decl_stmt|;
name|int
name|add_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|add_size
operator|=
name|max_t
argument_list|(
name|int
argument_list|,
name|MLX5_UMR_ALIGN
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mr
operator|->
name|descs_alloc
operator|=
name|kzalloc
argument_list|(
name|size
operator|+
name|add_size
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
operator|->
name|descs_alloc
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mr
operator|->
name|descs
operator|=
name|PTR_ALIGN
argument_list|(
name|mr
operator|->
name|descs_alloc
argument_list|,
name|MLX5_UMR_ALIGN
argument_list|)
expr_stmt|;
name|mr
operator|->
name|desc_map
operator|=
name|dma_map_single
argument_list|(
name|device
operator|->
name|dma_device
argument_list|,
name|mr
operator|->
name|descs
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_mapping_error
argument_list|(
name|device
operator|->
name|dma_device
argument_list|,
name|mr
operator|->
name|desc_map
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
literal|0
return|;
name|err
label|:
name|kfree
argument_list|(
name|mr
operator|->
name|descs_alloc
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx5_free_priv_descs
parameter_list|(
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|)
block|{
if|if
condition|(
name|mr
operator|->
name|descs
condition|)
block|{
name|struct
name|ib_device
modifier|*
name|device
init|=
name|mr
operator|->
name|ibmr
operator|.
name|device
decl_stmt|;
name|int
name|size
init|=
name|mr
operator|->
name|max_descs
operator|*
name|mr
operator|->
name|desc_size
decl_stmt|;
name|dma_unmap_single
argument_list|(
name|device
operator|->
name|dma_device
argument_list|,
name|mr
operator|->
name|desc_map
argument_list|,
name|size
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr
operator|->
name|descs_alloc
argument_list|)
expr_stmt|;
name|mr
operator|->
name|descs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|clean_mr
parameter_list|(
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|mr
operator|->
name|ibmr
operator|.
name|device
argument_list|)
decl_stmt|;
name|int
name|umred
init|=
name|mr
operator|->
name|umred
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|mr
operator|->
name|sig
condition|)
block|{
if|if
condition|(
name|mlx5_core_destroy_psv
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_memory
operator|.
name|psv_idx
argument_list|)
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to destroy mem psv %d\n"
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_memory
operator|.
name|psv_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx5_core_destroy_psv
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_wire
operator|.
name|psv_idx
argument_list|)
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to destroy wire psv %d\n"
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_wire
operator|.
name|psv_idx
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr
operator|->
name|sig
argument_list|)
expr_stmt|;
name|mr
operator|->
name|sig
operator|=
name|NULL
expr_stmt|;
block|}
name|mlx5_free_priv_descs
argument_list|(
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umred
condition|)
block|{
name|err
operator|=
name|destroy_mkey
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to destroy mkey 0x%x (%d)\n"
argument_list|,
name|mr
operator|->
name|mmkey
operator|.
name|key
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|unreg_umr
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed unregister\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|free_cached_mr
argument_list|(
name|dev
argument_list|,
name|mr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|umred
condition|)
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx5_ib_dereg_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ibmr
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibmr
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
init|=
name|to_mmr
argument_list|(
name|ibmr
argument_list|)
decl_stmt|;
name|int
name|npages
init|=
name|mr
operator|->
name|npages
decl_stmt|;
name|struct
name|ib_umem
modifier|*
name|umem
init|=
name|mr
operator|->
name|umem
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
if|if
condition|(
name|umem
operator|&&
name|umem
operator|->
name|odp_data
condition|)
block|{
comment|/* Prevent new page faults from succeeding */
name|mr
operator|->
name|live
operator|=
literal|0
expr_stmt|;
comment|/* Wait for all running page-fault handlers to finish. */
name|synchronize_srcu
argument_list|(
operator|&
name|dev
operator|->
name|mr_srcu
argument_list|)
expr_stmt|;
comment|/* Destroy all page mappings */
name|mlx5_ib_invalidate_range
argument_list|(
name|umem
argument_list|,
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
argument_list|,
name|ib_umem_end
argument_list|(
name|umem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * We kill the umem before the MR for ODP, 		 * so that there will not be any invalidations in 		 * flight, looking at the *mr struct. 		 */
name|ib_umem_release
argument_list|(
name|umem
argument_list|)
expr_stmt|;
name|atomic_sub
argument_list|(
name|npages
argument_list|,
operator|&
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|reg_pages
argument_list|)
expr_stmt|;
comment|/* Avoid double-freeing the umem. */
name|umem
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|clean_mr
argument_list|(
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|umem
condition|)
block|{
name|ib_umem_release
argument_list|(
name|umem
argument_list|)
expr_stmt|;
name|atomic_sub
argument_list|(
name|npages
argument_list|,
operator|&
name|dev
operator|->
name|mdev
operator|->
name|priv
operator|.
name|reg_pages
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx5_ib_alloc_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mr_type
name|mr_type
parameter_list|,
name|u32
name|max_num_sg
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|int
name|inlen
init|=
name|MLX5_ST_SZ_BYTES
argument_list|(
name|create_mkey_in
argument_list|)
decl_stmt|;
name|int
name|ndescs
init|=
name|ALIGN
argument_list|(
name|max_num_sg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
decl_stmt|;
name|void
modifier|*
name|mkc
decl_stmt|;
name|u32
modifier|*
name|in
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|in
operator|=
name|kzalloc
argument_list|(
name|inlen
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|mkc
operator|=
name|MLX5_ADDR_OF
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|memory_key_mkey_entry
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|free
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|translations_octword_size
argument_list|,
name|ndescs
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|qpn
argument_list|,
literal|0xffffff
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|pd
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr_type
operator|==
name|IB_MR_TYPE_MEM_REG
condition|)
block|{
name|mr
operator|->
name|access_mode
operator|=
name|MLX5_ACCESS_MODE_MTT
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|log_page_size
argument_list|,
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx5_alloc_priv_descs
argument_list|(
name|pd
operator|->
name|device
argument_list|,
name|mr
argument_list|,
name|ndescs
argument_list|,
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_in
goto|;
name|mr
operator|->
name|desc_size
operator|=
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
expr_stmt|;
name|mr
operator|->
name|max_descs
operator|=
name|ndescs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mr_type
operator|==
name|IB_MR_TYPE_SG_GAPS
condition|)
block|{
name|mr
operator|->
name|access_mode
operator|=
name|MLX5_ACCESS_MODE_KLM
expr_stmt|;
name|err
operator|=
name|mlx5_alloc_priv_descs
argument_list|(
name|pd
operator|->
name|device
argument_list|,
name|mr
argument_list|,
name|ndescs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx5_klm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_in
goto|;
name|mr
operator|->
name|desc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx5_klm
argument_list|)
expr_stmt|;
name|mr
operator|->
name|max_descs
operator|=
name|ndescs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mr_type
operator|==
name|IB_MR_TYPE_SIGNATURE
condition|)
block|{
name|u32
name|psv_index
index|[
literal|2
index|]
decl_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|bsf_en
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|bsf_octword_size
argument_list|,
name|MLX5_MKEY_BSF_OCTO_SIZE
argument_list|)
expr_stmt|;
name|mr
operator|->
name|sig
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mr
operator|->
name|sig
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
operator|->
name|sig
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free_in
goto|;
block|}
comment|/* create mem& wire PSVs */
name|err
operator|=
name|mlx5_core_create_psv
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
literal|2
argument_list|,
name|psv_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_sig
goto|;
name|mr
operator|->
name|access_mode
operator|=
name|MLX5_ACCESS_MODE_KLM
expr_stmt|;
name|mr
operator|->
name|sig
operator|->
name|psv_memory
operator|.
name|psv_idx
operator|=
name|psv_index
index|[
literal|0
index|]
expr_stmt|;
name|mr
operator|->
name|sig
operator|->
name|psv_wire
operator|.
name|psv_idx
operator|=
name|psv_index
index|[
literal|1
index|]
expr_stmt|;
name|mr
operator|->
name|sig
operator|->
name|sig_status_checked
operator|=
name|true
expr_stmt|;
name|mr
operator|->
name|sig
operator|->
name|sig_err_exists
operator|=
name|false
expr_stmt|;
comment|/* Next UMR, Arm SIGERR */
operator|++
name|mr
operator|->
name|sig
operator|->
name|sigerr_count
expr_stmt|;
block|}
else|else
block|{
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"Invalid mr type %d\n"
argument_list|,
name|mr_type
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_free_in
goto|;
block|}
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|access_mode
argument_list|,
name|mr
operator|->
name|access_mode
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|umr_en
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx5_core_create_mkey
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
operator|&
name|mr
operator|->
name|mmkey
argument_list|,
operator|(
expr|struct
name|mlx5_create_mkey_mbox_in
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_destroy_psv
goto|;
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_destroy_psv
label|:
if|if
condition|(
name|mr
operator|->
name|sig
condition|)
block|{
if|if
condition|(
name|mlx5_core_destroy_psv
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_memory
operator|.
name|psv_idx
argument_list|)
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to destroy mem psv %d\n"
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_memory
operator|.
name|psv_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx5_core_destroy_psv
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_wire
operator|.
name|psv_idx
argument_list|)
condition|)
name|mlx5_ib_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to destroy wire psv %d\n"
argument_list|,
name|mr
operator|->
name|sig
operator|->
name|psv_wire
operator|.
name|psv_idx
argument_list|)
expr_stmt|;
block|}
name|mlx5_free_priv_descs
argument_list|(
name|mr
argument_list|)
expr_stmt|;
name|err_free_sig
label|:
name|kfree
argument_list|(
name|mr
operator|->
name|sig
argument_list|)
expr_stmt|;
name|err_free_in
label|:
name|kfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ib_mw
modifier|*
name|mlx5_ib_alloc_mw
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mw_type
name|type
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx5_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|int
name|inlen
init|=
name|MLX5_ST_SZ_BYTES
argument_list|(
name|create_mkey_in
argument_list|)
decl_stmt|;
name|struct
name|mlx5_ib_mw
modifier|*
name|mw
init|=
name|NULL
decl_stmt|;
name|u32
modifier|*
name|in
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|mkc
decl_stmt|;
name|int
name|ndescs
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx5_ib_alloc_mw
name|req
init|=
block|{}
decl_stmt|;
struct|struct
block|{
name|__u32
name|comp_mask
decl_stmt|;
name|__u32
name|response_length
decl_stmt|;
block|}
name|resp
init|=
block|{}
struct|;
name|err
operator|=
name|ib_copy_from_udata
argument_list|(
operator|&
name|req
argument_list|,
name|udata
argument_list|,
name|min
argument_list|(
name|udata
operator|->
name|inlen
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|req
operator|.
name|comp_mask
operator|||
name|req
operator|.
name|reserved1
operator|||
name|req
operator|.
name|reserved2
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EOPNOTSUPP
argument_list|)
return|;
if|if
condition|(
name|udata
operator|->
name|inlen
operator|>
sizeof|sizeof
argument_list|(
name|req
argument_list|)
operator|&&
operator|!
name|ib_is_udata_cleared
argument_list|(
name|udata
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
name|udata
operator|->
name|inlen
operator|-
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EOPNOTSUPP
argument_list|)
return|;
name|ndescs
operator|=
name|req
operator|.
name|num_klms
condition|?
name|roundup
argument_list|(
name|req
operator|.
name|num_klms
argument_list|,
literal|4
argument_list|)
else|:
name|roundup
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mw
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mw
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|in
operator|=
name|kzalloc
argument_list|(
name|inlen
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mw
operator|||
operator|!
name|in
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|free
goto|;
block|}
name|mkc
operator|=
name|MLX5_ADDR_OF
argument_list|(
name|create_mkey_in
argument_list|,
name|in
argument_list|,
name|memory_key_mkey_entry
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|free
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|translations_octword_size
argument_list|,
name|ndescs
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|pd
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|umr_en
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|lr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|access_mode
argument_list|,
name|MLX5_ACCESS_MODE_KLM
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|en_rinval
argument_list|,
operator|!
operator|!
operator|(
operator|(
name|type
operator|==
name|IB_MW_TYPE_2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|MLX5_SET
argument_list|(
name|mkc
argument_list|,
name|mkc
argument_list|,
name|qpn
argument_list|,
literal|0xffffff
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx5_core_create_mkey
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
operator|&
name|mw
operator|->
name|mmkey
argument_list|,
operator|(
expr|struct
name|mlx5_create_mkey_mbox_in
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|free
goto|;
name|mw
operator|->
name|ibmw
operator|.
name|rkey
operator|=
name|mw
operator|->
name|mmkey
operator|.
name|key
expr_stmt|;
name|resp
operator|.
name|response_length
operator|=
name|min
argument_list|(
name|offsetof
argument_list|(
name|typeof
argument_list|(
name|resp
argument_list|)
argument_list|,
name|response_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|resp
operator|.
name|response_length
argument_list|)
argument_list|,
name|udata
operator|->
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|response_length
condition|)
block|{
name|err
operator|=
name|ib_copy_to_udata
argument_list|(
name|udata
argument_list|,
operator|&
name|resp
argument_list|,
name|resp
operator|.
name|response_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx5_core_destroy_mkey
argument_list|(
name|dev
operator|->
name|mdev
argument_list|,
operator|&
name|mw
operator|->
name|mmkey
argument_list|)
expr_stmt|;
goto|goto
name|free
goto|;
block|}
block|}
name|kfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
operator|&
name|mw
operator|->
name|ibmw
return|;
name|free
label|:
name|kfree
argument_list|(
name|mw
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx5_ib_dealloc_mw
parameter_list|(
name|struct
name|ib_mw
modifier|*
name|mw
parameter_list|)
block|{
name|struct
name|mlx5_ib_mw
modifier|*
name|mmw
init|=
name|to_mmw
argument_list|(
name|mw
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx5_core_destroy_mkey
argument_list|(
operator|(
name|to_mdev
argument_list|(
name|mw
operator|->
name|device
argument_list|)
operator|)
operator|->
name|mdev
argument_list|,
operator|&
name|mmw
operator|->
name|mmkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|kfree
argument_list|(
name|mmw
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx5_ib_check_mr_status
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ibmr
parameter_list|,
name|u32
name|check_mask
parameter_list|,
name|struct
name|ib_mr_status
modifier|*
name|mr_status
parameter_list|)
block|{
name|struct
name|mlx5_ib_mr
modifier|*
name|mmr
init|=
name|to_mmr
argument_list|(
name|ibmr
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|check_mask
operator|&
operator|~
name|IB_MR_CHECK_SIG_STATUS
condition|)
block|{
name|pr_err
argument_list|(
literal|"Invalid status check mask\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mr_status
operator|->
name|fail_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|check_mask
operator|&
name|IB_MR_CHECK_SIG_STATUS
condition|)
block|{
if|if
condition|(
operator|!
name|mmr
operator|->
name|sig
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|pr_err
argument_list|(
literal|"signature status check requested on a non-signature enabled MR\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mmr
operator|->
name|sig
operator|->
name|sig_status_checked
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|mmr
operator|->
name|sig
operator|->
name|sig_err_exists
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|ibmr
operator|->
name|lkey
operator|==
name|mmr
operator|->
name|sig
operator|->
name|err_item
operator|.
name|key
condition|)
name|memcpy
argument_list|(
operator|&
name|mr_status
operator|->
name|sig_err
argument_list|,
operator|&
name|mmr
operator|->
name|sig
operator|->
name|err_item
argument_list|,
sizeof|sizeof
argument_list|(
name|mr_status
operator|->
name|sig_err
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mr_status
operator|->
name|sig_err
operator|.
name|err_type
operator|=
name|IB_SIG_BAD_GUARD
expr_stmt|;
name|mr_status
operator|->
name|sig_err
operator|.
name|sig_err_offset
operator|=
literal|0
expr_stmt|;
name|mr_status
operator|->
name|sig_err
operator|.
name|key
operator|=
name|mmr
operator|->
name|sig
operator|->
name|err_item
operator|.
name|key
expr_stmt|;
block|}
name|mmr
operator|->
name|sig
operator|->
name|sig_err_exists
operator|=
name|false
expr_stmt|;
name|mr_status
operator|->
name|fail_status
operator||=
name|IB_MR_CHECK_SIG_STATUS
expr_stmt|;
block|}
name|done
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_ib_sg_to_klms
parameter_list|(
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sgl
parameter_list|,
name|unsigned
name|short
name|sg_nents
parameter_list|,
name|unsigned
name|int
modifier|*
name|sg_offset_p
parameter_list|)
block|{
name|struct
name|scatterlist
modifier|*
name|sg
init|=
name|sgl
decl_stmt|;
name|struct
name|mlx5_klm
modifier|*
name|klms
init|=
name|mr
operator|->
name|descs
decl_stmt|;
name|unsigned
name|int
name|sg_offset
init|=
name|sg_offset_p
condition|?
operator|*
name|sg_offset_p
else|:
literal|0
decl_stmt|;
name|u32
name|lkey
init|=
name|mr
operator|->
name|ibmr
operator|.
name|pd
operator|->
name|local_dma_lkey
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|iova
operator|=
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
operator|+
name|sg_offset
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|mr
operator|->
name|ndescs
operator|=
name|sg_nents
expr_stmt|;
name|for_each_sg
argument_list|(
argument|sgl
argument_list|,
argument|sg
argument_list|,
argument|sg_nents
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|i
operator|>
name|mr
operator|->
name|max_descs
argument_list|)
condition|)
break|break;
name|klms
index|[
name|i
index|]
operator|.
name|va
operator|=
name|cpu_to_be64
argument_list|(
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
operator|+
name|sg_offset
argument_list|)
expr_stmt|;
name|klms
index|[
name|i
index|]
operator|.
name|bcount
operator|=
name|cpu_to_be32
argument_list|(
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
operator|-
name|sg_offset
argument_list|)
expr_stmt|;
name|klms
index|[
name|i
index|]
operator|.
name|key
operator|=
name|cpu_to_be32
argument_list|(
name|lkey
argument_list|)
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|length
operator|+=
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|sg_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sg_offset_p
condition|)
operator|*
name|sg_offset_p
operator|=
name|sg_offset
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_set_page
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ibmr
parameter_list|,
name|u64
name|addr
parameter_list|)
block|{
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
init|=
name|to_mmr
argument_list|(
name|ibmr
argument_list|)
decl_stmt|;
name|__be64
modifier|*
name|descs
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|mr
operator|->
name|ndescs
operator|==
name|mr
operator|->
name|max_descs
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|descs
operator|=
name|mr
operator|->
name|descs
expr_stmt|;
name|descs
index|[
name|mr
operator|->
name|ndescs
operator|++
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|addr
operator||
name|MLX5_EN_RD
operator||
name|MLX5_EN_WR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx5_ib_map_mr_sg
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ibmr
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|sg_nents
parameter_list|,
name|unsigned
name|int
modifier|*
name|sg_offset
parameter_list|)
block|{
name|struct
name|mlx5_ib_mr
modifier|*
name|mr
init|=
name|to_mmr
argument_list|(
name|ibmr
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|mr
operator|->
name|ndescs
operator|=
literal|0
expr_stmt|;
name|ib_dma_sync_single_for_cpu
argument_list|(
name|ibmr
operator|->
name|device
argument_list|,
name|mr
operator|->
name|desc_map
argument_list|,
name|mr
operator|->
name|desc_size
operator|*
name|mr
operator|->
name|max_descs
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|->
name|access_mode
operator|==
name|MLX5_ACCESS_MODE_KLM
condition|)
name|n
operator|=
name|mlx5_ib_sg_to_klms
argument_list|(
name|mr
argument_list|,
name|sg
argument_list|,
name|sg_nents
argument_list|,
name|sg_offset
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|ib_sg_to_pages
argument_list|(
name|ibmr
argument_list|,
name|sg
argument_list|,
name|sg_nents
argument_list|,
name|sg_offset
argument_list|,
name|mlx5_set_page
argument_list|)
expr_stmt|;
name|ib_dma_sync_single_for_device
argument_list|(
name|ibmr
operator|->
name|device
argument_list|,
name|mr
operator|->
name|desc_map
argument_list|,
name|mr
operator|->
name|desc_size
operator|*
name|mr
operator|->
name|max_descs
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

end_unit

