begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2015, Mellanox Technologies, Ltd.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS `AS IS' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/random.h>
end_include

begin_include
include|#
directive|include
file|<linux/vmalloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx5/driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/mlx5/mlx5_ifc.h>
end_include

begin_include
include|#
directive|include
file|"mlx5_core.h"
end_include

begin_define
define|#
directive|define
name|MLX5_HEALTH_POLL_INTERVAL
value|(2 * HZ)
end_define

begin_define
define|#
directive|define
name|MAX_MISSES
value|3
end_define

begin_expr_stmt
specifier|static
name|DEFINE_SPINLOCK
argument_list|(
name|health_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|health_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|work_struct
name|health_work
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|health_care
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|mlx5_core_health
modifier|*
name|health
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|mlx5_core_dev
modifier|*
name|dev
decl_stmt|;
name|struct
name|mlx5_priv
modifier|*
name|priv
decl_stmt|;
name|LIST_HEAD
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
name|list_splice_init
argument_list|(
operator|&
name|health_list
argument_list|,
operator|&
name|tlist
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|health
argument_list|,
argument|n
argument_list|,
argument|&tlist
argument_list|,
argument|list
argument_list|)
block|{
name|priv
operator|=
name|container_of
argument_list|(
name|health
argument_list|,
expr|struct
name|mlx5_priv
argument_list|,
name|health
argument_list|)
expr_stmt|;
name|dev
operator|=
name|container_of
argument_list|(
name|priv
argument_list|,
expr|struct
name|mlx5_core_dev
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|mlx5_core_warn
argument_list|(
name|dev
argument_list|,
literal|"handling bad device here\n"
argument_list|)
expr_stmt|;
comment|/* nothing yet */
name|spin_lock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|health
operator|->
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hsynd_str
parameter_list|(
name|u8
name|synd
parameter_list|)
block|{
switch|switch
condition|(
name|synd
condition|)
block|{
case|case
name|MLX5_HEALTH_SYNDR_FW_ERR
case|:
return|return
literal|"firmware internal error"
return|;
case|case
name|MLX5_HEALTH_SYNDR_IRISC_ERR
case|:
return|return
literal|"irisc not responding"
return|;
case|case
name|MLX5_HEALTH_SYNDR_CRC_ERR
case|:
return|return
literal|"firmware CRC error"
return|;
case|case
name|MLX5_HEALTH_SYNDR_FETCH_PCI_ERR
case|:
return|return
literal|"ICM fetch PCI error"
return|;
case|case
name|MLX5_HEALTH_SYNDR_HW_FTL_ERR
case|:
return|return
literal|"HW fatal error\n"
return|;
case|case
name|MLX5_HEALTH_SYNDR_ASYNC_EQ_OVERRUN_ERR
case|:
return|return
literal|"async EQ buffer overrun"
return|;
case|case
name|MLX5_HEALTH_SYNDR_EQ_ERR
case|:
return|return
literal|"EQ error"
return|;
case|case
name|MLX5_HEALTH_SYNDR_FFSER_ERR
case|:
return|return
literal|"FFSER error"
return|;
default|default:
return|return
literal|"unrecognized error"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|u16
name|read_be16
parameter_list|(
name|__be16
name|__iomem
modifier|*
name|p
parameter_list|)
block|{
return|return
name|swab16
argument_list|(
name|readl
argument_list|(
operator|(
name|__force
name|u16
name|__iomem
operator|*
operator|)
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|read_be32
parameter_list|(
name|__be32
name|__iomem
modifier|*
name|p
parameter_list|)
block|{
return|return
name|swab32
argument_list|(
name|readl
argument_list|(
operator|(
name|__force
name|u32
name|__iomem
operator|*
operator|)
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_health_info
parameter_list|(
name|struct
name|mlx5_core_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx5_core_health
modifier|*
name|health
init|=
operator|&
name|dev
operator|->
name|priv
operator|.
name|health
decl_stmt|;
name|struct
name|mlx5_health_buffer
name|__iomem
modifier|*
name|h
init|=
name|health
operator|->
name|health
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|h
operator|->
name|assert_var
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"assert_var[%d] 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|read_be32
argument_list|(
name|h
operator|->
name|assert_var
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"assert_exit_ptr 0x%08x\n"
argument_list|,
name|read_be32
argument_list|(
operator|&
name|h
operator|->
name|assert_exit_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"assert_callra 0x%08x\n"
argument_list|,
name|read_be32
argument_list|(
operator|&
name|h
operator|->
name|assert_callra
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"fw_ver 0x%08x\n"
argument_list|,
name|read_be32
argument_list|(
operator|&
name|h
operator|->
name|fw_ver
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"hw_id 0x%08x\n"
argument_list|,
name|read_be32
argument_list|(
operator|&
name|h
operator|->
name|hw_id
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"irisc_index %d\n"
argument_list|,
name|readb
argument_list|(
operator|&
name|h
operator|->
name|irisc_index
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"synd 0x%x: %s\n"
argument_list|,
name|readb
argument_list|(
operator|&
name|h
operator|->
name|synd
argument_list|)
argument_list|,
name|hsynd_str
argument_list|(
name|readb
argument_list|(
operator|&
name|h
operator|->
name|synd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mlx5_core: INFO: "
literal|"ext_sync 0x%04x\n"
argument_list|,
name|read_be16
argument_list|(
operator|&
name|h
operator|->
name|ext_sync
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|poll_health
parameter_list|(
name|unsigned
name|long
name|data
parameter_list|)
block|{
name|struct
name|mlx5_core_dev
modifier|*
name|dev
init|=
operator|(
expr|struct
name|mlx5_core_dev
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mlx5_core_health
modifier|*
name|health
init|=
operator|&
name|dev
operator|->
name|priv
operator|.
name|health
decl_stmt|;
name|int
name|next
decl_stmt|;
name|u32
name|count
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|state
operator|!=
name|MLX5_DEVICE_STATE_UP
condition|)
return|return;
name|count
operator|=
name|ioread32be
argument_list|(
name|health
operator|->
name|health_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|health
operator|->
name|prev
condition|)
operator|++
name|health
operator|->
name|miss_counter
expr_stmt|;
else|else
name|health
operator|->
name|miss_counter
operator|=
literal|0
expr_stmt|;
name|health
operator|->
name|prev
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|health
operator|->
name|miss_counter
operator|==
name|MAX_MISSES
condition|)
block|{
name|mlx5_core_err
argument_list|(
name|dev
argument_list|,
literal|"device's health compromised\n"
argument_list|)
expr_stmt|;
name|print_health_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|health
operator|->
name|list
argument_list|,
operator|&
name|health_list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queue_work
argument_list|(
name|mlx5_core_wq
argument_list|,
operator|&
name|health_work
argument_list|)
condition|)
name|mlx5_core_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to queue health work\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_random_bytes
argument_list|(
operator|&
name|next
argument_list|,
sizeof|sizeof
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|%=
name|HZ
expr_stmt|;
name|next
operator|+=
name|jiffies
operator|+
name|MLX5_HEALTH_POLL_INTERVAL
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|health
operator|->
name|timer
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mlx5_start_health_poll
parameter_list|(
name|struct
name|mlx5_core_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx5_core_health
modifier|*
name|health
init|=
operator|&
name|dev
operator|->
name|priv
operator|.
name|health
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|health
operator|->
name|list
argument_list|)
expr_stmt|;
name|init_timer
argument_list|(
operator|&
name|health
operator|->
name|timer
argument_list|)
expr_stmt|;
name|health
operator|->
name|health
operator|=
operator|&
name|dev
operator|->
name|iseg
operator|->
name|health
expr_stmt|;
name|health
operator|->
name|health_counter
operator|=
operator|&
name|dev
operator|->
name|iseg
operator|->
name|health_counter
expr_stmt|;
name|setup_timer
argument_list|(
operator|&
name|health
operator|->
name|timer
argument_list|,
name|poll_health
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dev
argument_list|)
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|health
operator|->
name|timer
argument_list|,
name|round_jiffies
argument_list|(
name|jiffies
operator|+
name|MLX5_HEALTH_POLL_INTERVAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx5_stop_health_poll
parameter_list|(
name|struct
name|mlx5_core_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx5_core_health
modifier|*
name|health
init|=
operator|&
name|dev
operator|->
name|priv
operator|.
name|health
decl_stmt|;
name|del_timer_sync
argument_list|(
operator|&
name|health
operator|->
name|timer
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|health
operator|->
name|list
argument_list|)
condition|)
name|list_del_init
argument_list|(
operator|&
name|health
operator|->
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|health_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx5_health_cleanup
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|__init
name|mlx5_health_init
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_WORK
argument_list|(
operator|&
name|health_work
argument_list|,
name|health_care
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

