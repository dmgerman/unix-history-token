begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Hacks for working around the PCCard layer problems in NEWBUS kludge  * and OLDCARD.  *  * Now that /sys/pccard/pcic.c can support multiple memory maps per  * slot correctly this is historical code. It is being left in the tree  * for a short while until interactions between OLDCARD and pccardd  * are ironed out. The common and attribute memory is now always  * mapped in. dmlb 17/1/01  *  * The driver assumes that the common memory is always mapped in,  * for the moment we ensure this with the following macro at the  * head of each function and by using functions to access attribute  * memory. Hysterical raisins led to the non-"reflexive" approach.  * Roll on NEWCARD and it can all die...  *  * We call the pccard layer to change and restore the mapping each  * time we use the attribute memory.  *  * These could become marcos around bus_activate_resource, but  * the functions do made hacking them around safer.  */
end_comment

begin_if
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
end_if

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_mapcm(sc)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_CM_REMAPPING */
end_comment

begin_if
if|#
directive|if
name|RAY_NEED_AM_REMAPPING
end_if

begin_function_decl
specifier|static
name|__inline
name|void
name|ray_attr_mapam
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int8_t
name|ray_attr_read_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ray_attr_write_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|ATTR_READ_1
end_undef

begin_define
define|#
directive|define
name|ATTR_READ_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
value|ray_attr_read_1((sc), (off))
end_define

begin_undef
undef|#
directive|undef
name|ATTR_WRITE_1
end_undef

begin_define
define|#
directive|define
name|ATTR_WRITE_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
value|ray_attr_write_1((sc), (off), (val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_AM_REMAPPING */
end_comment

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_AM_REMAPPING
operator|||
name|RAY_NEED_CM_REMAPPING
operator|)
end_if

begin_function_decl
specifier|static
name|__inline
name|void
name|ray_attr_mapcm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_AM_REMAPPING || RAY_NEED_CM_REMAPPING) */
end_comment

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_AM_REMAPPING
operator|||
name|RAY_NEED_CM_REMAPPING
operator|)
end_if

begin_function
specifier|static
name|__inline
name|void
name|ray_attr_mapcm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_activate_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_CM
block|{
name|u_long
name|flags
init|=
literal|0xffff
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"common memory\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_CM */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_AM_REMAPPING || RAY_NEED_CM_REMAPPING) */
end_comment

begin_if
if|#
directive|if
name|RAY_NEED_AM_REMAPPING
end_if

begin_function
specifier|static
name|__inline
name|void
name|ray_attr_mapam
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_activate_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_CM
block|{
name|u_long
name|flags
init|=
literal|0xffff
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"attribute memory\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_CM */
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int8_t
name|ray_attr_read_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_mapam
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
name|u_int8_t
operator|)
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|am_bst
argument_list|,
name|sc
operator|->
name|am_bsh
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ray_attr_mapcm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ray_attr_write_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
block|{
name|ray_attr_mapam
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|am_bst
argument_list|,
name|sc
operator|->
name|am_bsh
argument_list|,
name|offset
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|ray_attr_mapcm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_AM_REMAPPING */
end_comment

end_unit

